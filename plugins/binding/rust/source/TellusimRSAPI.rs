// Copyright (C) 2018-2025, Tellusim Technologies Inc. All rights reserved
// https://tellusim.com/

use std::fmt;
use std::cmp;
use std::ops;
use std::mem;
use std::ptr;
use std::string;
use std::ffi::{ c_void, c_char, CString };

pub use crate::base::*;
pub use crate::math::*;

// Tellusim::Vendor
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum Vendor {
	ARM = 0x13b5,
	AMD = 0x1002,
	Apple = 0x106b,
	Intel = 0x8086,
	Nvidia = 0x10de,
	Qualcomm = 0x5143,
}
impl cmp::PartialEq for Vendor {
	fn eq(&self, flags: &Vendor) -> bool { unsafe { *mem::transmute::<&Vendor, &u32>(self) as u32 == *mem::transmute::<&Vendor, &u32>(flags) as u32 } }
}

// Tellusim::Platform
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum Platform {
	Unknown = 0,
	Fusion,
	D3D12,
	D3D11,
	MTL,
	VK,
	GL,
	GLES,
	WG,
	CU,
	HIP,
	Any,
	NumPlatforms,
}
impl cmp::PartialEq for Platform {
	fn eq(&self, flags: &Platform) -> bool { unsafe { *mem::transmute::<&Platform, &u32>(self) as u32 == *mem::transmute::<&Platform, &u32>(flags) as u32 } }
}

// Tellusim::BindFlags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum BindFlags {
	BindFlagNone = 0,
	BindFlagFixed = 1,
	BindFlagRead = 2,
}
impl cmp::PartialEq for BindFlags {
	fn eq(&self, flags: &BindFlags) -> bool { unsafe { *mem::transmute::<&BindFlags, &u32>(self) as u32 == *mem::transmute::<&BindFlags, &u32>(flags) as u32 } }
}

// Tellusim::TableType
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TableType {
	Texture = 0,
	Storage,
	NumTableTypes,
}
impl cmp::PartialEq for TableType {
	fn eq(&self, flags: &TableType) -> bool { unsafe { *mem::transmute::<&TableType, &u32>(self) as u32 == *mem::transmute::<&TableType, &u32>(flags) as u32 } }
}

// Tellusim::Format
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum Format {
	Unknown = 0,
	Ri8,
	Ru8,
	Ri8n,
	Ru8n,
	RGi8,
	RGu8,
	RGi8n,
	RGu8n,
	RGBi8,
	RGBu8,
	RGBi8n,
	RGBu8n,
	RGBu8ns,
	RGBAi8,
	RGBAu8,
	RGBAi8n,
	RGBAu8n,
	RGBAu8ns,
	BGRAu8n,
	BGRAu8ns,
	Ri16,
	Ru16,
	Ri16n,
	Ru16n,
	Rf16,
	RGi16,
	RGu16,
	RGi16n,
	RGu16n,
	RGf16,
	RGBi16,
	RGBu16,
	RGBi16n,
	RGBu16n,
	RGBf16,
	RGBAi16,
	RGBAu16,
	RGBAi16n,
	RGBAu16n,
	RGBAf16,
	Ri32,
	Ru32,
	Rf32,
	RGi32,
	RGu32,
	RGf32,
	RGBi32,
	RGBu32,
	RGBf32,
	RGBAi32,
	RGBAu32,
	RGBAf32,
	Ri64,
	Ru64,
	Rf64,
	RGi64,
	RGu64,
	RGf64,
	RGBi64,
	RGBu64,
	RGBf64,
	RGBAi64,
	RGBAu64,
	RGBAf64,
	RGBAu4n,
	RGBu5Au1n,
	Ru5Gu6Bu5n,
	RGBu10Au2,
	RGBu10Au2n,
	RGf11Bf10,
	RGBf9Eu5,
	RGBf21,
	BC1RGBu8n,
	BC1RGBu8ns,
	BC1RGBAu8n,
	BC1RGBAu8ns,
	BC2RGBAu8n,
	BC2RGBAu8ns,
	BC3RGBAu8n,
	BC3RGBAu8ns,
	BC4Ri8n,
	BC4Ru8n,
	BC5RGi8n,
	BC5RGu8n,
	BC6RGBf16s,
	BC6RGBf16u,
	BC7RGBAu8n,
	BC7RGBAu8ns,
	EACRi8n,
	EACRu8n,
	EACRGi8n,
	EACRGu8n,
	ETC2RGBu8n,
	ETC2RGBu8ns,
	ETC2RGBAu8n,
	ETC2RGBAu8ns,
	ETC2RGBu8Au1n,
	ETC2RGBu8Au1ns,
	ASTC44RGBAu8n,
	ASTC44RGBAu8ns,
	ASTC44RGBAf16,
	ASTC54RGBAu8n,
	ASTC54RGBAu8ns,
	ASTC54RGBAf16,
	ASTC55RGBAu8n,
	ASTC55RGBAu8ns,
	ASTC55RGBAf16,
	ASTC65RGBAu8n,
	ASTC65RGBAu8ns,
	ASTC65RGBAf16,
	ASTC66RGBAu8n,
	ASTC66RGBAu8ns,
	ASTC66RGBAf16,
	ASTC85RGBAu8n,
	ASTC85RGBAu8ns,
	ASTC85RGBAf16,
	ASTC86RGBAu8n,
	ASTC86RGBAu8ns,
	ASTC86RGBAf16,
	ASTC88RGBAu8n,
	ASTC88RGBAu8ns,
	ASTC88RGBAf16,
	Du16,
	Du16Su8,
	Du24,
	Du24Su8,
	Df32,
	Df32Su8,
	NumFormats,
}
impl cmp::PartialEq for Format {
	fn eq(&self, flags: &Format) -> bool { unsafe { *mem::transmute::<&Format, &u32>(self) as u32 == *mem::transmute::<&Format, &u32>(flags) as u32 } }
}

// Tellusim::App::
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum AppVersion {
	Version = 20250816,
}

// Tellusim::Socket::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SocketType {
	Stream = 0,
	Datagram,
	NumTypes,
}

// Tellusim::Directory::Attributes
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DirectoryAttributes {
	None = 0,
	Read = 1,
	Write = 2,
	Hidden = 4,
	Execute = 8,
	Temporary = 16,
	NumAttributes = 5,
}

// Tellusim::Image::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ImageType {
	Unknown = 0,
	_2D,
	_3D,
	Cube,
	NumTypes,
}

// Tellusim::Image::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ImageFlags {
	None = 0,
	Mipmaps = 1,
	NoClear = 2,
	NoAllocate = 4,
	Fast = 8,
	Best = 16,
	Perceptual = 32,
	Panorama = 64,
	Normalize = 128,
	Gamma = 256,
	SRGB = 512,
	Num = 10,
}
impl ImageFlags {
	pub fn has_flag(self, flag: ImageFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: ImageFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for ImageFlags {
	fn eq(&self, flags: &ImageFlags) -> bool { unsafe { *mem::transmute::<&ImageFlags, &u32>(self) as u32 == *mem::transmute::<&ImageFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for ImageFlags {
	type Output = ImageFlags;
	fn bitor(self, flags: ImageFlags) -> ImageFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for ImageFlags {
	type Output = ImageFlags;
	fn bitand(self, flags: ImageFlags) -> ImageFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for ImageFlags {
	fn bitor_assign(&mut self, flags: ImageFlags) { unsafe { *mem::transmute::<&mut ImageFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for ImageFlags {
	fn bitand_assign(&mut self, flags: ImageFlags) { unsafe { *mem::transmute::<&mut ImageFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for ImageFlags {
	type Output = ImageFlags;
	fn not(self) -> ImageFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Image::Filter
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ImageFilter {
	Unknown = 0,
	Point,
	Linear,
	Cubic,
	Sinc,
	Box,
	Max,
	Min,
	Mip,
	CR,
	NumFilters,
}

// Tellusim::MeshIndices::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshIndicesType {
	Unknown = 0,
	Point,
	Line,
	Triangle,
	Quadrilateral,
	Tetrahedron,
	Material,
	Island,
	Group,
	Joint,
	Edge,
	NumTypes,
}

// Tellusim::MeshAttribute::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshAttributeType {
	Unknown = 0,
	Position,
	Basis,
	Normal,
	Tangent,
	Binormal,
	TexCoord,
	Weights,
	Joints,
	Color,
	Crease,
	Index,
	NumTypes,
}

// Tellusim::MeshMaterial::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshMaterialFlags {
	None = 0,
	Bool = 1,
	Scalarf32 = 2,
	Vector4f = 4,
	Matrix3x2f = 8,
	Color = 16,
	Name = 32,
	Layout = 64,
	Blob = 128,
	Image = 256,
	Texture = 416,
}
impl MeshMaterialFlags {
	pub fn has_flag(self, flag: MeshMaterialFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: MeshMaterialFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for MeshMaterialFlags {
	fn eq(&self, flags: &MeshMaterialFlags) -> bool { unsafe { *mem::transmute::<&MeshMaterialFlags, &u32>(self) as u32 == *mem::transmute::<&MeshMaterialFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for MeshMaterialFlags {
	type Output = MeshMaterialFlags;
	fn bitor(self, flags: MeshMaterialFlags) -> MeshMaterialFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for MeshMaterialFlags {
	type Output = MeshMaterialFlags;
	fn bitand(self, flags: MeshMaterialFlags) -> MeshMaterialFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for MeshMaterialFlags {
	fn bitor_assign(&mut self, flags: MeshMaterialFlags) { unsafe { *mem::transmute::<&mut MeshMaterialFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for MeshMaterialFlags {
	fn bitand_assign(&mut self, flags: MeshMaterialFlags) { unsafe { *mem::transmute::<&mut MeshMaterialFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for MeshMaterialFlags {
	type Output = MeshMaterialFlags;
	fn not(self) -> MeshMaterialFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::MeshAttachment::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshAttachmentType {
	Unknown = 0,
	LightGlobal,
	LightPoint,
	LightSpot,
	LightImage,
	CameraPerspective,
	CameraOrthographic,
	NumTypes,
}

// Tellusim::MeshAttachment::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshAttachmentFlags {
	None = 0,
	Bool = 1,
	Scalarf32 = 2,
	Vector4f = 4,
	Color = 8,
	Name = 16,
}
impl MeshAttachmentFlags {
	pub fn has_flag(self, flag: MeshAttachmentFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: MeshAttachmentFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for MeshAttachmentFlags {
	fn eq(&self, flags: &MeshAttachmentFlags) -> bool { unsafe { *mem::transmute::<&MeshAttachmentFlags, &u32>(self) as u32 == *mem::transmute::<&MeshAttachmentFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for MeshAttachmentFlags {
	type Output = MeshAttachmentFlags;
	fn bitor(self, flags: MeshAttachmentFlags) -> MeshAttachmentFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for MeshAttachmentFlags {
	type Output = MeshAttachmentFlags;
	fn bitand(self, flags: MeshAttachmentFlags) -> MeshAttachmentFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for MeshAttachmentFlags {
	fn bitor_assign(&mut self, flags: MeshAttachmentFlags) { unsafe { *mem::transmute::<&mut MeshAttachmentFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for MeshAttachmentFlags {
	fn bitand_assign(&mut self, flags: MeshAttachmentFlags) { unsafe { *mem::transmute::<&mut MeshAttachmentFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for MeshAttachmentFlags {
	type Output = MeshAttachmentFlags;
	fn not(self) -> MeshAttachmentFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Mesh::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshFlags {
	None = 0,
	Embed = 1,
	_32Bit = 2,
}
impl MeshFlags {
	pub fn has_flag(self, flag: MeshFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: MeshFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for MeshFlags {
	fn eq(&self, flags: &MeshFlags) -> bool { unsafe { *mem::transmute::<&MeshFlags, &u32>(self) as u32 == *mem::transmute::<&MeshFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for MeshFlags {
	type Output = MeshFlags;
	fn bitor(self, flags: MeshFlags) -> MeshFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for MeshFlags {
	type Output = MeshFlags;
	fn bitand(self, flags: MeshFlags) -> MeshFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for MeshFlags {
	fn bitor_assign(&mut self, flags: MeshFlags) { unsafe { *mem::transmute::<&mut MeshFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for MeshFlags {
	fn bitand_assign(&mut self, flags: MeshFlags) { unsafe { *mem::transmute::<&mut MeshFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for MeshFlags {
	type Output = MeshFlags;
	fn not(self) -> MeshFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Mesh::Basis
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshBasis {
	Unknown = 0,
	XUpRight,
	YUpRight,
	ZUpRight,
	XUpLeft,
	YUpLeft,
	ZUpLeft,
	ZUpMaya,
	NumBases,
}

// Tellusim::Mesh::Axis
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshAxis {
	Unknown = 0,
	PX,
	PY,
	PZ,
	NX,
	NY,
	NZ,
	NumAxes,
}

// Tellusim::Json::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum JsonType {
	Unknown = 0,
	Null,
	Bool,
	Number,
	String,
	Object,
	Array,
	NumTypes,
}

// Tellusim::Buffer::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum BufferFlags {
	None = 0,
	Read = 1,
	Write = 2,
	Source = 4,
	Sparse = 8,
	Shared = 16,
	Mapped = 32,
	Extern = 64,
	Interop = 128,
	Dynamic = 256,
	Uniform = 512,
	Storage = 1024,
	Address = 2048,
	Tracing = 4096,
	Scratch = 8192,
	Binding = 16384,
	Indirect = 32768,
	Conditional = 65536,
	Vertex = 131072,
	Index = 262144,
	Texel = 524288,
	Accel = 1048576,
	Num = 21,
}
impl BufferFlags {
	pub fn has_flag(self, flag: BufferFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: BufferFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for BufferFlags {
	fn default() -> BufferFlags { BufferFlags::None }
}
impl cmp::PartialEq for BufferFlags {
	fn eq(&self, flags: &BufferFlags) -> bool { unsafe { *mem::transmute::<&BufferFlags, &u32>(self) as u32 == *mem::transmute::<&BufferFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for BufferFlags {
	type Output = BufferFlags;
	fn bitor(self, flags: BufferFlags) -> BufferFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for BufferFlags {
	type Output = BufferFlags;
	fn bitand(self, flags: BufferFlags) -> BufferFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for BufferFlags {
	fn bitor_assign(&mut self, flags: BufferFlags) { unsafe { *mem::transmute::<&mut BufferFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for BufferFlags {
	fn bitand_assign(&mut self, flags: BufferFlags) { unsafe { *mem::transmute::<&mut BufferFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for BufferFlags {
	type Output = BufferFlags;
	fn not(self) -> BufferFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Query::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum QueryType {
	Unknown = 0,
	Time,
	Clock,
	Samples,
	Samples1,
	Statistics,
	NumTypes,
}

// Tellusim::Fence::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum FenceFlags {
	None = 0,
	Semaphore = 1,
	Signaled = 2,
	Shared = 4,
	Extern = 8,
}
impl FenceFlags {
	pub fn has_flag(self, flag: FenceFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: FenceFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for FenceFlags {
	fn default() -> FenceFlags { FenceFlags::None }
}
impl cmp::PartialEq for FenceFlags {
	fn eq(&self, flags: &FenceFlags) -> bool { unsafe { *mem::transmute::<&FenceFlags, &u32>(self) as u32 == *mem::transmute::<&FenceFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for FenceFlags {
	type Output = FenceFlags;
	fn bitor(self, flags: FenceFlags) -> FenceFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for FenceFlags {
	type Output = FenceFlags;
	fn bitand(self, flags: FenceFlags) -> FenceFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for FenceFlags {
	fn bitor_assign(&mut self, flags: FenceFlags) { unsafe { *mem::transmute::<&mut FenceFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for FenceFlags {
	fn bitand_assign(&mut self, flags: FenceFlags) { unsafe { *mem::transmute::<&mut FenceFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for FenceFlags {
	type Output = FenceFlags;
	fn not(self) -> FenceFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Shader::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ShaderType {
	Unknown = 0,
	Vertex,
	Control,
	Evaluate,
	Geometry,
	Fragment,
	Compute,
	Task,
	Mesh,
	RayGen,
	RayMiss,
	Closest,
	FirstHit,
	Intersection,
	Callable,
	NumTypes,
}

// Tellusim::Shader::Mask
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ShaderMask {
	None = 0,
	Vertex = 2,
	Control = 4,
	Evaluate = 8,
	Geometry = 16,
	Fragment = 32,
	Compute = 64,
	Task = 128,
	Mesh = 256,
	RayGen = 512,
	RayMiss = 1024,
	Closest = 2048,
	FirstHit = 4096,
	Intersection = 8192,
	Callable = 16384,
	VertexFragment = 34,
	Graphics = 62,
	Tracing = 32256,
	All = 32766,
}
impl ShaderMask {
	pub fn has_flag(self, flag: ShaderMask) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: ShaderMask) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for ShaderMask {
	fn eq(&self, flags: &ShaderMask) -> bool { unsafe { *mem::transmute::<&ShaderMask, &u32>(self) as u32 == *mem::transmute::<&ShaderMask, &u32>(flags) as u32 } }
}
impl ops::BitOr for ShaderMask {
	type Output = ShaderMask;
	fn bitor(self, flags: ShaderMask) -> ShaderMask { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for ShaderMask {
	type Output = ShaderMask;
	fn bitand(self, flags: ShaderMask) -> ShaderMask { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for ShaderMask {
	fn bitor_assign(&mut self, flags: ShaderMask) { unsafe { *mem::transmute::<&mut ShaderMask, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for ShaderMask {
	fn bitand_assign(&mut self, flags: ShaderMask) { unsafe { *mem::transmute::<&mut ShaderMask, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for ShaderMask {
	type Output = ShaderMask;
	fn not(self) -> ShaderMask { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::ShaderCompiler::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ShaderCompilerFlags {
	None = 0,
	MSLIndirect = 1,
}
impl ShaderCompilerFlags {
	pub fn has_flag(self, flag: ShaderCompilerFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: ShaderCompilerFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for ShaderCompilerFlags {
	fn eq(&self, flags: &ShaderCompilerFlags) -> bool { unsafe { *mem::transmute::<&ShaderCompilerFlags, &u32>(self) as u32 == *mem::transmute::<&ShaderCompilerFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for ShaderCompilerFlags {
	type Output = ShaderCompilerFlags;
	fn bitor(self, flags: ShaderCompilerFlags) -> ShaderCompilerFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for ShaderCompilerFlags {
	type Output = ShaderCompilerFlags;
	fn bitand(self, flags: ShaderCompilerFlags) -> ShaderCompilerFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for ShaderCompilerFlags {
	fn bitor_assign(&mut self, flags: ShaderCompilerFlags) { unsafe { *mem::transmute::<&mut ShaderCompilerFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for ShaderCompilerFlags {
	fn bitand_assign(&mut self, flags: ShaderCompilerFlags) { unsafe { *mem::transmute::<&mut ShaderCompilerFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for ShaderCompilerFlags {
	type Output = ShaderCompilerFlags;
	fn not(self) -> ShaderCompilerFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Sampler::Filter
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SamplerFilter {
	Point = 0,
	Linear,
	Bipoint,
	Bilinear,
	Trilinear,
	NumFilters,
}

// Tellusim::Sampler::
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SamplerCommon {
	MinAnisotropy = 1,
	MaxAnisotropy = 16,
}

// Tellusim::Sampler::WrapMode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SamplerWrapMode {
	Clamp = 0,
	Repeat,
	Mirror,
	Border,
	NumWrapModes,
}

// Tellusim::Sampler::CompareFunc
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SamplerCompareFunc {
	None = 0,
	Equal,
	Less,
	Greater,
	NotEqual,
	LessEqual,
	GreaterEqual,
	NumCompareFunctions,
}

// Tellusim::Sampler::ReductionMode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SamplerReductionMode {
	Average = 0,
	Min,
	Max,
	NumReductionModes,
}

// Tellusim::Texture::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TextureType {
	Unknown = 0,
	_2D,
	_3D,
	Cube,
	NumTypes,
}

// Tellusim::Texture::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TextureFlags {
	None = 0,
	Read = 1,
	Write = 2,
	Target = 4,
	Buffer = 8,
	Source = 16,
	Sparse = 32,
	Shared = 64,
	Extern = 128,
	Interop = 256,
	Surface = 512,
	Mutable = 1024,
	Mipmaps = 2048,
	Generate = 4096,
	FormatNorm = 8192,
	FormatSRGB = 16384,
	FormatSigned = 32768,
	Multisample2 = 65536,
	Multisample4 = 131072,
	Multisample8 = 262144,
	ClearOne = 524288,
	ClearZero = 1048576,
	ClearNormal = 2097152,
	Multisample = 458752,
	Num = 22,
}
impl TextureFlags {
	pub fn has_flag(self, flag: TextureFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: TextureFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for TextureFlags {
	fn default() -> TextureFlags { TextureFlags::None }
}
impl cmp::PartialEq for TextureFlags {
	fn eq(&self, flags: &TextureFlags) -> bool { unsafe { *mem::transmute::<&TextureFlags, &u32>(self) as u32 == *mem::transmute::<&TextureFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for TextureFlags {
	type Output = TextureFlags;
	fn bitor(self, flags: TextureFlags) -> TextureFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for TextureFlags {
	type Output = TextureFlags;
	fn bitand(self, flags: TextureFlags) -> TextureFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for TextureFlags {
	fn bitor_assign(&mut self, flags: TextureFlags) { unsafe { *mem::transmute::<&mut TextureFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for TextureFlags {
	fn bitand_assign(&mut self, flags: TextureFlags) { unsafe { *mem::transmute::<&mut TextureFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for TextureFlags {
	type Output = TextureFlags;
	fn not(self) -> TextureFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Tracing::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TracingType {
	Unknown = 0,
	Instance,
	Triangle,
	Bound,
	NumTypes,
}

// Tellusim::Tracing::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TracingFlags {
	None = 0,
	Info = 1,
	Update = 2,
	Compact = 4,
	Transparent = 8,
	FastBuild = 16,
	FastTrace = 32,
	Num = 6,
}
impl TracingFlags {
	pub fn has_flag(self, flag: TracingFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: TracingFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for TracingFlags {
	fn default() -> TracingFlags { TracingFlags::None }
}
impl cmp::PartialEq for TracingFlags {
	fn eq(&self, flags: &TracingFlags) -> bool { unsafe { *mem::transmute::<&TracingFlags, &u32>(self) as u32 == *mem::transmute::<&TracingFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for TracingFlags {
	type Output = TracingFlags;
	fn bitor(self, flags: TracingFlags) -> TracingFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for TracingFlags {
	type Output = TracingFlags;
	fn bitand(self, flags: TracingFlags) -> TracingFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for TracingFlags {
	fn bitor_assign(&mut self, flags: TracingFlags) { unsafe { *mem::transmute::<&mut TracingFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for TracingFlags {
	fn bitand_assign(&mut self, flags: TracingFlags) { unsafe { *mem::transmute::<&mut TracingFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for TracingFlags {
	type Output = TracingFlags;
	fn not(self) -> TracingFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Tracing::
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TracingCommon {
	InstanceSize = 64,
}

// Tellusim::Target::Operation
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TargetOperation {
	BeginLoad = 1,
	BeginClear = 2,
	BeginDiscard = 4,
	BeginMask = 7,
	EndStore = 8,
	EndResolve = 16,
	EndDiscard = 32,
	EndMask = 56,
	OpNone = 0,
	OpLoadStore = 9,
	OpClearStore = 10,
	OpClearDiscard = 34,
}

// Tellusim::Pipeline::Primitive
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelinePrimitive {
	Point = 0,
	PointPatch,
	Line,
	LineAdj,
	LineStrip,
	LinePatch,
	Triangle,
	TriangleAdj,
	TriangleStrip,
	TrianglePatch,
	QuadrilateralPatch,
	NumPrimitiveTypes,
}

// Tellusim::Pipeline::Attribute
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineAttribute {
	Position = 0,
	Basis,
	Normal,
	Tangent,
	Binormal,
	TexCoord,
	Weights,
	Joints,
	Color,
	Index,
	NumAttributeTypes,
}

// Tellusim::Pipeline::FillMode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineFillMode {
	Line = 0,
	Solid,
	NumFillModes,
}

// Tellusim::Pipeline::CullMode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineCullMode {
	None = 0,
	Back,
	Front,
	NumCullModes,
}

// Tellusim::Pipeline::FrontMode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineFrontMode {
	CCW = 0,
	CW,
	NumFrontModes,
}

// Tellusim::Pipeline::BlendOp
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineBlendOp {
	Add = 0,
	Sub,
	Min,
	Max,
	NumBlendOperations,
}

// Tellusim::Pipeline::BlendFunc
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineBlendFunc {
	None = 0,
	Zero,
	One,
	SrcColor,
	SrcAlpha,
	Src1Color,
	Src1Alpha,
	DestColor,
	DestAlpha,
	FactorColor,
	FactorAlpha,
	InvSrcColor,
	InvSrcAlpha,
	InvSrc1Color,
	InvSrc1Alpha,
	InvDestColor,
	InvDestAlpha,
	InvFactorColor,
	InvFactorAlpha,
	NumBlendFunctions,
}

// Tellusim::Pipeline::ColorMask
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineColorMask {
	None = 0,
	R = 1,
	G = 2,
	B = 4,
	A = 8,
	Unknown = 16,
	RGB = 7,
	All = 15,
}

// Tellusim::Pipeline::DepthMask
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineDepthMask {
	None = 0,
	Read,
	Write,
	NumDepthMasks,
}

// Tellusim::Pipeline::DepthFunc
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineDepthFunc {
	None = 0,
	Never,
	Always,
	Equal,
	Less,
	Greater,
	NotEqual,
	LessEqual,
	GreaterEqual,
	NumDepthFunctions,
}

// Tellusim::Pipeline::StencilOp
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineStencilOp {
	Keep = 0,
	Invert,
	Replace,
	IncrWrap,
	DecrWrap,
	IncrSat,
	DecrSat,
	NumStencilOperations,
}

// Tellusim::Pipeline::StencilFunc
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PipelineStencilFunc {
	None = 0,
	Never,
	Always,
	Equal,
	Less,
	Greater,
	NotEqual,
	LessEqual,
	GreaterEqual,
	NumStencilFunctions,
}

// Tellusim::Window::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum WindowFlags {
	None = 0,
	Title = 1,
	Close = 2,
	Frame = 4,
	Resize = 8,
	Minimize = 16,
	Maximize = 32,
	Transient = 64,
	Fullscreen = 128,
	Transparent = 256,
	FileDropped = 512,
	Multisample2 = 1024,
	Multisample4 = 2048,
	Multisample8 = 4096,
	VerticalSync = 8192,
	RefreshSync = 16384,
	ColorRGBAu8ns = 32768,
	ColorRGBu10Au2n = 65536,
	ColorRGBAf16 = 131072,
	Multisample = 7168,
	Default = 59,
	Num = 18,
}
impl WindowFlags {
	pub fn has_flag(self, flag: WindowFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: WindowFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for WindowFlags {
	fn default() -> WindowFlags { WindowFlags::Default }
}
impl cmp::PartialEq for WindowFlags {
	fn eq(&self, flags: &WindowFlags) -> bool { unsafe { *mem::transmute::<&WindowFlags, &u32>(self) as u32 == *mem::transmute::<&WindowFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for WindowFlags {
	type Output = WindowFlags;
	fn bitor(self, flags: WindowFlags) -> WindowFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for WindowFlags {
	type Output = WindowFlags;
	fn bitand(self, flags: WindowFlags) -> WindowFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for WindowFlags {
	fn bitor_assign(&mut self, flags: WindowFlags) { unsafe { *mem::transmute::<&mut WindowFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for WindowFlags {
	fn bitand_assign(&mut self, flags: WindowFlags) { unsafe { *mem::transmute::<&mut WindowFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for WindowFlags {
	type Output = WindowFlags;
	fn not(self) -> WindowFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Window::Cursor
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum WindowCursor {
	Arrow = 0,
	Invalid,
	Left,
	Right,
	Bottom,
	Top,
	Width,
	Height,
	Major,
	Minor,
	All,
	NumCursors,
}

// Tellusim::Window::Button
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum WindowButton {
	None = 0,
	Left = 1,
	Left2 = 2,
	Right = 4,
	Right2 = 8,
	Middle = 16,
	Middle2 = 32,
	Back = 64,
	Back2 = 128,
	Forward = 256,
	Forward2 = 512,
	NumButtons = 10,
}
impl WindowButton {
	pub fn has_flag(self, flag: WindowButton) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: WindowButton) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for WindowButton {
	fn eq(&self, flags: &WindowButton) -> bool { unsafe { *mem::transmute::<&WindowButton, &u32>(self) as u32 == *mem::transmute::<&WindowButton, &u32>(flags) as u32 } }
}
impl ops::BitOr for WindowButton {
	type Output = WindowButton;
	fn bitor(self, flags: WindowButton) -> WindowButton { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for WindowButton {
	type Output = WindowButton;
	fn bitand(self, flags: WindowButton) -> WindowButton { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for WindowButton {
	fn bitor_assign(&mut self, flags: WindowButton) { unsafe { *mem::transmute::<&mut WindowButton, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for WindowButton {
	fn bitand_assign(&mut self, flags: WindowButton) { unsafe { *mem::transmute::<&mut WindowButton, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for WindowButton {
	type Output = WindowButton;
	fn not(self) -> WindowButton { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Window::Axis
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum WindowAxis {
	X = 0,
	Y,
	Z,
	W,
	NumAxes,
}

// Tellusim::Window::
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum WindowCommon {
	NumTouches = 16,
}

// Tellusim::Window::Key
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum WindowKey {
	None = 128,
	Esc,
	Tab,
	Backspace,
	Delete,
	Insert,
	Return,
	Pause,
	Prior,
	Next,
	End,
	Home,
	Up,
	Down,
	Left,
	Right,
	Num,
	Caps,
	Scroll,
	Shift,
	Ctrl,
	Alt,
	Win,
	Cmd,
	Menu,
	F1,
	F2,
	F3,
	F4,
	F5,
	F6,
	F7,
	F8,
	F9,
	F10,
	F11,
	F12,
	NumKeys,
}

// Tellusim::CanvasElement::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum CanvasElementType {
	Unknown = 0,
	Text,
	Mesh,
	Rect,
	Triangle,
	Ellipse,
	Shape,
	Strip,
	NumTypes,
}

// Tellusim::CanvasElement::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum CanvasElementMode {
	Solid = 0,
	Texture,
	TextureFetch,
	TextureClamp,
	TextureCubic,
	TextureCubic3x3,
	TextureCubic5x5,
	TextureRed,
	TextureGreen,
	TextureBlue,
	TextureAlpha,
	TextureYOG,
	Gradient,
	NumModes,
}

// Tellusim::CanvasElement::Align
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum CanvasElementAlign {
	None = 0,
	Left = 1,
	Right = 2,
	Bottom = 4,
	Top = 8,
	CenterX = 16,
	CenterY = 32,
	LeftBottom = 5,
	LeftTop = 9,
	RightBottom = 6,
	RightTop = 10,
	Center = 48,
}

// Tellusim::CanvasElement::Stack
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum CanvasElementStack {
	None = 0,
	Push = 1,
	Pop = 2,
	Set = 4,
	Mul = 8,
	Get = 16,
}

// Tellusim::Control::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlType {
	Unknown = 0,
	Root,
	Text,
	Rect,
	Grid,
	Group,
	Panel,
	Dialog,
	Window,
	Check,
	Combo,
	Button,
	Slider,
	Scroll,
	Split,
	Area,
	Tree,
	Edit,
	NumTypes,
}

// Tellusim::Control::State
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlState {
	Unknown = 0,
	Normal,
	Focused,
	Pressed,
	Disabled,
	NumStates,
}

// Tellusim::Control::Mesh
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlMesh {
	Check = 0,
	Button,
	SliderLine,
	HScrollLine,
	VScrollLine,
	SliderHandle,
	HScrollHandle,
	VScrollHandle,
	Background,
	Selection,
	Border,
	Frame,
	NumMeshes,
}

// Tellusim::Control::Align
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlAlign {
	None = 0,
	Left = 1,
	Right = 2,
	Bottom = 4,
	Top = 8,
	CenterX = 16,
	CenterY = 32,
	ExpandX = 64,
	ExpandY = 128,
	Overlap = 256,
	Spacer = 512,
	Aspect = 1024,
	LeftBottom = 5,
	LeftTop = 9,
	RightBottom = 6,
	RightTop = 10,
	Center = 48,
	Expand = 192,
	NumAligns = 11,
}

// Tellusim::Control::Button
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlButtons {
	None = 0,
	Left = 1,
	Left2 = 2,
	Right = 4,
	Right2 = 8,
	Middle = 16,
	Middle2 = 32,
	NumButtons = 6,
}
impl ControlButtons {
	pub fn has_flag(self, flag: ControlButtons) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: ControlButtons) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for ControlButtons {
	fn eq(&self, flags: &ControlButtons) -> bool { unsafe { *mem::transmute::<&ControlButtons, &u32>(self) as u32 == *mem::transmute::<&ControlButtons, &u32>(flags) as u32 } }
}
impl ops::BitOr for ControlButtons {
	type Output = ControlButtons;
	fn bitor(self, flags: ControlButtons) -> ControlButtons { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for ControlButtons {
	type Output = ControlButtons;
	fn bitand(self, flags: ControlButtons) -> ControlButtons { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for ControlButtons {
	fn bitor_assign(&mut self, flags: ControlButtons) { unsafe { *mem::transmute::<&mut ControlButtons, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for ControlButtons {
	fn bitand_assign(&mut self, flags: ControlButtons) { unsafe { *mem::transmute::<&mut ControlButtons, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for ControlButtons {
	type Output = ControlButtons;
	fn not(self) -> ControlButtons { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Control::Axis
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlAxis {
	Unknown = 0,
	X,
	Y,
	Z,
	W,
	NumAxes,
}

// Tellusim::Control::Key
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlKey {
	None = 128,
	Tab,
	Backspace,
	Delete,
	Insert,
	Return,
	Prior,
	Next,
	End,
	Home,
	Up,
	Down,
	Left,
	Right,
	Shift,
	Ctrl,
	Alt,
	Cmd,
	NumKeys,
}

// Tellusim::ControlEdit::EditMode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControlEditEditMode {
	Text,
	Password,
	Number,
	Signed,
	Unsigned,
	Hexadecimal,
}

// Tellusim::DialogMessage::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogMessageFlags {
	None = 0,
	Yes = 1,
	No = 2,
	Ok = 4,
	Cancel = 8,
	Close = 16,
	Message = 32,
	Warning = 64,
	Question = 128,
	Error = 256,
	Mouse = 512,
	YesNo = 3,
	OkCancel = 12,
	Num = 10,
}
impl DialogMessageFlags {
	pub fn has_flag(self, flag: DialogMessageFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogMessageFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogMessageFlags {
	fn default() -> DialogMessageFlags { DialogMessageFlags::Ok }
}
impl cmp::PartialEq for DialogMessageFlags {
	fn eq(&self, flags: &DialogMessageFlags) -> bool { unsafe { *mem::transmute::<&DialogMessageFlags, &u32>(self) as u32 == *mem::transmute::<&DialogMessageFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogMessageFlags {
	type Output = DialogMessageFlags;
	fn bitor(self, flags: DialogMessageFlags) -> DialogMessageFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogMessageFlags {
	type Output = DialogMessageFlags;
	fn bitand(self, flags: DialogMessageFlags) -> DialogMessageFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogMessageFlags {
	fn bitor_assign(&mut self, flags: DialogMessageFlags) { unsafe { *mem::transmute::<&mut DialogMessageFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogMessageFlags {
	fn bitand_assign(&mut self, flags: DialogMessageFlags) { unsafe { *mem::transmute::<&mut DialogMessageFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogMessageFlags {
	type Output = DialogMessageFlags;
	fn not(self) -> DialogMessageFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogMessage::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogMessageResult {
	Close = 0,
	Cancel,
	Ok,
	No,
	Yes,
	NumResults,
}

// Tellusim::DialogFileOpen::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogFileOpenFlags {
	None = 0,
	Hidden = 1,
	Mouse = 2,
}
impl DialogFileOpenFlags {
	pub fn has_flag(self, flag: DialogFileOpenFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogFileOpenFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogFileOpenFlags {
	fn default() -> DialogFileOpenFlags { DialogFileOpenFlags::None }
}
impl cmp::PartialEq for DialogFileOpenFlags {
	fn eq(&self, flags: &DialogFileOpenFlags) -> bool { unsafe { *mem::transmute::<&DialogFileOpenFlags, &u32>(self) as u32 == *mem::transmute::<&DialogFileOpenFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogFileOpenFlags {
	type Output = DialogFileOpenFlags;
	fn bitor(self, flags: DialogFileOpenFlags) -> DialogFileOpenFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogFileOpenFlags {
	type Output = DialogFileOpenFlags;
	fn bitand(self, flags: DialogFileOpenFlags) -> DialogFileOpenFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogFileOpenFlags {
	fn bitor_assign(&mut self, flags: DialogFileOpenFlags) { unsafe { *mem::transmute::<&mut DialogFileOpenFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogFileOpenFlags {
	fn bitand_assign(&mut self, flags: DialogFileOpenFlags) { unsafe { *mem::transmute::<&mut DialogFileOpenFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogFileOpenFlags {
	type Output = DialogFileOpenFlags;
	fn not(self) -> DialogFileOpenFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogFileOpen::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogFileOpenResult {
	Cancel = 0,
	Ok,
	NumResults,
}

// Tellusim::DialogFileSave::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogFileSaveFlags {
	None = 0,
	Hidden = 1,
	Overwrite = 2,
	Mouse = 4,
	Num = 3,
}
impl DialogFileSaveFlags {
	pub fn has_flag(self, flag: DialogFileSaveFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogFileSaveFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogFileSaveFlags {
	fn default() -> DialogFileSaveFlags { DialogFileSaveFlags::Overwrite }
}
impl cmp::PartialEq for DialogFileSaveFlags {
	fn eq(&self, flags: &DialogFileSaveFlags) -> bool { unsafe { *mem::transmute::<&DialogFileSaveFlags, &u32>(self) as u32 == *mem::transmute::<&DialogFileSaveFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogFileSaveFlags {
	type Output = DialogFileSaveFlags;
	fn bitor(self, flags: DialogFileSaveFlags) -> DialogFileSaveFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogFileSaveFlags {
	type Output = DialogFileSaveFlags;
	fn bitand(self, flags: DialogFileSaveFlags) -> DialogFileSaveFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogFileSaveFlags {
	fn bitor_assign(&mut self, flags: DialogFileSaveFlags) { unsafe { *mem::transmute::<&mut DialogFileSaveFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogFileSaveFlags {
	fn bitand_assign(&mut self, flags: DialogFileSaveFlags) { unsafe { *mem::transmute::<&mut DialogFileSaveFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogFileSaveFlags {
	type Output = DialogFileSaveFlags;
	fn not(self) -> DialogFileSaveFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogFileSave::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogFileSaveResult {
	Cancel = 0,
	Ok,
	NumResults,
}

// Tellusim::DialogDirectory::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogDirectoryFlags {
	None = 0,
	Mouse = 1,
}
impl DialogDirectoryFlags {
	pub fn has_flag(self, flag: DialogDirectoryFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogDirectoryFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogDirectoryFlags {
	fn default() -> DialogDirectoryFlags { DialogDirectoryFlags::None }
}
impl cmp::PartialEq for DialogDirectoryFlags {
	fn eq(&self, flags: &DialogDirectoryFlags) -> bool { unsafe { *mem::transmute::<&DialogDirectoryFlags, &u32>(self) as u32 == *mem::transmute::<&DialogDirectoryFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogDirectoryFlags {
	type Output = DialogDirectoryFlags;
	fn bitor(self, flags: DialogDirectoryFlags) -> DialogDirectoryFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogDirectoryFlags {
	type Output = DialogDirectoryFlags;
	fn bitand(self, flags: DialogDirectoryFlags) -> DialogDirectoryFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogDirectoryFlags {
	fn bitor_assign(&mut self, flags: DialogDirectoryFlags) { unsafe { *mem::transmute::<&mut DialogDirectoryFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogDirectoryFlags {
	fn bitand_assign(&mut self, flags: DialogDirectoryFlags) { unsafe { *mem::transmute::<&mut DialogDirectoryFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogDirectoryFlags {
	type Output = DialogDirectoryFlags;
	fn not(self) -> DialogDirectoryFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogDirectory::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogDirectoryResult {
	Cancel = 0,
	Ok,
	NumResults,
}

// Tellusim::DialogProgress::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogProgressFlags {
	None = 0,
	Mouse = 1,
}
impl DialogProgressFlags {
	pub fn has_flag(self, flag: DialogProgressFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogProgressFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogProgressFlags {
	fn default() -> DialogProgressFlags { DialogProgressFlags::None }
}
impl cmp::PartialEq for DialogProgressFlags {
	fn eq(&self, flags: &DialogProgressFlags) -> bool { unsafe { *mem::transmute::<&DialogProgressFlags, &u32>(self) as u32 == *mem::transmute::<&DialogProgressFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogProgressFlags {
	type Output = DialogProgressFlags;
	fn bitor(self, flags: DialogProgressFlags) -> DialogProgressFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogProgressFlags {
	type Output = DialogProgressFlags;
	fn bitand(self, flags: DialogProgressFlags) -> DialogProgressFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogProgressFlags {
	fn bitor_assign(&mut self, flags: DialogProgressFlags) { unsafe { *mem::transmute::<&mut DialogProgressFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogProgressFlags {
	fn bitand_assign(&mut self, flags: DialogProgressFlags) { unsafe { *mem::transmute::<&mut DialogProgressFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogProgressFlags {
	type Output = DialogProgressFlags;
	fn not(self) -> DialogProgressFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogProgress::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogProgressResult {
	Cancel = 0,
	Ok,
	NumResults,
}

// Tellusim::DialogColor::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogColorFlags {
	None = 0,
	Alpha = 1,
	Mouse = 2,
}
impl DialogColorFlags {
	pub fn has_flag(self, flag: DialogColorFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogColorFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogColorFlags {
	fn default() -> DialogColorFlags { DialogColorFlags::None }
}
impl cmp::PartialEq for DialogColorFlags {
	fn eq(&self, flags: &DialogColorFlags) -> bool { unsafe { *mem::transmute::<&DialogColorFlags, &u32>(self) as u32 == *mem::transmute::<&DialogColorFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogColorFlags {
	type Output = DialogColorFlags;
	fn bitor(self, flags: DialogColorFlags) -> DialogColorFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogColorFlags {
	type Output = DialogColorFlags;
	fn bitand(self, flags: DialogColorFlags) -> DialogColorFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogColorFlags {
	fn bitor_assign(&mut self, flags: DialogColorFlags) { unsafe { *mem::transmute::<&mut DialogColorFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogColorFlags {
	fn bitand_assign(&mut self, flags: DialogColorFlags) { unsafe { *mem::transmute::<&mut DialogColorFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogColorFlags {
	type Output = DialogColorFlags;
	fn not(self) -> DialogColorFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogColor::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogColorResult {
	Cancel = 0,
	Ok,
	NumResults,
}

// Tellusim::DialogMenu::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogMenuFlags {
	None = 0,
	Mouse = 1,
}
impl DialogMenuFlags {
	pub fn has_flag(self, flag: DialogMenuFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DialogMenuFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for DialogMenuFlags {
	fn default() -> DialogMenuFlags { DialogMenuFlags::None }
}
impl cmp::PartialEq for DialogMenuFlags {
	fn eq(&self, flags: &DialogMenuFlags) -> bool { unsafe { *mem::transmute::<&DialogMenuFlags, &u32>(self) as u32 == *mem::transmute::<&DialogMenuFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DialogMenuFlags {
	type Output = DialogMenuFlags;
	fn bitor(self, flags: DialogMenuFlags) -> DialogMenuFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DialogMenuFlags {
	type Output = DialogMenuFlags;
	fn bitand(self, flags: DialogMenuFlags) -> DialogMenuFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DialogMenuFlags {
	fn bitor_assign(&mut self, flags: DialogMenuFlags) { unsafe { *mem::transmute::<&mut DialogMenuFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DialogMenuFlags {
	fn bitand_assign(&mut self, flags: DialogMenuFlags) { unsafe { *mem::transmute::<&mut DialogMenuFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DialogMenuFlags {
	type Output = DialogMenuFlags;
	fn not(self) -> DialogMenuFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DialogMenu::Result
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DialogMenuResult {
	Cancel = 0,
	Click,
	NumResults,
}

// Tellusim::CubeFilter::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum CubeFilterMode {
	Cube = 0,
	Panorama,
	NumModes,
}

// Tellusim::CubeFilter::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum CubeFilterFlags {
	Cube = 1,
	Panorama = 2,
	All = 3,
}
impl CubeFilterFlags {
	pub fn has_flag(self, flag: CubeFilterFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: CubeFilterFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for CubeFilterFlags {
	fn eq(&self, flags: &CubeFilterFlags) -> bool { unsafe { *mem::transmute::<&CubeFilterFlags, &u32>(self) as u32 == *mem::transmute::<&CubeFilterFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for CubeFilterFlags {
	type Output = CubeFilterFlags;
	fn bitor(self, flags: CubeFilterFlags) -> CubeFilterFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for CubeFilterFlags {
	type Output = CubeFilterFlags;
	fn bitand(self, flags: CubeFilterFlags) -> CubeFilterFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for CubeFilterFlags {
	fn bitor_assign(&mut self, flags: CubeFilterFlags) { unsafe { *mem::transmute::<&mut CubeFilterFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for CubeFilterFlags {
	fn bitand_assign(&mut self, flags: CubeFilterFlags) { unsafe { *mem::transmute::<&mut CubeFilterFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for CubeFilterFlags {
	type Output = CubeFilterFlags;
	fn not(self) -> CubeFilterFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::DecoderJPEG::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DecoderJPEGMode {
	R = 0,
	RG,
	RGBA,
	YUV444,
	YUV422H,
	YUV422V,
	YUV420,
	NumModes,
}

// Tellusim::DecoderJPEG::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum DecoderJPEGFlags {
	None = 0,
	R = 1,
	RG = 2,
	RGBA = 4,
	YUV444 = 8,
	YUV422H = 16,
	YUV422V = 32,
	YUV420 = 64,
	All = 127,
}
impl DecoderJPEGFlags {
	pub fn has_flag(self, flag: DecoderJPEGFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: DecoderJPEGFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for DecoderJPEGFlags {
	fn eq(&self, flags: &DecoderJPEGFlags) -> bool { unsafe { *mem::transmute::<&DecoderJPEGFlags, &u32>(self) as u32 == *mem::transmute::<&DecoderJPEGFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for DecoderJPEGFlags {
	type Output = DecoderJPEGFlags;
	fn bitor(self, flags: DecoderJPEGFlags) -> DecoderJPEGFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for DecoderJPEGFlags {
	type Output = DecoderJPEGFlags;
	fn bitand(self, flags: DecoderJPEGFlags) -> DecoderJPEGFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for DecoderJPEGFlags {
	fn bitor_assign(&mut self, flags: DecoderJPEGFlags) { unsafe { *mem::transmute::<&mut DecoderJPEGFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for DecoderJPEGFlags {
	fn bitand_assign(&mut self, flags: DecoderJPEGFlags) { unsafe { *mem::transmute::<&mut DecoderJPEGFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for DecoderJPEGFlags {
	type Output = DecoderJPEGFlags;
	fn not(self) -> DecoderJPEGFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::EncoderBC15::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum EncoderBC15Mode {
	BC1RGBu8n = 0,
	BC2RGBAu8n,
	BC3RGBAu8n,
	BC4Ru8n,
	BC5RGu8n,
	NumModes,
}

// Tellusim::EncoderBC15::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum EncoderBC15Flags {
	None = 0,
	BC1RGBu8n = 1,
	BC2RGBAu8n = 2,
	BC3RGBAu8n = 4,
	BC4Ru8n = 8,
	BC5RGu8n = 16,
	Cube = 64,
	BC13 = 7,
	BC45 = 24,
	All = 31,
}
impl EncoderBC15Flags {
	pub fn has_flag(self, flag: EncoderBC15Flags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: EncoderBC15Flags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for EncoderBC15Flags {
	fn eq(&self, flags: &EncoderBC15Flags) -> bool { unsafe { *mem::transmute::<&EncoderBC15Flags, &u32>(self) as u32 == *mem::transmute::<&EncoderBC15Flags, &u32>(flags) as u32 } }
}
impl ops::BitOr for EncoderBC15Flags {
	type Output = EncoderBC15Flags;
	fn bitor(self, flags: EncoderBC15Flags) -> EncoderBC15Flags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for EncoderBC15Flags {
	type Output = EncoderBC15Flags;
	fn bitand(self, flags: EncoderBC15Flags) -> EncoderBC15Flags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for EncoderBC15Flags {
	fn bitor_assign(&mut self, flags: EncoderBC15Flags) { unsafe { *mem::transmute::<&mut EncoderBC15Flags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for EncoderBC15Flags {
	fn bitand_assign(&mut self, flags: EncoderBC15Flags) { unsafe { *mem::transmute::<&mut EncoderBC15Flags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for EncoderBC15Flags {
	type Output = EncoderBC15Flags;
	fn not(self) -> EncoderBC15Flags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::EncoderBC67::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum EncoderBC67Mode {
	BC6RGBf16s = 0,
	BC6RGBf16u,
	BC7RGBAu8n,
	NumModes,
}

// Tellusim::EncoderBC67::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum EncoderBC67Flags {
	None = 0,
	BC6RGBf16s = 1,
	BC6RGBf16u = 2,
	BC7RGBAu8n = 4,
	Cube = 16,
	All = 7,
}
impl EncoderBC67Flags {
	pub fn has_flag(self, flag: EncoderBC67Flags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: EncoderBC67Flags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for EncoderBC67Flags {
	fn eq(&self, flags: &EncoderBC67Flags) -> bool { unsafe { *mem::transmute::<&EncoderBC67Flags, &u32>(self) as u32 == *mem::transmute::<&EncoderBC67Flags, &u32>(flags) as u32 } }
}
impl ops::BitOr for EncoderBC67Flags {
	type Output = EncoderBC67Flags;
	fn bitor(self, flags: EncoderBC67Flags) -> EncoderBC67Flags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for EncoderBC67Flags {
	type Output = EncoderBC67Flags;
	fn bitand(self, flags: EncoderBC67Flags) -> EncoderBC67Flags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for EncoderBC67Flags {
	fn bitor_assign(&mut self, flags: EncoderBC67Flags) { unsafe { *mem::transmute::<&mut EncoderBC67Flags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for EncoderBC67Flags {
	fn bitand_assign(&mut self, flags: EncoderBC67Flags) { unsafe { *mem::transmute::<&mut EncoderBC67Flags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for EncoderBC67Flags {
	type Output = EncoderBC67Flags;
	fn not(self) -> EncoderBC67Flags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::EncoderASTC::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum EncoderASTCMode {
	ASTC44RGBAu8n = 0,
	ASTC54RGBAu8n,
	ASTC55RGBAu8n,
	NumModes,
}

// Tellusim::EncoderASTC::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum EncoderASTCFlags {
	None = 0,
	ASTC44RGBAu8n = 1,
	ASTC54RGBAu8n = 2,
	ASTC55RGBAu8n = 4,
	Cube = 16,
	All = 7,
}
impl EncoderASTCFlags {
	pub fn has_flag(self, flag: EncoderASTCFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: EncoderASTCFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for EncoderASTCFlags {
	fn eq(&self, flags: &EncoderASTCFlags) -> bool { unsafe { *mem::transmute::<&EncoderASTCFlags, &u32>(self) as u32 == *mem::transmute::<&EncoderASTCFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for EncoderASTCFlags {
	type Output = EncoderASTCFlags;
	fn bitor(self, flags: EncoderASTCFlags) -> EncoderASTCFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for EncoderASTCFlags {
	type Output = EncoderASTCFlags;
	fn bitand(self, flags: EncoderASTCFlags) -> EncoderASTCFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for EncoderASTCFlags {
	fn bitor_assign(&mut self, flags: EncoderASTCFlags) { unsafe { *mem::transmute::<&mut EncoderASTCFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for EncoderASTCFlags {
	fn bitand_assign(&mut self, flags: EncoderASTCFlags) { unsafe { *mem::transmute::<&mut EncoderASTCFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for EncoderASTCFlags {
	type Output = EncoderASTCFlags;
	fn not(self) -> EncoderASTCFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::MeshModel::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum MeshModelFlags {
	None = 0,
	Direct = 1,
	Verbose = 2,
	Optimize = 4,
	Materials = 8,
	Indices10 = 16,
	Indices16 = 32,
	Indices32 = 64,
	Meshlet64x84 = 128,
	Meshlet64x126 = 256,
	Meshlet96x169 = 512,
	Meshlet128x212 = 1024,
	BufferWrite = 2048,
	BufferSource = 4096,
	BufferStorage = 8192,
	BufferTracing = 16384,
	BufferAddress = 32768,
	BufferTexel = 65536,
	Meshlets = 1920,
	Default = 10,
	Num = 17,
}
impl MeshModelFlags {
	pub fn has_flag(self, flag: MeshModelFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: MeshModelFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for MeshModelFlags {
	fn default() -> MeshModelFlags { MeshModelFlags::Default }
}
impl cmp::PartialEq for MeshModelFlags {
	fn eq(&self, flags: &MeshModelFlags) -> bool { unsafe { *mem::transmute::<&MeshModelFlags, &u32>(self) as u32 == *mem::transmute::<&MeshModelFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for MeshModelFlags {
	type Output = MeshModelFlags;
	fn bitor(self, flags: MeshModelFlags) -> MeshModelFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for MeshModelFlags {
	type Output = MeshModelFlags;
	fn bitand(self, flags: MeshModelFlags) -> MeshModelFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for MeshModelFlags {
	fn bitor_assign(&mut self, flags: MeshModelFlags) { unsafe { *mem::transmute::<&mut MeshModelFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for MeshModelFlags {
	fn bitand_assign(&mut self, flags: MeshModelFlags) { unsafe { *mem::transmute::<&mut MeshModelFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for MeshModelFlags {
	type Output = MeshModelFlags;
	fn not(self) -> MeshModelFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::SeparableFilter::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SeparableFilterMode {
	Horizontal = 0,
	Vertical,
	NumModes,
}

// Tellusim::SeparableFilter::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SeparableFilterFlags {
	None = 0,
	Repeat = 1,
	Zero = 2,
}
impl SeparableFilterFlags {
	pub fn has_flag(self, flag: SeparableFilterFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: SeparableFilterFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl Default for SeparableFilterFlags {
	fn default() -> SeparableFilterFlags { SeparableFilterFlags::None }
}
impl cmp::PartialEq for SeparableFilterFlags {
	fn eq(&self, flags: &SeparableFilterFlags) -> bool { unsafe { *mem::transmute::<&SeparableFilterFlags, &u32>(self) as u32 == *mem::transmute::<&SeparableFilterFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for SeparableFilterFlags {
	type Output = SeparableFilterFlags;
	fn bitor(self, flags: SeparableFilterFlags) -> SeparableFilterFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for SeparableFilterFlags {
	type Output = SeparableFilterFlags;
	fn bitand(self, flags: SeparableFilterFlags) -> SeparableFilterFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for SeparableFilterFlags {
	fn bitor_assign(&mut self, flags: SeparableFilterFlags) { unsafe { *mem::transmute::<&mut SeparableFilterFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for SeparableFilterFlags {
	fn bitand_assign(&mut self, flags: SeparableFilterFlags) { unsafe { *mem::transmute::<&mut SeparableFilterFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for SeparableFilterFlags {
	type Output = SeparableFilterFlags;
	fn not(self) -> SeparableFilterFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::PrefixScan::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PrefixScanMode {
	Single = 0,
	Multiple,
	NumModes,
}

// Tellusim::PrefixScan::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum PrefixScanFlags {
	None = 0,
	Single = 1,
	Multiple = 2,
	Indirect = 4,
	Repeat = 8,
	All = 7,
}
impl PrefixScanFlags {
	pub fn has_flag(self, flag: PrefixScanFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: PrefixScanFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for PrefixScanFlags {
	fn eq(&self, flags: &PrefixScanFlags) -> bool { unsafe { *mem::transmute::<&PrefixScanFlags, &u32>(self) as u32 == *mem::transmute::<&PrefixScanFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for PrefixScanFlags {
	type Output = PrefixScanFlags;
	fn bitor(self, flags: PrefixScanFlags) -> PrefixScanFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for PrefixScanFlags {
	type Output = PrefixScanFlags;
	fn bitand(self, flags: PrefixScanFlags) -> PrefixScanFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for PrefixScanFlags {
	fn bitor_assign(&mut self, flags: PrefixScanFlags) { unsafe { *mem::transmute::<&mut PrefixScanFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for PrefixScanFlags {
	fn bitand_assign(&mut self, flags: PrefixScanFlags) { unsafe { *mem::transmute::<&mut PrefixScanFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for PrefixScanFlags {
	type Output = PrefixScanFlags;
	fn not(self) -> PrefixScanFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::RadixSort::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum RadixSortMode {
	Single = 0,
	Multiple,
	NumModes,
}

// Tellusim::RadixSort::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum RadixSortFlags {
	None = 0,
	Single = 1,
	Multiple = 2,
	Indirect = 4,
	Order = 8,
	Tracing = 16,
	Scratch = 32,
	All = 15,
}
impl RadixSortFlags {
	pub fn has_flag(self, flag: RadixSortFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: RadixSortFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for RadixSortFlags {
	fn eq(&self, flags: &RadixSortFlags) -> bool { unsafe { *mem::transmute::<&RadixSortFlags, &u32>(self) as u32 == *mem::transmute::<&RadixSortFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for RadixSortFlags {
	type Output = RadixSortFlags;
	fn bitor(self, flags: RadixSortFlags) -> RadixSortFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for RadixSortFlags {
	type Output = RadixSortFlags;
	fn bitand(self, flags: RadixSortFlags) -> RadixSortFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for RadixSortFlags {
	fn bitor_assign(&mut self, flags: RadixSortFlags) { unsafe { *mem::transmute::<&mut RadixSortFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for RadixSortFlags {
	fn bitand_assign(&mut self, flags: RadixSortFlags) { unsafe { *mem::transmute::<&mut RadixSortFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for RadixSortFlags {
	type Output = RadixSortFlags;
	fn not(self) -> RadixSortFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::BitonicSort::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum BitonicSortMode {
	Single = 0,
	Multiple,
	NumModes,
}

// Tellusim::BitonicSort::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum BitonicSortFlags {
	None = 0,
	Single = 1,
	Multiple = 2,
	Indirect = 4,
	Order = 8,
	All = 15,
}
impl BitonicSortFlags {
	pub fn has_flag(self, flag: BitonicSortFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: BitonicSortFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for BitonicSortFlags {
	fn eq(&self, flags: &BitonicSortFlags) -> bool { unsafe { *mem::transmute::<&BitonicSortFlags, &u32>(self) as u32 == *mem::transmute::<&BitonicSortFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for BitonicSortFlags {
	type Output = BitonicSortFlags;
	fn bitor(self, flags: BitonicSortFlags) -> BitonicSortFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for BitonicSortFlags {
	type Output = BitonicSortFlags;
	fn bitand(self, flags: BitonicSortFlags) -> BitonicSortFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for BitonicSortFlags {
	fn bitor_assign(&mut self, flags: BitonicSortFlags) { unsafe { *mem::transmute::<&mut BitonicSortFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for BitonicSortFlags {
	fn bitand_assign(&mut self, flags: BitonicSortFlags) { unsafe { *mem::transmute::<&mut BitonicSortFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for BitonicSortFlags {
	type Output = BitonicSortFlags;
	fn not(self) -> BitonicSortFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::SpatialTree::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SpatialTreeMode {
	Single = 0,
	Multiple,
	NumModes,
}

// Tellusim::SpatialTree::Hash
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SpatialTreeHash {
	XYZ10,
	XYZ9,
	XYZ8,
	XY15,
	XY14,
	XY12,
	XY10,
}

// Tellusim::SpatialTree::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum SpatialTreeFlags {
	None = 0,
	Single = 1,
	Multiple = 2,
	Update = 4,
	Optimize = 8,
	Tracing = 16,
	Scratch = 32,
	Atomic = 64,
	LeafNodef16 = 128,
	SpatialData = 256,
	SingleUpdate = 5,
	MultipleUpdate = 6,
	SingleOptimize = 9,
	MultipleOptimize = 10,
	All = 3,
	AllOptimize = 11,
}
impl SpatialTreeFlags {
	pub fn has_flag(self, flag: SpatialTreeFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: SpatialTreeFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for SpatialTreeFlags {
	fn eq(&self, flags: &SpatialTreeFlags) -> bool { unsafe { *mem::transmute::<&SpatialTreeFlags, &u32>(self) as u32 == *mem::transmute::<&SpatialTreeFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for SpatialTreeFlags {
	type Output = SpatialTreeFlags;
	fn bitor(self, flags: SpatialTreeFlags) -> SpatialTreeFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for SpatialTreeFlags {
	type Output = SpatialTreeFlags;
	fn bitand(self, flags: SpatialTreeFlags) -> SpatialTreeFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for SpatialTreeFlags {
	fn bitor_assign(&mut self, flags: SpatialTreeFlags) { unsafe { *mem::transmute::<&mut SpatialTreeFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for SpatialTreeFlags {
	fn bitand_assign(&mut self, flags: SpatialTreeFlags) { unsafe { *mem::transmute::<&mut SpatialTreeFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for SpatialTreeFlags {
	type Output = SpatialTreeFlags;
	fn not(self) -> SpatialTreeFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::FourierTransform::Mode
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum FourierTransformMode {
	Rf16i = 0,
	Rf32i,
	RGf16i,
	RGf32i,
	RGBf16c,
	RGBf21c,
	RGBf16p,
	RGBf32p,
	NumModes,
}

// Tellusim::FourierTransform::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum FourierTransformFlags {
	None = 0,
	Rf16i = 1,
	Rf32i = 2,
	RGf16i = 4,
	RGf32i = 8,
	RGBf16c = 16,
	RGBf21c = 32,
	RGBf16p = 64,
	RGBf32p = 128,
	Npot = 256,
	Interleaved = 15,
	Complex = 48,
	Planar = 192,
	All = 511,
}
impl FourierTransformFlags {
	pub fn has_flag(self, flag: FourierTransformFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: FourierTransformFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for FourierTransformFlags {
	fn eq(&self, flags: &FourierTransformFlags) -> bool { unsafe { *mem::transmute::<&FourierTransformFlags, &u32>(self) as u32 == *mem::transmute::<&FourierTransformFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for FourierTransformFlags {
	type Output = FourierTransformFlags;
	fn bitor(self, flags: FourierTransformFlags) -> FourierTransformFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for FourierTransformFlags {
	type Output = FourierTransformFlags;
	fn bitand(self, flags: FourierTransformFlags) -> FourierTransformFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for FourierTransformFlags {
	fn bitor_assign(&mut self, flags: FourierTransformFlags) { unsafe { *mem::transmute::<&mut FourierTransformFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for FourierTransformFlags {
	fn bitand_assign(&mut self, flags: FourierTransformFlags) { unsafe { *mem::transmute::<&mut FourierTransformFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for FourierTransformFlags {
	type Output = FourierTransformFlags;
	fn not(self) -> FourierTransformFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::FourierTransform::Operation
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum FourierTransformOperation {
	ForwardCtoC = 0,
	BackwardCtoC,
	ForwardRtoC,
	BackwardCtoR,
	NumOperations,
}

// Tellusim::TensorGraph::Operation
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TensorGraphOperation {
	Clear = 0,
	Range,
	Copy,
	Cat,
	Transpose,
	MatMul,
	Mul,
	Mad,
	Div,
	Add,
	Conv,
	DeConv,
	BatchNorm,
	BatchMad,
	SoftMin,
	SoftMax,
	MaxPool,
	AvgPool,
	GELU,
	ReLU,
	SiLU,
	Sigm,
	Tanh,
	Sin,
	Cos,
	Exp,
	NumOperations,
}

// Tellusim::TensorGraph::Flags
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TensorGraphFlags {
	None = 0,
	SizeQuery = 1,
	FormatRf32 = 2,
	FormatRf16 = 4,
	Transpose = 8,
	WrapClamp = 16,
	WrapRepeat = 32,
	ReadScale = 64,
	ReadBias = 128,
	Convert = 256,
	Kernel = 512,
	GELU = 1024,
	ReLU = 2048,
	SiLU = 4096,
	Sigm = 8192,
	Tanh = 16384,
	Sin = 32768,
	Cos = 65536,
	Exp = 131072,
	Format = 6,
	Wrap = 48,
	Read = 192,
	Unit = 7168,
	Math = 253952,
	All = 262142,
}
impl TensorGraphFlags {
	pub fn has_flag(self, flag: TensorGraphFlags) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: TensorGraphFlags) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for TensorGraphFlags {
	fn eq(&self, flags: &TensorGraphFlags) -> bool { unsafe { *mem::transmute::<&TensorGraphFlags, &u32>(self) as u32 == *mem::transmute::<&TensorGraphFlags, &u32>(flags) as u32 } }
}
impl ops::BitOr for TensorGraphFlags {
	type Output = TensorGraphFlags;
	fn bitor(self, flags: TensorGraphFlags) -> TensorGraphFlags { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for TensorGraphFlags {
	type Output = TensorGraphFlags;
	fn bitand(self, flags: TensorGraphFlags) -> TensorGraphFlags { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for TensorGraphFlags {
	fn bitor_assign(&mut self, flags: TensorGraphFlags) { unsafe { *mem::transmute::<&mut TensorGraphFlags, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for TensorGraphFlags {
	fn bitand_assign(&mut self, flags: TensorGraphFlags) { unsafe { *mem::transmute::<&mut TensorGraphFlags, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for TensorGraphFlags {
	type Output = TensorGraphFlags;
	fn not(self) -> TensorGraphFlags { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::TensorGraph::Masks
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum TensorGraphMasks {
	MaskNone = 0,
	MaskClear = 1,
	MaskRange = 2,
	MaskCopy = 4,
	MaskCat = 8,
	MaskTranspose = 16,
	MaskMatMul = 32,
	MaskMul = 64,
	MaskMad = 128,
	MaskDiv = 256,
	MaskAdd = 512,
	MaskConv = 1024,
	MaskDeConv = 2048,
	MaskBatchNorm = 4096,
	MaskBatchMad = 8192,
	MaskSoftMin = 16384,
	MaskSoftMax = 32768,
	MaskMaxPool = 65536,
	MaskAvgPool = 131072,
	MaskGELU = 262144,
	MaskReLU = 524288,
	MaskSiLU = 1048576,
	MaskSigm = 2097152,
	MaskTanh = 4194304,
	MaskSin = 8388608,
	MaskCos = 16777216,
	MaskExp = 33554432,
	All = 67108863,
}

// Tellusim::Controller::Type
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControllerType {
	Unknown = 0,
	Joystick,
	GamePad,
	Wheel,
	NumTypes,
}

// Tellusim::Controller::Stick
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControllerStick {
	Left = 0,
	Right,
	NumSticks,
}

// Tellusim::Controller::Axis
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControllerAxis {
	X = 0,
	Y,
	Z,
	RX,
	RY,
	RZ,
	NumAxes = 16,
}

// Tellusim::Controller::Button
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControllerButton {
	Left = 0,
	Right,
	Down,
	Up,
	Home,
	ShoulderLeft,
	ShoulderRight,
	TriggerLeft,
	TriggerRight,
	StickLeft,
	StickRight,
	A,
	B,
	X,
	Y,
	View,
	Menu,
	NumButtons = 32,
}
impl ControllerButton {
	pub fn has_flag(self, flag: ControllerButton) -> bool { if (self as u32) & (flag as u32) != 0 { true } else { false } }
	pub fn has_flags(self, flags: ControllerButton) -> bool { let flags = flags as u32; if (self as u32) & flags != flags { true } else { false } }
}
impl cmp::PartialEq for ControllerButton {
	fn eq(&self, flags: &ControllerButton) -> bool { unsafe { *mem::transmute::<&ControllerButton, &u32>(self) as u32 == *mem::transmute::<&ControllerButton, &u32>(flags) as u32 } }
}
impl ops::BitOr for ControllerButton {
	type Output = ControllerButton;
	fn bitor(self, flags: ControllerButton) -> ControllerButton { unsafe { mem::transmute(self as u32 | flags as u32) } }
}
impl ops::BitAnd for ControllerButton {
	type Output = ControllerButton;
	fn bitand(self, flags: ControllerButton) -> ControllerButton { unsafe { mem::transmute(self as u32 & flags as u32) } }
}
impl ops::BitOrAssign for ControllerButton {
	fn bitor_assign(&mut self, flags: ControllerButton) { unsafe { *mem::transmute::<&mut ControllerButton, &mut u32>(self) |= flags as u32 } }
}
impl ops::BitAndAssign for ControllerButton {
	fn bitand_assign(&mut self, flags: ControllerButton) { unsafe { *mem::transmute::<&mut ControllerButton, &mut u32>(self) &= flags as u32 } }
}
impl ops::Not for ControllerButton {
	type Output = ControllerButton;
	fn not(self) -> ControllerButton { unsafe { mem::transmute(!(self as u32)) } }
}

// Tellusim::Controller::Motor
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum ControllerMotor {
	Low = 0,
	High,
	NumMotors,
}

// Tellusim::Log::Level
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum LogLevel {
	Fatal = 0,
	Error,
	Warning,
	Message,
	Verbose,
	Unknown,
	NumLevels,
}
impl cmp::PartialEq for LogLevel {
	fn eq(&self, flags: &LogLevel) -> bool { unsafe { *mem::transmute::<&LogLevel, &u32>(self) as u32 == *mem::transmute::<&LogLevel, &u32>(flags) as u32 } }
}

// Tellusim::Time::
#[repr(u32)]
#[derive(Copy, Clone)]
pub enum Time {
	Seconds = 1000000,
	MSeconds = 1000,
	USeconds = 1,
}
impl cmp::PartialEq for Time {
	fn eq(&self, flags: &Time) -> bool { unsafe { *mem::transmute::<&Time, &u32>(self) as u32 == *mem::transmute::<&Time, &u32>(flags) as u32 } }
}

// Tellusim::String
pub struct String {
	this: *mut c_void,
	owner: bool,
}
impl String {
	pub fn null() -> String { String { this: ptr::null_mut(), owner: false } }
	pub fn new() -> String { unsafe { String { this: tsString_new(), owner: true } } }
	pub fn new_with_size(size: u32) -> String { unsafe { String { this: tsString_new_uc(size, 0), owner: true } } }
	pub fn new_with_size_c(size: u32, c: c_char) -> String { unsafe { String { this: tsString_new_uc(size, c), owner: true } } }
	pub fn new_with_str(str: &str) -> String {
		let str_ = CString::new(str).unwrap();
		unsafe { String { this: tsString_new_su(str_.as_ptr(), MAXU32), owner: true } }
	}
	pub fn new_with_str_length(str: &str, length: u32) -> String {
		let str_ = CString::new(str).unwrap();
		unsafe { String { this: tsString_new_su(str_.as_ptr(), length), owner: true } }
	}
	pub fn new_with_strw(str: *const u16) -> String { unsafe { String { this: tsString_new_wu(str, MAXU32), owner: true } } }
	pub fn new_with_strw_length(str: *const u16, length: u32) -> String { unsafe { String { this: tsString_new_wu(str, length), owner: true } } }
	pub fn new_with_stru32(str: *const u32) -> String { unsafe { String { this: tsString_new_upu(str, MAXU32), owner: true } } }
	pub fn new_with_stru32_length(str: *const u32, length: u32) -> String { unsafe { String { this: tsString_new_upu(str, length), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> String { String { this: ptr, owner: true } }
	pub fn copy_ptr(&self) -> String { String { this: self.this, owner: false } }
	pub fn reserve(&mut self, size: u32) { unsafe { tsString_reserve(self.this, size, 0) } }
	pub fn reserve_with_discard(&mut self, size: u32, discard: bool) { unsafe { tsString_reserve(self.this, size, if discard {1} else {0}) } }
	pub fn resize(&mut self, size: u32) { unsafe { tsString_resize(self.this, size, 0, 0) } }
	pub fn resize_with_c(&mut self, size: u32, c: c_char) { unsafe { tsString_resize(self.this, size, c, 0) } }
	pub fn resize_with_c_reserve(&mut self, size: u32, c: c_char, reserve: bool) { unsafe { tsString_resize(self.this, size, c, if reserve {1} else {0}) } }
	pub fn release(&mut self) { unsafe { tsString_release(self.this) } }
	pub fn clear(&mut self) { unsafe { tsString_clear(self.this) } }
	pub fn copy(&mut self, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_copy_su(self.this, str_.as_ptr(), MAXU32) }
	}
	pub fn copy_with_length(&mut self, str: &str, length: u32) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_copy_su(self.this, str_.as_ptr(), length) }
	}
	pub fn copy_with_strw(&mut self, str: *const u16) { unsafe { tsString_copy_wu(self.this, str, MAXU32) } }
	pub fn copy_with_strw_length(&mut self, str: *const u16, length: u32) { unsafe { tsString_copy_wu(self.this, str, length) } }
	pub fn copy_with_stru32(&mut self, str: *const u32) { unsafe { tsString_copy_upu(self.this, str, MAXU32) } }
	pub fn copy_with_stru32_length(&mut self, str: *const u32, length: u32) { unsafe { tsString_copy_upu(self.this, str, length) } }
	pub fn copy_with_string(&mut self, string: &String) { unsafe { tsString_copy_cSu(self.this, string.this, MAXU32) } }
	pub fn copy_with_string_length(&mut self, string: &String, length: u32) { unsafe { tsString_copy_cSu(self.this, string.this, length) } }
	pub fn append(&mut self, c: c_char) { unsafe { tsString_append_c(self.this, c) } }
	pub fn append_with_str(&mut self, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_append_su(self.this, str_.as_ptr(), MAXU32) }
	}
	pub fn append_with_str_length(&mut self, str: &str, length: u32) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_append_su(self.this, str_.as_ptr(), length) }
	}
	pub fn append_with_string(&mut self, string: &String) { unsafe { tsString_append_cSu(self.this, string.this, MAXU32) } }
	pub fn append_with_string_length(&mut self, string: &String, length: u32) { unsafe { tsString_append_cSu(self.this, string.this, length) } }
	pub fn insert(&mut self, pos: u32, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_insert_usu(self.this, pos, str_.as_ptr(), MAXU32) }
	}
	pub fn insert_with_length(&mut self, pos: u32, str: &str, length: u32) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_insert_usu(self.this, pos, str_.as_ptr(), length) }
	}
	pub fn insert_with_string(&mut self, pos: u32, string: &String) { unsafe { tsString_insert_ucSu(self.this, pos, string.this, MAXU32) } }
	pub fn insert_with_string_length(&mut self, pos: u32, string: &String, length: u32) { unsafe { tsString_insert_ucSu(self.this, pos, string.this, length) } }
	pub fn remove_back(&mut self) { unsafe { tsString_removeBack(self.this, 1) } }
	pub fn remove_back_with_length(&mut self, length: u32) { unsafe { tsString_removeBack(self.this, length) } }
	pub fn remove(&mut self, pos: u32) { unsafe { tsString_remove(self.this, pos, 1) } }
	pub fn remove_with_length(&mut self, pos: u32, length: u32) { unsafe { tsString_remove(self.this, pos, length) } }
	pub fn reverse(&mut self) { unsafe { tsString_reverse(self.this, 0, MAXU32) } }
	pub fn reverse_with_pos(&mut self, pos: u32) { unsafe { tsString_reverse(self.this, pos, MAXU32) } }
	pub fn reverse_with_pos_length(&mut self, pos: u32, length: u32) { unsafe { tsString_reverse(self.this, pos, length) } }
	pub fn size(&self) -> u32 { unsafe { tsString_size(self.this) } }
	pub fn empty(&self) -> bool { unsafe { tsString_empty(self.this) != 0 } }
	pub fn get_mut(&mut self) -> *mut c_char { unsafe { tsString_get(self.this) } }
	pub fn get(&self) -> string::String { unsafe { get_cstring(tsString_get_c(self.this)) } }
	pub fn get_mut_with_index(&mut self, index: u32) -> c_char { unsafe { tsString_get_u(self.this, index) } }
	pub fn get_with_index(&self, index: u32) -> c_char { unsafe { tsString_get_cu(self.this, index) } }
	pub fn find(&self, c: c_char) -> u32 { unsafe { tsString_find_ccu(self.this, c, 0) } }
	pub fn find_with_pos(&self, c: c_char, pos: u32) -> u32 { unsafe { tsString_find_ccu(self.this, c, pos) } }
	pub fn rfind(&self, c: c_char) -> u32 { unsafe { tsString_rfind_ccu(self.this, c, MAXU32) } }
	pub fn rfind_with_pos(&self, c: c_char, pos: u32) -> u32 { unsafe { tsString_rfind_ccu(self.this, c, pos) } }
	pub fn count(&self, c: c_char) -> u32 { unsafe { tsString_count_ccu(self.this, c, 0) } }
	pub fn count_with_pos(&self, c: c_char, pos: u32) -> u32 { unsafe { tsString_count_ccu(self.this, c, pos) } }
	pub fn find_with_str(&self, str: &str) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_find_csu(self.this, str_.as_ptr(), 0) }
	}
	pub fn find_with_str_pos(&self, str: &str, pos: u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_find_csu(self.this, str_.as_ptr(), pos) }
	}
	pub fn rfind_with_str(&self, str: &str) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_rfind_csu(self.this, str_.as_ptr(), MAXU32) }
	}
	pub fn rfind_with_str_pos(&self, str: &str, pos: u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_rfind_csu(self.this, str_.as_ptr(), pos) }
	}
	pub fn count_with_str(&self, str: &str) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_count_csu(self.this, str_.as_ptr(), 0) }
	}
	pub fn count_with_str_pos(&self, str: &str, pos: u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_count_csu(self.this, str_.as_ptr(), pos) }
	}
	pub fn begins(&self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_begins(self.this, str_.as_ptr(), MAXU32, 0) != 0 }
	}
	pub fn begins_with_length(&self, str: &str, length: u32) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_begins(self.this, str_.as_ptr(), length, 0) != 0 }
	}
	pub fn begins_with_length_pos(&self, str: &str, length: u32, pos: u32) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_begins(self.this, str_.as_ptr(), length, pos) != 0 }
	}
	pub fn contains(&self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_contains(self.this, str_.as_ptr(), MAXU32, 0) != 0 }
	}
	pub fn contains_with_length(&self, str: &str, length: u32) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_contains(self.this, str_.as_ptr(), length, 0) != 0 }
	}
	pub fn contains_with_length_pos(&self, str: &str, length: u32, pos: u32) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_contains(self.this, str_.as_ptr(), length, pos) != 0 }
	}
	pub fn match_(&self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_match(self.this, str_.as_ptr(), MAXU32, 0) != 0 }
	}
	pub fn match_with_length(&self, str: &str, length: u32) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_match(self.this, str_.as_ptr(), length, 0) != 0 }
	}
	pub fn match_with_length_pos(&self, str: &str, length: u32, pos: u32) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_match(self.this, str_.as_ptr(), length, pos) != 0 }
	}
	pub fn compare(&self, str: &str) -> i32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_compare(self.this, str_.as_ptr(), 0) }
	}
	pub fn compare_with_pos(&self, str: &str, pos: u32) -> i32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_compare(self.this, str_.as_ptr(), pos) }
	}
	pub fn distance(&self, str: &str) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_distance(self.this, str_.as_ptr(), 0, 0) }
	}
	pub fn distance_with_scan(&self, str: &str, scan: bool) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_distance(self.this, str_.as_ptr(), if scan {1} else {0}, 0) }
	}
	pub fn distance_with_scan_pos(&self, str: &str, scan: bool, pos: u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_distance(self.this, str_.as_ptr(), if scan {1} else {0}, pos) }
	}
	pub fn begin(&self) -> string::String { unsafe { get_cstring(tsString_begin(self.this)) } }
	pub fn end(&self) -> string::String { unsafe { get_cstring(tsString_end(self.this)) } }
	pub fn front(&self) -> c_char { unsafe { tsString_front_cu(self.this, 0) } }
	pub fn front_with_index(&self, index: u32) -> c_char { unsafe { tsString_front_cu(self.this, index) } }
	pub fn back(&self) -> c_char { unsafe { tsString_back_cu(self.this, 0) } }
	pub fn back_with_index(&self, index: u32) -> c_char { unsafe { tsString_back_cu(self.this, index) } }
	pub fn front_mut(&mut self) -> c_char { unsafe { tsString_front_u(self.this, 0) } }
	pub fn front_mut_with_index(&mut self, index: u32) -> c_char { unsafe { tsString_front_u(self.this, index) } }
	pub fn back_mut(&mut self) -> c_char { unsafe { tsString_back_u(self.this, 0) } }
	pub fn back_mut_with_index(&mut self, index: u32) -> c_char { unsafe { tsString_back_u(self.this, index) } }
	pub fn substring(&self, pos: u32) -> string::String { unsafe { get_string(tsString_substring(self.this, pos, MAXU32)) } }
	pub fn substring_with_length(&self, pos: u32, length: u32) -> string::String { unsafe { get_string(tsString_substring(self.this, pos, length)) } }
	pub fn replace(&self, before: c_char, after: c_char) -> string::String { unsafe { get_string(tsString_replace_cccu(self.this, before, after, 0)) } }
	pub fn replace_with_pos(&self, before: c_char, after: c_char, pos: u32) -> string::String { unsafe { get_string(tsString_replace_cccu(self.this, before, after, pos)) } }
	pub fn replace_with_before(&self, before: &str, after: &str) -> string::String {
		let before_ = CString::new(before).unwrap();
		let after_ = CString::new(after).unwrap();
		unsafe { get_string(tsString_replace_cssu(self.this, before_.as_ptr(), after_.as_ptr(), 0)) }
	}
	pub fn replace_with_before_pos(&self, before: &str, after: &str, pos: u32) -> string::String {
		let before_ = CString::new(before).unwrap();
		let after_ = CString::new(after).unwrap();
		unsafe { get_string(tsString_replace_cssu(self.this, before_.as_ptr(), after_.as_ptr(), pos)) }
	}
	pub fn replace_with_befores(&self, before: &String, after: &String) -> string::String { unsafe { get_string(tsString_replace_ccScSu(self.this, before.this, after.this, 0)) } }
	pub fn replace_with_befores_pos(&self, before: &String, after: &String, pos: u32) -> string::String { unsafe { get_string(tsString_replace_ccScSu(self.this, before.this, after.this, pos)) } }
	pub fn extension_with_extension(&self, extension: &str) -> string::String {
		let extension_ = CString::new(extension).unwrap();
		unsafe { get_string(tsString_extension_cs(self.this, extension_.as_ptr())) }
	}
	pub fn extension(&self) -> string::String { unsafe { get_string(tsString_extension_c(self.this)) } }
	pub fn pathname(&self) -> string::String { unsafe { get_string(tsString_pathname(self.this)) } }
	pub fn basename(&self) -> string::String { unsafe { get_string(tsString_basename(self.this)) } }
	pub fn dirname(&self) -> string::String { unsafe { get_string(tsString_dirname(self.this)) } }
	pub fn relname(path: &str, str: &str) -> string::String {
		let path_ = CString::new(path).unwrap();
		let str_ = CString::new(str).unwrap();
		unsafe { get_string(tsString_relname_ss(path_.as_ptr(), str_.as_ptr())) }
	}
	pub fn relname_with_path(path: &String, str: &String) -> string::String { unsafe { get_string(tsString_relname_cScS(path.this, str.this)) } }
	pub fn capitalize(&self) -> string::String { unsafe { get_string(tsString_capitalize(self.this, ptr::null_mut(), ptr::null_mut())) } }
	pub fn capitalize_with_delimiters(&self, delimiters: &str) -> string::String {
		let delimiters_ = CString::new(delimiters).unwrap();
		unsafe { get_string(tsString_capitalize(self.this, delimiters_.as_ptr(), ptr::null_mut())) }
	}
	pub fn capitalize_with_delimiters_spaces(&self, delimiters: &str, spaces: &str) -> string::String {
		let delimiters_ = CString::new(delimiters).unwrap();
		let spaces_ = CString::new(spaces).unwrap();
		unsafe { get_string(tsString_capitalize(self.this, delimiters_.as_ptr(), spaces_.as_ptr())) }
	}
	pub fn lower(&self) -> string::String { unsafe { get_string(tsString_lower(self.this)) } }
	pub fn upper(&self) -> string::String { unsafe { get_string(tsString_upper(self.this)) } }
	pub fn to_utf32(str: &str, code: &mut u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toUtf32_sur(str_.as_ptr(), code) }
	}
	pub fn to_utf16(&self, d: *mut u16, length: u32) -> u32 { unsafe { tsString_toUtf16(self.this, d, length) } }
	pub fn to_utf32_with_d(&self, d: *mut u32, length: u32) -> u32 { unsafe { tsString_toUtf32_curu(self.this, d, length) } }
	pub fn from_utf32(d: &mut String, code: u32) -> u32 { unsafe { tsString_fromUtf32_Su(d.this, code) } }
	pub fn from_utf16(str: *const u16) -> string::String { unsafe { get_string(tsString_fromUtf16(str, MAXU32)) } }
	pub fn from_utf16_with_length(str: *const u16, length: u32) -> string::String { unsafe { get_string(tsString_fromUtf16(str, length)) } }
	pub fn from_utf32_with_str(str: *const u32) -> string::String { unsafe { get_string(tsString_fromUtf32_upu(str, MAXU32)) } }
	pub fn from_utf32_with_str_length(str: *const u32, length: u32) -> string::String { unsafe { get_string(tsString_fromUtf32_upu(str, length)) } }
	pub fn from_url(str: &str) -> string::String {
		let str_ = CString::new(str).unwrap();
		unsafe { get_string(tsString_fromUrl_su(str_.as_ptr(), MAXU32)) }
	}
	pub fn from_url_with_length(str: &str, length: u32) -> string::String {
		let str_ = CString::new(str).unwrap();
		unsafe { get_string(tsString_fromUrl_su(str_.as_ptr(), length)) }
	}
	pub fn from_url_with_string(string: &String) -> string::String { unsafe { get_string(tsString_fromUrl_cSu(string.this, MAXU32)) } }
	pub fn from_url_with_string_length(string: &String, length: u32) -> string::String { unsafe { get_string(tsString_fromUrl_cSu(string.this, length)) } }
	pub fn fromi32_with_d(d: &mut String, value: i32) -> string::String { unsafe { get_string(tsString_fromi32_Siu(d.this, value, 10)) } }
	pub fn fromi32_with_d_radix(d: &mut String, value: i32, radix: u32) -> string::String { unsafe { get_string(tsString_fromi32_Siu(d.this, value, radix)) } }
	pub fn fromi64_with_d(d: &mut String, value: i64) -> string::String { unsafe { get_string(tsString_fromi64_Si64u(d.this, value, 10)) } }
	pub fn fromi64_with_d_radix(d: &mut String, value: i64, radix: u32) -> string::String { unsafe { get_string(tsString_fromi64_Si64u(d.this, value, radix)) } }
	pub fn fromu32_with_d(d: &mut String, value: u32) -> string::String { unsafe { get_string(tsString_fromu32_Suu(d.this, value, 10)) } }
	pub fn fromu32_with_d_radix(d: &mut String, value: u32, radix: u32) -> string::String { unsafe { get_string(tsString_fromu32_Suu(d.this, value, radix)) } }
	pub fn fromu64_with_d(d: &mut String, value: u64) -> string::String { unsafe { get_string(tsString_fromu64_Su64u(d.this, value, 10)) } }
	pub fn fromu64_with_d_radix(d: &mut String, value: u64, radix: u32) -> string::String { unsafe { get_string(tsString_fromu64_Su64u(d.this, value, radix)) } }
	pub fn fromf32_with_d(d: &mut String, value: f32) -> string::String { unsafe { get_string(tsString_fromf32_Sfubb(d.this, value, 6, 0, 0)) } }
	pub fn fromf32_with_d_digits(d: &mut String, value: f32, digits: u32) -> string::String { unsafe { get_string(tsString_fromf32_Sfubb(d.this, value, digits, 0, 0)) } }
	pub fn fromf32_with_d_digits_compact(d: &mut String, value: f32, digits: u32, compact: bool) -> string::String { unsafe { get_string(tsString_fromf32_Sfubb(d.this, value, digits, if compact {1} else {0}, 0)) } }
	pub fn fromf32_with_d_digits_compact_exponent(d: &mut String, value: f32, digits: u32, compact: bool, exponent: bool) -> string::String { unsafe { get_string(tsString_fromf32_Sfubb(d.this, value, digits, if compact {1} else {0}, if exponent {1} else {0})) } }
	pub fn fromf64_with_d(d: &mut String, value: f64) -> string::String { unsafe { get_string(tsString_fromf64_Sf64ubb(d.this, value, 12, 0, 0)) } }
	pub fn fromf64_with_d_digits(d: &mut String, value: f64, digits: u32) -> string::String { unsafe { get_string(tsString_fromf64_Sf64ubb(d.this, value, digits, 0, 0)) } }
	pub fn fromf64_with_d_digits_compact(d: &mut String, value: f64, digits: u32, compact: bool) -> string::String { unsafe { get_string(tsString_fromf64_Sf64ubb(d.this, value, digits, if compact {1} else {0}, 0)) } }
	pub fn fromf64_with_d_digits_compact_exponent(d: &mut String, value: f64, digits: u32, compact: bool, exponent: bool) -> string::String { unsafe { get_string(tsString_fromf64_Sf64ubb(d.this, value, digits, if compact {1} else {0}, if exponent {1} else {0})) } }
	pub fn fromi32(value: i32) -> string::String { unsafe { get_string(tsString_fromi32_iu(value, 10)) } }
	pub fn fromi32_with_radix(value: i32, radix: u32) -> string::String { unsafe { get_string(tsString_fromi32_iu(value, radix)) } }
	pub fn fromi64(value: i64) -> string::String { unsafe { get_string(tsString_fromi64_i64u(value, 10)) } }
	pub fn fromi64_with_radix(value: i64, radix: u32) -> string::String { unsafe { get_string(tsString_fromi64_i64u(value, radix)) } }
	pub fn fromu32(value: u32) -> string::String { unsafe { get_string(tsString_fromu32_uu(value, 10)) } }
	pub fn fromu32_with_radix(value: u32, radix: u32) -> string::String { unsafe { get_string(tsString_fromu32_uu(value, radix)) } }
	pub fn fromu64(value: u64) -> string::String { unsafe { get_string(tsString_fromu64_u64u(value, 10)) } }
	pub fn fromu64_with_radix(value: u64, radix: u32) -> string::String { unsafe { get_string(tsString_fromu64_u64u(value, radix)) } }
	pub fn fromf32(value: f32) -> string::String { unsafe { get_string(tsString_fromf32_fubb(value, 6, 0, 0)) } }
	pub fn fromf32_with_digits(value: f32, digits: u32) -> string::String { unsafe { get_string(tsString_fromf32_fubb(value, digits, 0, 0)) } }
	pub fn fromf32_with_digits_compact(value: f32, digits: u32, compact: bool) -> string::String { unsafe { get_string(tsString_fromf32_fubb(value, digits, if compact {1} else {0}, 0)) } }
	pub fn fromf32_with_digits_compact_exponent(value: f32, digits: u32, compact: bool, exponent: bool) -> string::String { unsafe { get_string(tsString_fromf32_fubb(value, digits, if compact {1} else {0}, if exponent {1} else {0})) } }
	pub fn fromf64(value: f64) -> string::String { unsafe { get_string(tsString_fromf64_f64ubb(value, 12, 0, 0)) } }
	pub fn fromf64_with_digits(value: f64, digits: u32) -> string::String { unsafe { get_string(tsString_fromf64_f64ubb(value, digits, 0, 0)) } }
	pub fn fromf64_with_digits_compact(value: f64, digits: u32, compact: bool) -> string::String { unsafe { get_string(tsString_fromf64_f64ubb(value, digits, if compact {1} else {0}, 0)) } }
	pub fn fromf64_with_digits_compact_exponent(value: f64, digits: u32, compact: bool, exponent: bool) -> string::String { unsafe { get_string(tsString_fromf64_f64ubb(value, digits, if compact {1} else {0}, if exponent {1} else {0})) } }
	pub fn toi32_with_str_radix(str: &str, radix: u32) -> i32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toi32_suur(str_.as_ptr(), radix, ptr::null_mut()) }
	}
	pub fn toi32_with_str_radix_size(str: &str, radix: u32, size: *mut u32) -> i32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toi32_suur(str_.as_ptr(), radix, size) }
	}
	pub fn toi64_with_str_radix(str: &str, radix: u32) -> i64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toi64_suur(str_.as_ptr(), radix, ptr::null_mut()) }
	}
	pub fn toi64_with_str_radix_size(str: &str, radix: u32, size: *mut u32) -> i64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toi64_suur(str_.as_ptr(), radix, size) }
	}
	pub fn tou32_with_str_radix(str: &str, radix: u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tou32_suur(str_.as_ptr(), radix, ptr::null_mut()) }
	}
	pub fn tou32_with_str_radix_size(str: &str, radix: u32, size: *mut u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tou32_suur(str_.as_ptr(), radix, size) }
	}
	pub fn tou64_with_str_radix(str: &str, radix: u32) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tou64_suur(str_.as_ptr(), radix, ptr::null_mut()) }
	}
	pub fn tou64_with_str_radix_size(str: &str, radix: u32, size: *mut u32) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tou64_suur(str_.as_ptr(), radix, size) }
	}
	pub fn toi32_with_str(str: &str, size: *mut u32) -> i32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toi32_sur(str_.as_ptr(), size) }
	}
	pub fn toi64_with_str(str: &str, size: *mut u32) -> i64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toi64_sur(str_.as_ptr(), size) }
	}
	pub fn tou32_with_str(str: &str, size: *mut u32) -> u32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tou32_sur(str_.as_ptr(), size) }
	}
	pub fn tou64_with_str(str: &str, size: *mut u32) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tou64_sur(str_.as_ptr(), size) }
	}
	pub fn tof32_with_str(str: &str) -> f32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tof32_sur(str_.as_ptr(), ptr::null_mut()) }
	}
	pub fn tof32_with_str_size(str: &str, size: *mut u32) -> f32 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tof32_sur(str_.as_ptr(), size) }
	}
	pub fn tof64_with_str(str: &str) -> f64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tof64_sur(str_.as_ptr(), ptr::null_mut()) }
	}
	pub fn tof64_with_str_size(str: &str, size: *mut u32) -> f64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_tof64_sur(str_.as_ptr(), size) }
	}
	pub fn toi32_with_radix(&self, radix: u32) -> i32 { unsafe { tsString_toi32_cuu(self.this, radix, 0) } }
	pub fn toi32_with_radix_pos(&self, radix: u32, pos: u32) -> i32 { unsafe { tsString_toi32_cuu(self.this, radix, pos) } }
	pub fn toi64_with_radix(&self, radix: u32) -> i64 { unsafe { tsString_toi64_cuu(self.this, radix, 0) } }
	pub fn toi64_with_radix_pos(&self, radix: u32, pos: u32) -> i64 { unsafe { tsString_toi64_cuu(self.this, radix, pos) } }
	pub fn tou32_with_radix(&self, radix: u32) -> u32 { unsafe { tsString_tou32_cuu(self.this, radix, 0) } }
	pub fn tou32_with_radix_pos(&self, radix: u32, pos: u32) -> u32 { unsafe { tsString_tou32_cuu(self.this, radix, pos) } }
	pub fn tou64_with_radix(&self, radix: u32) -> u64 { unsafe { tsString_tou64_cuu(self.this, radix, 0) } }
	pub fn tou64_with_radix_pos(&self, radix: u32, pos: u32) -> u64 { unsafe { tsString_tou64_cuu(self.this, radix, pos) } }
	pub fn tof32(&self) -> f32 { unsafe { tsString_tof32_cu(self.this, 0) } }
	pub fn tof32_with_pos(&self, pos: u32) -> f32 { unsafe { tsString_tof32_cu(self.this, pos) } }
	pub fn tof64(&self) -> f64 { unsafe { tsString_tof64_cu(self.this, 0) } }
	pub fn tof64_with_pos(&self, pos: u32) -> f64 { unsafe { tsString_tof64_cu(self.this, pos) } }
	pub fn to_hashu32(&self) -> u32 { unsafe { tsString_toHashu32(self.this, 0) } }
	pub fn to_hashu32_with_pos(&self, pos: u32) -> u32 { unsafe { tsString_toHashu32(self.this, pos) } }
	pub fn to_hashu64(&self) -> u64 { unsafe { tsString_toHashu64(self.this, 0) } }
	pub fn to_hashu64_with_pos(&self, pos: u32) -> u64 { unsafe { tsString_toHashu64(self.this, pos) } }
	pub fn to_rgb_au8(&self) -> u32 { unsafe { tsString_toRGBAu8(self.this, 0) } }
	pub fn to_rgb_au8_with_pos(&self, pos: u32) -> u32 { unsafe { tsString_toRGBAu8(self.this, pos) } }
	pub fn from_time(usec: u64) -> string::String { unsafe { get_string(tsString_fromTime(usec, 2)) } }
	pub fn from_time_with_digits(usec: u64, digits: u32) -> string::String { unsafe { get_string(tsString_fromTime(usec, digits)) } }
	pub fn from_bytes(bytes: u64) -> string::String { unsafe { get_string(tsString_fromBytes(bytes, 2)) } }
	pub fn from_bytes_with_digits(bytes: u64, digits: u32) -> string::String { unsafe { get_string(tsString_fromBytes(bytes, digits)) } }
	pub fn from_number(value: u64) -> string::String { unsafe { get_string(tsString_fromNumber(value, 2)) } }
	pub fn from_number_with_digits(value: u64, digits: u32) -> string::String { unsafe { get_string(tsString_fromNumber(value, digits)) } }
	pub fn from_frequency(hz: u64) -> string::String { unsafe { get_string(tsString_fromFrequency(hz, 2)) } }
	pub fn from_frequency_with_digits(hz: u64, digits: u32) -> string::String { unsafe { get_string(tsString_fromFrequency(hz, digits)) } }
	pub fn from_length(distance: f64) -> string::String { unsafe { get_string(tsString_fromLength(distance, 2)) } }
	pub fn from_length_with_digits(distance: f64, digits: u32) -> string::String { unsafe { get_string(tsString_fromLength(distance, digits)) } }
	pub fn from_angle(angle: f64) -> string::String { unsafe { get_string(tsString_fromAngle(angle, 2)) } }
	pub fn from_angle_with_digits(angle: f64, digits: u32) -> string::String { unsafe { get_string(tsString_fromAngle(angle, digits)) } }
	pub fn to_bytes(str: &str) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toBytes_sur(str_.as_ptr(), ptr::null_mut()) }
	}
	pub fn to_bytes_with_size(str: &str, size: *mut u32) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toBytes_sur(str_.as_ptr(), size) }
	}
	pub fn to_number(str: &str) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toNumber_sur(str_.as_ptr(), ptr::null_mut()) }
	}
	pub fn to_number_with_size(str: &str, size: *mut u32) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toNumber_sur(str_.as_ptr(), size) }
	}
	pub fn to_frequency(str: &str) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toFrequency_sur(str_.as_ptr(), ptr::null_mut()) }
	}
	pub fn to_frequency_with_size(str: &str, size: *mut u32) -> u64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toFrequency_sur(str_.as_ptr(), size) }
	}
	pub fn to_length(str: &str) -> f64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toLength_sur(str_.as_ptr(), ptr::null_mut()) }
	}
	pub fn to_length_with_size(str: &str, size: *mut u32) -> f64 {
		let str_ = CString::new(str).unwrap();
		unsafe { tsString_toLength_sur(str_.as_ptr(), size) }
	}
	pub fn to_bytes_with_pos(&self, pos: u32) -> u64 { unsafe { tsString_toBytes_cuur(self.this, pos, ptr::null_mut()) } }
	pub fn to_bytes_with_pos_size(&self, pos: u32, size: *mut u32) -> u64 { unsafe { tsString_toBytes_cuur(self.this, pos, size) } }
	pub fn to_number_with_pos(&self, pos: u32) -> u64 { unsafe { tsString_toNumber_cuur(self.this, pos, ptr::null_mut()) } }
	pub fn to_number_with_pos_size(&self, pos: u32, size: *mut u32) -> u64 { unsafe { tsString_toNumber_cuur(self.this, pos, size) } }
	pub fn to_frequency_with_pos(&self, pos: u32) -> u64 { unsafe { tsString_toFrequency_cuur(self.this, pos, ptr::null_mut()) } }
	pub fn to_frequency_with_pos_size(&self, pos: u32, size: *mut u32) -> u64 { unsafe { tsString_toFrequency_cuur(self.this, pos, size) } }
	pub fn to_length_with_pos(&self, pos: u32) -> f64 { unsafe { tsString_toLength_cuur(self.this, pos, ptr::null_mut()) } }
	pub fn to_length_with_pos_size(&self, pos: u32, size: *mut u32) -> f64 { unsafe { tsString_toLength_cuur(self.this, pos, size) } }
}
impl Drop for String {
	fn drop(&mut self) { if self.owner { unsafe { tsString_delete(self.this) } } }
}
impl fmt::Display for String {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::String ".to_string();
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsString_new() -> *mut c_void;
	fn tsString_new_uc(size: u32, c: c_char) -> *mut c_void;
	fn tsString_new_su(str: *const c_char, length: u32) -> *mut c_void;
	fn tsString_new_wu(str: *const u16, length: u32) -> *mut c_void;
	fn tsString_new_upu(str: *const u32, length: u32) -> *mut c_void;
	fn tsString_delete(this: *mut c_void);
	fn tsString_reserve(this: *mut c_void, size: u32, discard: i32);
	fn tsString_resize(this: *mut c_void, size: u32, c: c_char, reserve: i32);
	fn tsString_release(this: *mut c_void);
	fn tsString_clear(this: *mut c_void);
	fn tsString_copy_su(this: *mut c_void, str: *const c_char, length: u32);
	fn tsString_copy_wu(this: *mut c_void, str: *const u16, length: u32);
	fn tsString_copy_upu(this: *mut c_void, str: *const u32, length: u32);
	fn tsString_copy_cSu(this: *mut c_void, string: *mut c_void, length: u32);
	fn tsString_append_c(this: *mut c_void, c: c_char);
	fn tsString_append_su(this: *mut c_void, str: *const c_char, length: u32);
	fn tsString_append_cSu(this: *mut c_void, string: *mut c_void, length: u32);
	fn tsString_insert_usu(this: *mut c_void, pos: u32, str: *const c_char, length: u32);
	fn tsString_insert_ucSu(this: *mut c_void, pos: u32, string: *mut c_void, length: u32);
	fn tsString_removeBack(this: *mut c_void, length: u32);
	fn tsString_remove(this: *mut c_void, pos: u32, length: u32);
	fn tsString_reverse(this: *mut c_void, pos: u32, length: u32);
	fn tsString_size(this: *const c_void) -> u32;
	fn tsString_empty(this: *const c_void) -> i32;
	fn tsString_get(this: *mut c_void) -> *mut c_char;
	fn tsString_get_c(this: *const c_void) -> *const c_char;
	fn tsString_get_u(this: *mut c_void, index: u32) -> c_char;
	fn tsString_get_cu(this: *const c_void, index: u32) -> c_char;
	fn tsString_find_ccu(this: *const c_void, c: c_char, pos: u32) -> u32;
	fn tsString_rfind_ccu(this: *const c_void, c: c_char, pos: u32) -> u32;
	fn tsString_count_ccu(this: *const c_void, c: c_char, pos: u32) -> u32;
	fn tsString_find_csu(this: *const c_void, str: *const c_char, pos: u32) -> u32;
	fn tsString_rfind_csu(this: *const c_void, str: *const c_char, pos: u32) -> u32;
	fn tsString_count_csu(this: *const c_void, str: *const c_char, pos: u32) -> u32;
	fn tsString_begins(this: *const c_void, str: *const c_char, length: u32, pos: u32) -> i32;
	fn tsString_contains(this: *const c_void, str: *const c_char, length: u32, pos: u32) -> i32;
	fn tsString_match(this: *const c_void, str: *const c_char, length: u32, pos: u32) -> i32;
	fn tsString_compare(this: *const c_void, str: *const c_char, pos: u32) -> i32;
	fn tsString_distance(this: *const c_void, str: *const c_char, scan: i32, pos: u32) -> u32;
	fn tsString_begin(this: *const c_void) -> *const c_char;
	fn tsString_end(this: *const c_void) -> *const c_char;
	fn tsString_front_cu(this: *const c_void, index: u32) -> c_char;
	fn tsString_back_cu(this: *const c_void, index: u32) -> c_char;
	fn tsString_front_u(this: *mut c_void, index: u32) -> c_char;
	fn tsString_back_u(this: *mut c_void, index: u32) -> c_char;
	fn tsString_substring(this: *const c_void, pos: u32, length: u32) -> *mut c_void;
	fn tsString_replace_cccu(this: *const c_void, before: c_char, after: c_char, pos: u32) -> *mut c_void;
	fn tsString_replace_cssu(this: *const c_void, before: *const c_char, after: *const c_char, pos: u32) -> *mut c_void;
	fn tsString_replace_ccScSu(this: *const c_void, before: *mut c_void, after: *mut c_void, pos: u32) -> *mut c_void;
	fn tsString_extension_cs(this: *const c_void, extension: *const c_char) -> *mut c_void;
	fn tsString_extension_c(this: *const c_void) -> *mut c_void;
	fn tsString_pathname(this: *const c_void) -> *mut c_void;
	fn tsString_basename(this: *const c_void) -> *mut c_void;
	fn tsString_dirname(this: *const c_void) -> *mut c_void;
	fn tsString_relname_ss(path: *const c_char, str: *const c_char) -> *mut c_void;
	fn tsString_relname_cScS(path: *mut c_void, str: *mut c_void) -> *mut c_void;
	fn tsString_capitalize(this: *const c_void, delimiters: *const c_char, spaces: *const c_char) -> *mut c_void;
	fn tsString_lower(this: *const c_void) -> *mut c_void;
	fn tsString_upper(this: *const c_void) -> *mut c_void;
	fn tsString_toUtf32_sur(str: *const c_char, code: &mut u32) -> u32;
	fn tsString_toUtf16(this: *const c_void, d: *mut u16, length: u32) -> u32;
	fn tsString_toUtf32_curu(this: *const c_void, d: *mut u32, length: u32) -> u32;
	fn tsString_fromUtf32_Su(d: *mut c_void, code: u32) -> u32;
	fn tsString_fromUtf16(str: *const u16, length: u32) -> *mut c_void;
	fn tsString_fromUtf32_upu(str: *const u32, length: u32) -> *mut c_void;
	fn tsString_fromUrl_su(str: *const c_char, length: u32) -> *mut c_void;
	fn tsString_fromUrl_cSu(string: *mut c_void, length: u32) -> *mut c_void;
	fn tsString_fromi32_Siu(d: *mut c_void, value: i32, radix: u32) -> *mut c_void;
	fn tsString_fromi64_Si64u(d: *mut c_void, value: i64, radix: u32) -> *mut c_void;
	fn tsString_fromu32_Suu(d: *mut c_void, value: u32, radix: u32) -> *mut c_void;
	fn tsString_fromu64_Su64u(d: *mut c_void, value: u64, radix: u32) -> *mut c_void;
	fn tsString_fromf32_Sfubb(d: *mut c_void, value: f32, digits: u32, compact: i32, exponent: i32) -> *mut c_void;
	fn tsString_fromf64_Sf64ubb(d: *mut c_void, value: f64, digits: u32, compact: i32, exponent: i32) -> *mut c_void;
	fn tsString_fromi32_iu(value: i32, radix: u32) -> *mut c_void;
	fn tsString_fromi64_i64u(value: i64, radix: u32) -> *mut c_void;
	fn tsString_fromu32_uu(value: u32, radix: u32) -> *mut c_void;
	fn tsString_fromu64_u64u(value: u64, radix: u32) -> *mut c_void;
	fn tsString_fromf32_fubb(value: f32, digits: u32, compact: i32, exponent: i32) -> *mut c_void;
	fn tsString_fromf64_f64ubb(value: f64, digits: u32, compact: i32, exponent: i32) -> *mut c_void;
	fn tsString_toi32_suur(str: *const c_char, radix: u32, size: *mut u32) -> i32;
	fn tsString_toi64_suur(str: *const c_char, radix: u32, size: *mut u32) -> i64;
	fn tsString_tou32_suur(str: *const c_char, radix: u32, size: *mut u32) -> u32;
	fn tsString_tou64_suur(str: *const c_char, radix: u32, size: *mut u32) -> u64;
	fn tsString_toi32_sur(str: *const c_char, size: *mut u32) -> i32;
	fn tsString_toi64_sur(str: *const c_char, size: *mut u32) -> i64;
	fn tsString_tou32_sur(str: *const c_char, size: *mut u32) -> u32;
	fn tsString_tou64_sur(str: *const c_char, size: *mut u32) -> u64;
	fn tsString_tof32_sur(str: *const c_char, size: *mut u32) -> f32;
	fn tsString_tof64_sur(str: *const c_char, size: *mut u32) -> f64;
	fn tsString_toi32_cuu(this: *const c_void, radix: u32, pos: u32) -> i32;
	fn tsString_toi64_cuu(this: *const c_void, radix: u32, pos: u32) -> i64;
	fn tsString_tou32_cuu(this: *const c_void, radix: u32, pos: u32) -> u32;
	fn tsString_tou64_cuu(this: *const c_void, radix: u32, pos: u32) -> u64;
	fn tsString_tof32_cu(this: *const c_void, pos: u32) -> f32;
	fn tsString_tof64_cu(this: *const c_void, pos: u32) -> f64;
	fn tsString_toHashu32(this: *const c_void, pos: u32) -> u32;
	fn tsString_toHashu64(this: *const c_void, pos: u32) -> u64;
	fn tsString_toRGBAu8(this: *const c_void, pos: u32) -> u32;
	fn tsString_fromTime(usec: u64, digits: u32) -> *mut c_void;
	fn tsString_fromBytes(bytes: u64, digits: u32) -> *mut c_void;
	fn tsString_fromNumber(value: u64, digits: u32) -> *mut c_void;
	fn tsString_fromFrequency(hz: u64, digits: u32) -> *mut c_void;
	fn tsString_fromLength(distance: f64, digits: u32) -> *mut c_void;
	fn tsString_fromAngle(angle: f64, digits: u32) -> *mut c_void;
	fn tsString_toBytes_sur(str: *const c_char, size: *mut u32) -> u64;
	fn tsString_toNumber_sur(str: *const c_char, size: *mut u32) -> u64;
	fn tsString_toFrequency_sur(str: *const c_char, size: *mut u32) -> u64;
	fn tsString_toLength_sur(str: *const c_char, size: *mut u32) -> f64;
	fn tsString_toBytes_cuur(this: *const c_void, pos: u32, size: *mut u32) -> u64;
	fn tsString_toNumber_cuur(this: *const c_void, pos: u32, size: *mut u32) -> u64;
	fn tsString_toFrequency_cuur(this: *const c_void, pos: u32, size: *mut u32) -> u64;
	fn tsString_toLength_cuur(this: *const c_void, pos: u32, size: *mut u32) -> f64;
}

// Tellusim::App
pub struct App {
	this: *mut c_void,
	owner: bool,
}
impl App {
	pub fn null() -> App { App { this: ptr::null_mut(), owner: false } }
	pub fn new() -> App {
		let mut args = Vec::new();
		let mut argv = Vec::new();
		for arg in std::env::args() {
			args.push(CString::new(arg).unwrap());
			argv.push(args.last().unwrap().as_ptr());
		}
		unsafe { App { this: tsApp_new(argv.len() as i32, argv.as_mut_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> App { App { this: ptr, owner: true } }
	pub fn copy_ptr(&self) -> App { App { this: self.this, owner: false } }
	pub fn clear(&mut self) { unsafe { tsApp_clear(self.this) } }
	pub fn platform(&self) -> Platform { unsafe { tsApp_getPlatform(self.this) } }
	pub fn device(&self) -> u32 { unsafe { tsApp_getDevice(self.this) } }
	pub fn width(&self) -> u32 { unsafe { tsApp_getWidth(self.this) } }
	pub fn height(&self) -> u32 { unsafe { tsApp_getHeight(self.this) } }
	pub fn multisample(&self) -> u32 { unsafe { tsApp_getMultisample(self.this) } }
	pub fn num_arguments(&self) -> u32 { unsafe { tsApp_getNumArguments(self.this) } }
	pub fn argument(&self, num: u32) -> string::String { unsafe { get_string(tsApp_getArgument_cu(self.this, num)) } }
	pub fn is_argument(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsApp_isArgument(self.this, name_.as_ptr()) != 0 }
	}
	pub fn argument_with_name(&self, name: &str) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsApp_getArgument_cs(self.this, name_.as_ptr())) }
	}
	pub fn create(&mut self) -> bool { unsafe { tsApp_create(self.this, Platform::Unknown, AppVersion::Version as u32) != 0 } }
	pub fn create_with_platform(&mut self, platform: Platform) -> bool { unsafe { tsApp_create(self.this, platform, AppVersion::Version as u32) != 0 } }
	pub fn create_with_platform_version(&mut self, platform: Platform, version: AppVersion) -> bool { unsafe { tsApp_create(self.this, platform, version as u32) != 0 } }
	pub fn set_platform(platform: Platform) { unsafe { tsApp_setPlatform(platform, MAXU32) } }
	pub fn set_platform_with_device(platform: Platform, device: u32) { unsafe { tsApp_setPlatform(platform, device) } }
	pub fn set_size(width: u32, height: u32) { unsafe { tsApp_setSize(width, height, 0) } }
	pub fn set_size_with_multisample(width: u32, height: u32, multisample: u32) { unsafe { tsApp_setSize(width, height, multisample) } }
	pub fn is_build_core() -> bool { unsafe { tsApp_isBuildCore() != 0 } }
	pub fn is_build_debug() -> bool { unsafe { tsApp_isBuildDebug() != 0 } }
	pub fn is_build_float64() -> bool { unsafe { tsApp_isBuildFloat64() != 0 } }
	pub fn build_date() -> string::String { unsafe { get_string(tsApp_getBuildDate()) } }
	pub fn build_info() -> string::String { unsafe { get_string(tsApp_getBuildInfo()) } }
	pub fn version() -> u32 { unsafe { tsApp_getVersion() } }
	pub fn api_hash() -> u64 { unsafe { tsApp_getAPIHash() } }
}
impl Drop for App {
	fn drop(&mut self) { if self.owner { unsafe { tsApp_delete(self.this) } } }
}
impl fmt::Display for App {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::App ".to_string();
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsApp_new(argc: i32, argv: *mut *const c_char) -> *mut c_void;
	fn tsApp_delete(this: *mut c_void);
	fn tsApp_clear(this: *mut c_void);
	fn tsApp_getPlatform(this: *const c_void) -> Platform;
	fn tsApp_getDevice(this: *const c_void) -> u32;
	fn tsApp_getWidth(this: *const c_void) -> u32;
	fn tsApp_getHeight(this: *const c_void) -> u32;
	fn tsApp_getMultisample(this: *const c_void) -> u32;
	fn tsApp_getNumArguments(this: *const c_void) -> u32;
	fn tsApp_getArgument_cu(this: *const c_void, num: u32) -> *mut c_void;
	fn tsApp_isArgument(this: *const c_void, name: *const c_char) -> i32;
	fn tsApp_getArgument_cs(this: *const c_void, name: *const c_char) -> *mut c_void;
	fn tsApp_create(this: *mut c_void, platform: Platform, version: u32) -> i32;
	fn tsApp_setPlatform(platform: Platform, device: u32);
	fn tsApp_setSize(width: u32, height: u32, multisample: u32);
	fn tsApp_isBuildCore() -> i32;
	fn tsApp_isBuildDebug() -> i32;
	fn tsApp_isBuildFloat64() -> i32;
	fn tsApp_getBuildDate() -> *mut c_void;
	fn tsApp_getBuildInfo() -> *mut c_void;
	fn tsApp_getVersion() -> u32;
	fn tsApp_getAPIHash() -> u64;
}

// Tellusim::Async
pub struct Async {
	this: *mut c_void,
	owner: bool,
}
impl Async {
	pub fn null() -> Async { Async { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Async { unsafe { Async { this: tsAsync_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Async { unsafe { Async { this: ptr, owner: tsAsync_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Async { unsafe { Async { this: tsAsync_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Async) -> bool { unsafe { tsAsync_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Async { unsafe { Async { this: tsAsync_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsAsync_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsAsync_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsAsync_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsAsync_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsAsync_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsAsync_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsAsync_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsAsync_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsAsync_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn init(&mut self) -> bool { unsafe { tsAsync_init(self.this, 0) != 0 } }
	pub fn init_with_num(&mut self, num: u32) -> bool { unsafe { tsAsync_init(self.this, num) != 0 } }
	pub fn shutdown(&mut self) -> bool { unsafe { tsAsync_shutdown(self.this) != 0 } }
	pub fn is_initialized(&self) -> bool { unsafe { tsAsync_isInitialized(self.this) != 0 } }
	pub fn num_cores() -> u32 { unsafe { tsAsync_getNumCores() } }
	pub fn num_threads(&self) -> u32 { unsafe { tsAsync_getNumThreads(self.this) } }
	pub fn clear(&mut self) { unsafe { tsAsync_clear(self.this) } }
	pub fn num_tasks(&self) -> u32 { unsafe { tsAsync_getNumTasks(self.this, 0) } }
	pub fn num_tasks_with_check(&self, check: bool) -> u32 { unsafe { tsAsync_getNumTasks(self.this, if check {1} else {0}) } }
	pub fn check(&self) -> bool { unsafe { tsAsync_check_c(self.this) != 0 } }
	pub fn wait(&self) -> bool { unsafe { tsAsync_wait_c(self.this) != 0 } }
}
impl Drop for Async {
	fn drop(&mut self) { if self.owner { unsafe { tsAsync_delete(self.this) } } }
}
impl Clone for Async {
	fn clone(&self) -> Async { unsafe { Async { this: tsAsync_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Async { }
impl fmt::Display for Async {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Async ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsAsync_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsAsync_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsAsync_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsAsync_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsAsync_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsAsync_new() -> *mut c_void;
	fn tsAsync_delete(this: *mut c_void);
	fn tsAsync_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsAsync_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsAsync_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsAsync_clearPtr(this: *const c_void);
	fn tsAsync_destroyPtr(this: *const c_void);
	fn tsAsync_acquirePtr(this: *const c_void);
	fn tsAsync_unacquirePtr(this: *const c_void);
	fn tsAsync_isValidPtr(this: *const c_void) -> i32;
	fn tsAsync_isOwnerPtr(this: *const c_void) -> i32;
	fn tsAsync_isConstPtr(this: *const c_void) -> i32;
	fn tsAsync_getCountPtr(this: *const c_void) -> u32;
	fn tsAsync_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsAsync_init(this: *mut c_void, num: u32) -> i32;
	fn tsAsync_shutdown(this: *mut c_void) -> i32;
	fn tsAsync_isInitialized(this: *const c_void) -> i32;
	fn tsAsync_getNumCores() -> u32;
	fn tsAsync_getNumThreads(this: *const c_void) -> u32;
	fn tsAsync_clear(this: *mut c_void);
	fn tsAsync_getNumTasks(this: *const c_void, check: i32) -> u32;
	fn tsAsync_check_c(this: *const c_void) -> i32;
	fn tsAsync_wait_c(this: *const c_void) -> i32;
}

// Tellusim::Stream
pub struct Stream {
	this: *mut c_void,
	owner: bool,
}
impl Stream {
	pub fn null() -> Stream { Stream { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Stream { unsafe { Stream { this: tsStream_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Stream { unsafe { Stream { this: ptr, owner: tsStream_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Stream { unsafe { Stream { this: tsStream_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Stream) -> bool { unsafe { tsStream_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Stream { unsafe { Stream { this: tsStream_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsStream_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsStream_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsStream_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsStream_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsStream_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsStream_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsStream_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsStream_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsStream_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait StreamTrait {
	fn move_(&mut self) -> Stream;
	fn is_opened(&self) -> bool;
	fn is_mapped(&self) -> bool;
	fn is_available(&self) -> bool;
	fn size(&self) -> usize;
	fn name(&self) -> string::String;
	fn tell(&mut self) -> usize;
	fn seek(&mut self, offset: usize) -> bool;
	fn seek_back(&mut self, offset: usize) -> bool;
	fn seek_cur(&mut self, offset: i64) -> bool;
	fn data(&self) -> *const u8;
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize;
	fn write(&mut self, src: *const c_void, size: usize) -> usize;
	fn flush(&mut self) -> bool;
	fn puts(&mut self, str: &str) -> bool;
	fn puts_with_str(&mut self, str: &String) -> bool;
	fn printf(&mut self, format: &str) -> bool;
	fn gets(&mut self) -> string::String;
	fn gets_with_status(&mut self, status: *mut u8) -> string::String;
	fn readi8(&mut self) -> i8;
	fn readi8_with_status(&mut self, status: *mut u8) -> i8;
	fn writei8(&mut self, value: i8) -> bool;
	fn readu8(&mut self) -> u8;
	fn readu8_with_status(&mut self, status: *mut u8) -> u8;
	fn writeu8(&mut self, value: u8) -> bool;
	fn readi16(&mut self) -> i16;
	fn readi16_with_status(&mut self, status: *mut u8) -> i16;
	fn writei16(&mut self, value: i16) -> bool;
	fn readu16(&mut self) -> u16;
	fn readu16_with_status(&mut self, status: *mut u8) -> u16;
	fn writeu16(&mut self, value: u16) -> bool;
	fn readi32(&mut self) -> i32;
	fn readi32_with_status(&mut self, status: *mut u8) -> i32;
	fn writei32(&mut self, value: i32) -> bool;
	fn readu32(&mut self) -> u32;
	fn readu32_with_status(&mut self, status: *mut u8) -> u32;
	fn writeu32(&mut self, value: u32) -> bool;
	fn readi64(&mut self) -> i64;
	fn readi64_with_status(&mut self, status: *mut u8) -> i64;
	fn writei64(&mut self, value: i64) -> bool;
	fn readu64(&mut self) -> u64;
	fn readu64_with_status(&mut self, status: *mut u8) -> u64;
	fn writeu64(&mut self, value: u64) -> bool;
	fn readf32(&mut self) -> f32;
	fn readf32_with_status(&mut self, status: *mut u8) -> f32;
	fn writef32(&mut self, value: f32) -> bool;
	fn readf64(&mut self) -> f64;
	fn readf64_with_status(&mut self, status: *mut u8) -> f64;
	fn writef64(&mut self, value: f64) -> bool;
	fn readi32e(&mut self) -> i32;
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32;
	fn writei32e(&mut self, value: i32) -> bool;
	fn readu32e(&mut self) -> u32;
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32;
	fn writeu32e(&mut self, value: u32) -> bool;
	fn readi64e(&mut self) -> i64;
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64;
	fn writei64e(&mut self, value: i64) -> bool;
	fn readu64e(&mut self) -> u64;
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64;
	fn writeu64e(&mut self, value: u64) -> bool;
	fn read_string(&mut self) -> string::String;
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String;
	fn write_string_with_strs(&mut self, str: &String) -> bool;
	fn write_string_with_str(&mut self, str: &str) -> bool;
	fn read_string_with_term(&mut self, term: c_char) -> string::String;
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String;
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String;
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool;
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool;
	fn read_token(&mut self) -> string::String;
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String;
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool;
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool;
	fn read_line(&mut self) -> string::String;
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String;
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool;
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool;
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool;
	fn read_stream(&mut self, dest: &mut Stream) -> usize;
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn write_stream(&mut self, src: &mut Stream) -> usize;
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize;
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize;
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize;
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize;
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize;
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize;
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize;
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize;
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize;
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize;
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize;
	fn decode_zip(&mut self, src: &mut Stream) -> usize;
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize;
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize;
	fn encode_zip(&mut self, dest: &mut Stream) -> usize;
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize;
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize;
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize;
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn decode_lz4(&mut self, src: &mut Stream) -> usize;
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize;
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize;
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize;
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize;
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize;
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize;
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize;
}
impl StreamTrait for Stream {
	fn move_(&mut self) -> Stream { unsafe { Stream::new_ptr(tsStream_move(self.this)) } }
	fn is_opened(&self) -> bool { unsafe { tsStream_isOpened(self.this) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsStream_isMapped(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsStream_isAvailable(self.this) != 0 } }
	fn size(&self) -> usize { unsafe { tsStream_getSize(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsStream_getName(self.this)) } }
	fn tell(&mut self) -> usize { unsafe { tsStream_tell(self.this) } }
	fn seek(&mut self, offset: usize) -> bool { unsafe { tsStream_seek(self.this, offset) != 0 } }
	fn seek_back(&mut self, offset: usize) -> bool { unsafe { tsStream_seekBack(self.this, offset) != 0 } }
	fn seek_cur(&mut self, offset: i64) -> bool { unsafe { tsStream_seekCur(self.this, offset) != 0 } }
	fn data(&self) -> *const u8 { unsafe { tsStream_getData(self.this) } }
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_read(self.this, dest, size) } }
	fn write(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_write(self.this, src, size) } }
	fn flush(&mut self) -> bool { unsafe { tsStream_flush(self.this) != 0 } }
	fn puts(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_puts_s(self.this, str_.as_ptr()) != 0 }
	}
	fn puts_with_str(&mut self, str: &String) -> bool { unsafe { tsStream_puts_cS(self.this, str.this) != 0 } }
	fn printf(&mut self, format: &str) -> bool {
		let format_ = CString::new(format).unwrap();
		unsafe { tsStream_printf(self.this, format_.as_ptr()) != 0 }
	}
	fn gets(&mut self) -> string::String { unsafe { get_string(tsStream_gets(self.this, ptr::null_mut())) } }
	fn gets_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_gets(self.this, status)) } }
	fn readi8(&mut self) -> i8 { unsafe { tsStream_readi8(self.this, ptr::null_mut()) } }
	fn readi8_with_status(&mut self, status: *mut u8) -> i8 { unsafe { tsStream_readi8(self.this, status) } }
	fn writei8(&mut self, value: i8) -> bool { unsafe { tsStream_writei8(self.this, value) != 0 } }
	fn readu8(&mut self) -> u8 { unsafe { tsStream_readu8(self.this, ptr::null_mut()) } }
	fn readu8_with_status(&mut self, status: *mut u8) -> u8 { unsafe { tsStream_readu8(self.this, status) } }
	fn writeu8(&mut self, value: u8) -> bool { unsafe { tsStream_writeu8(self.this, value) != 0 } }
	fn readi16(&mut self) -> i16 { unsafe { tsStream_readi16(self.this, ptr::null_mut()) } }
	fn readi16_with_status(&mut self, status: *mut u8) -> i16 { unsafe { tsStream_readi16(self.this, status) } }
	fn writei16(&mut self, value: i16) -> bool { unsafe { tsStream_writei16(self.this, value) != 0 } }
	fn readu16(&mut self) -> u16 { unsafe { tsStream_readu16(self.this, ptr::null_mut()) } }
	fn readu16_with_status(&mut self, status: *mut u8) -> u16 { unsafe { tsStream_readu16(self.this, status) } }
	fn writeu16(&mut self, value: u16) -> bool { unsafe { tsStream_writeu16(self.this, value) != 0 } }
	fn readi32(&mut self) -> i32 { unsafe { tsStream_readi32(self.this, ptr::null_mut()) } }
	fn readi32_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32(self.this, status) } }
	fn writei32(&mut self, value: i32) -> bool { unsafe { tsStream_writei32(self.this, value) != 0 } }
	fn readu32(&mut self) -> u32 { unsafe { tsStream_readu32(self.this, ptr::null_mut()) } }
	fn readu32_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32(self.this, status) } }
	fn writeu32(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32(self.this, value) != 0 } }
	fn readi64(&mut self) -> i64 { unsafe { tsStream_readi64(self.this, ptr::null_mut()) } }
	fn readi64_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64(self.this, status) } }
	fn writei64(&mut self, value: i64) -> bool { unsafe { tsStream_writei64(self.this, value) != 0 } }
	fn readu64(&mut self) -> u64 { unsafe { tsStream_readu64(self.this, ptr::null_mut()) } }
	fn readu64_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64(self.this, status) } }
	fn writeu64(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64(self.this, value) != 0 } }
	fn readf32(&mut self) -> f32 { unsafe { tsStream_readf32(self.this, ptr::null_mut()) } }
	fn readf32_with_status(&mut self, status: *mut u8) -> f32 { unsafe { tsStream_readf32(self.this, status) } }
	fn writef32(&mut self, value: f32) -> bool { unsafe { tsStream_writef32(self.this, value) != 0 } }
	fn readf64(&mut self) -> f64 { unsafe { tsStream_readf64(self.this, ptr::null_mut()) } }
	fn readf64_with_status(&mut self, status: *mut u8) -> f64 { unsafe { tsStream_readf64(self.this, status) } }
	fn writef64(&mut self, value: f64) -> bool { unsafe { tsStream_writef64(self.this, value) != 0 } }
	fn readi32e(&mut self) -> i32 { unsafe { tsStream_readi32e(self.this, ptr::null_mut()) } }
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32e(self.this, status) } }
	fn writei32e(&mut self, value: i32) -> bool { unsafe { tsStream_writei32e(self.this, value) != 0 } }
	fn readu32e(&mut self) -> u32 { unsafe { tsStream_readu32e(self.this, ptr::null_mut()) } }
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32e(self.this, status) } }
	fn writeu32e(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32e(self.this, value) != 0 } }
	fn readi64e(&mut self) -> i64 { unsafe { tsStream_readi64e(self.this, ptr::null_mut()) } }
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64e(self.this, status) } }
	fn writei64e(&mut self, value: i64) -> bool { unsafe { tsStream_writei64e(self.this, value) != 0 } }
	fn readu64e(&mut self) -> u64 { unsafe { tsStream_readu64e(self.this, ptr::null_mut()) } }
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64e(self.this, status) } }
	fn writeu64e(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64e(self.this, value) != 0 } }
	fn read_string(&mut self) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, ptr::null_mut())) } }
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, status)) } }
	fn write_string_with_strs(&mut self, str: &String) -> bool { unsafe { tsStream_writeString_cS(self.this, str.this) != 0 } }
	fn write_string_with_str(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_s(self.this, str_.as_ptr()) != 0 }
	}
	fn read_string_with_term(&mut self, term: c_char) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, ptr::null_mut(), MAXU32)) } }
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, MAXU32)) } }
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, size)) } }
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool { unsafe { tsStream_writeString_cSc(self.this, str.this, term) != 0 } }
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_sc(self.this, str_.as_ptr(), term) != 0 }
	}
	fn read_token(&mut self) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, ptr::null_mut())) } }
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, status)) } }
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, 1) != 0 } }
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, if clear {1} else {0}) != 0 } }
	fn read_line(&mut self) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, ptr::null_mut())) } }
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, status)) } }
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, 0, 1) != 0 } }
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, 1) != 0 } }
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, if clear {1} else {0}) != 0 } }
	fn read_stream(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_readStream(self.this, dest.this, 0, ptr::null_mut()) } }
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, ptr::null_mut()) } }
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, status) } }
	fn write_stream(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_writeStream(self.this, src.this, 0, ptr::null_mut()) } }
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, ptr::null_mut()) } }
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, status) } }
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readZip(self.this, dest, size) } }
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZip(self.this, src, size, -1) } }
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeZip(self.this, src, size, level) } }
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipFast(self.this, src, size) } }
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipBest(self.this, src, size) } }
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readLz4(self.this, dest, size) } }
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, -1) } }
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, level) } }
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Fast(self.this, src, size) } }
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Best(self.this, src, size) } }
	fn decode_zip(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, 0, ptr::null_mut(), 15) } }
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, ptr::null_mut(), 15) } }
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, 15) } }
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, window) } }
	fn encode_zip(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, -1) } }
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, level) } }
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, status) } }
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, status) } }
	fn decode_lz4(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, 0, ptr::null_mut()) } }
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, ptr::null_mut()) } }
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, status) } }
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, -1) } }
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, level) } }
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, status) } }
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, status) } }
}
impl Drop for Stream {
	fn drop(&mut self) { if self.owner { unsafe { tsStream_delete(self.this) } } }
}
impl Clone for Stream {
	fn clone(&self) -> Stream { unsafe { Stream { this: tsStream_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Stream { }
impl fmt::Display for Stream {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Stream ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsStream_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsStream_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsStream_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsStream_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsStream_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsStream_new() -> *mut c_void;
	fn tsStream_delete(this: *mut c_void);
	fn tsStream_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsStream_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsStream_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsStream_clearPtr(this: *const c_void);
	fn tsStream_destroyPtr(this: *const c_void);
	fn tsStream_acquirePtr(this: *const c_void);
	fn tsStream_unacquirePtr(this: *const c_void);
	fn tsStream_isValidPtr(this: *const c_void) -> i32;
	fn tsStream_isOwnerPtr(this: *const c_void) -> i32;
	fn tsStream_isConstPtr(this: *const c_void) -> i32;
	fn tsStream_getCountPtr(this: *const c_void) -> u32;
	fn tsStream_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsStream_move(this: *mut c_void) -> *mut c_void;
	fn tsStream_isOpened(this: *const c_void) -> i32;
	fn tsStream_isMapped(this: *const c_void) -> i32;
	fn tsStream_isAvailable(this: *const c_void) -> i32;
	fn tsStream_getSize(this: *const c_void) -> usize;
	fn tsStream_getName(this: *const c_void) -> *mut c_void;
	fn tsStream_tell(this: *mut c_void) -> usize;
	fn tsStream_seek(this: *mut c_void, offset: usize) -> i32;
	fn tsStream_seekBack(this: *mut c_void, offset: usize) -> i32;
	fn tsStream_seekCur(this: *mut c_void, offset: i64) -> i32;
	fn tsStream_getData(this: *const c_void) -> *const u8;
	fn tsStream_read(this: *mut c_void, dest: *mut c_void, size: usize) -> usize;
	fn tsStream_write(this: *mut c_void, src: *const c_void, size: usize) -> usize;
	fn tsStream_flush(this: *mut c_void) -> i32;
	fn tsStream_puts_s(this: *mut c_void, str: *const c_char) -> i32;
	fn tsStream_puts_cS(this: *mut c_void, str: *mut c_void) -> i32;
	fn tsStream_printf(this: *mut c_void, format: *const c_char) -> i32;
	fn tsStream_gets(this: *mut c_void, status: *mut u8) -> *mut c_void;
	fn tsStream_readi8(this: *mut c_void, status: *mut u8) -> i8;
	fn tsStream_writei8(this: *mut c_void, value: i8) -> i32;
	fn tsStream_readu8(this: *mut c_void, status: *mut u8) -> u8;
	fn tsStream_writeu8(this: *mut c_void, value: u8) -> i32;
	fn tsStream_readi16(this: *mut c_void, status: *mut u8) -> i16;
	fn tsStream_writei16(this: *mut c_void, value: i16) -> i32;
	fn tsStream_readu16(this: *mut c_void, status: *mut u8) -> u16;
	fn tsStream_writeu16(this: *mut c_void, value: u16) -> i32;
	fn tsStream_readi32(this: *mut c_void, status: *mut u8) -> i32;
	fn tsStream_writei32(this: *mut c_void, value: i32) -> i32;
	fn tsStream_readu32(this: *mut c_void, status: *mut u8) -> u32;
	fn tsStream_writeu32(this: *mut c_void, value: u32) -> i32;
	fn tsStream_readi64(this: *mut c_void, status: *mut u8) -> i64;
	fn tsStream_writei64(this: *mut c_void, value: i64) -> i32;
	fn tsStream_readu64(this: *mut c_void, status: *mut u8) -> u64;
	fn tsStream_writeu64(this: *mut c_void, value: u64) -> i32;
	fn tsStream_readf32(this: *mut c_void, status: *mut u8) -> f32;
	fn tsStream_writef32(this: *mut c_void, value: f32) -> i32;
	fn tsStream_readf64(this: *mut c_void, status: *mut u8) -> f64;
	fn tsStream_writef64(this: *mut c_void, value: f64) -> i32;
	fn tsStream_readi32e(this: *mut c_void, status: *mut u8) -> i32;
	fn tsStream_writei32e(this: *mut c_void, value: i32) -> i32;
	fn tsStream_readu32e(this: *mut c_void, status: *mut u8) -> u32;
	fn tsStream_writeu32e(this: *mut c_void, value: u32) -> i32;
	fn tsStream_readi64e(this: *mut c_void, status: *mut u8) -> i64;
	fn tsStream_writei64e(this: *mut c_void, value: i64) -> i32;
	fn tsStream_readu64e(this: *mut c_void, status: *mut u8) -> u64;
	fn tsStream_writeu64e(this: *mut c_void, value: u64) -> i32;
	fn tsStream_readString_br(this: *mut c_void, status: *mut u8) -> *mut c_void;
	fn tsStream_writeString_cS(this: *mut c_void, str: *mut c_void) -> i32;
	fn tsStream_writeString_s(this: *mut c_void, str: *const c_char) -> i32;
	fn tsStream_readString_cbru(this: *mut c_void, term: c_char, status: *mut u8, size: u32) -> *mut c_void;
	fn tsStream_writeString_cSc(this: *mut c_void, str: *mut c_void, term: c_char) -> i32;
	fn tsStream_writeString_sc(this: *mut c_void, str: *const c_char, term: c_char) -> i32;
	fn tsStream_readToken_br(this: *mut c_void, status: *mut u8) -> *mut c_void;
	fn tsStream_readToken_Sb(this: *mut c_void, dest: *mut c_void, clear: i32) -> i32;
	fn tsStream_readLine_br(this: *mut c_void, status: *mut u8) -> *mut c_void;
	fn tsStream_readLine_Sbb(this: *mut c_void, dest: *mut c_void, empty: i32, clear: i32) -> i32;
	fn tsStream_readStream(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8) -> usize;
	fn tsStream_writeStream(this: *mut c_void, src: *mut c_void, size: usize, status: *mut u8) -> usize;
	fn tsStream_readZip(this: *mut c_void, dest: *mut c_void, size: usize) -> usize;
	fn tsStream_writeZip(this: *mut c_void, src: *const c_void, size: usize, level: i32) -> usize;
	fn tsStream_writeZipFast(this: *mut c_void, src: *const c_void, size: usize) -> usize;
	fn tsStream_writeZipBest(this: *mut c_void, src: *const c_void, size: usize) -> usize;
	fn tsStream_readLz4(this: *mut c_void, dest: *mut c_void, size: usize) -> usize;
	fn tsStream_writeLz4(this: *mut c_void, src: *const c_void, size: usize, level: i32) -> usize;
	fn tsStream_writeLz4Fast(this: *mut c_void, src: *const c_void, size: usize) -> usize;
	fn tsStream_writeLz4Best(this: *mut c_void, src: *const c_void, size: usize) -> usize;
	fn tsStream_decodeZip(this: *mut c_void, src: *mut c_void, size: usize, status: *mut u8, window: i32) -> usize;
	fn tsStream_encodeZip(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8, level: i32) -> usize;
	fn tsStream_encodeZipFast(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8) -> usize;
	fn tsStream_encodeZipBest(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8) -> usize;
	fn tsStream_decodeLz4(this: *mut c_void, src: *mut c_void, size: usize, status: *mut u8) -> usize;
	fn tsStream_encodeLz4(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8, level: i32) -> usize;
	fn tsStream_encodeLz4Fast(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8) -> usize;
	fn tsStream_encodeLz4Best(this: *mut c_void, dest: *mut c_void, size: usize, status: *mut u8) -> usize;
}

// Tellusim::Blob
pub struct Blob {
	this: *mut c_void,
	owner: bool,
}
impl Blob {
	pub fn null() -> Blob { Blob { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Blob { unsafe { Blob { this: tsBlob_new_s(ptr::null_mut()), owner: true } } }
	pub fn new_with_name(name: &str) -> Blob {
		let name_ = CString::new(name).unwrap();
		unsafe { Blob { this: tsBlob_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_size(size: usize) -> Blob { unsafe { Blob { this: tsBlob_new_zs(size, ptr::null_mut()), owner: true } } }
	pub fn new_with_size_name(size: usize, name: &str) -> Blob {
		let name_ = CString::new(name).unwrap();
		unsafe { Blob { this: tsBlob_new_zs(size, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_data(data: *const u8, size: usize) -> Blob { unsafe { Blob { this: tsBlob_new_u8pzs(data, size, ptr::null_mut()), owner: true } } }
	pub fn new_with_data_name(data: *const u8, size: usize, name: &str) -> Blob {
		let name_ = CString::new(name).unwrap();
		unsafe { Blob { this: tsBlob_new_u8pzs(data, size, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_blobbl(blob: *const *const u8) -> Blob { unsafe { Blob { this: tsBlob_new_bls(blob, ptr::null_mut()), owner: true } } }
	pub fn new_with_blobbl_name(blob: *const *const u8, name: &str) -> Blob {
		let name_ = CString::new(name).unwrap();
		unsafe { Blob { this: tsBlob_new_bls(blob, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_blobcb(blob: &Blob, move_: bool) -> Blob { unsafe { Blob { this: tsBlob_new_cBb(blob.this, if move_ {1} else {0}), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Blob { unsafe { Blob { this: ptr, owner: tsBlob_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Blob { unsafe { Blob { this: tsBlob_copyPtr(self.this), owner: true } } }
	pub fn to_stream(&self) -> Stream { Stream { this: self.this, owner: false } }
	pub fn equal_ptr(&self, ptr: Blob) -> bool { unsafe { tsBlob_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Blob { unsafe { Blob { this: tsBlob_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsBlob_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsBlob_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsBlob_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsBlob_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsBlob_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsBlob_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsBlob_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsBlob_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsBlob_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn release(&mut self) { unsafe { tsBlob_release(self.this) } }
	pub fn clear(&mut self) { unsafe { tsBlob_clear(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBlob_setName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_name_with_name(&mut self, name: &String) { unsafe { tsBlob_setName_cS(self.this, name.this) } }
	pub fn set_size(&mut self, size: usize) { unsafe { tsBlob_setSize(self.this, size) } }
	pub fn set_capacity(&mut self, size: usize) { unsafe { tsBlob_setCapacity(self.this, size) } }
	pub fn capacity(&self) -> usize { unsafe { tsBlob_getCapacity(self.this) } }
	pub fn set_data_with_data(&mut self, data: *const u8, size: usize) -> bool { unsafe { tsBlob_setData_u8pz(self.this, data, size) != 0 } }
	pub fn set_data(&mut self, blob: *const *const u8) -> bool { unsafe { tsBlob_setData_bl(self.this, blob) != 0 } }
	pub fn set_data_with_blob(&mut self, blob: &Blob) -> bool { unsafe { tsBlob_setData_cB(self.this, blob.this) != 0 } }
	pub fn data(&self) -> *const u8 { unsafe { tsBlob_getData_c(self.this) } }
	pub fn data_mut(&mut self) -> *mut u8 { unsafe { tsBlob_getData(self.this) } }
	pub fn encode_base64(&mut self) -> string::String { unsafe { get_string(tsBlob_encodeBase64(self.this, 0)) } }
	pub fn encode_base64_with_size(&mut self, size: usize) -> string::String { unsafe { get_string(tsBlob_encodeBase64(self.this, size)) } }
	pub fn decode_base64(&mut self, src: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsBlob_decodeBase64(self.this, src_.as_ptr()) != 0 }
	}
	pub fn md5_with_hash(&mut self, hash: *mut u32) { unsafe { tsBlob_getMD5_urz(self.this, hash, 0) } }
	pub fn md5_with_hash_size(&mut self, hash: *mut u32, size: usize) { unsafe { tsBlob_getMD5_urz(self.this, hash, size) } }
	pub fn md5(&mut self) -> string::String { unsafe { get_string(tsBlob_getMD5_z(self.this, 0)) } }
	pub fn md5_with_size(&mut self, size: usize) -> string::String { unsafe { get_string(tsBlob_getMD5_z(self.this, size)) } }
	pub fn md5_with_str(str: &String) -> string::String { unsafe { get_string(tsBlob_getMD5_cS(str.this)) } }
	pub fn md5_with_srcp(src: *const c_void, size: usize) -> string::String { unsafe { get_string(tsBlob_getMD5_pz(src, size)) } }
	pub fn md5_with_srcst(src: &mut Stream) -> string::String { unsafe { get_string(tsBlob_getMD5_Stz(src.this, 0)) } }
	pub fn md5_with_srcst_size(src: &mut Stream, size: usize) -> string::String { unsafe { get_string(tsBlob_getMD5_Stz(src.this, size)) } }
	pub fn sha1_with_hash(&mut self, hash: *mut u32) { unsafe { tsBlob_getSHA1_urz(self.this, hash, 0) } }
	pub fn sha1_with_hash_size(&mut self, hash: *mut u32, size: usize) { unsafe { tsBlob_getSHA1_urz(self.this, hash, size) } }
	pub fn sha1(&mut self) -> string::String { unsafe { get_string(tsBlob_getSHA1_z(self.this, 0)) } }
	pub fn sha1_with_size(&mut self, size: usize) -> string::String { unsafe { get_string(tsBlob_getSHA1_z(self.this, size)) } }
	pub fn sha1_with_str(str: &String) -> string::String { unsafe { get_string(tsBlob_getSHA1_cS(str.this)) } }
	pub fn sha1_with_srcp(src: *const c_void, size: usize) -> string::String { unsafe { get_string(tsBlob_getSHA1_pz(src, size)) } }
	pub fn sha1_with_srcst(src: &mut Stream) -> string::String { unsafe { get_string(tsBlob_getSHA1_Stz(src.this, 0)) } }
	pub fn sha1_with_srcst_size(src: &mut Stream, size: usize) -> string::String { unsafe { get_string(tsBlob_getSHA1_Stz(src.this, size)) } }
}
impl StreamTrait for Blob {
	fn move_(&mut self) -> Stream { unsafe { Stream::new_ptr(tsStream_move(self.this)) } }
	fn is_opened(&self) -> bool { unsafe { tsStream_isOpened(self.this) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsStream_isMapped(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsStream_isAvailable(self.this) != 0 } }
	fn size(&self) -> usize { unsafe { tsStream_getSize(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsStream_getName(self.this)) } }
	fn tell(&mut self) -> usize { unsafe { tsStream_tell(self.this) } }
	fn seek(&mut self, offset: usize) -> bool { unsafe { tsStream_seek(self.this, offset) != 0 } }
	fn seek_back(&mut self, offset: usize) -> bool { unsafe { tsStream_seekBack(self.this, offset) != 0 } }
	fn seek_cur(&mut self, offset: i64) -> bool { unsafe { tsStream_seekCur(self.this, offset) != 0 } }
	fn data(&self) -> *const u8 { unsafe { tsStream_getData(self.this) } }
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_read(self.this, dest, size) } }
	fn write(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_write(self.this, src, size) } }
	fn flush(&mut self) -> bool { unsafe { tsStream_flush(self.this) != 0 } }
	fn puts(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_puts_s(self.this, str_.as_ptr()) != 0 }
	}
	fn puts_with_str(&mut self, str: &String) -> bool { unsafe { tsStream_puts_cS(self.this, str.this) != 0 } }
	fn printf(&mut self, format: &str) -> bool {
		let format_ = CString::new(format).unwrap();
		unsafe { tsStream_printf(self.this, format_.as_ptr()) != 0 }
	}
	fn gets(&mut self) -> string::String { unsafe { get_string(tsStream_gets(self.this, ptr::null_mut())) } }
	fn gets_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_gets(self.this, status)) } }
	fn readi8(&mut self) -> i8 { unsafe { tsStream_readi8(self.this, ptr::null_mut()) } }
	fn readi8_with_status(&mut self, status: *mut u8) -> i8 { unsafe { tsStream_readi8(self.this, status) } }
	fn writei8(&mut self, value: i8) -> bool { unsafe { tsStream_writei8(self.this, value) != 0 } }
	fn readu8(&mut self) -> u8 { unsafe { tsStream_readu8(self.this, ptr::null_mut()) } }
	fn readu8_with_status(&mut self, status: *mut u8) -> u8 { unsafe { tsStream_readu8(self.this, status) } }
	fn writeu8(&mut self, value: u8) -> bool { unsafe { tsStream_writeu8(self.this, value) != 0 } }
	fn readi16(&mut self) -> i16 { unsafe { tsStream_readi16(self.this, ptr::null_mut()) } }
	fn readi16_with_status(&mut self, status: *mut u8) -> i16 { unsafe { tsStream_readi16(self.this, status) } }
	fn writei16(&mut self, value: i16) -> bool { unsafe { tsStream_writei16(self.this, value) != 0 } }
	fn readu16(&mut self) -> u16 { unsafe { tsStream_readu16(self.this, ptr::null_mut()) } }
	fn readu16_with_status(&mut self, status: *mut u8) -> u16 { unsafe { tsStream_readu16(self.this, status) } }
	fn writeu16(&mut self, value: u16) -> bool { unsafe { tsStream_writeu16(self.this, value) != 0 } }
	fn readi32(&mut self) -> i32 { unsafe { tsStream_readi32(self.this, ptr::null_mut()) } }
	fn readi32_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32(self.this, status) } }
	fn writei32(&mut self, value: i32) -> bool { unsafe { tsStream_writei32(self.this, value) != 0 } }
	fn readu32(&mut self) -> u32 { unsafe { tsStream_readu32(self.this, ptr::null_mut()) } }
	fn readu32_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32(self.this, status) } }
	fn writeu32(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32(self.this, value) != 0 } }
	fn readi64(&mut self) -> i64 { unsafe { tsStream_readi64(self.this, ptr::null_mut()) } }
	fn readi64_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64(self.this, status) } }
	fn writei64(&mut self, value: i64) -> bool { unsafe { tsStream_writei64(self.this, value) != 0 } }
	fn readu64(&mut self) -> u64 { unsafe { tsStream_readu64(self.this, ptr::null_mut()) } }
	fn readu64_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64(self.this, status) } }
	fn writeu64(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64(self.this, value) != 0 } }
	fn readf32(&mut self) -> f32 { unsafe { tsStream_readf32(self.this, ptr::null_mut()) } }
	fn readf32_with_status(&mut self, status: *mut u8) -> f32 { unsafe { tsStream_readf32(self.this, status) } }
	fn writef32(&mut self, value: f32) -> bool { unsafe { tsStream_writef32(self.this, value) != 0 } }
	fn readf64(&mut self) -> f64 { unsafe { tsStream_readf64(self.this, ptr::null_mut()) } }
	fn readf64_with_status(&mut self, status: *mut u8) -> f64 { unsafe { tsStream_readf64(self.this, status) } }
	fn writef64(&mut self, value: f64) -> bool { unsafe { tsStream_writef64(self.this, value) != 0 } }
	fn readi32e(&mut self) -> i32 { unsafe { tsStream_readi32e(self.this, ptr::null_mut()) } }
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32e(self.this, status) } }
	fn writei32e(&mut self, value: i32) -> bool { unsafe { tsStream_writei32e(self.this, value) != 0 } }
	fn readu32e(&mut self) -> u32 { unsafe { tsStream_readu32e(self.this, ptr::null_mut()) } }
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32e(self.this, status) } }
	fn writeu32e(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32e(self.this, value) != 0 } }
	fn readi64e(&mut self) -> i64 { unsafe { tsStream_readi64e(self.this, ptr::null_mut()) } }
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64e(self.this, status) } }
	fn writei64e(&mut self, value: i64) -> bool { unsafe { tsStream_writei64e(self.this, value) != 0 } }
	fn readu64e(&mut self) -> u64 { unsafe { tsStream_readu64e(self.this, ptr::null_mut()) } }
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64e(self.this, status) } }
	fn writeu64e(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64e(self.this, value) != 0 } }
	fn read_string(&mut self) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, ptr::null_mut())) } }
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, status)) } }
	fn write_string_with_strs(&mut self, str: &String) -> bool { unsafe { tsStream_writeString_cS(self.this, str.this) != 0 } }
	fn write_string_with_str(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_s(self.this, str_.as_ptr()) != 0 }
	}
	fn read_string_with_term(&mut self, term: c_char) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, ptr::null_mut(), MAXU32)) } }
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, MAXU32)) } }
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, size)) } }
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool { unsafe { tsStream_writeString_cSc(self.this, str.this, term) != 0 } }
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_sc(self.this, str_.as_ptr(), term) != 0 }
	}
	fn read_token(&mut self) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, ptr::null_mut())) } }
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, status)) } }
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, 1) != 0 } }
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, if clear {1} else {0}) != 0 } }
	fn read_line(&mut self) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, ptr::null_mut())) } }
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, status)) } }
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, 0, 1) != 0 } }
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, 1) != 0 } }
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, if clear {1} else {0}) != 0 } }
	fn read_stream(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_readStream(self.this, dest.this, 0, ptr::null_mut()) } }
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, ptr::null_mut()) } }
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, status) } }
	fn write_stream(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_writeStream(self.this, src.this, 0, ptr::null_mut()) } }
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, ptr::null_mut()) } }
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, status) } }
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readZip(self.this, dest, size) } }
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZip(self.this, src, size, -1) } }
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeZip(self.this, src, size, level) } }
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipFast(self.this, src, size) } }
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipBest(self.this, src, size) } }
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readLz4(self.this, dest, size) } }
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, -1) } }
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, level) } }
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Fast(self.this, src, size) } }
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Best(self.this, src, size) } }
	fn decode_zip(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, 0, ptr::null_mut(), 15) } }
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, ptr::null_mut(), 15) } }
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, 15) } }
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, window) } }
	fn encode_zip(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, -1) } }
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, level) } }
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, status) } }
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, status) } }
	fn decode_lz4(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, 0, ptr::null_mut()) } }
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, ptr::null_mut()) } }
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, status) } }
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, -1) } }
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, level) } }
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, status) } }
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, status) } }
}
impl Drop for Blob {
	fn drop(&mut self) { if self.owner { unsafe { tsBlob_delete(self.this) } } }
}
impl Clone for Blob {
	fn clone(&self) -> Blob { unsafe { Blob { this: tsBlob_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Blob { }
impl fmt::Display for Blob {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Blob ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsBlob_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsBlob_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsBlob_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsBlob_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsBlob_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsBlob_new_s(name: *const c_char) -> *mut c_void;
	fn tsBlob_new_cS(name: *mut c_void) -> *mut c_void;
	fn tsBlob_new_zs(size: usize, name: *const c_char) -> *mut c_void;
	fn tsBlob_new_u8pzs(data: *const u8, size: usize, name: *const c_char) -> *mut c_void;
	fn tsBlob_new_bls(blob: *const *const u8, name: *const c_char) -> *mut c_void;
	fn tsBlob_new_cBb(blob: *mut c_void, move_: i32) -> *mut c_void;
	fn tsBlob_delete(this: *mut c_void);
	fn tsBlob_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsBlob_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsBlob_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsBlob_clearPtr(this: *const c_void);
	fn tsBlob_destroyPtr(this: *const c_void);
	fn tsBlob_acquirePtr(this: *const c_void);
	fn tsBlob_unacquirePtr(this: *const c_void);
	fn tsBlob_isValidPtr(this: *const c_void) -> i32;
	fn tsBlob_isOwnerPtr(this: *const c_void) -> i32;
	fn tsBlob_isConstPtr(this: *const c_void) -> i32;
	fn tsBlob_getCountPtr(this: *const c_void) -> u32;
	fn tsBlob_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsBlob_release(this: *mut c_void);
	fn tsBlob_clear(this: *mut c_void);
	fn tsBlob_setName_s(this: *mut c_void, name: *const c_char);
	fn tsBlob_setName_cS(this: *mut c_void, name: *mut c_void);
	fn tsBlob_setSize(this: *mut c_void, size: usize);
	fn tsBlob_setCapacity(this: *mut c_void, size: usize);
	fn tsBlob_getCapacity(this: *const c_void) -> usize;
	fn tsBlob_setData_u8pz(this: *mut c_void, data: *const u8, size: usize) -> i32;
	fn tsBlob_setData_bl(this: *mut c_void, blob: *const *const u8) -> i32;
	fn tsBlob_setData_cB(this: *mut c_void, blob: *mut c_void) -> i32;
	fn tsBlob_getData_c(this: *const c_void) -> *const u8;
	fn tsBlob_getData(this: *mut c_void) -> *mut u8;
	fn tsBlob_encodeBase64(this: *mut c_void, size: usize) -> *mut c_void;
	fn tsBlob_decodeBase64(this: *mut c_void, src: *const c_char) -> i32;
	fn tsBlob_getMD5_urz(this: *mut c_void, hash: *mut u32, size: usize);
	fn tsBlob_getMD5_z(this: *mut c_void, size: usize) -> *mut c_void;
	fn tsBlob_getMD5_cS(str: *mut c_void) -> *mut c_void;
	fn tsBlob_getMD5_pz(src: *const c_void, size: usize) -> *mut c_void;
	fn tsBlob_getMD5_Stz(src: *mut c_void, size: usize) -> *mut c_void;
	fn tsBlob_getSHA1_urz(this: *mut c_void, hash: *mut u32, size: usize);
	fn tsBlob_getSHA1_z(this: *mut c_void, size: usize) -> *mut c_void;
	fn tsBlob_getSHA1_cS(str: *mut c_void) -> *mut c_void;
	fn tsBlob_getSHA1_pz(src: *const c_void, size: usize) -> *mut c_void;
	fn tsBlob_getSHA1_Stz(src: *mut c_void, size: usize) -> *mut c_void;
}

// Tellusim::File
pub struct File {
	this: *mut c_void,
	owner: bool,
}
impl File {
	pub fn null() -> File { File { this: ptr::null_mut(), owner: false } }
	pub fn new() -> File { unsafe { File { this: tsFile_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> File { unsafe { File { this: ptr, owner: tsFile_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> File { unsafe { File { this: tsFile_copyPtr(self.this), owner: true } } }
	pub fn to_stream(&self) -> Stream { Stream { this: self.this, owner: false } }
	pub fn equal_ptr(&self, ptr: File) -> bool { unsafe { tsFile_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> File { unsafe { File { this: tsFile_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFile_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFile_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFile_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFile_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFile_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFile_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFile_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFile_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFile_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn open(&mut self, name: &str, mode: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let mode_ = CString::new(mode).unwrap();
		unsafe { tsFile_open_ss(self.this, name_.as_ptr(), mode_.as_ptr()) != 0 }
	}
	pub fn open_with_name(&mut self, name: &String, mode: &str) -> bool {
		let mode_ = CString::new(mode).unwrap();
		unsafe { tsFile_open_cSs(self.this, name.this, mode_.as_ptr()) != 0 }
	}
	pub fn open_with_fd(&mut self, fd: i32, name: &str, mode: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let mode_ = CString::new(mode).unwrap();
		unsafe { tsFile_open_iss(self.this, fd, name_.as_ptr(), mode_.as_ptr()) != 0 }
	}
	pub fn popen(&mut self, command: &str, mode: &str) -> bool {
		let command_ = CString::new(command).unwrap();
		let mode_ = CString::new(mode).unwrap();
		unsafe { tsFile_popen_ss(self.this, command_.as_ptr(), mode_.as_ptr()) != 0 }
	}
	pub fn popen_with_command(&mut self, command: &String, mode: &str) -> bool {
		let mode_ = CString::new(mode).unwrap();
		unsafe { tsFile_popen_cSs(self.this, command.this, mode_.as_ptr()) != 0 }
	}
	pub fn close(&mut self) { unsafe { tsFile_close(self.this) } }
	pub fn is_file(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsFile_isFile_s(name_.as_ptr()) != 0 }
	}
	pub fn is_file_with_name(name: &String) -> bool { unsafe { tsFile_isFile_cS(name.this) != 0 } }
	pub fn mtime(name: &str) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsFile_getMTime(name_.as_ptr()) }
	}
	pub fn size(name: &str) -> usize {
		let name_ = CString::new(name).unwrap();
		unsafe { tsFile_getSize(name_.as_ptr()) }
	}
	pub fn remove(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsFile_remove(name_.as_ptr()) != 0 }
	}
}
impl StreamTrait for File {
	fn move_(&mut self) -> Stream { unsafe { Stream::new_ptr(tsStream_move(self.this)) } }
	fn is_opened(&self) -> bool { unsafe { tsStream_isOpened(self.this) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsStream_isMapped(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsStream_isAvailable(self.this) != 0 } }
	fn size(&self) -> usize { unsafe { tsStream_getSize(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsStream_getName(self.this)) } }
	fn tell(&mut self) -> usize { unsafe { tsStream_tell(self.this) } }
	fn seek(&mut self, offset: usize) -> bool { unsafe { tsStream_seek(self.this, offset) != 0 } }
	fn seek_back(&mut self, offset: usize) -> bool { unsafe { tsStream_seekBack(self.this, offset) != 0 } }
	fn seek_cur(&mut self, offset: i64) -> bool { unsafe { tsStream_seekCur(self.this, offset) != 0 } }
	fn data(&self) -> *const u8 { unsafe { tsStream_getData(self.this) } }
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_read(self.this, dest, size) } }
	fn write(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_write(self.this, src, size) } }
	fn flush(&mut self) -> bool { unsafe { tsStream_flush(self.this) != 0 } }
	fn puts(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_puts_s(self.this, str_.as_ptr()) != 0 }
	}
	fn puts_with_str(&mut self, str: &String) -> bool { unsafe { tsStream_puts_cS(self.this, str.this) != 0 } }
	fn printf(&mut self, format: &str) -> bool {
		let format_ = CString::new(format).unwrap();
		unsafe { tsStream_printf(self.this, format_.as_ptr()) != 0 }
	}
	fn gets(&mut self) -> string::String { unsafe { get_string(tsStream_gets(self.this, ptr::null_mut())) } }
	fn gets_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_gets(self.this, status)) } }
	fn readi8(&mut self) -> i8 { unsafe { tsStream_readi8(self.this, ptr::null_mut()) } }
	fn readi8_with_status(&mut self, status: *mut u8) -> i8 { unsafe { tsStream_readi8(self.this, status) } }
	fn writei8(&mut self, value: i8) -> bool { unsafe { tsStream_writei8(self.this, value) != 0 } }
	fn readu8(&mut self) -> u8 { unsafe { tsStream_readu8(self.this, ptr::null_mut()) } }
	fn readu8_with_status(&mut self, status: *mut u8) -> u8 { unsafe { tsStream_readu8(self.this, status) } }
	fn writeu8(&mut self, value: u8) -> bool { unsafe { tsStream_writeu8(self.this, value) != 0 } }
	fn readi16(&mut self) -> i16 { unsafe { tsStream_readi16(self.this, ptr::null_mut()) } }
	fn readi16_with_status(&mut self, status: *mut u8) -> i16 { unsafe { tsStream_readi16(self.this, status) } }
	fn writei16(&mut self, value: i16) -> bool { unsafe { tsStream_writei16(self.this, value) != 0 } }
	fn readu16(&mut self) -> u16 { unsafe { tsStream_readu16(self.this, ptr::null_mut()) } }
	fn readu16_with_status(&mut self, status: *mut u8) -> u16 { unsafe { tsStream_readu16(self.this, status) } }
	fn writeu16(&mut self, value: u16) -> bool { unsafe { tsStream_writeu16(self.this, value) != 0 } }
	fn readi32(&mut self) -> i32 { unsafe { tsStream_readi32(self.this, ptr::null_mut()) } }
	fn readi32_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32(self.this, status) } }
	fn writei32(&mut self, value: i32) -> bool { unsafe { tsStream_writei32(self.this, value) != 0 } }
	fn readu32(&mut self) -> u32 { unsafe { tsStream_readu32(self.this, ptr::null_mut()) } }
	fn readu32_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32(self.this, status) } }
	fn writeu32(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32(self.this, value) != 0 } }
	fn readi64(&mut self) -> i64 { unsafe { tsStream_readi64(self.this, ptr::null_mut()) } }
	fn readi64_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64(self.this, status) } }
	fn writei64(&mut self, value: i64) -> bool { unsafe { tsStream_writei64(self.this, value) != 0 } }
	fn readu64(&mut self) -> u64 { unsafe { tsStream_readu64(self.this, ptr::null_mut()) } }
	fn readu64_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64(self.this, status) } }
	fn writeu64(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64(self.this, value) != 0 } }
	fn readf32(&mut self) -> f32 { unsafe { tsStream_readf32(self.this, ptr::null_mut()) } }
	fn readf32_with_status(&mut self, status: *mut u8) -> f32 { unsafe { tsStream_readf32(self.this, status) } }
	fn writef32(&mut self, value: f32) -> bool { unsafe { tsStream_writef32(self.this, value) != 0 } }
	fn readf64(&mut self) -> f64 { unsafe { tsStream_readf64(self.this, ptr::null_mut()) } }
	fn readf64_with_status(&mut self, status: *mut u8) -> f64 { unsafe { tsStream_readf64(self.this, status) } }
	fn writef64(&mut self, value: f64) -> bool { unsafe { tsStream_writef64(self.this, value) != 0 } }
	fn readi32e(&mut self) -> i32 { unsafe { tsStream_readi32e(self.this, ptr::null_mut()) } }
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32e(self.this, status) } }
	fn writei32e(&mut self, value: i32) -> bool { unsafe { tsStream_writei32e(self.this, value) != 0 } }
	fn readu32e(&mut self) -> u32 { unsafe { tsStream_readu32e(self.this, ptr::null_mut()) } }
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32e(self.this, status) } }
	fn writeu32e(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32e(self.this, value) != 0 } }
	fn readi64e(&mut self) -> i64 { unsafe { tsStream_readi64e(self.this, ptr::null_mut()) } }
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64e(self.this, status) } }
	fn writei64e(&mut self, value: i64) -> bool { unsafe { tsStream_writei64e(self.this, value) != 0 } }
	fn readu64e(&mut self) -> u64 { unsafe { tsStream_readu64e(self.this, ptr::null_mut()) } }
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64e(self.this, status) } }
	fn writeu64e(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64e(self.this, value) != 0 } }
	fn read_string(&mut self) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, ptr::null_mut())) } }
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, status)) } }
	fn write_string_with_strs(&mut self, str: &String) -> bool { unsafe { tsStream_writeString_cS(self.this, str.this) != 0 } }
	fn write_string_with_str(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_s(self.this, str_.as_ptr()) != 0 }
	}
	fn read_string_with_term(&mut self, term: c_char) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, ptr::null_mut(), MAXU32)) } }
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, MAXU32)) } }
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, size)) } }
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool { unsafe { tsStream_writeString_cSc(self.this, str.this, term) != 0 } }
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_sc(self.this, str_.as_ptr(), term) != 0 }
	}
	fn read_token(&mut self) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, ptr::null_mut())) } }
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, status)) } }
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, 1) != 0 } }
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, if clear {1} else {0}) != 0 } }
	fn read_line(&mut self) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, ptr::null_mut())) } }
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, status)) } }
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, 0, 1) != 0 } }
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, 1) != 0 } }
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, if clear {1} else {0}) != 0 } }
	fn read_stream(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_readStream(self.this, dest.this, 0, ptr::null_mut()) } }
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, ptr::null_mut()) } }
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, status) } }
	fn write_stream(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_writeStream(self.this, src.this, 0, ptr::null_mut()) } }
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, ptr::null_mut()) } }
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, status) } }
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readZip(self.this, dest, size) } }
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZip(self.this, src, size, -1) } }
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeZip(self.this, src, size, level) } }
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipFast(self.this, src, size) } }
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipBest(self.this, src, size) } }
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readLz4(self.this, dest, size) } }
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, -1) } }
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, level) } }
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Fast(self.this, src, size) } }
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Best(self.this, src, size) } }
	fn decode_zip(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, 0, ptr::null_mut(), 15) } }
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, ptr::null_mut(), 15) } }
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, 15) } }
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, window) } }
	fn encode_zip(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, -1) } }
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, level) } }
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, status) } }
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, status) } }
	fn decode_lz4(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, 0, ptr::null_mut()) } }
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, ptr::null_mut()) } }
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, status) } }
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, -1) } }
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, level) } }
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, status) } }
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, status) } }
}
impl Drop for File {
	fn drop(&mut self) { if self.owner { unsafe { tsFile_delete(self.this) } } }
}
impl Clone for File {
	fn clone(&self) -> File { unsafe { File { this: tsFile_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for File { }
impl fmt::Display for File {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::File ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFile_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFile_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFile_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFile_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFile_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFile_new() -> *mut c_void;
	fn tsFile_delete(this: *mut c_void);
	fn tsFile_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFile_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFile_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFile_clearPtr(this: *const c_void);
	fn tsFile_destroyPtr(this: *const c_void);
	fn tsFile_acquirePtr(this: *const c_void);
	fn tsFile_unacquirePtr(this: *const c_void);
	fn tsFile_isValidPtr(this: *const c_void) -> i32;
	fn tsFile_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFile_isConstPtr(this: *const c_void) -> i32;
	fn tsFile_getCountPtr(this: *const c_void) -> u32;
	fn tsFile_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFile_open_ss(this: *mut c_void, name: *const c_char, mode: *const c_char) -> i32;
	fn tsFile_open_cSs(this: *mut c_void, name: *mut c_void, mode: *const c_char) -> i32;
	fn tsFile_open_iss(this: *mut c_void, fd: i32, name: *const c_char, mode: *const c_char) -> i32;
	fn tsFile_popen_ss(this: *mut c_void, command: *const c_char, mode: *const c_char) -> i32;
	fn tsFile_popen_cSs(this: *mut c_void, command: *mut c_void, mode: *const c_char) -> i32;
	fn tsFile_close(this: *mut c_void);
	fn tsFile_isFile_s(name: *const c_char) -> i32;
	fn tsFile_isFile_cS(name: *mut c_void) -> i32;
	fn tsFile_getMTime(name: *const c_char) -> u64;
	fn tsFile_getSize(name: *const c_char) -> usize;
	fn tsFile_remove(name: *const c_char) -> i32;
}

// Tellusim::Socket
pub struct Socket {
	this: *mut c_void,
	owner: bool,
}
impl Socket {
	pub fn null() -> Socket { Socket { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Socket { unsafe { Socket { this: tsSocket_new(SocketType::Stream), owner: true } } }
	pub fn new_with_type(type_: SocketType) -> Socket { unsafe { Socket { this: tsSocket_new(type_), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Socket { unsafe { Socket { this: ptr, owner: tsSocket_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Socket { unsafe { Socket { this: tsSocket_copyPtr(self.this), owner: true } } }
	pub fn to_stream(&self) -> Stream { Stream { this: self.this, owner: false } }
	pub fn equal_ptr(&self, ptr: Socket) -> bool { unsafe { tsSocket_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Socket { unsafe { Socket { this: tsSocket_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSocket_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSocket_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSocket_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSocket_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSocket_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSocket_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSocket_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSocket_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSocket_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait SocketTrait {
	fn open(&mut self, port: u16) -> bool;
	fn open_with_num(&mut self, port: u16, num: u16) -> bool;
	fn open_with_name(&mut self, name: &str, port: u16) -> bool;
	fn open_with_names(&mut self, name: &String, port: u16) -> bool;
	fn close(&mut self);
	fn connect(&mut self, sec: u32) -> bool;
	fn connect_with_usec(&mut self, sec: u32, usec: u32) -> bool;
	fn accept(&mut self, socket: &mut Socket) -> bool;
	fn select(&mut self, sec: u32) -> bool;
	fn select_with_usec(&mut self, sec: u32, usec: u32) -> bool;
	fn set_timeout(&mut self, sec: u32) -> bool;
	fn timeout(&self) -> u32;
	fn set_block(&mut self, block: bool) -> bool;
	fn block(&self) -> bool;
	fn set_delay(&mut self, delay: bool) -> bool;
	fn delay(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn set_name_with_name(&mut self, name: &String);
	fn port(&self) -> u16;
	fn fd(&self) -> i32;
	fn type_(&self) -> SocketType;
	fn address() -> string::String;
	fn address_with_delimiter(delimiter: &str) -> string::String;
}
impl SocketTrait for Socket {
	fn open(&mut self, port: u16) -> bool { unsafe { tsSocket_open_u16u16(self.this, port, 32) != 0 } }
	fn open_with_num(&mut self, port: u16, num: u16) -> bool { unsafe { tsSocket_open_u16u16(self.this, port, num) != 0 } }
	fn open_with_name(&mut self, name: &str, port: u16) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSocket_open_su16(self.this, name_.as_ptr(), port) != 0 }
	}
	fn open_with_names(&mut self, name: &String, port: u16) -> bool { unsafe { tsSocket_open_cSu16(self.this, name.this, port) != 0 } }
	fn close(&mut self) { unsafe { tsSocket_close(self.this) } }
	fn connect(&mut self, sec: u32) -> bool { unsafe { tsSocket_connect(self.this, sec, 0) != 0 } }
	fn connect_with_usec(&mut self, sec: u32, usec: u32) -> bool { unsafe { tsSocket_connect(self.this, sec, usec) != 0 } }
	fn accept(&mut self, socket: &mut Socket) -> bool { unsafe { tsSocket_accept(self.this, socket.this) != 0 } }
	fn select(&mut self, sec: u32) -> bool { unsafe { tsSocket_select(self.this, sec, 0) != 0 } }
	fn select_with_usec(&mut self, sec: u32, usec: u32) -> bool { unsafe { tsSocket_select(self.this, sec, usec) != 0 } }
	fn set_timeout(&mut self, sec: u32) -> bool { unsafe { tsSocket_setTimeout(self.this, sec) != 0 } }
	fn timeout(&self) -> u32 { unsafe { tsSocket_getTimeout(self.this) } }
	fn set_block(&mut self, block: bool) -> bool { unsafe { tsSocket_setBlock(self.this, if block {1} else {0}) != 0 } }
	fn block(&self) -> bool { unsafe { tsSocket_getBlock(self.this) != 0 } }
	fn set_delay(&mut self, delay: bool) -> bool { unsafe { tsSocket_setDelay(self.this, if delay {1} else {0}) != 0 } }
	fn delay(&self) -> bool { unsafe { tsSocket_getDelay(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSocket_setName_s(self.this, name_.as_ptr()) }
	}
	fn set_name_with_name(&mut self, name: &String) { unsafe { tsSocket_setName_cS(self.this, name.this) } }
	fn port(&self) -> u16 { unsafe { tsSocket_getPort(self.this) } }
	fn fd(&self) -> i32 { unsafe { tsSocket_getFD(self.this) } }
	fn type_(&self) -> SocketType { unsafe { tsSocket_getType(self.this) } }
	fn address() -> string::String { unsafe { get_string(tsSocket_getAddress(ptr::null_mut())) } }
	fn address_with_delimiter(delimiter: &str) -> string::String {
		let delimiter_ = CString::new(delimiter).unwrap();
		unsafe { get_string(tsSocket_getAddress(delimiter_.as_ptr())) }
	}
}
impl StreamTrait for Socket {
	fn move_(&mut self) -> Stream { unsafe { Stream::new_ptr(tsStream_move(self.this)) } }
	fn is_opened(&self) -> bool { unsafe { tsStream_isOpened(self.this) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsStream_isMapped(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsStream_isAvailable(self.this) != 0 } }
	fn size(&self) -> usize { unsafe { tsStream_getSize(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsStream_getName(self.this)) } }
	fn tell(&mut self) -> usize { unsafe { tsStream_tell(self.this) } }
	fn seek(&mut self, offset: usize) -> bool { unsafe { tsStream_seek(self.this, offset) != 0 } }
	fn seek_back(&mut self, offset: usize) -> bool { unsafe { tsStream_seekBack(self.this, offset) != 0 } }
	fn seek_cur(&mut self, offset: i64) -> bool { unsafe { tsStream_seekCur(self.this, offset) != 0 } }
	fn data(&self) -> *const u8 { unsafe { tsStream_getData(self.this) } }
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_read(self.this, dest, size) } }
	fn write(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_write(self.this, src, size) } }
	fn flush(&mut self) -> bool { unsafe { tsStream_flush(self.this) != 0 } }
	fn puts(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_puts_s(self.this, str_.as_ptr()) != 0 }
	}
	fn puts_with_str(&mut self, str: &String) -> bool { unsafe { tsStream_puts_cS(self.this, str.this) != 0 } }
	fn printf(&mut self, format: &str) -> bool {
		let format_ = CString::new(format).unwrap();
		unsafe { tsStream_printf(self.this, format_.as_ptr()) != 0 }
	}
	fn gets(&mut self) -> string::String { unsafe { get_string(tsStream_gets(self.this, ptr::null_mut())) } }
	fn gets_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_gets(self.this, status)) } }
	fn readi8(&mut self) -> i8 { unsafe { tsStream_readi8(self.this, ptr::null_mut()) } }
	fn readi8_with_status(&mut self, status: *mut u8) -> i8 { unsafe { tsStream_readi8(self.this, status) } }
	fn writei8(&mut self, value: i8) -> bool { unsafe { tsStream_writei8(self.this, value) != 0 } }
	fn readu8(&mut self) -> u8 { unsafe { tsStream_readu8(self.this, ptr::null_mut()) } }
	fn readu8_with_status(&mut self, status: *mut u8) -> u8 { unsafe { tsStream_readu8(self.this, status) } }
	fn writeu8(&mut self, value: u8) -> bool { unsafe { tsStream_writeu8(self.this, value) != 0 } }
	fn readi16(&mut self) -> i16 { unsafe { tsStream_readi16(self.this, ptr::null_mut()) } }
	fn readi16_with_status(&mut self, status: *mut u8) -> i16 { unsafe { tsStream_readi16(self.this, status) } }
	fn writei16(&mut self, value: i16) -> bool { unsafe { tsStream_writei16(self.this, value) != 0 } }
	fn readu16(&mut self) -> u16 { unsafe { tsStream_readu16(self.this, ptr::null_mut()) } }
	fn readu16_with_status(&mut self, status: *mut u8) -> u16 { unsafe { tsStream_readu16(self.this, status) } }
	fn writeu16(&mut self, value: u16) -> bool { unsafe { tsStream_writeu16(self.this, value) != 0 } }
	fn readi32(&mut self) -> i32 { unsafe { tsStream_readi32(self.this, ptr::null_mut()) } }
	fn readi32_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32(self.this, status) } }
	fn writei32(&mut self, value: i32) -> bool { unsafe { tsStream_writei32(self.this, value) != 0 } }
	fn readu32(&mut self) -> u32 { unsafe { tsStream_readu32(self.this, ptr::null_mut()) } }
	fn readu32_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32(self.this, status) } }
	fn writeu32(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32(self.this, value) != 0 } }
	fn readi64(&mut self) -> i64 { unsafe { tsStream_readi64(self.this, ptr::null_mut()) } }
	fn readi64_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64(self.this, status) } }
	fn writei64(&mut self, value: i64) -> bool { unsafe { tsStream_writei64(self.this, value) != 0 } }
	fn readu64(&mut self) -> u64 { unsafe { tsStream_readu64(self.this, ptr::null_mut()) } }
	fn readu64_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64(self.this, status) } }
	fn writeu64(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64(self.this, value) != 0 } }
	fn readf32(&mut self) -> f32 { unsafe { tsStream_readf32(self.this, ptr::null_mut()) } }
	fn readf32_with_status(&mut self, status: *mut u8) -> f32 { unsafe { tsStream_readf32(self.this, status) } }
	fn writef32(&mut self, value: f32) -> bool { unsafe { tsStream_writef32(self.this, value) != 0 } }
	fn readf64(&mut self) -> f64 { unsafe { tsStream_readf64(self.this, ptr::null_mut()) } }
	fn readf64_with_status(&mut self, status: *mut u8) -> f64 { unsafe { tsStream_readf64(self.this, status) } }
	fn writef64(&mut self, value: f64) -> bool { unsafe { tsStream_writef64(self.this, value) != 0 } }
	fn readi32e(&mut self) -> i32 { unsafe { tsStream_readi32e(self.this, ptr::null_mut()) } }
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32e(self.this, status) } }
	fn writei32e(&mut self, value: i32) -> bool { unsafe { tsStream_writei32e(self.this, value) != 0 } }
	fn readu32e(&mut self) -> u32 { unsafe { tsStream_readu32e(self.this, ptr::null_mut()) } }
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32e(self.this, status) } }
	fn writeu32e(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32e(self.this, value) != 0 } }
	fn readi64e(&mut self) -> i64 { unsafe { tsStream_readi64e(self.this, ptr::null_mut()) } }
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64e(self.this, status) } }
	fn writei64e(&mut self, value: i64) -> bool { unsafe { tsStream_writei64e(self.this, value) != 0 } }
	fn readu64e(&mut self) -> u64 { unsafe { tsStream_readu64e(self.this, ptr::null_mut()) } }
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64e(self.this, status) } }
	fn writeu64e(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64e(self.this, value) != 0 } }
	fn read_string(&mut self) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, ptr::null_mut())) } }
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, status)) } }
	fn write_string_with_strs(&mut self, str: &String) -> bool { unsafe { tsStream_writeString_cS(self.this, str.this) != 0 } }
	fn write_string_with_str(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_s(self.this, str_.as_ptr()) != 0 }
	}
	fn read_string_with_term(&mut self, term: c_char) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, ptr::null_mut(), MAXU32)) } }
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, MAXU32)) } }
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, size)) } }
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool { unsafe { tsStream_writeString_cSc(self.this, str.this, term) != 0 } }
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_sc(self.this, str_.as_ptr(), term) != 0 }
	}
	fn read_token(&mut self) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, ptr::null_mut())) } }
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, status)) } }
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, 1) != 0 } }
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, if clear {1} else {0}) != 0 } }
	fn read_line(&mut self) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, ptr::null_mut())) } }
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, status)) } }
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, 0, 1) != 0 } }
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, 1) != 0 } }
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, if clear {1} else {0}) != 0 } }
	fn read_stream(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_readStream(self.this, dest.this, 0, ptr::null_mut()) } }
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, ptr::null_mut()) } }
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, status) } }
	fn write_stream(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_writeStream(self.this, src.this, 0, ptr::null_mut()) } }
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, ptr::null_mut()) } }
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, status) } }
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readZip(self.this, dest, size) } }
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZip(self.this, src, size, -1) } }
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeZip(self.this, src, size, level) } }
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipFast(self.this, src, size) } }
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipBest(self.this, src, size) } }
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readLz4(self.this, dest, size) } }
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, -1) } }
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, level) } }
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Fast(self.this, src, size) } }
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Best(self.this, src, size) } }
	fn decode_zip(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, 0, ptr::null_mut(), 15) } }
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, ptr::null_mut(), 15) } }
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, 15) } }
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, window) } }
	fn encode_zip(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, -1) } }
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, level) } }
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, status) } }
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, status) } }
	fn decode_lz4(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, 0, ptr::null_mut()) } }
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, ptr::null_mut()) } }
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, status) } }
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, -1) } }
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, level) } }
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, status) } }
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, status) } }
}
impl Drop for Socket {
	fn drop(&mut self) { if self.owner { unsafe { tsSocket_delete(self.this) } } }
}
impl Clone for Socket {
	fn clone(&self) -> Socket { unsafe { Socket { this: tsSocket_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Socket { }
impl fmt::Display for Socket {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Socket ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSocket_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSocket_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSocket_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSocket_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSocket_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSocket_new(type_: SocketType) -> *mut c_void;
	fn tsSocket_delete(this: *mut c_void);
	fn tsSocket_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSocket_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSocket_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSocket_clearPtr(this: *const c_void);
	fn tsSocket_destroyPtr(this: *const c_void);
	fn tsSocket_acquirePtr(this: *const c_void);
	fn tsSocket_unacquirePtr(this: *const c_void);
	fn tsSocket_isValidPtr(this: *const c_void) -> i32;
	fn tsSocket_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSocket_isConstPtr(this: *const c_void) -> i32;
	fn tsSocket_getCountPtr(this: *const c_void) -> u32;
	fn tsSocket_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSocket_open_u16u16(this: *mut c_void, port: u16, num: u16) -> i32;
	fn tsSocket_open_su16(this: *mut c_void, name: *const c_char, port: u16) -> i32;
	fn tsSocket_open_cSu16(this: *mut c_void, name: *mut c_void, port: u16) -> i32;
	fn tsSocket_close(this: *mut c_void);
	fn tsSocket_connect(this: *mut c_void, sec: u32, usec: u32) -> i32;
	fn tsSocket_accept(this: *mut c_void, socket: *mut c_void) -> i32;
	fn tsSocket_select(this: *mut c_void, sec: u32, usec: u32) -> i32;
	fn tsSocket_setTimeout(this: *mut c_void, sec: u32) -> i32;
	fn tsSocket_getTimeout(this: *const c_void) -> u32;
	fn tsSocket_setBlock(this: *mut c_void, block: i32) -> i32;
	fn tsSocket_getBlock(this: *const c_void) -> i32;
	fn tsSocket_setDelay(this: *mut c_void, delay: i32) -> i32;
	fn tsSocket_getDelay(this: *const c_void) -> i32;
	fn tsSocket_setName_s(this: *mut c_void, name: *const c_char);
	fn tsSocket_setName_cS(this: *mut c_void, name: *mut c_void);
	fn tsSocket_getPort(this: *const c_void) -> u16;
	fn tsSocket_getFD(this: *const c_void) -> i32;
	fn tsSocket_getType(this: *const c_void) -> SocketType;
	fn tsSocket_getAddress(delimiter: *const c_char) -> *mut c_void;
}

// Tellusim::SocketSSL
pub struct SocketSSL {
	this: *mut c_void,
	owner: bool,
}
impl SocketSSL {
	pub fn null() -> SocketSSL { SocketSSL { this: ptr::null_mut(), owner: false } }
	pub fn new() -> SocketSSL { unsafe { SocketSSL { this: tsSocketSSL_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> SocketSSL { unsafe { SocketSSL { this: ptr, owner: tsSocketSSL_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> SocketSSL { unsafe { SocketSSL { this: tsSocketSSL_copyPtr(self.this), owner: true } } }
	pub fn from_socket(ptr: &Socket) -> SocketSSL { unsafe { SocketSSL::new_ptr(tsSocketSSL_castSocketPtr(ptr.this)) } }
	pub fn to_socket(&self) -> Socket { unsafe { Socket::new_ptr(tsSocketSSL_baseSocketPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: SocketSSL) -> bool { unsafe { tsSocketSSL_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> SocketSSL { unsafe { SocketSSL { this: tsSocketSSL_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSocketSSL_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSocketSSL_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSocketSSL_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSocketSSL_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSocketSSL_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSocketSSL_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSocketSSL_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSocketSSL_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSocketSSL_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn handshake(&mut self) -> bool { unsafe { tsSocketSSL_handshake(self.this, ptr::null_mut()) != 0 } }
	pub fn handshake_with_name(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSocketSSL_handshake(self.this, name_.as_ptr()) != 0 }
	}
	pub fn accept(&mut self, socket: &mut SocketSSL) -> bool { unsafe { tsSocketSSL_accept_SS(self.this, socket.this) != 0 } }
	pub fn accept_with_socket(&mut self, socket: &mut Socket) -> bool { unsafe { tsSocketSSL_accept_S(self.this, socket.this) != 0 } }
	pub fn load(&mut self, stream: &mut Stream) -> bool { unsafe { tsSocketSSL_load_St(self.this, stream.this) != 0 } }
	pub fn load_with_name(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSocketSSL_load_s(self.this, name_.as_ptr()) != 0 }
	}
	pub fn load_with_names(&mut self, name: &String) -> bool { unsafe { tsSocketSSL_load_cS(self.this, name.this) != 0 } }
	pub fn is_connected(&self) -> bool { unsafe { tsSocketSSL_isConnected(self.this) != 0 } }
}
impl SocketTrait for SocketSSL {
	fn open(&mut self, port: u16) -> bool { unsafe { tsSocket_open_u16u16(self.this, port, 32) != 0 } }
	fn open_with_num(&mut self, port: u16, num: u16) -> bool { unsafe { tsSocket_open_u16u16(self.this, port, num) != 0 } }
	fn open_with_name(&mut self, name: &str, port: u16) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSocket_open_su16(self.this, name_.as_ptr(), port) != 0 }
	}
	fn open_with_names(&mut self, name: &String, port: u16) -> bool { unsafe { tsSocket_open_cSu16(self.this, name.this, port) != 0 } }
	fn close(&mut self) { unsafe { tsSocket_close(self.this) } }
	fn connect(&mut self, sec: u32) -> bool { unsafe { tsSocket_connect(self.this, sec, 0) != 0 } }
	fn connect_with_usec(&mut self, sec: u32, usec: u32) -> bool { unsafe { tsSocket_connect(self.this, sec, usec) != 0 } }
	fn accept(&mut self, socket: &mut Socket) -> bool { unsafe { tsSocket_accept(self.this, socket.this) != 0 } }
	fn select(&mut self, sec: u32) -> bool { unsafe { tsSocket_select(self.this, sec, 0) != 0 } }
	fn select_with_usec(&mut self, sec: u32, usec: u32) -> bool { unsafe { tsSocket_select(self.this, sec, usec) != 0 } }
	fn set_timeout(&mut self, sec: u32) -> bool { unsafe { tsSocket_setTimeout(self.this, sec) != 0 } }
	fn timeout(&self) -> u32 { unsafe { tsSocket_getTimeout(self.this) } }
	fn set_block(&mut self, block: bool) -> bool { unsafe { tsSocket_setBlock(self.this, if block {1} else {0}) != 0 } }
	fn block(&self) -> bool { unsafe { tsSocket_getBlock(self.this) != 0 } }
	fn set_delay(&mut self, delay: bool) -> bool { unsafe { tsSocket_setDelay(self.this, if delay {1} else {0}) != 0 } }
	fn delay(&self) -> bool { unsafe { tsSocket_getDelay(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSocket_setName_s(self.this, name_.as_ptr()) }
	}
	fn set_name_with_name(&mut self, name: &String) { unsafe { tsSocket_setName_cS(self.this, name.this) } }
	fn port(&self) -> u16 { unsafe { tsSocket_getPort(self.this) } }
	fn fd(&self) -> i32 { unsafe { tsSocket_getFD(self.this) } }
	fn type_(&self) -> SocketType { unsafe { tsSocket_getType(self.this) } }
	fn address() -> string::String { unsafe { get_string(tsSocket_getAddress(ptr::null_mut())) } }
	fn address_with_delimiter(delimiter: &str) -> string::String {
		let delimiter_ = CString::new(delimiter).unwrap();
		unsafe { get_string(tsSocket_getAddress(delimiter_.as_ptr())) }
	}
}
impl StreamTrait for SocketSSL {
	fn move_(&mut self) -> Stream { unsafe { Stream::new_ptr(tsStream_move(self.this)) } }
	fn is_opened(&self) -> bool { unsafe { tsStream_isOpened(self.this) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsStream_isMapped(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsStream_isAvailable(self.this) != 0 } }
	fn size(&self) -> usize { unsafe { tsStream_getSize(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsStream_getName(self.this)) } }
	fn tell(&mut self) -> usize { unsafe { tsStream_tell(self.this) } }
	fn seek(&mut self, offset: usize) -> bool { unsafe { tsStream_seek(self.this, offset) != 0 } }
	fn seek_back(&mut self, offset: usize) -> bool { unsafe { tsStream_seekBack(self.this, offset) != 0 } }
	fn seek_cur(&mut self, offset: i64) -> bool { unsafe { tsStream_seekCur(self.this, offset) != 0 } }
	fn data(&self) -> *const u8 { unsafe { tsStream_getData(self.this) } }
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_read(self.this, dest, size) } }
	fn write(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_write(self.this, src, size) } }
	fn flush(&mut self) -> bool { unsafe { tsStream_flush(self.this) != 0 } }
	fn puts(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_puts_s(self.this, str_.as_ptr()) != 0 }
	}
	fn puts_with_str(&mut self, str: &String) -> bool { unsafe { tsStream_puts_cS(self.this, str.this) != 0 } }
	fn printf(&mut self, format: &str) -> bool {
		let format_ = CString::new(format).unwrap();
		unsafe { tsStream_printf(self.this, format_.as_ptr()) != 0 }
	}
	fn gets(&mut self) -> string::String { unsafe { get_string(tsStream_gets(self.this, ptr::null_mut())) } }
	fn gets_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_gets(self.this, status)) } }
	fn readi8(&mut self) -> i8 { unsafe { tsStream_readi8(self.this, ptr::null_mut()) } }
	fn readi8_with_status(&mut self, status: *mut u8) -> i8 { unsafe { tsStream_readi8(self.this, status) } }
	fn writei8(&mut self, value: i8) -> bool { unsafe { tsStream_writei8(self.this, value) != 0 } }
	fn readu8(&mut self) -> u8 { unsafe { tsStream_readu8(self.this, ptr::null_mut()) } }
	fn readu8_with_status(&mut self, status: *mut u8) -> u8 { unsafe { tsStream_readu8(self.this, status) } }
	fn writeu8(&mut self, value: u8) -> bool { unsafe { tsStream_writeu8(self.this, value) != 0 } }
	fn readi16(&mut self) -> i16 { unsafe { tsStream_readi16(self.this, ptr::null_mut()) } }
	fn readi16_with_status(&mut self, status: *mut u8) -> i16 { unsafe { tsStream_readi16(self.this, status) } }
	fn writei16(&mut self, value: i16) -> bool { unsafe { tsStream_writei16(self.this, value) != 0 } }
	fn readu16(&mut self) -> u16 { unsafe { tsStream_readu16(self.this, ptr::null_mut()) } }
	fn readu16_with_status(&mut self, status: *mut u8) -> u16 { unsafe { tsStream_readu16(self.this, status) } }
	fn writeu16(&mut self, value: u16) -> bool { unsafe { tsStream_writeu16(self.this, value) != 0 } }
	fn readi32(&mut self) -> i32 { unsafe { tsStream_readi32(self.this, ptr::null_mut()) } }
	fn readi32_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32(self.this, status) } }
	fn writei32(&mut self, value: i32) -> bool { unsafe { tsStream_writei32(self.this, value) != 0 } }
	fn readu32(&mut self) -> u32 { unsafe { tsStream_readu32(self.this, ptr::null_mut()) } }
	fn readu32_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32(self.this, status) } }
	fn writeu32(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32(self.this, value) != 0 } }
	fn readi64(&mut self) -> i64 { unsafe { tsStream_readi64(self.this, ptr::null_mut()) } }
	fn readi64_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64(self.this, status) } }
	fn writei64(&mut self, value: i64) -> bool { unsafe { tsStream_writei64(self.this, value) != 0 } }
	fn readu64(&mut self) -> u64 { unsafe { tsStream_readu64(self.this, ptr::null_mut()) } }
	fn readu64_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64(self.this, status) } }
	fn writeu64(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64(self.this, value) != 0 } }
	fn readf32(&mut self) -> f32 { unsafe { tsStream_readf32(self.this, ptr::null_mut()) } }
	fn readf32_with_status(&mut self, status: *mut u8) -> f32 { unsafe { tsStream_readf32(self.this, status) } }
	fn writef32(&mut self, value: f32) -> bool { unsafe { tsStream_writef32(self.this, value) != 0 } }
	fn readf64(&mut self) -> f64 { unsafe { tsStream_readf64(self.this, ptr::null_mut()) } }
	fn readf64_with_status(&mut self, status: *mut u8) -> f64 { unsafe { tsStream_readf64(self.this, status) } }
	fn writef64(&mut self, value: f64) -> bool { unsafe { tsStream_writef64(self.this, value) != 0 } }
	fn readi32e(&mut self) -> i32 { unsafe { tsStream_readi32e(self.this, ptr::null_mut()) } }
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32e(self.this, status) } }
	fn writei32e(&mut self, value: i32) -> bool { unsafe { tsStream_writei32e(self.this, value) != 0 } }
	fn readu32e(&mut self) -> u32 { unsafe { tsStream_readu32e(self.this, ptr::null_mut()) } }
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32e(self.this, status) } }
	fn writeu32e(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32e(self.this, value) != 0 } }
	fn readi64e(&mut self) -> i64 { unsafe { tsStream_readi64e(self.this, ptr::null_mut()) } }
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64e(self.this, status) } }
	fn writei64e(&mut self, value: i64) -> bool { unsafe { tsStream_writei64e(self.this, value) != 0 } }
	fn readu64e(&mut self) -> u64 { unsafe { tsStream_readu64e(self.this, ptr::null_mut()) } }
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64e(self.this, status) } }
	fn writeu64e(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64e(self.this, value) != 0 } }
	fn read_string(&mut self) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, ptr::null_mut())) } }
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, status)) } }
	fn write_string_with_strs(&mut self, str: &String) -> bool { unsafe { tsStream_writeString_cS(self.this, str.this) != 0 } }
	fn write_string_with_str(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_s(self.this, str_.as_ptr()) != 0 }
	}
	fn read_string_with_term(&mut self, term: c_char) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, ptr::null_mut(), MAXU32)) } }
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, MAXU32)) } }
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, size)) } }
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool { unsafe { tsStream_writeString_cSc(self.this, str.this, term) != 0 } }
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_sc(self.this, str_.as_ptr(), term) != 0 }
	}
	fn read_token(&mut self) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, ptr::null_mut())) } }
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, status)) } }
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, 1) != 0 } }
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, if clear {1} else {0}) != 0 } }
	fn read_line(&mut self) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, ptr::null_mut())) } }
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, status)) } }
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, 0, 1) != 0 } }
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, 1) != 0 } }
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, if clear {1} else {0}) != 0 } }
	fn read_stream(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_readStream(self.this, dest.this, 0, ptr::null_mut()) } }
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, ptr::null_mut()) } }
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, status) } }
	fn write_stream(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_writeStream(self.this, src.this, 0, ptr::null_mut()) } }
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, ptr::null_mut()) } }
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, status) } }
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readZip(self.this, dest, size) } }
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZip(self.this, src, size, -1) } }
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeZip(self.this, src, size, level) } }
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipFast(self.this, src, size) } }
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipBest(self.this, src, size) } }
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readLz4(self.this, dest, size) } }
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, -1) } }
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, level) } }
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Fast(self.this, src, size) } }
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Best(self.this, src, size) } }
	fn decode_zip(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, 0, ptr::null_mut(), 15) } }
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, ptr::null_mut(), 15) } }
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, 15) } }
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, window) } }
	fn encode_zip(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, -1) } }
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, level) } }
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, status) } }
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, status) } }
	fn decode_lz4(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, 0, ptr::null_mut()) } }
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, ptr::null_mut()) } }
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, status) } }
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, -1) } }
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, level) } }
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, status) } }
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, status) } }
}
impl Drop for SocketSSL {
	fn drop(&mut self) { if self.owner { unsafe { tsSocketSSL_delete(self.this) } } }
}
impl Clone for SocketSSL {
	fn clone(&self) -> SocketSSL { unsafe { SocketSSL { this: tsSocketSSL_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for SocketSSL { }
impl fmt::Display for SocketSSL {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::SocketSSL ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSocketSSL_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSocketSSL_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSocketSSL_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSocketSSL_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSocketSSL_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSocketSSL_new() -> *mut c_void;
	fn tsSocketSSL_delete(this: *mut c_void);
	fn tsSocketSSL_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSocketSSL_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSocketSSL_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSocketSSL_clearPtr(this: *const c_void);
	fn tsSocketSSL_destroyPtr(this: *const c_void);
	fn tsSocketSSL_acquirePtr(this: *const c_void);
	fn tsSocketSSL_unacquirePtr(this: *const c_void);
	fn tsSocketSSL_isValidPtr(this: *const c_void) -> i32;
	fn tsSocketSSL_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSocketSSL_isConstPtr(this: *const c_void) -> i32;
	fn tsSocketSSL_getCountPtr(this: *const c_void) -> u32;
	fn tsSocketSSL_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSocketSSL_equalSocketPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSocketSSL_castSocketPtr(this: *const c_void) -> *mut c_void;
	fn tsSocketSSL_baseSocketPtr(this: *const c_void) -> *mut c_void;
	fn tsSocketSSL_handshake(this: *mut c_void, name: *const c_char) -> i32;
	fn tsSocketSSL_accept_SS(this: *mut c_void, socket: *mut c_void) -> i32;
	fn tsSocketSSL_accept_S(this: *mut c_void, socket: *mut c_void) -> i32;
	fn tsSocketSSL_load_St(this: *mut c_void, stream: *mut c_void) -> i32;
	fn tsSocketSSL_load_s(this: *mut c_void, name: *const c_char) -> i32;
	fn tsSocketSSL_load_cS(this: *mut c_void, name: *mut c_void) -> i32;
	fn tsSocketSSL_isConnected(this: *const c_void) -> i32;
}

// Tellusim::Source
pub struct Source {
	this: *mut c_void,
	owner: bool,
}
type SourceIsCallback = unsafe extern "C" fn(name: *const c_char, data: *mut c_void) -> i32;
type SourceOpenCallback = unsafe extern "C" fn(name: *const c_char, data: *mut c_void) -> *mut c_void;
impl Source {
	pub fn null() -> Source { Source { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Source { unsafe { Source { this: tsSource_new(), owner: true } } }
	pub fn new_with_data(data: *const u8, size: usize) -> Source { unsafe { Source { this: tsSource_new_u8pzs(data, size, ptr::null_mut()), owner: true } } }
	pub fn new_with_data_name(data: *const u8, size: usize, name: &str) -> Source {
		let name_ = CString::new(name).unwrap();
		unsafe { Source { this: tsSource_new_u8pzs(data, size, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> Source { unsafe { Source { this: ptr, owner: tsSource_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Source { unsafe { Source { this: tsSource_copyPtr(self.this), owner: true } } }
	pub fn to_stream(&self) -> Stream { Stream { this: self.this, owner: false } }
	pub fn equal_ptr(&self, ptr: Source) -> bool { unsafe { tsSource_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Source { unsafe { Source { this: tsSource_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSource_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSource_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSource_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSource_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSource_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSource_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSource_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSource_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSource_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn open(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_open_sbb(self.this, name_.as_ptr(), 1, 0) != 0 }
	}
	pub fn open_with_callback(&mut self, name: &str, callback: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_open_sbb(self.this, name_.as_ptr(), if callback {1} else {0}, 0) != 0 }
	}
	pub fn open_with_callback_write(&mut self, name: &str, callback: bool, write: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_open_sbb(self.this, name_.as_ptr(), if callback {1} else {0}, if write {1} else {0}) != 0 }
	}
	pub fn open_with_name(&mut self, name: &String) -> bool { unsafe { tsSource_open_cSbb(self.this, name.this, 1, 0) != 0 } }
	pub fn open_with_name_callback(&mut self, name: &String, callback: bool) -> bool { unsafe { tsSource_open_cSbb(self.this, name.this, if callback {1} else {0}, 0) != 0 } }
	pub fn open_with_name_callback_write(&mut self, name: &String, callback: bool, write: bool) -> bool { unsafe { tsSource_open_cSbb(self.this, name.this, if callback {1} else {0}, if write {1} else {0}) != 0 } }
	pub fn close(&mut self) { unsafe { tsSource_close(self.this) } }
	pub fn set_name(&mut self, name: &str, offset: usize, size: usize) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_setName_szz(self.this, name_.as_ptr(), offset, size) }
	}
	pub fn set_name_with_name(&mut self, name: &String, offset: usize, size: usize) { unsafe { tsSource_setName_cSzz(self.this, name.this, offset, size) } }
	pub fn set_data(&mut self, data: *const u8, size: usize) { unsafe { tsSource_setData(self.this, data, size, ptr::null_mut()) } }
	pub fn set_data_with_name(&mut self, data: *const u8, size: usize, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_setData(self.this, data, size, name_.as_ptr()) }
	}
	pub fn is_source(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_isSource_s(name_.as_ptr()) != 0 }
	}
	pub fn is_source_with_name(name: &String) -> bool { unsafe { tsSource_isSource_cS(name.this) != 0 } }
	pub fn mtime(name: &str) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_getMTime(name_.as_ptr()) }
	}
	pub fn size(name: &str) -> usize {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSource_getSize(name_.as_ptr()) }
	}
}
impl StreamTrait for Source {
	fn move_(&mut self) -> Stream { unsafe { Stream::new_ptr(tsStream_move(self.this)) } }
	fn is_opened(&self) -> bool { unsafe { tsStream_isOpened(self.this) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsStream_isMapped(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsStream_isAvailable(self.this) != 0 } }
	fn size(&self) -> usize { unsafe { tsStream_getSize(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsStream_getName(self.this)) } }
	fn tell(&mut self) -> usize { unsafe { tsStream_tell(self.this) } }
	fn seek(&mut self, offset: usize) -> bool { unsafe { tsStream_seek(self.this, offset) != 0 } }
	fn seek_back(&mut self, offset: usize) -> bool { unsafe { tsStream_seekBack(self.this, offset) != 0 } }
	fn seek_cur(&mut self, offset: i64) -> bool { unsafe { tsStream_seekCur(self.this, offset) != 0 } }
	fn data(&self) -> *const u8 { unsafe { tsStream_getData(self.this) } }
	fn read(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_read(self.this, dest, size) } }
	fn write(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_write(self.this, src, size) } }
	fn flush(&mut self) -> bool { unsafe { tsStream_flush(self.this) != 0 } }
	fn puts(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_puts_s(self.this, str_.as_ptr()) != 0 }
	}
	fn puts_with_str(&mut self, str: &String) -> bool { unsafe { tsStream_puts_cS(self.this, str.this) != 0 } }
	fn printf(&mut self, format: &str) -> bool {
		let format_ = CString::new(format).unwrap();
		unsafe { tsStream_printf(self.this, format_.as_ptr()) != 0 }
	}
	fn gets(&mut self) -> string::String { unsafe { get_string(tsStream_gets(self.this, ptr::null_mut())) } }
	fn gets_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_gets(self.this, status)) } }
	fn readi8(&mut self) -> i8 { unsafe { tsStream_readi8(self.this, ptr::null_mut()) } }
	fn readi8_with_status(&mut self, status: *mut u8) -> i8 { unsafe { tsStream_readi8(self.this, status) } }
	fn writei8(&mut self, value: i8) -> bool { unsafe { tsStream_writei8(self.this, value) != 0 } }
	fn readu8(&mut self) -> u8 { unsafe { tsStream_readu8(self.this, ptr::null_mut()) } }
	fn readu8_with_status(&mut self, status: *mut u8) -> u8 { unsafe { tsStream_readu8(self.this, status) } }
	fn writeu8(&mut self, value: u8) -> bool { unsafe { tsStream_writeu8(self.this, value) != 0 } }
	fn readi16(&mut self) -> i16 { unsafe { tsStream_readi16(self.this, ptr::null_mut()) } }
	fn readi16_with_status(&mut self, status: *mut u8) -> i16 { unsafe { tsStream_readi16(self.this, status) } }
	fn writei16(&mut self, value: i16) -> bool { unsafe { tsStream_writei16(self.this, value) != 0 } }
	fn readu16(&mut self) -> u16 { unsafe { tsStream_readu16(self.this, ptr::null_mut()) } }
	fn readu16_with_status(&mut self, status: *mut u8) -> u16 { unsafe { tsStream_readu16(self.this, status) } }
	fn writeu16(&mut self, value: u16) -> bool { unsafe { tsStream_writeu16(self.this, value) != 0 } }
	fn readi32(&mut self) -> i32 { unsafe { tsStream_readi32(self.this, ptr::null_mut()) } }
	fn readi32_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32(self.this, status) } }
	fn writei32(&mut self, value: i32) -> bool { unsafe { tsStream_writei32(self.this, value) != 0 } }
	fn readu32(&mut self) -> u32 { unsafe { tsStream_readu32(self.this, ptr::null_mut()) } }
	fn readu32_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32(self.this, status) } }
	fn writeu32(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32(self.this, value) != 0 } }
	fn readi64(&mut self) -> i64 { unsafe { tsStream_readi64(self.this, ptr::null_mut()) } }
	fn readi64_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64(self.this, status) } }
	fn writei64(&mut self, value: i64) -> bool { unsafe { tsStream_writei64(self.this, value) != 0 } }
	fn readu64(&mut self) -> u64 { unsafe { tsStream_readu64(self.this, ptr::null_mut()) } }
	fn readu64_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64(self.this, status) } }
	fn writeu64(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64(self.this, value) != 0 } }
	fn readf32(&mut self) -> f32 { unsafe { tsStream_readf32(self.this, ptr::null_mut()) } }
	fn readf32_with_status(&mut self, status: *mut u8) -> f32 { unsafe { tsStream_readf32(self.this, status) } }
	fn writef32(&mut self, value: f32) -> bool { unsafe { tsStream_writef32(self.this, value) != 0 } }
	fn readf64(&mut self) -> f64 { unsafe { tsStream_readf64(self.this, ptr::null_mut()) } }
	fn readf64_with_status(&mut self, status: *mut u8) -> f64 { unsafe { tsStream_readf64(self.this, status) } }
	fn writef64(&mut self, value: f64) -> bool { unsafe { tsStream_writef64(self.this, value) != 0 } }
	fn readi32e(&mut self) -> i32 { unsafe { tsStream_readi32e(self.this, ptr::null_mut()) } }
	fn readi32e_with_status(&mut self, status: *mut u8) -> i32 { unsafe { tsStream_readi32e(self.this, status) } }
	fn writei32e(&mut self, value: i32) -> bool { unsafe { tsStream_writei32e(self.this, value) != 0 } }
	fn readu32e(&mut self) -> u32 { unsafe { tsStream_readu32e(self.this, ptr::null_mut()) } }
	fn readu32e_with_status(&mut self, status: *mut u8) -> u32 { unsafe { tsStream_readu32e(self.this, status) } }
	fn writeu32e(&mut self, value: u32) -> bool { unsafe { tsStream_writeu32e(self.this, value) != 0 } }
	fn readi64e(&mut self) -> i64 { unsafe { tsStream_readi64e(self.this, ptr::null_mut()) } }
	fn readi64e_with_status(&mut self, status: *mut u8) -> i64 { unsafe { tsStream_readi64e(self.this, status) } }
	fn writei64e(&mut self, value: i64) -> bool { unsafe { tsStream_writei64e(self.this, value) != 0 } }
	fn readu64e(&mut self) -> u64 { unsafe { tsStream_readu64e(self.this, ptr::null_mut()) } }
	fn readu64e_with_status(&mut self, status: *mut u8) -> u64 { unsafe { tsStream_readu64e(self.this, status) } }
	fn writeu64e(&mut self, value: u64) -> bool { unsafe { tsStream_writeu64e(self.this, value) != 0 } }
	fn read_string(&mut self) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, ptr::null_mut())) } }
	fn read_string_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_br(self.this, status)) } }
	fn write_string_with_strs(&mut self, str: &String) -> bool { unsafe { tsStream_writeString_cS(self.this, str.this) != 0 } }
	fn write_string_with_str(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_s(self.this, str_.as_ptr()) != 0 }
	}
	fn read_string_with_term(&mut self, term: c_char) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, ptr::null_mut(), MAXU32)) } }
	fn read_string_with_term_status(&mut self, term: c_char, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, MAXU32)) } }
	fn read_string_with_term_status_size(&mut self, term: c_char, status: *mut u8, size: u32) -> string::String { unsafe { get_string(tsStream_readString_cbru(self.this, term, status, size)) } }
	fn write_string_with_strs_term(&mut self, str: &String, term: c_char) -> bool { unsafe { tsStream_writeString_cSc(self.this, str.this, term) != 0 } }
	fn write_string_with_str_term(&mut self, str: &str, term: c_char) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsStream_writeString_sc(self.this, str_.as_ptr(), term) != 0 }
	}
	fn read_token(&mut self) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, ptr::null_mut())) } }
	fn read_token_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readToken_br(self.this, status)) } }
	fn read_token_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, 1) != 0 } }
	fn read_token_with_dest_clear(&mut self, dest: &mut String, clear: bool) -> bool { unsafe { tsStream_readToken_Sb(self.this, dest.this, if clear {1} else {0}) != 0 } }
	fn read_line(&mut self) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, ptr::null_mut())) } }
	fn read_line_with_status(&mut self, status: *mut u8) -> string::String { unsafe { get_string(tsStream_readLine_br(self.this, status)) } }
	fn read_line_with_dest(&mut self, dest: &mut String) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, 0, 1) != 0 } }
	fn read_line_with_dest_empty(&mut self, dest: &mut String, empty: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, 1) != 0 } }
	fn read_line_with_dest_empty_clear(&mut self, dest: &mut String, empty: bool, clear: bool) -> bool { unsafe { tsStream_readLine_Sbb(self.this, dest.this, if empty {1} else {0}, if clear {1} else {0}) != 0 } }
	fn read_stream(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_readStream(self.this, dest.this, 0, ptr::null_mut()) } }
	fn read_stream_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, ptr::null_mut()) } }
	fn read_stream_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_readStream(self.this, dest.this, size, status) } }
	fn write_stream(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_writeStream(self.this, src.this, 0, ptr::null_mut()) } }
	fn write_stream_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, ptr::null_mut()) } }
	fn write_stream_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_writeStream(self.this, src.this, size, status) } }
	fn read_zip(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readZip(self.this, dest, size) } }
	fn write_zip(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZip(self.this, src, size, -1) } }
	fn write_zip_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeZip(self.this, src, size, level) } }
	fn write_zip_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipFast(self.this, src, size) } }
	fn write_zip_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeZipBest(self.this, src, size) } }
	fn read_lz4(&mut self, dest: *mut c_void, size: usize) -> usize { unsafe { tsStream_readLz4(self.this, dest, size) } }
	fn write_lz4(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, -1) } }
	fn write_lz4_with_level(&mut self, src: *const c_void, size: usize, level: i32) -> usize { unsafe { tsStream_writeLz4(self.this, src, size, level) } }
	fn write_lz4_fast(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Fast(self.this, src, size) } }
	fn write_lz4_best(&mut self, src: *const c_void, size: usize) -> usize { unsafe { tsStream_writeLz4Best(self.this, src, size) } }
	fn decode_zip(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, 0, ptr::null_mut(), 15) } }
	fn decode_zip_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, ptr::null_mut(), 15) } }
	fn decode_zip_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, 15) } }
	fn decode_zip_with_size_status_window(&mut self, src: &mut Stream, size: usize, status: *mut u8, window: i32) -> usize { unsafe { tsStream_decodeZip(self.this, src.this, size, status, window) } }
	fn encode_zip(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_zip_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_zip_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, -1) } }
	fn encode_zip_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeZip(self.this, dest.this, size, status, level) } }
	fn encode_zip_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipFast(self.this, dest.this, size, status) } }
	fn encode_zip_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_zip_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_zip_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeZipBest(self.this, dest.this, size, status) } }
	fn decode_lz4(&mut self, src: &mut Stream) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, 0, ptr::null_mut()) } }
	fn decode_lz4_with_size(&mut self, src: &mut Stream, size: usize) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, ptr::null_mut()) } }
	fn decode_lz4_with_size_status(&mut self, src: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_decodeLz4(self.this, src.this, size, status) } }
	fn encode_lz4(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, 0, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, ptr::null_mut(), -1) } }
	fn encode_lz4_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, -1) } }
	fn encode_lz4_with_size_status_level(&mut self, dest: &mut Stream, size: usize, status: *mut u8, level: i32) -> usize { unsafe { tsStream_encodeLz4(self.this, dest.this, size, status, level) } }
	fn encode_lz4_fast(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_fast_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Fast(self.this, dest.this, size, status) } }
	fn encode_lz4_best(&mut self, dest: &mut Stream) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, 0, ptr::null_mut()) } }
	fn encode_lz4_best_with_size(&mut self, dest: &mut Stream, size: usize) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, ptr::null_mut()) } }
	fn encode_lz4_best_with_size_status(&mut self, dest: &mut Stream, size: usize, status: *mut u8) -> usize { unsafe { tsStream_encodeLz4Best(self.this, dest.this, size, status) } }
}
impl Drop for Source {
	fn drop(&mut self) { if self.owner { unsafe { tsSource_delete(self.this) } } }
}
impl Clone for Source {
	fn clone(&self) -> Source { unsafe { Source { this: tsSource_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Source { }
impl fmt::Display for Source {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Source ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSource_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSource_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSource_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSource_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSource_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSource_new() -> *mut c_void;
	fn tsSource_new_u8pzs(data: *const u8, size: usize, name: *const c_char) -> *mut c_void;
	fn tsSource_delete(this: *mut c_void);
	fn tsSource_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSource_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSource_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSource_clearPtr(this: *const c_void);
	fn tsSource_destroyPtr(this: *const c_void);
	fn tsSource_acquirePtr(this: *const c_void);
	fn tsSource_unacquirePtr(this: *const c_void);
	fn tsSource_isValidPtr(this: *const c_void) -> i32;
	fn tsSource_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSource_isConstPtr(this: *const c_void) -> i32;
	fn tsSource_getCountPtr(this: *const c_void) -> u32;
	fn tsSource_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSource_open_sbb(this: *mut c_void, name: *const c_char, callback: i32, write: i32) -> i32;
	fn tsSource_open_cSbb(this: *mut c_void, name: *mut c_void, callback: i32, write: i32) -> i32;
	fn tsSource_close(this: *mut c_void);
	fn tsSource_setName_szz(this: *mut c_void, name: *const c_char, offset: usize, size: usize);
	fn tsSource_setName_cSzz(this: *mut c_void, name: *mut c_void, offset: usize, size: usize);
	fn tsSource_setData(this: *mut c_void, data: *const u8, size: usize, name: *const c_char);
	fn tsSource_isSource_s(name: *const c_char) -> i32;
	fn tsSource_isSource_cS(name: *mut c_void) -> i32;
	fn tsSource_getMTime(name: *const c_char) -> u64;
	fn tsSource_getSize(name: *const c_char) -> usize;
}

// Tellusim::Date
pub struct Date {
	this: *mut c_void,
	owner: bool,
}
impl Date {
	pub fn null() -> Date { Date { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Date { unsafe { Date { this: tsDate_new(), owner: true } } }
	pub fn new_with_time(time: i64) -> Date { unsafe { Date { this: tsDate_new_i64b(time, 1), owner: true } } }
	pub fn new_with_time_local(time: i64, local: bool) -> Date { unsafe { Date { this: tsDate_new_i64b(time, if local {1} else {0}), owner: true } } }
	pub fn new_with_str(str: &str) -> Date {
		let str_ = CString::new(str).unwrap();
		unsafe { Date { this: tsDate_new_ss(str_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_str_format(str: &str, format: &str) -> Date {
		let str_ = CString::new(str).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Date { this: tsDate_new_ss(str_.as_ptr(), format_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> Date { unsafe { Date { this: ptr, owner: tsDate_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Date { unsafe { Date { this: tsDate_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Date) -> bool { unsafe { tsDate_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Date { unsafe { Date { this: tsDate_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDate_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDate_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDate_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDate_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDate_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDate_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDate_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDate_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDate_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsDate_clear(self.this) } }
	pub fn set_time(&mut self, time: i64) { unsafe { tsDate_setTime(self.this, time, 1) } }
	pub fn set_time_with_local(&mut self, time: i64, local: bool) { unsafe { tsDate_setTime(self.this, time, if local {1} else {0}) } }
	pub fn time(&self) -> i64 { unsafe { tsDate_getTime(self.this, 1) } }
	pub fn time_with_local(&self, local: bool) -> i64 { unsafe { tsDate_getTime(self.this, if local {1} else {0}) } }
	pub fn set_string(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsDate_setString(self.this, str_.as_ptr(), ptr::null_mut()) != 0 }
	}
	pub fn set_string_with_format(&mut self, str: &str, format: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsDate_setString(self.this, str_.as_ptr(), format_.as_ptr()) != 0 }
	}
	pub fn string(&self) -> string::String { unsafe { get_string(tsDate_getString(self.this, ptr::null_mut())) } }
	pub fn string_with_format(&self, format: &str) -> string::String {
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsDate_getString(self.this, format_.as_ptr())) }
	}
	pub fn set_year(&mut self, year: u32) { unsafe { tsDate_setYear(self.this, year) } }
	pub fn set_month(&mut self, month: u32) { unsafe { tsDate_setMonth(self.this, month) } }
	pub fn set_date(&mut self, date: u32) { unsafe { tsDate_setDate(self.this, date) } }
	pub fn set_day(&mut self, day: u32) { unsafe { tsDate_setDay(self.this, day) } }
	pub fn set_hours(&mut self, hours: u32) { unsafe { tsDate_setHours(self.this, hours) } }
	pub fn set_minutes(&mut self, minutes: u32) { unsafe { tsDate_setMinutes(self.this, minutes) } }
	pub fn set_seconds(&mut self, seconds: u32) { unsafe { tsDate_setSeconds(self.this, seconds) } }
	pub fn year(&self) -> u32 { unsafe { tsDate_getYear(self.this) } }
	pub fn month(&self) -> u32 { unsafe { tsDate_getMonth(self.this) } }
	pub fn date(&self) -> u32 { unsafe { tsDate_getDate(self.this) } }
	pub fn day(&self) -> u32 { unsafe { tsDate_getDay(self.this) } }
	pub fn hours(&self) -> u32 { unsafe { tsDate_getHours(self.this) } }
	pub fn minutes(&self) -> u32 { unsafe { tsDate_getMinutes(self.this) } }
	pub fn seconds(&self) -> u32 { unsafe { tsDate_getSeconds(self.this) } }
	pub fn time_zone() -> i32 { unsafe { tsDate_getTimeZone() } }
}
impl Drop for Date {
	fn drop(&mut self) { if self.owner { unsafe { tsDate_delete(self.this) } } }
}
impl Clone for Date {
	fn clone(&self) -> Date { unsafe { Date { this: tsDate_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Date { }
impl fmt::Display for Date {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Date ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDate_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDate_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDate_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDate_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDate_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDate_new() -> *mut c_void;
	fn tsDate_new_i64b(time: i64, local: i32) -> *mut c_void;
	fn tsDate_new_ss(str: *const c_char, format: *const c_char) -> *mut c_void;
	fn tsDate_delete(this: *mut c_void);
	fn tsDate_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDate_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDate_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDate_clearPtr(this: *const c_void);
	fn tsDate_destroyPtr(this: *const c_void);
	fn tsDate_acquirePtr(this: *const c_void);
	fn tsDate_unacquirePtr(this: *const c_void);
	fn tsDate_isValidPtr(this: *const c_void) -> i32;
	fn tsDate_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDate_isConstPtr(this: *const c_void) -> i32;
	fn tsDate_getCountPtr(this: *const c_void) -> u32;
	fn tsDate_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDate_clear(this: *mut c_void);
	fn tsDate_setTime(this: *mut c_void, time: i64, local: i32);
	fn tsDate_getTime(this: *const c_void, local: i32) -> i64;
	fn tsDate_setString(this: *mut c_void, str: *const c_char, format: *const c_char) -> i32;
	fn tsDate_getString(this: *const c_void, format: *const c_char) -> *mut c_void;
	fn tsDate_setYear(this: *mut c_void, year: u32);
	fn tsDate_setMonth(this: *mut c_void, month: u32);
	fn tsDate_setDate(this: *mut c_void, date: u32);
	fn tsDate_setDay(this: *mut c_void, day: u32);
	fn tsDate_setHours(this: *mut c_void, hours: u32);
	fn tsDate_setMinutes(this: *mut c_void, minutes: u32);
	fn tsDate_setSeconds(this: *mut c_void, seconds: u32);
	fn tsDate_getYear(this: *const c_void) -> u32;
	fn tsDate_getMonth(this: *const c_void) -> u32;
	fn tsDate_getDate(this: *const c_void) -> u32;
	fn tsDate_getDay(this: *const c_void) -> u32;
	fn tsDate_getHours(this: *const c_void) -> u32;
	fn tsDate_getMinutes(this: *const c_void) -> u32;
	fn tsDate_getSeconds(this: *const c_void) -> u32;
	fn tsDate_getTimeZone() -> i32;
}

// Tellusim::Info
pub struct Info {
	this: *mut c_void,
	owner: bool,
}
impl Info {
	pub fn null() -> Info { Info { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Info { unsafe { Info { this: tsInfo_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Info { unsafe { Info { this: ptr, owner: tsInfo_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Info { unsafe { Info { this: tsInfo_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Info) -> bool { unsafe { tsInfo_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Info { unsafe { Info { this: tsInfo_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsInfo_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsInfo_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsInfo_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsInfo_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsInfo_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsInfo_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsInfo_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsInfo_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsInfo_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn system_memory(&self) -> usize { unsafe { tsInfo_getSystemMemory(self.this) } }
	pub fn system_uptime(&self) -> u64 { unsafe { tsInfo_getSystemUptime(self.this) } }
	pub fn system_name(&self) -> string::String { unsafe { get_string(tsInfo_getSystemName(self.this)) } }
	pub fn system_version(&self) -> string::String { unsafe { get_string(tsInfo_getSystemVersion(self.this)) } }
	pub fn kernel_version(&self) -> string::String { unsafe { get_string(tsInfo_getKernelVersion(self.this)) } }
	pub fn cpu_count(&self) -> u32 { unsafe { tsInfo_getCPUCount(self.this) } }
	pub fn cpu_name(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getCPUName(self.this, index)) } }
	pub fn cpu_vendor(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getCPUVendor(self.this, index)) } }
	pub fn cpu_cores(&self, index: u32) -> u32 { unsafe { tsInfo_getCPUCores(self.this, index) } }
	pub fn cpu_threads(&self, index: u32) -> u32 { unsafe { tsInfo_getCPUThreads(self.this, index) } }
	pub fn cpu_frequency(&self, index: u32) -> u64 { unsafe { tsInfo_getCPUFrequency(self.this, index) } }
	pub fn cpu_temperature(&self, index: u32) -> u32 { unsafe { tsInfo_getCPUTemperature(self.this, index) } }
	pub fn cpu_utilization(&self, index: u32) -> u32 { unsafe { tsInfo_getCPUUtilization(self.this, index) } }
	pub fn cpu_fan_speed(&self, index: u32) -> u32 { unsafe { tsInfo_getCPUFanSpeed(self.this, index) } }
	pub fn cpu_power(&self, index: u32) -> u32 { unsafe { tsInfo_getCPUPower(self.this, index) } }
	pub fn gpu_count(&self) -> u32 { unsafe { tsInfo_getGPUCount(self.this) } }
	pub fn gpu_name(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getGPUName(self.this, index)) } }
	pub fn gpu_vendor(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getGPUVendor(self.this, index)) } }
	pub fn gpu_serial(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getGPUSerial(self.this, index)) } }
	pub fn gpu_device(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getGPUDevice(self.this, index)) } }
	pub fn gpu_version(&self, index: u32) -> string::String { unsafe { get_string(tsInfo_getGPUVersion(self.this, index)) } }
	pub fn gpu_memory(&self, index: u32) -> usize { unsafe { tsInfo_getGPUMemory(self.this, index) } }
	pub fn gpu_screens(&self, index: u32) -> u32 { unsafe { tsInfo_getGPUScreens(self.this, index) } }
	pub fn gpu_frequency(&self, index: u32) -> u64 { unsafe { tsInfo_getGPUFrequency(self.this, index) } }
	pub fn gpu_temperature(&self, index: u32) -> u32 { unsafe { tsInfo_getGPUTemperature(self.this, index) } }
	pub fn gpu_utilization(&self, index: u32) -> u32 { unsafe { tsInfo_getGPUUtilization(self.this, index) } }
	pub fn gpu_fan_speed(&self, index: u32) -> u32 { unsafe { tsInfo_getGPUFanSpeed(self.this, index) } }
	pub fn gpu_power(&self, index: u32) -> u32 { unsafe { tsInfo_getGPUPower(self.this, index) } }
	pub fn is_gpu_throttling(&self, index: u32) -> bool { unsafe { tsInfo_isGPUThrottling(self.this, index) != 0 } }
}
impl Drop for Info {
	fn drop(&mut self) { if self.owner { unsafe { tsInfo_delete(self.this) } } }
}
impl Clone for Info {
	fn clone(&self) -> Info { unsafe { Info { this: tsInfo_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Info { }
impl fmt::Display for Info {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Info ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsInfo_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsInfo_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsInfo_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsInfo_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsInfo_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsInfo_new() -> *mut c_void;
	fn tsInfo_delete(this: *mut c_void);
	fn tsInfo_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsInfo_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsInfo_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsInfo_clearPtr(this: *const c_void);
	fn tsInfo_destroyPtr(this: *const c_void);
	fn tsInfo_acquirePtr(this: *const c_void);
	fn tsInfo_unacquirePtr(this: *const c_void);
	fn tsInfo_isValidPtr(this: *const c_void) -> i32;
	fn tsInfo_isOwnerPtr(this: *const c_void) -> i32;
	fn tsInfo_isConstPtr(this: *const c_void) -> i32;
	fn tsInfo_getCountPtr(this: *const c_void) -> u32;
	fn tsInfo_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsInfo_getSystemMemory(this: *const c_void) -> usize;
	fn tsInfo_getSystemUptime(this: *const c_void) -> u64;
	fn tsInfo_getSystemName(this: *const c_void) -> *mut c_void;
	fn tsInfo_getSystemVersion(this: *const c_void) -> *mut c_void;
	fn tsInfo_getKernelVersion(this: *const c_void) -> *mut c_void;
	fn tsInfo_getCPUCount(this: *const c_void) -> u32;
	fn tsInfo_getCPUName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getCPUVendor(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getCPUCores(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getCPUThreads(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getCPUFrequency(this: *const c_void, index: u32) -> u64;
	fn tsInfo_getCPUTemperature(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getCPUUtilization(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getCPUFanSpeed(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getCPUPower(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getGPUCount(this: *const c_void) -> u32;
	fn tsInfo_getGPUName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getGPUVendor(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getGPUSerial(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getGPUDevice(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getGPUVersion(this: *const c_void, index: u32) -> *mut c_void;
	fn tsInfo_getGPUMemory(this: *const c_void, index: u32) -> usize;
	fn tsInfo_getGPUScreens(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getGPUFrequency(this: *const c_void, index: u32) -> u64;
	fn tsInfo_getGPUTemperature(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getGPUUtilization(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getGPUFanSpeed(this: *const c_void, index: u32) -> u32;
	fn tsInfo_getGPUPower(this: *const c_void, index: u32) -> u32;
	fn tsInfo_isGPUThrottling(this: *const c_void, index: u32) -> i32;
}

// Tellusim::Directory
pub struct Directory {
	this: *mut c_void,
	owner: bool,
}
impl Directory {
	pub fn null() -> Directory { Directory { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Directory { unsafe { Directory { this: tsDirectory_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Directory { unsafe { Directory { this: ptr, owner: tsDirectory_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Directory { unsafe { Directory { this: tsDirectory_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Directory) -> bool { unsafe { tsDirectory_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Directory { unsafe { Directory { this: tsDirectory_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDirectory_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDirectory_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDirectory_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDirectory_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDirectory_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDirectory_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDirectory_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDirectory_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDirectory_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn open(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_open_sb(self.this, name_.as_ptr(), 0) != 0 }
	}
	pub fn open_with_children(&mut self, name: &str, children: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_open_sb(self.this, name_.as_ptr(), if children {1} else {0}) != 0 }
	}
	pub fn open_with_name(&mut self, name: &String) -> bool { unsafe { tsDirectory_open_cSb(self.this, name.this, 0) != 0 } }
	pub fn open_with_name_children(&mut self, name: &String, children: bool) -> bool { unsafe { tsDirectory_open_cSb(self.this, name.this, if children {1} else {0}) != 0 } }
	pub fn close(&mut self) { unsafe { tsDirectory_close(self.this) } }
	pub fn is_opened(&self) -> bool { unsafe { tsDirectory_isOpened(self.this) != 0 } }
	pub fn name(&self) -> string::String { unsafe { get_string(tsDirectory_getName(self.this)) } }
	pub fn num_files(&self) -> u32 { unsafe { tsDirectory_getNumFiles(self.this) } }
	pub fn file_name(&self, index: u32) -> string::String { unsafe { get_string(tsDirectory_getFileName(self.this, index)) } }
	pub fn file_attributes(&self, index: u32) -> DirectoryAttributes { unsafe { tsDirectory_getFileAttributes_cu(self.this, index) } }
	pub fn file_mtime(&self, index: u32) -> u64 { unsafe { tsDirectory_getFileMTime_cu(self.this, index) } }
	pub fn file_atime(&self, index: u32) -> u64 { unsafe { tsDirectory_getFileATime_cu(self.this, index) } }
	pub fn file_ctime(&self, index: u32) -> u64 { unsafe { tsDirectory_getFileCTime_cu(self.this, index) } }
	pub fn file_size(&self, index: u32) -> usize { unsafe { tsDirectory_getFileSize_cu(self.this, index) } }
	pub fn num_directories(&self) -> u32 { unsafe { tsDirectory_getNumDirectories(self.this) } }
	pub fn directory_name(&self, index: u32) -> string::String { unsafe { get_string(tsDirectory_getDirectoryName(self.this, index)) } }
	pub fn directory_attributes(&self, index: u32) -> DirectoryAttributes { unsafe { tsDirectory_getDirectoryAttributes(self.this, index) } }
	pub fn directory_ctime(&self, index: u32) -> u64 { unsafe { tsDirectory_getDirectoryCTime(self.this, index) } }
	pub fn directory_size(&self, index: u32) -> u32 { unsafe { tsDirectory_getDirectorySize(self.this, index) } }
	pub fn is_file(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_isFile_s(name_.as_ptr()) != 0 }
	}
	pub fn is_file_with_name(name: &String) -> bool { unsafe { tsDirectory_isFile_cS(name.this) != 0 } }
	pub fn set_file_attributes(name: &str, attributes: DirectoryAttributes) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_setFileAttributes(name_.as_ptr(), attributes) != 0 }
	}
	pub fn file_attributes_with_name(name: &str) -> DirectoryAttributes {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_getFileAttributes_s(name_.as_ptr()) }
	}
	pub fn set_file_mtime(name: &str, time: u64) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_setFileMTime(name_.as_ptr(), time) != 0 }
	}
	pub fn file_mtime_with_name(name: &str) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_getFileMTime_s(name_.as_ptr()) }
	}
	pub fn file_atime_with_name(name: &str) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_getFileATime_s(name_.as_ptr()) }
	}
	pub fn file_ctime_with_name(name: &str) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_getFileCTime_s(name_.as_ptr()) }
	}
	pub fn file_size_with_name(name: &str) -> usize {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_getFileSize_s(name_.as_ptr()) }
	}
	pub fn file_size_with_names(name: &String) -> usize { unsafe { tsDirectory_getFileSize_cS(name.this) } }
	pub fn remove_file(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_removeFile_s(name_.as_ptr()) != 0 }
	}
	pub fn remove_file_with_name(name: &String) -> bool { unsafe { tsDirectory_removeFile_cS(name.this) != 0 } }
	pub fn copy_file(name: &str, new_name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let new_name_ = CString::new(new_name).unwrap();
		unsafe { tsDirectory_copyFile_ssb(name_.as_ptr(), new_name_.as_ptr(), 0) != 0 }
	}
	pub fn copy_file_with_attributes(name: &str, new_name: &str, attributes: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		let new_name_ = CString::new(new_name).unwrap();
		unsafe { tsDirectory_copyFile_ssb(name_.as_ptr(), new_name_.as_ptr(), if attributes {1} else {0}) != 0 }
	}
	pub fn copy_file_with_name(name: &String, new_name: &String) -> bool { unsafe { tsDirectory_copyFile_cScSb(name.this, new_name.this, 0) != 0 } }
	pub fn copy_file_with_name_attributes(name: &String, new_name: &String, attributes: bool) -> bool { unsafe { tsDirectory_copyFile_cScSb(name.this, new_name.this, if attributes {1} else {0}) != 0 } }
	pub fn is_directory(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_isDirectory_s(name_.as_ptr()) != 0 }
	}
	pub fn is_directory_with_name(name: &String) -> bool { unsafe { tsDirectory_isDirectory_cS(name.this) != 0 } }
	pub fn change_directory(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_changeDirectory_s(name_.as_ptr()) != 0 }
	}
	pub fn change_directory_with_name(name: &String) -> bool { unsafe { tsDirectory_changeDirectory_cS(name.this) != 0 } }
	pub fn create_directory(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_createDirectory_sb(name_.as_ptr(), 0) != 0 }
	}
	pub fn create_directory_with_children(name: &str, children: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_createDirectory_sb(name_.as_ptr(), if children {1} else {0}) != 0 }
	}
	pub fn create_directory_with_name(name: &String) -> bool { unsafe { tsDirectory_createDirectory_cSb(name.this, 0) != 0 } }
	pub fn create_directory_with_name_children(name: &String, children: bool) -> bool { unsafe { tsDirectory_createDirectory_cSb(name.this, if children {1} else {0}) != 0 } }
	pub fn remove_directory(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_removeDirectory_sb(name_.as_ptr(), 0) != 0 }
	}
	pub fn remove_directory_with_children(name: &str, children: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDirectory_removeDirectory_sb(name_.as_ptr(), if children {1} else {0}) != 0 }
	}
	pub fn remove_directory_with_name(name: &String) -> bool { unsafe { tsDirectory_removeDirectory_cSb(name.this, 0) != 0 } }
	pub fn remove_directory_with_name_children(name: &String, children: bool) -> bool { unsafe { tsDirectory_removeDirectory_cSb(name.this, if children {1} else {0}) != 0 } }
	pub fn copy_directory(name: &str, new_name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let new_name_ = CString::new(new_name).unwrap();
		unsafe { tsDirectory_copyDirectory_ssb(name_.as_ptr(), new_name_.as_ptr(), 0) != 0 }
	}
	pub fn copy_directory_with_attributes(name: &str, new_name: &str, attributes: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		let new_name_ = CString::new(new_name).unwrap();
		unsafe { tsDirectory_copyDirectory_ssb(name_.as_ptr(), new_name_.as_ptr(), if attributes {1} else {0}) != 0 }
	}
	pub fn copy_directory_with_name(name: &String, new_name: &String) -> bool { unsafe { tsDirectory_copyDirectory_cScSb(name.this, new_name.this, 0) != 0 } }
	pub fn copy_directory_with_name_attributes(name: &String, new_name: &String, attributes: bool) -> bool { unsafe { tsDirectory_copyDirectory_cScSb(name.this, new_name.this, if attributes {1} else {0}) != 0 } }
	pub fn rename(name: &str, new_name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let new_name_ = CString::new(new_name).unwrap();
		unsafe { tsDirectory_rename_ss(name_.as_ptr(), new_name_.as_ptr()) != 0 }
	}
	pub fn rename_with_name(name: &String, new_name: &String) -> bool { unsafe { tsDirectory_rename_cScS(name.this, new_name.this) != 0 } }
	pub fn current_directory() -> string::String { unsafe { get_string(tsDirectory_getCurrentDirectory()) } }
	pub fn binary_directory() -> string::String { unsafe { get_string(tsDirectory_getBinaryDirectory()) } }
	pub fn home_directory() -> string::String { unsafe { get_string(tsDirectory_getHomeDirectory()) } }
	pub fn temp_directory() -> string::String { unsafe { get_string(tsDirectory_getTempDirectory()) } }
	pub fn config_directory() -> string::String { unsafe { get_string(tsDirectory_getConfigDirectory()) } }
	pub fn documents_directory() -> string::String { unsafe { get_string(tsDirectory_getDocumentsDirectory()) } }
}
impl Drop for Directory {
	fn drop(&mut self) { if self.owner { unsafe { tsDirectory_delete(self.this) } } }
}
impl Clone for Directory {
	fn clone(&self) -> Directory { unsafe { Directory { this: tsDirectory_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Directory { }
impl fmt::Display for Directory {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Directory ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDirectory_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDirectory_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDirectory_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDirectory_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDirectory_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDirectory_new() -> *mut c_void;
	fn tsDirectory_delete(this: *mut c_void);
	fn tsDirectory_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDirectory_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDirectory_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDirectory_clearPtr(this: *const c_void);
	fn tsDirectory_destroyPtr(this: *const c_void);
	fn tsDirectory_acquirePtr(this: *const c_void);
	fn tsDirectory_unacquirePtr(this: *const c_void);
	fn tsDirectory_isValidPtr(this: *const c_void) -> i32;
	fn tsDirectory_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDirectory_isConstPtr(this: *const c_void) -> i32;
	fn tsDirectory_getCountPtr(this: *const c_void) -> u32;
	fn tsDirectory_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDirectory_open_sb(this: *mut c_void, name: *const c_char, children: i32) -> i32;
	fn tsDirectory_open_cSb(this: *mut c_void, name: *mut c_void, children: i32) -> i32;
	fn tsDirectory_close(this: *mut c_void);
	fn tsDirectory_isOpened(this: *const c_void) -> i32;
	fn tsDirectory_getName(this: *const c_void) -> *mut c_void;
	fn tsDirectory_getNumFiles(this: *const c_void) -> u32;
	fn tsDirectory_getFileName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDirectory_getFileAttributes_cu(this: *const c_void, index: u32) -> DirectoryAttributes;
	fn tsDirectory_getFileMTime_cu(this: *const c_void, index: u32) -> u64;
	fn tsDirectory_getFileATime_cu(this: *const c_void, index: u32) -> u64;
	fn tsDirectory_getFileCTime_cu(this: *const c_void, index: u32) -> u64;
	fn tsDirectory_getFileSize_cu(this: *const c_void, index: u32) -> usize;
	fn tsDirectory_getNumDirectories(this: *const c_void) -> u32;
	fn tsDirectory_getDirectoryName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDirectory_getDirectoryAttributes(this: *const c_void, index: u32) -> DirectoryAttributes;
	fn tsDirectory_getDirectoryCTime(this: *const c_void, index: u32) -> u64;
	fn tsDirectory_getDirectorySize(this: *const c_void, index: u32) -> u32;
	fn tsDirectory_isFile_s(name: *const c_char) -> i32;
	fn tsDirectory_isFile_cS(name: *mut c_void) -> i32;
	fn tsDirectory_setFileAttributes(name: *const c_char, attributes: DirectoryAttributes) -> i32;
	fn tsDirectory_getFileAttributes_s(name: *const c_char) -> DirectoryAttributes;
	fn tsDirectory_setFileMTime(name: *const c_char, time: u64) -> i32;
	fn tsDirectory_getFileMTime_s(name: *const c_char) -> u64;
	fn tsDirectory_getFileATime_s(name: *const c_char) -> u64;
	fn tsDirectory_getFileCTime_s(name: *const c_char) -> u64;
	fn tsDirectory_getFileSize_s(name: *const c_char) -> usize;
	fn tsDirectory_getFileSize_cS(name: *mut c_void) -> usize;
	fn tsDirectory_removeFile_s(name: *const c_char) -> i32;
	fn tsDirectory_removeFile_cS(name: *mut c_void) -> i32;
	fn tsDirectory_copyFile_ssb(name: *const c_char, new_name: *const c_char, attributes: i32) -> i32;
	fn tsDirectory_copyFile_cScSb(name: *mut c_void, new_name: *mut c_void, attributes: i32) -> i32;
	fn tsDirectory_isDirectory_s(name: *const c_char) -> i32;
	fn tsDirectory_isDirectory_cS(name: *mut c_void) -> i32;
	fn tsDirectory_changeDirectory_s(name: *const c_char) -> i32;
	fn tsDirectory_changeDirectory_cS(name: *mut c_void) -> i32;
	fn tsDirectory_createDirectory_sb(name: *const c_char, children: i32) -> i32;
	fn tsDirectory_createDirectory_cSb(name: *mut c_void, children: i32) -> i32;
	fn tsDirectory_removeDirectory_sb(name: *const c_char, children: i32) -> i32;
	fn tsDirectory_removeDirectory_cSb(name: *mut c_void, children: i32) -> i32;
	fn tsDirectory_copyDirectory_ssb(name: *const c_char, new_name: *const c_char, attributes: i32) -> i32;
	fn tsDirectory_copyDirectory_cScSb(name: *mut c_void, new_name: *mut c_void, attributes: i32) -> i32;
	fn tsDirectory_rename_ss(name: *const c_char, new_name: *const c_char) -> i32;
	fn tsDirectory_rename_cScS(name: *mut c_void, new_name: *mut c_void) -> i32;
	fn tsDirectory_getCurrentDirectory() -> *mut c_void;
	fn tsDirectory_getBinaryDirectory() -> *mut c_void;
	fn tsDirectory_getHomeDirectory() -> *mut c_void;
	fn tsDirectory_getTempDirectory() -> *mut c_void;
	fn tsDirectory_getConfigDirectory() -> *mut c_void;
	fn tsDirectory_getDocumentsDirectory() -> *mut c_void;
}

// Tellusim::Archive
pub struct Archive {
	this: *mut c_void,
	owner: bool,
}
impl Archive {
	pub fn null() -> Archive { Archive { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Archive { unsafe { Archive { this: tsArchive_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Archive { Archive { this: ptr, owner: true } }
	pub fn copy_ptr(&self) -> Archive { Archive { this: self.this, owner: false } }
	pub fn open(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsArchive_open_ss(self.this, name_.as_ptr(), ptr::null_mut()) != 0 }
	}
	pub fn open_with_type(&mut self, name: &str, type_: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let type__ = CString::new(type_).unwrap();
		unsafe { tsArchive_open_ss(self.this, name_.as_ptr(), type__.as_ptr()) != 0 }
	}
	pub fn open_with_name(&mut self, name: &String) -> bool { unsafe { tsArchive_open_cSs(self.this, name.this, ptr::null_mut()) != 0 } }
	pub fn open_with_name_type(&mut self, name: &String, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsArchive_open_cSs(self.this, name.this, type__.as_ptr()) != 0 }
	}
	pub fn open_with_stream(&mut self, stream: &mut Stream) -> bool { unsafe { tsArchive_open_Sts(self.this, stream.this, ptr::null_mut()) != 0 } }
	pub fn open_with_stream_type(&mut self, stream: &mut Stream, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsArchive_open_Sts(self.this, stream.this, type__.as_ptr()) != 0 }
	}
	pub fn close(&mut self) { unsafe { tsArchive_close(self.this) } }
	pub fn is_opened(&self) -> bool { unsafe { tsArchive_isOpened(self.this) != 0 } }
	pub fn name(&self) -> string::String { unsafe { get_string(tsArchive_getName(self.this)) } }
	pub fn num_files(&self) -> u32 { unsafe { tsArchive_getNumFiles(self.this) } }
	pub fn file_name(&self, index: u32) -> string::String { unsafe { get_string(tsArchive_getFileName(self.this, index)) } }
	pub fn file_mtime(&self, index: u32) -> u64 { unsafe { tsArchive_getFileMTime(self.this, index) } }
	pub fn file_size(&self, index: u32) -> usize { unsafe { tsArchive_getFileSize(self.this, index) } }
	pub fn find_file(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsArchive_findFile_cs(self.this, name_.as_ptr()) }
	}
	pub fn find_file_with_name(&self, name: &String) -> u32 { unsafe { tsArchive_findFile_ccS(self.this, name.this) } }
	pub fn is_file(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsArchive_isFile_cs(self.this, name_.as_ptr()) != 0 }
	}
	pub fn is_file_with_name(&self, name: &String) -> bool { unsafe { tsArchive_isFile_ccS(self.this, name.this) != 0 } }
	pub fn open_file(&self, name: &str) -> Stream {
		let name_ = CString::new(name).unwrap();
		unsafe { Stream::new_ptr(tsArchive_openFile_cs(self.this, name_.as_ptr())) }
	}
	pub fn open_file_with_name(&self, name: &String) -> Stream { unsafe { Stream::new_ptr(tsArchive_openFile_ccS(self.this, name.this)) } }
	pub fn open_file_with_index(&self, index: u32) -> Stream { unsafe { Stream::new_ptr(tsArchive_openFile_cu(self.this, index)) } }
}
impl Drop for Archive {
	fn drop(&mut self) { if self.owner { unsafe { tsArchive_delete(self.this) } } }
}
impl fmt::Display for Archive {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Archive ".to_string();
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsArchive_new() -> *mut c_void;
	fn tsArchive_delete(this: *mut c_void);
	fn tsArchive_open_ss(this: *mut c_void, name: *const c_char, type_: *const c_char) -> i32;
	fn tsArchive_open_cSs(this: *mut c_void, name: *mut c_void, type_: *const c_char) -> i32;
	fn tsArchive_open_Sts(this: *mut c_void, stream: *mut c_void, type_: *const c_char) -> i32;
	fn tsArchive_close(this: *mut c_void);
	fn tsArchive_isOpened(this: *const c_void) -> i32;
	fn tsArchive_getName(this: *const c_void) -> *mut c_void;
	fn tsArchive_getNumFiles(this: *const c_void) -> u32;
	fn tsArchive_getFileName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsArchive_getFileMTime(this: *const c_void, index: u32) -> u64;
	fn tsArchive_getFileSize(this: *const c_void, index: u32) -> usize;
	fn tsArchive_findFile_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsArchive_findFile_ccS(this: *const c_void, name: *mut c_void) -> u32;
	fn tsArchive_isFile_cs(this: *const c_void, name: *const c_char) -> i32;
	fn tsArchive_isFile_ccS(this: *const c_void, name: *mut c_void) -> i32;
	fn tsArchive_openFile_cs(this: *const c_void, name: *const c_char) -> *mut c_void;
	fn tsArchive_openFile_ccS(this: *const c_void, name: *mut c_void) -> *mut c_void;
	fn tsArchive_openFile_cu(this: *const c_void, index: u32) -> *mut c_void;
}

// Tellusim::Image
pub struct Image {
	this: *mut c_void,
	owner: bool,
}
impl Image {
	pub fn null() -> Image { Image { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Image { unsafe { Image { this: tsImage_new(), owner: true } } }
	pub fn new_with_name(name: &str) -> Image {
		let name_ = CString::new(name).unwrap();
		unsafe { Image { this: tsImage_new_sIFu(name_.as_ptr(), ImageFlags::None, 0), owner: true } }
	}
	pub fn new_with_name_flags(name: &str, flags: ImageFlags) -> Image {
		let name_ = CString::new(name).unwrap();
		unsafe { Image { this: tsImage_new_sIFu(name_.as_ptr(), flags, 0), owner: true } }
	}
	pub fn new_with_name_flags_offset(name: &str, flags: ImageFlags, offset: u32) -> Image {
		let name_ = CString::new(name).unwrap();
		unsafe { Image { this: tsImage_new_sIFu(name_.as_ptr(), flags, offset), owner: true } }
	}
	pub fn new_with_stream(stream: &mut Stream) -> Image { unsafe { Image { this: tsImage_new_StIFu(stream.this, ImageFlags::None, 0), owner: true } } }
	pub fn new_with_stream_flags(stream: &mut Stream, flags: ImageFlags) -> Image { unsafe { Image { this: tsImage_new_StIFu(stream.this, flags, 0), owner: true } } }
	pub fn new_with_stream_flags_offset(stream: &mut Stream, flags: ImageFlags, offset: u32) -> Image { unsafe { Image { this: tsImage_new_StIFu(stream.this, flags, offset), owner: true } } }
	pub fn new_with_type(type_: ImageType, format: Format, size: &Size) -> Image { unsafe { Image { this: tsImage_new_ITFcSIF(type_, format, size, ImageFlags::None), owner: true } } }
	pub fn new_with_type_flags(type_: ImageType, format: Format, size: &Size, flags: ImageFlags) -> Image { unsafe { Image { this: tsImage_new_ITFcSIF(type_, format, size, flags), owner: true } } }
	pub fn new_with_type_layers(type_: ImageType, format: Format, size: &Size, layers: u32) -> Image { unsafe { Image { this: tsImage_new_ITFcSuIF(type_, format, size, layers, ImageFlags::None), owner: true } } }
	pub fn new_with_type_layers_flags(type_: ImageType, format: Format, size: &Size, layers: u32, flags: ImageFlags) -> Image { unsafe { Image { this: tsImage_new_ITFcSuIF(type_, format, size, layers, flags), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Image { unsafe { Image { this: ptr, owner: tsImage_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Image { unsafe { Image { this: tsImage_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Image) -> bool { unsafe { tsImage_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Image { unsafe { Image { this: tsImage_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsImage_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsImage_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsImage_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsImage_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsImage_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsImage_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsImage_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsImage_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsImage_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsImage_clear(self.this) } }
	pub fn is_loaded(&self) -> bool { unsafe { tsImage_isLoaded(self.this) != 0 } }
	pub fn is_allocated(&self) -> bool { unsafe { tsImage_isAllocated(self.this) != 0 } }
	pub fn type_(&self) -> ImageType { unsafe { tsImage_getType(self.this) } }
	pub fn type_name_with_type(type_: ImageType) -> string::String { unsafe { get_cstring(tsImage_getTypeName_IT(type_)) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsImage_getTypeName_c(self.this)) } }
	pub fn is2d_type(&self) -> bool { unsafe { tsImage_is2DType(self.this) != 0 } }
	pub fn is3d_type(&self) -> bool { unsafe { tsImage_is3DType(self.this) != 0 } }
	pub fn is_cube_type(&self) -> bool { unsafe { tsImage_isCubeType(self.this) != 0 } }
	pub fn format(&self) -> Format { unsafe { tsImage_getFormat(self.this) } }
	pub fn format_name(&self) -> string::String { unsafe { get_cstring(tsImage_getFormatName(self.this)) } }
	pub fn is_color_format(&self) -> bool { unsafe { tsImage_isColorFormat(self.this) != 0 } }
	pub fn is_depth_format(&self) -> bool { unsafe { tsImage_isDepthFormat(self.this) != 0 } }
	pub fn is_pixel_format(&self) -> bool { unsafe { tsImage_isPixelFormat(self.this) != 0 } }
	pub fn is_plain_format(&self) -> bool { unsafe { tsImage_isPlainFormat(self.this) != 0 } }
	pub fn is_mixed_format(&self) -> bool { unsafe { tsImage_isMixedFormat(self.this) != 0 } }
	pub fn is_block_format(&self) -> bool { unsafe { tsImage_isBlockFormat(self.this) != 0 } }
	pub fn is_stencil_format(&self) -> bool { unsafe { tsImage_isStencilFormat(self.this) != 0 } }
	pub fn is_norm_format(&self) -> bool { unsafe { tsImage_isNormFormat(self.this) != 0 } }
	pub fn is_srgb_format(&self) -> bool { unsafe { tsImage_isSRGBFormat(self.this) != 0 } }
	pub fn is_float_format(&self) -> bool { unsafe { tsImage_isFloatFormat(self.this) != 0 } }
	pub fn is_signed_format(&self) -> bool { unsafe { tsImage_isSignedFormat(self.this) != 0 } }
	pub fn is_unsigned_format(&self) -> bool { unsafe { tsImage_isUnsignedFormat(self.this) != 0 } }
	pub fn is_integer_format(&self) -> bool { unsafe { tsImage_isIntegerFormat(self.this) != 0 } }
	pub fn isi8_format(&self) -> bool { unsafe { tsImage_isi8Format(self.this) != 0 } }
	pub fn isu8_format(&self) -> bool { unsafe { tsImage_isu8Format(self.this) != 0 } }
	pub fn is8_bit_format(&self) -> bool { unsafe { tsImage_is8BitFormat(self.this) != 0 } }
	pub fn isi16_format(&self) -> bool { unsafe { tsImage_isi16Format(self.this) != 0 } }
	pub fn isu16_format(&self) -> bool { unsafe { tsImage_isu16Format(self.this) != 0 } }
	pub fn isf16_format(&self) -> bool { unsafe { tsImage_isf16Format(self.this) != 0 } }
	pub fn is16_bit_format(&self) -> bool { unsafe { tsImage_is16BitFormat(self.this) != 0 } }
	pub fn isi32_format(&self) -> bool { unsafe { tsImage_isi32Format(self.this) != 0 } }
	pub fn isu32_format(&self) -> bool { unsafe { tsImage_isu32Format(self.this) != 0 } }
	pub fn isf32_format(&self) -> bool { unsafe { tsImage_isf32Format(self.this) != 0 } }
	pub fn is32_bit_format(&self) -> bool { unsafe { tsImage_is32BitFormat(self.this) != 0 } }
	pub fn isi64_format(&self) -> bool { unsafe { tsImage_isi64Format(self.this) != 0 } }
	pub fn isu64_format(&self) -> bool { unsafe { tsImage_isu64Format(self.this) != 0 } }
	pub fn isf64_format(&self) -> bool { unsafe { tsImage_isf64Format(self.this) != 0 } }
	pub fn is64_bit_format(&self) -> bool { unsafe { tsImage_is64BitFormat(self.this) != 0 } }
	pub fn is_bc15_format(&self) -> bool { unsafe { tsImage_isBC15Format(self.this) != 0 } }
	pub fn is_bc67_format(&self) -> bool { unsafe { tsImage_isBC67Format(self.this) != 0 } }
	pub fn is_etc2_format(&self) -> bool { unsafe { tsImage_isETC2Format(self.this) != 0 } }
	pub fn is_astc_format(&self) -> bool { unsafe { tsImage_isASTCFormat(self.this) != 0 } }
	pub fn components(&self) -> u32 { unsafe { tsImage_getComponents(self.this) } }
	pub fn pixel_size(&self) -> u32 { unsafe { tsImage_getPixelSize(self.this) } }
	pub fn block_size(&self) -> u32 { unsafe { tsImage_getBlockSize(self.this) } }
	pub fn block_width(&self) -> u32 { unsafe { tsImage_getBlockWidth(self.this) } }
	pub fn block_height(&self) -> u32 { unsafe { tsImage_getBlockHeight(self.this) } }
	pub fn width(&self) -> u32 { unsafe { tsImage_getWidth_c(self.this) } }
	pub fn height(&self) -> u32 { unsafe { tsImage_getHeight_c(self.this) } }
	pub fn depth(&self) -> u32 { unsafe { tsImage_getDepth_c(self.this) } }
	pub fn faces(&self) -> u32 { unsafe { tsImage_getFaces(self.this) } }
	pub fn layers(&self) -> u32 { unsafe { tsImage_getLayers(self.this) } }
	pub fn mipmaps(&self) -> u32 { unsafe { tsImage_getMipmaps(self.this) } }
	pub fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsImage_findMipmap(self.this, size) } }
	pub fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsImage_getWidth_cu(self.this, mipmap) } }
	pub fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsImage_getHeight_cu(self.this, mipmap) } }
	pub fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsImage_getDepth_cu(self.this, mipmap) } }
	pub fn has_layers(&self) -> bool { unsafe { tsImage_hasLayers(self.this) != 0 } }
	pub fn has_mipmaps(&self) -> bool { unsafe { tsImage_hasMipmaps(self.this) != 0 } }
	pub fn size(&self) -> Size { unsafe { tsImage_getSize_c(self.this) } }
	pub fn region(&self) -> Region { unsafe { tsImage_getRegion_c(self.this) } }
	pub fn slice(&self) -> Slice { unsafe { tsImage_getSlice_c(self.this) } }
	pub fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsImage_getSize_cu(self.this, mipmap) } }
	pub fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsImage_getRegion_cu(self.this, mipmap) } }
	pub fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsImage_getSlice_cu(self.this, mipmap) } }
	pub fn set_meta_info(&mut self, str: &String) { unsafe { tsImage_setMetaInfo(self.this, str.this) } }
	pub fn meta_info(&self) -> string::String { unsafe { get_string(tsImage_getMetaInfo(self.this)) } }
	pub fn description(&self) -> string::String { unsafe { get_string(tsImage_getDescription(self.this)) } }
	pub fn offset(&self, slice: Option<&Slice>) -> usize {
		let slice_ = Slice::default();
		unsafe { tsImage_getOffset(self.this, match slice { Some(slice) => slice, None => &slice_ }, 1) }
	}
	pub fn offset_with_alignment(&self, slice: Option<&Slice>, alignment: u32) -> usize {
		let slice_ = Slice::default();
		unsafe { tsImage_getOffset(self.this, match slice { Some(slice) => slice, None => &slice_ }, alignment) }
	}
	pub fn stride(&self) -> usize { unsafe { tsImage_getStride(self.this, 0, 1) } }
	pub fn stride_with_mipmap(&self, mipmap: u32) -> usize { unsafe { tsImage_getStride(self.this, mipmap, 1) } }
	pub fn stride_with_mipmap_alignment(&self, mipmap: u32, alignment: u32) -> usize { unsafe { tsImage_getStride(self.this, mipmap, alignment) } }
	pub fn mipmap_size(&self, mipmap: u32) -> usize { unsafe { tsImage_getMipmapSize(self.this, mipmap, 1) } }
	pub fn mipmap_size_with_alignment(&self, mipmap: u32, alignment: u32) -> usize { unsafe { tsImage_getMipmapSize(self.this, mipmap, alignment) } }
	pub fn layer_size(&self) -> usize { unsafe { tsImage_getLayerSize(self.this, 1) } }
	pub fn layer_size_with_alignment(&self, alignment: u32) -> usize { unsafe { tsImage_getLayerSize(self.this, alignment) } }
	pub fn data_size(&self) -> usize { unsafe { tsImage_getDataSize(self.this, 1) } }
	pub fn data_size_with_alignment(&self, alignment: u32) -> usize { unsafe { tsImage_getDataSize(self.this, alignment) } }
	pub fn create(&mut self, type_: ImageType, format: Format, size: &Size) -> bool { unsafe { tsImage_create_ITFcSIF(self.this, type_, format, size, ImageFlags::None) != 0 } }
	pub fn create_with_flags(&mut self, type_: ImageType, format: Format, size: &Size, flags: ImageFlags) -> bool { unsafe { tsImage_create_ITFcSIF(self.this, type_, format, size, flags) != 0 } }
	pub fn create_with_layers(&mut self, type_: ImageType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsImage_create_ITFcSuIF(self.this, type_, format, size, layers, ImageFlags::None) != 0 } }
	pub fn create_with_layers_flags(&mut self, type_: ImageType, format: Format, size: &Size, layers: u32, flags: ImageFlags) -> bool { unsafe { tsImage_create_ITFcSuIF(self.this, type_, format, size, layers, flags) != 0 } }
	pub fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsImage_create2D_FuIF(self.this, format, size, ImageFlags::None) != 0 } }
	pub fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: ImageFlags) -> bool { unsafe { tsImage_create2D_FuIF(self.this, format, size, flags) != 0 } }
	pub fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsImage_create3D_FuIF(self.this, format, size, ImageFlags::None) != 0 } }
	pub fn create3d_with_flags(&mut self, format: Format, size: u32, flags: ImageFlags) -> bool { unsafe { tsImage_create3D_FuIF(self.this, format, size, flags) != 0 } }
	pub fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsImage_createCube_FuIF(self.this, format, size, ImageFlags::None) != 0 } }
	pub fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: ImageFlags) -> bool { unsafe { tsImage_createCube_FuIF(self.this, format, size, flags) != 0 } }
	pub fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsImage_create2D_FuuIF(self.this, format, width, height, ImageFlags::None) != 0 } }
	pub fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: ImageFlags) -> bool { unsafe { tsImage_create2D_FuuIF(self.this, format, width, height, flags) != 0 } }
	pub fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsImage_create3D_FuuuIF(self.this, format, width, height, depth, ImageFlags::None) != 0 } }
	pub fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: ImageFlags) -> bool { unsafe { tsImage_create3D_FuuuIF(self.this, format, width, height, depth, flags) != 0 } }
	pub fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsImage_create2D_FuuuIF(self.this, format, width, height, layers, ImageFlags::None) != 0 } }
	pub fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: ImageFlags) -> bool { unsafe { tsImage_create2D_FuuuIF(self.this, format, width, height, layers, flags) != 0 } }
	pub fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsImage_createCube_FuuIF(self.this, format, size, layers, ImageFlags::None) != 0 } }
	pub fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: ImageFlags) -> bool { unsafe { tsImage_createCube_FuuIF(self.this, format, size, layers, flags) != 0 } }
	pub fn info_with_name_flags(&mut self, name: &str, flags: ImageFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_info_sIFuA(self.this, name_.as_ptr(), flags, 0, ptr::null_mut()) != 0 }
	}
	pub fn info_with_name_flags_offset(&mut self, name: &str, flags: ImageFlags, offset: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_info_sIFuA(self.this, name_.as_ptr(), flags, offset, ptr::null_mut()) != 0 }
	}
	pub fn info_with_name_flags_offset_async(&mut self, name: &str, flags: ImageFlags, offset: u32, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_info_sIFuA(self.this, name_.as_ptr(), flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn info_with_names_flags(&mut self, name: &String, flags: ImageFlags) -> bool { unsafe { tsImage_info_cSIFuA(self.this, name.this, flags, 0, ptr::null_mut()) != 0 } }
	pub fn info_with_names_flags_offset(&mut self, name: &String, flags: ImageFlags, offset: u32) -> bool { unsafe { tsImage_info_cSIFuA(self.this, name.this, flags, offset, ptr::null_mut()) != 0 } }
	pub fn info_with_names_flags_offset_async(&mut self, name: &String, flags: ImageFlags, offset: u32, async_: Option<&Async>) -> bool { unsafe { tsImage_info_cSIFuA(self.this, name.this, flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn info_with_stream_flags(&mut self, stream: &mut Stream, flags: ImageFlags) -> bool { unsafe { tsImage_info_StIFuA(self.this, stream.this, flags, 0, ptr::null_mut()) != 0 } }
	pub fn info_with_stream_flags_offset(&mut self, stream: &mut Stream, flags: ImageFlags, offset: u32) -> bool { unsafe { tsImage_info_StIFuA(self.this, stream.this, flags, offset, ptr::null_mut()) != 0 } }
	pub fn info_with_stream_flags_offset_async(&mut self, stream: &mut Stream, flags: ImageFlags, offset: u32, async_: Option<&Async>) -> bool { unsafe { tsImage_info_StIFuA(self.this, stream.this, flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn info_with_name(&mut self, name: &str, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_info_sA(self.this, name_.as_ptr(), match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn info_with_names(&mut self, name: &String, async_: Option<&Async>) -> bool { unsafe { tsImage_info_cSA(self.this, name.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn info_with_stream(&mut self, stream: &mut Stream, async_: Option<&Async>) -> bool { unsafe { tsImage_info_StA(self.this, stream.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_name_flags(&mut self, name: &str, flags: ImageFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_load_sIFuA(self.this, name_.as_ptr(), flags, 0, ptr::null_mut()) != 0 }
	}
	pub fn load_with_name_flags_offset(&mut self, name: &str, flags: ImageFlags, offset: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_load_sIFuA(self.this, name_.as_ptr(), flags, offset, ptr::null_mut()) != 0 }
	}
	pub fn load_with_name_flags_offset_async(&mut self, name: &str, flags: ImageFlags, offset: u32, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_load_sIFuA(self.this, name_.as_ptr(), flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn load_with_names_flags(&mut self, name: &String, flags: ImageFlags) -> bool { unsafe { tsImage_load_cSIFuA(self.this, name.this, flags, 0, ptr::null_mut()) != 0 } }
	pub fn load_with_names_flags_offset(&mut self, name: &String, flags: ImageFlags, offset: u32) -> bool { unsafe { tsImage_load_cSIFuA(self.this, name.this, flags, offset, ptr::null_mut()) != 0 } }
	pub fn load_with_names_flags_offset_async(&mut self, name: &String, flags: ImageFlags, offset: u32, async_: Option<&Async>) -> bool { unsafe { tsImage_load_cSIFuA(self.this, name.this, flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_stream_flags(&mut self, stream: &mut Stream, flags: ImageFlags) -> bool { unsafe { tsImage_load_StIFuA(self.this, stream.this, flags, 0, ptr::null_mut()) != 0 } }
	pub fn load_with_stream_flags_offset(&mut self, stream: &mut Stream, flags: ImageFlags, offset: u32) -> bool { unsafe { tsImage_load_StIFuA(self.this, stream.this, flags, offset, ptr::null_mut()) != 0 } }
	pub fn load_with_stream_flags_offset_async(&mut self, stream: &mut Stream, flags: ImageFlags, offset: u32, async_: Option<&Async>) -> bool { unsafe { tsImage_load_StIFuA(self.this, stream.this, flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_name(&mut self, name: &str, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_load_sA(self.this, name_.as_ptr(), match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn load_with_names(&mut self, name: &String, async_: Option<&Async>) -> bool { unsafe { tsImage_load_cSA(self.this, name.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_stream(&mut self, stream: &mut Stream, async_: Option<&Async>) -> bool { unsafe { tsImage_load_StA(self.this, stream.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn save(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_save_csIFu(self.this, name_.as_ptr(), ImageFlags::None, 95) != 0 }
	}
	pub fn save_with_flags(&self, name: &str, flags: ImageFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_save_csIFu(self.this, name_.as_ptr(), flags, 95) != 0 }
	}
	pub fn save_with_flags_quality(&self, name: &str, flags: ImageFlags, quality: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsImage_save_csIFu(self.this, name_.as_ptr(), flags, quality) != 0 }
	}
	pub fn save_with_name(&self, name: &String) -> bool { unsafe { tsImage_save_ccSIFu(self.this, name.this, ImageFlags::None, 95) != 0 } }
	pub fn save_with_name_flags(&self, name: &String, flags: ImageFlags) -> bool { unsafe { tsImage_save_ccSIFu(self.this, name.this, flags, 95) != 0 } }
	pub fn save_with_name_flags_quality(&self, name: &String, flags: ImageFlags, quality: u32) -> bool { unsafe { tsImage_save_ccSIFu(self.this, name.this, flags, quality) != 0 } }
	pub fn save_with_stream(&self, stream: &mut Stream) -> bool { unsafe { tsImage_save_cStIFu(self.this, stream.this, ImageFlags::None, 95) != 0 } }
	pub fn save_with_stream_flags(&self, stream: &mut Stream, flags: ImageFlags) -> bool { unsafe { tsImage_save_cStIFu(self.this, stream.this, flags, 95) != 0 } }
	pub fn save_with_stream_flags_quality(&self, stream: &mut Stream, flags: ImageFlags, quality: u32) -> bool { unsafe { tsImage_save_cStIFu(self.this, stream.this, flags, quality) != 0 } }
	pub fn swap(&mut self, component_0: u32, component_1: u32) -> bool { unsafe { tsImage_swap(self.this, component_0, component_1) != 0 } }
	pub fn copy_with_destcomponent(&mut self, src: &Image, dest_component: u32, src_component: u32) -> bool { unsafe { tsImage_copy_cIuu(self.this, src.this, dest_component, src_component) != 0 } }
	pub fn flip_x_with_region_slice(&mut self, region: &Region, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_flipX_cRcS(self.this, region, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn flip_x_with_region(&mut self, region: &Region) -> bool { unsafe { tsImage_flipX_cR(self.this, region) != 0 } }
	pub fn flip_x(&mut self) -> bool { unsafe { tsImage_flipX(self.this) != 0 } }
	pub fn flip_y_with_region_slice(&mut self, region: &Region, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_flipY_cRcS(self.this, region, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn flip_y_with_region(&mut self, region: &Region) -> bool { unsafe { tsImage_flipY_cR(self.this, region) != 0 } }
	pub fn flip_y(&mut self) -> bool { unsafe { tsImage_flipY(self.this) != 0 } }
	pub fn copy_with_destorigin_srcregion_destslice(&mut self, src: &Image, dest_origin: &Origin, src_region: &Region, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsImage_copy_cIcOcRcScS(self.this, src.this, dest_origin, src_region, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn copy_with_destorigin_srcregion(&mut self, src: &Image, dest_origin: &Origin, src_region: &Region) -> bool { unsafe { tsImage_copy_cIcOcR(self.this, src.this, dest_origin, src_region) != 0 } }
	pub fn copy_with_destorigin_destslice(&mut self, src: &Image, dest_origin: &Origin, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsImage_copy_cIcOcS(self.this, src.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	pub fn copy_with_destslice_srcslice(&mut self, src: &Image, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsImage_copy_cIcScS(self.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn copy_with_destorigin(&mut self, src: &Image, dest_origin: &Origin) -> bool { unsafe { tsImage_copy_cIcO(self.this, src.this, dest_origin) != 0 } }
	pub fn copy_with_destslice(&mut self, src: &Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsImage_copy_cIcS(self.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	pub fn to_type_with_flags(&self, type_: ImageType, flags: ImageFlags) -> Image { unsafe { Image::new_ptr(tsImage_toType_cITIFA(self.this, type_, flags, ptr::null_mut())) } }
	pub fn to_type_with_flags_async(&self, type_: ImageType, flags: ImageFlags, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_toType_cITIFA(self.this, type_, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn to_type(&self, type_: ImageType) -> Image { unsafe { Image::new_ptr(tsImage_toType_cITA(self.this, type_, ptr::null_mut())) } }
	pub fn to_type_with_async(&self, type_: ImageType, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_toType_cITA(self.this, type_, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn to_format_with_flags(&self, format: Format, flags: ImageFlags) -> Image { unsafe { Image::new_ptr(tsImage_toFormat_cFIFA(self.this, format, flags, ptr::null_mut())) } }
	pub fn to_format_with_flags_async(&self, format: Format, flags: ImageFlags, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_toFormat_cFIFA(self.this, format, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn to_format(&self, format: Format) -> Image { unsafe { Image::new_ptr(tsImage_toFormat_cFA(self.this, format, ptr::null_mut())) } }
	pub fn to_format_with_async(&self, format: Format, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_toFormat_cFA(self.this, format, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn slice_with_slice(&self, slice: Option<&Slice>) -> Image {
		let slice_ = Slice::default();
		unsafe { Image::new_ptr(tsImage_getSlice_ccS(self.this, match slice { Some(slice) => slice, None => &slice_ })) }
	}
	pub fn component(&self, component: u32) -> Image { unsafe { Image::new_ptr(tsImage_getComponent(self.this, component)) } }
	pub fn region_with_region_slice(&self, region: &Region, slice: Option<&Slice>) -> Image {
		let slice_ = Slice::default();
		unsafe { Image::new_ptr(tsImage_getRegion_ccRcS(self.this, region, match slice { Some(slice) => slice, None => &slice_ })) }
	}
	pub fn region_with_region(&self, region: &Region) -> Image { unsafe { Image::new_ptr(tsImage_getRegion_ccR(self.this, region)) } }
	pub fn rotated_with_slice(&self, angle: i32, slice: Option<&Slice>) -> Image {
		let slice_ = Slice::default();
		unsafe { Image::new_ptr(tsImage_getRotated_cicS(self.this, angle, match slice { Some(slice) => slice, None => &slice_ })) }
	}
	pub fn rotated(&self, angle: i32) -> Image { unsafe { Image::new_ptr(tsImage_getRotated_ci(self.this, angle)) } }
	pub fn resized_with_min_flags(&self, size: &Size, min: ImageFilter, mag: ImageFilter, flags: ImageFlags) -> Image { unsafe { Image::new_ptr(tsImage_getResized_ccSIFIFIFA(self.this, size, min, mag, flags, ptr::null_mut())) } }
	pub fn resized_with_min_flags_async(&self, size: &Size, min: ImageFilter, mag: ImageFilter, flags: ImageFlags, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_getResized_ccSIFIFIFA(self.this, size, min, mag, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn resized_with_min(&self, size: &Size, min: ImageFilter) -> Image { unsafe { Image::new_ptr(tsImage_getResized_ccSIFIFA(self.this, size, min, ImageFilter::Cubic, ptr::null_mut())) } }
	pub fn resized_with_min_mag(&self, size: &Size, min: ImageFilter, mag: ImageFilter) -> Image { unsafe { Image::new_ptr(tsImage_getResized_ccSIFIFA(self.this, size, min, mag, ptr::null_mut())) } }
	pub fn resized_with_min_mag_async(&self, size: &Size, min: ImageFilter, mag: ImageFilter, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_getResized_ccSIFIFA(self.this, size, min, mag, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn resized_with_async(&self, size: &Size, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_getResized_ccSA(self.this, size, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn mipmapped_with_filter_flags(&self, filter: ImageFilter, flags: ImageFlags) -> Image { unsafe { Image::new_ptr(tsImage_getMipmapped_cIFIFA(self.this, filter, flags, ptr::null_mut())) } }
	pub fn mipmapped_with_filter_flags_async(&self, filter: ImageFilter, flags: ImageFlags, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_getMipmapped_cIFIFA(self.this, filter, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn mipmapped_with_filter(&self, filter: ImageFilter) -> Image { unsafe { Image::new_ptr(tsImage_getMipmapped_cIFA(self.this, filter, ptr::null_mut())) } }
	pub fn mipmapped_with_filter_async(&self, filter: ImageFilter, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_getMipmapped_cIFA(self.this, filter, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn mipmapped_with_async(&self, async_: Option<&Async>) -> Image { unsafe { Image::new_ptr(tsImage_getMipmapped_cA(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	pub fn compare(&self, image: &Image) -> i32 { unsafe { tsImage_compare(self.this, image.this) } }
	pub fn data(&self) -> *const u8 { unsafe { tsImage_getData_ccS(self.this, &Slice::default()) } }
	pub fn data_with_slice(&self, slice: Option<&Slice>) -> *const u8 {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_ccS(self.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	pub fn data_mut(&mut self) -> *mut u8 { unsafe { tsImage_getData_cS(self.this, &Slice::default()) } }
	pub fn data_mut_with_slice(&mut self, slice: Option<&Slice>) -> *mut u8 {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_cS(self.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	pub fn data_with_origin(&self, origin: &Origin) -> *const u8 { unsafe { tsImage_getData_ccOcS(self.this, origin, &Slice::default()) } }
	pub fn data_with_origin_slice(&self, origin: &Origin, slice: Option<&Slice>) -> *const u8 {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_ccOcS(self.this, origin, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	pub fn data_mut_with_origin(&mut self, origin: &Origin) -> *mut u8 { unsafe { tsImage_getData_cOcS(self.this, origin, &Slice::default()) } }
	pub fn data_mut_with_origin_slice(&mut self, origin: &Origin, slice: Option<&Slice>) -> *mut u8 {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_cOcS(self.this, origin, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	pub fn set_data(&mut self, src: *const c_void) -> bool { unsafe { tsImage_setData(self.this, src, &Slice::default(), 1, 0) != 0 } }
	pub fn set_data_with_slice(&mut self, src: *const c_void, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_setData(self.this, src, match slice { Some(slice) => slice, None => &slice_ }, 1, 0) != 0 }
	}
	pub fn set_data_with_slice_alignment(&mut self, src: *const c_void, slice: Option<&Slice>, alignment: u32) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_setData(self.this, src, match slice { Some(slice) => slice, None => &slice_ }, alignment, 0) != 0 }
	}
	pub fn set_data_with_slice_alignment_stride(&mut self, src: *const c_void, slice: Option<&Slice>, alignment: u32, stride: usize) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_setData(self.this, src, match slice { Some(slice) => slice, None => &slice_ }, alignment, stride) != 0 }
	}
	pub fn data_with_dest(&self, dest: *mut c_void) -> bool { unsafe { tsImage_getData_cprcSuz(self.this, dest, &Slice::default(), 1, 0) != 0 } }
	pub fn data_with_dest_slice(&self, dest: *mut c_void, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_cprcSuz(self.this, dest, match slice { Some(slice) => slice, None => &slice_ }, 1, 0) != 0 }
	}
	pub fn data_with_dest_slice_alignment(&self, dest: *mut c_void, slice: Option<&Slice>, alignment: u32) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_cprcSuz(self.this, dest, match slice { Some(slice) => slice, None => &slice_ }, alignment, 0) != 0 }
	}
	pub fn data_with_dest_slice_alignment_stride(&self, dest: *mut c_void, slice: Option<&Slice>, alignment: u32, stride: usize) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImage_getData_cprcSuz(self.this, dest, match slice { Some(slice) => slice, None => &slice_ }, alignment, stride) != 0 }
	}
	pub fn memory(&self) -> usize { unsafe { tsImage_getMemory(self.this) } }
}
impl Drop for Image {
	fn drop(&mut self) { if self.owner { unsafe { tsImage_delete(self.this) } } }
}
impl Clone for Image {
	fn clone(&self) -> Image { unsafe { Image { this: tsImage_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Image { }
impl fmt::Display for Image {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Image ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsImage_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsImage_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsImage_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsImage_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsImage_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsImage_new() -> *mut c_void;
	fn tsImage_new_sIFu(name: *const c_char, flags: ImageFlags, offset: u32) -> *mut c_void;
	fn tsImage_new_StIFu(stream: *mut c_void, flags: ImageFlags, offset: u32) -> *mut c_void;
	fn tsImage_new_ITFcSIF(type_: ImageType, format: Format, size: *const Size, flags: ImageFlags) -> *mut c_void;
	fn tsImage_new_ITFcSuIF(type_: ImageType, format: Format, size: *const Size, layers: u32, flags: ImageFlags) -> *mut c_void;
	fn tsImage_delete(this: *mut c_void);
	fn tsImage_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsImage_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsImage_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsImage_clearPtr(this: *const c_void);
	fn tsImage_destroyPtr(this: *const c_void);
	fn tsImage_acquirePtr(this: *const c_void);
	fn tsImage_unacquirePtr(this: *const c_void);
	fn tsImage_isValidPtr(this: *const c_void) -> i32;
	fn tsImage_isOwnerPtr(this: *const c_void) -> i32;
	fn tsImage_isConstPtr(this: *const c_void) -> i32;
	fn tsImage_getCountPtr(this: *const c_void) -> u32;
	fn tsImage_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsImage_clear(this: *mut c_void);
	fn tsImage_isLoaded(this: *const c_void) -> i32;
	fn tsImage_isAllocated(this: *const c_void) -> i32;
	fn tsImage_getType(this: *const c_void) -> ImageType;
	fn tsImage_getTypeName_IT(type_: ImageType) -> *const c_char;
	fn tsImage_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsImage_is2DType(this: *const c_void) -> i32;
	fn tsImage_is3DType(this: *const c_void) -> i32;
	fn tsImage_isCubeType(this: *const c_void) -> i32;
	fn tsImage_getFormat(this: *const c_void) -> Format;
	fn tsImage_getFormatName(this: *const c_void) -> *const c_char;
	fn tsImage_isColorFormat(this: *const c_void) -> i32;
	fn tsImage_isDepthFormat(this: *const c_void) -> i32;
	fn tsImage_isPixelFormat(this: *const c_void) -> i32;
	fn tsImage_isPlainFormat(this: *const c_void) -> i32;
	fn tsImage_isMixedFormat(this: *const c_void) -> i32;
	fn tsImage_isBlockFormat(this: *const c_void) -> i32;
	fn tsImage_isStencilFormat(this: *const c_void) -> i32;
	fn tsImage_isNormFormat(this: *const c_void) -> i32;
	fn tsImage_isSRGBFormat(this: *const c_void) -> i32;
	fn tsImage_isFloatFormat(this: *const c_void) -> i32;
	fn tsImage_isSignedFormat(this: *const c_void) -> i32;
	fn tsImage_isUnsignedFormat(this: *const c_void) -> i32;
	fn tsImage_isIntegerFormat(this: *const c_void) -> i32;
	fn tsImage_isi8Format(this: *const c_void) -> i32;
	fn tsImage_isu8Format(this: *const c_void) -> i32;
	fn tsImage_is8BitFormat(this: *const c_void) -> i32;
	fn tsImage_isi16Format(this: *const c_void) -> i32;
	fn tsImage_isu16Format(this: *const c_void) -> i32;
	fn tsImage_isf16Format(this: *const c_void) -> i32;
	fn tsImage_is16BitFormat(this: *const c_void) -> i32;
	fn tsImage_isi32Format(this: *const c_void) -> i32;
	fn tsImage_isu32Format(this: *const c_void) -> i32;
	fn tsImage_isf32Format(this: *const c_void) -> i32;
	fn tsImage_is32BitFormat(this: *const c_void) -> i32;
	fn tsImage_isi64Format(this: *const c_void) -> i32;
	fn tsImage_isu64Format(this: *const c_void) -> i32;
	fn tsImage_isf64Format(this: *const c_void) -> i32;
	fn tsImage_is64BitFormat(this: *const c_void) -> i32;
	fn tsImage_isBC15Format(this: *const c_void) -> i32;
	fn tsImage_isBC67Format(this: *const c_void) -> i32;
	fn tsImage_isETC2Format(this: *const c_void) -> i32;
	fn tsImage_isASTCFormat(this: *const c_void) -> i32;
	fn tsImage_getComponents(this: *const c_void) -> u32;
	fn tsImage_getPixelSize(this: *const c_void) -> u32;
	fn tsImage_getBlockSize(this: *const c_void) -> u32;
	fn tsImage_getBlockWidth(this: *const c_void) -> u32;
	fn tsImage_getBlockHeight(this: *const c_void) -> u32;
	fn tsImage_getWidth_c(this: *const c_void) -> u32;
	fn tsImage_getHeight_c(this: *const c_void) -> u32;
	fn tsImage_getDepth_c(this: *const c_void) -> u32;
	fn tsImage_getFaces(this: *const c_void) -> u32;
	fn tsImage_getLayers(this: *const c_void) -> u32;
	fn tsImage_getMipmaps(this: *const c_void) -> u32;
	fn tsImage_findMipmap(this: *const c_void, size: *const Size) -> u32;
	fn tsImage_getWidth_cu(this: *const c_void, mipmap: u32) -> u32;
	fn tsImage_getHeight_cu(this: *const c_void, mipmap: u32) -> u32;
	fn tsImage_getDepth_cu(this: *const c_void, mipmap: u32) -> u32;
	fn tsImage_hasLayers(this: *const c_void) -> i32;
	fn tsImage_hasMipmaps(this: *const c_void) -> i32;
	fn tsImage_getSize_c(this: *const c_void) -> Size;
	fn tsImage_getRegion_c(this: *const c_void) -> Region;
	fn tsImage_getSlice_c(this: *const c_void) -> Slice;
	fn tsImage_getSize_cu(this: *const c_void, mipmap: u32) -> Size;
	fn tsImage_getRegion_cu(this: *const c_void, mipmap: u32) -> Region;
	fn tsImage_getSlice_cu(this: *const c_void, mipmap: u32) -> Slice;
	fn tsImage_setMetaInfo(this: *mut c_void, str: *mut c_void);
	fn tsImage_getMetaInfo(this: *const c_void) -> *mut c_void;
	fn tsImage_getDescription(this: *const c_void) -> *mut c_void;
	fn tsImage_getOffset(this: *const c_void, slice: *const Slice, alignment: u32) -> usize;
	fn tsImage_getStride(this: *const c_void, mipmap: u32, alignment: u32) -> usize;
	fn tsImage_getMipmapSize(this: *const c_void, mipmap: u32, alignment: u32) -> usize;
	fn tsImage_getLayerSize(this: *const c_void, alignment: u32) -> usize;
	fn tsImage_getDataSize(this: *const c_void, alignment: u32) -> usize;
	fn tsImage_create_ITFcSIF(this: *mut c_void, type_: ImageType, format: Format, size: *const Size, flags: ImageFlags) -> i32;
	fn tsImage_create_ITFcSuIF(this: *mut c_void, type_: ImageType, format: Format, size: *const Size, layers: u32, flags: ImageFlags) -> i32;
	fn tsImage_create2D_FuIF(this: *mut c_void, format: Format, size: u32, flags: ImageFlags) -> i32;
	fn tsImage_create3D_FuIF(this: *mut c_void, format: Format, size: u32, flags: ImageFlags) -> i32;
	fn tsImage_createCube_FuIF(this: *mut c_void, format: Format, size: u32, flags: ImageFlags) -> i32;
	fn tsImage_create2D_FuuIF(this: *mut c_void, format: Format, width: u32, height: u32, flags: ImageFlags) -> i32;
	fn tsImage_create3D_FuuuIF(this: *mut c_void, format: Format, width: u32, height: u32, depth: u32, flags: ImageFlags) -> i32;
	fn tsImage_create2D_FuuuIF(this: *mut c_void, format: Format, width: u32, height: u32, layers: u32, flags: ImageFlags) -> i32;
	fn tsImage_createCube_FuuIF(this: *mut c_void, format: Format, size: u32, layers: u32, flags: ImageFlags) -> i32;
	fn tsImage_info_sIFuA(this: *mut c_void, name: *const c_char, flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> i32;
	fn tsImage_info_cSIFuA(this: *mut c_void, name: *mut c_void, flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> i32;
	fn tsImage_info_StIFuA(this: *mut c_void, stream: *mut c_void, flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> i32;
	fn tsImage_info_sA(this: *mut c_void, name: *const c_char, async_: *const *mut c_void) -> i32;
	fn tsImage_info_cSA(this: *mut c_void, name: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsImage_info_StA(this: *mut c_void, stream: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsImage_load_sIFuA(this: *mut c_void, name: *const c_char, flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> i32;
	fn tsImage_load_cSIFuA(this: *mut c_void, name: *mut c_void, flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> i32;
	fn tsImage_load_StIFuA(this: *mut c_void, stream: *mut c_void, flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> i32;
	fn tsImage_load_sA(this: *mut c_void, name: *const c_char, async_: *const *mut c_void) -> i32;
	fn tsImage_load_cSA(this: *mut c_void, name: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsImage_load_StA(this: *mut c_void, stream: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsImage_save_csIFu(this: *const c_void, name: *const c_char, flags: ImageFlags, quality: u32) -> i32;
	fn tsImage_save_ccSIFu(this: *const c_void, name: *mut c_void, flags: ImageFlags, quality: u32) -> i32;
	fn tsImage_save_cStIFu(this: *const c_void, stream: *mut c_void, flags: ImageFlags, quality: u32) -> i32;
	fn tsImage_swap(this: *mut c_void, component_0: u32, component_1: u32) -> i32;
	fn tsImage_copy_cIuu(this: *mut c_void, src: *mut c_void, dest_component: u32, src_component: u32) -> i32;
	fn tsImage_flipX_cRcS(this: *mut c_void, region: *const Region, slice: *const Slice) -> i32;
	fn tsImage_flipX_cR(this: *mut c_void, region: *const Region) -> i32;
	fn tsImage_flipX(this: *mut c_void) -> i32;
	fn tsImage_flipY_cRcS(this: *mut c_void, region: *const Region, slice: *const Slice) -> i32;
	fn tsImage_flipY_cR(this: *mut c_void, region: *const Region) -> i32;
	fn tsImage_flipY(this: *mut c_void) -> i32;
	fn tsImage_copy_cIcOcRcScS(this: *mut c_void, src: *mut c_void, dest_origin: *const Origin, src_region: *const Region, dest_slice: *const Slice, src_slice: *const Slice) -> i32;
	fn tsImage_copy_cIcOcR(this: *mut c_void, src: *mut c_void, dest_origin: *const Origin, src_region: *const Region) -> i32;
	fn tsImage_copy_cIcOcS(this: *mut c_void, src: *mut c_void, dest_origin: *const Origin, dest_slice: *const Slice) -> i32;
	fn tsImage_copy_cIcScS(this: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice) -> i32;
	fn tsImage_copy_cIcO(this: *mut c_void, src: *mut c_void, dest_origin: *const Origin) -> i32;
	fn tsImage_copy_cIcS(this: *mut c_void, src: *mut c_void, dest_slice: *const Slice) -> i32;
	fn tsImage_toType_cITIFA(this: *const c_void, type_: ImageType, flags: ImageFlags, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_toType_cITA(this: *const c_void, type_: ImageType, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_toFormat_cFIFA(this: *const c_void, format: Format, flags: ImageFlags, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_toFormat_cFA(this: *const c_void, format: Format, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_getSlice_ccS(this: *const c_void, slice: *const Slice) -> *mut c_void;
	fn tsImage_getComponent(this: *const c_void, component: u32) -> *mut c_void;
	fn tsImage_getRegion_ccRcS(this: *const c_void, region: *const Region, slice: *const Slice) -> *mut c_void;
	fn tsImage_getRegion_ccR(this: *const c_void, region: *const Region) -> *mut c_void;
	fn tsImage_getRotated_cicS(this: *const c_void, angle: i32, slice: *const Slice) -> *mut c_void;
	fn tsImage_getRotated_ci(this: *const c_void, angle: i32) -> *mut c_void;
	fn tsImage_getResized_ccSIFIFIFA(this: *const c_void, size: *const Size, min: ImageFilter, mag: ImageFilter, flags: ImageFlags, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_getResized_ccSIFIFA(this: *const c_void, size: *const Size, min: ImageFilter, mag: ImageFilter, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_getResized_ccSA(this: *const c_void, size: *const Size, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_getMipmapped_cIFIFA(this: *const c_void, filter: ImageFilter, flags: ImageFlags, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_getMipmapped_cIFA(this: *const c_void, filter: ImageFilter, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_getMipmapped_cA(this: *const c_void, async_: *const *mut c_void) -> *mut c_void;
	fn tsImage_compare(this: *const c_void, image: *mut c_void) -> i32;
	fn tsImage_getData_ccS(this: *const c_void, slice: *const Slice) -> *const u8;
	fn tsImage_getData_cS(this: *mut c_void, slice: *const Slice) -> *mut u8;
	fn tsImage_getData_ccOcS(this: *const c_void, origin: *const Origin, slice: *const Slice) -> *const u8;
	fn tsImage_getData_cOcS(this: *mut c_void, origin: *const Origin, slice: *const Slice) -> *mut u8;
	fn tsImage_setData(this: *mut c_void, src: *const c_void, slice: *const Slice, alignment: u32, stride: usize) -> i32;
	fn tsImage_getData_cprcSuz(this: *const c_void, dest: *mut c_void, slice: *const Slice, alignment: u32, stride: usize) -> i32;
	fn tsImage_getMemory(this: *const c_void) -> usize;
}

// Tellusim::ImageSampler
pub struct ImageSampler {
	this: *mut c_void,
	owner: bool,
}
impl ImageSampler {
	pub fn null() -> ImageSampler { ImageSampler { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ImageSampler { unsafe { ImageSampler { this: tsImageSampler_new(), owner: true } } }
	pub fn new_with_image_mut(image: &mut Image) -> ImageSampler { unsafe { ImageSampler { this: tsImageSampler_new_IcS(image.this, &Slice::default()), owner: true } } }
	pub fn new_with_image_mut_slice(image: &mut Image, slice: Option<&Slice>) -> ImageSampler {
		let slice_ = Slice::default();
		unsafe { ImageSampler { this: tsImageSampler_new_IcS(image.this, match slice { Some(slice) => slice, None => &slice_ }), owner: true } }
	}
	pub fn new_with_image(image: &Image) -> ImageSampler { unsafe { ImageSampler { this: tsImageSampler_new_cIcS(image.this, &Slice::default()), owner: true } } }
	pub fn new_with_image_slice(image: &Image, slice: Option<&Slice>) -> ImageSampler {
		let slice_ = Slice::default();
		unsafe { ImageSampler { this: tsImageSampler_new_cIcS(image.this, match slice { Some(slice) => slice, None => &slice_ }), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> ImageSampler { ImageSampler { this: ptr, owner: true } }
	pub fn copy_ptr(&self) -> ImageSampler { ImageSampler { this: self.this, owner: false } }
	pub fn clear(&mut self) { unsafe { tsImageSampler_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsImageSampler_isCreated(self.this) != 0 } }
	pub fn type_(&self) -> ImageType { unsafe { tsImageSampler_getType(self.this) } }
	pub fn is2d_type(&self) -> bool { unsafe { tsImageSampler_is2DType(self.this) != 0 } }
	pub fn is3d_type(&self) -> bool { unsafe { tsImageSampler_is3DType(self.this) != 0 } }
	pub fn is_cube_type(&self) -> bool { unsafe { tsImageSampler_isCubeType(self.this) != 0 } }
	pub fn format(&self) -> Format { unsafe { tsImageSampler_getFormat(self.this) } }
	pub fn format_name(&self) -> string::String { unsafe { get_cstring(tsImageSampler_getFormatName(self.this)) } }
	pub fn width(&self) -> u32 { unsafe { tsImageSampler_getWidth(self.this) } }
	pub fn height(&self) -> u32 { unsafe { tsImageSampler_getHeight(self.this) } }
	pub fn depth(&self) -> u32 { unsafe { tsImageSampler_getDepth(self.this) } }
	pub fn faces(&self) -> u32 { unsafe { tsImageSampler_getFaces(self.this) } }
	pub fn texels(&self) -> usize { unsafe { tsImageSampler_getTexels(self.this) } }
	pub fn size(&self) -> Size { unsafe { tsImageSampler_getSize(self.this) } }
	pub fn region(&self) -> Region { unsafe { tsImageSampler_getRegion(self.this) } }
	pub fn stride(&self) -> usize { unsafe { tsImageSampler_getStride(self.this) } }
	pub fn layer_size(&self) -> usize { unsafe { tsImageSampler_getLayerSize(self.this) } }
	pub fn pixel_size(&self) -> u32 { unsafe { tsImageSampler_getPixelSize(self.this) } }
	pub fn components(&self) -> u32 { unsafe { tsImageSampler_getComponents(self.this) } }
	pub fn data(&self) -> *const u8 { unsafe { tsImageSampler_getData_c(self.this) } }
	pub fn data_mut(&mut self) -> *mut u8 { unsafe { tsImageSampler_getData(self.this) } }
	pub fn create_with_imagei(&mut self, image: &mut Image) -> bool { unsafe { tsImageSampler_create_IcS(self.this, image.this, &Slice::default()) != 0 } }
	pub fn create_with_imagei_slice(&mut self, image: &mut Image, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImageSampler_create_IcS(self.this, image.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn create_with_imageci(&mut self, image: &Image) -> bool { unsafe { tsImageSampler_create_cIcS(self.this, image.this, &Slice::default()) != 0 } }
	pub fn create_with_imageci_slice(&mut self, image: &Image, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsImageSampler_create_cIcS(self.this, image.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn create_with_type_datapr(&mut self, type_: ImageType, format: Format, size: &Size, stride: usize, data: *mut c_void) -> bool { unsafe { tsImageSampler_create_ITFcSzpr(self.this, type_, format, size, stride, data) != 0 } }
	pub fn create_with_type_datap(&mut self, type_: ImageType, format: Format, size: &Size, stride: usize, data: *const c_void) -> bool { unsafe { tsImageSampler_create_ITFcSzp(self.this, type_, format, size, stride, data) != 0 } }
	pub fn create_with_type_layersize(&mut self, type_: ImageType, format: Format, size: &Size, stride: usize, layer_size: usize, data: *mut c_void) -> bool { unsafe { tsImageSampler_create_ITFcSzzpr(self.this, type_, format, size, stride, layer_size, data) != 0 } }
	pub fn create_with_type_layersize_data(&mut self, type_: ImageType, format: Format, size: &Size, stride: usize, layer_size: usize, data: *const c_void) -> bool { unsafe { tsImageSampler_create_ITFcSzzp(self.this, type_, format, size, stride, layer_size, data) != 0 } }
	pub fn clear_with_colorcc(&mut self, color: &Color) -> bool { unsafe { tsImageSampler_clear_cC(self.this, color) != 0 } }
	pub fn clear_with_colorcic(&mut self, color: &ImageColor) -> bool { unsafe { tsImageSampler_clear_cIC(self.this, color) != 0 } }
	pub fn mad(&mut self, m: &Color, a: &Color) -> bool { unsafe { tsImageSampler_mad(self.this, m, a) != 0 } }
	pub fn set2d(&mut self, x: u32, y: u32, color: &ImageColor) { unsafe { tsImageSampler_set2D(self.this, x, y, color) } }
	pub fn get2d(&self, x: u32, y: u32) -> ImageColor { unsafe { tsImageSampler_get2D_cuub(self.this, x, y, 0) } }
	pub fn get2d_with_repeat(&self, x: u32, y: u32, repeat: bool) -> ImageColor { unsafe { tsImageSampler_get2D_cuub(self.this, x, y, if repeat {1} else {0}) } }
	pub fn get2df64(&self, x: f64, y: f64) -> ImageColor { unsafe { tsImageSampler_get2D_cf64f64bIF(self.this, x, y, 0, ImageFilter::Linear) } }
	pub fn get2df64_with_repeat(&self, x: f64, y: f64, repeat: bool) -> ImageColor { unsafe { tsImageSampler_get2D_cf64f64bIF(self.this, x, y, if repeat {1} else {0}, ImageFilter::Linear) } }
	pub fn get2df64_with_repeat_filter(&self, x: f64, y: f64, repeat: bool, filter: ImageFilter) -> ImageColor { unsafe { tsImageSampler_get2D_cf64f64bIF(self.this, x, y, if repeat {1} else {0}, filter) } }
	pub fn set3d(&mut self, x: u32, y: u32, z: u32, color: &ImageColor) { unsafe { tsImageSampler_set3D(self.this, x, y, z, color) } }
	pub fn get3d(&self, x: u32, y: u32, z: u32) -> ImageColor { unsafe { tsImageSampler_get3D_cuuub(self.this, x, y, z, 0) } }
	pub fn get3d_with_repeat(&self, x: u32, y: u32, z: u32, repeat: bool) -> ImageColor { unsafe { tsImageSampler_get3D_cuuub(self.this, x, y, z, if repeat {1} else {0}) } }
	pub fn get3df32(&self, x: f32, y: f32, z: f32) -> ImageColor { unsafe { tsImageSampler_get3D_cfffbIF(self.this, x, y, z, 0, ImageFilter::Linear) } }
	pub fn get3df32_with_repeat(&self, x: f32, y: f32, z: f32, repeat: bool) -> ImageColor { unsafe { tsImageSampler_get3D_cfffbIF(self.this, x, y, z, if repeat {1} else {0}, ImageFilter::Linear) } }
	pub fn get3df32_with_repeat_filter(&self, x: f32, y: f32, z: f32, repeat: bool, filter: ImageFilter) -> ImageColor { unsafe { tsImageSampler_get3D_cfffbIF(self.this, x, y, z, if repeat {1} else {0}, filter) } }
	pub fn set_cube(&mut self, x: f32, y: f32, z: f32, color: &ImageColor) { unsafe { tsImageSampler_setCube(self.this, x, y, z, color) } }
	pub fn cube(&self, x: f32, y: f32, z: f32) -> ImageColor { unsafe { tsImageSampler_getCube(self.this, x, y, z, ImageFilter::Linear) } }
	pub fn cube_with_filter(&self, x: f32, y: f32, z: f32, filter: ImageFilter) -> ImageColor { unsafe { tsImageSampler_getCube(self.this, x, y, z, filter) } }
	pub fn cube_face(&self, x: f32, y: f32, z: f32, tx: &mut f32, ty: &mut f32) -> u32 { unsafe { tsImageSampler_getCubeFace(self.this, x, y, z, tx, ty) } }
	pub fn set_texel(&mut self, t: usize, color: &ImageColor) { unsafe { tsImageSampler_setTexel(self.this, t, color) } }
	pub fn texel(&self, t: usize) -> ImageColor { unsafe { tsImageSampler_getTexel(self.this, t) } }
}
impl Drop for ImageSampler {
	fn drop(&mut self) { if self.owner { unsafe { tsImageSampler_delete(self.this) } } }
}
impl fmt::Display for ImageSampler {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ImageSampler ".to_string();
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsImageSampler_new() -> *mut c_void;
	fn tsImageSampler_new_IcS(image: *mut c_void, slice: *const Slice) -> *mut c_void;
	fn tsImageSampler_new_cIcS(image: *mut c_void, slice: *const Slice) -> *mut c_void;
	fn tsImageSampler_delete(this: *mut c_void);
	fn tsImageSampler_clear(this: *mut c_void);
	fn tsImageSampler_isCreated(this: *const c_void) -> i32;
	fn tsImageSampler_getType(this: *const c_void) -> ImageType;
	fn tsImageSampler_is2DType(this: *const c_void) -> i32;
	fn tsImageSampler_is3DType(this: *const c_void) -> i32;
	fn tsImageSampler_isCubeType(this: *const c_void) -> i32;
	fn tsImageSampler_getFormat(this: *const c_void) -> Format;
	fn tsImageSampler_getFormatName(this: *const c_void) -> *const c_char;
	fn tsImageSampler_getWidth(this: *const c_void) -> u32;
	fn tsImageSampler_getHeight(this: *const c_void) -> u32;
	fn tsImageSampler_getDepth(this: *const c_void) -> u32;
	fn tsImageSampler_getFaces(this: *const c_void) -> u32;
	fn tsImageSampler_getTexels(this: *const c_void) -> usize;
	fn tsImageSampler_getSize(this: *const c_void) -> Size;
	fn tsImageSampler_getRegion(this: *const c_void) -> Region;
	fn tsImageSampler_getStride(this: *const c_void) -> usize;
	fn tsImageSampler_getLayerSize(this: *const c_void) -> usize;
	fn tsImageSampler_getPixelSize(this: *const c_void) -> u32;
	fn tsImageSampler_getComponents(this: *const c_void) -> u32;
	fn tsImageSampler_getData_c(this: *const c_void) -> *const u8;
	fn tsImageSampler_getData(this: *mut c_void) -> *mut u8;
	fn tsImageSampler_create_IcS(this: *mut c_void, image: *mut c_void, slice: *const Slice) -> i32;
	fn tsImageSampler_create_cIcS(this: *mut c_void, image: *mut c_void, slice: *const Slice) -> i32;
	fn tsImageSampler_create_ITFcSzpr(this: *mut c_void, type_: ImageType, format: Format, size: *const Size, stride: usize, data: *mut c_void) -> i32;
	fn tsImageSampler_create_ITFcSzp(this: *mut c_void, type_: ImageType, format: Format, size: *const Size, stride: usize, data: *const c_void) -> i32;
	fn tsImageSampler_create_ITFcSzzpr(this: *mut c_void, type_: ImageType, format: Format, size: *const Size, stride: usize, layer_size: usize, data: *mut c_void) -> i32;
	fn tsImageSampler_create_ITFcSzzp(this: *mut c_void, type_: ImageType, format: Format, size: *const Size, stride: usize, layer_size: usize, data: *const c_void) -> i32;
	fn tsImageSampler_clear_cC(this: *mut c_void, color: *const Color) -> i32;
	fn tsImageSampler_clear_cIC(this: *mut c_void, color: *const ImageColor) -> i32;
	fn tsImageSampler_mad(this: *mut c_void, m: *const Color, a: *const Color) -> i32;
	fn tsImageSampler_set2D(this: *mut c_void, x: u32, y: u32, color: *const ImageColor);
	fn tsImageSampler_get2D_cuub(this: *const c_void, x: u32, y: u32, repeat: i32) -> ImageColor;
	fn tsImageSampler_get2D_cf64f64bIF(this: *const c_void, x: f64, y: f64, repeat: i32, filter: ImageFilter) -> ImageColor;
	fn tsImageSampler_set3D(this: *mut c_void, x: u32, y: u32, z: u32, color: *const ImageColor);
	fn tsImageSampler_get3D_cuuub(this: *const c_void, x: u32, y: u32, z: u32, repeat: i32) -> ImageColor;
	fn tsImageSampler_get3D_cfffbIF(this: *const c_void, x: f32, y: f32, z: f32, repeat: i32, filter: ImageFilter) -> ImageColor;
	fn tsImageSampler_setCube(this: *mut c_void, x: f32, y: f32, z: f32, color: *const ImageColor);
	fn tsImageSampler_getCube(this: *const c_void, x: f32, y: f32, z: f32, filter: ImageFilter) -> ImageColor;
	fn tsImageSampler_getCubeFace(this: *const c_void, x: f32, y: f32, z: f32, tx: &mut f32, ty: &mut f32) -> u32;
	fn tsImageSampler_setTexel(this: *mut c_void, t: usize, color: *const ImageColor);
	fn tsImageSampler_getTexel(this: *const c_void, t: usize) -> ImageColor;
}

// Tellusim::MeshNode
pub struct MeshNode {
	this: *mut c_void,
	owner: bool,
}
impl MeshNode {
	pub fn null() -> MeshNode { MeshNode { this: ptr::null_mut(), owner: false } }
	pub fn new_with_name(name: &str) -> MeshNode {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshNode { this: tsMeshNode_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_mesh(mesh: &mut Mesh) -> MeshNode { unsafe { MeshNode { this: tsMeshNode_new_Ms(mesh.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_mesh_name(mesh: &mut Mesh, name: &str) -> MeshNode {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshNode { this: tsMeshNode_new_Ms(mesh.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent(parent: Option<&MeshNode>) -> MeshNode { unsafe { MeshNode { this: tsMeshNode_new_MNs(match parent { Some(parent) => &parent.this, None => ptr::null() }, ptr::null_mut()), owner: true } } }
	pub fn new_with_parent_name(parent: Option<&MeshNode>, name: &str) -> MeshNode {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshNode { this: tsMeshNode_new_MNs(match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_mesh_parent(mesh: &mut Mesh, parent: Option<&MeshNode>) -> MeshNode { unsafe { MeshNode { this: tsMeshNode_new_MMNs(mesh.this, match parent { Some(parent) => &parent.this, None => ptr::null() }, ptr::null_mut()), owner: true } } }
	pub fn new_with_mesh_parent_name(mesh: &mut Mesh, parent: Option<&MeshNode>, name: &str) -> MeshNode {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshNode { this: tsMeshNode_new_MMNs(mesh.this, match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshNode { unsafe { MeshNode { this: ptr, owner: tsMeshNode_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshNode { unsafe { MeshNode { this: tsMeshNode_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshNode) -> bool { unsafe { tsMeshNode_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshNode { unsafe { MeshNode { this: tsMeshNode_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshNode_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshNode_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshNode_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshNode_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshNode_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshNode_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshNode_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshNode_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshNode_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshNode_clear(self.this) } }
	pub fn clone(&self, mesh: &mut Mesh) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshNode_clone(self.this, mesh.this)) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshNode_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshNode_getName(self.this)) } }
	pub fn index(&self) -> u32 { unsafe { tsMeshNode_getIndex(self.this) } }
	pub fn set_mesh(&mut self, mesh: &mut Mesh) { unsafe { tsMeshNode_setMesh(self.this, mesh.this, 1) } }
	pub fn set_mesh_with_check(&mut self, mesh: &mut Mesh, check: bool) { unsafe { tsMeshNode_setMesh(self.this, mesh.this, if check {1} else {0}) } }
	pub fn mesh(&self) -> Mesh { unsafe { Mesh::new_ptr(tsMeshNode_getMesh_c(self.this)) } }
	pub fn mesh_mut(&mut self) -> Mesh { unsafe { Mesh::new_ptr(tsMeshNode_getMesh(self.this)) } }
	pub fn set_parent(&mut self, parent: &mut MeshNode) -> u32 { unsafe { tsMeshNode_setParent(self.this, parent.this, 1) } }
	pub fn set_parent_with_check(&mut self, parent: &mut MeshNode, check: bool) -> u32 { unsafe { tsMeshNode_setParent(self.this, parent.this, if check {1} else {0}) } }
	pub fn parent(&self) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshNode_getParent_c(self.this)) } }
	pub fn parent_mut(&mut self) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshNode_getParent(self.this)) } }
	pub fn is_root(&self) -> bool { unsafe { tsMeshNode_isRoot(self.this) != 0 } }
	pub fn reserve_children(&mut self, num_children: u32) { unsafe { tsMeshNode_reserveChildren(self.this, num_children) } }
	pub fn add_child(&mut self, child: &mut MeshNode) -> u32 { unsafe { tsMeshNode_addChild(self.this, child.this, 1) } }
	pub fn add_child_with_check(&mut self, child: &mut MeshNode, check: bool) -> u32 { unsafe { tsMeshNode_addChild(self.this, child.this, if check {1} else {0}) } }
	pub fn remove_child(&mut self, child: &mut MeshNode) -> bool { unsafe { tsMeshNode_removeChild(self.this, child.this) != 0 } }
	pub fn release_children(&mut self) { unsafe { tsMeshNode_releaseChildren(self.this) } }
	pub fn find_child(&self, child: &MeshNode) -> u32 { unsafe { tsMeshNode_findChild_ccMN(self.this, child.this) } }
	pub fn find_child_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshNode_findChild_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_children(&self) -> u32 { unsafe { tsMeshNode_getNumChildren(self.this) } }
	pub fn child(&self, index: u32) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshNode_getChild_cu(self.this, index)) } }
	pub fn child_with_name(&self, name: &str) -> MeshNode {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshNode::new_ptr(tsMeshNode_getChild_cs(self.this, name_.as_ptr())) }
	}
	pub fn child_mut(&mut self, index: u32) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshNode_getChild_u(self.this, index)) } }
	pub fn child_mut_with_name(&mut self, name: &str) -> MeshNode {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshNode::new_ptr(tsMeshNode_getChild_s(self.this, name_.as_ptr())) }
	}
	pub fn clear_geometries(&mut self) { unsafe { tsMeshNode_clearGeometries(self.this) } }
	pub fn reserve_geometries(&mut self, num_geometries: u32) { unsafe { tsMeshNode_reserveGeometries(self.this, num_geometries) } }
	pub fn add_geometry(&mut self, geometry: &mut MeshGeometry) -> u32 { unsafe { tsMeshNode_addGeometry(self.this, geometry.this, 1) } }
	pub fn add_geometry_with_check(&mut self, geometry: &mut MeshGeometry, check: bool) -> u32 { unsafe { tsMeshNode_addGeometry(self.this, geometry.this, if check {1} else {0}) } }
	pub fn remove_geometry(&mut self, geometry: &mut MeshGeometry) -> bool { unsafe { tsMeshNode_removeGeometry(self.this, geometry.this) != 0 } }
	pub fn replace_geometry(&mut self, old_geometry: &mut MeshGeometry, geometry: &mut MeshGeometry) -> bool { unsafe { tsMeshNode_replaceGeometry(self.this, old_geometry.this, geometry.this) != 0 } }
	pub fn find_geometry(&self, geometry: &MeshGeometry) -> u32 { unsafe { tsMeshNode_findGeometry(self.this, geometry.this) } }
	pub fn num_geometries(&self) -> u32 { unsafe { tsMeshNode_getNumGeometries(self.this) } }
	pub fn geometry(&self, index: u32) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshNode_getGeometry_cu(self.this, index)) } }
	pub fn geometry_mut(&mut self, index: u32) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshNode_getGeometry_u(self.this, index)) } }
	pub fn clear_attachments(&mut self) { unsafe { tsMeshNode_clearAttachments(self.this) } }
	pub fn reserve_attachments(&mut self, num_attachments: u32) { unsafe { tsMeshNode_reserveAttachments(self.this, num_attachments) } }
	pub fn add_attachment(&mut self, attachment: &mut MeshAttachment) -> u32 { unsafe { tsMeshNode_addAttachment(self.this, attachment.this, 1) } }
	pub fn add_attachment_with_check(&mut self, attachment: &mut MeshAttachment, check: bool) -> u32 { unsafe { tsMeshNode_addAttachment(self.this, attachment.this, if check {1} else {0}) } }
	pub fn remove_attachment(&mut self, attachment: &mut MeshAttachment) -> bool { unsafe { tsMeshNode_removeAttachment(self.this, attachment.this) != 0 } }
	pub fn replace_attachment(&mut self, old_attachment: &mut MeshAttachment, attachment: &mut MeshAttachment) -> bool { unsafe { tsMeshNode_replaceAttachment(self.this, old_attachment.this, attachment.this) != 0 } }
	pub fn find_attachment(&self, attachment: &MeshAttachment) -> u32 { unsafe { tsMeshNode_findAttachment_ccMA(self.this, attachment.this) } }
	pub fn find_attachment_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshNode_findAttachment_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_attachments(&self) -> u32 { unsafe { tsMeshNode_getNumAttachments(self.this) } }
	pub fn attachment(&self, index: u32) -> MeshAttachment { unsafe { MeshAttachment::new_ptr(tsMeshNode_getAttachment_cu(self.this, index)) } }
	pub fn attachment_mut(&mut self, index: u32) -> MeshAttachment { unsafe { MeshAttachment::new_ptr(tsMeshNode_getAttachment_u(self.this, index)) } }
	pub fn set_local_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMeshNode_setLocalTransform(self.this, transform) } }
	pub fn local_transform(&self) -> Matrix4x3d { unsafe { tsMeshNode_getLocalTransform(self.this) } }
	pub fn set_global_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMeshNode_setGlobalTransform(self.this, transform) } }
	pub fn global_transform(&self) -> Matrix4x3d { unsafe { tsMeshNode_getGlobalTransform(self.this) } }
	pub fn set_pivot_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMeshNode_setPivotTransform(self.this, transform) } }
	pub fn pivot_transform(&self) -> Matrix4x3d { unsafe { tsMeshNode_getPivotTransform(self.this) } }
	pub fn set_morph_transform(&mut self, transform: &Vector4f) { unsafe { tsMeshNode_setMorphTransform(self.this, transform) } }
	pub fn morph_transform(&self) -> Vector4f { unsafe { tsMeshNode_getMorphTransform(self.this) } }
	pub fn create_local_transforms(&mut self) { unsafe { tsMeshNode_createLocalTransforms(self.this, &Matrix4x3d::identity()) } }
	pub fn create_local_transforms_with_itransform(&mut self, itransform: &Matrix4x3d) { unsafe { tsMeshNode_createLocalTransforms(self.this, itransform) } }
	pub fn create_global_transforms(&mut self) { unsafe { tsMeshNode_createGlobalTransforms(self.this, &Matrix4x3d::identity()) } }
	pub fn create_global_transforms_with_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMeshNode_createGlobalTransforms(self.this, transform) } }
	pub fn set_transform(&mut self, scale: &Vector3d) { unsafe { tsMeshNode_setTransform(self.this, scale) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshNode_getMemory(self.this) } }
}
impl Drop for MeshNode {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshNode_delete(self.this) } } }
}
impl Clone for MeshNode {
	fn clone(&self) -> MeshNode { unsafe { MeshNode { this: tsMeshNode_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshNode { }
impl fmt::Display for MeshNode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshNode ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshNode_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshNode_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshNode_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshNode_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshNode_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshNode_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshNode_new_Ms(mesh: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshNode_new_MNs(parent: *const *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshNode_new_MMNs(mesh: *mut c_void, parent: *const *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshNode_delete(this: *mut c_void);
	fn tsMeshNode_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshNode_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshNode_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshNode_clearPtr(this: *const c_void);
	fn tsMeshNode_destroyPtr(this: *const c_void);
	fn tsMeshNode_acquirePtr(this: *const c_void);
	fn tsMeshNode_unacquirePtr(this: *const c_void);
	fn tsMeshNode_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshNode_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshNode_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshNode_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshNode_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshNode_clear(this: *mut c_void);
	fn tsMeshNode_clone(this: *const c_void, mesh: *mut c_void) -> *mut c_void;
	fn tsMeshNode_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshNode_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshNode_getIndex(this: *const c_void) -> u32;
	fn tsMeshNode_setMesh(this: *mut c_void, mesh: *mut c_void, check: i32);
	fn tsMeshNode_getMesh_c(this: *const c_void) -> *mut c_void;
	fn tsMeshNode_getMesh(this: *mut c_void) -> *mut c_void;
	fn tsMeshNode_setParent(this: *mut c_void, parent: *mut c_void, check: i32) -> u32;
	fn tsMeshNode_getParent_c(this: *const c_void) -> *mut c_void;
	fn tsMeshNode_getParent(this: *mut c_void) -> *mut c_void;
	fn tsMeshNode_isRoot(this: *const c_void) -> i32;
	fn tsMeshNode_reserveChildren(this: *mut c_void, num_children: u32);
	fn tsMeshNode_addChild(this: *mut c_void, child: *mut c_void, check: i32) -> u32;
	fn tsMeshNode_removeChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsMeshNode_releaseChildren(this: *mut c_void);
	fn tsMeshNode_findChild_ccMN(this: *const c_void, child: *mut c_void) -> u32;
	fn tsMeshNode_findChild_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMeshNode_getNumChildren(this: *const c_void) -> u32;
	fn tsMeshNode_getChild_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshNode_getChild_cs(this: *const c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshNode_getChild_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshNode_getChild_s(this: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshNode_clearGeometries(this: *mut c_void);
	fn tsMeshNode_reserveGeometries(this: *mut c_void, num_geometries: u32);
	fn tsMeshNode_addGeometry(this: *mut c_void, geometry: *mut c_void, check: i32) -> u32;
	fn tsMeshNode_removeGeometry(this: *mut c_void, geometry: *mut c_void) -> i32;
	fn tsMeshNode_replaceGeometry(this: *mut c_void, old_geometry: *mut c_void, geometry: *mut c_void) -> i32;
	fn tsMeshNode_findGeometry(this: *const c_void, geometry: *mut c_void) -> u32;
	fn tsMeshNode_getNumGeometries(this: *const c_void) -> u32;
	fn tsMeshNode_getGeometry_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshNode_getGeometry_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshNode_clearAttachments(this: *mut c_void);
	fn tsMeshNode_reserveAttachments(this: *mut c_void, num_attachments: u32);
	fn tsMeshNode_addAttachment(this: *mut c_void, attachment: *mut c_void, check: i32) -> u32;
	fn tsMeshNode_removeAttachment(this: *mut c_void, attachment: *mut c_void) -> i32;
	fn tsMeshNode_replaceAttachment(this: *mut c_void, old_attachment: *mut c_void, attachment: *mut c_void) -> i32;
	fn tsMeshNode_findAttachment_ccMA(this: *const c_void, attachment: *mut c_void) -> u32;
	fn tsMeshNode_findAttachment_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMeshNode_getNumAttachments(this: *const c_void) -> u32;
	fn tsMeshNode_getAttachment_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshNode_getAttachment_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshNode_setLocalTransform(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMeshNode_getLocalTransform(this: *const c_void) -> Matrix4x3d;
	fn tsMeshNode_setGlobalTransform(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMeshNode_getGlobalTransform(this: *const c_void) -> Matrix4x3d;
	fn tsMeshNode_setPivotTransform(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMeshNode_getPivotTransform(this: *const c_void) -> Matrix4x3d;
	fn tsMeshNode_setMorphTransform(this: *mut c_void, transform: *const Vector4f);
	fn tsMeshNode_getMorphTransform(this: *const c_void) -> Vector4f;
	fn tsMeshNode_createLocalTransforms(this: *mut c_void, itransform: *const Matrix4x3d);
	fn tsMeshNode_createGlobalTransforms(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMeshNode_setTransform(this: *mut c_void, scale: *const Vector3d);
	fn tsMeshNode_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshIndices
pub struct MeshIndices {
	this: *mut c_void,
	owner: bool,
}
impl MeshIndices {
	pub fn null() -> MeshIndices { MeshIndices { this: ptr::null_mut(), owner: false } }
	pub fn new_with_name(name: &str) -> MeshIndices {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshIndices { this: tsMeshIndices_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_type(type_: MeshIndicesType, format: Format) -> MeshIndices { unsafe { MeshIndices { this: tsMeshIndices_new_MITFs(type_, format, ptr::null_mut()), owner: true } } }
	pub fn new_with_type_name(type_: MeshIndicesType, format: Format, name: &str) -> MeshIndices {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshIndices { this: tsMeshIndices_new_MITFs(type_, format, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_type_size(type_: MeshIndicesType, format: Format, size: u32) -> MeshIndices { unsafe { MeshIndices { this: tsMeshIndices_new_MITFus(type_, format, size, ptr::null_mut()), owner: true } } }
	pub fn new_with_type_size_name(type_: MeshIndicesType, format: Format, size: u32, name: &str) -> MeshIndices {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshIndices { this: tsMeshIndices_new_MITFus(type_, format, size, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshIndices { unsafe { MeshIndices { this: ptr, owner: tsMeshIndices_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshIndices { unsafe { MeshIndices { this: tsMeshIndices_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshIndices) -> bool { unsafe { tsMeshIndices_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshIndices { unsafe { MeshIndices { this: tsMeshIndices_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshIndices_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshIndices_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshIndices_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshIndices_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshIndices_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshIndices_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshIndices_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshIndices_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshIndices_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshIndices_clear(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshIndices_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshIndices_getName(self.this)) } }
	pub fn create(&mut self, type_: MeshIndicesType, format: Format) { unsafe { tsMeshIndices_create(self.this, type_, format, 0) } }
	pub fn create_with_size(&mut self, type_: MeshIndicesType, format: Format, size: u32) { unsafe { tsMeshIndices_create(self.this, type_, format, size) } }
	pub fn type_(&self) -> MeshIndicesType { unsafe { tsMeshIndices_getType(self.this) } }
	pub fn type_name_with_type(type_: MeshIndicesType) -> string::String { unsafe { get_cstring(tsMeshIndices_getTypeName_MIT(type_)) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsMeshIndices_getTypeName_c(self.this)) } }
	pub fn is_unknown(&self) -> bool { unsafe { tsMeshIndices_isUnknown(self.this) != 0 } }
	pub fn is_point(&self) -> bool { unsafe { tsMeshIndices_isPoint(self.this) != 0 } }
	pub fn is_line(&self) -> bool { unsafe { tsMeshIndices_isLine(self.this) != 0 } }
	pub fn is_triangle(&self) -> bool { unsafe { tsMeshIndices_isTriangle(self.this) != 0 } }
	pub fn is_quadrilateral(&self) -> bool { unsafe { tsMeshIndices_isQuadrilateral(self.this) != 0 } }
	pub fn is_tetrahedron(&self) -> bool { unsafe { tsMeshIndices_isTetrahedron(self.this) != 0 } }
	pub fn is_primitive(&self) -> bool { unsafe { tsMeshIndices_isPrimitive(self.this) != 0 } }
	pub fn is_solid(&self) -> bool { unsafe { tsMeshIndices_isSolid(self.this) != 0 } }
	pub fn is_volume(&self) -> bool { unsafe { tsMeshIndices_isVolume(self.this) != 0 } }
	pub fn is_material(&self) -> bool { unsafe { tsMeshIndices_isMaterial(self.this) != 0 } }
	pub fn is_group(&self) -> bool { unsafe { tsMeshIndices_isGroup(self.this) != 0 } }
	pub fn is_joint(&self) -> bool { unsafe { tsMeshIndices_isJoint(self.this) != 0 } }
	pub fn is_edge(&self) -> bool { unsafe { tsMeshIndices_isEdge(self.this) != 0 } }
	pub fn primitive_size(&self) -> u32 { unsafe { tsMeshIndices_getPrimitiveSize(self.this) } }
	pub fn format(&self) -> Format { unsafe { tsMeshIndices_getFormat(self.this) } }
	pub fn format_name(&self) -> string::String { unsafe { get_cstring(tsMeshIndices_getFormatName(self.this)) } }
	pub fn set_geometry(&mut self, geometry: &mut MeshGeometry) { unsafe { tsMeshIndices_setGeometry(self.this, geometry.this, 1) } }
	pub fn set_geometry_with_check(&mut self, geometry: &mut MeshGeometry, check: bool) { unsafe { tsMeshIndices_setGeometry(self.this, geometry.this, if check {1} else {0}) } }
	pub fn geometry(&self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshIndices_getGeometry_c(self.this)) } }
	pub fn geometry_mut(&mut self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshIndices_getGeometry(self.this)) } }
	pub fn set_size(&mut self, size: u32) { unsafe { tsMeshIndices_setSize(self.this, size, 1, 0) } }
	pub fn set_size_with_discard(&mut self, size: u32, discard: bool) { unsafe { tsMeshIndices_setSize(self.this, size, if discard {1} else {0}, 0) } }
	pub fn set_size_with_discard_clear(&mut self, size: u32, discard: bool, clear: bool) { unsafe { tsMeshIndices_setSize(self.this, size, if discard {1} else {0}, if clear {1} else {0}) } }
	pub fn size(&self) -> u32 { unsafe { tsMeshIndices_getSize(self.this) } }
	pub fn stride(&self) -> u32 { unsafe { tsMeshIndices_getStride(self.this) } }
	pub fn bytes(&self) -> usize { unsafe { tsMeshIndices_getBytes(self.this) } }
	pub fn set_data(&mut self, value: u32) { unsafe { tsMeshIndices_setData_uuu(self.this, value, 0, 0) } }
	pub fn set_data_with_size(&mut self, value: u32, size: u32) { unsafe { tsMeshIndices_setData_uuu(self.this, value, size, 0) } }
	pub fn set_data_with_size_offset(&mut self, value: u32, size: u32, offset: u32) { unsafe { tsMeshIndices_setData_uuu(self.this, value, size, offset) } }
	pub fn set_data_with_src(&mut self, src: *const c_void) { unsafe { tsMeshIndices_setData_pFuu(self.this, src, Format::Unknown, 0, 1) } }
	pub fn set_data_with_src_format(&mut self, src: *const c_void, format: Format) { unsafe { tsMeshIndices_setData_pFuu(self.this, src, format, 0, 1) } }
	pub fn set_data_with_src_format_size(&mut self, src: *const c_void, format: Format, size: u32) { unsafe { tsMeshIndices_setData_pFuu(self.this, src, format, size, 1) } }
	pub fn set_data_with_src_format_size_repeat(&mut self, src: *const c_void, format: Format, size: u32, repeat: u32) { unsafe { tsMeshIndices_setData_pFuu(self.this, src, format, size, repeat) } }
	pub fn data_with_dest(&self, dest: *mut c_void) { unsafe { tsMeshIndices_getData_cprFuu(self.this, dest, Format::Unknown, 0, 1) } }
	pub fn data_with_dest_format(&self, dest: *mut c_void, format: Format) { unsafe { tsMeshIndices_getData_cprFuu(self.this, dest, format, 0, 1) } }
	pub fn data_with_dest_format_size(&self, dest: *mut c_void, format: Format, size: u32) { unsafe { tsMeshIndices_getData_cprFuu(self.this, dest, format, size, 1) } }
	pub fn data_with_dest_format_size_repeat(&self, dest: *mut c_void, format: Format, size: u32, repeat: u32) { unsafe { tsMeshIndices_getData_cprFuu(self.this, dest, format, size, repeat) } }
	pub fn data(&self) -> *const c_void { unsafe { tsMeshIndices_getData_c(self.this) } }
	pub fn data_mut(&mut self) -> *mut c_void { unsafe { tsMeshIndices_getData(self.this) } }
	pub fn set(&mut self, index: u32, value: u32) { unsafe { tsMeshIndices_set_uu(self.this, index, value) } }
	pub fn set2(&mut self, index: u32, value_0: u32, value_1: u32) { unsafe { tsMeshIndices_set_uuu(self.this, index, value_0, value_1) } }
	pub fn set3(&mut self, index: u32, value_0: u32, value_1: u32, value_2: u32) { unsafe { tsMeshIndices_set_uuuu(self.this, index, value_0, value_1, value_2) } }
	pub fn set4(&mut self, index: u32, value_0: u32, value_1: u32, value_2: u32, value_3: u32) { unsafe { tsMeshIndices_set_uuuuu(self.this, index, value_0, value_1, value_2, value_3) } }
	pub fn get(&self, index: u32) -> u32 { unsafe { tsMeshIndices_get_cu(self.this, index) } }
	pub fn get2(&self, index: u32, value_0: &mut u32, value_1: &mut u32) { unsafe { tsMeshIndices_get_cuurur(self.this, index, value_0, value_1) } }
	pub fn get3(&self, index: u32, value_0: &mut u32, value_1: &mut u32, value_2: &mut u32) { unsafe { tsMeshIndices_get_cuururur(self.this, index, value_0, value_1, value_2) } }
	pub fn get4(&self, index: u32, value_0: &mut u32, value_1: &mut u32, value_2: &mut u32, value_3: &mut u32) { unsafe { tsMeshIndices_get_cuurururur(self.this, index, value_0, value_1, value_2, value_3) } }
	pub fn ptr(&self, index: u32) -> *const c_void { unsafe { tsMeshIndices_getPtr_cu(self.this, index) } }
	pub fn ptr_mut(&mut self, index: u32) -> *mut c_void { unsafe { tsMeshIndices_getPtr_u(self.this, index) } }
	pub fn is_direct(&self) -> bool { unsafe { tsMeshIndices_isDirect(self.this) != 0 } }
	pub fn is_uniform(&self) -> bool { unsafe { tsMeshIndices_isUniform(self.this) != 0 } }
	pub fn min_index(&self) -> u32 { unsafe { tsMeshIndices_getMinIndex(self.this) } }
	pub fn max_index(&self) -> u32 { unsafe { tsMeshIndices_getMaxIndex(self.this) } }
	pub fn compare(&self, indices: &MeshIndices) -> i32 { unsafe { tsMeshIndices_compare(self.this, indices.this) } }
	pub fn add_indices(&mut self, indices: &MeshIndices, offset: u32) { unsafe { tsMeshIndices_addIndices(self.this, indices.this, offset, 0) } }
	pub fn add_indices_with_expand(&mut self, indices: &MeshIndices, offset: u32, expand: bool) { unsafe { tsMeshIndices_addIndices(self.this, indices.this, offset, if expand {1} else {0}) } }
	pub fn to_format(&self, format: Format) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshIndices_toFormat(self.this, format)) } }
	pub fn to_type(&self, type_: MeshIndicesType) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshIndices_toType_cMIT(self.this, type_)) } }
	pub fn to_type_with_positionattribute(&self, type_: MeshIndicesType, position_attribute: &MeshAttribute) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshIndices_toType_cMITcMA(self.this, type_, position_attribute.this)) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshIndices_getMemory(self.this) } }
}
impl Drop for MeshIndices {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshIndices_delete(self.this) } } }
}
impl Clone for MeshIndices {
	fn clone(&self) -> MeshIndices { unsafe { MeshIndices { this: tsMeshIndices_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshIndices { }
impl fmt::Display for MeshIndices {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshIndices ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshIndices_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshIndices_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshIndices_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshIndices_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshIndices_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshIndices_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshIndices_new_MITFs(type_: MeshIndicesType, format: Format, name: *const c_char) -> *mut c_void;
	fn tsMeshIndices_new_MITFus(type_: MeshIndicesType, format: Format, size: u32, name: *const c_char) -> *mut c_void;
	fn tsMeshIndices_delete(this: *mut c_void);
	fn tsMeshIndices_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshIndices_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshIndices_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshIndices_clearPtr(this: *const c_void);
	fn tsMeshIndices_destroyPtr(this: *const c_void);
	fn tsMeshIndices_acquirePtr(this: *const c_void);
	fn tsMeshIndices_unacquirePtr(this: *const c_void);
	fn tsMeshIndices_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshIndices_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshIndices_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshIndices_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshIndices_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshIndices_clear(this: *mut c_void);
	fn tsMeshIndices_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshIndices_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshIndices_create(this: *mut c_void, type_: MeshIndicesType, format: Format, size: u32);
	fn tsMeshIndices_getType(this: *const c_void) -> MeshIndicesType;
	fn tsMeshIndices_getTypeName_MIT(type_: MeshIndicesType) -> *const c_char;
	fn tsMeshIndices_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsMeshIndices_isUnknown(this: *const c_void) -> i32;
	fn tsMeshIndices_isPoint(this: *const c_void) -> i32;
	fn tsMeshIndices_isLine(this: *const c_void) -> i32;
	fn tsMeshIndices_isTriangle(this: *const c_void) -> i32;
	fn tsMeshIndices_isQuadrilateral(this: *const c_void) -> i32;
	fn tsMeshIndices_isTetrahedron(this: *const c_void) -> i32;
	fn tsMeshIndices_isPrimitive(this: *const c_void) -> i32;
	fn tsMeshIndices_isSolid(this: *const c_void) -> i32;
	fn tsMeshIndices_isVolume(this: *const c_void) -> i32;
	fn tsMeshIndices_isMaterial(this: *const c_void) -> i32;
	fn tsMeshIndices_isGroup(this: *const c_void) -> i32;
	fn tsMeshIndices_isJoint(this: *const c_void) -> i32;
	fn tsMeshIndices_isEdge(this: *const c_void) -> i32;
	fn tsMeshIndices_getPrimitiveSize(this: *const c_void) -> u32;
	fn tsMeshIndices_getFormat(this: *const c_void) -> Format;
	fn tsMeshIndices_getFormatName(this: *const c_void) -> *const c_char;
	fn tsMeshIndices_setGeometry(this: *mut c_void, geometry: *mut c_void, check: i32);
	fn tsMeshIndices_getGeometry_c(this: *const c_void) -> *mut c_void;
	fn tsMeshIndices_getGeometry(this: *mut c_void) -> *mut c_void;
	fn tsMeshIndices_setSize(this: *mut c_void, size: u32, discard: i32, clear: i32);
	fn tsMeshIndices_getSize(this: *const c_void) -> u32;
	fn tsMeshIndices_getStride(this: *const c_void) -> u32;
	fn tsMeshIndices_getBytes(this: *const c_void) -> usize;
	fn tsMeshIndices_setData_uuu(this: *mut c_void, value: u32, size: u32, offset: u32);
	fn tsMeshIndices_setData_pFuu(this: *mut c_void, src: *const c_void, format: Format, size: u32, repeat: u32);
	fn tsMeshIndices_getData_cprFuu(this: *const c_void, dest: *mut c_void, format: Format, size: u32, repeat: u32);
	fn tsMeshIndices_getData_c(this: *const c_void) -> *const c_void;
	fn tsMeshIndices_getData(this: *mut c_void) -> *mut c_void;
	fn tsMeshIndices_set_uu(this: *mut c_void, index: u32, value: u32);
	fn tsMeshIndices_set_uuu(this: *mut c_void, index: u32, value_0: u32, value_1: u32);
	fn tsMeshIndices_set_uuuu(this: *mut c_void, index: u32, value_0: u32, value_1: u32, value_2: u32);
	fn tsMeshIndices_set_uuuuu(this: *mut c_void, index: u32, value_0: u32, value_1: u32, value_2: u32, value_3: u32);
	fn tsMeshIndices_get_cu(this: *const c_void, index: u32) -> u32;
	fn tsMeshIndices_get_cuurur(this: *const c_void, index: u32, value_0: &mut u32, value_1: &mut u32);
	fn tsMeshIndices_get_cuururur(this: *const c_void, index: u32, value_0: &mut u32, value_1: &mut u32, value_2: &mut u32);
	fn tsMeshIndices_get_cuurururur(this: *const c_void, index: u32, value_0: &mut u32, value_1: &mut u32, value_2: &mut u32, value_3: &mut u32);
	fn tsMeshIndices_getPtr_cu(this: *const c_void, index: u32) -> *const c_void;
	fn tsMeshIndices_getPtr_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshIndices_isDirect(this: *const c_void) -> i32;
	fn tsMeshIndices_isUniform(this: *const c_void) -> i32;
	fn tsMeshIndices_getMinIndex(this: *const c_void) -> u32;
	fn tsMeshIndices_getMaxIndex(this: *const c_void) -> u32;
	fn tsMeshIndices_compare(this: *const c_void, indices: *mut c_void) -> i32;
	fn tsMeshIndices_addIndices(this: *mut c_void, indices: *mut c_void, offset: u32, expand: i32);
	fn tsMeshIndices_toFormat(this: *const c_void, format: Format) -> *mut c_void;
	fn tsMeshIndices_toType_cMIT(this: *const c_void, type_: MeshIndicesType) -> *mut c_void;
	fn tsMeshIndices_toType_cMITcMA(this: *const c_void, type_: MeshIndicesType, position_attribute: *mut c_void) -> *mut c_void;
	fn tsMeshIndices_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshAttribute
pub struct MeshAttribute {
	this: *mut c_void,
	owner: bool,
}
impl MeshAttribute {
	pub fn null() -> MeshAttribute { MeshAttribute { this: ptr::null_mut(), owner: false } }
	pub fn new_with_name(name: &str) -> MeshAttribute {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttribute { this: tsMeshAttribute_new_su(name_.as_ptr(), 0), owner: true } }
	}
	pub fn new_with_name_index(name: &str, index: u32) -> MeshAttribute {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttribute { this: tsMeshAttribute_new_su(name_.as_ptr(), index), owner: true } }
	}
	pub fn new_with_type_name(type_: MeshAttributeType, format: Format, name: &str) -> MeshAttribute {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttribute { this: tsMeshAttribute_new_MATFsu(type_, format, name_.as_ptr(), 0), owner: true } }
	}
	pub fn new_with_type_name_index(type_: MeshAttributeType, format: Format, name: &str, index: u32) -> MeshAttribute {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttribute { this: tsMeshAttribute_new_MATFsu(type_, format, name_.as_ptr(), index), owner: true } }
	}
	pub fn new_with_type_size_name(type_: MeshAttributeType, format: Format, size: u32, name: &str) -> MeshAttribute {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttribute { this: tsMeshAttribute_new_MATFusu(type_, format, size, name_.as_ptr(), 0), owner: true } }
	}
	pub fn new_with_type_size_name_index(type_: MeshAttributeType, format: Format, size: u32, name: &str, index: u32) -> MeshAttribute {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttribute { this: tsMeshAttribute_new_MATFusu(type_, format, size, name_.as_ptr(), index), owner: true } }
	}
	pub fn new_with_type_size(type_: MeshAttributeType, format: Format, size: u32, index: u32) -> MeshAttribute { unsafe { MeshAttribute { this: tsMeshAttribute_new_MATFuu(type_, format, size, index), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MeshAttribute { unsafe { MeshAttribute { this: ptr, owner: tsMeshAttribute_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshAttribute { unsafe { MeshAttribute { this: tsMeshAttribute_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshAttribute) -> bool { unsafe { tsMeshAttribute_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshAttribute { unsafe { MeshAttribute { this: tsMeshAttribute_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshAttribute_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshAttribute_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshAttribute_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshAttribute_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshAttribute_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshAttribute_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshAttribute_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshAttribute_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshAttribute_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshAttribute_clear(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshAttribute_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshAttribute_getName(self.this)) } }
	pub fn create(&mut self, type_: MeshAttributeType, format: Format) { unsafe { tsMeshAttribute_create(self.this, type_, format, 0) } }
	pub fn create_with_size(&mut self, type_: MeshAttributeType, format: Format, size: u32) { unsafe { tsMeshAttribute_create(self.this, type_, format, size) } }
	pub fn type_(&self) -> MeshAttributeType { unsafe { tsMeshAttribute_getType(self.this) } }
	pub fn type_name_with_type(type_: MeshAttributeType) -> string::String { unsafe { get_cstring(tsMeshAttribute_getTypeName_MAT(type_)) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsMeshAttribute_getTypeName_c(self.this)) } }
	pub fn is_unknown(&self) -> bool { unsafe { tsMeshAttribute_isUnknown(self.this) != 0 } }
	pub fn is_position(&self) -> bool { unsafe { tsMeshAttribute_isPosition(self.this) != 0 } }
	pub fn is_basis(&self) -> bool { unsafe { tsMeshAttribute_isBasis(self.this) != 0 } }
	pub fn is_normal(&self) -> bool { unsafe { tsMeshAttribute_isNormal(self.this) != 0 } }
	pub fn is_tangent(&self) -> bool { unsafe { tsMeshAttribute_isTangent(self.this) != 0 } }
	pub fn is_binormal(&self) -> bool { unsafe { tsMeshAttribute_isBinormal(self.this) != 0 } }
	pub fn is_spatial(&self) -> bool { unsafe { tsMeshAttribute_isSpatial(self.this) != 0 } }
	pub fn is_normalized(&self) -> bool { unsafe { tsMeshAttribute_isNormalized(self.this) != 0 } }
	pub fn is_tex_coord(&self) -> bool { unsafe { tsMeshAttribute_isTexCoord(self.this) != 0 } }
	pub fn is_weights(&self) -> bool { unsafe { tsMeshAttribute_isWeights(self.this) != 0 } }
	pub fn is_joints(&self) -> bool { unsafe { tsMeshAttribute_isJoints(self.this) != 0 } }
	pub fn is_color(&self) -> bool { unsafe { tsMeshAttribute_isColor(self.this) != 0 } }
	pub fn is_vertex(&self) -> bool { unsafe { tsMeshAttribute_isVertex(self.this) != 0 } }
	pub fn is_crease(&self) -> bool { unsafe { tsMeshAttribute_isCrease(self.this) != 0 } }
	pub fn format(&self) -> Format { unsafe { tsMeshAttribute_getFormat(self.this) } }
	pub fn format_name(&self) -> string::String { unsafe { get_cstring(tsMeshAttribute_getFormatName(self.this)) } }
	pub fn components(&self) -> u32 { unsafe { tsMeshAttribute_getComponents(self.this) } }
	pub fn is_packed(&self) -> bool { unsafe { tsMeshAttribute_isPacked(self.this) != 0 } }
	pub fn set_index(&mut self, index: u32) { unsafe { tsMeshAttribute_setIndex(self.this, index) } }
	pub fn index(&self) -> u32 { unsafe { tsMeshAttribute_getIndex(self.this) } }
	pub fn set_indices(&mut self, indices: &mut MeshIndices) { unsafe { tsMeshAttribute_setIndices(self.this, indices.this) } }
	pub fn indices(&self) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshAttribute_getIndices_c(self.this)) } }
	pub fn indices_mut(&mut self) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshAttribute_getIndices(self.this)) } }
	pub fn set_geometry(&mut self, geometry: &mut MeshGeometry) { unsafe { tsMeshAttribute_setGeometry(self.this, geometry.this, 1) } }
	pub fn set_geometry_with_check(&mut self, geometry: &mut MeshGeometry, check: bool) { unsafe { tsMeshAttribute_setGeometry(self.this, geometry.this, if check {1} else {0}) } }
	pub fn geometry(&self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshAttribute_getGeometry_c(self.this)) } }
	pub fn geometry_mut(&mut self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshAttribute_getGeometry(self.this)) } }
	pub fn set_size(&mut self, size: u32) { unsafe { tsMeshAttribute_setSize(self.this, size, 1, 0) } }
	pub fn set_size_with_discard(&mut self, size: u32, discard: bool) { unsafe { tsMeshAttribute_setSize(self.this, size, if discard {1} else {0}, 0) } }
	pub fn set_size_with_discard_clear(&mut self, size: u32, discard: bool, clear: bool) { unsafe { tsMeshAttribute_setSize(self.this, size, if discard {1} else {0}, if clear {1} else {0}) } }
	pub fn size(&self) -> u32 { unsafe { tsMeshAttribute_getSize(self.this) } }
	pub fn stride(&self) -> u32 { unsafe { tsMeshAttribute_getStride(self.this) } }
	pub fn bytes(&self) -> usize { unsafe { tsMeshAttribute_getBytes(self.this) } }
	pub fn set_data(&mut self, src: *const c_void) { unsafe { tsMeshAttribute_setData_puu(self.this, src, 0, 0) } }
	pub fn set_data_with_size(&mut self, src: *const c_void, size: u32) { unsafe { tsMeshAttribute_setData_puu(self.this, src, size, 0) } }
	pub fn set_data_with_size_stride(&mut self, src: *const c_void, size: u32, stride: u32) { unsafe { tsMeshAttribute_setData_puu(self.this, src, size, stride) } }
	pub fn set_data_with_indices(&mut self, src: *const c_void, indices: &[u32]) { unsafe { tsMeshAttribute_setData_pcA32u(self.this, src, indices.as_ptr(), indices.len() as u32, 0) } }
	pub fn set_data_with_indices_stride(&mut self, src: *const c_void, indices: &[u32], stride: u32) { unsafe { tsMeshAttribute_setData_pcA32u(self.this, src, indices.as_ptr(), indices.len() as u32, stride) } }
	pub fn data_with_dest(&self, dest: *mut c_void) { unsafe { tsMeshAttribute_getData_cpruu(self.this, dest, 0, 0) } }
	pub fn data_with_dest_size(&self, dest: *mut c_void, size: u32) { unsafe { tsMeshAttribute_getData_cpruu(self.this, dest, size, 0) } }
	pub fn data_with_dest_size_stride(&self, dest: *mut c_void, size: u32, stride: u32) { unsafe { tsMeshAttribute_getData_cpruu(self.this, dest, size, stride) } }
	pub fn data_with_dest_indicescmi(&self, dest: *mut c_void, indices: &MeshIndices) { unsafe { tsMeshAttribute_getData_cprcMIu(self.this, dest, indices.this, 0) } }
	pub fn data_with_dest_indicescmi_stride(&self, dest: *mut c_void, indices: &MeshIndices, stride: u32) { unsafe { tsMeshAttribute_getData_cprcMIu(self.this, dest, indices.this, stride) } }
	pub fn data_with_dest_indicesa32(&self, dest: *mut c_void, indices: &[u32]) { unsafe { tsMeshAttribute_getData_cprcA32u(self.this, dest, indices.as_ptr(), indices.len() as u32, 0) } }
	pub fn data_with_dest_indicesa32_stride(&self, dest: *mut c_void, indices: &[u32], stride: u32) { unsafe { tsMeshAttribute_getData_cprcA32u(self.this, dest, indices.as_ptr(), indices.len() as u32, stride) } }
	pub fn data(&self) -> *const c_void { unsafe { tsMeshAttribute_getData_c(self.this) } }
	pub fn data_mut(&mut self) -> *mut c_void { unsafe { tsMeshAttribute_getData(self.this) } }
	pub fn set_value(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsMeshAttribute_setValue(self.this, index, src, size) } }
	pub fn value(&self, index: u32, dest: *mut c_void, size: usize) { unsafe { tsMeshAttribute_getValue(self.this, index, dest, size) } }
	pub fn ptr(&self, index: u32) -> *const c_void { unsafe { tsMeshAttribute_getPtr_cu(self.this, index) } }
	pub fn ptr_mut(&mut self, index: u32) -> *mut c_void { unsafe { tsMeshAttribute_getPtr_u(self.this, index) } }
	pub fn compare(&self, attribute: &MeshAttribute) -> i32 { unsafe { tsMeshAttribute_compare(self.this, attribute.this, &Matrix4x3f::identity(), 1e-6, 1) } }
	pub fn compare_with_transform(&self, attribute: &MeshAttribute, transform: &Matrix4x3f) -> i32 { unsafe { tsMeshAttribute_compare(self.this, attribute.this, transform, 1e-6, 1) } }
	pub fn compare_with_transform_threshold(&self, attribute: &MeshAttribute, transform: &Matrix4x3f, threshold: f32) -> i32 { unsafe { tsMeshAttribute_compare(self.this, attribute.this, transform, threshold, 1) } }
	pub fn compare_with_transform_threshold_spatial(&self, attribute: &MeshAttribute, transform: &Matrix4x3f, threshold: f32, spatial: bool) -> i32 { unsafe { tsMeshAttribute_compare(self.this, attribute.this, transform, threshold, if spatial {1} else {0}) } }
	pub fn add_attribute(&mut self, attribute: &MeshAttribute) { unsafe { tsMeshAttribute_addAttribute(self.this, attribute.this) } }
	pub fn set_transform(&mut self, transform: &Matrix4x3f) -> bool { unsafe { tsMeshAttribute_setTransform(self.this, transform) != 0 } }
	pub fn morph_attribute(&mut self, attribute: &MeshAttribute, k: f32) -> bool { unsafe { tsMeshAttribute_morphAttribute(self.this, attribute.this, k) != 0 } }
	pub fn pack_attributes(&mut self, attribute_0: &MeshAttribute, attribute_1: &MeshAttribute, format: Format) -> bool { unsafe { tsMeshAttribute_packAttributes(self.this, attribute_0.this, attribute_1.this, format) != 0 } }
	pub fn unpack_attributes(&self, attribute_0: &mut MeshAttribute, attribute_1: &mut MeshAttribute) -> bool { unsafe { tsMeshAttribute_unpackAttributes(self.this, attribute_0.this, attribute_1.this) != 0 } }
	pub fn optimize_attribute(&self, indices: &mut MeshIndices) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshAttribute_optimizeAttribute(self.this, indices.this)) } }
	pub fn to_direct(&self, indices: &MeshIndices) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshAttribute_toDirect(self.this, indices.this)) } }
	pub fn to_format(&self, format: Format) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshAttribute_toFormat(self.this, format)) } }
	pub fn to_type(&self, type_: MeshAttributeType) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshAttribute_toType(self.this, type_)) } }
	pub fn covariance_matrix(&self) -> Matrix4x3f { unsafe { tsMeshAttribute_getCovarianceMatrix(self.this) } }
	pub fn min_transform(&self) -> Matrix4x3f { unsafe { tsMeshAttribute_getMinTransform(self.this) } }
	pub fn bound_box(&self) -> BoundBoxf { unsafe { tsMeshAttribute_getBoundBox(self.this) } }
	pub fn bound_sphere(&self) -> BoundSpheref { unsafe { tsMeshAttribute_getBoundSphere(self.this) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshAttribute_getMemory(self.this) } }
	pub fn set<Type>(&mut self, index: u32, value: Type) { unsafe { ptr::copy_nonoverlapping(&value, tsMeshAttribute_getPtr_u(self.this, index) as *mut Type, 1); } }
	pub fn get<Type: Default>(&self, index: u32) -> Type { let mut value = Type::default(); unsafe { ptr::copy_nonoverlapping(tsMeshAttribute_getPtr_cu(self.this, index) as *const Type, &mut value, 1); } value }
}
impl Drop for MeshAttribute {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshAttribute_delete(self.this) } } }
}
impl Clone for MeshAttribute {
	fn clone(&self) -> MeshAttribute { unsafe { MeshAttribute { this: tsMeshAttribute_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshAttribute { }
impl fmt::Display for MeshAttribute {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshAttribute ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshAttribute_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshAttribute_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshAttribute_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshAttribute_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshAttribute_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshAttribute_new_su(name: *const c_char, index: u32) -> *mut c_void;
	fn tsMeshAttribute_new_MATFsu(type_: MeshAttributeType, format: Format, name: *const c_char, index: u32) -> *mut c_void;
	fn tsMeshAttribute_new_MATFusu(type_: MeshAttributeType, format: Format, size: u32, name: *const c_char, index: u32) -> *mut c_void;
	fn tsMeshAttribute_new_MATFuu(type_: MeshAttributeType, format: Format, size: u32, index: u32) -> *mut c_void;
	fn tsMeshAttribute_delete(this: *mut c_void);
	fn tsMeshAttribute_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshAttribute_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAttribute_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAttribute_clearPtr(this: *const c_void);
	fn tsMeshAttribute_destroyPtr(this: *const c_void);
	fn tsMeshAttribute_acquirePtr(this: *const c_void);
	fn tsMeshAttribute_unacquirePtr(this: *const c_void);
	fn tsMeshAttribute_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshAttribute_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshAttribute_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshAttribute_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshAttribute_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAttribute_clear(this: *mut c_void);
	fn tsMeshAttribute_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshAttribute_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshAttribute_create(this: *mut c_void, type_: MeshAttributeType, format: Format, size: u32);
	fn tsMeshAttribute_getType(this: *const c_void) -> MeshAttributeType;
	fn tsMeshAttribute_getTypeName_MAT(type_: MeshAttributeType) -> *const c_char;
	fn tsMeshAttribute_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsMeshAttribute_isUnknown(this: *const c_void) -> i32;
	fn tsMeshAttribute_isPosition(this: *const c_void) -> i32;
	fn tsMeshAttribute_isBasis(this: *const c_void) -> i32;
	fn tsMeshAttribute_isNormal(this: *const c_void) -> i32;
	fn tsMeshAttribute_isTangent(this: *const c_void) -> i32;
	fn tsMeshAttribute_isBinormal(this: *const c_void) -> i32;
	fn tsMeshAttribute_isSpatial(this: *const c_void) -> i32;
	fn tsMeshAttribute_isNormalized(this: *const c_void) -> i32;
	fn tsMeshAttribute_isTexCoord(this: *const c_void) -> i32;
	fn tsMeshAttribute_isWeights(this: *const c_void) -> i32;
	fn tsMeshAttribute_isJoints(this: *const c_void) -> i32;
	fn tsMeshAttribute_isColor(this: *const c_void) -> i32;
	fn tsMeshAttribute_isVertex(this: *const c_void) -> i32;
	fn tsMeshAttribute_isCrease(this: *const c_void) -> i32;
	fn tsMeshAttribute_getFormat(this: *const c_void) -> Format;
	fn tsMeshAttribute_getFormatName(this: *const c_void) -> *const c_char;
	fn tsMeshAttribute_getComponents(this: *const c_void) -> u32;
	fn tsMeshAttribute_isPacked(this: *const c_void) -> i32;
	fn tsMeshAttribute_setIndex(this: *mut c_void, index: u32);
	fn tsMeshAttribute_getIndex(this: *const c_void) -> u32;
	fn tsMeshAttribute_setIndices(this: *mut c_void, indices: *mut c_void);
	fn tsMeshAttribute_getIndices_c(this: *const c_void) -> *mut c_void;
	fn tsMeshAttribute_getIndices(this: *mut c_void) -> *mut c_void;
	fn tsMeshAttribute_setGeometry(this: *mut c_void, geometry: *mut c_void, check: i32);
	fn tsMeshAttribute_getGeometry_c(this: *const c_void) -> *mut c_void;
	fn tsMeshAttribute_getGeometry(this: *mut c_void) -> *mut c_void;
	fn tsMeshAttribute_setSize(this: *mut c_void, size: u32, discard: i32, clear: i32);
	fn tsMeshAttribute_getSize(this: *const c_void) -> u32;
	fn tsMeshAttribute_getStride(this: *const c_void) -> u32;
	fn tsMeshAttribute_getBytes(this: *const c_void) -> usize;
	fn tsMeshAttribute_setData_puu(this: *mut c_void, src: *const c_void, size: u32, stride: u32);
	fn tsMeshAttribute_setData_pcA32u(this: *mut c_void, src: *const c_void, indices: *const u32, indices_size: u32, stride: u32);
	fn tsMeshAttribute_getData_cpruu(this: *const c_void, dest: *mut c_void, size: u32, stride: u32);
	fn tsMeshAttribute_getData_cprcMIu(this: *const c_void, dest: *mut c_void, indices: *mut c_void, stride: u32);
	fn tsMeshAttribute_getData_cprcA32u(this: *const c_void, dest: *mut c_void, indices: *const u32, indices_size: u32, stride: u32);
	fn tsMeshAttribute_getData_c(this: *const c_void) -> *const c_void;
	fn tsMeshAttribute_getData(this: *mut c_void) -> *mut c_void;
	fn tsMeshAttribute_setValue(this: *mut c_void, index: u32, src: *const c_void, size: usize);
	fn tsMeshAttribute_getValue(this: *const c_void, index: u32, dest: *mut c_void, size: usize);
	fn tsMeshAttribute_getPtr_cu(this: *const c_void, index: u32) -> *const c_void;
	fn tsMeshAttribute_getPtr_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshAttribute_compare(this: *const c_void, attribute: *mut c_void, transform: *const Matrix4x3f, threshold: f32, spatial: i32) -> i32;
	fn tsMeshAttribute_addAttribute(this: *mut c_void, attribute: *mut c_void);
	fn tsMeshAttribute_setTransform(this: *mut c_void, transform: *const Matrix4x3f) -> i32;
	fn tsMeshAttribute_morphAttribute(this: *mut c_void, attribute: *mut c_void, k: f32) -> i32;
	fn tsMeshAttribute_packAttributes(this: *mut c_void, attribute_0: *mut c_void, attribute_1: *mut c_void, format: Format) -> i32;
	fn tsMeshAttribute_unpackAttributes(this: *const c_void, attribute_0: *mut c_void, attribute_1: *mut c_void) -> i32;
	fn tsMeshAttribute_optimizeAttribute(this: *const c_void, indices: *mut c_void) -> *mut c_void;
	fn tsMeshAttribute_toDirect(this: *const c_void, indices: *mut c_void) -> *mut c_void;
	fn tsMeshAttribute_toFormat(this: *const c_void, format: Format) -> *mut c_void;
	fn tsMeshAttribute_toType(this: *const c_void, type_: MeshAttributeType) -> *mut c_void;
	fn tsMeshAttribute_getCovarianceMatrix(this: *const c_void) -> Matrix4x3f;
	fn tsMeshAttribute_getMinTransform(this: *const c_void) -> Matrix4x3f;
	fn tsMeshAttribute_getBoundBox(this: *const c_void) -> BoundBoxf;
	fn tsMeshAttribute_getBoundSphere(this: *const c_void) -> BoundSpheref;
	fn tsMeshAttribute_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshJoint
pub struct MeshJoint {
	this: *mut c_void,
	owner: bool,
}
impl MeshJoint {
	pub fn null() -> MeshJoint { MeshJoint { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshJoint { unsafe { MeshJoint { this: tsMeshJoint_new_s(ptr::null_mut()), owner: true } } }
	pub fn new_with_name(name: &str) -> MeshJoint {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshJoint { this: tsMeshJoint_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_geometry(geometry: &mut MeshGeometry) -> MeshJoint { unsafe { MeshJoint { this: tsMeshJoint_new_MGs(geometry.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_geometry_name(geometry: &mut MeshGeometry, name: &str) -> MeshJoint {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshJoint { this: tsMeshJoint_new_MGs(geometry.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshJoint { unsafe { MeshJoint { this: ptr, owner: tsMeshJoint_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshJoint { unsafe { MeshJoint { this: tsMeshJoint_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshJoint) -> bool { unsafe { tsMeshJoint_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshJoint { unsafe { MeshJoint { this: tsMeshJoint_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshJoint_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshJoint_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshJoint_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshJoint_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshJoint_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshJoint_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshJoint_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshJoint_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshJoint_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshJoint_clear(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshJoint_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshJoint_getName(self.this)) } }
	pub fn set_node(&mut self, node: &mut MeshNode) { unsafe { tsMeshJoint_setNode(self.this, node.this) } }
	pub fn node(&self) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshJoint_getNode_c(self.this)) } }
	pub fn node_mut(&mut self) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshJoint_getNode(self.this)) } }
	pub fn node_index(&self) -> u32 { unsafe { tsMeshJoint_getNodeIndex(self.this) } }
	pub fn local_transform(&self) -> Matrix4x3d { unsafe { tsMeshJoint_getLocalTransform(self.this) } }
	pub fn global_transform(&self) -> Matrix4x3d { unsafe { tsMeshJoint_getGlobalTransform(self.this) } }
	pub fn set_indices(&mut self, indices: &mut MeshIndices) { unsafe { tsMeshJoint_setIndices(self.this, indices.this) } }
	pub fn indices(&self) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshJoint_getIndices_c(self.this)) } }
	pub fn indices_mut(&mut self) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshJoint_getIndices(self.this)) } }
	pub fn set_geometry(&mut self, geometry: &mut MeshGeometry) { unsafe { tsMeshJoint_setGeometry(self.this, geometry.this, 1) } }
	pub fn set_geometry_with_check(&mut self, geometry: &mut MeshGeometry, check: bool) { unsafe { tsMeshJoint_setGeometry(self.this, geometry.this, if check {1} else {0}) } }
	pub fn geometry(&self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshJoint_getGeometry_c(self.this)) } }
	pub fn geometry_mut(&mut self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshJoint_getGeometry(self.this)) } }
	pub fn set_bound_box(&mut self, box_: &BoundBoxf) { unsafe { tsMeshJoint_setBoundBox(self.this, box_) } }
	pub fn bound_box(&self) -> BoundBoxf { unsafe { tsMeshJoint_getBoundBox(self.this) } }
	pub fn set_bound_sphere(&mut self, sphere: &BoundSpheref) { unsafe { tsMeshJoint_setBoundSphere(self.this, sphere) } }
	pub fn bound_sphere(&mut self) -> BoundSpheref { unsafe { tsMeshJoint_getBoundSphere(self.this) } }
	pub fn set_itransform(&mut self, itransform: &Matrix4x3f) { unsafe { tsMeshJoint_setITransform(self.this, itransform) } }
	pub fn itransform(&self) -> Matrix4x3f { unsafe { tsMeshJoint_getITransform(self.this) } }
	pub fn compare(&self, joint: &MeshJoint) -> i32 { unsafe { tsMeshJoint_compare(self.this, joint.this) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshJoint_getMemory(self.this) } }
}
impl Drop for MeshJoint {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshJoint_delete(self.this) } } }
}
impl Clone for MeshJoint {
	fn clone(&self) -> MeshJoint { unsafe { MeshJoint { this: tsMeshJoint_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshJoint { }
impl fmt::Display for MeshJoint {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshJoint ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshJoint_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshJoint_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshJoint_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshJoint_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshJoint_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshJoint_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshJoint_new_MGs(geometry: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshJoint_delete(this: *mut c_void);
	fn tsMeshJoint_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshJoint_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_clearPtr(this: *const c_void);
	fn tsMeshJoint_destroyPtr(this: *const c_void);
	fn tsMeshJoint_acquirePtr(this: *const c_void);
	fn tsMeshJoint_unacquirePtr(this: *const c_void);
	fn tsMeshJoint_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshJoint_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshJoint_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshJoint_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshJoint_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_clear(this: *mut c_void);
	fn tsMeshJoint_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshJoint_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_setNode(this: *mut c_void, node: *mut c_void);
	fn tsMeshJoint_getNode_c(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_getNode(this: *mut c_void) -> *mut c_void;
	fn tsMeshJoint_getNodeIndex(this: *const c_void) -> u32;
	fn tsMeshJoint_getLocalTransform(this: *const c_void) -> Matrix4x3d;
	fn tsMeshJoint_getGlobalTransform(this: *const c_void) -> Matrix4x3d;
	fn tsMeshJoint_setIndices(this: *mut c_void, indices: *mut c_void);
	fn tsMeshJoint_getIndices_c(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_getIndices(this: *mut c_void) -> *mut c_void;
	fn tsMeshJoint_setGeometry(this: *mut c_void, geometry: *mut c_void, check: i32);
	fn tsMeshJoint_getGeometry_c(this: *const c_void) -> *mut c_void;
	fn tsMeshJoint_getGeometry(this: *mut c_void) -> *mut c_void;
	fn tsMeshJoint_setBoundBox(this: *mut c_void, box_: *const BoundBoxf);
	fn tsMeshJoint_getBoundBox(this: *const c_void) -> BoundBoxf;
	fn tsMeshJoint_setBoundSphere(this: *mut c_void, sphere: *const BoundSpheref);
	fn tsMeshJoint_getBoundSphere(this: *mut c_void) -> BoundSpheref;
	fn tsMeshJoint_setITransform(this: *mut c_void, itransform: *const Matrix4x3f);
	fn tsMeshJoint_getITransform(this: *const c_void) -> Matrix4x3f;
	fn tsMeshJoint_compare(this: *const c_void, joint: *mut c_void) -> i32;
	fn tsMeshJoint_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshMaterial
pub struct MeshMaterial {
	this: *mut c_void,
	owner: bool,
}
impl MeshMaterial {
	pub fn null() -> MeshMaterial { MeshMaterial { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshMaterial { unsafe { MeshMaterial { this: tsMeshMaterial_new_s(ptr::null_mut()), owner: true } } }
	pub fn new_with_name(name: &str) -> MeshMaterial {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshMaterial { this: tsMeshMaterial_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_geometry(geometry: &mut MeshGeometry) -> MeshMaterial { unsafe { MeshMaterial { this: tsMeshMaterial_new_MGs(geometry.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_geometry_name(geometry: &mut MeshGeometry, name: &str) -> MeshMaterial {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshMaterial { this: tsMeshMaterial_new_MGs(geometry.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshMaterial { unsafe { MeshMaterial { this: ptr, owner: tsMeshMaterial_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshMaterial { unsafe { MeshMaterial { this: tsMeshMaterial_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshMaterial) -> bool { unsafe { tsMeshMaterial_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshMaterial { unsafe { MeshMaterial { this: tsMeshMaterial_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshMaterial_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshMaterial_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshMaterial_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshMaterial_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshMaterial_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshMaterial_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshMaterial_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshMaterial_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshMaterial_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshMaterial_clear(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshMaterial_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshMaterial_getName(self.this)) } }
	pub fn index(&self) -> u32 { unsafe { tsMeshMaterial_getIndex(self.this) } }
	pub fn set_indices(&mut self, indices: &mut MeshIndices) { unsafe { tsMeshMaterial_setIndices(self.this, indices.this) } }
	pub fn indices(&self) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshMaterial_getIndices_c(self.this)) } }
	pub fn indices_mut(&mut self) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshMaterial_getIndices(self.this)) } }
	pub fn set_geometry(&mut self, geometry: &mut MeshGeometry) { unsafe { tsMeshMaterial_setGeometry(self.this, geometry.this, 1) } }
	pub fn set_geometry_with_check(&mut self, geometry: &mut MeshGeometry, check: bool) { unsafe { tsMeshMaterial_setGeometry(self.this, geometry.this, if check {1} else {0}) } }
	pub fn geometry(&self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshMaterial_getGeometry_c(self.this)) } }
	pub fn geometry_mut(&mut self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshMaterial_getGeometry(self.this)) } }
	pub fn set_data(&mut self, data: &str) {
		let data_ = CString::new(data).unwrap();
		unsafe { tsMeshMaterial_setData_s(self.this, data_.as_ptr()) }
	}
	pub fn set_data_with_data(&mut self, data: &String) { unsafe { tsMeshMaterial_setData_cS(self.this, data.this) } }
	pub fn data(&self) -> string::String { unsafe { get_string(tsMeshMaterial_getData(self.this)) } }
	pub fn clear_parameters(&mut self) { unsafe { tsMeshMaterial_clearParameters(self.this) } }
	pub fn remove_parameter(&mut self, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_removeParameter(self.this, type__.as_ptr()) != 0 }
	}
	pub fn copy_parameters(&mut self, material: &MeshMaterial) { unsafe { tsMeshMaterial_copyParameters(self.this, material.this) } }
	pub fn find_parameter(&self, type_: &str) -> u32 {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_findParameter(self.this, type__.as_ptr()) }
	}
	pub fn has_parameter(&self, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_hasParameter(self.this, type__.as_ptr()) != 0 }
	}
	pub fn num_parameters(&self) -> u32 { unsafe { tsMeshMaterial_getNumParameters(self.this) } }
	pub fn parameter_type(&self, index: u32) -> string::String { unsafe { get_string(tsMeshMaterial_getParameterType(self.this, index)) } }
	pub fn add_parameter(&mut self, type_: &str, value: bool) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_sb(self.this, type__.as_ptr(), if value {1} else {0}) }
	}
	pub fn add_parameter_with_valuef32(&mut self, type_: &str, value: f32) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_sf(self.this, type__.as_ptr(), value) }
	}
	pub fn add_parameter_with_valuecv4(&mut self, type_: &str, value: &Vector4f) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_scV4(self.this, type__.as_ptr(), value) }
	}
	pub fn add_parameter_with_valuecm32(&mut self, type_: &str, value: &Matrix3x2f) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_scM32(self.this, type__.as_ptr(), value) }
	}
	pub fn add_parameter_with_color(&mut self, type_: &str, color: &Color) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_scC(self.this, type__.as_ptr(), color) }
	}
	pub fn add_parameter_with_name(&mut self, type_: &str, name: &str) {
		let type__ = CString::new(type_).unwrap();
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshMaterial_addParameter_sss(self.this, type__.as_ptr(), name_.as_ptr(), ptr::null_mut()) }
	}
	pub fn add_parameter_with_name_layout(&mut self, type_: &str, name: &str, layout: &str) {
		let type__ = CString::new(type_).unwrap();
		let name_ = CString::new(name).unwrap();
		let layout_ = CString::new(layout).unwrap();
		unsafe { tsMeshMaterial_addParameter_sss(self.this, type__.as_ptr(), name_.as_ptr(), layout_.as_ptr()) }
	}
	pub fn add_parameter_with_names(&mut self, type_: &str, name: &String) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_scSs(self.this, type__.as_ptr(), name.this, ptr::null_mut()) }
	}
	pub fn add_parameter_with_names_layout(&mut self, type_: &str, name: &String, layout: &str) {
		let type__ = CString::new(type_).unwrap();
		let layout_ = CString::new(layout).unwrap();
		unsafe { tsMeshMaterial_addParameter_scSs(self.this, type__.as_ptr(), name.this, layout_.as_ptr()) }
	}
	pub fn add_parameter_with_image(&mut self, type_: &str, image: &Image) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_scIs(self.this, type__.as_ptr(), image.this, ptr::null_mut()) }
	}
	pub fn add_parameter_with_image_layout(&mut self, type_: &str, image: &Image, layout: &str) {
		let type__ = CString::new(type_).unwrap();
		let layout_ = CString::new(layout).unwrap();
		unsafe { tsMeshMaterial_addParameter_scIs(self.this, type__.as_ptr(), image.this, layout_.as_ptr()) }
	}
	pub fn add_parameter_with_blob(&mut self, type_: &str, blob: &mut Blob) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_addParameter_sBs(self.this, type__.as_ptr(), blob.this, ptr::null_mut()) }
	}
	pub fn add_parameter_with_blob_layout(&mut self, type_: &str, blob: &mut Blob, layout: &str) {
		let type__ = CString::new(type_).unwrap();
		let layout_ = CString::new(layout).unwrap();
		unsafe { tsMeshMaterial_addParameter_sBs(self.this, type__.as_ptr(), blob.this, layout_.as_ptr()) }
	}
	pub fn parameter_flags(&self, index: u32) -> MeshMaterialFlags { unsafe { tsMeshMaterial_getParameterFlags_cu(self.this, index) } }
	pub fn has_parameter_flag(&self, index: u32, flags: MeshMaterialFlags) -> bool { unsafe { tsMeshMaterial_hasParameterFlag_cuMMF(self.this, index, flags) != 0 } }
	pub fn has_parameter_flags(&self, index: u32, flags: MeshMaterialFlags) -> bool { unsafe { tsMeshMaterial_hasParameterFlags_cuMMF(self.this, index, flags) != 0 } }
	pub fn parameter_bool(&self, index: u32) -> bool { unsafe { tsMeshMaterial_getParameterBool_cub(self.this, index, 0) != 0 } }
	pub fn parameter_bool_with_value(&self, index: u32, value: bool) -> bool { unsafe { tsMeshMaterial_getParameterBool_cub(self.this, index, if value {1} else {0}) != 0 } }
	pub fn parameter_scalarf32(&self, index: u32) -> f32 { unsafe { tsMeshMaterial_getParameterScalarf32_cuf(self.this, index, 0.0) } }
	pub fn parameter_scalarf32_with_value(&self, index: u32, value: f32) -> f32 { unsafe { tsMeshMaterial_getParameterScalarf32_cuf(self.this, index, value) } }
	pub fn parameter_vector4f(&self, index: u32) -> Vector4f { unsafe { tsMeshMaterial_getParameterVector4f_cucV4(self.this, index, &Vector4f::zero()) } }
	pub fn parameter_vector4f_with_vector(&self, index: u32, vector: &Vector4f) -> Vector4f { unsafe { tsMeshMaterial_getParameterVector4f_cucV4(self.this, index, vector) } }
	pub fn parameter_matrix3x2f(&self, index: u32) -> Matrix3x2f { unsafe { tsMeshMaterial_getParameterMatrix3x2f_cucM32(self.this, index, &Matrix3x2f::identity()) } }
	pub fn parameter_matrix3x2f_with_matrix(&self, index: u32, matrix: &Matrix3x2f) -> Matrix3x2f { unsafe { tsMeshMaterial_getParameterMatrix3x2f_cucM32(self.this, index, matrix) } }
	pub fn parameter_color(&self, index: u32) -> Color { unsafe { tsMeshMaterial_getParameterColor_cucC(self.this, index, &Color::white()) } }
	pub fn parameter_color_with_color(&self, index: u32, color: &Color) -> Color { unsafe { tsMeshMaterial_getParameterColor_cucC(self.this, index, color) } }
	pub fn parameter_name(&self, index: u32) -> string::String { unsafe { get_string(tsMeshMaterial_getParameterName_cucS(self.this, index, ptr::null_mut())) } }
	pub fn parameter_name_with_name(&self, index: u32, name: &String) -> string::String { unsafe { get_string(tsMeshMaterial_getParameterName_cucS(self.this, index, name.this)) } }
	pub fn parameter_layout(&self, index: u32) -> string::String { unsafe { get_string(tsMeshMaterial_getParameterLayout_cucS(self.this, index, ptr::null_mut())) } }
	pub fn parameter_layout_with_layout(&self, index: u32, layout: &String) -> string::String { unsafe { get_string(tsMeshMaterial_getParameterLayout_cucS(self.this, index, layout.this)) } }
	pub fn parameter_image(&self, index: u32) -> Image { unsafe { Image::new_ptr(tsMeshMaterial_getParameterImage_cu(self.this, index)) } }
	pub fn parameter_blob(&self, index: u32) -> Blob { unsafe { Blob::new_ptr(tsMeshMaterial_getParameterBlob_cu(self.this, index)) } }
	pub fn parameter_image_mut(&mut self, index: u32) -> Image { unsafe { Image::new_ptr(tsMeshMaterial_getParameterImage_u(self.this, index)) } }
	pub fn parameter_blob_mut(&mut self, index: u32) -> Blob { unsafe { Blob::new_ptr(tsMeshMaterial_getParameterBlob_u(self.this, index)) } }
	pub fn parameter_flags_with_type(&self, type_: &str) -> MeshMaterialFlags {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterFlags_cs(self.this, type__.as_ptr()) }
	}
	pub fn has_parameter_flag_with_type(&self, type_: &str, flags: MeshMaterialFlags) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_hasParameterFlag_csMMF(self.this, type__.as_ptr(), flags) != 0 }
	}
	pub fn has_parameter_flags_with_type(&self, type_: &str, flags: MeshMaterialFlags) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_hasParameterFlags_csMMF(self.this, type__.as_ptr(), flags) != 0 }
	}
	pub fn parameter_bool_with_type(&self, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterBool_csb(self.this, type__.as_ptr(), 0) != 0 }
	}
	pub fn parameter_bool_with_type_value(&self, type_: &str, value: bool) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterBool_csb(self.this, type__.as_ptr(), if value {1} else {0}) != 0 }
	}
	pub fn parameter_scalarf32_with_type(&self, type_: &str) -> f32 {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterScalarf32_csf(self.this, type__.as_ptr(), 0.0) }
	}
	pub fn parameter_scalarf32_with_type_value(&self, type_: &str, value: f32) -> f32 {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterScalarf32_csf(self.this, type__.as_ptr(), value) }
	}
	pub fn parameter_vector4f_with_type(&self, type_: &str) -> Vector4f {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterVector4f_cscV4(self.this, type__.as_ptr(), &Vector4f::zero()) }
	}
	pub fn parameter_vector4f_with_type_vector(&self, type_: &str, vector: &Vector4f) -> Vector4f {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterVector4f_cscV4(self.this, type__.as_ptr(), vector) }
	}
	pub fn parameter_matrix3x2f_with_type(&self, type_: &str) -> Matrix3x2f {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterMatrix3x2f_cscM32(self.this, type__.as_ptr(), &Matrix3x2f::identity()) }
	}
	pub fn parameter_matrix3x2f_with_type_matrix(&self, type_: &str, matrix: &Matrix3x2f) -> Matrix3x2f {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterMatrix3x2f_cscM32(self.this, type__.as_ptr(), matrix) }
	}
	pub fn parameter_color_with_type(&self, type_: &str) -> Color {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterColor_cscC(self.this, type__.as_ptr(), &Color::white()) }
	}
	pub fn parameter_color_with_type_color(&self, type_: &str, color: &Color) -> Color {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshMaterial_getParameterColor_cscC(self.this, type__.as_ptr(), color) }
	}
	pub fn parameter_name_with_type(&self, type_: &str) -> string::String {
		let type__ = CString::new(type_).unwrap();
		unsafe { get_string(tsMeshMaterial_getParameterName_cscS(self.this, type__.as_ptr(), ptr::null_mut())) }
	}
	pub fn parameter_name_with_type_name(&self, type_: &str, name: &String) -> string::String {
		let type__ = CString::new(type_).unwrap();
		unsafe { get_string(tsMeshMaterial_getParameterName_cscS(self.this, type__.as_ptr(), name.this)) }
	}
	pub fn parameter_layout_with_type(&self, type_: &str) -> string::String {
		let type__ = CString::new(type_).unwrap();
		unsafe { get_string(tsMeshMaterial_getParameterLayout_cscS(self.this, type__.as_ptr(), ptr::null_mut())) }
	}
	pub fn parameter_layout_with_type_layout(&self, type_: &str, layout: &String) -> string::String {
		let type__ = CString::new(type_).unwrap();
		unsafe { get_string(tsMeshMaterial_getParameterLayout_cscS(self.this, type__.as_ptr(), layout.this)) }
	}
	pub fn compare(&self, material: &MeshMaterial) -> i32 { unsafe { tsMeshMaterial_compare(self.this, material.this) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshMaterial_getMemory(self.this) } }
}
impl Drop for MeshMaterial {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshMaterial_delete(self.this) } } }
}
impl Clone for MeshMaterial {
	fn clone(&self) -> MeshMaterial { unsafe { MeshMaterial { this: tsMeshMaterial_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshMaterial { }
impl fmt::Display for MeshMaterial {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshMaterial ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshMaterial_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshMaterial_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshMaterial_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshMaterial_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshMaterial_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshMaterial_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshMaterial_new_MGs(geometry: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshMaterial_delete(this: *mut c_void);
	fn tsMeshMaterial_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshMaterial_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_clearPtr(this: *const c_void);
	fn tsMeshMaterial_destroyPtr(this: *const c_void);
	fn tsMeshMaterial_acquirePtr(this: *const c_void);
	fn tsMeshMaterial_unacquirePtr(this: *const c_void);
	fn tsMeshMaterial_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshMaterial_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshMaterial_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshMaterial_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshMaterial_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_clear(this: *mut c_void);
	fn tsMeshMaterial_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshMaterial_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_getIndex(this: *const c_void) -> u32;
	fn tsMeshMaterial_setIndices(this: *mut c_void, indices: *mut c_void);
	fn tsMeshMaterial_getIndices_c(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_getIndices(this: *mut c_void) -> *mut c_void;
	fn tsMeshMaterial_setGeometry(this: *mut c_void, geometry: *mut c_void, check: i32);
	fn tsMeshMaterial_getGeometry_c(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_getGeometry(this: *mut c_void) -> *mut c_void;
	fn tsMeshMaterial_setData_s(this: *mut c_void, data: *const c_char);
	fn tsMeshMaterial_setData_cS(this: *mut c_void, data: *mut c_void);
	fn tsMeshMaterial_getData(this: *const c_void) -> *mut c_void;
	fn tsMeshMaterial_clearParameters(this: *mut c_void);
	fn tsMeshMaterial_removeParameter(this: *mut c_void, type_: *const c_char) -> i32;
	fn tsMeshMaterial_copyParameters(this: *mut c_void, material: *mut c_void);
	fn tsMeshMaterial_findParameter(this: *const c_void, type_: *const c_char) -> u32;
	fn tsMeshMaterial_hasParameter(this: *const c_void, type_: *const c_char) -> i32;
	fn tsMeshMaterial_getNumParameters(this: *const c_void) -> u32;
	fn tsMeshMaterial_getParameterType(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshMaterial_addParameter_sb(this: *mut c_void, type_: *const c_char, value: i32);
	fn tsMeshMaterial_addParameter_sf(this: *mut c_void, type_: *const c_char, value: f32);
	fn tsMeshMaterial_addParameter_scV4(this: *mut c_void, type_: *const c_char, value: *const Vector4f);
	fn tsMeshMaterial_addParameter_scM32(this: *mut c_void, type_: *const c_char, value: *const Matrix3x2f);
	fn tsMeshMaterial_addParameter_scC(this: *mut c_void, type_: *const c_char, color: *const Color);
	fn tsMeshMaterial_addParameter_sss(this: *mut c_void, type_: *const c_char, name: *const c_char, layout: *const c_char);
	fn tsMeshMaterial_addParameter_scSs(this: *mut c_void, type_: *const c_char, name: *mut c_void, layout: *const c_char);
	fn tsMeshMaterial_addParameter_scIs(this: *mut c_void, type_: *const c_char, image: *mut c_void, layout: *const c_char);
	fn tsMeshMaterial_addParameter_sBs(this: *mut c_void, type_: *const c_char, blob: *mut c_void, layout: *const c_char);
	fn tsMeshMaterial_getParameterFlags_cu(this: *const c_void, index: u32) -> MeshMaterialFlags;
	fn tsMeshMaterial_hasParameterFlag_cuMMF(this: *const c_void, index: u32, flags: MeshMaterialFlags) -> i32;
	fn tsMeshMaterial_hasParameterFlags_cuMMF(this: *const c_void, index: u32, flags: MeshMaterialFlags) -> i32;
	fn tsMeshMaterial_getParameterBool_cub(this: *const c_void, index: u32, value: i32) -> i32;
	fn tsMeshMaterial_getParameterScalarf32_cuf(this: *const c_void, index: u32, value: f32) -> f32;
	fn tsMeshMaterial_getParameterVector4f_cucV4(this: *const c_void, index: u32, vector: *const Vector4f) -> Vector4f;
	fn tsMeshMaterial_getParameterMatrix3x2f_cucM32(this: *const c_void, index: u32, matrix: *const Matrix3x2f) -> Matrix3x2f;
	fn tsMeshMaterial_getParameterColor_cucC(this: *const c_void, index: u32, color: *const Color) -> Color;
	fn tsMeshMaterial_getParameterName_cucS(this: *const c_void, index: u32, name: *mut c_void) -> *mut c_void;
	fn tsMeshMaterial_getParameterLayout_cucS(this: *const c_void, index: u32, layout: *mut c_void) -> *mut c_void;
	fn tsMeshMaterial_getParameterImage_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshMaterial_getParameterBlob_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshMaterial_getParameterImage_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshMaterial_getParameterBlob_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshMaterial_getParameterFlags_cs(this: *const c_void, type_: *const c_char) -> MeshMaterialFlags;
	fn tsMeshMaterial_hasParameterFlag_csMMF(this: *const c_void, type_: *const c_char, flags: MeshMaterialFlags) -> i32;
	fn tsMeshMaterial_hasParameterFlags_csMMF(this: *const c_void, type_: *const c_char, flags: MeshMaterialFlags) -> i32;
	fn tsMeshMaterial_getParameterBool_csb(this: *const c_void, type_: *const c_char, value: i32) -> i32;
	fn tsMeshMaterial_getParameterScalarf32_csf(this: *const c_void, type_: *const c_char, value: f32) -> f32;
	fn tsMeshMaterial_getParameterVector4f_cscV4(this: *const c_void, type_: *const c_char, vector: *const Vector4f) -> Vector4f;
	fn tsMeshMaterial_getParameterMatrix3x2f_cscM32(this: *const c_void, type_: *const c_char, matrix: *const Matrix3x2f) -> Matrix3x2f;
	fn tsMeshMaterial_getParameterColor_cscC(this: *const c_void, type_: *const c_char, color: *const Color) -> Color;
	fn tsMeshMaterial_getParameterName_cscS(this: *const c_void, type_: *const c_char, name: *mut c_void) -> *mut c_void;
	fn tsMeshMaterial_getParameterLayout_cscS(this: *const c_void, type_: *const c_char, layout: *mut c_void) -> *mut c_void;
	fn tsMeshMaterial_compare(this: *const c_void, material: *mut c_void) -> i32;
	fn tsMeshMaterial_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshGeometry
pub struct MeshGeometry {
	this: *mut c_void,
	owner: bool,
}
impl MeshGeometry {
	pub fn null() -> MeshGeometry { MeshGeometry { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshGeometry { unsafe { MeshGeometry { this: tsMeshGeometry_new_s(ptr::null_mut()), owner: true } } }
	pub fn new_with_name(name: &str) -> MeshGeometry {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshGeometry { this: tsMeshGeometry_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_mesh(mesh: &mut Mesh) -> MeshGeometry { unsafe { MeshGeometry { this: tsMeshGeometry_new_Ms(mesh.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_mesh_name(mesh: &mut Mesh, name: &str) -> MeshGeometry {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshGeometry { this: tsMeshGeometry_new_Ms(mesh.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshGeometry { unsafe { MeshGeometry { this: ptr, owner: tsMeshGeometry_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshGeometry { unsafe { MeshGeometry { this: tsMeshGeometry_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshGeometry) -> bool { unsafe { tsMeshGeometry_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshGeometry { unsafe { MeshGeometry { this: tsMeshGeometry_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshGeometry_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshGeometry_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshGeometry_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshGeometry_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshGeometry_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshGeometry_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshGeometry_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshGeometry_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshGeometry_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshGeometry_clear(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshGeometry_getName(self.this)) } }
	pub fn index(&self) -> u32 { unsafe { tsMeshGeometry_getIndex(self.this) } }
	pub fn set_mesh(&mut self, mesh: &mut Mesh) { unsafe { tsMeshGeometry_setMesh(self.this, mesh.this, 1) } }
	pub fn set_mesh_with_check(&mut self, mesh: &mut Mesh, check: bool) { unsafe { tsMeshGeometry_setMesh(self.this, mesh.this, if check {1} else {0}) } }
	pub fn mesh(&self) -> Mesh { unsafe { Mesh::new_ptr(tsMeshGeometry_getMesh_c(self.this)) } }
	pub fn mesh_mut(&mut self) -> Mesh { unsafe { Mesh::new_ptr(tsMeshGeometry_getMesh(self.this)) } }
	pub fn set_parent0(&mut self, parent: &mut MeshGeometry) -> u32 { unsafe { tsMeshGeometry_setParent0(self.this, parent.this, 1) } }
	pub fn set_parent0_with_check(&mut self, parent: &mut MeshGeometry, check: bool) -> u32 { unsafe { tsMeshGeometry_setParent0(self.this, parent.this, if check {1} else {0}) } }
	pub fn set_parent1(&mut self, parent: &mut MeshGeometry) -> u32 { unsafe { tsMeshGeometry_setParent1(self.this, parent.this, 1) } }
	pub fn set_parent1_with_check(&mut self, parent: &mut MeshGeometry, check: bool) -> u32 { unsafe { tsMeshGeometry_setParent1(self.this, parent.this, if check {1} else {0}) } }
	pub fn parent0(&self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshGeometry_getParent0_c(self.this)) } }
	pub fn parent1(&self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshGeometry_getParent1_c(self.this)) } }
	pub fn parent0_mut(&mut self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshGeometry_getParent0(self.this)) } }
	pub fn parent1_mut(&mut self) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshGeometry_getParent1(self.this)) } }
	pub fn is_root(&self) -> bool { unsafe { tsMeshGeometry_isRoot(self.this) != 0 } }
	pub fn reserve_children(&mut self, num_children: u32) { unsafe { tsMeshGeometry_reserveChildren(self.this, num_children) } }
	pub fn add_child0(&mut self, child: &mut MeshGeometry) -> u32 { unsafe { tsMeshGeometry_addChild0(self.this, child.this, 1) } }
	pub fn add_child0_with_check(&mut self, child: &mut MeshGeometry, check: bool) -> u32 { unsafe { tsMeshGeometry_addChild0(self.this, child.this, if check {1} else {0}) } }
	pub fn add_child1(&mut self, child: &mut MeshGeometry) -> u32 { unsafe { tsMeshGeometry_addChild1(self.this, child.this, 1) } }
	pub fn add_child1_with_check(&mut self, child: &mut MeshGeometry, check: bool) -> u32 { unsafe { tsMeshGeometry_addChild1(self.this, child.this, if check {1} else {0}) } }
	pub fn remove_child(&mut self, child: &mut MeshGeometry) -> bool { unsafe { tsMeshGeometry_removeChild(self.this, child.this) != 0 } }
	pub fn release_children(&mut self) { unsafe { tsMeshGeometry_releaseChildren(self.this) } }
	pub fn find_child(&self, child: &MeshGeometry) -> u32 { unsafe { tsMeshGeometry_findChild(self.this, child.this) } }
	pub fn num_children(&self) -> u32 { unsafe { tsMeshGeometry_getNumChildren(self.this) } }
	pub fn child(&self, index: u32) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshGeometry_getChild_cu(self.this, index)) } }
	pub fn child_mut(&mut self, index: u32) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMeshGeometry_getChild_u(self.this, index)) } }
	pub fn clear_indices(&mut self) { unsafe { tsMeshGeometry_clearIndices(self.this) } }
	pub fn reserve_indices(&mut self, num_indices: u32) { unsafe { tsMeshGeometry_reserveIndices(self.this, num_indices) } }
	pub fn add_indices(&mut self, indices: &mut MeshIndices) -> u32 { unsafe { tsMeshGeometry_addIndices(self.this, indices.this, 1) } }
	pub fn add_indices_with_check(&mut self, indices: &mut MeshIndices, check: bool) -> u32 { unsafe { tsMeshGeometry_addIndices(self.this, indices.this, if check {1} else {0}) } }
	pub fn remove_indices(&mut self, indices: &mut MeshIndices) -> bool { unsafe { tsMeshGeometry_removeIndices(self.this, indices.this) != 0 } }
	pub fn replace_indices(&mut self, old_indices: &mut MeshIndices, indices: &mut MeshIndices) -> bool { unsafe { tsMeshGeometry_replaceIndices(self.this, old_indices.this, indices.this) != 0 } }
	pub fn find_indices(&self, indices: &MeshIndices) -> u32 { unsafe { tsMeshGeometry_findIndices_ccMI(self.this, indices.this) } }
	pub fn find_indices_with_type(&self, type_: MeshIndicesType) -> u32 { unsafe { tsMeshGeometry_findIndices_cMIT(self.this, type_) } }
	pub fn has_indices(&self, type_: MeshIndicesType) -> bool { unsafe { tsMeshGeometry_hasIndices(self.this, type_) != 0 } }
	pub fn has_solid_indices(&self) -> bool { unsafe { tsMeshGeometry_hasSolidIndices(self.this) != 0 } }
	pub fn num_indices_with_type(&self, type_: MeshIndicesType) -> u32 { unsafe { tsMeshGeometry_getNumIndices_cMIT(self.this, type_) } }
	pub fn indices(&self, type_: MeshIndicesType) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshGeometry_getIndices_cMIT(self.this, type_)) } }
	pub fn indices_mut(&mut self, type_: MeshIndicesType) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshGeometry_getIndices_MIT(self.this, type_)) } }
	pub fn num_indices(&self) -> u32 { unsafe { tsMeshGeometry_getNumIndices_c(self.this) } }
	pub fn indices_with_index(&self, index: u32) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshGeometry_getIndices_cu(self.this, index)) } }
	pub fn indices_mut_with_index(&mut self, index: u32) -> MeshIndices { unsafe { MeshIndices::new_ptr(tsMeshGeometry_getIndices_u(self.this, index)) } }
	pub fn clear_attributes(&mut self) { unsafe { tsMeshGeometry_clearAttributes(self.this) } }
	pub fn reserve_attributes(&mut self, num_attributes: u32) { unsafe { tsMeshGeometry_reserveAttributes(self.this, num_attributes) } }
	pub fn add_attribute(&mut self, attribute: &mut MeshAttribute) -> u32 { unsafe { tsMeshGeometry_addAttribute_MAb(self.this, attribute.this, 1) } }
	pub fn add_attribute_with_check(&mut self, attribute: &mut MeshAttribute, check: bool) -> u32 { unsafe { tsMeshGeometry_addAttribute_MAb(self.this, attribute.this, if check {1} else {0}) } }
	pub fn add_attribute_with_indices(&mut self, attribute: &mut MeshAttribute, indices: &mut MeshIndices) -> u32 { unsafe { tsMeshGeometry_addAttribute_MAMIb(self.this, attribute.this, indices.this, 1) } }
	pub fn add_attribute_with_indices_check(&mut self, attribute: &mut MeshAttribute, indices: &mut MeshIndices, check: bool) -> u32 { unsafe { tsMeshGeometry_addAttribute_MAMIb(self.this, attribute.this, indices.this, if check {1} else {0}) } }
	pub fn remove_attribute(&mut self, attribute: &mut MeshAttribute) -> bool { unsafe { tsMeshGeometry_removeAttribute(self.this, attribute.this) != 0 } }
	pub fn replace_attribute(&mut self, old_attribute: &mut MeshAttribute, attribute: &mut MeshAttribute) -> bool { unsafe { tsMeshGeometry_replaceAttribute(self.this, old_attribute.this, attribute.this) != 0 } }
	pub fn replace_attribute_indices(&mut self, old_indices: &MeshIndices, indices: &mut MeshIndices) -> bool { unsafe { tsMeshGeometry_replaceAttributeIndices(self.this, old_indices.this, indices.this) != 0 } }
	pub fn find_attribute_with_type_format(&self, type_: MeshAttributeType, format: Format) -> u32 { unsafe { tsMeshGeometry_findAttribute_cMATFu(self.this, type_, format, 0) } }
	pub fn find_attribute_with_type_format_index(&self, type_: MeshAttributeType, format: Format, index: u32) -> u32 { unsafe { tsMeshGeometry_findAttribute_cMATFu(self.this, type_, format, index) } }
	pub fn find_attribute_with_type(&self, type_: MeshAttributeType) -> u32 { unsafe { tsMeshGeometry_findAttribute_cMATu(self.this, type_, 0) } }
	pub fn find_attribute_with_type_index(&self, type_: MeshAttributeType, index: u32) -> u32 { unsafe { tsMeshGeometry_findAttribute_cMATu(self.this, type_, index) } }
	pub fn find_attribute_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_findAttribute_csu(self.this, name_.as_ptr(), 0) }
	}
	pub fn find_attribute_with_name_index(&self, name: &str, index: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_findAttribute_csu(self.this, name_.as_ptr(), index) }
	}
	pub fn find_attribute_with_attribute(&self, attribute: &MeshAttribute) -> u32 { unsafe { tsMeshGeometry_findAttribute_ccMA(self.this, attribute.this) } }
	pub fn has_attribute_with_type_format(&self, type_: MeshAttributeType, format: Format) -> bool { unsafe { tsMeshGeometry_hasAttribute_cMATFu(self.this, type_, format, 0) != 0 } }
	pub fn has_attribute_with_type_format_index(&self, type_: MeshAttributeType, format: Format, index: u32) -> bool { unsafe { tsMeshGeometry_hasAttribute_cMATFu(self.this, type_, format, index) != 0 } }
	pub fn has_attribute_with_type(&self, type_: MeshAttributeType) -> bool { unsafe { tsMeshGeometry_hasAttribute_cMATu(self.this, type_, 0) != 0 } }
	pub fn has_attribute_with_type_index(&self, type_: MeshAttributeType, index: u32) -> bool { unsafe { tsMeshGeometry_hasAttribute_cMATu(self.this, type_, index) != 0 } }
	pub fn has_attribute_with_name(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_hasAttribute_csu(self.this, name_.as_ptr(), 0) != 0 }
	}
	pub fn has_attribute_with_name_index(&self, name: &str, index: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_hasAttribute_csu(self.this, name_.as_ptr(), index) != 0 }
	}
	pub fn has_attribute_with_attribute(&self, attribute: &MeshAttribute) -> bool { unsafe { tsMeshGeometry_hasAttribute_ccMA(self.this, attribute.this) != 0 } }
	pub fn num_attributes_with_type(&self, type_: MeshAttributeType) -> u32 { unsafe { tsMeshGeometry_getNumAttributes_cMAT(self.this, type_) } }
	pub fn num_attributes_with_indices(&self, indices: &MeshIndices) -> u32 { unsafe { tsMeshGeometry_getNumAttributes_ccMI(self.this, indices.this) } }
	pub fn attribute_with_type(&self, type_: MeshAttributeType) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshGeometry_getAttribute_cMATu(self.this, type_, 0)) } }
	pub fn attribute_with_type_index(&self, type_: MeshAttributeType, index: u32) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshGeometry_getAttribute_cMATu(self.this, type_, index)) } }
	pub fn attribute_mut_with_type(&mut self, type_: MeshAttributeType) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshGeometry_getAttribute_MATu(self.this, type_, 0)) } }
	pub fn attribute_mut_with_type_index(&mut self, type_: MeshAttributeType, index: u32) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshGeometry_getAttribute_MATu(self.this, type_, index)) } }
	pub fn num_attributes(&self) -> u32 { unsafe { tsMeshGeometry_getNumAttributes_c(self.this) } }
	pub fn attribute(&self, index: u32) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshGeometry_getAttribute_cu(self.this, index)) } }
	pub fn attribute_mut(&mut self, index: u32) -> MeshAttribute { unsafe { MeshAttribute::new_ptr(tsMeshGeometry_getAttribute_u(self.this, index)) } }
	pub fn clear_joints(&mut self) { unsafe { tsMeshGeometry_clearJoints(self.this) } }
	pub fn reserve_joints(&mut self, num_joints: u32) { unsafe { tsMeshGeometry_reserveJoints(self.this, num_joints) } }
	pub fn add_joint(&mut self, joint: &mut MeshJoint) -> u32 { unsafe { tsMeshGeometry_addJoint_MJb(self.this, joint.this, 1) } }
	pub fn add_joint_with_check(&mut self, joint: &mut MeshJoint, check: bool) -> u32 { unsafe { tsMeshGeometry_addJoint_MJb(self.this, joint.this, if check {1} else {0}) } }
	pub fn add_joint_with_node(&mut self, joint: &mut MeshJoint, node: &mut MeshNode) -> u32 { unsafe { tsMeshGeometry_addJoint_MJMNb(self.this, joint.this, node.this, 1) } }
	pub fn add_joint_with_node_check(&mut self, joint: &mut MeshJoint, node: &mut MeshNode, check: bool) -> u32 { unsafe { tsMeshGeometry_addJoint_MJMNb(self.this, joint.this, node.this, if check {1} else {0}) } }
	pub fn remove_joint(&mut self, joint: &mut MeshJoint) -> bool { unsafe { tsMeshGeometry_removeJoint(self.this, joint.this) != 0 } }
	pub fn replace_joint(&mut self, old_joint: &mut MeshJoint, joint: &mut MeshJoint) -> bool { unsafe { tsMeshGeometry_replaceJoint(self.this, old_joint.this, joint.this) != 0 } }
	pub fn find_joint(&self, joint: &MeshJoint) -> u32 { unsafe { tsMeshGeometry_findJoint_ccMJ(self.this, joint.this) } }
	pub fn find_joint_with_node(&self, node: &MeshNode) -> u32 { unsafe { tsMeshGeometry_findJoint_ccMN(self.this, node.this) } }
	pub fn find_joint_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_findJoint_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_joints(&self) -> u32 { unsafe { tsMeshGeometry_getNumJoints(self.this) } }
	pub fn joint(&self, index: u32) -> MeshJoint { unsafe { MeshJoint::new_ptr(tsMeshGeometry_getJoint_cu(self.this, index)) } }
	pub fn joint_mut(&mut self, index: u32) -> MeshJoint { unsafe { MeshJoint::new_ptr(tsMeshGeometry_getJoint_u(self.this, index)) } }
	pub fn clear_materials(&mut self) { unsafe { tsMeshGeometry_clearMaterials(self.this) } }
	pub fn reserve_materials(&mut self, num_materials: u32) { unsafe { tsMeshGeometry_reserveMaterials(self.this, num_materials) } }
	pub fn add_material(&mut self, material: &mut MeshMaterial) -> u32 { unsafe { tsMeshGeometry_addMaterial_MMb(self.this, material.this, 1) } }
	pub fn add_material_with_check(&mut self, material: &mut MeshMaterial, check: bool) -> u32 { unsafe { tsMeshGeometry_addMaterial_MMb(self.this, material.this, if check {1} else {0}) } }
	pub fn add_material_with_indices(&mut self, material: &mut MeshMaterial, indices: &mut MeshIndices) -> u32 { unsafe { tsMeshGeometry_addMaterial_MMMIb(self.this, material.this, indices.this, 1) } }
	pub fn add_material_with_indices_check(&mut self, material: &mut MeshMaterial, indices: &mut MeshIndices, check: bool) -> u32 { unsafe { tsMeshGeometry_addMaterial_MMMIb(self.this, material.this, indices.this, if check {1} else {0}) } }
	pub fn remove_material(&mut self, material: &mut MeshMaterial) -> bool { unsafe { tsMeshGeometry_removeMaterial(self.this, material.this) != 0 } }
	pub fn replace_material(&mut self, old_material: &mut MeshMaterial, material: &mut MeshMaterial) -> bool { unsafe { tsMeshGeometry_replaceMaterial(self.this, old_material.this, material.this) != 0 } }
	pub fn find_material(&self, material: &MeshMaterial) -> u32 { unsafe { tsMeshGeometry_findMaterial_ccMM(self.this, material.this) } }
	pub fn find_material_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshGeometry_findMaterial_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_materials(&self) -> u32 { unsafe { tsMeshGeometry_getNumMaterials(self.this) } }
	pub fn material(&self, index: u32) -> MeshMaterial { unsafe { MeshMaterial::new_ptr(tsMeshGeometry_getMaterial_cu(self.this, index)) } }
	pub fn material_mut(&mut self, index: u32) -> MeshMaterial { unsafe { MeshMaterial::new_ptr(tsMeshGeometry_getMaterial_u(self.this, index)) } }
	pub fn set_bound_box(&mut self, box_: &BoundBoxf) { unsafe { tsMeshGeometry_setBoundBox(self.this, box_) } }
	pub fn bound_box(&self) -> BoundBoxf { unsafe { tsMeshGeometry_getBoundBox(self.this) } }
	pub fn set_bound_sphere(&mut self, sphere: &BoundSpheref) { unsafe { tsMeshGeometry_setBoundSphere(self.this, sphere) } }
	pub fn bound_sphere(&self) -> BoundSpheref { unsafe { tsMeshGeometry_getBoundSphere(self.this) } }
	pub fn set_transform(&mut self, scale: &Vector3f) -> bool { unsafe { tsMeshGeometry_setTransform_cV3(self.this, scale) != 0 } }
	pub fn set_transform_with_transform(&mut self, transform: &Matrix4x3f) -> bool { unsafe { tsMeshGeometry_setTransform_cM43b(self.this, transform, 0) != 0 } }
	pub fn set_transform_with_transform_apply(&mut self, transform: &Matrix4x3f, apply: bool) -> bool { unsafe { tsMeshGeometry_setTransform_cM43b(self.this, transform, if apply {1} else {0}) != 0 } }
	pub fn transform(&self) -> Matrix4x3f { unsafe { tsMeshGeometry_getTransform(self.this) } }
	pub fn set_joint_itransform(&mut self, itransform: &Matrix4x3f) { unsafe { tsMeshGeometry_setJointITransform(self.this, itransform) } }
	pub fn joint_itransform(&self) -> Matrix4x3f { unsafe { tsMeshGeometry_getJointITransform(self.this) } }
	pub fn set_min_visibility(&mut self, distance: f32) { unsafe { tsMeshGeometry_setMinVisibility(self.this, distance) } }
	pub fn set_max_visibility(&mut self, distance: f32) { unsafe { tsMeshGeometry_setMaxVisibility(self.this, distance) } }
	pub fn set_visibility_range(&mut self, min: f32, max: f32) { unsafe { tsMeshGeometry_setVisibilityRange(self.this, min, max) } }
	pub fn min_visibility(&self) -> f32 { unsafe { tsMeshGeometry_getMinVisibility(self.this) } }
	pub fn max_visibility(&self) -> f32 { unsafe { tsMeshGeometry_getMaxVisibility(self.this) } }
	pub fn has_visibility_range(&self) -> bool { unsafe { tsMeshGeometry_hasVisibilityRange(self.this) != 0 } }
	pub fn set_visibility_error(&mut self, error: f32) { unsafe { tsMeshGeometry_setVisibilityError(self.this, error) } }
	pub fn visibility_error(&self) -> f32 { unsafe { tsMeshGeometry_getVisibilityError(self.this) } }
	pub fn create_bounds(&mut self) -> bool { unsafe { tsMeshGeometry_createBounds(self.this, 0, MAXU32) != 0 } }
	pub fn create_bounds_with_force(&mut self, force: bool) -> bool { unsafe { tsMeshGeometry_createBounds(self.this, if force {1} else {0}, MAXU32) != 0 } }
	pub fn create_bounds_with_force_position(&mut self, force: bool, position: u32) -> bool { unsafe { tsMeshGeometry_createBounds(self.this, if force {1} else {0}, position) != 0 } }
	pub fn create_basis(&mut self) -> u32 { unsafe { tsMeshGeometry_createBasis_buuub(self.this, 0, MAXU32, MAXU32, MAXU32, 0) } }
	pub fn create_basis_with_force(&mut self, force: bool) -> u32 { unsafe { tsMeshGeometry_createBasis_buuub(self.this, if force {1} else {0}, MAXU32, MAXU32, MAXU32, 0) } }
	pub fn create_basis_with_force_position(&mut self, force: bool, position: u32) -> u32 { unsafe { tsMeshGeometry_createBasis_buuub(self.this, if force {1} else {0}, position, MAXU32, MAXU32, 0) } }
	pub fn create_basis_with_force_position_normal(&mut self, force: bool, position: u32, normal: u32) -> u32 { unsafe { tsMeshGeometry_createBasis_buuub(self.this, if force {1} else {0}, position, normal, MAXU32, 0) } }
	pub fn create_basis_with_force_position_normal_tangent(&mut self, force: bool, position: u32, normal: u32, tangent: u32) -> u32 { unsafe { tsMeshGeometry_createBasis_buuub(self.this, if force {1} else {0}, position, normal, tangent, 0) } }
	pub fn create_basis_with_force_position_normal_tangent_append(&mut self, force: bool, position: u32, normal: u32, tangent: u32, append: bool) -> u32 { unsafe { tsMeshGeometry_createBasis_buuub(self.this, if force {1} else {0}, position, normal, tangent, if append {1} else {0}) } }
	pub fn create_basis_with_angle(&mut self, angle: f32) -> u32 { unsafe { tsMeshGeometry_createBasis_fbuuub(self.this, angle, 0, MAXU32, MAXU32, MAXU32, 0) } }
	pub fn create_basis_with_angle_force(&mut self, angle: f32, force: bool) -> u32 { unsafe { tsMeshGeometry_createBasis_fbuuub(self.this, angle, if force {1} else {0}, MAXU32, MAXU32, MAXU32, 0) } }
	pub fn create_basis_with_angle_force_position(&mut self, angle: f32, force: bool, position: u32) -> u32 { unsafe { tsMeshGeometry_createBasis_fbuuub(self.this, angle, if force {1} else {0}, position, MAXU32, MAXU32, 0) } }
	pub fn create_basis_with_angle_force_position_normal(&mut self, angle: f32, force: bool, position: u32, normal: u32) -> u32 { unsafe { tsMeshGeometry_createBasis_fbuuub(self.this, angle, if force {1} else {0}, position, normal, MAXU32, 0) } }
	pub fn create_basis_with_angle_force_position_normal_tangent(&mut self, angle: f32, force: bool, position: u32, normal: u32, tangent: u32) -> u32 { unsafe { tsMeshGeometry_createBasis_fbuuub(self.this, angle, if force {1} else {0}, position, normal, tangent, 0) } }
	pub fn create_basis_with_angle_force_position_normal_tangent_append(&mut self, angle: f32, force: bool, position: u32, normal: u32, tangent: u32, append: bool) -> u32 { unsafe { tsMeshGeometry_createBasis_fbuuub(self.this, angle, if force {1} else {0}, position, normal, tangent, if append {1} else {0}) } }
	pub fn create_normals(&mut self) -> u32 { unsafe { tsMeshGeometry_createNormals_bub(self.this, 0, MAXU32, 0) } }
	pub fn create_normals_with_force(&mut self, force: bool) -> u32 { unsafe { tsMeshGeometry_createNormals_bub(self.this, if force {1} else {0}, MAXU32, 0) } }
	pub fn create_normals_with_force_position(&mut self, force: bool, position: u32) -> u32 { unsafe { tsMeshGeometry_createNormals_bub(self.this, if force {1} else {0}, position, 0) } }
	pub fn create_normals_with_force_position_append(&mut self, force: bool, position: u32, append: bool) -> u32 { unsafe { tsMeshGeometry_createNormals_bub(self.this, if force {1} else {0}, position, if append {1} else {0}) } }
	pub fn create_normals_with_angle(&mut self, angle: f32) -> u32 { unsafe { tsMeshGeometry_createNormals_fbub(self.this, angle, 0, MAXU32, 0) } }
	pub fn create_normals_with_angle_force(&mut self, angle: f32, force: bool) -> u32 { unsafe { tsMeshGeometry_createNormals_fbub(self.this, angle, if force {1} else {0}, MAXU32, 0) } }
	pub fn create_normals_with_angle_force_position(&mut self, angle: f32, force: bool, position: u32) -> u32 { unsafe { tsMeshGeometry_createNormals_fbub(self.this, angle, if force {1} else {0}, position, 0) } }
	pub fn create_normals_with_angle_force_position_append(&mut self, angle: f32, force: bool, position: u32, append: bool) -> u32 { unsafe { tsMeshGeometry_createNormals_fbub(self.this, angle, if force {1} else {0}, position, if append {1} else {0}) } }
	pub fn create_tangents(&mut self) -> u32 { unsafe { tsMeshGeometry_createTangents(self.this, 0, MAXU32, MAXU32, MAXU32, 0) } }
	pub fn create_tangents_with_force(&mut self, force: bool) -> u32 { unsafe { tsMeshGeometry_createTangents(self.this, if force {1} else {0}, MAXU32, MAXU32, MAXU32, 0) } }
	pub fn create_tangents_with_force_position(&mut self, force: bool, position: u32) -> u32 { unsafe { tsMeshGeometry_createTangents(self.this, if force {1} else {0}, position, MAXU32, MAXU32, 0) } }
	pub fn create_tangents_with_force_position_normal(&mut self, force: bool, position: u32, normal: u32) -> u32 { unsafe { tsMeshGeometry_createTangents(self.this, if force {1} else {0}, position, normal, MAXU32, 0) } }
	pub fn create_tangents_with_force_position_normal_texcoord(&mut self, force: bool, position: u32, normal: u32, texcoord: u32) -> u32 { unsafe { tsMeshGeometry_createTangents(self.this, if force {1} else {0}, position, normal, texcoord, 0) } }
	pub fn create_tangents_with_force_position_normal_texcoord_append(&mut self, force: bool, position: u32, normal: u32, texcoord: u32, append: bool) -> u32 { unsafe { tsMeshGeometry_createTangents(self.this, if force {1} else {0}, position, normal, texcoord, if append {1} else {0}) } }
	pub fn create_islands(&mut self, max_attributes: u32, max_primitives: u32) -> u32 { unsafe { tsMeshGeometry_createIslands(self.this, max_attributes, max_primitives, 0, MAXU32, MAXU32, 0) } }
	pub fn create_islands_with_force(&mut self, max_attributes: u32, max_primitives: u32, force: bool) -> u32 { unsafe { tsMeshGeometry_createIslands(self.this, max_attributes, max_primitives, if force {1} else {0}, MAXU32, MAXU32, 0) } }
	pub fn create_islands_with_force_index(&mut self, max_attributes: u32, max_primitives: u32, force: bool, index: u32) -> u32 { unsafe { tsMeshGeometry_createIslands(self.this, max_attributes, max_primitives, if force {1} else {0}, index, MAXU32, 0) } }
	pub fn create_islands_with_force_index_position(&mut self, max_attributes: u32, max_primitives: u32, force: bool, index: u32, position: u32) -> u32 { unsafe { tsMeshGeometry_createIslands(self.this, max_attributes, max_primitives, if force {1} else {0}, index, position, 0) } }
	pub fn create_islands_with_force_index_position_append(&mut self, max_attributes: u32, max_primitives: u32, force: bool, index: u32, position: u32, append: bool) -> u32 { unsafe { tsMeshGeometry_createIslands(self.this, max_attributes, max_primitives, if force {1} else {0}, index, position, if append {1} else {0}) } }
	pub fn optimize_indices(&mut self) -> bool { unsafe { tsMeshGeometry_optimizeIndices(self.this, 32, 0, MAXU32, MAXU32) != 0 } }
	pub fn optimize_indices_with_cache(&mut self, cache: u32) -> bool { unsafe { tsMeshGeometry_optimizeIndices(self.this, cache, 0, MAXU32, MAXU32) != 0 } }
	pub fn optimize_indices_with_cache_transparent(&mut self, cache: u32, transparent: bool) -> bool { unsafe { tsMeshGeometry_optimizeIndices(self.this, cache, if transparent {1} else {0}, MAXU32, MAXU32) != 0 } }
	pub fn optimize_indices_with_cache_transparent_index(&mut self, cache: u32, transparent: bool, index: u32) -> bool { unsafe { tsMeshGeometry_optimizeIndices(self.this, cache, if transparent {1} else {0}, index, MAXU32) != 0 } }
	pub fn optimize_indices_with_cache_transparent_index_position(&mut self, cache: u32, transparent: bool, index: u32, position: u32) -> bool { unsafe { tsMeshGeometry_optimizeIndices(self.this, cache, if transparent {1} else {0}, index, position) != 0 } }
	pub fn optimize_attributes(&mut self) -> bool { unsafe { tsMeshGeometry_optimizeAttributes(self.this, MAXU32) != 0 } }
	pub fn optimize_attributes_with_material(&mut self, material: u32) -> bool { unsafe { tsMeshGeometry_optimizeAttributes(self.this, material) != 0 } }
	pub fn optimize_materials(&mut self) { unsafe { tsMeshGeometry_optimizeMaterials(self.this) } }
	pub fn pack_attributes(&mut self) -> bool { unsafe { tsMeshGeometry_packAttributes(self.this, 1) != 0 } }
	pub fn pack_attributes_with_remove(&mut self, remove: bool) -> bool { unsafe { tsMeshGeometry_packAttributes(self.this, if remove {1} else {0}) != 0 } }
	pub fn unpack_attributes(&mut self) -> bool { unsafe { tsMeshGeometry_unpackAttributes(self.this, 1) != 0 } }
	pub fn unpack_attributes_with_remove(&mut self, remove: bool) -> bool { unsafe { tsMeshGeometry_unpackAttributes(self.this, if remove {1} else {0}) != 0 } }
	pub fn compare(&self, geometry: &MeshGeometry) -> i32 { unsafe { tsMeshGeometry_compare(self.this, geometry.this, &Matrix4x3f::identity(), 1e-6, 1) } }
	pub fn compare_with_transform(&self, geometry: &MeshGeometry, transform: &Matrix4x3f) -> i32 { unsafe { tsMeshGeometry_compare(self.this, geometry.this, transform, 1e-6, 1) } }
	pub fn compare_with_transform_threshold(&self, geometry: &MeshGeometry, transform: &Matrix4x3f, threshold: f32) -> i32 { unsafe { tsMeshGeometry_compare(self.this, geometry.this, transform, threshold, 1) } }
	pub fn compare_with_transform_threshold_spatial(&self, geometry: &MeshGeometry, transform: &Matrix4x3f, threshold: f32, spatial: bool) -> i32 { unsafe { tsMeshGeometry_compare(self.this, geometry.this, transform, threshold, if spatial {1} else {0}) } }
	pub fn is_optimized(&self) -> bool { unsafe { tsMeshGeometry_isOptimized(self.this) != 0 } }
	pub fn validate(&self) -> bool { unsafe { tsMeshGeometry_validate(self.this) != 0 } }
	pub fn memory(&self) -> usize { unsafe { tsMeshGeometry_getMemory(self.this) } }
}
impl Drop for MeshGeometry {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshGeometry_delete(self.this) } } }
}
impl Clone for MeshGeometry {
	fn clone(&self) -> MeshGeometry { unsafe { MeshGeometry { this: tsMeshGeometry_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshGeometry { }
impl fmt::Display for MeshGeometry {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshGeometry ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshGeometry_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshGeometry_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshGeometry_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshGeometry_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshGeometry_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshGeometry_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshGeometry_new_Ms(mesh: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshGeometry_delete(this: *mut c_void);
	fn tsMeshGeometry_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshGeometry_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_clearPtr(this: *const c_void);
	fn tsMeshGeometry_destroyPtr(this: *const c_void);
	fn tsMeshGeometry_acquirePtr(this: *const c_void);
	fn tsMeshGeometry_unacquirePtr(this: *const c_void);
	fn tsMeshGeometry_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshGeometry_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshGeometry_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshGeometry_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshGeometry_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_clear(this: *mut c_void);
	fn tsMeshGeometry_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshGeometry_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_getIndex(this: *const c_void) -> u32;
	fn tsMeshGeometry_setMesh(this: *mut c_void, mesh: *mut c_void, check: i32);
	fn tsMeshGeometry_getMesh_c(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_getMesh(this: *mut c_void) -> *mut c_void;
	fn tsMeshGeometry_setParent0(this: *mut c_void, parent: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_setParent1(this: *mut c_void, parent: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_getParent0_c(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_getParent1_c(this: *const c_void) -> *mut c_void;
	fn tsMeshGeometry_getParent0(this: *mut c_void) -> *mut c_void;
	fn tsMeshGeometry_getParent1(this: *mut c_void) -> *mut c_void;
	fn tsMeshGeometry_isRoot(this: *const c_void) -> i32;
	fn tsMeshGeometry_reserveChildren(this: *mut c_void, num_children: u32);
	fn tsMeshGeometry_addChild0(this: *mut c_void, child: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_addChild1(this: *mut c_void, child: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_removeChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsMeshGeometry_releaseChildren(this: *mut c_void);
	fn tsMeshGeometry_findChild(this: *const c_void, child: *mut c_void) -> u32;
	fn tsMeshGeometry_getNumChildren(this: *const c_void) -> u32;
	fn tsMeshGeometry_getChild_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getChild_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_clearIndices(this: *mut c_void);
	fn tsMeshGeometry_reserveIndices(this: *mut c_void, num_indices: u32);
	fn tsMeshGeometry_addIndices(this: *mut c_void, indices: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_removeIndices(this: *mut c_void, indices: *mut c_void) -> i32;
	fn tsMeshGeometry_replaceIndices(this: *mut c_void, old_indices: *mut c_void, indices: *mut c_void) -> i32;
	fn tsMeshGeometry_findIndices_ccMI(this: *const c_void, indices: *mut c_void) -> u32;
	fn tsMeshGeometry_findIndices_cMIT(this: *const c_void, type_: MeshIndicesType) -> u32;
	fn tsMeshGeometry_hasIndices(this: *const c_void, type_: MeshIndicesType) -> i32;
	fn tsMeshGeometry_hasSolidIndices(this: *const c_void) -> i32;
	fn tsMeshGeometry_getNumIndices_cMIT(this: *const c_void, type_: MeshIndicesType) -> u32;
	fn tsMeshGeometry_getIndices_cMIT(this: *const c_void, type_: MeshIndicesType) -> *mut c_void;
	fn tsMeshGeometry_getIndices_MIT(this: *mut c_void, type_: MeshIndicesType) -> *mut c_void;
	fn tsMeshGeometry_getNumIndices_c(this: *const c_void) -> u32;
	fn tsMeshGeometry_getIndices_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getIndices_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_clearAttributes(this: *mut c_void);
	fn tsMeshGeometry_reserveAttributes(this: *mut c_void, num_attributes: u32);
	fn tsMeshGeometry_addAttribute_MAb(this: *mut c_void, attribute: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_addAttribute_MAMIb(this: *mut c_void, attribute: *mut c_void, indices: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_removeAttribute(this: *mut c_void, attribute: *mut c_void) -> i32;
	fn tsMeshGeometry_replaceAttribute(this: *mut c_void, old_attribute: *mut c_void, attribute: *mut c_void) -> i32;
	fn tsMeshGeometry_replaceAttributeIndices(this: *mut c_void, old_indices: *mut c_void, indices: *mut c_void) -> i32;
	fn tsMeshGeometry_findAttribute_cMATFu(this: *const c_void, type_: MeshAttributeType, format: Format, index: u32) -> u32;
	fn tsMeshGeometry_findAttribute_cMATu(this: *const c_void, type_: MeshAttributeType, index: u32) -> u32;
	fn tsMeshGeometry_findAttribute_csu(this: *const c_void, name: *const c_char, index: u32) -> u32;
	fn tsMeshGeometry_findAttribute_ccMA(this: *const c_void, attribute: *mut c_void) -> u32;
	fn tsMeshGeometry_hasAttribute_cMATFu(this: *const c_void, type_: MeshAttributeType, format: Format, index: u32) -> i32;
	fn tsMeshGeometry_hasAttribute_cMATu(this: *const c_void, type_: MeshAttributeType, index: u32) -> i32;
	fn tsMeshGeometry_hasAttribute_csu(this: *const c_void, name: *const c_char, index: u32) -> i32;
	fn tsMeshGeometry_hasAttribute_ccMA(this: *const c_void, attribute: *mut c_void) -> i32;
	fn tsMeshGeometry_getNumAttributes_cMAT(this: *const c_void, type_: MeshAttributeType) -> u32;
	fn tsMeshGeometry_getNumAttributes_ccMI(this: *const c_void, indices: *mut c_void) -> u32;
	fn tsMeshGeometry_getAttribute_cMATu(this: *const c_void, type_: MeshAttributeType, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getAttribute_MATu(this: *mut c_void, type_: MeshAttributeType, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getNumAttributes_c(this: *const c_void) -> u32;
	fn tsMeshGeometry_getAttribute_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getAttribute_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_clearJoints(this: *mut c_void);
	fn tsMeshGeometry_reserveJoints(this: *mut c_void, num_joints: u32);
	fn tsMeshGeometry_addJoint_MJb(this: *mut c_void, joint: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_addJoint_MJMNb(this: *mut c_void, joint: *mut c_void, node: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_removeJoint(this: *mut c_void, joint: *mut c_void) -> i32;
	fn tsMeshGeometry_replaceJoint(this: *mut c_void, old_joint: *mut c_void, joint: *mut c_void) -> i32;
	fn tsMeshGeometry_findJoint_ccMJ(this: *const c_void, joint: *mut c_void) -> u32;
	fn tsMeshGeometry_findJoint_ccMN(this: *const c_void, node: *mut c_void) -> u32;
	fn tsMeshGeometry_findJoint_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMeshGeometry_getNumJoints(this: *const c_void) -> u32;
	fn tsMeshGeometry_getJoint_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getJoint_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_clearMaterials(this: *mut c_void);
	fn tsMeshGeometry_reserveMaterials(this: *mut c_void, num_materials: u32);
	fn tsMeshGeometry_addMaterial_MMb(this: *mut c_void, material: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_addMaterial_MMMIb(this: *mut c_void, material: *mut c_void, indices: *mut c_void, check: i32) -> u32;
	fn tsMeshGeometry_removeMaterial(this: *mut c_void, material: *mut c_void) -> i32;
	fn tsMeshGeometry_replaceMaterial(this: *mut c_void, old_material: *mut c_void, material: *mut c_void) -> i32;
	fn tsMeshGeometry_findMaterial_ccMM(this: *const c_void, material: *mut c_void) -> u32;
	fn tsMeshGeometry_findMaterial_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMeshGeometry_getNumMaterials(this: *const c_void) -> u32;
	fn tsMeshGeometry_getMaterial_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_getMaterial_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMeshGeometry_setBoundBox(this: *mut c_void, box_: *const BoundBoxf);
	fn tsMeshGeometry_getBoundBox(this: *const c_void) -> BoundBoxf;
	fn tsMeshGeometry_setBoundSphere(this: *mut c_void, sphere: *const BoundSpheref);
	fn tsMeshGeometry_getBoundSphere(this: *const c_void) -> BoundSpheref;
	fn tsMeshGeometry_setTransform_cV3(this: *mut c_void, scale: *const Vector3f) -> i32;
	fn tsMeshGeometry_setTransform_cM43b(this: *mut c_void, transform: *const Matrix4x3f, apply: i32) -> i32;
	fn tsMeshGeometry_getTransform(this: *const c_void) -> Matrix4x3f;
	fn tsMeshGeometry_setJointITransform(this: *mut c_void, itransform: *const Matrix4x3f);
	fn tsMeshGeometry_getJointITransform(this: *const c_void) -> Matrix4x3f;
	fn tsMeshGeometry_setMinVisibility(this: *mut c_void, distance: f32);
	fn tsMeshGeometry_setMaxVisibility(this: *mut c_void, distance: f32);
	fn tsMeshGeometry_setVisibilityRange(this: *mut c_void, min: f32, max: f32);
	fn tsMeshGeometry_getMinVisibility(this: *const c_void) -> f32;
	fn tsMeshGeometry_getMaxVisibility(this: *const c_void) -> f32;
	fn tsMeshGeometry_hasVisibilityRange(this: *const c_void) -> i32;
	fn tsMeshGeometry_setVisibilityError(this: *mut c_void, error: f32);
	fn tsMeshGeometry_getVisibilityError(this: *const c_void) -> f32;
	fn tsMeshGeometry_createBounds(this: *mut c_void, force: i32, position: u32) -> i32;
	fn tsMeshGeometry_createBasis_buuub(this: *mut c_void, force: i32, position: u32, normal: u32, tangent: u32, append: i32) -> u32;
	fn tsMeshGeometry_createBasis_fbuuub(this: *mut c_void, angle: f32, force: i32, position: u32, normal: u32, tangent: u32, append: i32) -> u32;
	fn tsMeshGeometry_createNormals_bub(this: *mut c_void, force: i32, position: u32, append: i32) -> u32;
	fn tsMeshGeometry_createNormals_fbub(this: *mut c_void, angle: f32, force: i32, position: u32, append: i32) -> u32;
	fn tsMeshGeometry_createTangents(this: *mut c_void, force: i32, position: u32, normal: u32, texcoord: u32, append: i32) -> u32;
	fn tsMeshGeometry_createIslands(this: *mut c_void, max_attributes: u32, max_primitives: u32, force: i32, index: u32, position: u32, append: i32) -> u32;
	fn tsMeshGeometry_optimizeIndices(this: *mut c_void, cache: u32, transparent: i32, index: u32, position: u32) -> i32;
	fn tsMeshGeometry_optimizeAttributes(this: *mut c_void, material: u32) -> i32;
	fn tsMeshGeometry_optimizeMaterials(this: *mut c_void);
	fn tsMeshGeometry_packAttributes(this: *mut c_void, remove: i32) -> i32;
	fn tsMeshGeometry_unpackAttributes(this: *mut c_void, remove: i32) -> i32;
	fn tsMeshGeometry_compare(this: *const c_void, geometry: *mut c_void, transform: *const Matrix4x3f, threshold: f32, spatial: i32) -> i32;
	fn tsMeshGeometry_isOptimized(this: *const c_void) -> i32;
	fn tsMeshGeometry_validate(this: *const c_void) -> i32;
	fn tsMeshGeometry_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshTransform
pub struct MeshTransform {
	this: *mut c_void,
	owner: bool,
}
impl MeshTransform {
	pub fn null() -> MeshTransform { MeshTransform { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshTransform { unsafe { MeshTransform { this: tsMeshTransform_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MeshTransform { unsafe { MeshTransform { this: ptr, owner: tsMeshTransform_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshTransform { unsafe { MeshTransform { this: tsMeshTransform_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshTransform) -> bool { unsafe { tsMeshTransform_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshTransform { unsafe { MeshTransform { this: tsMeshTransform_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshTransform_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshTransform_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshTransform_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshTransform_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshTransform_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshTransform_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshTransform_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshTransform_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshTransform_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshTransform_clear(self.this) } }
	pub fn min_time(&self) -> f64 { unsafe { tsMeshTransform_getMinTime(self.this) } }
	pub fn max_time(&self) -> f64 { unsafe { tsMeshTransform_getMaxTime(self.this) } }
	pub fn set_transform_with_time(&mut self, time: f64, transform: &Matrix4x3d) { unsafe { tsMeshTransform_setTransform_f64cM43f(self.this, time, transform, 1e-6) } }
	pub fn set_transform_with_time_threshold(&mut self, time: f64, transform: &Matrix4x3d, threshold: f32) { unsafe { tsMeshTransform_setTransform_f64cM43f(self.this, time, transform, threshold) } }
	pub fn set_translate(&mut self, time: f64, translate: &Vector3d) { unsafe { tsMeshTransform_setTranslate(self.this, time, translate, 1e-6) } }
	pub fn set_translate_with_threshold(&mut self, time: f64, translate: &Vector3d, threshold: f32) { unsafe { tsMeshTransform_setTranslate(self.this, time, translate, threshold) } }
	pub fn set_rotate(&mut self, time: f64, rotate: &Quaternionf) { unsafe { tsMeshTransform_setRotate(self.this, time, rotate, 1e-6) } }
	pub fn set_rotate_with_threshold(&mut self, time: f64, rotate: &Quaternionf, threshold: f32) { unsafe { tsMeshTransform_setRotate(self.this, time, rotate, threshold) } }
	pub fn set_scale(&mut self, time: f64, scale: &Vector3f) { unsafe { tsMeshTransform_setScale(self.this, time, scale, 1e-6) } }
	pub fn set_scale_with_threshold(&mut self, time: f64, scale: &Vector3f, threshold: f32) { unsafe { tsMeshTransform_setScale(self.this, time, scale, threshold) } }
	pub fn set_morph(&mut self, time: f64, morph: &Vector4f) { unsafe { tsMeshTransform_setMorph(self.this, time, morph, 1e-6) } }
	pub fn set_morph_with_threshold(&mut self, time: f64, morph: &Vector4f, threshold: f32) { unsafe { tsMeshTransform_setMorph(self.this, time, morph, threshold) } }
	pub fn transform(&self, time: f64) -> Matrix4x3d { unsafe { tsMeshTransform_getTransform(self.this, time) } }
	pub fn translate(&self, time: f64) -> Vector3d { unsafe { tsMeshTransform_getTranslate(self.this, time) } }
	pub fn rotate(&self, time: f64) -> Quaternionf { unsafe { tsMeshTransform_getRotate(self.this, time) } }
	pub fn scale(&self, time: f64) -> Vector3f { unsafe { tsMeshTransform_getScale(self.this, time) } }
	pub fn morph(&self, time: f64) -> Vector4f { unsafe { tsMeshTransform_getMorph(self.this, time) } }
	pub fn has_transform_keys(&self) -> bool { unsafe { tsMeshTransform_hasTransformKeys(self.this) != 0 } }
	pub fn has_translate_keys(&self) -> bool { unsafe { tsMeshTransform_hasTranslateKeys(self.this) != 0 } }
	pub fn has_rotate_keys(&self) -> bool { unsafe { tsMeshTransform_hasRotateKeys(self.this) != 0 } }
	pub fn has_scale_keys(&self) -> bool { unsafe { tsMeshTransform_hasScaleKeys(self.this) != 0 } }
	pub fn has_morph_keys(&self) -> bool { unsafe { tsMeshTransform_hasMorphKeys(self.this) != 0 } }
	pub fn set_transform(&mut self, scale: &Vector3d) { unsafe { tsMeshTransform_setTransform_cV3(self.this, scale) } }
	pub fn set_transform_with_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMeshTransform_setTransform_cM43(self.this, transform) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshTransform_getMemory(self.this) } }
}
impl Drop for MeshTransform {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshTransform_delete(self.this) } } }
}
impl Clone for MeshTransform {
	fn clone(&self) -> MeshTransform { unsafe { MeshTransform { this: tsMeshTransform_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshTransform { }
impl fmt::Display for MeshTransform {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshTransform ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshTransform_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshTransform_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshTransform_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshTransform_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshTransform_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshTransform_new() -> *mut c_void;
	fn tsMeshTransform_delete(this: *mut c_void);
	fn tsMeshTransform_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshTransform_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshTransform_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshTransform_clearPtr(this: *const c_void);
	fn tsMeshTransform_destroyPtr(this: *const c_void);
	fn tsMeshTransform_acquirePtr(this: *const c_void);
	fn tsMeshTransform_unacquirePtr(this: *const c_void);
	fn tsMeshTransform_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshTransform_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshTransform_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshTransform_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshTransform_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshTransform_clear(this: *mut c_void);
	fn tsMeshTransform_getMinTime(this: *const c_void) -> f64;
	fn tsMeshTransform_getMaxTime(this: *const c_void) -> f64;
	fn tsMeshTransform_setTransform_f64cM43f(this: *mut c_void, time: f64, transform: *const Matrix4x3d, threshold: f32);
	fn tsMeshTransform_setTranslate(this: *mut c_void, time: f64, translate: *const Vector3d, threshold: f32);
	fn tsMeshTransform_setRotate(this: *mut c_void, time: f64, rotate: *const Quaternionf, threshold: f32);
	fn tsMeshTransform_setScale(this: *mut c_void, time: f64, scale: *const Vector3f, threshold: f32);
	fn tsMeshTransform_setMorph(this: *mut c_void, time: f64, morph: *const Vector4f, threshold: f32);
	fn tsMeshTransform_getTransform(this: *const c_void, time: f64) -> Matrix4x3d;
	fn tsMeshTransform_getTranslate(this: *const c_void, time: f64) -> Vector3d;
	fn tsMeshTransform_getRotate(this: *const c_void, time: f64) -> Quaternionf;
	fn tsMeshTransform_getScale(this: *const c_void, time: f64) -> Vector3f;
	fn tsMeshTransform_getMorph(this: *const c_void, time: f64) -> Vector4f;
	fn tsMeshTransform_hasTransformKeys(this: *const c_void) -> i32;
	fn tsMeshTransform_hasTranslateKeys(this: *const c_void) -> i32;
	fn tsMeshTransform_hasRotateKeys(this: *const c_void) -> i32;
	fn tsMeshTransform_hasScaleKeys(this: *const c_void) -> i32;
	fn tsMeshTransform_hasMorphKeys(this: *const c_void) -> i32;
	fn tsMeshTransform_setTransform_cV3(this: *mut c_void, scale: *const Vector3d);
	fn tsMeshTransform_setTransform_cM43(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMeshTransform_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshAnimation
pub struct MeshAnimation {
	this: *mut c_void,
	owner: bool,
}
impl MeshAnimation {
	pub fn null() -> MeshAnimation { MeshAnimation { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshAnimation { unsafe { MeshAnimation { this: tsMeshAnimation_new_s(ptr::null_mut()), owner: true } } }
	pub fn new_with_name(name: &str) -> MeshAnimation {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAnimation { this: tsMeshAnimation_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_mesh(mesh: &mut Mesh) -> MeshAnimation { unsafe { MeshAnimation { this: tsMeshAnimation_new_Ms(mesh.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_mesh_name(mesh: &mut Mesh, name: &str) -> MeshAnimation {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAnimation { this: tsMeshAnimation_new_Ms(mesh.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshAnimation { unsafe { MeshAnimation { this: ptr, owner: tsMeshAnimation_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshAnimation { unsafe { MeshAnimation { this: tsMeshAnimation_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshAnimation) -> bool { unsafe { tsMeshAnimation_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshAnimation { unsafe { MeshAnimation { this: tsMeshAnimation_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshAnimation_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshAnimation_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshAnimation_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshAnimation_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshAnimation_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshAnimation_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshAnimation_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshAnimation_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshAnimation_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshAnimation_clear(self.this) } }
	pub fn index(&self) -> u32 { unsafe { tsMeshAnimation_getIndex(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshAnimation_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshAnimation_getName(self.this)) } }
	pub fn set_mesh(&mut self, mesh: &mut Mesh) { unsafe { tsMeshAnimation_setMesh(self.this, mesh.this, 1) } }
	pub fn set_mesh_with_check(&mut self, mesh: &mut Mesh, check: bool) { unsafe { tsMeshAnimation_setMesh(self.this, mesh.this, if check {1} else {0}) } }
	pub fn mesh(&self) -> Mesh { unsafe { Mesh::new_ptr(tsMeshAnimation_getMesh_c(self.this)) } }
	pub fn mesh_mut(&mut self) -> Mesh { unsafe { Mesh::new_ptr(tsMeshAnimation_getMesh(self.this)) } }
	pub fn min_time(&self) -> f64 { unsafe { tsMeshAnimation_getMinTime(self.this) } }
	pub fn max_time(&self) -> f64 { unsafe { tsMeshAnimation_getMaxTime(self.this) } }
	pub fn set_num_transforms(&mut self, num_transforms: u32) { unsafe { tsMeshAnimation_setNumTransforms(self.this, num_transforms) } }
	pub fn num_transforms(&self) -> u32 { unsafe { tsMeshAnimation_getNumTransforms(self.this) } }
	pub fn transform(&self, node: u32) -> MeshTransform { unsafe { MeshTransform::new_ptr(tsMeshAnimation_getTransform_cu(self.this, node)) } }
	pub fn transform_mut(&mut self, node: u32) -> MeshTransform { unsafe { MeshTransform::new_ptr(tsMeshAnimation_getTransform_u(self.this, node)) } }
	pub fn set_transform_with_time(&mut self, time: f64, node: u32, transform: &Matrix4x3d) { unsafe { tsMeshAnimation_setTransform_f64ucM43f(self.this, time, node, transform, 1e-6) } }
	pub fn set_transform_with_time_threshold(&mut self, time: f64, node: u32, transform: &Matrix4x3d, threshold: f32) { unsafe { tsMeshAnimation_setTransform_f64ucM43f(self.this, time, node, transform, threshold) } }
	pub fn set_translate(&mut self, time: f64, node: u32, translate: &Vector3d) { unsafe { tsMeshAnimation_setTranslate(self.this, time, node, translate, 1e-6) } }
	pub fn set_translate_with_threshold(&mut self, time: f64, node: u32, translate: &Vector3d, threshold: f32) { unsafe { tsMeshAnimation_setTranslate(self.this, time, node, translate, threshold) } }
	pub fn set_rotate(&mut self, time: f64, node: u32, rotate: &Quaternionf) { unsafe { tsMeshAnimation_setRotate(self.this, time, node, rotate, 1e-6) } }
	pub fn set_rotate_with_threshold(&mut self, time: f64, node: u32, rotate: &Quaternionf, threshold: f32) { unsafe { tsMeshAnimation_setRotate(self.this, time, node, rotate, threshold) } }
	pub fn set_scale(&mut self, time: f64, node: u32, scale: &Vector3f) { unsafe { tsMeshAnimation_setScale(self.this, time, node, scale, 1e-6) } }
	pub fn set_scale_with_threshold(&mut self, time: f64, node: u32, scale: &Vector3f, threshold: f32) { unsafe { tsMeshAnimation_setScale(self.this, time, node, scale, threshold) } }
	pub fn set_morph(&mut self, time: f64, node: u32, morph: &Vector4f) { unsafe { tsMeshAnimation_setMorph(self.this, time, node, morph, 1e-6) } }
	pub fn set_morph_with_threshold(&mut self, time: f64, node: u32, morph: &Vector4f, threshold: f32) { unsafe { tsMeshAnimation_setMorph(self.this, time, node, morph, threshold) } }
	pub fn set_time_with_transform(&mut self, time: f64, transform: &Matrix4x3d) { unsafe { tsMeshAnimation_setTime_f64cM43bf64f64(self.this, time, transform, 1, -MAXF32 as f64, MAXF32 as f64) } }
	pub fn set_time_with_transform_loop(&mut self, time: f64, transform: &Matrix4x3d, loop_: bool) { unsafe { tsMeshAnimation_setTime_f64cM43bf64f64(self.this, time, transform, if loop_ {1} else {0}, -MAXF32 as f64, MAXF32 as f64) } }
	pub fn set_time_with_transform_loop_from(&mut self, time: f64, transform: &Matrix4x3d, loop_: bool, from: f64) { unsafe { tsMeshAnimation_setTime_f64cM43bf64f64(self.this, time, transform, if loop_ {1} else {0}, from, MAXF32 as f64) } }
	pub fn set_time_with_transform_loop_from_to(&mut self, time: f64, transform: &Matrix4x3d, loop_: bool, from: f64, to: f64) { unsafe { tsMeshAnimation_setTime_f64cM43bf64f64(self.this, time, transform, if loop_ {1} else {0}, from, to) } }
	pub fn set_time(&mut self, time: f64, loop_: bool) { unsafe { tsMeshAnimation_setTime_f64bf64f64(self.this, time, if loop_ {1} else {0}, -MAXF32 as f64, MAXF32 as f64) } }
	pub fn set_time_with_from(&mut self, time: f64, loop_: bool, from: f64) { unsafe { tsMeshAnimation_setTime_f64bf64f64(self.this, time, if loop_ {1} else {0}, from, MAXF32 as f64) } }
	pub fn set_time_with_from_to(&mut self, time: f64, loop_: bool, from: f64, to: f64) { unsafe { tsMeshAnimation_setTime_f64bf64f64(self.this, time, if loop_ {1} else {0}, from, to) } }
	pub fn local_transform(&self, node: u32) -> Matrix4x3d { unsafe { tsMeshAnimation_getLocalTransform_cu(self.this, node) } }
	pub fn local_transform_with_node(&self, node: &MeshNode) -> Matrix4x3d { unsafe { tsMeshAnimation_getLocalTransform_ccMN(self.this, node.this) } }
	pub fn local_transform_with_joint(&self, joint: &MeshJoint) -> Matrix4x3d { unsafe { tsMeshAnimation_getLocalTransform_ccMJ(self.this, joint.this) } }
	pub fn global_transform(&self, node: u32) -> Matrix4x3d { unsafe { tsMeshAnimation_getGlobalTransform_cu(self.this, node) } }
	pub fn global_transform_with_node(&self, node: &MeshNode) -> Matrix4x3d { unsafe { tsMeshAnimation_getGlobalTransform_ccMN(self.this, node.this) } }
	pub fn global_transform_with_joint(&self, joint: &MeshJoint) -> Matrix4x3d { unsafe { tsMeshAnimation_getGlobalTransform_ccMJ(self.this, joint.this) } }
	pub fn morph_transform(&self, node: u32) -> Vector4f { unsafe { tsMeshAnimation_getMorphTransform_cu(self.this, node) } }
	pub fn morph_transform_with_node(&self, node: &MeshNode) -> Vector4f { unsafe { tsMeshAnimation_getMorphTransform_ccMN(self.this, node.this) } }
	pub fn bound_box(&self) -> BoundBoxd { unsafe { tsMeshAnimation_getBoundBox_c(self.this) } }
	pub fn bound_box_with_node(&self, node: &MeshNode) -> BoundBoxd { unsafe { tsMeshAnimation_getBoundBox_ccMN(self.this, node.this) } }
	pub fn bound_box_with_geometry(&self, geometry: &MeshGeometry) -> BoundBoxd { unsafe { tsMeshAnimation_getBoundBox_ccMG(self.this, geometry.this) } }
	pub fn bound_box_with_geometry_morph(&self, geometry: &MeshGeometry, morph: &Vector4f) -> BoundBoxd { unsafe { tsMeshAnimation_getBoundBox_ccMGcV4(self.this, geometry.this, morph) } }
	pub fn set_transform(&mut self, scale: &Vector3d) { unsafe { tsMeshAnimation_setTransform_cV3(self.this, scale) } }
	pub fn set_transform_with_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMeshAnimation_setTransform_cM43(self.this, transform) } }
	pub fn optimize_transforms(&mut self) { unsafe { tsMeshAnimation_optimizeTransforms(self.this, 1e-6) } }
	pub fn optimize_transforms_with_threshold(&mut self, threshold: f32) { unsafe { tsMeshAnimation_optimizeTransforms(self.this, threshold) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshAnimation_getMemory(self.this) } }
}
impl Drop for MeshAnimation {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshAnimation_delete(self.this) } } }
}
impl Clone for MeshAnimation {
	fn clone(&self) -> MeshAnimation { unsafe { MeshAnimation { this: tsMeshAnimation_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshAnimation { }
impl fmt::Display for MeshAnimation {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshAnimation ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshAnimation_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshAnimation_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshAnimation_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshAnimation_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshAnimation_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshAnimation_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshAnimation_new_Ms(mesh: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshAnimation_delete(this: *mut c_void);
	fn tsMeshAnimation_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshAnimation_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAnimation_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAnimation_clearPtr(this: *const c_void);
	fn tsMeshAnimation_destroyPtr(this: *const c_void);
	fn tsMeshAnimation_acquirePtr(this: *const c_void);
	fn tsMeshAnimation_unacquirePtr(this: *const c_void);
	fn tsMeshAnimation_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshAnimation_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshAnimation_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshAnimation_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshAnimation_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAnimation_clear(this: *mut c_void);
	fn tsMeshAnimation_getIndex(this: *const c_void) -> u32;
	fn tsMeshAnimation_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshAnimation_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshAnimation_setMesh(this: *mut c_void, mesh: *mut c_void, check: i32);
	fn tsMeshAnimation_getMesh_c(this: *const c_void) -> *mut c_void;
	fn tsMeshAnimation_getMesh(this: *mut c_void) -> *mut c_void;
	fn tsMeshAnimation_getMinTime(this: *const c_void) -> f64;
	fn tsMeshAnimation_getMaxTime(this: *const c_void) -> f64;
	fn tsMeshAnimation_setNumTransforms(this: *mut c_void, num_transforms: u32);
	fn tsMeshAnimation_getNumTransforms(this: *const c_void) -> u32;
	fn tsMeshAnimation_getTransform_cu(this: *const c_void, node: u32) -> *mut c_void;
	fn tsMeshAnimation_getTransform_u(this: *mut c_void, node: u32) -> *mut c_void;
	fn tsMeshAnimation_setTransform_f64ucM43f(this: *mut c_void, time: f64, node: u32, transform: *const Matrix4x3d, threshold: f32);
	fn tsMeshAnimation_setTranslate(this: *mut c_void, time: f64, node: u32, translate: *const Vector3d, threshold: f32);
	fn tsMeshAnimation_setRotate(this: *mut c_void, time: f64, node: u32, rotate: *const Quaternionf, threshold: f32);
	fn tsMeshAnimation_setScale(this: *mut c_void, time: f64, node: u32, scale: *const Vector3f, threshold: f32);
	fn tsMeshAnimation_setMorph(this: *mut c_void, time: f64, node: u32, morph: *const Vector4f, threshold: f32);
	fn tsMeshAnimation_setTime_f64cM43bf64f64(this: *mut c_void, time: f64, transform: *const Matrix4x3d, loop_: i32, from: f64, to: f64);
	fn tsMeshAnimation_setTime_f64bf64f64(this: *mut c_void, time: f64, loop_: i32, from: f64, to: f64);
	fn tsMeshAnimation_getLocalTransform_cu(this: *const c_void, node: u32) -> Matrix4x3d;
	fn tsMeshAnimation_getLocalTransform_ccMN(this: *const c_void, node: *mut c_void) -> Matrix4x3d;
	fn tsMeshAnimation_getLocalTransform_ccMJ(this: *const c_void, joint: *mut c_void) -> Matrix4x3d;
	fn tsMeshAnimation_getGlobalTransform_cu(this: *const c_void, node: u32) -> Matrix4x3d;
	fn tsMeshAnimation_getGlobalTransform_ccMN(this: *const c_void, node: *mut c_void) -> Matrix4x3d;
	fn tsMeshAnimation_getGlobalTransform_ccMJ(this: *const c_void, joint: *mut c_void) -> Matrix4x3d;
	fn tsMeshAnimation_getMorphTransform_cu(this: *const c_void, node: u32) -> Vector4f;
	fn tsMeshAnimation_getMorphTransform_ccMN(this: *const c_void, node: *mut c_void) -> Vector4f;
	fn tsMeshAnimation_getBoundBox_c(this: *const c_void) -> BoundBoxd;
	fn tsMeshAnimation_getBoundBox_ccMN(this: *const c_void, node: *mut c_void) -> BoundBoxd;
	fn tsMeshAnimation_getBoundBox_ccMG(this: *const c_void, geometry: *mut c_void) -> BoundBoxd;
	fn tsMeshAnimation_getBoundBox_ccMGcV4(this: *const c_void, geometry: *mut c_void, morph: *const Vector4f) -> BoundBoxd;
	fn tsMeshAnimation_setTransform_cV3(this: *mut c_void, scale: *const Vector3d);
	fn tsMeshAnimation_setTransform_cM43(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMeshAnimation_optimizeTransforms(this: *mut c_void, threshold: f32);
	fn tsMeshAnimation_getMemory(this: *const c_void) -> usize;
}

// Tellusim::MeshAttachment
pub struct MeshAttachment {
	this: *mut c_void,
	owner: bool,
}
impl MeshAttachment {
	pub fn null() -> MeshAttachment { MeshAttachment { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshAttachment { unsafe { MeshAttachment { this: tsMeshAttachment_new_s(ptr::null_mut()), owner: true } } }
	pub fn new_with_name(name: &str) -> MeshAttachment {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttachment { this: tsMeshAttachment_new_s(name_.as_ptr()), owner: true } }
	}
	pub fn new_with_type(type_: MeshAttachmentType) -> MeshAttachment { unsafe { MeshAttachment { this: tsMeshAttachment_new_MATs(type_, ptr::null_mut()), owner: true } } }
	pub fn new_with_type_name(type_: MeshAttachmentType, name: &str) -> MeshAttachment {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttachment { this: tsMeshAttachment_new_MATs(type_, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_node(node: &mut MeshNode) -> MeshAttachment { unsafe { MeshAttachment { this: tsMeshAttachment_new_MNs(node.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_node_name(node: &mut MeshNode, name: &str) -> MeshAttachment {
		let name_ = CString::new(name).unwrap();
		unsafe { MeshAttachment { this: tsMeshAttachment_new_MNs(node.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> MeshAttachment { unsafe { MeshAttachment { this: ptr, owner: tsMeshAttachment_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MeshAttachment { unsafe { MeshAttachment { this: tsMeshAttachment_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: MeshAttachment) -> bool { unsafe { tsMeshAttachment_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MeshAttachment { unsafe { MeshAttachment { this: tsMeshAttachment_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMeshAttachment_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMeshAttachment_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMeshAttachment_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMeshAttachment_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMeshAttachment_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMeshAttachment_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMeshAttachment_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMeshAttachment_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMeshAttachment_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMeshAttachment_clear(self.this) } }
	pub fn set_type(&mut self, type_: MeshAttachmentType) { unsafe { tsMeshAttachment_setType(self.this, type_) } }
	pub fn type_(&self) -> MeshAttachmentType { unsafe { tsMeshAttachment_getType(self.this) } }
	pub fn type_name_with_type(type_: MeshAttachmentType) -> string::String { unsafe { get_cstring(tsMeshAttachment_getTypeName_MAT(type_)) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsMeshAttachment_getTypeName_c(self.this)) } }
	pub fn is_unknown(&self) -> bool { unsafe { tsMeshAttachment_isUnknown(self.this) != 0 } }
	pub fn is_light(&self) -> bool { unsafe { tsMeshAttachment_isLight(self.this) != 0 } }
	pub fn is_camera(&self) -> bool { unsafe { tsMeshAttachment_isCamera(self.this) != 0 } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshAttachment_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMeshAttachment_getName(self.this)) } }
	pub fn set_node(&mut self, node: &mut MeshNode) { unsafe { tsMeshAttachment_setNode(self.this, node.this, 1) } }
	pub fn set_node_with_check(&mut self, node: &mut MeshNode, check: bool) { unsafe { tsMeshAttachment_setNode(self.this, node.this, if check {1} else {0}) } }
	pub fn node(&self) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshAttachment_getNode_c(self.this)) } }
	pub fn node_mut(&mut self) -> MeshNode { unsafe { MeshNode::new_ptr(tsMeshAttachment_getNode(self.this)) } }
	pub fn set_data(&mut self, data: &str) {
		let data_ = CString::new(data).unwrap();
		unsafe { tsMeshAttachment_setData_s(self.this, data_.as_ptr()) }
	}
	pub fn set_data_with_data(&mut self, data: &String) { unsafe { tsMeshAttachment_setData_cS(self.this, data.this) } }
	pub fn data(&self) -> string::String { unsafe { get_string(tsMeshAttachment_getData(self.this)) } }
	pub fn clear_parameters(&mut self) { unsafe { tsMeshAttachment_clearParameters(self.this) } }
	pub fn remove_parameter(&mut self, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_removeParameter(self.this, type__.as_ptr()) != 0 }
	}
	pub fn copy_parameters(&mut self, attachment: &MeshAttachment) { unsafe { tsMeshAttachment_copyParameters(self.this, attachment.this) } }
	pub fn find_parameter(&self, type_: &str) -> u32 {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_findParameter(self.this, type__.as_ptr()) }
	}
	pub fn has_parameter(&self, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_hasParameter(self.this, type__.as_ptr()) != 0 }
	}
	pub fn num_parameters(&self) -> u32 { unsafe { tsMeshAttachment_getNumParameters(self.this) } }
	pub fn parameter_type(&self, index: u32) -> string::String { unsafe { get_string(tsMeshAttachment_getParameterType(self.this, index)) } }
	pub fn add_parameter(&mut self, type_: &str, value: bool) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_addParameter_sb(self.this, type__.as_ptr(), if value {1} else {0}) }
	}
	pub fn add_parameter_with_value(&mut self, type_: &str, value: f32) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_addParameter_sf(self.this, type__.as_ptr(), value) }
	}
	pub fn add_parameter_with_vector(&mut self, type_: &str, vector: &Vector4f) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_addParameter_scV4(self.this, type__.as_ptr(), vector) }
	}
	pub fn add_parameter_with_color(&mut self, type_: &str, color: &Color) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_addParameter_scC(self.this, type__.as_ptr(), color) }
	}
	pub fn add_parameter_with_name(&mut self, type_: &str, name: &str) {
		let type__ = CString::new(type_).unwrap();
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshAttachment_addParameter_ss(self.this, type__.as_ptr(), name_.as_ptr()) }
	}
	pub fn add_parameter_with_names(&mut self, type_: &str, name: &String) {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_addParameter_scS(self.this, type__.as_ptr(), name.this) }
	}
	pub fn parameter_flags(&self, index: u32) -> MeshAttachmentFlags { unsafe { tsMeshAttachment_getParameterFlags_cu(self.this, index) } }
	pub fn has_parameter_flag(&self, index: u32, flags: MeshAttachmentFlags) -> bool { unsafe { tsMeshAttachment_hasParameterFlag_cuMAF(self.this, index, flags) != 0 } }
	pub fn has_parameter_flags(&self, index: u32, flags: MeshAttachmentFlags) -> bool { unsafe { tsMeshAttachment_hasParameterFlags_cuMAF(self.this, index, flags) != 0 } }
	pub fn parameter_bool(&self, index: u32) -> bool { unsafe { tsMeshAttachment_getParameterBool_cub(self.this, index, 0) != 0 } }
	pub fn parameter_bool_with_value(&self, index: u32, value: bool) -> bool { unsafe { tsMeshAttachment_getParameterBool_cub(self.this, index, if value {1} else {0}) != 0 } }
	pub fn parameter_scalarf32(&self, index: u32) -> f32 { unsafe { tsMeshAttachment_getParameterScalarf32_cuf(self.this, index, 0.0) } }
	pub fn parameter_scalarf32_with_value(&self, index: u32, value: f32) -> f32 { unsafe { tsMeshAttachment_getParameterScalarf32_cuf(self.this, index, value) } }
	pub fn parameter_vector4f(&self, index: u32) -> Vector4f { unsafe { tsMeshAttachment_getParameterVector4f_cucV4(self.this, index, &Vector4f::zero()) } }
	pub fn parameter_vector4f_with_vector(&self, index: u32, vector: &Vector4f) -> Vector4f { unsafe { tsMeshAttachment_getParameterVector4f_cucV4(self.this, index, vector) } }
	pub fn parameter_color(&self, index: u32) -> Color { unsafe { tsMeshAttachment_getParameterColor_cucC(self.this, index, &Color::white()) } }
	pub fn parameter_color_with_color(&self, index: u32, color: &Color) -> Color { unsafe { tsMeshAttachment_getParameterColor_cucC(self.this, index, color) } }
	pub fn parameter_name(&self, index: u32) -> string::String { unsafe { get_string(tsMeshAttachment_getParameterName_cucS(self.this, index, ptr::null_mut())) } }
	pub fn parameter_name_with_name(&self, index: u32, name: &String) -> string::String { unsafe { get_string(tsMeshAttachment_getParameterName_cucS(self.this, index, name.this)) } }
	pub fn parameter_flags_with_type(&self, type_: &str) -> MeshAttachmentFlags {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterFlags_cs(self.this, type__.as_ptr()) }
	}
	pub fn has_parameter_flag_with_type(&self, type_: &str, flags: MeshAttachmentFlags) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_hasParameterFlag_csMAF(self.this, type__.as_ptr(), flags) != 0 }
	}
	pub fn has_parameter_flags_with_type(&self, type_: &str, flags: MeshAttachmentFlags) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_hasParameterFlags_csMAF(self.this, type__.as_ptr(), flags) != 0 }
	}
	pub fn parameter_bool_with_type(&self, type_: &str) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterBool_csb(self.this, type__.as_ptr(), 0) != 0 }
	}
	pub fn parameter_bool_with_type_value(&self, type_: &str, value: bool) -> bool {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterBool_csb(self.this, type__.as_ptr(), if value {1} else {0}) != 0 }
	}
	pub fn parameter_scalarf32_with_type(&self, type_: &str) -> f32 {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterScalarf32_csf(self.this, type__.as_ptr(), 0.0) }
	}
	pub fn parameter_scalarf32_with_type_value(&self, type_: &str, value: f32) -> f32 {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterScalarf32_csf(self.this, type__.as_ptr(), value) }
	}
	pub fn parameter_vector4f_with_type(&self, type_: &str) -> Vector4f {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterVector4f_cscV4(self.this, type__.as_ptr(), &Vector4f::zero()) }
	}
	pub fn parameter_vector4f_with_type_vector(&self, type_: &str, vector: &Vector4f) -> Vector4f {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterVector4f_cscV4(self.this, type__.as_ptr(), vector) }
	}
	pub fn parameter_color_with_type(&self, type_: &str) -> Color {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterColor_cscC(self.this, type__.as_ptr(), &Color::white()) }
	}
	pub fn parameter_color_with_type_color(&self, type_: &str, color: &Color) -> Color {
		let type__ = CString::new(type_).unwrap();
		unsafe { tsMeshAttachment_getParameterColor_cscC(self.this, type__.as_ptr(), color) }
	}
	pub fn parameter_name_with_type(&self, type_: &str) -> string::String {
		let type__ = CString::new(type_).unwrap();
		unsafe { get_string(tsMeshAttachment_getParameterName_cscS(self.this, type__.as_ptr(), ptr::null_mut())) }
	}
	pub fn parameter_name_with_type_name(&self, type_: &str, name: &String) -> string::String {
		let type__ = CString::new(type_).unwrap();
		unsafe { get_string(tsMeshAttachment_getParameterName_cscS(self.this, type__.as_ptr(), name.this)) }
	}
	pub fn set_transform(&mut self, scale: &Vector3f) { unsafe { tsMeshAttachment_setTransform_cV3(self.this, scale) } }
	pub fn set_transform_with_transform(&mut self, transform: &Matrix4x3f) { unsafe { tsMeshAttachment_setTransform_cM43(self.this, transform) } }
	pub fn transform(&self) -> Matrix4x3f { unsafe { tsMeshAttachment_getTransform(self.this) } }
	pub fn compare(&self, attachment: &MeshAttachment) -> i32 { unsafe { tsMeshAttachment_compare(self.this, attachment.this) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshAttachment_getMemory(self.this) } }
}
impl Drop for MeshAttachment {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshAttachment_delete(self.this) } } }
}
impl Clone for MeshAttachment {
	fn clone(&self) -> MeshAttachment { unsafe { MeshAttachment { this: tsMeshAttachment_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MeshAttachment { }
impl fmt::Display for MeshAttachment {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshAttachment ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMeshAttachment_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMeshAttachment_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMeshAttachment_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMeshAttachment_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMeshAttachment_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshAttachment_new_s(name: *const c_char) -> *mut c_void;
	fn tsMeshAttachment_new_MATs(type_: MeshAttachmentType, name: *const c_char) -> *mut c_void;
	fn tsMeshAttachment_new_MNs(node: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsMeshAttachment_delete(this: *mut c_void);
	fn tsMeshAttachment_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMeshAttachment_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAttachment_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAttachment_clearPtr(this: *const c_void);
	fn tsMeshAttachment_destroyPtr(this: *const c_void);
	fn tsMeshAttachment_acquirePtr(this: *const c_void);
	fn tsMeshAttachment_unacquirePtr(this: *const c_void);
	fn tsMeshAttachment_isValidPtr(this: *const c_void) -> i32;
	fn tsMeshAttachment_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMeshAttachment_isConstPtr(this: *const c_void) -> i32;
	fn tsMeshAttachment_getCountPtr(this: *const c_void) -> u32;
	fn tsMeshAttachment_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMeshAttachment_clear(this: *mut c_void);
	fn tsMeshAttachment_setType(this: *mut c_void, type_: MeshAttachmentType);
	fn tsMeshAttachment_getType(this: *const c_void) -> MeshAttachmentType;
	fn tsMeshAttachment_getTypeName_MAT(type_: MeshAttachmentType) -> *const c_char;
	fn tsMeshAttachment_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsMeshAttachment_isUnknown(this: *const c_void) -> i32;
	fn tsMeshAttachment_isLight(this: *const c_void) -> i32;
	fn tsMeshAttachment_isCamera(this: *const c_void) -> i32;
	fn tsMeshAttachment_setName(this: *mut c_void, name: *const c_char);
	fn tsMeshAttachment_getName(this: *const c_void) -> *mut c_void;
	fn tsMeshAttachment_setNode(this: *mut c_void, node: *mut c_void, check: i32);
	fn tsMeshAttachment_getNode_c(this: *const c_void) -> *mut c_void;
	fn tsMeshAttachment_getNode(this: *mut c_void) -> *mut c_void;
	fn tsMeshAttachment_setData_s(this: *mut c_void, data: *const c_char);
	fn tsMeshAttachment_setData_cS(this: *mut c_void, data: *mut c_void);
	fn tsMeshAttachment_getData(this: *const c_void) -> *mut c_void;
	fn tsMeshAttachment_clearParameters(this: *mut c_void);
	fn tsMeshAttachment_removeParameter(this: *mut c_void, type_: *const c_char) -> i32;
	fn tsMeshAttachment_copyParameters(this: *mut c_void, attachment: *mut c_void);
	fn tsMeshAttachment_findParameter(this: *const c_void, type_: *const c_char) -> u32;
	fn tsMeshAttachment_hasParameter(this: *const c_void, type_: *const c_char) -> i32;
	fn tsMeshAttachment_getNumParameters(this: *const c_void) -> u32;
	fn tsMeshAttachment_getParameterType(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMeshAttachment_addParameter_sb(this: *mut c_void, type_: *const c_char, value: i32);
	fn tsMeshAttachment_addParameter_sf(this: *mut c_void, type_: *const c_char, value: f32);
	fn tsMeshAttachment_addParameter_scV4(this: *mut c_void, type_: *const c_char, vector: *const Vector4f);
	fn tsMeshAttachment_addParameter_scC(this: *mut c_void, type_: *const c_char, color: *const Color);
	fn tsMeshAttachment_addParameter_ss(this: *mut c_void, type_: *const c_char, name: *const c_char);
	fn tsMeshAttachment_addParameter_scS(this: *mut c_void, type_: *const c_char, name: *mut c_void);
	fn tsMeshAttachment_getParameterFlags_cu(this: *const c_void, index: u32) -> MeshAttachmentFlags;
	fn tsMeshAttachment_hasParameterFlag_cuMAF(this: *const c_void, index: u32, flags: MeshAttachmentFlags) -> i32;
	fn tsMeshAttachment_hasParameterFlags_cuMAF(this: *const c_void, index: u32, flags: MeshAttachmentFlags) -> i32;
	fn tsMeshAttachment_getParameterBool_cub(this: *const c_void, index: u32, value: i32) -> i32;
	fn tsMeshAttachment_getParameterScalarf32_cuf(this: *const c_void, index: u32, value: f32) -> f32;
	fn tsMeshAttachment_getParameterVector4f_cucV4(this: *const c_void, index: u32, vector: *const Vector4f) -> Vector4f;
	fn tsMeshAttachment_getParameterColor_cucC(this: *const c_void, index: u32, color: *const Color) -> Color;
	fn tsMeshAttachment_getParameterName_cucS(this: *const c_void, index: u32, name: *mut c_void) -> *mut c_void;
	fn tsMeshAttachment_getParameterFlags_cs(this: *const c_void, type_: *const c_char) -> MeshAttachmentFlags;
	fn tsMeshAttachment_hasParameterFlag_csMAF(this: *const c_void, type_: *const c_char, flags: MeshAttachmentFlags) -> i32;
	fn tsMeshAttachment_hasParameterFlags_csMAF(this: *const c_void, type_: *const c_char, flags: MeshAttachmentFlags) -> i32;
	fn tsMeshAttachment_getParameterBool_csb(this: *const c_void, type_: *const c_char, value: i32) -> i32;
	fn tsMeshAttachment_getParameterScalarf32_csf(this: *const c_void, type_: *const c_char, value: f32) -> f32;
	fn tsMeshAttachment_getParameterVector4f_cscV4(this: *const c_void, type_: *const c_char, vector: *const Vector4f) -> Vector4f;
	fn tsMeshAttachment_getParameterColor_cscC(this: *const c_void, type_: *const c_char, color: *const Color) -> Color;
	fn tsMeshAttachment_getParameterName_cscS(this: *const c_void, type_: *const c_char, name: *mut c_void) -> *mut c_void;
	fn tsMeshAttachment_setTransform_cV3(this: *mut c_void, scale: *const Vector3f);
	fn tsMeshAttachment_setTransform_cM43(this: *mut c_void, transform: *const Matrix4x3f);
	fn tsMeshAttachment_getTransform(this: *const c_void) -> Matrix4x3f;
	fn tsMeshAttachment_compare(this: *const c_void, attachment: *mut c_void) -> i32;
	fn tsMeshAttachment_getMemory(this: *const c_void) -> usize;
}

// Tellusim::Mesh
pub struct Mesh {
	this: *mut c_void,
	owner: bool,
}
impl Mesh {
	pub fn null() -> Mesh { Mesh { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Mesh { unsafe { Mesh { this: tsMesh_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Mesh { unsafe { Mesh { this: ptr, owner: tsMesh_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Mesh { unsafe { Mesh { this: tsMesh_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Mesh) -> bool { unsafe { tsMesh_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Mesh { unsafe { Mesh { this: tsMesh_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMesh_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMesh_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMesh_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMesh_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMesh_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMesh_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMesh_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMesh_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMesh_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsMesh_clear(self.this) } }
	pub fn is_loaded(&self) -> bool { unsafe { tsMesh_isLoaded(self.this) != 0 } }
	pub fn info_with_name_flags(&mut self, name: &str, flags: MeshFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_info_sMFA(self.this, name_.as_ptr(), flags, ptr::null_mut()) != 0 }
	}
	pub fn info_with_name_flags_async(&mut self, name: &str, flags: MeshFlags, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_info_sMFA(self.this, name_.as_ptr(), flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn info_with_names_flags(&mut self, name: &String, flags: MeshFlags) -> bool { unsafe { tsMesh_info_cSMFA(self.this, name.this, flags, ptr::null_mut()) != 0 } }
	pub fn info_with_names_flags_async(&mut self, name: &String, flags: MeshFlags, async_: Option<&Async>) -> bool { unsafe { tsMesh_info_cSMFA(self.this, name.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn info_with_stream_flags(&mut self, stream: &mut Stream, flags: MeshFlags) -> bool { unsafe { tsMesh_info_StMFA(self.this, stream.this, flags, ptr::null_mut()) != 0 } }
	pub fn info_with_stream_flags_async(&mut self, stream: &mut Stream, flags: MeshFlags, async_: Option<&Async>) -> bool { unsafe { tsMesh_info_StMFA(self.this, stream.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn info_with_name(&mut self, name: &str, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_info_sA(self.this, name_.as_ptr(), match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn info_with_names(&mut self, name: &String, async_: Option<&Async>) -> bool { unsafe { tsMesh_info_cSA(self.this, name.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn info_with_stream(&mut self, stream: &mut Stream, async_: Option<&Async>) -> bool { unsafe { tsMesh_info_StA(self.this, stream.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_name_flags(&mut self, name: &str, flags: MeshFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_load_sMFA(self.this, name_.as_ptr(), flags, ptr::null_mut()) != 0 }
	}
	pub fn load_with_name_flags_async(&mut self, name: &str, flags: MeshFlags, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_load_sMFA(self.this, name_.as_ptr(), flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn load_with_names_flags(&mut self, name: &String, flags: MeshFlags) -> bool { unsafe { tsMesh_load_cSMFA(self.this, name.this, flags, ptr::null_mut()) != 0 } }
	pub fn load_with_names_flags_async(&mut self, name: &String, flags: MeshFlags, async_: Option<&Async>) -> bool { unsafe { tsMesh_load_cSMFA(self.this, name.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_stream_flags(&mut self, stream: &mut Stream, flags: MeshFlags) -> bool { unsafe { tsMesh_load_StMFA(self.this, stream.this, flags, ptr::null_mut()) != 0 } }
	pub fn load_with_stream_flags_async(&mut self, stream: &mut Stream, flags: MeshFlags, async_: Option<&Async>) -> bool { unsafe { tsMesh_load_StMFA(self.this, stream.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_name(&mut self, name: &str, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_load_sA(self.this, name_.as_ptr(), match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn load_with_names(&mut self, name: &String, async_: Option<&Async>) -> bool { unsafe { tsMesh_load_cSA(self.this, name.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn load_with_stream(&mut self, stream: &mut Stream, async_: Option<&Async>) -> bool { unsafe { tsMesh_load_StA(self.this, stream.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn save(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_save_csMF(self.this, name_.as_ptr(), MeshFlags::None) != 0 }
	}
	pub fn save_with_flags(&self, name: &str, flags: MeshFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_save_csMF(self.this, name_.as_ptr(), flags) != 0 }
	}
	pub fn save_with_name(&self, name: &String) -> bool { unsafe { tsMesh_save_ccSMF(self.this, name.this, MeshFlags::None) != 0 } }
	pub fn save_with_name_flags(&self, name: &String, flags: MeshFlags) -> bool { unsafe { tsMesh_save_ccSMF(self.this, name.this, flags) != 0 } }
	pub fn save_with_stream(&self, stream: &mut Stream) -> bool { unsafe { tsMesh_save_cStMF(self.this, stream.this, MeshFlags::None) != 0 } }
	pub fn save_with_stream_flags(&self, stream: &mut Stream, flags: MeshFlags) -> bool { unsafe { tsMesh_save_cStMF(self.this, stream.this, flags) != 0 } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsMesh_getName(self.this)) } }
	pub fn set_basis_with_front(&mut self, front: MeshAxis, right: MeshAxis, up: MeshAxis) -> bool { unsafe { tsMesh_setBasis_MAMAMA(self.this, front, right, up) != 0 } }
	pub fn set_basis(&mut self, basis: MeshBasis) -> bool { unsafe { tsMesh_setBasis_MB(self.this, basis) != 0 } }
	pub fn front_axis(&self) -> MeshAxis { unsafe { tsMesh_getFrontAxis(self.this) } }
	pub fn right_axis(&self) -> MeshAxis { unsafe { tsMesh_getRightAxis(self.this) } }
	pub fn up_axis(&self) -> MeshAxis { unsafe { tsMesh_getUpAxis(self.this) } }
	pub fn basis(&self) -> MeshBasis { unsafe { tsMesh_getBasis(self.this) } }
	pub fn front_axis_name(&self) -> string::String { unsafe { get_cstring(tsMesh_getFrontAxisName(self.this)) } }
	pub fn right_axis_name(&self) -> string::String { unsafe { get_cstring(tsMesh_getRightAxisName(self.this)) } }
	pub fn up_axis_name(&self) -> string::String { unsafe { get_cstring(tsMesh_getUpAxisName(self.this)) } }
	pub fn basis_name(&self) -> string::String { unsafe { get_string(tsMesh_getBasisName(self.this)) } }
	pub fn clear_nodes(&mut self) { unsafe { tsMesh_clearNodes(self.this) } }
	pub fn reserve_nodes(&mut self, num_nodes: u32) { unsafe { tsMesh_reserveNodes(self.this, num_nodes) } }
	pub fn add_node(&mut self, node: &mut MeshNode) -> u32 { unsafe { tsMesh_addNode(self.this, node.this, 1) } }
	pub fn add_node_with_check(&mut self, node: &mut MeshNode, check: bool) -> u32 { unsafe { tsMesh_addNode(self.this, node.this, if check {1} else {0}) } }
	pub fn remove_node(&mut self, node: &mut MeshNode) -> bool { unsafe { tsMesh_removeNode(self.this, node.this) != 0 } }
	pub fn find_node(&self, node: &MeshNode) -> u32 { unsafe { tsMesh_findNode_ccMN(self.this, node.this) } }
	pub fn find_node_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_findNode_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_nodes(&self) -> u32 { unsafe { tsMesh_getNumNodes(self.this) } }
	pub fn node(&self, index: u32) -> MeshNode { unsafe { MeshNode::new_ptr(tsMesh_getNode_cu(self.this, index)) } }
	pub fn node_mut(&mut self, index: u32) -> MeshNode { unsafe { MeshNode::new_ptr(tsMesh_getNode_u(self.this, index)) } }
	pub fn create_local_transforms(&mut self) { unsafe { tsMesh_createLocalTransforms(self.this, &Matrix4x3d::identity()) } }
	pub fn create_local_transforms_with_itransform(&mut self, itransform: &Matrix4x3d) { unsafe { tsMesh_createLocalTransforms(self.this, itransform) } }
	pub fn create_global_transforms(&mut self) { unsafe { tsMesh_createGlobalTransforms(self.this, &Matrix4x3d::identity()) } }
	pub fn create_global_transforms_with_transform(&mut self, transform: &Matrix4x3d) { unsafe { tsMesh_createGlobalTransforms(self.this, transform) } }
	pub fn clear_geometries(&mut self) { unsafe { tsMesh_clearGeometries(self.this) } }
	pub fn reserve_geometries(&mut self, num_geometries: u32) { unsafe { tsMesh_reserveGeometries(self.this, num_geometries) } }
	pub fn add_geometry(&mut self, geometry: &mut MeshGeometry) -> u32 { unsafe { tsMesh_addGeometry_MGb(self.this, geometry.this, 1) } }
	pub fn add_geometry_with_check(&mut self, geometry: &mut MeshGeometry, check: bool) -> u32 { unsafe { tsMesh_addGeometry_MGb(self.this, geometry.this, if check {1} else {0}) } }
	pub fn add_geometry_with_node(&mut self, geometry: &mut MeshGeometry, node: &mut MeshNode) -> u32 { unsafe { tsMesh_addGeometry_MGMNb(self.this, geometry.this, node.this, 1) } }
	pub fn add_geometry_with_node_check(&mut self, geometry: &mut MeshGeometry, node: &mut MeshNode, check: bool) -> u32 { unsafe { tsMesh_addGeometry_MGMNb(self.this, geometry.this, node.this, if check {1} else {0}) } }
	pub fn remove_geometry(&mut self, geometry: &mut MeshGeometry) -> bool { unsafe { tsMesh_removeGeometry(self.this, geometry.this) != 0 } }
	pub fn replace_geometry(&mut self, old_geometry: &mut MeshGeometry, geometry: &mut MeshGeometry) -> bool { unsafe { tsMesh_replaceGeometry(self.this, old_geometry.this, geometry.this) != 0 } }
	pub fn find_geometry(&self, geometry: &MeshGeometry) -> u32 { unsafe { tsMesh_findGeometry_ccMG(self.this, geometry.this) } }
	pub fn find_geometry_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_findGeometry_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_geometries(&self) -> u32 { unsafe { tsMesh_getNumGeometries(self.this) } }
	pub fn geometry(&self, index: u32) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMesh_getGeometry_cu(self.this, index)) } }
	pub fn geometry_mut(&mut self, index: u32) -> MeshGeometry { unsafe { MeshGeometry::new_ptr(tsMesh_getGeometry_u(self.this, index)) } }
	pub fn has_geometry_indices(&self, type_: MeshIndicesType) -> bool { unsafe { tsMesh_hasGeometryIndices(self.this, type_) != 0 } }
	pub fn has_geometry_attribute(&self, type_: MeshAttributeType) -> bool { unsafe { tsMesh_hasGeometryAttribute(self.this, type_) != 0 } }
	pub fn num_geometry_positions(&self) -> usize { unsafe { tsMesh_getNumGeometryPositions(self.this) } }
	pub fn num_geometry_primitives(&self) -> usize { unsafe { tsMesh_getNumGeometryPrimitives(self.this) } }
	pub fn clear_animations(&mut self) { unsafe { tsMesh_clearAnimations(self.this) } }
	pub fn reserve_animations(&mut self, num_animations: u32) { unsafe { tsMesh_reserveAnimations(self.this, num_animations) } }
	pub fn add_animation(&mut self, animation: &mut MeshAnimation) -> u32 { unsafe { tsMesh_addAnimation(self.this, animation.this, 1) } }
	pub fn add_animation_with_check(&mut self, animation: &mut MeshAnimation, check: bool) -> u32 { unsafe { tsMesh_addAnimation(self.this, animation.this, if check {1} else {0}) } }
	pub fn remove_animation(&mut self, animation: &mut MeshAnimation) -> bool { unsafe { tsMesh_removeAnimation(self.this, animation.this) != 0 } }
	pub fn replace_animation(&mut self, old_animation: &mut MeshAnimation, animation: &mut MeshAnimation) -> bool { unsafe { tsMesh_replaceAnimation(self.this, old_animation.this, animation.this) != 0 } }
	pub fn find_animation(&self, animation: &MeshAnimation) -> u32 { unsafe { tsMesh_findAnimation_ccMA(self.this, animation.this) } }
	pub fn find_animation_with_name(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMesh_findAnimation_cs(self.this, name_.as_ptr()) }
	}
	pub fn num_animations(&self) -> u32 { unsafe { tsMesh_getNumAnimations(self.this) } }
	pub fn animation(&self, index: u32) -> MeshAnimation { unsafe { MeshAnimation::new_ptr(tsMesh_getAnimation_cu(self.this, index)) } }
	pub fn animation_mut(&mut self, index: u32) -> MeshAnimation { unsafe { MeshAnimation::new_ptr(tsMesh_getAnimation_u(self.this, index)) } }
	pub fn bound_box(&self) -> BoundBoxd { unsafe { tsMesh_getBoundBox_c(self.this) } }
	pub fn bound_box_with_node(&self, node: &MeshNode) -> BoundBoxd { unsafe { tsMesh_getBoundBox_ccMN(self.this, node.this) } }
	pub fn bound_box_with_geometry(&self, geometry: &MeshGeometry) -> BoundBoxd { unsafe { tsMesh_getBoundBox_ccMG(self.this, geometry.this) } }
	pub fn create_bounds_with_force(&mut self, force: bool) -> bool { unsafe { tsMesh_createBounds_bA(self.this, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_bounds_with_force_async(&mut self, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createBounds_bA(self.this, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_bounds(&mut self) -> bool { unsafe { tsMesh_createBounds_A(self.this, ptr::null_mut()) != 0 } }
	pub fn create_bounds_with_async(&mut self, async_: Option<&Async>) -> bool { unsafe { tsMesh_createBounds_A(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_basis_with_force(&mut self, force: bool) -> bool { unsafe { tsMesh_createBasis_bA(self.this, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_basis_with_force_async(&mut self, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createBasis_bA(self.this, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_basis_with_angle_force(&mut self, angle: f32, force: bool) -> bool { unsafe { tsMesh_createBasis_fbA(self.this, angle, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_basis_with_angle_force_async(&mut self, angle: f32, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createBasis_fbA(self.this, angle, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_basis_with_async(&mut self, async_: Option<&Async>) -> bool { unsafe { tsMesh_createBasis_A(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_basis_with_angle(&mut self, angle: f32) -> bool { unsafe { tsMesh_createBasis_fA(self.this, angle, ptr::null_mut()) != 0 } }
	pub fn create_basis_with_angle_async(&mut self, angle: f32, async_: Option<&Async>) -> bool { unsafe { tsMesh_createBasis_fA(self.this, angle, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_normals_with_force(&mut self, force: bool) -> bool { unsafe { tsMesh_createNormals_bA(self.this, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_normals_with_force_async(&mut self, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createNormals_bA(self.this, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_normals_with_angle_force(&mut self, angle: f32, force: bool) -> bool { unsafe { tsMesh_createNormals_fbA(self.this, angle, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_normals_with_angle_force_async(&mut self, angle: f32, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createNormals_fbA(self.this, angle, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_normals_with_async(&mut self, async_: Option<&Async>) -> bool { unsafe { tsMesh_createNormals_A(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_normals_with_angle(&mut self, angle: f32) -> bool { unsafe { tsMesh_createNormals_fA(self.this, angle, ptr::null_mut()) != 0 } }
	pub fn create_normals_with_angle_async(&mut self, angle: f32, async_: Option<&Async>) -> bool { unsafe { tsMesh_createNormals_fA(self.this, angle, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_tangents_with_force(&mut self, force: bool) -> bool { unsafe { tsMesh_createTangents_bA(self.this, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_tangents_with_force_async(&mut self, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createTangents_bA(self.this, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_tangents(&mut self) -> bool { unsafe { tsMesh_createTangents_A(self.this, ptr::null_mut()) != 0 } }
	pub fn create_tangents_with_async(&mut self, async_: Option<&Async>) -> bool { unsafe { tsMesh_createTangents_A(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_islands_with_force(&mut self, max_attributes: u32, max_primitives: u32, force: bool) -> bool { unsafe { tsMesh_createIslands_uubA(self.this, max_attributes, max_primitives, if force {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn create_islands_with_force_async(&mut self, max_attributes: u32, max_primitives: u32, force: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_createIslands_uubA(self.this, max_attributes, max_primitives, if force {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_islands(&mut self, max_attributes: u32, max_primitives: u32) -> bool { unsafe { tsMesh_createIslands_uuA(self.this, max_attributes, max_primitives, ptr::null_mut()) != 0 } }
	pub fn create_islands_with_async(&mut self, max_attributes: u32, max_primitives: u32, async_: Option<&Async>) -> bool { unsafe { tsMesh_createIslands_uuA(self.this, max_attributes, max_primitives, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn optimize_indices_with_cache_transparent(&mut self, cache: u32, transparent: bool) -> bool { unsafe { tsMesh_optimizeIndices_ubA(self.this, cache, if transparent {1} else {0}, ptr::null_mut()) != 0 } }
	pub fn optimize_indices_with_cache_transparent_async(&mut self, cache: u32, transparent: bool, async_: Option<&Async>) -> bool { unsafe { tsMesh_optimizeIndices_ubA(self.this, cache, if transparent {1} else {0}, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn optimize_indices_with_async(&mut self, async_: Option<&Async>) -> bool { unsafe { tsMesh_optimizeIndices_A(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn optimize_indices_with_cache(&mut self, cache: u32) -> bool { unsafe { tsMesh_optimizeIndices_uA(self.this, cache, ptr::null_mut()) != 0 } }
	pub fn optimize_indices_with_cache_async(&mut self, cache: u32, async_: Option<&Async>) -> bool { unsafe { tsMesh_optimizeIndices_uA(self.this, cache, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn optimize_attributes(&mut self) -> bool { unsafe { tsMesh_optimizeAttributes(self.this, ptr::null_mut()) != 0 } }
	pub fn optimize_attributes_with_async(&mut self, async_: Option<&Async>) -> bool { unsafe { tsMesh_optimizeAttributes(self.this, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn optimize_materials(&mut self) { unsafe { tsMesh_optimizeMaterials(self.this) } }
	pub fn optimize_winding(&mut self) -> bool { unsafe { tsMesh_optimizeWinding(self.this, 0) != 0 } }
	pub fn optimize_winding_with_clockwise(&mut self, clockwise: bool) -> bool { unsafe { tsMesh_optimizeWinding(self.this, if clockwise {1} else {0}) != 0 } }
	pub fn optimize_geometries(&mut self) { unsafe { tsMesh_optimizeGeometries(self.this, 1e-3, 16) } }
	pub fn optimize_geometries_with_threshold(&mut self, threshold: f32) { unsafe { tsMesh_optimizeGeometries(self.this, threshold, 16) } }
	pub fn optimize_geometries_with_threshold_depth(&mut self, threshold: f32, depth: u32) { unsafe { tsMesh_optimizeGeometries(self.this, threshold, depth) } }
	pub fn optimize_animations(&mut self) { unsafe { tsMesh_optimizeAnimations(self.this, 1e-6) } }
	pub fn optimize_animations_with_threshold(&mut self, threshold: f32) { unsafe { tsMesh_optimizeAnimations(self.this, threshold) } }
	pub fn optimize_order(&mut self) -> bool { unsafe { tsMesh_optimizeOrder(self.this) != 0 } }
	pub fn merge_geometries(&mut self) { unsafe { tsMesh_mergeGeometries(self.this) } }
	pub fn pack_attributes(&mut self) -> bool { unsafe { tsMesh_packAttributes(self.this, 1) != 0 } }
	pub fn pack_attributes_with_remove(&mut self, remove: bool) -> bool { unsafe { tsMesh_packAttributes(self.this, if remove {1} else {0}) != 0 } }
	pub fn unpack_attributes(&mut self) -> bool { unsafe { tsMesh_unpackAttributes(self.this, 1) != 0 } }
	pub fn unpack_attributes_with_remove(&mut self, remove: bool) -> bool { unsafe { tsMesh_unpackAttributes(self.this, if remove {1} else {0}) != 0 } }
	pub fn set_transform(&mut self, scale: &Vector3d) -> bool { unsafe { tsMesh_setTransform(self.this, scale) != 0 } }
	pub fn memory(&self) -> usize { unsafe { tsMesh_getMemory(self.this) } }
}
impl Drop for Mesh {
	fn drop(&mut self) { if self.owner { unsafe { tsMesh_delete(self.this) } } }
}
impl Clone for Mesh {
	fn clone(&self) -> Mesh { unsafe { Mesh { this: tsMesh_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Mesh { }
impl fmt::Display for Mesh {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Mesh ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMesh_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMesh_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMesh_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMesh_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMesh_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMesh_new() -> *mut c_void;
	fn tsMesh_delete(this: *mut c_void);
	fn tsMesh_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMesh_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMesh_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMesh_clearPtr(this: *const c_void);
	fn tsMesh_destroyPtr(this: *const c_void);
	fn tsMesh_acquirePtr(this: *const c_void);
	fn tsMesh_unacquirePtr(this: *const c_void);
	fn tsMesh_isValidPtr(this: *const c_void) -> i32;
	fn tsMesh_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMesh_isConstPtr(this: *const c_void) -> i32;
	fn tsMesh_getCountPtr(this: *const c_void) -> u32;
	fn tsMesh_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMesh_clear(this: *mut c_void);
	fn tsMesh_isLoaded(this: *const c_void) -> i32;
	fn tsMesh_info_sMFA(this: *mut c_void, name: *const c_char, flags: MeshFlags, async_: *const *mut c_void) -> i32;
	fn tsMesh_info_cSMFA(this: *mut c_void, name: *mut c_void, flags: MeshFlags, async_: *const *mut c_void) -> i32;
	fn tsMesh_info_StMFA(this: *mut c_void, stream: *mut c_void, flags: MeshFlags, async_: *const *mut c_void) -> i32;
	fn tsMesh_info_sA(this: *mut c_void, name: *const c_char, async_: *const *mut c_void) -> i32;
	fn tsMesh_info_cSA(this: *mut c_void, name: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_info_StA(this: *mut c_void, stream: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_load_sMFA(this: *mut c_void, name: *const c_char, flags: MeshFlags, async_: *const *mut c_void) -> i32;
	fn tsMesh_load_cSMFA(this: *mut c_void, name: *mut c_void, flags: MeshFlags, async_: *const *mut c_void) -> i32;
	fn tsMesh_load_StMFA(this: *mut c_void, stream: *mut c_void, flags: MeshFlags, async_: *const *mut c_void) -> i32;
	fn tsMesh_load_sA(this: *mut c_void, name: *const c_char, async_: *const *mut c_void) -> i32;
	fn tsMesh_load_cSA(this: *mut c_void, name: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_load_StA(this: *mut c_void, stream: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_save_csMF(this: *const c_void, name: *const c_char, flags: MeshFlags) -> i32;
	fn tsMesh_save_ccSMF(this: *const c_void, name: *mut c_void, flags: MeshFlags) -> i32;
	fn tsMesh_save_cStMF(this: *const c_void, stream: *mut c_void, flags: MeshFlags) -> i32;
	fn tsMesh_setName(this: *mut c_void, name: *const c_char);
	fn tsMesh_getName(this: *const c_void) -> *mut c_void;
	fn tsMesh_setBasis_MAMAMA(this: *mut c_void, front: MeshAxis, right: MeshAxis, up: MeshAxis) -> i32;
	fn tsMesh_setBasis_MB(this: *mut c_void, basis: MeshBasis) -> i32;
	fn tsMesh_getFrontAxis(this: *const c_void) -> MeshAxis;
	fn tsMesh_getRightAxis(this: *const c_void) -> MeshAxis;
	fn tsMesh_getUpAxis(this: *const c_void) -> MeshAxis;
	fn tsMesh_getBasis(this: *const c_void) -> MeshBasis;
	fn tsMesh_getFrontAxisName(this: *const c_void) -> *const c_char;
	fn tsMesh_getRightAxisName(this: *const c_void) -> *const c_char;
	fn tsMesh_getUpAxisName(this: *const c_void) -> *const c_char;
	fn tsMesh_getBasisName(this: *const c_void) -> *mut c_void;
	fn tsMesh_clearNodes(this: *mut c_void);
	fn tsMesh_reserveNodes(this: *mut c_void, num_nodes: u32);
	fn tsMesh_addNode(this: *mut c_void, node: *mut c_void, check: i32) -> u32;
	fn tsMesh_removeNode(this: *mut c_void, node: *mut c_void) -> i32;
	fn tsMesh_findNode_ccMN(this: *const c_void, node: *mut c_void) -> u32;
	fn tsMesh_findNode_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMesh_getNumNodes(this: *const c_void) -> u32;
	fn tsMesh_getNode_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMesh_getNode_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMesh_createLocalTransforms(this: *mut c_void, itransform: *const Matrix4x3d);
	fn tsMesh_createGlobalTransforms(this: *mut c_void, transform: *const Matrix4x3d);
	fn tsMesh_clearGeometries(this: *mut c_void);
	fn tsMesh_reserveGeometries(this: *mut c_void, num_geometries: u32);
	fn tsMesh_addGeometry_MGb(this: *mut c_void, geometry: *mut c_void, check: i32) -> u32;
	fn tsMesh_addGeometry_MGMNb(this: *mut c_void, geometry: *mut c_void, node: *mut c_void, check: i32) -> u32;
	fn tsMesh_removeGeometry(this: *mut c_void, geometry: *mut c_void) -> i32;
	fn tsMesh_replaceGeometry(this: *mut c_void, old_geometry: *mut c_void, geometry: *mut c_void) -> i32;
	fn tsMesh_findGeometry_ccMG(this: *const c_void, geometry: *mut c_void) -> u32;
	fn tsMesh_findGeometry_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMesh_getNumGeometries(this: *const c_void) -> u32;
	fn tsMesh_getGeometry_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMesh_getGeometry_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMesh_hasGeometryIndices(this: *const c_void, type_: MeshIndicesType) -> i32;
	fn tsMesh_hasGeometryAttribute(this: *const c_void, type_: MeshAttributeType) -> i32;
	fn tsMesh_getNumGeometryPositions(this: *const c_void) -> usize;
	fn tsMesh_getNumGeometryPrimitives(this: *const c_void) -> usize;
	fn tsMesh_clearAnimations(this: *mut c_void);
	fn tsMesh_reserveAnimations(this: *mut c_void, num_animations: u32);
	fn tsMesh_addAnimation(this: *mut c_void, animation: *mut c_void, check: i32) -> u32;
	fn tsMesh_removeAnimation(this: *mut c_void, animation: *mut c_void) -> i32;
	fn tsMesh_replaceAnimation(this: *mut c_void, old_animation: *mut c_void, animation: *mut c_void) -> i32;
	fn tsMesh_findAnimation_ccMA(this: *const c_void, animation: *mut c_void) -> u32;
	fn tsMesh_findAnimation_cs(this: *const c_void, name: *const c_char) -> u32;
	fn tsMesh_getNumAnimations(this: *const c_void) -> u32;
	fn tsMesh_getAnimation_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMesh_getAnimation_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsMesh_getBoundBox_c(this: *const c_void) -> BoundBoxd;
	fn tsMesh_getBoundBox_ccMN(this: *const c_void, node: *mut c_void) -> BoundBoxd;
	fn tsMesh_getBoundBox_ccMG(this: *const c_void, geometry: *mut c_void) -> BoundBoxd;
	fn tsMesh_createBounds_bA(this: *mut c_void, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createBounds_A(this: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_createBasis_bA(this: *mut c_void, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createBasis_fbA(this: *mut c_void, angle: f32, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createBasis_A(this: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_createBasis_fA(this: *mut c_void, angle: f32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createNormals_bA(this: *mut c_void, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createNormals_fbA(this: *mut c_void, angle: f32, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createNormals_A(this: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_createNormals_fA(this: *mut c_void, angle: f32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createTangents_bA(this: *mut c_void, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createTangents_A(this: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_createIslands_uubA(this: *mut c_void, max_attributes: u32, max_primitives: u32, force: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_createIslands_uuA(this: *mut c_void, max_attributes: u32, max_primitives: u32, async_: *const *mut c_void) -> i32;
	fn tsMesh_optimizeIndices_ubA(this: *mut c_void, cache: u32, transparent: i32, async_: *const *mut c_void) -> i32;
	fn tsMesh_optimizeIndices_A(this: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_optimizeIndices_uA(this: *mut c_void, cache: u32, async_: *const *mut c_void) -> i32;
	fn tsMesh_optimizeAttributes(this: *mut c_void, async_: *const *mut c_void) -> i32;
	fn tsMesh_optimizeMaterials(this: *mut c_void);
	fn tsMesh_optimizeWinding(this: *mut c_void, clockwise: i32) -> i32;
	fn tsMesh_optimizeGeometries(this: *mut c_void, threshold: f32, depth: u32);
	fn tsMesh_optimizeAnimations(this: *mut c_void, threshold: f32);
	fn tsMesh_optimizeOrder(this: *mut c_void) -> i32;
	fn tsMesh_mergeGeometries(this: *mut c_void);
	fn tsMesh_packAttributes(this: *mut c_void, remove: i32) -> i32;
	fn tsMesh_unpackAttributes(this: *mut c_void, remove: i32) -> i32;
	fn tsMesh_setTransform(this: *mut c_void, scale: *const Vector3d) -> i32;
	fn tsMesh_getMemory(this: *const c_void) -> usize;
}

// Tellusim::Json
pub struct Json {
	this: *mut c_void,
	owner: bool,
}
impl Json {
	pub fn null() -> Json { Json { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Json { unsafe { Json { this: tsJson_new(), owner: true } } }
	pub fn new_with_type(type_: JsonType) -> Json { unsafe { Json { this: tsJson_new_JT(type_), owner: true } } }
	pub fn new_with_name(name: &str) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json { this: tsJson_new_sJT(name_.as_ptr(), JsonType::Unknown), owner: true } }
	}
	pub fn new_with_name_type(name: &str, type_: JsonType) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json { this: tsJson_new_sJT(name_.as_ptr(), type_), owner: true } }
	}
	pub fn new_with_names(name: &String) -> Json { unsafe { Json { this: tsJson_new_cSJT(name.this, JsonType::Unknown), owner: true } } }
	pub fn new_with_names_type(name: &String, type_: JsonType) -> Json { unsafe { Json { this: tsJson_new_cSJT(name.this, type_), owner: true } } }
	pub fn new_with_parent(parent: Option<&Json>, name: &str) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json { this: tsJson_new_JsJT(match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr(), JsonType::Unknown), owner: true } }
	}
	pub fn new_with_parent_type(parent: Option<&Json>, name: &str, type_: JsonType) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json { this: tsJson_new_JsJT(match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr(), type_), owner: true } }
	}
	pub fn new_with_parent_name(parent: Option<&Json>, name: &String) -> Json { unsafe { Json { this: tsJson_new_JcSJT(match parent { Some(parent) => &parent.this, None => ptr::null() }, name.this, JsonType::Unknown), owner: true } } }
	pub fn new_with_parent_name_type(parent: Option<&Json>, name: &String, type_: JsonType) -> Json { unsafe { Json { this: tsJson_new_JcSJT(match parent { Some(parent) => &parent.this, None => ptr::null() }, name.this, type_), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Json { unsafe { Json { this: ptr, owner: tsJson_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Json { unsafe { Json { this: tsJson_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Json) -> bool { unsafe { tsJson_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Json { unsafe { Json { this: tsJson_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsJson_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsJson_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsJson_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsJson_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsJson_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsJson_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsJson_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsJson_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsJson_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsJson_clear(self.this) } }
	pub fn create(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsJson_create_szb(self.this, str_.as_ptr(), 0, 0) != 0 }
	}
	pub fn create_with_size(&mut self, str: &str, size: usize) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsJson_create_szb(self.this, str_.as_ptr(), size, 0) != 0 }
	}
	pub fn create_with_size_owner(&mut self, str: &str, size: usize, owner: bool) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsJson_create_szb(self.this, str_.as_ptr(), size, if owner {1} else {0}) != 0 }
	}
	pub fn create_with_str(&mut self, str: &String) -> bool { unsafe { tsJson_create_cSzb(self.this, str.this, 0, 0) != 0 } }
	pub fn create_with_str_size(&mut self, str: &String, size: usize) -> bool { unsafe { tsJson_create_cSzb(self.this, str.this, size, 0) != 0 } }
	pub fn create_with_str_size_owner(&mut self, str: &String, size: usize, owner: bool) -> bool { unsafe { tsJson_create_cSzb(self.this, str.this, size, if owner {1} else {0}) != 0 } }
	pub fn load(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_load_s(self.this, name_.as_ptr()) != 0 }
	}
	pub fn load_with_name(&mut self, name: &String) -> bool { unsafe { tsJson_load_cS(self.this, name.this) != 0 } }
	pub fn load_with_stream(&mut self, stream: &mut Stream) -> bool { unsafe { tsJson_load_St(self.this, stream.this) != 0 } }
	pub fn save(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_save_csb(self.this, name_.as_ptr(), 0) != 0 }
	}
	pub fn save_with_compact(&self, name: &str, compact: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_save_csb(self.this, name_.as_ptr(), if compact {1} else {0}) != 0 }
	}
	pub fn save_with_name(&self, name: &String) -> bool { unsafe { tsJson_save_ccSb(self.this, name.this, 0) != 0 } }
	pub fn save_with_name_compact(&self, name: &String, compact: bool) -> bool { unsafe { tsJson_save_ccSb(self.this, name.this, if compact {1} else {0}) != 0 } }
	pub fn save_with_stream(&self, stream: &mut Stream) -> bool { unsafe { tsJson_save_cStb(self.this, stream.this, 0) != 0 } }
	pub fn save_with_stream_compact(&self, stream: &mut Stream, compact: bool) -> bool { unsafe { tsJson_save_cStb(self.this, stream.this, if compact {1} else {0}) != 0 } }
	pub fn root(&self) -> Json { unsafe { Json::new_ptr(tsJson_getRoot_c(self.this)) } }
	pub fn root_mut(&mut self) -> Json { unsafe { Json::new_ptr(tsJson_getRoot(self.this)) } }
	pub fn set_parent(&mut self, parent: &mut Json) -> u32 { unsafe { tsJson_setParent(self.this, parent.this, 1) } }
	pub fn set_parent_with_check(&mut self, parent: &mut Json, check: bool) -> u32 { unsafe { tsJson_setParent(self.this, parent.this, if check {1} else {0}) } }
	pub fn parent(&self) -> Json { unsafe { Json::new_ptr(tsJson_getParent_c(self.this)) } }
	pub fn parent_mut(&mut self) -> Json { unsafe { Json::new_ptr(tsJson_getParent(self.this)) } }
	pub fn add_child_with_name(&mut self, name: &str) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json::new_ptr(tsJson_addChild_sJTb(self.this, name_.as_ptr(), JsonType::Unknown, 1)) }
	}
	pub fn add_child_with_name_type(&mut self, name: &str, type_: JsonType) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json::new_ptr(tsJson_addChild_sJTb(self.this, name_.as_ptr(), type_, 1)) }
	}
	pub fn add_child_with_name_type_check(&mut self, name: &str, type_: JsonType, check: bool) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json::new_ptr(tsJson_addChild_sJTb(self.this, name_.as_ptr(), type_, if check {1} else {0})) }
	}
	pub fn add_child(&mut self, child: &mut Json) -> u32 { unsafe { tsJson_addChild_Jb(self.this, child.this, 1) } }
	pub fn add_child_with_check(&mut self, child: &mut Json, check: bool) -> u32 { unsafe { tsJson_addChild_Jb(self.this, child.this, if check {1} else {0}) } }
	pub fn remove_child(&mut self, child: &mut Json) -> bool { unsafe { tsJson_removeChild(self.this, child.this) != 0 } }
	pub fn release_children(&mut self) { unsafe { tsJson_releaseChildren(self.this) } }
	pub fn find_child(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_findChild(self.this, name_.as_ptr()) }
	}
	pub fn is_child(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_isChild(self.this, name_.as_ptr()) != 0 }
	}
	pub fn child(&self, name: &str) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json::new_ptr(tsJson_getChild_cs(self.this, name_.as_ptr())) }
	}
	pub fn child_mut(&mut self, name: &str) -> Json {
		let name_ = CString::new(name).unwrap();
		unsafe { Json::new_ptr(tsJson_getChild_s(self.this, name_.as_ptr())) }
	}
	pub fn num_children(&self) -> u32 { unsafe { tsJson_getNumChildren(self.this) } }
	pub fn child_with_index(&self, index: u32) -> Json { unsafe { Json::new_ptr(tsJson_getChild_cu(self.this, index)) } }
	pub fn child_mut_with_index(&mut self, index: u32) -> Json { unsafe { Json::new_ptr(tsJson_getChild_u(self.this, index)) } }
	pub fn path_name(&self) -> string::String { unsafe { get_string(tsJson_getPathName(self.this)) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_setName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_name_with_name(&mut self, name: &String) { unsafe { tsJson_setName_cS(self.this, name.this) } }
	pub fn name(&self) -> string::String { unsafe { get_string(tsJson_getName(self.this)) } }
	pub fn set_type(&mut self, type_: JsonType) { unsafe { tsJson_setType(self.this, type_) } }
	pub fn type_(&self) -> JsonType { unsafe { tsJson_getType(self.this) } }
	pub fn type_name_with_type(type_: JsonType) -> string::String { unsafe { get_cstring(tsJson_getTypeName_JT(type_)) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsJson_getTypeName_c(self.this)) } }
	pub fn is_unknown(&self) -> bool { unsafe { tsJson_isUnknown(self.this) != 0 } }
	pub fn is_null(&self) -> bool { unsafe { tsJson_isNull(self.this) != 0 } }
	pub fn is_bool(&self) -> bool { unsafe { tsJson_isBool(self.this) != 0 } }
	pub fn is_number(&self) -> bool { unsafe { tsJson_isNumber(self.this) != 0 } }
	pub fn is_string(&self) -> bool { unsafe { tsJson_isString(self.this) != 0 } }
	pub fn is_object(&self) -> bool { unsafe { tsJson_isObject(self.this) != 0 } }
	pub fn is_array(&self) -> bool { unsafe { tsJson_isArray(self.this) != 0 } }
	pub fn set_data_with_valueb(&mut self, value: bool) { unsafe { tsJson_setData_b(self.this, if value {1} else {0}) } }
	pub fn set_data_with_valuei32(&mut self, value: i32) { unsafe { tsJson_setData_iu(self.this, value, 10) } }
	pub fn set_data_with_valuei32_radix(&mut self, value: i32, radix: u32) { unsafe { tsJson_setData_iu(self.this, value, radix) } }
	pub fn set_data_with_valueu32(&mut self, value: u32) { unsafe { tsJson_setData_uu(self.this, value, 10) } }
	pub fn set_data_with_valueu32_radix(&mut self, value: u32, radix: u32) { unsafe { tsJson_setData_uu(self.this, value, radix) } }
	pub fn set_data_with_valueu64(&mut self, value: u64) { unsafe { tsJson_setData_u64u(self.this, value, 10) } }
	pub fn set_data_with_valueu64_radix(&mut self, value: u64, radix: u32) { unsafe { tsJson_setData_u64u(self.this, value, radix) } }
	pub fn set_data_with_valuef32(&mut self, value: f32) { unsafe { tsJson_setData_fubb(self.this, value, 6, 1, 1) } }
	pub fn set_data_with_valuef32_digits(&mut self, value: f32, digits: u32) { unsafe { tsJson_setData_fubb(self.this, value, digits, 1, 1) } }
	pub fn set_data_with_valuef32_digits_compact(&mut self, value: f32, digits: u32, compact: bool) { unsafe { tsJson_setData_fubb(self.this, value, digits, if compact {1} else {0}, 1) } }
	pub fn set_data_with_valuef32_digits_compact_exponent(&mut self, value: f32, digits: u32, compact: bool, exponent: bool) { unsafe { tsJson_setData_fubb(self.this, value, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn set_data_with_valuef64(&mut self, value: f64) { unsafe { tsJson_setData_f64ubb(self.this, value, 12, 1, 1) } }
	pub fn set_data_with_valuef64_digits(&mut self, value: f64, digits: u32) { unsafe { tsJson_setData_f64ubb(self.this, value, digits, 1, 1) } }
	pub fn set_data_with_valuef64_digits_compact(&mut self, value: f64, digits: u32, compact: bool) { unsafe { tsJson_setData_f64ubb(self.this, value, digits, if compact {1} else {0}, 1) } }
	pub fn set_data_with_valuef64_digits_compact_exponent(&mut self, value: f64, digits: u32, compact: bool, exponent: bool) { unsafe { tsJson_setData_f64ubb(self.this, value, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn set_data_with_value(&mut self, value: &str) {
		let value_ = CString::new(value).unwrap();
		unsafe { tsJson_setData_s(self.this, value_.as_ptr()) }
	}
	pub fn set_data_with_values(&mut self, value: &String) { unsafe { tsJson_setData_cS(self.this, value.this) } }
	pub fn data(&self) -> string::String { unsafe { get_string(tsJson_getData_c(self.this)) } }
	pub fn data_bool(&self) -> bool { unsafe { tsJson_getDataBool(self.this) != 0 } }
	pub fn datai32(&self) -> i32 { unsafe { tsJson_getDatai32(self.this, 10) } }
	pub fn datai32_with_radix(&self, radix: u32) -> i32 { unsafe { tsJson_getDatai32(self.this, radix) } }
	pub fn datau32(&self) -> u32 { unsafe { tsJson_getDatau32(self.this, 10) } }
	pub fn datau32_with_radix(&self, radix: u32) -> u32 { unsafe { tsJson_getDatau32(self.this, radix) } }
	pub fn datau64(&self) -> u64 { unsafe { tsJson_getDatau64(self.this, 10) } }
	pub fn datau64_with_radix(&self, radix: u32) -> u64 { unsafe { tsJson_getDatau64(self.this, radix) } }
	pub fn dataf32(&self) -> f32 { unsafe { tsJson_getDataf32(self.this) } }
	pub fn dataf64(&self) -> f64 { unsafe { tsJson_getDataf64(self.this) } }
	pub fn number(&self) -> string::String { unsafe { get_string(tsJson_getNumber(self.this)) } }
	pub fn string(&self) -> string::String { unsafe { get_string(tsJson_getString(self.this)) } }
	pub fn data_with_name(&self, name: &str, value: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csb(self.this, name_.as_ptr(), if value {1} else {0}) != 0 }
	}
	pub fn data_with_name_valuei32(&self, name: &str, value: i32) -> i32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csiu(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn data_with_name_valuei32_radix(&self, name: &str, value: i32, radix: u32) -> i32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csiu(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn data_with_name_valueu32(&self, name: &str, value: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csuu(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn data_with_name_valueu32_radix(&self, name: &str, value: u32, radix: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csuu(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn data_with_name_valueu64(&self, name: &str, value: u64) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csu64u(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn data_with_name_valueu64_radix(&self, name: &str, value: u64, radix: u32) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csu64u(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn data_with_name_valuef32(&self, name: &str, value: f32) -> f32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csf(self.this, name_.as_ptr(), value) }
	}
	pub fn data_with_name_valuef64(&self, name: &str, value: f64) -> f64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsJson_getData_csf64(self.this, name_.as_ptr(), value) }
	}
	pub fn data_with_name_values(&self, name: &str, value: &String) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsJson_getData_cscS(self.this, name_.as_ptr(), value.this)) }
	}
	pub fn set_data_with_valuessp(&mut self, values: &[&str], size: u32) {
		let mut values_ = Vec::new();
		let mut values__ = Vec::new();
		for it in values {
			values_.push(CString::new(*it).unwrap());
			values__.push(values_.last().unwrap().as_ptr());
		}
		unsafe { tsJson_setData_spu(self.this, values__.as_ptr(), size) }
	}
	pub fn set_data_with_valuess(&mut self, values: Option<&String>, size: u32) { unsafe { tsJson_setData_cSu(self.this, match values { Some(values) => &values.this, None => ptr::null() }, size) } }
	pub fn set_data_with_valuesi32(&mut self, values: *const i32, size: u32) { unsafe { tsJson_setData_ipuu(self.this, values, size, 10) } }
	pub fn set_data_with_valuesi32_radix(&mut self, values: *const i32, size: u32, radix: u32) { unsafe { tsJson_setData_ipuu(self.this, values, size, radix) } }
	pub fn set_data_with_valuesu32(&mut self, values: *const u32, size: u32) { unsafe { tsJson_setData_upuu(self.this, values, size, 10) } }
	pub fn set_data_with_valuesu32_radix(&mut self, values: *const u32, size: u32, radix: u32) { unsafe { tsJson_setData_upuu(self.this, values, size, radix) } }
	pub fn set_data_with_valuesf32(&mut self, values: *const f32, size: u32) { unsafe { tsJson_setData_fpuubb(self.this, values, size, 6, 1, 1) } }
	pub fn set_data_with_valuesf32_digits(&mut self, values: *const f32, size: u32, digits: u32) { unsafe { tsJson_setData_fpuubb(self.this, values, size, digits, 1, 1) } }
	pub fn set_data_with_valuesf32_digits_compact(&mut self, values: *const f32, size: u32, digits: u32, compact: bool) { unsafe { tsJson_setData_fpuubb(self.this, values, size, digits, if compact {1} else {0}, 1) } }
	pub fn set_data_with_valuesf32_digits_compact_exponent(&mut self, values: *const f32, size: u32, digits: u32, compact: bool, exponent: bool) { unsafe { tsJson_setData_fpuubb(self.this, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn set_data_with_valuesf64(&mut self, values: *const f64, size: u32) { unsafe { tsJson_setData_f64puubb(self.this, values, size, 12, 1, 1) } }
	pub fn set_data_with_valuesf64_digits(&mut self, values: *const f64, size: u32, digits: u32) { unsafe { tsJson_setData_f64puubb(self.this, values, size, digits, 1, 1) } }
	pub fn set_data_with_valuesf64_digits_compact(&mut self, values: *const f64, size: u32, digits: u32, compact: bool) { unsafe { tsJson_setData_f64puubb(self.this, values, size, digits, if compact {1} else {0}, 1) } }
	pub fn set_data_with_valuesf64_digits_compact_exponent(&mut self, values: *const f64, size: u32, digits: u32, compact: bool, exponent: bool) { unsafe { tsJson_setData_f64puubb(self.this, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn data_with_valuess(&self, values: Option<&String>, size: u32) -> u32 { unsafe { tsJson_getData_cSu(self.this, match values { Some(values) => &values.this, None => ptr::null() }, size) } }
	pub fn data_with_valuesi32(&self, values: *mut i32, size: u32) -> u32 { unsafe { tsJson_getData_ciruu(self.this, values, size, 10) } }
	pub fn data_with_valuesi32_radix(&self, values: *mut i32, size: u32, radix: u32) -> u32 { unsafe { tsJson_getData_ciruu(self.this, values, size, radix) } }
	pub fn data_with_valuesu32(&self, values: *mut u32, size: u32) -> u32 { unsafe { tsJson_getData_curuu(self.this, values, size, 10) } }
	pub fn data_with_valuesu32_radix(&self, values: *mut u32, size: u32, radix: u32) -> u32 { unsafe { tsJson_getData_curuu(self.this, values, size, radix) } }
	pub fn data_with_valuesf32(&self, values: *mut f32, size: u32) -> u32 { unsafe { tsJson_getData_cfru(self.this, values, size) } }
	pub fn data_with_valuesf64(&self, values: *mut f64, size: u32) -> u32 { unsafe { tsJson_getData_cf64ru(self.this, values, size) } }
}
impl Drop for Json {
	fn drop(&mut self) { if self.owner { unsafe { tsJson_delete(self.this) } } }
}
impl Clone for Json {
	fn clone(&self) -> Json { unsafe { Json { this: tsJson_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Json { }
impl fmt::Display for Json {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Json ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsJson_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsJson_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsJson_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsJson_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsJson_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsJson_new() -> *mut c_void;
	fn tsJson_new_JT(type_: JsonType) -> *mut c_void;
	fn tsJson_new_sJT(name: *const c_char, type_: JsonType) -> *mut c_void;
	fn tsJson_new_cSJT(name: *mut c_void, type_: JsonType) -> *mut c_void;
	fn tsJson_new_JsJT(parent: *const *mut c_void, name: *const c_char, type_: JsonType) -> *mut c_void;
	fn tsJson_new_JcSJT(parent: *const *mut c_void, name: *mut c_void, type_: JsonType) -> *mut c_void;
	fn tsJson_delete(this: *mut c_void);
	fn tsJson_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsJson_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsJson_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsJson_clearPtr(this: *const c_void);
	fn tsJson_destroyPtr(this: *const c_void);
	fn tsJson_acquirePtr(this: *const c_void);
	fn tsJson_unacquirePtr(this: *const c_void);
	fn tsJson_isValidPtr(this: *const c_void) -> i32;
	fn tsJson_isOwnerPtr(this: *const c_void) -> i32;
	fn tsJson_isConstPtr(this: *const c_void) -> i32;
	fn tsJson_getCountPtr(this: *const c_void) -> u32;
	fn tsJson_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsJson_clear(this: *mut c_void);
	fn tsJson_create_szb(this: *mut c_void, str: *const c_char, size: usize, owner: i32) -> i32;
	fn tsJson_create_cSzb(this: *mut c_void, str: *mut c_void, size: usize, owner: i32) -> i32;
	fn tsJson_load_s(this: *mut c_void, name: *const c_char) -> i32;
	fn tsJson_load_cS(this: *mut c_void, name: *mut c_void) -> i32;
	fn tsJson_load_St(this: *mut c_void, stream: *mut c_void) -> i32;
	fn tsJson_save_csb(this: *const c_void, name: *const c_char, compact: i32) -> i32;
	fn tsJson_save_ccSb(this: *const c_void, name: *mut c_void, compact: i32) -> i32;
	fn tsJson_save_cStb(this: *const c_void, stream: *mut c_void, compact: i32) -> i32;
	fn tsJson_getRoot_c(this: *const c_void) -> *mut c_void;
	fn tsJson_getRoot(this: *mut c_void) -> *mut c_void;
	fn tsJson_setParent(this: *mut c_void, parent: *mut c_void, check: i32) -> u32;
	fn tsJson_getParent_c(this: *const c_void) -> *mut c_void;
	fn tsJson_getParent(this: *mut c_void) -> *mut c_void;
	fn tsJson_addChild_sJTb(this: *mut c_void, name: *const c_char, type_: JsonType, check: i32) -> *mut c_void;
	fn tsJson_addChild_Jb(this: *mut c_void, child: *mut c_void, check: i32) -> u32;
	fn tsJson_removeChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsJson_releaseChildren(this: *mut c_void);
	fn tsJson_findChild(this: *const c_void, name: *const c_char) -> u32;
	fn tsJson_isChild(this: *const c_void, name: *const c_char) -> i32;
	fn tsJson_getChild_cs(this: *const c_void, name: *const c_char) -> *mut c_void;
	fn tsJson_getChild_s(this: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsJson_getNumChildren(this: *const c_void) -> u32;
	fn tsJson_getChild_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsJson_getChild_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsJson_getPathName(this: *const c_void) -> *mut c_void;
	fn tsJson_setName_s(this: *mut c_void, name: *const c_char);
	fn tsJson_setName_cS(this: *mut c_void, name: *mut c_void);
	fn tsJson_getName(this: *const c_void) -> *mut c_void;
	fn tsJson_setType(this: *mut c_void, type_: JsonType);
	fn tsJson_getType(this: *const c_void) -> JsonType;
	fn tsJson_getTypeName_JT(type_: JsonType) -> *const c_char;
	fn tsJson_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsJson_isUnknown(this: *const c_void) -> i32;
	fn tsJson_isNull(this: *const c_void) -> i32;
	fn tsJson_isBool(this: *const c_void) -> i32;
	fn tsJson_isNumber(this: *const c_void) -> i32;
	fn tsJson_isString(this: *const c_void) -> i32;
	fn tsJson_isObject(this: *const c_void) -> i32;
	fn tsJson_isArray(this: *const c_void) -> i32;
	fn tsJson_setData_b(this: *mut c_void, value: i32);
	fn tsJson_setData_iu(this: *mut c_void, value: i32, radix: u32);
	fn tsJson_setData_uu(this: *mut c_void, value: u32, radix: u32);
	fn tsJson_setData_u64u(this: *mut c_void, value: u64, radix: u32);
	fn tsJson_setData_fubb(this: *mut c_void, value: f32, digits: u32, compact: i32, exponent: i32);
	fn tsJson_setData_f64ubb(this: *mut c_void, value: f64, digits: u32, compact: i32, exponent: i32);
	fn tsJson_setData_s(this: *mut c_void, value: *const c_char);
	fn tsJson_setData_cS(this: *mut c_void, value: *mut c_void);
	fn tsJson_getData_c(this: *const c_void) -> *mut c_void;
	fn tsJson_getDataBool(this: *const c_void) -> i32;
	fn tsJson_getDatai32(this: *const c_void, radix: u32) -> i32;
	fn tsJson_getDatau32(this: *const c_void, radix: u32) -> u32;
	fn tsJson_getDatau64(this: *const c_void, radix: u32) -> u64;
	fn tsJson_getDataf32(this: *const c_void) -> f32;
	fn tsJson_getDataf64(this: *const c_void) -> f64;
	fn tsJson_getNumber(this: *const c_void) -> *mut c_void;
	fn tsJson_getString(this: *const c_void) -> *mut c_void;
	fn tsJson_getData_csb(this: *const c_void, name: *const c_char, value: i32) -> i32;
	fn tsJson_getData_csiu(this: *const c_void, name: *const c_char, value: i32, radix: u32) -> i32;
	fn tsJson_getData_csuu(this: *const c_void, name: *const c_char, value: u32, radix: u32) -> u32;
	fn tsJson_getData_csu64u(this: *const c_void, name: *const c_char, value: u64, radix: u32) -> u64;
	fn tsJson_getData_csf(this: *const c_void, name: *const c_char, value: f32) -> f32;
	fn tsJson_getData_csf64(this: *const c_void, name: *const c_char, value: f64) -> f64;
	fn tsJson_getData_cscS(this: *const c_void, name: *const c_char, value: *mut c_void) -> *mut c_void;
	fn tsJson_setData_spu(this: *mut c_void, values: *const *const c_char, size: u32);
	fn tsJson_setData_cSu(this: *mut c_void, values: *const *mut c_void, size: u32);
	fn tsJson_setData_ipuu(this: *mut c_void, values: *const i32, size: u32, radix: u32);
	fn tsJson_setData_upuu(this: *mut c_void, values: *const u32, size: u32, radix: u32);
	fn tsJson_setData_fpuubb(this: *mut c_void, values: *const f32, size: u32, digits: u32, compact: i32, exponent: i32);
	fn tsJson_setData_f64puubb(this: *mut c_void, values: *const f64, size: u32, digits: u32, compact: i32, exponent: i32);
	fn tsJson_getData_cSu(this: *const c_void, values: *const *mut c_void, size: u32) -> u32;
	fn tsJson_getData_ciruu(this: *const c_void, values: *mut i32, size: u32, radix: u32) -> u32;
	fn tsJson_getData_curuu(this: *const c_void, values: *mut u32, size: u32, radix: u32) -> u32;
	fn tsJson_getData_cfru(this: *const c_void, values: *mut f32, size: u32) -> u32;
	fn tsJson_getData_cf64ru(this: *const c_void, values: *mut f64, size: u32) -> u32;
}

// Tellusim::Xml
pub struct Xml {
	this: *mut c_void,
	owner: bool,
}
impl Xml {
	pub fn null() -> Xml { Xml { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Xml { unsafe { Xml { this: tsXml_new(), owner: true } } }
	pub fn new_with_name(name: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		unsafe { Xml { this: tsXml_new_ss(name_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_name_attributes(name: &str, attributes: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		let attributes_ = CString::new(attributes).unwrap();
		unsafe { Xml { this: tsXml_new_ss(name_.as_ptr(), attributes_.as_ptr()), owner: true } }
	}
	pub fn new_with_names(name: &String) -> Xml { unsafe { Xml { this: tsXml_new_cSs(name.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_names_attributes(name: &String, attributes: &str) -> Xml {
		let attributes_ = CString::new(attributes).unwrap();
		unsafe { Xml { this: tsXml_new_cSs(name.this, attributes_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent(parent: Option<&Xml>, name: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		unsafe { Xml { this: tsXml_new_Xss(match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_parent_attributes(parent: Option<&Xml>, name: &str, attributes: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		let attributes_ = CString::new(attributes).unwrap();
		unsafe { Xml { this: tsXml_new_Xss(match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr(), attributes_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_name(parent: Option<&Xml>, name: &String) -> Xml { unsafe { Xml { this: tsXml_new_XcSs(match parent { Some(parent) => &parent.this, None => ptr::null() }, name.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_parent_name_attributes(parent: Option<&Xml>, name: &String, attributes: &str) -> Xml {
		let attributes_ = CString::new(attributes).unwrap();
		unsafe { Xml { this: tsXml_new_XcSs(match parent { Some(parent) => &parent.this, None => ptr::null() }, name.this, attributes_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> Xml { unsafe { Xml { this: ptr, owner: tsXml_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Xml { unsafe { Xml { this: tsXml_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Xml) -> bool { unsafe { tsXml_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Xml { unsafe { Xml { this: tsXml_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsXml_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsXml_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsXml_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsXml_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsXml_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsXml_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsXml_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsXml_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsXml_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsXml_clear(self.this) } }
	pub fn create(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsXml_create_szb(self.this, str_.as_ptr(), 0, 0) != 0 }
	}
	pub fn create_with_size(&mut self, str: &str, size: usize) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsXml_create_szb(self.this, str_.as_ptr(), size, 0) != 0 }
	}
	pub fn create_with_size_owner(&mut self, str: &str, size: usize, owner: bool) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsXml_create_szb(self.this, str_.as_ptr(), size, if owner {1} else {0}) != 0 }
	}
	pub fn create_with_str(&mut self, str: &String) -> bool { unsafe { tsXml_create_cSzb(self.this, str.this, 0, 0) != 0 } }
	pub fn create_with_str_size(&mut self, str: &String, size: usize) -> bool { unsafe { tsXml_create_cSzb(self.this, str.this, size, 0) != 0 } }
	pub fn create_with_str_size_owner(&mut self, str: &String, size: usize, owner: bool) -> bool { unsafe { tsXml_create_cSzb(self.this, str.this, size, if owner {1} else {0}) != 0 } }
	pub fn load(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_load_s(self.this, name_.as_ptr()) != 0 }
	}
	pub fn load_with_name(&mut self, name: &String) -> bool { unsafe { tsXml_load_cS(self.this, name.this) != 0 } }
	pub fn load_with_stream(&mut self, stream: &mut Stream) -> bool { unsafe { tsXml_load_St(self.this, stream.this) != 0 } }
	pub fn save(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_save_csb(self.this, name_.as_ptr(), 0) != 0 }
	}
	pub fn save_with_compact(&self, name: &str, compact: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_save_csb(self.this, name_.as_ptr(), if compact {1} else {0}) != 0 }
	}
	pub fn save_with_name(&self, name: &String) -> bool { unsafe { tsXml_save_ccSb(self.this, name.this, 0) != 0 } }
	pub fn save_with_name_compact(&self, name: &String, compact: bool) -> bool { unsafe { tsXml_save_ccSb(self.this, name.this, if compact {1} else {0}) != 0 } }
	pub fn save_with_stream(&self, stream: &mut Stream) -> bool { unsafe { tsXml_save_cStb(self.this, stream.this, 0) != 0 } }
	pub fn save_with_stream_compact(&self, stream: &mut Stream, compact: bool) -> bool { unsafe { tsXml_save_cStb(self.this, stream.this, if compact {1} else {0}) != 0 } }
	pub fn root(&self) -> Xml { unsafe { Xml::new_ptr(tsXml_getRoot_c(self.this)) } }
	pub fn root_mut(&mut self) -> Xml { unsafe { Xml::new_ptr(tsXml_getRoot(self.this)) } }
	pub fn set_parent(&mut self, parent: &mut Xml) -> u32 { unsafe { tsXml_setParent(self.this, parent.this, 1) } }
	pub fn set_parent_with_check(&mut self, parent: &mut Xml, check: bool) -> u32 { unsafe { tsXml_setParent(self.this, parent.this, if check {1} else {0}) } }
	pub fn parent(&self) -> Xml { unsafe { Xml::new_ptr(tsXml_getParent_c(self.this)) } }
	pub fn parent_mut(&mut self) -> Xml { unsafe { Xml::new_ptr(tsXml_getParent(self.this)) } }
	pub fn add_child(&mut self, name: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		unsafe { Xml::new_ptr(tsXml_addChild_sb(self.this, name_.as_ptr(), 1)) }
	}
	pub fn add_child_with_check(&mut self, name: &str, check: bool) -> Xml {
		let name_ = CString::new(name).unwrap();
		unsafe { Xml::new_ptr(tsXml_addChild_sb(self.this, name_.as_ptr(), if check {1} else {0})) }
	}
	pub fn add_child_with_child(&mut self, child: &mut Xml) -> u32 { unsafe { tsXml_addChild_Xb(self.this, child.this, 1) } }
	pub fn add_child_with_child_check(&mut self, child: &mut Xml, check: bool) -> u32 { unsafe { tsXml_addChild_Xb(self.this, child.this, if check {1} else {0}) } }
	pub fn remove_child(&mut self, child: &mut Xml) -> bool { unsafe { tsXml_removeChild(self.this, child.this) != 0 } }
	pub fn release_children(&mut self) { unsafe { tsXml_releaseChildren(self.this) } }
	pub fn find_child(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_findChild(self.this, name_.as_ptr()) }
	}
	pub fn is_child(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_isChild(self.this, name_.as_ptr()) != 0 }
	}
	pub fn child(&self, name: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		unsafe { Xml::new_ptr(tsXml_getChild_cs(self.this, name_.as_ptr())) }
	}
	pub fn child_mut(&mut self, name: &str) -> Xml {
		let name_ = CString::new(name).unwrap();
		unsafe { Xml::new_ptr(tsXml_getChild_s(self.this, name_.as_ptr())) }
	}
	pub fn num_children(&self) -> u32 { unsafe { tsXml_getNumChildren(self.this) } }
	pub fn child_with_index(&self, index: u32) -> Xml { unsafe { Xml::new_ptr(tsXml_getChild_cu(self.this, index)) } }
	pub fn child_mut_with_index(&mut self, index: u32) -> Xml { unsafe { Xml::new_ptr(tsXml_getChild_u(self.this, index)) } }
	pub fn path_name(&self) -> string::String { unsafe { get_string(tsXml_getPathName(self.this)) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_setName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_name_with_name(&mut self, name: &String) { unsafe { tsXml_setName_cS(self.this, name.this) } }
	pub fn name(&self) -> string::String { unsafe { get_string(tsXml_getName(self.this)) } }
	pub fn set_data_with_valueb(&mut self, value: bool) { unsafe { tsXml_setData_b(self.this, if value {1} else {0}) } }
	pub fn set_data_with_value(&mut self, value: &str) {
		let value_ = CString::new(value).unwrap();
		unsafe { tsXml_setData_s(self.this, value_.as_ptr()) }
	}
	pub fn set_data_with_values(&mut self, value: &String) { unsafe { tsXml_setData_cS(self.this, value.this) } }
	pub fn set_data_with_valuei32(&mut self, value: i32) { unsafe { tsXml_setData_iu(self.this, value, 10) } }
	pub fn set_data_with_valuei32_radix(&mut self, value: i32, radix: u32) { unsafe { tsXml_setData_iu(self.this, value, radix) } }
	pub fn set_data_with_valueu32(&mut self, value: u32) { unsafe { tsXml_setData_uu(self.this, value, 10) } }
	pub fn set_data_with_valueu32_radix(&mut self, value: u32, radix: u32) { unsafe { tsXml_setData_uu(self.this, value, radix) } }
	pub fn set_data_with_valueu64(&mut self, value: u64) { unsafe { tsXml_setData_u64u(self.this, value, 10) } }
	pub fn set_data_with_valueu64_radix(&mut self, value: u64, radix: u32) { unsafe { tsXml_setData_u64u(self.this, value, radix) } }
	pub fn set_data_with_valuef32(&mut self, value: f32) { unsafe { tsXml_setData_fubb(self.this, value, 6, 1, 1) } }
	pub fn set_data_with_valuef32_digits(&mut self, value: f32, digits: u32) { unsafe { tsXml_setData_fubb(self.this, value, digits, 1, 1) } }
	pub fn set_data_with_valuef32_digits_compact(&mut self, value: f32, digits: u32, compact: bool) { unsafe { tsXml_setData_fubb(self.this, value, digits, if compact {1} else {0}, 1) } }
	pub fn set_data_with_valuef32_digits_compact_exponent(&mut self, value: f32, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setData_fubb(self.this, value, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn set_data_with_valuef64(&mut self, value: f64) { unsafe { tsXml_setData_f64ubb(self.this, value, 12, 1, 1) } }
	pub fn set_data_with_valuef64_digits(&mut self, value: f64, digits: u32) { unsafe { tsXml_setData_f64ubb(self.this, value, digits, 1, 1) } }
	pub fn set_data_with_valuef64_digits_compact(&mut self, value: f64, digits: u32, compact: bool) { unsafe { tsXml_setData_f64ubb(self.this, value, digits, if compact {1} else {0}, 1) } }
	pub fn set_data_with_valuef64_digits_compact_exponent(&mut self, value: f64, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setData_f64ubb(self.this, value, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn data(&self) -> string::String { unsafe { get_string(tsXml_getData_c(self.this)) } }
	pub fn data_bool(&self) -> bool { unsafe { tsXml_getDataBool(self.this) != 0 } }
	pub fn datai32(&self) -> i32 { unsafe { tsXml_getDatai32(self.this, 10) } }
	pub fn datai32_with_radix(&self, radix: u32) -> i32 { unsafe { tsXml_getDatai32(self.this, radix) } }
	pub fn datau32(&self) -> u32 { unsafe { tsXml_getDatau32(self.this, 10) } }
	pub fn datau32_with_radix(&self, radix: u32) -> u32 { unsafe { tsXml_getDatau32(self.this, radix) } }
	pub fn datau64(&self) -> u64 { unsafe { tsXml_getDatau64(self.this, 10) } }
	pub fn datau64_with_radix(&self, radix: u32) -> u64 { unsafe { tsXml_getDatau64(self.this, radix) } }
	pub fn dataf32(&self) -> f32 { unsafe { tsXml_getDataf32(self.this) } }
	pub fn dataf64(&self) -> f64 { unsafe { tsXml_getDataf64(self.this) } }
	pub fn data_with_name(&self, name: &str) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsXml_getData_cscS(self.this, name_.as_ptr(), ptr::null_mut())) }
	}
	pub fn data_with_name_value(&self, name: &str, value: &String) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsXml_getData_cscS(self.this, name_.as_ptr(), value.this)) }
	}
	pub fn data_with_name_valueb(&self, name: &str, value: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csb(self.this, name_.as_ptr(), if value {1} else {0}) != 0 }
	}
	pub fn data_with_name_valuei32(&self, name: &str, value: i32) -> i32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csiu(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn data_with_name_valuei32_radix(&self, name: &str, value: i32, radix: u32) -> i32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csiu(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn data_with_name_valueu32(&self, name: &str, value: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csuu(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn data_with_name_valueu32_radix(&self, name: &str, value: u32, radix: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csuu(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn data_with_name_valueu64(&self, name: &str, value: u64) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csu64u(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn data_with_name_valueu64_radix(&self, name: &str, value: u64, radix: u32) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csu64u(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn data_with_name_valuef32(&self, name: &str, value: f32) -> f32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csf(self.this, name_.as_ptr(), value) }
	}
	pub fn data_with_name_valuef64(&self, name: &str, value: f64) -> f64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getData_csf64(self.this, name_.as_ptr(), value) }
	}
	pub fn set_data_with_valuessp(&mut self, values: &[&str], size: u32) {
		let mut values_ = Vec::new();
		let mut values__ = Vec::new();
		for it in values {
			values_.push(CString::new(*it).unwrap());
			values__.push(values_.last().unwrap().as_ptr());
		}
		unsafe { tsXml_setData_spuu(self.this, values__.as_ptr(), size, MAXU32) }
	}
	pub fn set_data_with_valuessp_wrap(&mut self, values: &[&str], size: u32, wrap: u32) {
		let mut values_ = Vec::new();
		let mut values__ = Vec::new();
		for it in values {
			values_.push(CString::new(*it).unwrap());
			values__.push(values_.last().unwrap().as_ptr());
		}
		unsafe { tsXml_setData_spuu(self.this, values__.as_ptr(), size, wrap) }
	}
	pub fn set_data_with_valuess(&mut self, values: Option<&String>, size: u32) { unsafe { tsXml_setData_cSuu(self.this, match values { Some(values) => &values.this, None => ptr::null() }, size, MAXU32) } }
	pub fn set_data_with_valuess_wrap(&mut self, values: Option<&String>, size: u32, wrap: u32) { unsafe { tsXml_setData_cSuu(self.this, match values { Some(values) => &values.this, None => ptr::null() }, size, wrap) } }
	pub fn set_data_with_valuesi32(&mut self, values: *const i32, size: u32) { unsafe { tsXml_setData_ipuuu(self.this, values, size, 10, MAXU32) } }
	pub fn set_data_with_valuesi32_radix(&mut self, values: *const i32, size: u32, radix: u32) { unsafe { tsXml_setData_ipuuu(self.this, values, size, radix, MAXU32) } }
	pub fn set_data_with_valuesi32_radix_wrap(&mut self, values: *const i32, size: u32, radix: u32, wrap: u32) { unsafe { tsXml_setData_ipuuu(self.this, values, size, radix, wrap) } }
	pub fn set_data_with_valuesu32(&mut self, values: *const u32, size: u32) { unsafe { tsXml_setData_upuuu(self.this, values, size, 10, MAXU32) } }
	pub fn set_data_with_valuesu32_radix(&mut self, values: *const u32, size: u32, radix: u32) { unsafe { tsXml_setData_upuuu(self.this, values, size, radix, MAXU32) } }
	pub fn set_data_with_valuesu32_radix_wrap(&mut self, values: *const u32, size: u32, radix: u32, wrap: u32) { unsafe { tsXml_setData_upuuu(self.this, values, size, radix, wrap) } }
	pub fn set_data_with_valuesf32(&mut self, values: *const f32, size: u32) { unsafe { tsXml_setData_fpuubbu(self.this, values, size, 6, 1, 1, MAXU32) } }
	pub fn set_data_with_valuesf32_digits(&mut self, values: *const f32, size: u32, digits: u32) { unsafe { tsXml_setData_fpuubbu(self.this, values, size, digits, 1, 1, MAXU32) } }
	pub fn set_data_with_valuesf32_digits_compact(&mut self, values: *const f32, size: u32, digits: u32, compact: bool) { unsafe { tsXml_setData_fpuubbu(self.this, values, size, digits, if compact {1} else {0}, 1, MAXU32) } }
	pub fn set_data_with_valuesf32_digits_compact_exponent(&mut self, values: *const f32, size: u32, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setData_fpuubbu(self.this, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}, MAXU32) } }
	pub fn set_data_with_valuesf32_digits_compact_exponent_wrap(&mut self, values: *const f32, size: u32, digits: u32, compact: bool, exponent: bool, wrap: u32) { unsafe { tsXml_setData_fpuubbu(self.this, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}, wrap) } }
	pub fn set_data_with_valuesf64(&mut self, values: *const f64, size: u32) { unsafe { tsXml_setData_f64puubbu(self.this, values, size, 12, 1, 1, MAXU32) } }
	pub fn set_data_with_valuesf64_digits(&mut self, values: *const f64, size: u32, digits: u32) { unsafe { tsXml_setData_f64puubbu(self.this, values, size, digits, 1, 1, MAXU32) } }
	pub fn set_data_with_valuesf64_digits_compact(&mut self, values: *const f64, size: u32, digits: u32, compact: bool) { unsafe { tsXml_setData_f64puubbu(self.this, values, size, digits, if compact {1} else {0}, 1, MAXU32) } }
	pub fn set_data_with_valuesf64_digits_compact_exponent(&mut self, values: *const f64, size: u32, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setData_f64puubbu(self.this, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}, MAXU32) } }
	pub fn set_data_with_valuesf64_digits_compact_exponent_wrap(&mut self, values: *const f64, size: u32, digits: u32, compact: bool, exponent: bool, wrap: u32) { unsafe { tsXml_setData_f64puubbu(self.this, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}, wrap) } }
	pub fn data_with_valuess(&self, values: Option<&String>, size: u32) -> u32 { unsafe { tsXml_getData_cSu(self.this, match values { Some(values) => &values.this, None => ptr::null() }, size) } }
	pub fn data_with_valuesi32(&self, values: *mut i32, size: u32) -> u32 { unsafe { tsXml_getData_ciruu(self.this, values, size, 10) } }
	pub fn data_with_valuesi32_radix(&self, values: *mut i32, size: u32, radix: u32) -> u32 { unsafe { tsXml_getData_ciruu(self.this, values, size, radix) } }
	pub fn data_with_valuesu32(&self, values: *mut u32, size: u32) -> u32 { unsafe { tsXml_getData_curuu(self.this, values, size, 10) } }
	pub fn data_with_valuesu32_radix(&self, values: *mut u32, size: u32, radix: u32) -> u32 { unsafe { tsXml_getData_curuu(self.this, values, size, radix) } }
	pub fn data_with_valuesf32(&self, values: *mut f32, size: u32) -> u32 { unsafe { tsXml_getData_cfru(self.this, values, size) } }
	pub fn data_with_valuesf64(&self, values: *mut f64, size: u32) -> u32 { unsafe { tsXml_getData_cf64ru(self.this, values, size) } }
	pub fn add_attribute(&mut self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_addAttribute(self.this, name_.as_ptr()) }
	}
	pub fn remove_attribute(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_removeAttribute(self.this, name_.as_ptr()) != 0 }
	}
	pub fn find_attribute(&self, name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_findAttribute(self.this, name_.as_ptr()) }
	}
	pub fn is_attribute(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_isAttribute(self.this, name_.as_ptr()) != 0 }
	}
	pub fn remove_attributes(&mut self) { unsafe { tsXml_removeAttributes(self.this) } }
	pub fn num_attributes(&self) -> u32 { unsafe { tsXml_getNumAttributes(self.this) } }
	pub fn attribute_name(&self, index: u32) -> string::String { unsafe { get_string(tsXml_getAttributeName(self.this, index)) } }
	pub fn set_attributes(&mut self, str: &str) -> bool {
		let str_ = CString::new(str).unwrap();
		unsafe { tsXml_setAttributes(self.this, str_.as_ptr()) != 0 }
	}
	pub fn set_attribute_with_valueb(&mut self, index: u32, value: bool) { unsafe { tsXml_setAttribute_ub(self.this, index, if value {1} else {0}) } }
	pub fn set_attribute_with_value(&mut self, index: u32, value: &str) {
		let value_ = CString::new(value).unwrap();
		unsafe { tsXml_setAttribute_us(self.this, index, value_.as_ptr()) }
	}
	pub fn set_attribute_with_values(&mut self, index: u32, value: &String) { unsafe { tsXml_setAttribute_ucS(self.this, index, value.this) } }
	pub fn set_attribute_with_valuei32(&mut self, index: u32, value: i32) { unsafe { tsXml_setAttribute_uiu(self.this, index, value, 10) } }
	pub fn set_attribute_with_valuei32_radix(&mut self, index: u32, value: i32, radix: u32) { unsafe { tsXml_setAttribute_uiu(self.this, index, value, radix) } }
	pub fn set_attribute_with_valueu32(&mut self, index: u32, value: u32) { unsafe { tsXml_setAttribute_uuu(self.this, index, value, 10) } }
	pub fn set_attribute_with_valueu32_radix(&mut self, index: u32, value: u32, radix: u32) { unsafe { tsXml_setAttribute_uuu(self.this, index, value, radix) } }
	pub fn set_attribute_with_valueu64(&mut self, index: u32, value: u64) { unsafe { tsXml_setAttribute_uu64u(self.this, index, value, 10) } }
	pub fn set_attribute_with_valueu64_radix(&mut self, index: u32, value: u64, radix: u32) { unsafe { tsXml_setAttribute_uu64u(self.this, index, value, radix) } }
	pub fn set_attribute_with_valuef32(&mut self, index: u32, value: f32) { unsafe { tsXml_setAttribute_ufubb(self.this, index, value, 6, 1, 1) } }
	pub fn set_attribute_with_valuef32_digits(&mut self, index: u32, value: f32, digits: u32) { unsafe { tsXml_setAttribute_ufubb(self.this, index, value, digits, 1, 1) } }
	pub fn set_attribute_with_valuef32_digits_compact(&mut self, index: u32, value: f32, digits: u32, compact: bool) { unsafe { tsXml_setAttribute_ufubb(self.this, index, value, digits, if compact {1} else {0}, 1) } }
	pub fn set_attribute_with_valuef32_digits_compact_exponent(&mut self, index: u32, value: f32, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setAttribute_ufubb(self.this, index, value, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn set_attribute_with_valuef64(&mut self, index: u32, value: f64) { unsafe { tsXml_setAttribute_uf64ubb(self.this, index, value, 12, 1, 1) } }
	pub fn set_attribute_with_valuef64_digits(&mut self, index: u32, value: f64, digits: u32) { unsafe { tsXml_setAttribute_uf64ubb(self.this, index, value, digits, 1, 1) } }
	pub fn set_attribute_with_valuef64_digits_compact(&mut self, index: u32, value: f64, digits: u32, compact: bool) { unsafe { tsXml_setAttribute_uf64ubb(self.this, index, value, digits, if compact {1} else {0}, 1) } }
	pub fn set_attribute_with_valuef64_digits_compact_exponent(&mut self, index: u32, value: f64, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setAttribute_uf64ubb(self.this, index, value, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn attribute_with_index(&self, index: u32) -> string::String { unsafe { get_string(tsXml_getAttribute_cu(self.this, index)) } }
	pub fn attributei32(&self, index: u32) -> i32 { unsafe { tsXml_getAttributei32(self.this, index, 10) } }
	pub fn attributei32_with_radix(&self, index: u32, radix: u32) -> i32 { unsafe { tsXml_getAttributei32(self.this, index, radix) } }
	pub fn attributeu32(&self, index: u32) -> u32 { unsafe { tsXml_getAttributeu32(self.this, index, 10) } }
	pub fn attributeu32_with_radix(&self, index: u32, radix: u32) -> u32 { unsafe { tsXml_getAttributeu32(self.this, index, radix) } }
	pub fn attributeu64(&self, index: u32) -> u64 { unsafe { tsXml_getAttributeu64(self.this, index, 10) } }
	pub fn attributeu64_with_radix(&self, index: u32, radix: u32) -> u64 { unsafe { tsXml_getAttributeu64(self.this, index, radix) } }
	pub fn attributef32(&self, index: u32) -> f32 { unsafe { tsXml_getAttributef32(self.this, index) } }
	pub fn attributef64(&self, index: u32) -> f64 { unsafe { tsXml_getAttributef64(self.this, index) } }
	pub fn attribute_with_name(&self, name: &str) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsXml_getAttribute_cscS(self.this, name_.as_ptr(), ptr::null_mut())) }
	}
	pub fn attribute_with_name_value(&self, name: &str, value: &String) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsXml_getAttribute_cscS(self.this, name_.as_ptr(), value.this)) }
	}
	pub fn attribute_with_name_valueb(&self, name: &str, value: bool) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csb(self.this, name_.as_ptr(), if value {1} else {0}) != 0 }
	}
	pub fn attribute_with_name_valuei32(&self, name: &str, value: i32) -> i32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csiu(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn attribute_with_name_valuei32_radix(&self, name: &str, value: i32, radix: u32) -> i32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csiu(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn attribute_with_name_valueu32(&self, name: &str, value: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csuu(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn attribute_with_name_valueu32_radix(&self, name: &str, value: u32, radix: u32) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csuu(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn attribute_with_name_valueu64(&self, name: &str, value: u64) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csu64u(self.this, name_.as_ptr(), value, 10) }
	}
	pub fn attribute_with_name_valueu64_radix(&self, name: &str, value: u64, radix: u32) -> u64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csu64u(self.this, name_.as_ptr(), value, radix) }
	}
	pub fn attribute_with_name_valuef32(&self, name: &str, value: f32) -> f32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csf(self.this, name_.as_ptr(), value) }
	}
	pub fn attribute_with_name_valuef64(&self, name: &str, value: f64) -> f64 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsXml_getAttribute_csf64(self.this, name_.as_ptr(), value) }
	}
	pub fn set_attribute_with_valuessp(&mut self, index: u32, values: &[&str], size: u32) {
		let mut values_ = Vec::new();
		let mut values__ = Vec::new();
		for it in values {
			values_.push(CString::new(*it).unwrap());
			values__.push(values_.last().unwrap().as_ptr());
		}
		unsafe { tsXml_setAttribute_uspus(self.this, index, values__.as_ptr(), size, ptr::null_mut()) }
	}
	pub fn set_attribute_with_valuessp_delimiter(&mut self, index: u32, values: &[&str], size: u32, delimiter: &str) {
		let mut values_ = Vec::new();
		let mut values__ = Vec::new();
		for it in values {
			values_.push(CString::new(*it).unwrap());
			values__.push(values_.last().unwrap().as_ptr());
		}
		let delimiter_ = CString::new(delimiter).unwrap();
		unsafe { tsXml_setAttribute_uspus(self.this, index, values__.as_ptr(), size, delimiter_.as_ptr()) }
	}
	pub fn set_attribute_with_valuess(&mut self, index: u32, values: Option<&String>, size: u32) { unsafe { tsXml_setAttribute_ucSus(self.this, index, match values { Some(values) => &values.this, None => ptr::null() }, size, ptr::null_mut()) } }
	pub fn set_attribute_with_valuess_delimiter(&mut self, index: u32, values: Option<&String>, size: u32, delimiter: &str) {
		let delimiter_ = CString::new(delimiter).unwrap();
		unsafe { tsXml_setAttribute_ucSus(self.this, index, match values { Some(values) => &values.this, None => ptr::null() }, size, delimiter_.as_ptr()) }
	}
	pub fn set_attribute_with_valuesi32(&mut self, index: u32, values: *const i32, size: u32) { unsafe { tsXml_setAttribute_uipuu(self.this, index, values, size, 10) } }
	pub fn set_attribute_with_valuesi32_radix(&mut self, index: u32, values: *const i32, size: u32, radix: u32) { unsafe { tsXml_setAttribute_uipuu(self.this, index, values, size, radix) } }
	pub fn set_attribute_with_valuesu32(&mut self, index: u32, values: *const u32, size: u32) { unsafe { tsXml_setAttribute_uupuu(self.this, index, values, size, 10) } }
	pub fn set_attribute_with_valuesu32_radix(&mut self, index: u32, values: *const u32, size: u32, radix: u32) { unsafe { tsXml_setAttribute_uupuu(self.this, index, values, size, radix) } }
	pub fn set_attribute_with_valuesf32(&mut self, index: u32, values: *const f32, size: u32) { unsafe { tsXml_setAttribute_ufpuubb(self.this, index, values, size, 6, 1, 1) } }
	pub fn set_attribute_with_valuesf32_digits(&mut self, index: u32, values: *const f32, size: u32, digits: u32) { unsafe { tsXml_setAttribute_ufpuubb(self.this, index, values, size, digits, 1, 1) } }
	pub fn set_attribute_with_valuesf32_digits_compact(&mut self, index: u32, values: *const f32, size: u32, digits: u32, compact: bool) { unsafe { tsXml_setAttribute_ufpuubb(self.this, index, values, size, digits, if compact {1} else {0}, 1) } }
	pub fn set_attribute_with_valuesf32_digits_compact_exponent(&mut self, index: u32, values: *const f32, size: u32, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setAttribute_ufpuubb(self.this, index, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn set_attribute_with_valuesf64(&mut self, index: u32, values: *const f64, size: u32) { unsafe { tsXml_setAttribute_uf64puubb(self.this, index, values, size, 12, 1, 1) } }
	pub fn set_attribute_with_valuesf64_digits(&mut self, index: u32, values: *const f64, size: u32, digits: u32) { unsafe { tsXml_setAttribute_uf64puubb(self.this, index, values, size, digits, 1, 1) } }
	pub fn set_attribute_with_valuesf64_digits_compact(&mut self, index: u32, values: *const f64, size: u32, digits: u32, compact: bool) { unsafe { tsXml_setAttribute_uf64puubb(self.this, index, values, size, digits, if compact {1} else {0}, 1) } }
	pub fn set_attribute_with_valuesf64_digits_compact_exponent(&mut self, index: u32, values: *const f64, size: u32, digits: u32, compact: bool, exponent: bool) { unsafe { tsXml_setAttribute_uf64puubb(self.this, index, values, size, digits, if compact {1} else {0}, if exponent {1} else {0}) } }
	pub fn attribute_with_index_valuess(&self, index: u32, values: Option<&String>, size: u32) -> u32 { unsafe { tsXml_getAttribute_cuSus(self.this, index, match values { Some(values) => &values.this, None => ptr::null() }, size, ptr::null_mut()) } }
	pub fn attribute_with_index_valuess_delimiter(&self, index: u32, values: Option<&String>, size: u32, delimiter: &str) -> u32 {
		let delimiter_ = CString::new(delimiter).unwrap();
		unsafe { tsXml_getAttribute_cuSus(self.this, index, match values { Some(values) => &values.this, None => ptr::null() }, size, delimiter_.as_ptr()) }
	}
	pub fn attribute_with_index_valuesi32(&self, index: u32, values: *mut i32, size: u32) -> u32 { unsafe { tsXml_getAttribute_cuiruu(self.this, index, values, size, 10) } }
	pub fn attribute_with_index_valuesi32_radix(&self, index: u32, values: *mut i32, size: u32, radix: u32) -> u32 { unsafe { tsXml_getAttribute_cuiruu(self.this, index, values, size, radix) } }
	pub fn attribute_with_index_valuesu32(&self, index: u32, values: *mut u32, size: u32) -> u32 { unsafe { tsXml_getAttribute_cuuruu(self.this, index, values, size, 10) } }
	pub fn attribute_with_index_valuesu32_radix(&self, index: u32, values: *mut u32, size: u32, radix: u32) -> u32 { unsafe { tsXml_getAttribute_cuuruu(self.this, index, values, size, radix) } }
	pub fn attribute_with_index_valuesf32(&self, index: u32, values: *mut f32, size: u32) -> u32 { unsafe { tsXml_getAttribute_cufru(self.this, index, values, size) } }
	pub fn attribute_with_index_valuesf64(&self, index: u32, values: *mut f64, size: u32) -> u32 { unsafe { tsXml_getAttribute_cuf64ru(self.this, index, values, size) } }
}
impl Drop for Xml {
	fn drop(&mut self) { if self.owner { unsafe { tsXml_delete(self.this) } } }
}
impl Clone for Xml {
	fn clone(&self) -> Xml { unsafe { Xml { this: tsXml_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Xml { }
impl fmt::Display for Xml {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Xml ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsXml_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsXml_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsXml_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsXml_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsXml_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsXml_new() -> *mut c_void;
	fn tsXml_new_ss(name: *const c_char, attributes: *const c_char) -> *mut c_void;
	fn tsXml_new_cSs(name: *mut c_void, attributes: *const c_char) -> *mut c_void;
	fn tsXml_new_Xss(parent: *const *mut c_void, name: *const c_char, attributes: *const c_char) -> *mut c_void;
	fn tsXml_new_XcSs(parent: *const *mut c_void, name: *mut c_void, attributes: *const c_char) -> *mut c_void;
	fn tsXml_delete(this: *mut c_void);
	fn tsXml_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsXml_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsXml_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsXml_clearPtr(this: *const c_void);
	fn tsXml_destroyPtr(this: *const c_void);
	fn tsXml_acquirePtr(this: *const c_void);
	fn tsXml_unacquirePtr(this: *const c_void);
	fn tsXml_isValidPtr(this: *const c_void) -> i32;
	fn tsXml_isOwnerPtr(this: *const c_void) -> i32;
	fn tsXml_isConstPtr(this: *const c_void) -> i32;
	fn tsXml_getCountPtr(this: *const c_void) -> u32;
	fn tsXml_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsXml_clear(this: *mut c_void);
	fn tsXml_create_szb(this: *mut c_void, str: *const c_char, size: usize, owner: i32) -> i32;
	fn tsXml_create_cSzb(this: *mut c_void, str: *mut c_void, size: usize, owner: i32) -> i32;
	fn tsXml_load_s(this: *mut c_void, name: *const c_char) -> i32;
	fn tsXml_load_cS(this: *mut c_void, name: *mut c_void) -> i32;
	fn tsXml_load_St(this: *mut c_void, stream: *mut c_void) -> i32;
	fn tsXml_save_csb(this: *const c_void, name: *const c_char, compact: i32) -> i32;
	fn tsXml_save_ccSb(this: *const c_void, name: *mut c_void, compact: i32) -> i32;
	fn tsXml_save_cStb(this: *const c_void, stream: *mut c_void, compact: i32) -> i32;
	fn tsXml_getRoot_c(this: *const c_void) -> *mut c_void;
	fn tsXml_getRoot(this: *mut c_void) -> *mut c_void;
	fn tsXml_setParent(this: *mut c_void, parent: *mut c_void, check: i32) -> u32;
	fn tsXml_getParent_c(this: *const c_void) -> *mut c_void;
	fn tsXml_getParent(this: *mut c_void) -> *mut c_void;
	fn tsXml_addChild_sb(this: *mut c_void, name: *const c_char, check: i32) -> *mut c_void;
	fn tsXml_addChild_Xb(this: *mut c_void, child: *mut c_void, check: i32) -> u32;
	fn tsXml_removeChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsXml_releaseChildren(this: *mut c_void);
	fn tsXml_findChild(this: *const c_void, name: *const c_char) -> u32;
	fn tsXml_isChild(this: *const c_void, name: *const c_char) -> i32;
	fn tsXml_getChild_cs(this: *const c_void, name: *const c_char) -> *mut c_void;
	fn tsXml_getChild_s(this: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsXml_getNumChildren(this: *const c_void) -> u32;
	fn tsXml_getChild_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsXml_getChild_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsXml_getPathName(this: *const c_void) -> *mut c_void;
	fn tsXml_setName_s(this: *mut c_void, name: *const c_char);
	fn tsXml_setName_cS(this: *mut c_void, name: *mut c_void);
	fn tsXml_getName(this: *const c_void) -> *mut c_void;
	fn tsXml_setData_b(this: *mut c_void, value: i32);
	fn tsXml_setData_s(this: *mut c_void, value: *const c_char);
	fn tsXml_setData_cS(this: *mut c_void, value: *mut c_void);
	fn tsXml_setData_iu(this: *mut c_void, value: i32, radix: u32);
	fn tsXml_setData_uu(this: *mut c_void, value: u32, radix: u32);
	fn tsXml_setData_u64u(this: *mut c_void, value: u64, radix: u32);
	fn tsXml_setData_fubb(this: *mut c_void, value: f32, digits: u32, compact: i32, exponent: i32);
	fn tsXml_setData_f64ubb(this: *mut c_void, value: f64, digits: u32, compact: i32, exponent: i32);
	fn tsXml_getData_c(this: *const c_void) -> *mut c_void;
	fn tsXml_getDataBool(this: *const c_void) -> i32;
	fn tsXml_getDatai32(this: *const c_void, radix: u32) -> i32;
	fn tsXml_getDatau32(this: *const c_void, radix: u32) -> u32;
	fn tsXml_getDatau64(this: *const c_void, radix: u32) -> u64;
	fn tsXml_getDataf32(this: *const c_void) -> f32;
	fn tsXml_getDataf64(this: *const c_void) -> f64;
	fn tsXml_getData_cscS(this: *const c_void, name: *const c_char, value: *mut c_void) -> *mut c_void;
	fn tsXml_getData_csb(this: *const c_void, name: *const c_char, value: i32) -> i32;
	fn tsXml_getData_csiu(this: *const c_void, name: *const c_char, value: i32, radix: u32) -> i32;
	fn tsXml_getData_csuu(this: *const c_void, name: *const c_char, value: u32, radix: u32) -> u32;
	fn tsXml_getData_csu64u(this: *const c_void, name: *const c_char, value: u64, radix: u32) -> u64;
	fn tsXml_getData_csf(this: *const c_void, name: *const c_char, value: f32) -> f32;
	fn tsXml_getData_csf64(this: *const c_void, name: *const c_char, value: f64) -> f64;
	fn tsXml_setData_spuu(this: *mut c_void, values: *const *const c_char, size: u32, wrap: u32);
	fn tsXml_setData_cSuu(this: *mut c_void, values: *const *mut c_void, size: u32, wrap: u32);
	fn tsXml_setData_ipuuu(this: *mut c_void, values: *const i32, size: u32, radix: u32, wrap: u32);
	fn tsXml_setData_upuuu(this: *mut c_void, values: *const u32, size: u32, radix: u32, wrap: u32);
	fn tsXml_setData_fpuubbu(this: *mut c_void, values: *const f32, size: u32, digits: u32, compact: i32, exponent: i32, wrap: u32);
	fn tsXml_setData_f64puubbu(this: *mut c_void, values: *const f64, size: u32, digits: u32, compact: i32, exponent: i32, wrap: u32);
	fn tsXml_getData_cSu(this: *const c_void, values: *const *mut c_void, size: u32) -> u32;
	fn tsXml_getData_ciruu(this: *const c_void, values: *mut i32, size: u32, radix: u32) -> u32;
	fn tsXml_getData_curuu(this: *const c_void, values: *mut u32, size: u32, radix: u32) -> u32;
	fn tsXml_getData_cfru(this: *const c_void, values: *mut f32, size: u32) -> u32;
	fn tsXml_getData_cf64ru(this: *const c_void, values: *mut f64, size: u32) -> u32;
	fn tsXml_addAttribute(this: *mut c_void, name: *const c_char) -> u32;
	fn tsXml_removeAttribute(this: *mut c_void, name: *const c_char) -> i32;
	fn tsXml_findAttribute(this: *const c_void, name: *const c_char) -> u32;
	fn tsXml_isAttribute(this: *const c_void, name: *const c_char) -> i32;
	fn tsXml_removeAttributes(this: *mut c_void);
	fn tsXml_getNumAttributes(this: *const c_void) -> u32;
	fn tsXml_getAttributeName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsXml_setAttributes(this: *mut c_void, str: *const c_char) -> i32;
	fn tsXml_setAttribute_ub(this: *mut c_void, index: u32, value: i32);
	fn tsXml_setAttribute_us(this: *mut c_void, index: u32, value: *const c_char);
	fn tsXml_setAttribute_ucS(this: *mut c_void, index: u32, value: *mut c_void);
	fn tsXml_setAttribute_uiu(this: *mut c_void, index: u32, value: i32, radix: u32);
	fn tsXml_setAttribute_uuu(this: *mut c_void, index: u32, value: u32, radix: u32);
	fn tsXml_setAttribute_uu64u(this: *mut c_void, index: u32, value: u64, radix: u32);
	fn tsXml_setAttribute_ufubb(this: *mut c_void, index: u32, value: f32, digits: u32, compact: i32, exponent: i32);
	fn tsXml_setAttribute_uf64ubb(this: *mut c_void, index: u32, value: f64, digits: u32, compact: i32, exponent: i32);
	fn tsXml_getAttribute_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsXml_getAttributei32(this: *const c_void, index: u32, radix: u32) -> i32;
	fn tsXml_getAttributeu32(this: *const c_void, index: u32, radix: u32) -> u32;
	fn tsXml_getAttributeu64(this: *const c_void, index: u32, radix: u32) -> u64;
	fn tsXml_getAttributef32(this: *const c_void, index: u32) -> f32;
	fn tsXml_getAttributef64(this: *const c_void, index: u32) -> f64;
	fn tsXml_getAttribute_cscS(this: *const c_void, name: *const c_char, value: *mut c_void) -> *mut c_void;
	fn tsXml_getAttribute_csb(this: *const c_void, name: *const c_char, value: i32) -> i32;
	fn tsXml_getAttribute_csiu(this: *const c_void, name: *const c_char, value: i32, radix: u32) -> i32;
	fn tsXml_getAttribute_csuu(this: *const c_void, name: *const c_char, value: u32, radix: u32) -> u32;
	fn tsXml_getAttribute_csu64u(this: *const c_void, name: *const c_char, value: u64, radix: u32) -> u64;
	fn tsXml_getAttribute_csf(this: *const c_void, name: *const c_char, value: f32) -> f32;
	fn tsXml_getAttribute_csf64(this: *const c_void, name: *const c_char, value: f64) -> f64;
	fn tsXml_setAttribute_uspus(this: *mut c_void, index: u32, values: *const *const c_char, size: u32, delimiter: *const c_char);
	fn tsXml_setAttribute_ucSus(this: *mut c_void, index: u32, values: *const *mut c_void, size: u32, delimiter: *const c_char);
	fn tsXml_setAttribute_uipuu(this: *mut c_void, index: u32, values: *const i32, size: u32, radix: u32);
	fn tsXml_setAttribute_uupuu(this: *mut c_void, index: u32, values: *const u32, size: u32, radix: u32);
	fn tsXml_setAttribute_ufpuubb(this: *mut c_void, index: u32, values: *const f32, size: u32, digits: u32, compact: i32, exponent: i32);
	fn tsXml_setAttribute_uf64puubb(this: *mut c_void, index: u32, values: *const f64, size: u32, digits: u32, compact: i32, exponent: i32);
	fn tsXml_getAttribute_cuSus(this: *const c_void, index: u32, values: *const *mut c_void, size: u32, delimiter: *const c_char) -> u32;
	fn tsXml_getAttribute_cuiruu(this: *const c_void, index: u32, values: *mut i32, size: u32, radix: u32) -> u32;
	fn tsXml_getAttribute_cuuruu(this: *const c_void, index: u32, values: *mut u32, size: u32, radix: u32) -> u32;
	fn tsXml_getAttribute_cufru(this: *const c_void, index: u32, values: *mut f32, size: u32) -> u32;
	fn tsXml_getAttribute_cuf64ru(this: *const c_void, index: u32, values: *mut f64, size: u32) -> u32;
}

// Tellusim::Buffer
pub struct Buffer {
	this: *mut c_void,
	owner: bool,
}
impl Buffer {
	pub fn null() -> Buffer { Buffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Buffer { unsafe { Buffer { this: tsBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Buffer { unsafe { Buffer { this: ptr, owner: tsBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Buffer { unsafe { Buffer { this: tsBuffer_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Buffer) -> bool { unsafe { tsBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Buffer { unsafe { Buffer { this: tsBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait BufferTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn name(&self) -> string::String;
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool;
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool;
	fn is_mapped(&self) -> bool;
	fn flags(&self) -> BufferFlags;
	fn has_flag(&self, flags: BufferFlags) -> bool;
	fn has_flags(&self, flags: BufferFlags) -> bool;
	fn flags_name(&self) -> string::String;
	fn format(&self) -> Format;
	fn format_name(&self) -> string::String;
	fn components(&self) -> u32;
	fn pixel_size(&self) -> u32;
	fn size(&mut self) -> usize;
	fn page_size(&mut self) -> usize;
	fn description(&self) -> string::String;
}
impl BufferTrait for Buffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for Buffer {
	fn drop(&mut self) { if self.owner { unsafe { tsBuffer_delete(self.this) } } }
}
impl Clone for Buffer {
	fn clone(&self) -> Buffer { unsafe { Buffer { this: tsBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Buffer { }
impl fmt::Display for Buffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Buffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsBuffer_new() -> *mut c_void;
	fn tsBuffer_delete(this: *mut c_void);
	fn tsBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsBuffer_clearPtr(this: *const c_void);
	fn tsBuffer_destroyPtr(this: *const c_void);
	fn tsBuffer_acquirePtr(this: *const c_void);
	fn tsBuffer_unacquirePtr(this: *const c_void);
	fn tsBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsBuffer_getPlatform(this: *const c_void) -> Platform;
	fn tsBuffer_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsBuffer_getIndex(this: *const c_void) -> u32;
	fn tsBuffer_clear(this: *mut c_void);
	fn tsBuffer_isCreated(this: *const c_void) -> i32;
	fn tsBuffer_setName(this: *mut c_void, name: *const c_char);
	fn tsBuffer_getName(this: *const c_void) -> *mut c_void;
	fn tsBuffer_create(this: *mut c_void, flags: BufferFlags, size: usize, format: Format) -> i32;
	fn tsBuffer_isMapped(this: *const c_void) -> i32;
	fn tsBuffer_getFlags(this: *const c_void) -> BufferFlags;
	fn tsBuffer_hasFlag(this: *const c_void, flags: BufferFlags) -> i32;
	fn tsBuffer_hasFlags(this: *const c_void, flags: BufferFlags) -> i32;
	fn tsBuffer_getFlagsName(this: *const c_void) -> *mut c_void;
	fn tsBuffer_getFormat(this: *const c_void) -> Format;
	fn tsBuffer_getFormatName(this: *const c_void) -> *const c_char;
	fn tsBuffer_getComponents(this: *const c_void) -> u32;
	fn tsBuffer_getPixelSize(this: *const c_void) -> u32;
	fn tsBuffer_getSize(this: *mut c_void) -> usize;
	fn tsBuffer_getPageSize(this: *mut c_void) -> usize;
	fn tsBuffer_getDescription(this: *const c_void) -> *mut c_void;
}

// Tellusim::BufferTable
pub struct BufferTable {
	this: *mut c_void,
	owner: bool,
}
impl BufferTable {
	pub fn null() -> BufferTable { BufferTable { this: ptr::null_mut(), owner: false } }
	pub fn new() -> BufferTable { unsafe { BufferTable { this: tsBufferTable_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> BufferTable { unsafe { BufferTable { this: ptr, owner: tsBufferTable_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> BufferTable { unsafe { BufferTable { this: tsBufferTable_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: BufferTable) -> bool { unsafe { tsBufferTable_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> BufferTable { unsafe { BufferTable { this: tsBufferTable_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsBufferTable_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsBufferTable_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsBufferTable_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsBufferTable_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsBufferTable_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsBufferTable_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsBufferTable_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsBufferTable_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsBufferTable_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn platform(&self) -> Platform { unsafe { tsBufferTable_getPlatform(self.this) } }
	pub fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBufferTable_getPlatformName(self.this)) } }
	pub fn index(&self) -> u32 { unsafe { tsBufferTable_getIndex(self.this) } }
	pub fn clear(&mut self) { unsafe { tsBufferTable_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsBufferTable_isCreated(self.this) != 0 } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBufferTable_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsBufferTable_getName(self.this)) } }
	pub fn create(&mut self, size: u32) -> bool { unsafe { tsBufferTable_create(self.this, size) != 0 } }
	pub fn size(&self) -> u32 { unsafe { tsBufferTable_getSize(self.this) } }
	pub fn get(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsBufferTable_get(self.this, index)) } }
	pub fn is_owner(&self, index: u32) -> bool { unsafe { tsBufferTable_isOwner(self.this, index) != 0 } }
	pub fn memory(&self) -> usize { unsafe { tsBufferTable_getMemory(self.this) } }
}
impl Drop for BufferTable {
	fn drop(&mut self) { if self.owner { unsafe { tsBufferTable_delete(self.this) } } }
}
impl Clone for BufferTable {
	fn clone(&self) -> BufferTable { unsafe { BufferTable { this: tsBufferTable_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for BufferTable { }
impl fmt::Display for BufferTable {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::BufferTable ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsBufferTable_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsBufferTable_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsBufferTable_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsBufferTable_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsBufferTable_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsBufferTable_new() -> *mut c_void;
	fn tsBufferTable_delete(this: *mut c_void);
	fn tsBufferTable_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsBufferTable_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsBufferTable_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsBufferTable_clearPtr(this: *const c_void);
	fn tsBufferTable_destroyPtr(this: *const c_void);
	fn tsBufferTable_acquirePtr(this: *const c_void);
	fn tsBufferTable_unacquirePtr(this: *const c_void);
	fn tsBufferTable_isValidPtr(this: *const c_void) -> i32;
	fn tsBufferTable_isOwnerPtr(this: *const c_void) -> i32;
	fn tsBufferTable_isConstPtr(this: *const c_void) -> i32;
	fn tsBufferTable_getCountPtr(this: *const c_void) -> u32;
	fn tsBufferTable_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsBufferTable_getPlatform(this: *const c_void) -> Platform;
	fn tsBufferTable_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsBufferTable_getIndex(this: *const c_void) -> u32;
	fn tsBufferTable_clear(this: *mut c_void);
	fn tsBufferTable_isCreated(this: *const c_void) -> i32;
	fn tsBufferTable_setName(this: *mut c_void, name: *const c_char);
	fn tsBufferTable_getName(this: *const c_void) -> *mut c_void;
	fn tsBufferTable_create(this: *mut c_void, size: u32) -> i32;
	fn tsBufferTable_getSize(this: *const c_void) -> u32;
	fn tsBufferTable_get(this: *const c_void, index: u32) -> *mut c_void;
	fn tsBufferTable_isOwner(this: *const c_void, index: u32) -> i32;
	fn tsBufferTable_getMemory(this: *const c_void) -> usize;
}

// Tellusim::D3D12Buffer
pub struct D3D12Buffer {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Buffer {
	pub fn null() -> D3D12Buffer { D3D12Buffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Buffer { unsafe { D3D12Buffer { this: tsD3D12Buffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Buffer { unsafe { D3D12Buffer { this: ptr, owner: tsD3D12Buffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Buffer { unsafe { D3D12Buffer { this: tsD3D12Buffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> D3D12Buffer { unsafe { D3D12Buffer::new_ptr(tsD3D12Buffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsD3D12Buffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Buffer) -> bool { unsafe { tsD3D12Buffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Buffer { unsafe { D3D12Buffer { this: tsD3D12Buffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Buffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Buffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Buffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Buffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Buffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Buffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Buffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Buffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Buffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, flags: BufferFlags, buffer: *const c_void, state: u32) -> bool { unsafe { tsD3D12Buffer_create(self.this, flags, buffer, state) != 0 } }
	pub fn d3d12_buffer(&self) -> *const c_void { unsafe { tsD3D12Buffer_getD3D12Buffer(self.this) } }
	pub fn unordered_access_view(&self) -> usize { unsafe { tsD3D12Buffer_getUnorderedAccessView(self.this) } }
	pub fn shader_resource_view(&self) -> usize { unsafe { tsD3D12Buffer_getShaderResourceView(self.this) } }
	pub fn buffer_address(&self) -> u64 { unsafe { tsD3D12Buffer_getBufferAddress(self.this) } }
	pub fn set_buffer_state(&mut self, state: u32) { unsafe { tsD3D12Buffer_setBufferState(self.this, state) } }
	pub fn buffer_state(&self) -> u32 { unsafe { tsD3D12Buffer_getBufferState(self.this) } }
	pub fn shared_handle(&self) -> *mut c_void { unsafe { tsD3D12Buffer_getSharedHandle(self.this) } }
	pub fn interop_handle(&self) -> *mut c_void { unsafe { tsD3D12Buffer_getInteropHandle(self.this) } }
}
impl BufferTrait for D3D12Buffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for D3D12Buffer {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Buffer_delete(self.this) } } }
}
impl Clone for D3D12Buffer {
	fn clone(&self) -> D3D12Buffer { unsafe { D3D12Buffer { this: tsD3D12Buffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Buffer { }
impl fmt::Display for D3D12Buffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Buffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Buffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Buffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Buffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Buffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Buffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Buffer_new() -> *mut c_void;
	fn tsD3D12Buffer_delete(this: *mut c_void);
	fn tsD3D12Buffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Buffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Buffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Buffer_clearPtr(this: *const c_void);
	fn tsD3D12Buffer_destroyPtr(this: *const c_void);
	fn tsD3D12Buffer_acquirePtr(this: *const c_void);
	fn tsD3D12Buffer_unacquirePtr(this: *const c_void);
	fn tsD3D12Buffer_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Buffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Buffer_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Buffer_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Buffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Buffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Buffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Buffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Buffer_create(this: *mut c_void, flags: BufferFlags, buffer: *const c_void, state: u32) -> i32;
	fn tsD3D12Buffer_getD3D12Buffer(this: *const c_void) -> *const c_void;
	fn tsD3D12Buffer_getUnorderedAccessView(this: *const c_void) -> usize;
	fn tsD3D12Buffer_getShaderResourceView(this: *const c_void) -> usize;
	fn tsD3D12Buffer_getBufferAddress(this: *const c_void) -> u64;
	fn tsD3D12Buffer_setBufferState(this: *mut c_void, state: u32);
	fn tsD3D12Buffer_getBufferState(this: *const c_void) -> u32;
	fn tsD3D12Buffer_getSharedHandle(this: *const c_void) -> *mut c_void;
	fn tsD3D12Buffer_getInteropHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::D3D11Buffer
pub struct D3D11Buffer {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Buffer {
	pub fn null() -> D3D11Buffer { D3D11Buffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Buffer { unsafe { D3D11Buffer { this: tsD3D11Buffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Buffer { unsafe { D3D11Buffer { this: ptr, owner: tsD3D11Buffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Buffer { unsafe { D3D11Buffer { this: tsD3D11Buffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> D3D11Buffer { unsafe { D3D11Buffer::new_ptr(tsD3D11Buffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsD3D11Buffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Buffer) -> bool { unsafe { tsD3D11Buffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Buffer { unsafe { D3D11Buffer { this: tsD3D11Buffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Buffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Buffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Buffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Buffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Buffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Buffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Buffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Buffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Buffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, flags: BufferFlags, buffer: *const c_void) -> bool { unsafe { tsD3D11Buffer_create(self.this, flags, buffer) != 0 } }
	pub fn d3d11_buffer(&self) -> *const c_void { unsafe { tsD3D11Buffer_getD3D11Buffer(self.this) } }
	pub fn unordered_access_view(&self) -> *const c_void { unsafe { tsD3D11Buffer_getUnorderedAccessView(self.this) } }
	pub fn shader_resource_view(&self) -> *const c_void { unsafe { tsD3D11Buffer_getShaderResourceView(self.this) } }
	pub fn interop_handle(&self) -> *mut c_void { unsafe { tsD3D11Buffer_getInteropHandle(self.this) } }
}
impl BufferTrait for D3D11Buffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for D3D11Buffer {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Buffer_delete(self.this) } } }
}
impl Clone for D3D11Buffer {
	fn clone(&self) -> D3D11Buffer { unsafe { D3D11Buffer { this: tsD3D11Buffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Buffer { }
impl fmt::Display for D3D11Buffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Buffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Buffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Buffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Buffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Buffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Buffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Buffer_new() -> *mut c_void;
	fn tsD3D11Buffer_delete(this: *mut c_void);
	fn tsD3D11Buffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Buffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Buffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Buffer_clearPtr(this: *const c_void);
	fn tsD3D11Buffer_destroyPtr(this: *const c_void);
	fn tsD3D11Buffer_acquirePtr(this: *const c_void);
	fn tsD3D11Buffer_unacquirePtr(this: *const c_void);
	fn tsD3D11Buffer_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Buffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Buffer_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Buffer_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Buffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Buffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Buffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Buffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Buffer_create(this: *mut c_void, flags: BufferFlags, buffer: *const c_void) -> i32;
	fn tsD3D11Buffer_getD3D11Buffer(this: *const c_void) -> *const c_void;
	fn tsD3D11Buffer_getUnorderedAccessView(this: *const c_void) -> *const c_void;
	fn tsD3D11Buffer_getShaderResourceView(this: *const c_void) -> *const c_void;
	fn tsD3D11Buffer_getInteropHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::MTLBuffer
pub struct MTLBuffer {
	this: *mut c_void,
	owner: bool,
}
impl MTLBuffer {
	pub fn null() -> MTLBuffer { MTLBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLBuffer { unsafe { MTLBuffer { this: tsMTLBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLBuffer { unsafe { MTLBuffer { this: ptr, owner: tsMTLBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLBuffer { unsafe { MTLBuffer { this: tsMTLBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> MTLBuffer { unsafe { MTLBuffer::new_ptr(tsMTLBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsMTLBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLBuffer) -> bool { unsafe { tsMTLBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLBuffer { unsafe { MTLBuffer { this: tsMTLBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, flags: BufferFlags, buffer: *mut c_void) -> bool { unsafe { tsMTLBuffer_create(self.this, flags, buffer) != 0 } }
	pub fn mtl_buffer(&self) -> *mut c_void { unsafe { tsMTLBuffer_getMTLBuffer(self.this) } }
	pub fn shared_ptr(&self) -> *mut c_void { unsafe { tsMTLBuffer_getSharedPtr(self.this) } }
}
impl BufferTrait for MTLBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for MTLBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLBuffer_delete(self.this) } } }
}
impl Clone for MTLBuffer {
	fn clone(&self) -> MTLBuffer { unsafe { MTLBuffer { this: tsMTLBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLBuffer { }
impl fmt::Display for MTLBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLBuffer_new() -> *mut c_void;
	fn tsMTLBuffer_delete(this: *mut c_void);
	fn tsMTLBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLBuffer_clearPtr(this: *const c_void);
	fn tsMTLBuffer_destroyPtr(this: *const c_void);
	fn tsMTLBuffer_acquirePtr(this: *const c_void);
	fn tsMTLBuffer_unacquirePtr(this: *const c_void);
	fn tsMTLBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLBuffer_create(this: *mut c_void, flags: BufferFlags, buffer: *mut c_void) -> i32;
	fn tsMTLBuffer_getMTLBuffer(this: *const c_void) -> *mut c_void;
	fn tsMTLBuffer_getSharedPtr(this: *const c_void) -> *mut c_void;
}

// Tellusim::VKBuffer
pub struct VKBuffer {
	this: *mut c_void,
	owner: bool,
}
impl VKBuffer {
	pub fn null() -> VKBuffer { VKBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKBuffer { unsafe { VKBuffer { this: tsVKBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKBuffer { unsafe { VKBuffer { this: ptr, owner: tsVKBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKBuffer { unsafe { VKBuffer { this: tsVKBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> VKBuffer { unsafe { VKBuffer::new_ptr(tsVKBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsVKBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKBuffer) -> bool { unsafe { tsVKBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKBuffer { unsafe { VKBuffer { this: tsVKBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, flags: BufferFlags, size: usize, buffer: *const c_void, access: u32) -> bool { unsafe { tsVKBuffer_create(self.this, flags, size, buffer, access) != 0 } }
	pub fn vk_buffer(&self) -> *const c_void { unsafe { tsVKBuffer_getVKBuffer(self.this) } }
	pub fn buffer_view(&self) -> *const c_void { unsafe { tsVKBuffer_getBufferView(self.this) } }
	pub fn buffer_address(&self) -> u64 { unsafe { tsVKBuffer_getBufferAddress(self.this) } }
	pub fn set_buffer_access(&mut self, access: u32) { unsafe { tsVKBuffer_setBufferAccess(self.this, access) } }
	pub fn buffer_access(&self) -> u32 { unsafe { tsVKBuffer_getBufferAccess(self.this) } }
	pub fn shared_ptr(&self) -> *mut c_void { unsafe { tsVKBuffer_getSharedPtr(self.this) } }
	pub fn interop_handle(&self) -> *mut c_void { unsafe { tsVKBuffer_getInteropHandle(self.this) } }
}
impl BufferTrait for VKBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for VKBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsVKBuffer_delete(self.this) } } }
}
impl Clone for VKBuffer {
	fn clone(&self) -> VKBuffer { unsafe { VKBuffer { this: tsVKBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKBuffer { }
impl fmt::Display for VKBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKBuffer_new() -> *mut c_void;
	fn tsVKBuffer_delete(this: *mut c_void);
	fn tsVKBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKBuffer_clearPtr(this: *const c_void);
	fn tsVKBuffer_destroyPtr(this: *const c_void);
	fn tsVKBuffer_acquirePtr(this: *const c_void);
	fn tsVKBuffer_unacquirePtr(this: *const c_void);
	fn tsVKBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsVKBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsVKBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsVKBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsVKBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsVKBuffer_create(this: *mut c_void, flags: BufferFlags, size: usize, buffer: *const c_void, access: u32) -> i32;
	fn tsVKBuffer_getVKBuffer(this: *const c_void) -> *const c_void;
	fn tsVKBuffer_getBufferView(this: *const c_void) -> *const c_void;
	fn tsVKBuffer_getBufferAddress(this: *const c_void) -> u64;
	fn tsVKBuffer_setBufferAccess(this: *mut c_void, access: u32);
	fn tsVKBuffer_getBufferAccess(this: *const c_void) -> u32;
	fn tsVKBuffer_getSharedPtr(this: *const c_void) -> *mut c_void;
	fn tsVKBuffer_getInteropHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::GLBuffer
pub struct GLBuffer {
	this: *mut c_void,
	owner: bool,
}
impl GLBuffer {
	pub fn null() -> GLBuffer { GLBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLBuffer { unsafe { GLBuffer { this: tsGLBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLBuffer { unsafe { GLBuffer { this: ptr, owner: tsGLBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLBuffer { unsafe { GLBuffer { this: tsGLBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> GLBuffer { unsafe { GLBuffer::new_ptr(tsGLBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsGLBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLBuffer) -> bool { unsafe { tsGLBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLBuffer { unsafe { GLBuffer { this: tsGLBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, flags: BufferFlags, target: u32, buffer_id: u32) -> bool { unsafe { tsGLBuffer_create(self.this, flags, target, buffer_id) != 0 } }
	pub fn target(&self) -> u32 { unsafe { tsGLBuffer_getTarget(self.this) } }
	pub fn buffer_id(&self) -> u32 { unsafe { tsGLBuffer_getBufferID(self.this) } }
}
impl BufferTrait for GLBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for GLBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsGLBuffer_delete(self.this) } } }
}
impl Clone for GLBuffer {
	fn clone(&self) -> GLBuffer { unsafe { GLBuffer { this: tsGLBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLBuffer { }
impl fmt::Display for GLBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLBuffer_new() -> *mut c_void;
	fn tsGLBuffer_delete(this: *mut c_void);
	fn tsGLBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLBuffer_clearPtr(this: *const c_void);
	fn tsGLBuffer_destroyPtr(this: *const c_void);
	fn tsGLBuffer_acquirePtr(this: *const c_void);
	fn tsGLBuffer_unacquirePtr(this: *const c_void);
	fn tsGLBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsGLBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsGLBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsGLBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsGLBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsGLBuffer_create(this: *mut c_void, flags: BufferFlags, target: u32, buffer_id: u32) -> i32;
	fn tsGLBuffer_getTarget(this: *const c_void) -> u32;
	fn tsGLBuffer_getBufferID(this: *const c_void) -> u32;
}

// Tellusim::GLESBuffer
pub struct GLESBuffer {
	this: *mut c_void,
	owner: bool,
}
impl GLESBuffer {
	pub fn null() -> GLESBuffer { GLESBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLESBuffer { unsafe { GLESBuffer { this: tsGLESBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLESBuffer { unsafe { GLESBuffer { this: ptr, owner: tsGLESBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLESBuffer { unsafe { GLESBuffer { this: tsGLESBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> GLESBuffer { unsafe { GLESBuffer::new_ptr(tsGLESBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsGLESBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLESBuffer) -> bool { unsafe { tsGLESBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLESBuffer { unsafe { GLESBuffer { this: tsGLESBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLESBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLESBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLESBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLESBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLESBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLESBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLESBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLESBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLESBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, flags: BufferFlags, target: u32, buffer_id: u32) -> bool { unsafe { tsGLESBuffer_create(self.this, flags, target, buffer_id) != 0 } }
	pub fn target(&self) -> u32 { unsafe { tsGLESBuffer_getTarget(self.this) } }
	pub fn buffer_id(&self) -> u32 { unsafe { tsGLESBuffer_getBufferID(self.this) } }
}
impl BufferTrait for GLESBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for GLESBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsGLESBuffer_delete(self.this) } } }
}
impl Clone for GLESBuffer {
	fn clone(&self) -> GLESBuffer { unsafe { GLESBuffer { this: tsGLESBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLESBuffer { }
impl fmt::Display for GLESBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLESBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLESBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLESBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLESBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLESBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLESBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLESBuffer_new() -> *mut c_void;
	fn tsGLESBuffer_delete(this: *mut c_void);
	fn tsGLESBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESBuffer_clearPtr(this: *const c_void);
	fn tsGLESBuffer_destroyPtr(this: *const c_void);
	fn tsGLESBuffer_acquirePtr(this: *const c_void);
	fn tsGLESBuffer_unacquirePtr(this: *const c_void);
	fn tsGLESBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsGLESBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLESBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsGLESBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsGLESBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESBuffer_create(this: *mut c_void, flags: BufferFlags, target: u32, buffer_id: u32) -> i32;
	fn tsGLESBuffer_getTarget(this: *const c_void) -> u32;
	fn tsGLESBuffer_getBufferID(this: *const c_void) -> u32;
}

// Tellusim::CUBuffer
pub struct CUBuffer {
	this: *mut c_void,
	owner: bool,
}
impl CUBuffer {
	pub fn null() -> CUBuffer { CUBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CUBuffer { unsafe { CUBuffer { this: tsCUBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CUBuffer { unsafe { CUBuffer { this: ptr, owner: tsCUBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CUBuffer { unsafe { CUBuffer { this: tsCUBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> CUBuffer { unsafe { CUBuffer::new_ptr(tsCUBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsCUBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CUBuffer) -> bool { unsafe { tsCUBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CUBuffer { unsafe { CUBuffer { this: tsCUBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCUBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCUBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCUBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCUBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCUBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCUBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCUBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCUBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCUBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn buffer_ptr(&self) -> usize { unsafe { tsCUBuffer_getBufferPtr(self.this) } }
	pub fn buffer_data(&self) -> *mut u8 { unsafe { tsCUBuffer_getBufferData(self.this) } }
	pub fn buffer_event(&self) -> *const c_void { unsafe { tsCUBuffer_getBufferEvent(self.this) } }
	pub fn array_format(&self) -> u32 { unsafe { tsCUBuffer_getArrayFormat(self.this) } }
	pub fn array_channels(&self) -> u32 { unsafe { tsCUBuffer_getArrayChannels(self.this) } }
	pub fn shared_memory(&self) -> *const c_void { unsafe { tsCUBuffer_getSharedMemory(self.this) } }
}
impl BufferTrait for CUBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for CUBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsCUBuffer_delete(self.this) } } }
}
impl Clone for CUBuffer {
	fn clone(&self) -> CUBuffer { unsafe { CUBuffer { this: tsCUBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CUBuffer { }
impl fmt::Display for CUBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CUBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCUBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCUBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCUBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCUBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCUBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCUBuffer_new() -> *mut c_void;
	fn tsCUBuffer_delete(this: *mut c_void);
	fn tsCUBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCUBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCUBuffer_clearPtr(this: *const c_void);
	fn tsCUBuffer_destroyPtr(this: *const c_void);
	fn tsCUBuffer_acquirePtr(this: *const c_void);
	fn tsCUBuffer_unacquirePtr(this: *const c_void);
	fn tsCUBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsCUBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCUBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsCUBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsCUBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCUBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsCUBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsCUBuffer_getBufferPtr(this: *const c_void) -> usize;
	fn tsCUBuffer_getBufferData(this: *const c_void) -> *mut u8;
	fn tsCUBuffer_getBufferEvent(this: *const c_void) -> *const c_void;
	fn tsCUBuffer_getArrayFormat(this: *const c_void) -> u32;
	fn tsCUBuffer_getArrayChannels(this: *const c_void) -> u32;
	fn tsCUBuffer_getSharedMemory(this: *const c_void) -> *const c_void;
}

// Tellusim::HIPBuffer
pub struct HIPBuffer {
	this: *mut c_void,
	owner: bool,
}
impl HIPBuffer {
	pub fn null() -> HIPBuffer { HIPBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> HIPBuffer { unsafe { HIPBuffer { this: tsHIPBuffer_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> HIPBuffer { unsafe { HIPBuffer { this: ptr, owner: tsHIPBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> HIPBuffer { unsafe { HIPBuffer { this: tsHIPBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> HIPBuffer { unsafe { HIPBuffer::new_ptr(tsHIPBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsHIPBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: HIPBuffer) -> bool { unsafe { tsHIPBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> HIPBuffer { unsafe { HIPBuffer { this: tsHIPBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsHIPBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsHIPBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsHIPBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsHIPBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsHIPBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsHIPBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsHIPBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsHIPBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsHIPBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn buffer_ptr(&self) -> *mut c_void { unsafe { tsHIPBuffer_getBufferPtr(self.this) } }
	pub fn buffer_data(&self) -> *mut u8 { unsafe { tsHIPBuffer_getBufferData(self.this) } }
	pub fn buffer_event(&self) -> *mut c_void { unsafe { tsHIPBuffer_getBufferEvent(self.this) } }
	pub fn array_format(&self) -> u32 { unsafe { tsHIPBuffer_getArrayFormat(self.this) } }
	pub fn array_channels(&self) -> u32 { unsafe { tsHIPBuffer_getArrayChannels(self.this) } }
	pub fn shared_memory(&self) -> *mut c_void { unsafe { tsHIPBuffer_getSharedMemory(self.this) } }
}
impl BufferTrait for HIPBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for HIPBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsHIPBuffer_delete(self.this) } } }
}
impl Clone for HIPBuffer {
	fn clone(&self) -> HIPBuffer { unsafe { HIPBuffer { this: tsHIPBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for HIPBuffer { }
impl fmt::Display for HIPBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::HIPBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsHIPBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsHIPBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsHIPBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsHIPBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsHIPBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsHIPBuffer_new() -> *mut c_void;
	fn tsHIPBuffer_delete(this: *mut c_void);
	fn tsHIPBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_clearPtr(this: *const c_void);
	fn tsHIPBuffer_destroyPtr(this: *const c_void);
	fn tsHIPBuffer_acquirePtr(this: *const c_void);
	fn tsHIPBuffer_unacquirePtr(this: *const c_void);
	fn tsHIPBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsHIPBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsHIPBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsHIPBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsHIPBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_getBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_getBufferData(this: *const c_void) -> *mut u8;
	fn tsHIPBuffer_getBufferEvent(this: *const c_void) -> *mut c_void;
	fn tsHIPBuffer_getArrayFormat(this: *const c_void) -> u32;
	fn tsHIPBuffer_getArrayChannels(this: *const c_void) -> u32;
	fn tsHIPBuffer_getSharedMemory(this: *const c_void) -> *mut c_void;
}

// Tellusim::FUBuffer
pub struct FUBuffer {
	this: *mut c_void,
	owner: bool,
}
impl FUBuffer {
	pub fn null() -> FUBuffer { FUBuffer { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUBuffer { unsafe { FUBuffer { this: tsFUBuffer_new(), owner: true } } }
	pub fn new_with_buffers(buffers: &[&mut Buffer]) -> FUBuffer {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { FUBuffer { this: tsFUBuffer_new_cABb(buffers_.as_ptr(), buffers.len() as u32, 0), owner: true } }
	}
	pub fn new_with_buffers_owner(buffers: &[&mut Buffer], owner: bool) -> FUBuffer {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { FUBuffer { this: tsFUBuffer_new_cABb(buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUBuffer { unsafe { FUBuffer { this: ptr, owner: tsFUBuffer_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUBuffer { unsafe { FUBuffer { this: tsFUBuffer_copyPtr(self.this), owner: true } } }
	pub fn from_buffer(ptr: &Buffer) -> FUBuffer { unsafe { FUBuffer::new_ptr(tsFUBuffer_castBufferPtr(ptr.this)) } }
	pub fn to_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsFUBuffer_baseBufferPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUBuffer) -> bool { unsafe { tsFUBuffer_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUBuffer { unsafe { FUBuffer { this: tsFUBuffer_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUBuffer_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUBuffer_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUBuffer_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUBuffer_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUBuffer_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUBuffer_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUBuffer_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUBuffer_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUBuffer_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUBuffer_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUBuffer_getMask(self.this) } }
	pub fn num_buffers(&self) -> u32 { unsafe { tsFUBuffer_getNumBuffers(self.this) } }
	pub fn buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsFUBuffer_getBuffer_cu(self.this, index)) } }
	pub fn buffer_mut(&mut self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsFUBuffer_getBuffer_u(self.this, index)) } }
}
impl BufferTrait for FUBuffer {
	fn platform(&self) -> Platform { unsafe { tsBuffer_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsBuffer_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsBuffer_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsBuffer_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsBuffer_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsBuffer_getName(self.this)) } }
	fn create(&mut self, flags: BufferFlags, size: usize) -> bool { unsafe { tsBuffer_create(self.this, flags, size, Format::Unknown) != 0 } }
	fn create_with_format(&mut self, flags: BufferFlags, size: usize, format: Format) -> bool { unsafe { tsBuffer_create(self.this, flags, size, format) != 0 } }
	fn is_mapped(&self) -> bool { unsafe { tsBuffer_isMapped(self.this) != 0 } }
	fn flags(&self) -> BufferFlags { unsafe { tsBuffer_getFlags(self.this) } }
	fn has_flag(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: BufferFlags) -> bool { unsafe { tsBuffer_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsBuffer_getFlagsName(self.this)) } }
	fn format(&self) -> Format { unsafe { tsBuffer_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsBuffer_getFormatName(self.this)) } }
	fn components(&self) -> u32 { unsafe { tsBuffer_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsBuffer_getPixelSize(self.this) } }
	fn size(&mut self) -> usize { unsafe { tsBuffer_getSize(self.this) } }
	fn page_size(&mut self) -> usize { unsafe { tsBuffer_getPageSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsBuffer_getDescription(self.this)) } }
}
impl Drop for FUBuffer {
	fn drop(&mut self) { if self.owner { unsafe { tsFUBuffer_delete(self.this) } } }
}
impl Clone for FUBuffer {
	fn clone(&self) -> FUBuffer { unsafe { FUBuffer { this: tsFUBuffer_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUBuffer { }
impl fmt::Display for FUBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUBuffer ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUBuffer_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUBuffer_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUBuffer_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUBuffer_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUBuffer_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUBuffer_new() -> *mut c_void;
	fn tsFUBuffer_new_cABb(buffers: *const *mut c_void, buffers_size: u32, owner: i32) -> *mut c_void;
	fn tsFUBuffer_delete(this: *mut c_void);
	fn tsFUBuffer_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUBuffer_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUBuffer_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUBuffer_clearPtr(this: *const c_void);
	fn tsFUBuffer_destroyPtr(this: *const c_void);
	fn tsFUBuffer_acquirePtr(this: *const c_void);
	fn tsFUBuffer_unacquirePtr(this: *const c_void);
	fn tsFUBuffer_isValidPtr(this: *const c_void) -> i32;
	fn tsFUBuffer_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUBuffer_isConstPtr(this: *const c_void) -> i32;
	fn tsFUBuffer_getCountPtr(this: *const c_void) -> u32;
	fn tsFUBuffer_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUBuffer_equalBufferPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUBuffer_castBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsFUBuffer_baseBufferPtr(this: *const c_void) -> *mut c_void;
	fn tsFUBuffer_setMask(this: *mut c_void, mask: u32);
	fn tsFUBuffer_getMask(this: *const c_void) -> u32;
	fn tsFUBuffer_getNumBuffers(this: *const c_void) -> u32;
	fn tsFUBuffer_getBuffer_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUBuffer_getBuffer_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Command
pub struct Command {
	this: *mut c_void,
	owner: bool,
}
impl Command {
	pub fn null() -> Command { Command { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Command { unsafe { Command { this: tsCommand_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Command { unsafe { Command { this: ptr, owner: tsCommand_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Command { unsafe { Command { this: tsCommand_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Command) -> bool { unsafe { tsCommand_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Command { unsafe { Command { this: tsCommand_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCommand_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCommand_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCommand_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCommand_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCommand_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCommand_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCommand_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCommand_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCommand_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait CommandTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn set_pipeline(&mut self, pipeline: &mut Pipeline);
	fn pipeline(&self) -> Pipeline;
	fn set_viewport(&mut self, index: u32, viewport: &Viewport);
	fn set_viewports(&mut self, viewports: &[Viewport]);
	fn set_scissor(&mut self, index: u32, scissor: &Scissor);
	fn set_scissors(&mut self, scissors: &[Scissor]);
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler);
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]);
	fn set_texture(&mut self, index: u32, texture: &mut Texture);
	fn set_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>);
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]);
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture);
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>);
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format);
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]);
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void;
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize);
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize);
	fn set_uniform_offset(&mut self, index: u32, offset: usize);
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool);
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]);
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void;
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize);
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize);
	fn set_storage_offset(&mut self, index: u32, offset: usize);
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool);
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]);
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing);
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]);
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable);
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]);
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable);
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]);
	fn vertex_data(&mut self, index: u32, size: usize) -> *mut c_void;
	fn set_vertex_data(&mut self, index: u32, src: *const c_void, size: usize);
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_vertex_offset(&mut self, index: u32, offset: usize);
	fn set_vertex_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool);
	fn set_vertex_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_vertex_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]);
	fn index_data(&mut self, format: Format, size: usize) -> *mut c_void;
	fn set_index_data(&mut self, format: Format, src: *const c_void, size: usize);
	fn set_index_buffer(&mut self, format: Format, buffer: &mut Buffer);
	fn set_index_buffer_with_offset(&mut self, format: Format, buffer: &mut Buffer, offset: usize);
	fn set_index_offset(&mut self, offset: usize);
	fn set_index_offset_with_relative(&mut self, offset: usize, relative: bool);
	fn indirect_data(&mut self, size: usize) -> *mut c_void;
	fn set_indirect_data(&mut self, src: *const c_void, size: usize);
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer);
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize);
	fn set_indirect_offset(&mut self, offset: usize);
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool);
	fn set_blend_color(&mut self, color: &Color);
	fn set_blend_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32);
	fn set_stencil_ref(&mut self, ref_: u32);
	fn draw_arrays(&mut self, num_vertices: u32);
	fn draw_arrays_with_basevertex(&mut self, num_vertices: u32, base_vertex: u32);
	fn draw_arrays_instanced(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32);
	fn draw_arrays_instanced_with_baseinstance(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32);
	fn draw_arrays_indirect(&mut self, num_draws: u32);
	fn draw_arrays_indirect_with_stride(&mut self, num_draws: u32, stride: usize);
	fn draw_arrays_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32);
	fn draw_arrays_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize);
	fn draw_elements(&mut self, num_indices: u32);
	fn draw_elements_with_baseindex(&mut self, num_indices: u32, base_index: u32);
	fn draw_elements_with_baseindex_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32);
	fn draw_elements_instanced(&mut self, num_indices: u32, base_index: u32, num_instances: u32);
	fn draw_elements_instanced_with_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32);
	fn draw_elements_instanced_with_basevertex_baseinstance(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32);
	fn draw_elements_indirect(&mut self, num_draws: u32);
	fn draw_elements_indirect_with_stride(&mut self, num_draws: u32, stride: usize);
	fn draw_elements_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32);
	fn draw_elements_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize);
	fn draw_mesh(&mut self, width: u32);
	fn draw_mesh_with_height(&mut self, width: u32, height: u32);
	fn draw_mesh_with_height_depth(&mut self, width: u32, height: u32, depth: u32);
	fn draw_mesh_indirect(&mut self, num_draws: u32);
	fn draw_mesh_indirect_with_stride(&mut self, num_draws: u32, stride: usize);
	fn draw_mesh_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32);
	fn draw_mesh_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize);
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize);
	fn end_conditional(&mut self);
	fn begin_query(&mut self, query: &mut Query) -> bool;
	fn end_query(&mut self, query: &mut Query);
}
impl CommandTrait for Command {
	fn platform(&self) -> Platform { unsafe { tsCommand_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCommand_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCommand_getIndex(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCommand_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCommand_getPipeline(self.this)) } }
	fn set_viewport(&mut self, index: u32, viewport: &Viewport) { unsafe { tsCommand_setViewport(self.this, index, viewport) } }
	fn set_viewports(&mut self, viewports: &[Viewport]) { unsafe { tsCommand_setViewports(self.this, viewports.as_ptr(), viewports.len() as u32) } }
	fn set_scissor(&mut self, index: u32, scissor: &Scissor) { unsafe { tsCommand_setScissor(self.this, index, scissor) } }
	fn set_scissors(&mut self, scissors: &[Scissor]) { unsafe { tsCommand_setScissors(self.this, scissors.as_ptr(), scissors.len() as u32) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCommand_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCommand_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCommand_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCommand_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCommand_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCommand_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn vertex_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getVertexData(self.this, index, size) } }
	fn set_vertex_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setVertexData(self.this, index, src, size) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, offset) } }
	fn set_vertex_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, 0) } }
	fn set_vertex_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_vertex_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_vertex_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn index_data(&mut self, format: Format, size: usize) -> *mut c_void { unsafe { tsCommand_getIndexData(self.this, format, size) } }
	fn set_index_data(&mut self, format: Format, src: *const c_void, size: usize) { unsafe { tsCommand_setIndexData(self.this, format, src, size) } }
	fn set_index_buffer(&mut self, format: Format, buffer: &mut Buffer) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, format: Format, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, offset) } }
	fn set_index_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndexOffset(self.this, offset, 0) } }
	fn set_index_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndexOffset(self.this, offset, if relative {1} else {0}) } }
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCommand_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCommand_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn set_blend_color(&mut self, color: &Color) { unsafe { tsCommand_setBlendColor_cC(self.this, color) } }
	fn set_blend_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCommand_setBlendColor_ffff(self.this, r, g, b, a) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCommand_setStencilRef(self.this, ref_) } }
	fn draw_arrays(&mut self, num_vertices: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, 0) } }
	fn draw_arrays_with_basevertex(&mut self, num_vertices: u32, base_vertex: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, base_vertex) } }
	fn draw_arrays_instanced(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, 0) } }
	fn draw_arrays_instanced_with_baseinstance(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, base_instance) } }
	fn draw_arrays_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, 16) } }
	fn draw_arrays_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, stride) } }
	fn draw_arrays_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_arrays_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_elements(&mut self, num_indices: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, 0, 0) } }
	fn draw_elements_with_baseindex(&mut self, num_indices: u32, base_index: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, 0) } }
	fn draw_elements_with_baseindex_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, base_vertex) } }
	fn draw_elements_instanced(&mut self, num_indices: u32, base_index: u32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuu(self.this, num_indices, base_index, num_instances) } }
	fn draw_elements_instanced_with_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, 0) } }
	fn draw_elements_instanced_with_basevertex_baseinstance(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, base_instance) } }
	fn draw_elements_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, 20) } }
	fn draw_elements_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, stride) } }
	fn draw_elements_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 20) } }
	fn draw_elements_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_mesh(&mut self, width: u32) { unsafe { tsCommand_drawMesh(self.this, width, 1, 1) } }
	fn draw_mesh_with_height(&mut self, width: u32, height: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, 1) } }
	fn draw_mesh_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, depth) } }
	fn draw_mesh_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, 16) } }
	fn draw_mesh_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, stride) } }
	fn draw_mesh_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_mesh_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCommand_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCommand_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCommand_endQuery(self.this, query.this) } }
}
impl Drop for Command {
	fn drop(&mut self) { if self.owner { unsafe { tsCommand_delete(self.this) } } }
}
impl Clone for Command {
	fn clone(&self) -> Command { unsafe { Command { this: tsCommand_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Command { }
impl fmt::Display for Command {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Command ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCommand_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCommand_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCommand_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCommand_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCommand_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCommand_new() -> *mut c_void;
	fn tsCommand_delete(this: *mut c_void);
	fn tsCommand_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCommand_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCommand_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCommand_clearPtr(this: *const c_void);
	fn tsCommand_destroyPtr(this: *const c_void);
	fn tsCommand_acquirePtr(this: *const c_void);
	fn tsCommand_unacquirePtr(this: *const c_void);
	fn tsCommand_isValidPtr(this: *const c_void) -> i32;
	fn tsCommand_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCommand_isConstPtr(this: *const c_void) -> i32;
	fn tsCommand_getCountPtr(this: *const c_void) -> u32;
	fn tsCommand_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCommand_getPlatform(this: *const c_void) -> Platform;
	fn tsCommand_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsCommand_getIndex(this: *const c_void) -> u32;
	fn tsCommand_setPipeline(this: *mut c_void, pipeline: *mut c_void);
	fn tsCommand_getPipeline(this: *const c_void) -> *mut c_void;
	fn tsCommand_setViewport(this: *mut c_void, index: u32, viewport: *const Viewport);
	fn tsCommand_setViewports(this: *mut c_void, viewports: *const Viewport, num_viewports: u32);
	fn tsCommand_setScissor(this: *mut c_void, index: u32, scissor: *const Scissor);
	fn tsCommand_setScissors(this: *mut c_void, scissors: *const Scissor, num_scissors: u32);
	fn tsCommand_setSampler(this: *mut c_void, index: u32, sampler: *mut c_void);
	fn tsCommand_setSamplers_ucAS(this: *mut c_void, index: u32, samplers: *const *mut c_void, samplers_size: u32);
	fn tsCommand_setTexture_uT(this: *mut c_void, index: u32, texture: *mut c_void);
	fn tsCommand_setTexture_uTcS(this: *mut c_void, index: u32, texture: *mut c_void, slice: *const Slice);
	fn tsCommand_setTextures_ucAT(this: *mut c_void, index: u32, textures: *const *mut c_void, textures_size: u32);
	fn tsCommand_setSurfaceTexture_uT(this: *mut c_void, index: u32, texture: *mut c_void);
	fn tsCommand_setSurfaceTexture_uTcSF(this: *mut c_void, index: u32, texture: *mut c_void, slice: *const Slice, format: Format);
	fn tsCommand_setSurfaceTextures_ucAT(this: *mut c_void, index: u32, textures: *const *mut c_void, textures_size: u32);
	fn tsCommand_getUniformData(this: *mut c_void, index: u32, size: usize) -> *mut c_void;
	fn tsCommand_setUniformData(this: *mut c_void, index: u32, src: *const c_void, size: usize);
	fn tsCommand_setUniformBuffer(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize, size: usize);
	fn tsCommand_setUniformOffset(this: *mut c_void, index: u32, offset: usize, relative: i32);
	fn tsCommand_setUniformBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCommand_setUniformBuffers_ucABcA(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32, offsets: *const usize, offsets_size: u32);
	fn tsCommand_getStorageData(this: *mut c_void, index: u32, size: usize) -> *mut c_void;
	fn tsCommand_setStorageData(this: *mut c_void, index: u32, src: *const c_void, size: usize);
	fn tsCommand_setStorageBuffer(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize, size: usize);
	fn tsCommand_setStorageOffset(this: *mut c_void, index: u32, offset: usize, relative: i32);
	fn tsCommand_setStorageBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCommand_setStorageBuffers_ucABcA(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32, offsets: *const usize, offsets_size: u32);
	fn tsCommand_setTracing(this: *mut c_void, index: u32, tracing: *mut c_void);
	fn tsCommand_setTracings_ucAT(this: *mut c_void, index: u32, tracings: *const *mut c_void, tracings_size: u32);
	fn tsCommand_setTexelBuffer(this: *mut c_void, index: u32, buffer: *mut c_void);
	fn tsCommand_setTexelBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCommand_setTextureTable(this: *mut c_void, index: u32, table: *mut c_void);
	fn tsCommand_setTextureTables_ucATT(this: *mut c_void, index: u32, tables: *const *mut c_void, tables_size: u32);
	fn tsCommand_setStorageTable(this: *mut c_void, index: u32, table: *mut c_void);
	fn tsCommand_setStorageTables_ucABT(this: *mut c_void, index: u32, tables: *const *mut c_void, tables_size: u32);
	fn tsCommand_getVertexData(this: *mut c_void, index: u32, size: usize) -> *mut c_void;
	fn tsCommand_setVertexData(this: *mut c_void, index: u32, src: *const c_void, size: usize);
	fn tsCommand_setVertexBuffer(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize);
	fn tsCommand_setVertexOffset(this: *mut c_void, index: u32, offset: usize, relative: i32);
	fn tsCommand_setVertexBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCommand_setVertexBuffers_ucABcA(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32, offsets: *const usize, offsets_size: u32);
	fn tsCommand_getIndexData(this: *mut c_void, format: Format, size: usize) -> *mut c_void;
	fn tsCommand_setIndexData(this: *mut c_void, format: Format, src: *const c_void, size: usize);
	fn tsCommand_setIndexBuffer(this: *mut c_void, format: Format, buffer: *mut c_void, offset: usize);
	fn tsCommand_setIndexOffset(this: *mut c_void, offset: usize, relative: i32);
	fn tsCommand_getIndirectData(this: *mut c_void, size: usize) -> *mut c_void;
	fn tsCommand_setIndirectData(this: *mut c_void, src: *const c_void, size: usize);
	fn tsCommand_setIndirectBuffer(this: *mut c_void, buffer: *mut c_void, offset: usize);
	fn tsCommand_setIndirectOffset(this: *mut c_void, offset: usize, relative: i32);
	fn tsCommand_setBlendColor_cC(this: *mut c_void, color: *const Color);
	fn tsCommand_setBlendColor_ffff(this: *mut c_void, r: f32, g: f32, b: f32, a: f32);
	fn tsCommand_setStencilRef(this: *mut c_void, ref_: u32);
	fn tsCommand_drawArrays(this: *mut c_void, num_vertices: u32, base_vertex: u32);
	fn tsCommand_drawArraysInstanced(this: *mut c_void, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32);
	fn tsCommand_drawArraysIndirect_uz(this: *mut c_void, num_draws: u32, stride: usize);
	fn tsCommand_drawArraysIndirect_Bzuz(this: *mut c_void, buffer: *mut c_void, offset: usize, num_draws: u32, stride: usize);
	fn tsCommand_drawElements(this: *mut c_void, num_indices: u32, base_index: u32, base_vertex: i32);
	fn tsCommand_drawElementsInstanced_uuu(this: *mut c_void, num_indices: u32, base_index: u32, num_instances: u32);
	fn tsCommand_drawElementsInstanced_uuiuu(this: *mut c_void, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32);
	fn tsCommand_drawElementsIndirect_uz(this: *mut c_void, num_draws: u32, stride: usize);
	fn tsCommand_drawElementsIndirect_Bzuz(this: *mut c_void, buffer: *mut c_void, offset: usize, num_draws: u32, stride: usize);
	fn tsCommand_drawMesh(this: *mut c_void, width: u32, height: u32, depth: u32);
	fn tsCommand_drawMeshIndirect_uz(this: *mut c_void, num_draws: u32, stride: usize);
	fn tsCommand_drawMeshIndirect_Bzuz(this: *mut c_void, buffer: *mut c_void, offset: usize, num_draws: u32, stride: usize);
	fn tsCommand_beginConditional(this: *mut c_void, buffer: *mut c_void, offset: usize);
	fn tsCommand_endConditional(this: *mut c_void);
	fn tsCommand_beginQuery(this: *mut c_void, query: *mut c_void) -> i32;
	fn tsCommand_endQuery(this: *mut c_void, query: *mut c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandDrawArraysIndirect {
	pub num_vertices: u32,
	pub num_instances: u32,
	pub base_vertex: u32,
	pub base_instance: u32,
}
impl fmt::Display for CommandDrawArraysIndirect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("num_vertices: {0}\n", self.num_vertices);
		ret += &format!("num_instances: {0}\n", self.num_instances);
		ret += &format!("base_vertex: {0}\n", self.base_vertex);
		ret += &format!("base_instance: {0}", self.base_instance);
		write!(f, "{0}", ret)
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandDrawElementsIndirect {
	pub num_indices: u32,
	pub num_instances: u32,
	pub base_index: u32,
	pub base_vertex: i32,
	pub base_instance: u32,
}
impl fmt::Display for CommandDrawElementsIndirect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("num_indices: {0}\n", self.num_indices);
		ret += &format!("num_instances: {0}\n", self.num_instances);
		ret += &format!("base_index: {0}\n", self.base_index);
		ret += &format!("base_vertex: {0}\n", self.base_vertex);
		ret += &format!("base_instance: {0}", self.base_instance);
		write!(f, "{0}", ret)
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandDrawMeshIndirect {
	pub group_width: u32,
	pub group_height: u32,
	pub group_depth: u32,
	pub padding: u32,
}
impl fmt::Display for CommandDrawMeshIndirect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("group_width: {0}\n", self.group_width);
		ret += &format!("group_height: {0}\n", self.group_height);
		ret += &format!("group_depth: {0}\n", self.group_depth);
		write!(f, "{0}", ret)
	}
}

// Tellusim::D3D12Command
pub struct D3D12Command {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Command {
	pub fn null() -> D3D12Command { D3D12Command { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Command { unsafe { D3D12Command { this: tsD3D12Command_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Command { unsafe { D3D12Command { this: ptr, owner: tsD3D12Command_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Command { unsafe { D3D12Command { this: tsD3D12Command_copyPtr(self.this), owner: true } } }
	pub fn from_command(ptr: &Command) -> D3D12Command { unsafe { D3D12Command::new_ptr(tsD3D12Command_castCommandPtr(ptr.this)) } }
	pub fn to_command(&self) -> Command { unsafe { Command::new_ptr(tsD3D12Command_baseCommandPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Command) -> bool { unsafe { tsD3D12Command_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Command { unsafe { D3D12Command { this: tsD3D12Command_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Command_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Command_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Command_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Command_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Command_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Command_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Command_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Command_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Command_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn d3d12_command(&self) -> *const c_void { unsafe { tsD3D12Command_getD3D12Command(self.this) } }
	pub fn update(&mut self) { unsafe { tsD3D12Command_update(self.this) } }
}
impl CommandTrait for D3D12Command {
	fn platform(&self) -> Platform { unsafe { tsCommand_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCommand_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCommand_getIndex(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCommand_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCommand_getPipeline(self.this)) } }
	fn set_viewport(&mut self, index: u32, viewport: &Viewport) { unsafe { tsCommand_setViewport(self.this, index, viewport) } }
	fn set_viewports(&mut self, viewports: &[Viewport]) { unsafe { tsCommand_setViewports(self.this, viewports.as_ptr(), viewports.len() as u32) } }
	fn set_scissor(&mut self, index: u32, scissor: &Scissor) { unsafe { tsCommand_setScissor(self.this, index, scissor) } }
	fn set_scissors(&mut self, scissors: &[Scissor]) { unsafe { tsCommand_setScissors(self.this, scissors.as_ptr(), scissors.len() as u32) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCommand_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCommand_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCommand_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCommand_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCommand_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCommand_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn vertex_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getVertexData(self.this, index, size) } }
	fn set_vertex_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setVertexData(self.this, index, src, size) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, offset) } }
	fn set_vertex_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, 0) } }
	fn set_vertex_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_vertex_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_vertex_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn index_data(&mut self, format: Format, size: usize) -> *mut c_void { unsafe { tsCommand_getIndexData(self.this, format, size) } }
	fn set_index_data(&mut self, format: Format, src: *const c_void, size: usize) { unsafe { tsCommand_setIndexData(self.this, format, src, size) } }
	fn set_index_buffer(&mut self, format: Format, buffer: &mut Buffer) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, format: Format, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, offset) } }
	fn set_index_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndexOffset(self.this, offset, 0) } }
	fn set_index_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndexOffset(self.this, offset, if relative {1} else {0}) } }
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCommand_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCommand_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn set_blend_color(&mut self, color: &Color) { unsafe { tsCommand_setBlendColor_cC(self.this, color) } }
	fn set_blend_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCommand_setBlendColor_ffff(self.this, r, g, b, a) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCommand_setStencilRef(self.this, ref_) } }
	fn draw_arrays(&mut self, num_vertices: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, 0) } }
	fn draw_arrays_with_basevertex(&mut self, num_vertices: u32, base_vertex: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, base_vertex) } }
	fn draw_arrays_instanced(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, 0) } }
	fn draw_arrays_instanced_with_baseinstance(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, base_instance) } }
	fn draw_arrays_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, 16) } }
	fn draw_arrays_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, stride) } }
	fn draw_arrays_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_arrays_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_elements(&mut self, num_indices: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, 0, 0) } }
	fn draw_elements_with_baseindex(&mut self, num_indices: u32, base_index: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, 0) } }
	fn draw_elements_with_baseindex_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, base_vertex) } }
	fn draw_elements_instanced(&mut self, num_indices: u32, base_index: u32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuu(self.this, num_indices, base_index, num_instances) } }
	fn draw_elements_instanced_with_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, 0) } }
	fn draw_elements_instanced_with_basevertex_baseinstance(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, base_instance) } }
	fn draw_elements_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, 20) } }
	fn draw_elements_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, stride) } }
	fn draw_elements_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 20) } }
	fn draw_elements_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_mesh(&mut self, width: u32) { unsafe { tsCommand_drawMesh(self.this, width, 1, 1) } }
	fn draw_mesh_with_height(&mut self, width: u32, height: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, 1) } }
	fn draw_mesh_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, depth) } }
	fn draw_mesh_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, 16) } }
	fn draw_mesh_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, stride) } }
	fn draw_mesh_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_mesh_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCommand_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCommand_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCommand_endQuery(self.this, query.this) } }
}
impl Drop for D3D12Command {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Command_delete(self.this) } } }
}
impl Clone for D3D12Command {
	fn clone(&self) -> D3D12Command { unsafe { D3D12Command { this: tsD3D12Command_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Command { }
impl fmt::Display for D3D12Command {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Command ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Command_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Command_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Command_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Command_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Command_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Command_new() -> *mut c_void;
	fn tsD3D12Command_delete(this: *mut c_void);
	fn tsD3D12Command_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Command_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Command_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Command_clearPtr(this: *const c_void);
	fn tsD3D12Command_destroyPtr(this: *const c_void);
	fn tsD3D12Command_acquirePtr(this: *const c_void);
	fn tsD3D12Command_unacquirePtr(this: *const c_void);
	fn tsD3D12Command_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Command_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Command_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Command_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Command_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Command_equalCommandPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Command_castCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Command_baseCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Command_getD3D12Command(this: *const c_void) -> *const c_void;
	fn tsD3D12Command_update(this: *mut c_void);
}

// Tellusim::MTLCommand
pub struct MTLCommand {
	this: *mut c_void,
	owner: bool,
}
impl MTLCommand {
	pub fn null() -> MTLCommand { MTLCommand { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLCommand { unsafe { MTLCommand { this: tsMTLCommand_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLCommand { unsafe { MTLCommand { this: ptr, owner: tsMTLCommand_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLCommand { unsafe { MTLCommand { this: tsMTLCommand_copyPtr(self.this), owner: true } } }
	pub fn from_command(ptr: &Command) -> MTLCommand { unsafe { MTLCommand::new_ptr(tsMTLCommand_castCommandPtr(ptr.this)) } }
	pub fn to_command(&self) -> Command { unsafe { Command::new_ptr(tsMTLCommand_baseCommandPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLCommand) -> bool { unsafe { tsMTLCommand_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLCommand { unsafe { MTLCommand { this: tsMTLCommand_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLCommand_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLCommand_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLCommand_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLCommand_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLCommand_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLCommand_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLCommand_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLCommand_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLCommand_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn encoder(&self) -> *mut c_void { unsafe { tsMTLCommand_getEncoder(self.this) } }
	pub fn flush(&mut self, encoder: *mut c_void) { unsafe { tsMTLCommand_flush_prb(self.this, encoder, 0) } }
	pub fn flush_with_enqueue(&mut self, encoder: *mut c_void, enqueue: bool) { unsafe { tsMTLCommand_flush_prb(self.this, encoder, if enqueue {1} else {0}) } }
	pub fn flush_with_create(&mut self, create: bool) { unsafe { tsMTLCommand_flush_bb(self.this, if create {1} else {0}, 0) } }
	pub fn flush_with_create_enqueue(&mut self, create: bool, enqueue: bool) { unsafe { tsMTLCommand_flush_bb(self.this, if create {1} else {0}, if enqueue {1} else {0}) } }
	pub fn update(&mut self) { unsafe { tsMTLCommand_update(self.this) } }
}
impl CommandTrait for MTLCommand {
	fn platform(&self) -> Platform { unsafe { tsCommand_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCommand_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCommand_getIndex(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCommand_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCommand_getPipeline(self.this)) } }
	fn set_viewport(&mut self, index: u32, viewport: &Viewport) { unsafe { tsCommand_setViewport(self.this, index, viewport) } }
	fn set_viewports(&mut self, viewports: &[Viewport]) { unsafe { tsCommand_setViewports(self.this, viewports.as_ptr(), viewports.len() as u32) } }
	fn set_scissor(&mut self, index: u32, scissor: &Scissor) { unsafe { tsCommand_setScissor(self.this, index, scissor) } }
	fn set_scissors(&mut self, scissors: &[Scissor]) { unsafe { tsCommand_setScissors(self.this, scissors.as_ptr(), scissors.len() as u32) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCommand_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCommand_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCommand_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCommand_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCommand_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCommand_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn vertex_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getVertexData(self.this, index, size) } }
	fn set_vertex_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setVertexData(self.this, index, src, size) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, offset) } }
	fn set_vertex_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, 0) } }
	fn set_vertex_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_vertex_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_vertex_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn index_data(&mut self, format: Format, size: usize) -> *mut c_void { unsafe { tsCommand_getIndexData(self.this, format, size) } }
	fn set_index_data(&mut self, format: Format, src: *const c_void, size: usize) { unsafe { tsCommand_setIndexData(self.this, format, src, size) } }
	fn set_index_buffer(&mut self, format: Format, buffer: &mut Buffer) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, format: Format, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, offset) } }
	fn set_index_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndexOffset(self.this, offset, 0) } }
	fn set_index_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndexOffset(self.this, offset, if relative {1} else {0}) } }
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCommand_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCommand_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn set_blend_color(&mut self, color: &Color) { unsafe { tsCommand_setBlendColor_cC(self.this, color) } }
	fn set_blend_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCommand_setBlendColor_ffff(self.this, r, g, b, a) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCommand_setStencilRef(self.this, ref_) } }
	fn draw_arrays(&mut self, num_vertices: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, 0) } }
	fn draw_arrays_with_basevertex(&mut self, num_vertices: u32, base_vertex: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, base_vertex) } }
	fn draw_arrays_instanced(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, 0) } }
	fn draw_arrays_instanced_with_baseinstance(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, base_instance) } }
	fn draw_arrays_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, 16) } }
	fn draw_arrays_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, stride) } }
	fn draw_arrays_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_arrays_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_elements(&mut self, num_indices: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, 0, 0) } }
	fn draw_elements_with_baseindex(&mut self, num_indices: u32, base_index: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, 0) } }
	fn draw_elements_with_baseindex_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, base_vertex) } }
	fn draw_elements_instanced(&mut self, num_indices: u32, base_index: u32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuu(self.this, num_indices, base_index, num_instances) } }
	fn draw_elements_instanced_with_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, 0) } }
	fn draw_elements_instanced_with_basevertex_baseinstance(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, base_instance) } }
	fn draw_elements_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, 20) } }
	fn draw_elements_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, stride) } }
	fn draw_elements_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 20) } }
	fn draw_elements_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_mesh(&mut self, width: u32) { unsafe { tsCommand_drawMesh(self.this, width, 1, 1) } }
	fn draw_mesh_with_height(&mut self, width: u32, height: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, 1) } }
	fn draw_mesh_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, depth) } }
	fn draw_mesh_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, 16) } }
	fn draw_mesh_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, stride) } }
	fn draw_mesh_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_mesh_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCommand_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCommand_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCommand_endQuery(self.this, query.this) } }
}
impl Drop for MTLCommand {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLCommand_delete(self.this) } } }
}
impl Clone for MTLCommand {
	fn clone(&self) -> MTLCommand { unsafe { MTLCommand { this: tsMTLCommand_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLCommand { }
impl fmt::Display for MTLCommand {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLCommand ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLCommand_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLCommand_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLCommand_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLCommand_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLCommand_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLCommand_new() -> *mut c_void;
	fn tsMTLCommand_delete(this: *mut c_void);
	fn tsMTLCommand_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLCommand_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCommand_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCommand_clearPtr(this: *const c_void);
	fn tsMTLCommand_destroyPtr(this: *const c_void);
	fn tsMTLCommand_acquirePtr(this: *const c_void);
	fn tsMTLCommand_unacquirePtr(this: *const c_void);
	fn tsMTLCommand_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLCommand_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLCommand_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLCommand_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLCommand_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCommand_equalCommandPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLCommand_castCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCommand_baseCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCommand_getEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLCommand_flush_prb(this: *mut c_void, encoder: *mut c_void, enqueue: i32);
	fn tsMTLCommand_flush_bb(this: *mut c_void, create: i32, enqueue: i32);
	fn tsMTLCommand_update(this: *mut c_void);
}

// Tellusim::VKCommand
pub struct VKCommand {
	this: *mut c_void,
	owner: bool,
}
impl VKCommand {
	pub fn null() -> VKCommand { VKCommand { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKCommand { unsafe { VKCommand { this: tsVKCommand_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKCommand { unsafe { VKCommand { this: ptr, owner: tsVKCommand_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKCommand { unsafe { VKCommand { this: tsVKCommand_copyPtr(self.this), owner: true } } }
	pub fn from_command(ptr: &Command) -> VKCommand { unsafe { VKCommand::new_ptr(tsVKCommand_castCommandPtr(ptr.this)) } }
	pub fn to_command(&self) -> Command { unsafe { Command::new_ptr(tsVKCommand_baseCommandPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKCommand) -> bool { unsafe { tsVKCommand_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKCommand { unsafe { VKCommand { this: tsVKCommand_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKCommand_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKCommand_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKCommand_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKCommand_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKCommand_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKCommand_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKCommand_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKCommand_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKCommand_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn vk_command(&self) -> *const c_void { unsafe { tsVKCommand_getVKCommand(self.this) } }
	pub fn sampler_descriptor(&self) -> *const c_void { unsafe { tsVKCommand_getSamplerDescriptor(self.this) } }
	pub fn image_descriptor(&self) -> *const c_void { unsafe { tsVKCommand_getImageDescriptor(self.this) } }
	pub fn buffer_descriptor(&self) -> *const c_void { unsafe { tsVKCommand_getBufferDescriptor(self.this) } }
	pub fn tracing_descriptor(&self) -> *const c_void { unsafe { tsVKCommand_getTracingDescriptor(self.this) } }
	pub fn texel_descriptor(&self) -> *const c_void { unsafe { tsVKCommand_getTexelDescriptor(self.this) } }
	pub fn update(&mut self) { unsafe { tsVKCommand_update(self.this) } }
}
impl CommandTrait for VKCommand {
	fn platform(&self) -> Platform { unsafe { tsCommand_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCommand_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCommand_getIndex(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCommand_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCommand_getPipeline(self.this)) } }
	fn set_viewport(&mut self, index: u32, viewport: &Viewport) { unsafe { tsCommand_setViewport(self.this, index, viewport) } }
	fn set_viewports(&mut self, viewports: &[Viewport]) { unsafe { tsCommand_setViewports(self.this, viewports.as_ptr(), viewports.len() as u32) } }
	fn set_scissor(&mut self, index: u32, scissor: &Scissor) { unsafe { tsCommand_setScissor(self.this, index, scissor) } }
	fn set_scissors(&mut self, scissors: &[Scissor]) { unsafe { tsCommand_setScissors(self.this, scissors.as_ptr(), scissors.len() as u32) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCommand_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCommand_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCommand_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCommand_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCommand_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCommand_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn vertex_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getVertexData(self.this, index, size) } }
	fn set_vertex_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setVertexData(self.this, index, src, size) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, offset) } }
	fn set_vertex_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, 0) } }
	fn set_vertex_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_vertex_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_vertex_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn index_data(&mut self, format: Format, size: usize) -> *mut c_void { unsafe { tsCommand_getIndexData(self.this, format, size) } }
	fn set_index_data(&mut self, format: Format, src: *const c_void, size: usize) { unsafe { tsCommand_setIndexData(self.this, format, src, size) } }
	fn set_index_buffer(&mut self, format: Format, buffer: &mut Buffer) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, format: Format, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, offset) } }
	fn set_index_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndexOffset(self.this, offset, 0) } }
	fn set_index_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndexOffset(self.this, offset, if relative {1} else {0}) } }
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCommand_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCommand_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn set_blend_color(&mut self, color: &Color) { unsafe { tsCommand_setBlendColor_cC(self.this, color) } }
	fn set_blend_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCommand_setBlendColor_ffff(self.this, r, g, b, a) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCommand_setStencilRef(self.this, ref_) } }
	fn draw_arrays(&mut self, num_vertices: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, 0) } }
	fn draw_arrays_with_basevertex(&mut self, num_vertices: u32, base_vertex: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, base_vertex) } }
	fn draw_arrays_instanced(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, 0) } }
	fn draw_arrays_instanced_with_baseinstance(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, base_instance) } }
	fn draw_arrays_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, 16) } }
	fn draw_arrays_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, stride) } }
	fn draw_arrays_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_arrays_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_elements(&mut self, num_indices: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, 0, 0) } }
	fn draw_elements_with_baseindex(&mut self, num_indices: u32, base_index: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, 0) } }
	fn draw_elements_with_baseindex_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, base_vertex) } }
	fn draw_elements_instanced(&mut self, num_indices: u32, base_index: u32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuu(self.this, num_indices, base_index, num_instances) } }
	fn draw_elements_instanced_with_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, 0) } }
	fn draw_elements_instanced_with_basevertex_baseinstance(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, base_instance) } }
	fn draw_elements_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, 20) } }
	fn draw_elements_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, stride) } }
	fn draw_elements_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 20) } }
	fn draw_elements_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_mesh(&mut self, width: u32) { unsafe { tsCommand_drawMesh(self.this, width, 1, 1) } }
	fn draw_mesh_with_height(&mut self, width: u32, height: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, 1) } }
	fn draw_mesh_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, depth) } }
	fn draw_mesh_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, 16) } }
	fn draw_mesh_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, stride) } }
	fn draw_mesh_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_mesh_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCommand_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCommand_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCommand_endQuery(self.this, query.this) } }
}
impl Drop for VKCommand {
	fn drop(&mut self) { if self.owner { unsafe { tsVKCommand_delete(self.this) } } }
}
impl Clone for VKCommand {
	fn clone(&self) -> VKCommand { unsafe { VKCommand { this: tsVKCommand_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKCommand { }
impl fmt::Display for VKCommand {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKCommand ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKCommand_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKCommand_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKCommand_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKCommand_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKCommand_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKCommand_new() -> *mut c_void;
	fn tsVKCommand_delete(this: *mut c_void);
	fn tsVKCommand_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKCommand_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKCommand_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKCommand_clearPtr(this: *const c_void);
	fn tsVKCommand_destroyPtr(this: *const c_void);
	fn tsVKCommand_acquirePtr(this: *const c_void);
	fn tsVKCommand_unacquirePtr(this: *const c_void);
	fn tsVKCommand_isValidPtr(this: *const c_void) -> i32;
	fn tsVKCommand_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKCommand_isConstPtr(this: *const c_void) -> i32;
	fn tsVKCommand_getCountPtr(this: *const c_void) -> u32;
	fn tsVKCommand_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKCommand_equalCommandPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKCommand_castCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsVKCommand_baseCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsVKCommand_getVKCommand(this: *const c_void) -> *const c_void;
	fn tsVKCommand_getSamplerDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCommand_getImageDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCommand_getBufferDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCommand_getTracingDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCommand_getTexelDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCommand_update(this: *mut c_void);
}

// Tellusim::FUCommand
pub struct FUCommand {
	this: *mut c_void,
	owner: bool,
}
impl FUCommand {
	pub fn null() -> FUCommand { FUCommand { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUCommand { unsafe { FUCommand { this: tsFUCommand_new(), owner: true } } }
	pub fn new_with_commands(commands: &[&mut Command]) -> FUCommand {
		let mut commands_ = Vec::new();
		for ptr in commands { commands_.push(ptr.this); }
		unsafe { FUCommand { this: tsFUCommand_new_cACb(commands_.as_ptr(), commands.len() as u32, 0), owner: true } }
	}
	pub fn new_with_commands_owner(commands: &[&mut Command], owner: bool) -> FUCommand {
		let mut commands_ = Vec::new();
		for ptr in commands { commands_.push(ptr.this); }
		unsafe { FUCommand { this: tsFUCommand_new_cACb(commands_.as_ptr(), commands.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUCommand { unsafe { FUCommand { this: ptr, owner: tsFUCommand_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUCommand { unsafe { FUCommand { this: tsFUCommand_copyPtr(self.this), owner: true } } }
	pub fn from_command(ptr: &Command) -> FUCommand { unsafe { FUCommand::new_ptr(tsFUCommand_castCommandPtr(ptr.this)) } }
	pub fn to_command(&self) -> Command { unsafe { Command::new_ptr(tsFUCommand_baseCommandPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUCommand) -> bool { unsafe { tsFUCommand_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUCommand { unsafe { FUCommand { this: tsFUCommand_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUCommand_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUCommand_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUCommand_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUCommand_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUCommand_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUCommand_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUCommand_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUCommand_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUCommand_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUCommand_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUCommand_getMask(self.this) } }
	pub fn num_commands(&self) -> u32 { unsafe { tsFUCommand_getNumCommands(self.this) } }
	pub fn command(&self, index: u32) -> Command { unsafe { Command::new_ptr(tsFUCommand_getCommand_cu(self.this, index)) } }
	pub fn command_mut(&mut self, index: u32) -> Command { unsafe { Command::new_ptr(tsFUCommand_getCommand_u(self.this, index)) } }
}
impl CommandTrait for FUCommand {
	fn platform(&self) -> Platform { unsafe { tsCommand_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCommand_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCommand_getIndex(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCommand_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCommand_getPipeline(self.this)) } }
	fn set_viewport(&mut self, index: u32, viewport: &Viewport) { unsafe { tsCommand_setViewport(self.this, index, viewport) } }
	fn set_viewports(&mut self, viewports: &[Viewport]) { unsafe { tsCommand_setViewports(self.this, viewports.as_ptr(), viewports.len() as u32) } }
	fn set_scissor(&mut self, index: u32, scissor: &Scissor) { unsafe { tsCommand_setScissor(self.this, index, scissor) } }
	fn set_scissors(&mut self, scissors: &[Scissor]) { unsafe { tsCommand_setScissors(self.this, scissors.as_ptr(), scissors.len() as u32) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCommand_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCommand_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCommand_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCommand_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCommand_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCommand_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCommand_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCommand_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCommand_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCommand_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCommand_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn vertex_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCommand_getVertexData(self.this, index, size) } }
	fn set_vertex_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCommand_setVertexData(self.this, index, src, size) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setVertexBuffer(self.this, index, buffer.this, offset) } }
	fn set_vertex_offset(&mut self, index: u32, offset: usize) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, 0) } }
	fn set_vertex_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCommand_setVertexOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_vertex_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_vertex_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCommand_setVertexBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn index_data(&mut self, format: Format, size: usize) -> *mut c_void { unsafe { tsCommand_getIndexData(self.this, format, size) } }
	fn set_index_data(&mut self, format: Format, src: *const c_void, size: usize) { unsafe { tsCommand_setIndexData(self.this, format, src, size) } }
	fn set_index_buffer(&mut self, format: Format, buffer: &mut Buffer) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, format: Format, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndexBuffer(self.this, format, buffer.this, offset) } }
	fn set_index_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndexOffset(self.this, offset, 0) } }
	fn set_index_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndexOffset(self.this, offset, if relative {1} else {0}) } }
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCommand_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCommand_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCommand_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCommand_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn set_blend_color(&mut self, color: &Color) { unsafe { tsCommand_setBlendColor_cC(self.this, color) } }
	fn set_blend_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCommand_setBlendColor_ffff(self.this, r, g, b, a) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCommand_setStencilRef(self.this, ref_) } }
	fn draw_arrays(&mut self, num_vertices: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, 0) } }
	fn draw_arrays_with_basevertex(&mut self, num_vertices: u32, base_vertex: u32) { unsafe { tsCommand_drawArrays(self.this, num_vertices, base_vertex) } }
	fn draw_arrays_instanced(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, 0) } }
	fn draw_arrays_instanced_with_baseinstance(&mut self, num_vertices: u32, base_vertex: u32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawArraysInstanced(self.this, num_vertices, base_vertex, num_instances, base_instance) } }
	fn draw_arrays_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, 16) } }
	fn draw_arrays_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_uz(self.this, num_draws, stride) } }
	fn draw_arrays_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_arrays_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawArraysIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_elements(&mut self, num_indices: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, 0, 0) } }
	fn draw_elements_with_baseindex(&mut self, num_indices: u32, base_index: u32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, 0) } }
	fn draw_elements_with_baseindex_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32) { unsafe { tsCommand_drawElements(self.this, num_indices, base_index, base_vertex) } }
	fn draw_elements_instanced(&mut self, num_indices: u32, base_index: u32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuu(self.this, num_indices, base_index, num_instances) } }
	fn draw_elements_instanced_with_basevertex(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, 0) } }
	fn draw_elements_instanced_with_basevertex_baseinstance(&mut self, num_indices: u32, base_index: u32, base_vertex: i32, num_instances: u32, base_instance: u32) { unsafe { tsCommand_drawElementsInstanced_uuiuu(self.this, num_indices, base_index, base_vertex, num_instances, base_instance) } }
	fn draw_elements_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, 20) } }
	fn draw_elements_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_uz(self.this, num_draws, stride) } }
	fn draw_elements_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 20) } }
	fn draw_elements_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawElementsIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn draw_mesh(&mut self, width: u32) { unsafe { tsCommand_drawMesh(self.this, width, 1, 1) } }
	fn draw_mesh_with_height(&mut self, width: u32, height: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, 1) } }
	fn draw_mesh_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCommand_drawMesh(self.this, width, height, depth) } }
	fn draw_mesh_indirect(&mut self, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, 16) } }
	fn draw_mesh_indirect_with_stride(&mut self, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_uz(self.this, num_draws, stride) } }
	fn draw_mesh_indirect_with_buffer(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, 16) } }
	fn draw_mesh_indirect_with_buffer_stride(&mut self, buffer: &mut Buffer, offset: usize, num_draws: u32, stride: usize) { unsafe { tsCommand_drawMeshIndirect_Bzuz(self.this, buffer.this, offset, num_draws, stride) } }
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCommand_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCommand_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCommand_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCommand_endQuery(self.this, query.this) } }
}
impl Drop for FUCommand {
	fn drop(&mut self) { if self.owner { unsafe { tsFUCommand_delete(self.this) } } }
}
impl Clone for FUCommand {
	fn clone(&self) -> FUCommand { unsafe { FUCommand { this: tsFUCommand_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUCommand { }
impl fmt::Display for FUCommand {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUCommand ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUCommand_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUCommand_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUCommand_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUCommand_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUCommand_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUCommand_new() -> *mut c_void;
	fn tsFUCommand_new_cACb(commands: *const *mut c_void, commands_size: u32, owner: i32) -> *mut c_void;
	fn tsFUCommand_delete(this: *mut c_void);
	fn tsFUCommand_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUCommand_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUCommand_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUCommand_clearPtr(this: *const c_void);
	fn tsFUCommand_destroyPtr(this: *const c_void);
	fn tsFUCommand_acquirePtr(this: *const c_void);
	fn tsFUCommand_unacquirePtr(this: *const c_void);
	fn tsFUCommand_isValidPtr(this: *const c_void) -> i32;
	fn tsFUCommand_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUCommand_isConstPtr(this: *const c_void) -> i32;
	fn tsFUCommand_getCountPtr(this: *const c_void) -> u32;
	fn tsFUCommand_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUCommand_equalCommandPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUCommand_castCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsFUCommand_baseCommandPtr(this: *const c_void) -> *mut c_void;
	fn tsFUCommand_setMask(this: *mut c_void, mask: u32);
	fn tsFUCommand_getMask(this: *const c_void) -> u32;
	fn tsFUCommand_getNumCommands(this: *const c_void) -> u32;
	fn tsFUCommand_getCommand_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUCommand_getCommand_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Compute
pub struct Compute {
	this: *mut c_void,
	owner: bool,
}
impl Compute {
	pub fn null() -> Compute { Compute { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Compute { unsafe { Compute { this: tsCompute_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Compute { unsafe { Compute { this: ptr, owner: tsCompute_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Compute { unsafe { Compute { this: tsCompute_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Compute) -> bool { unsafe { tsCompute_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Compute { unsafe { Compute { this: tsCompute_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCompute_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCompute_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCompute_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCompute_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCompute_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCompute_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCompute_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCompute_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCompute_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ComputeTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn set_kernel(&mut self, kernel: &mut Kernel);
	fn kernel(&self) -> Kernel;
	fn set_traversal(&mut self, traversal: &mut Traversal);
	fn traversal(&self) -> Traversal;
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler);
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]);
	fn set_texture_with_index(&mut self, index: u32, texture: &mut Texture);
	fn set_texture_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>);
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]);
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture);
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>);
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format);
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]);
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void;
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize);
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize);
	fn set_uniform_offset(&mut self, index: u32, offset: usize);
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool);
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]);
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void;
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize);
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize);
	fn set_storage_offset(&mut self, index: u32, offset: usize);
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool);
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]);
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing);
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]);
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]);
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable);
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]);
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable);
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]);
	fn indirect_data(&mut self, size: usize) -> *mut c_void;
	fn set_indirect_data(&mut self, src: *const c_void, size: usize);
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer);
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize);
	fn set_indirect_offset(&mut self, offset: usize);
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool);
	fn dispatch_with_width(&mut self, width: u32);
	fn dispatch_with_width_height(&mut self, width: u32, height: u32);
	fn dispatch_with_width_height_depth(&mut self, width: u32, height: u32, depth: u32);
	fn dispatch(&mut self, texture: &Texture);
	fn dispatch_with_size(&mut self, size: &Size);
	fn dispatch_indirect(&mut self);
	fn set_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool;
	fn set_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool;
	fn set_buffer_with_src(&mut self, buffer: &mut Buffer, src: *const c_void) -> bool;
	fn copy_buffer_with_destoffset_srcoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool;
	fn copy_buffer_with_destoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool;
	fn copy_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool;
	fn copy_buffer_with_src(&mut self, buffer: &mut Buffer, src: &mut Buffer) -> bool;
	fn clear_buffer_with_format_offset(&mut self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool;
	fn clear_buffer_with_format_src_size(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool;
	fn clear_buffer_with_format_src(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool;
	fn clear_buffer(&mut self, buffer: &mut Buffer) -> bool;
	fn set_texture_with_texture_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool;
	fn set_texture_with_texture_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool;
	fn set_texture_with_texture_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool;
	fn set_texture_with_texture_image(&mut self, texture: &mut Texture, image: &Image) -> bool;
	fn copy_texture_with_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool;
	fn copy_texture_with_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool;
	fn copy_texture_with_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool;
	fn copy_texture_with_src(&mut self, texture: &mut Texture, src: &mut Texture) -> bool;
	fn clear_texture_with_region_slice(&mut self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool;
	fn clear_texture_with_region(&mut self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool;
	fn clear_texture_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool;
	fn clear_texture_with_src(&mut self, texture: &mut Texture, src: *const c_void) -> bool;
	fn barrier(&mut self, texture: &mut Texture);
	fn barrier_with_buffer(&mut self, buffer: &mut Buffer);
	fn barrier_with_textures(&mut self, textures: &[&mut Texture]);
	fn barrier_with_buffers(&mut self, buffers: &[&mut Buffer]);
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize);
	fn end_conditional(&mut self);
	fn begin_query(&mut self, query: &mut Query) -> bool;
	fn end_query(&mut self, query: &mut Query);
}
impl ComputeTrait for Compute {
	fn platform(&self) -> Platform { unsafe { tsCompute_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCompute_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCompute_getIndex(self.this) } }
	fn set_kernel(&mut self, kernel: &mut Kernel) { unsafe { tsCompute_setKernel(self.this, kernel.this) } }
	fn kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsCompute_getKernel(self.this)) } }
	fn set_traversal(&mut self, traversal: &mut Traversal) { unsafe { tsCompute_setTraversal(self.this, traversal.this) } }
	fn traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsCompute_getTraversal(self.this)) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCompute_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCompute_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCompute_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCompute_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCompute_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCompute_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCompute_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCompute_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCompute_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCompute_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn dispatch_with_width(&mut self, width: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, 1, 1) } }
	fn dispatch_with_width_height(&mut self, width: u32, height: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, 1) } }
	fn dispatch_with_width_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, depth) } }
	fn dispatch(&mut self, texture: &Texture) { unsafe { tsCompute_dispatch_cT(self.this, texture.this) } }
	fn dispatch_with_size(&mut self, size: &Size) { unsafe { tsCompute_dispatch_cS(self.this, size) } }
	fn dispatch_indirect(&mut self) { unsafe { tsCompute_dispatchIndirect(self.this) } }
	fn set_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&mut self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsCompute_setBuffer_Bp(self.this, buffer.this, src) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&mut self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsCompute_copyBuffer_BB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&mut self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsCompute_clearBuffer_BFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&mut self, buffer: &mut Buffer) -> bool { unsafe { tsCompute_clearBuffer_B(self.this, buffer.this) != 0 } }
	fn set_texture_with_texture_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_texture_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_texture_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_texture_image(&mut self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsCompute_copyTexture_TcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&mut self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsCompute_copyTexture_TT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&mut self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&mut self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_TcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&mut self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_Tp(self.this, texture.this, src) != 0 } }
	fn barrier(&mut self, texture: &mut Texture) { unsafe { tsCompute_barrier_T(self.this, texture.this) } }
	fn barrier_with_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_barrier_B(self.this, buffer.this) } }
	fn barrier_with_textures(&mut self, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAT(self.this, textures_.as_ptr(), textures.len() as u32) }
	}
	fn barrier_with_buffers(&mut self, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAB(self.this, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCompute_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCompute_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCompute_endQuery(self.this, query.this) } }
}
impl Drop for Compute {
	fn drop(&mut self) { if self.owner { unsafe { tsCompute_delete(self.this) } } }
}
impl Clone for Compute {
	fn clone(&self) -> Compute { unsafe { Compute { this: tsCompute_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Compute { }
impl fmt::Display for Compute {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Compute ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCompute_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCompute_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCompute_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCompute_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCompute_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCompute_new() -> *mut c_void;
	fn tsCompute_delete(this: *mut c_void);
	fn tsCompute_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCompute_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCompute_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCompute_clearPtr(this: *const c_void);
	fn tsCompute_destroyPtr(this: *const c_void);
	fn tsCompute_acquirePtr(this: *const c_void);
	fn tsCompute_unacquirePtr(this: *const c_void);
	fn tsCompute_isValidPtr(this: *const c_void) -> i32;
	fn tsCompute_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCompute_isConstPtr(this: *const c_void) -> i32;
	fn tsCompute_getCountPtr(this: *const c_void) -> u32;
	fn tsCompute_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCompute_getPlatform(this: *const c_void) -> Platform;
	fn tsCompute_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsCompute_getIndex(this: *const c_void) -> u32;
	fn tsCompute_setKernel(this: *mut c_void, kernel: *mut c_void);
	fn tsCompute_getKernel(this: *const c_void) -> *mut c_void;
	fn tsCompute_setTraversal(this: *mut c_void, traversal: *mut c_void);
	fn tsCompute_getTraversal(this: *const c_void) -> *mut c_void;
	fn tsCompute_setSampler(this: *mut c_void, index: u32, sampler: *mut c_void);
	fn tsCompute_setSamplers_ucAS(this: *mut c_void, index: u32, samplers: *const *mut c_void, samplers_size: u32);
	fn tsCompute_setTexture_uT(this: *mut c_void, index: u32, texture: *mut c_void);
	fn tsCompute_setTexture_uTcS(this: *mut c_void, index: u32, texture: *mut c_void, slice: *const Slice);
	fn tsCompute_setTextures_ucAT(this: *mut c_void, index: u32, textures: *const *mut c_void, textures_size: u32);
	fn tsCompute_setSurfaceTexture_uT(this: *mut c_void, index: u32, texture: *mut c_void);
	fn tsCompute_setSurfaceTexture_uTcSF(this: *mut c_void, index: u32, texture: *mut c_void, slice: *const Slice, format: Format);
	fn tsCompute_setSurfaceTextures_ucAT(this: *mut c_void, index: u32, textures: *const *mut c_void, textures_size: u32);
	fn tsCompute_getUniformData(this: *mut c_void, index: u32, size: usize) -> *mut c_void;
	fn tsCompute_setUniformData(this: *mut c_void, index: u32, src: *const c_void, size: usize);
	fn tsCompute_setUniformBuffer(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize, size: usize);
	fn tsCompute_setUniformOffset(this: *mut c_void, index: u32, offset: usize, relative: i32);
	fn tsCompute_setUniformBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCompute_setUniformBuffers_ucABcA(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32, offsets: *const usize, offsets_size: u32);
	fn tsCompute_getStorageData(this: *mut c_void, index: u32, size: usize) -> *mut c_void;
	fn tsCompute_setStorageData(this: *mut c_void, index: u32, src: *const c_void, size: usize);
	fn tsCompute_setStorageBuffer(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize, size: usize);
	fn tsCompute_setStorageOffset(this: *mut c_void, index: u32, offset: usize, relative: i32);
	fn tsCompute_setStorageBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCompute_setStorageBuffers_ucABcA(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32, offsets: *const usize, offsets_size: u32);
	fn tsCompute_setTracing(this: *mut c_void, index: u32, tracing: *mut c_void);
	fn tsCompute_setTracings_ucAT(this: *mut c_void, index: u32, tracings: *const *mut c_void, tracings_size: u32);
	fn tsCompute_setTexelBuffer(this: *mut c_void, index: u32, buffer: *mut c_void);
	fn tsCompute_setTexelBuffers_ucAB(this: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCompute_setTextureTable(this: *mut c_void, index: u32, table: *mut c_void);
	fn tsCompute_setTextureTables_ucATT(this: *mut c_void, index: u32, tables: *const *mut c_void, tables_size: u32);
	fn tsCompute_setStorageTable(this: *mut c_void, index: u32, table: *mut c_void);
	fn tsCompute_setStorageTables_ucABT(this: *mut c_void, index: u32, tables: *const *mut c_void, tables_size: u32);
	fn tsCompute_getIndirectData(this: *mut c_void, size: usize) -> *mut c_void;
	fn tsCompute_setIndirectData(this: *mut c_void, src: *const c_void, size: usize);
	fn tsCompute_setIndirectBuffer(this: *mut c_void, buffer: *mut c_void, offset: usize);
	fn tsCompute_setIndirectOffset(this: *mut c_void, offset: usize, relative: i32);
	fn tsCompute_dispatch_uuu(this: *mut c_void, width: u32, height: u32, depth: u32);
	fn tsCompute_dispatch_cT(this: *mut c_void, texture: *mut c_void);
	fn tsCompute_dispatch_cS(this: *mut c_void, size: *const Size);
	fn tsCompute_dispatchIndirect(this: *mut c_void);
	fn tsCompute_setBuffer_Bzpz(this: *mut c_void, buffer: *mut c_void, offset: usize, src: *const c_void, size: usize) -> i32;
	fn tsCompute_setBuffer_Bpz(this: *mut c_void, buffer: *mut c_void, src: *const c_void, size: usize) -> i32;
	fn tsCompute_setBuffer_Bp(this: *mut c_void, buffer: *mut c_void, src: *const c_void) -> i32;
	fn tsCompute_copyBuffer_BzBzz(this: *mut c_void, buffer: *mut c_void, dest_offset: usize, src: *mut c_void, src_offset: usize, size: usize) -> i32;
	fn tsCompute_copyBuffer_BzBz(this: *mut c_void, buffer: *mut c_void, dest_offset: usize, src: *mut c_void, size: usize) -> i32;
	fn tsCompute_copyBuffer_BBz(this: *mut c_void, buffer: *mut c_void, src: *mut c_void, size: usize) -> i32;
	fn tsCompute_copyBuffer_BB(this: *mut c_void, buffer: *mut c_void, src: *mut c_void) -> i32;
	fn tsCompute_clearBuffer_BFzpz(this: *mut c_void, buffer: *mut c_void, format: Format, offset: usize, src: *const c_void, size: usize) -> i32;
	fn tsCompute_clearBuffer_BFpz(this: *mut c_void, buffer: *mut c_void, format: Format, src: *const c_void, size: usize) -> i32;
	fn tsCompute_clearBuffer_BFp(this: *mut c_void, buffer: *mut c_void, format: Format, src: *const c_void) -> i32;
	fn tsCompute_clearBuffer_B(this: *mut c_void, buffer: *mut c_void) -> i32;
	fn tsCompute_setTexture_TcOcScIcS(this: *mut c_void, texture: *mut c_void, dest_origin: *const Origin, dest_slice: *const Slice, image: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsCompute_setTexture_TcOcI(this: *mut c_void, texture: *mut c_void, dest_origin: *const Origin, image: *mut c_void) -> i32;
	fn tsCompute_setTexture_TcScI(this: *mut c_void, texture: *mut c_void, dest_slice: *const Slice, image: *mut c_void) -> i32;
	fn tsCompute_setTexture_TcI(this: *mut c_void, texture: *mut c_void, image: *mut c_void) -> i32;
	fn tsCompute_copyTexture_TcOcSTcRcS(this: *mut c_void, texture: *mut c_void, dest_origin: *const Origin, dest_slice: *const Slice, src: *mut c_void, src_region: *const Region, src_slice: *const Slice) -> i32;
	fn tsCompute_copyTexture_TcOTcR(this: *mut c_void, texture: *mut c_void, dest_origin: *const Origin, src: *mut c_void, src_region: *const Region) -> i32;
	fn tsCompute_copyTexture_TcSTcS(this: *mut c_void, texture: *mut c_void, dest_slice: *const Slice, src: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsCompute_copyTexture_TT(this: *mut c_void, texture: *mut c_void, src: *mut c_void) -> i32;
	fn tsCompute_clearTexture_TcRcSp(this: *mut c_void, texture: *mut c_void, region: *const Region, slice: *const Slice, src: *const c_void) -> i32;
	fn tsCompute_clearTexture_TcRp(this: *mut c_void, texture: *mut c_void, region: *const Region, src: *const c_void) -> i32;
	fn tsCompute_clearTexture_TcSp(this: *mut c_void, texture: *mut c_void, slice: *const Slice, src: *const c_void) -> i32;
	fn tsCompute_clearTexture_Tp(this: *mut c_void, texture: *mut c_void, src: *const c_void) -> i32;
	fn tsCompute_barrier_T(this: *mut c_void, texture: *mut c_void);
	fn tsCompute_barrier_B(this: *mut c_void, buffer: *mut c_void);
	fn tsCompute_barrier_cAT(this: *mut c_void, textures: *const *mut c_void, textures_size: u32);
	fn tsCompute_barrier_cAB(this: *mut c_void, buffers: *const *mut c_void, buffers_size: u32);
	fn tsCompute_beginConditional(this: *mut c_void, buffer: *mut c_void, offset: usize);
	fn tsCompute_endConditional(this: *mut c_void);
	fn tsCompute_beginQuery(this: *mut c_void, query: *mut c_void) -> i32;
	fn tsCompute_endQuery(this: *mut c_void, query: *mut c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ComputeDispatchIndirect {
	pub group_width: u32,
	pub group_height: u32,
	pub group_depth: u32,
	pub padding: u32,
}
impl fmt::Display for ComputeDispatchIndirect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("group_width: {0}\n", self.group_width);
		ret += &format!("group_height: {0}\n", self.group_height);
		ret += &format!("group_depth: {0}\n", self.group_depth);
		write!(f, "{0}", ret)
	}
}

// Tellusim::D3D12Compute
pub struct D3D12Compute {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Compute {
	pub fn null() -> D3D12Compute { D3D12Compute { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Compute { unsafe { D3D12Compute { this: tsD3D12Compute_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Compute { unsafe { D3D12Compute { this: ptr, owner: tsD3D12Compute_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Compute { unsafe { D3D12Compute { this: tsD3D12Compute_copyPtr(self.this), owner: true } } }
	pub fn from_compute(ptr: &Compute) -> D3D12Compute { unsafe { D3D12Compute::new_ptr(tsD3D12Compute_castComputePtr(ptr.this)) } }
	pub fn to_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsD3D12Compute_baseComputePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Compute) -> bool { unsafe { tsD3D12Compute_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Compute { unsafe { D3D12Compute { this: tsD3D12Compute_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Compute_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Compute_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Compute_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Compute_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Compute_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Compute_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Compute_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Compute_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Compute_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn command(&self) -> *const c_void { unsafe { tsD3D12Compute_getCommand(self.this) } }
	pub fn update(&mut self) { unsafe { tsD3D12Compute_update(self.this) } }
}
impl ComputeTrait for D3D12Compute {
	fn platform(&self) -> Platform { unsafe { tsCompute_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCompute_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCompute_getIndex(self.this) } }
	fn set_kernel(&mut self, kernel: &mut Kernel) { unsafe { tsCompute_setKernel(self.this, kernel.this) } }
	fn kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsCompute_getKernel(self.this)) } }
	fn set_traversal(&mut self, traversal: &mut Traversal) { unsafe { tsCompute_setTraversal(self.this, traversal.this) } }
	fn traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsCompute_getTraversal(self.this)) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCompute_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCompute_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCompute_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCompute_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCompute_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCompute_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCompute_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCompute_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCompute_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCompute_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn dispatch_with_width(&mut self, width: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, 1, 1) } }
	fn dispatch_with_width_height(&mut self, width: u32, height: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, 1) } }
	fn dispatch_with_width_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, depth) } }
	fn dispatch(&mut self, texture: &Texture) { unsafe { tsCompute_dispatch_cT(self.this, texture.this) } }
	fn dispatch_with_size(&mut self, size: &Size) { unsafe { tsCompute_dispatch_cS(self.this, size) } }
	fn dispatch_indirect(&mut self) { unsafe { tsCompute_dispatchIndirect(self.this) } }
	fn set_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&mut self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsCompute_setBuffer_Bp(self.this, buffer.this, src) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&mut self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsCompute_copyBuffer_BB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&mut self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsCompute_clearBuffer_BFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&mut self, buffer: &mut Buffer) -> bool { unsafe { tsCompute_clearBuffer_B(self.this, buffer.this) != 0 } }
	fn set_texture_with_texture_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_texture_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_texture_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_texture_image(&mut self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsCompute_copyTexture_TcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&mut self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsCompute_copyTexture_TT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&mut self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&mut self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_TcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&mut self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_Tp(self.this, texture.this, src) != 0 } }
	fn barrier(&mut self, texture: &mut Texture) { unsafe { tsCompute_barrier_T(self.this, texture.this) } }
	fn barrier_with_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_barrier_B(self.this, buffer.this) } }
	fn barrier_with_textures(&mut self, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAT(self.this, textures_.as_ptr(), textures.len() as u32) }
	}
	fn barrier_with_buffers(&mut self, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAB(self.this, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCompute_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCompute_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCompute_endQuery(self.this, query.this) } }
}
impl Drop for D3D12Compute {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Compute_delete(self.this) } } }
}
impl Clone for D3D12Compute {
	fn clone(&self) -> D3D12Compute { unsafe { D3D12Compute { this: tsD3D12Compute_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Compute { }
impl fmt::Display for D3D12Compute {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Compute ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Compute_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Compute_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Compute_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Compute_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Compute_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Compute_new() -> *mut c_void;
	fn tsD3D12Compute_delete(this: *mut c_void);
	fn tsD3D12Compute_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Compute_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Compute_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Compute_clearPtr(this: *const c_void);
	fn tsD3D12Compute_destroyPtr(this: *const c_void);
	fn tsD3D12Compute_acquirePtr(this: *const c_void);
	fn tsD3D12Compute_unacquirePtr(this: *const c_void);
	fn tsD3D12Compute_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Compute_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Compute_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Compute_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Compute_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Compute_equalComputePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Compute_castComputePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Compute_baseComputePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Compute_getCommand(this: *const c_void) -> *const c_void;
	fn tsD3D12Compute_update(this: *mut c_void);
}

// Tellusim::MTLCompute
pub struct MTLCompute {
	this: *mut c_void,
	owner: bool,
}
impl MTLCompute {
	pub fn null() -> MTLCompute { MTLCompute { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLCompute { unsafe { MTLCompute { this: tsMTLCompute_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLCompute { unsafe { MTLCompute { this: ptr, owner: tsMTLCompute_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLCompute { unsafe { MTLCompute { this: tsMTLCompute_copyPtr(self.this), owner: true } } }
	pub fn from_compute(ptr: &Compute) -> MTLCompute { unsafe { MTLCompute::new_ptr(tsMTLCompute_castComputePtr(ptr.this)) } }
	pub fn to_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsMTLCompute_baseComputePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLCompute) -> bool { unsafe { tsMTLCompute_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLCompute { unsafe { MTLCompute { this: tsMTLCompute_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLCompute_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLCompute_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLCompute_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLCompute_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLCompute_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLCompute_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLCompute_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLCompute_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLCompute_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn encoder(&self) -> *mut c_void { unsafe { tsMTLCompute_getEncoder(self.this) } }
	pub fn flush(&mut self, encoder: *mut c_void) { unsafe { tsMTLCompute_flush_prb(self.this, encoder, 0) } }
	pub fn flush_with_enqueue(&mut self, encoder: *mut c_void, enqueue: bool) { unsafe { tsMTLCompute_flush_prb(self.this, encoder, if enqueue {1} else {0}) } }
	pub fn flush_with_create(&mut self, create: bool) { unsafe { tsMTLCompute_flush_bb(self.this, if create {1} else {0}, 0) } }
	pub fn flush_with_create_enqueue(&mut self, create: bool, enqueue: bool) { unsafe { tsMTLCompute_flush_bb(self.this, if create {1} else {0}, if enqueue {1} else {0}) } }
	pub fn update(&mut self) { unsafe { tsMTLCompute_update(self.this) } }
}
impl ComputeTrait for MTLCompute {
	fn platform(&self) -> Platform { unsafe { tsCompute_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCompute_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCompute_getIndex(self.this) } }
	fn set_kernel(&mut self, kernel: &mut Kernel) { unsafe { tsCompute_setKernel(self.this, kernel.this) } }
	fn kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsCompute_getKernel(self.this)) } }
	fn set_traversal(&mut self, traversal: &mut Traversal) { unsafe { tsCompute_setTraversal(self.this, traversal.this) } }
	fn traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsCompute_getTraversal(self.this)) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCompute_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCompute_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCompute_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCompute_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCompute_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCompute_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCompute_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCompute_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCompute_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCompute_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn dispatch_with_width(&mut self, width: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, 1, 1) } }
	fn dispatch_with_width_height(&mut self, width: u32, height: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, 1) } }
	fn dispatch_with_width_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, depth) } }
	fn dispatch(&mut self, texture: &Texture) { unsafe { tsCompute_dispatch_cT(self.this, texture.this) } }
	fn dispatch_with_size(&mut self, size: &Size) { unsafe { tsCompute_dispatch_cS(self.this, size) } }
	fn dispatch_indirect(&mut self) { unsafe { tsCompute_dispatchIndirect(self.this) } }
	fn set_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&mut self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsCompute_setBuffer_Bp(self.this, buffer.this, src) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&mut self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsCompute_copyBuffer_BB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&mut self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsCompute_clearBuffer_BFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&mut self, buffer: &mut Buffer) -> bool { unsafe { tsCompute_clearBuffer_B(self.this, buffer.this) != 0 } }
	fn set_texture_with_texture_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_texture_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_texture_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_texture_image(&mut self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsCompute_copyTexture_TcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&mut self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsCompute_copyTexture_TT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&mut self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&mut self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_TcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&mut self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_Tp(self.this, texture.this, src) != 0 } }
	fn barrier(&mut self, texture: &mut Texture) { unsafe { tsCompute_barrier_T(self.this, texture.this) } }
	fn barrier_with_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_barrier_B(self.this, buffer.this) } }
	fn barrier_with_textures(&mut self, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAT(self.this, textures_.as_ptr(), textures.len() as u32) }
	}
	fn barrier_with_buffers(&mut self, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAB(self.this, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCompute_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCompute_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCompute_endQuery(self.this, query.this) } }
}
impl Drop for MTLCompute {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLCompute_delete(self.this) } } }
}
impl Clone for MTLCompute {
	fn clone(&self) -> MTLCompute { unsafe { MTLCompute { this: tsMTLCompute_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLCompute { }
impl fmt::Display for MTLCompute {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLCompute ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLCompute_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLCompute_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLCompute_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLCompute_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLCompute_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLCompute_new() -> *mut c_void;
	fn tsMTLCompute_delete(this: *mut c_void);
	fn tsMTLCompute_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLCompute_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCompute_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCompute_clearPtr(this: *const c_void);
	fn tsMTLCompute_destroyPtr(this: *const c_void);
	fn tsMTLCompute_acquirePtr(this: *const c_void);
	fn tsMTLCompute_unacquirePtr(this: *const c_void);
	fn tsMTLCompute_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLCompute_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLCompute_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLCompute_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLCompute_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCompute_equalComputePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLCompute_castComputePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCompute_baseComputePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLCompute_getEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLCompute_flush_prb(this: *mut c_void, encoder: *mut c_void, enqueue: i32);
	fn tsMTLCompute_flush_bb(this: *mut c_void, create: i32, enqueue: i32);
	fn tsMTLCompute_update(this: *mut c_void);
}

// Tellusim::VKCompute
pub struct VKCompute {
	this: *mut c_void,
	owner: bool,
}
impl VKCompute {
	pub fn null() -> VKCompute { VKCompute { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKCompute { unsafe { VKCompute { this: tsVKCompute_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKCompute { unsafe { VKCompute { this: ptr, owner: tsVKCompute_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKCompute { unsafe { VKCompute { this: tsVKCompute_copyPtr(self.this), owner: true } } }
	pub fn from_compute(ptr: &Compute) -> VKCompute { unsafe { VKCompute::new_ptr(tsVKCompute_castComputePtr(ptr.this)) } }
	pub fn to_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsVKCompute_baseComputePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKCompute) -> bool { unsafe { tsVKCompute_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKCompute { unsafe { VKCompute { this: tsVKCompute_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKCompute_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKCompute_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKCompute_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKCompute_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKCompute_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKCompute_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKCompute_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKCompute_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKCompute_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn command(&self) -> *const c_void { unsafe { tsVKCompute_getCommand(self.this) } }
	pub fn sampler_descriptor(&self) -> *const c_void { unsafe { tsVKCompute_getSamplerDescriptor(self.this) } }
	pub fn image_descriptor(&self) -> *const c_void { unsafe { tsVKCompute_getImageDescriptor(self.this) } }
	pub fn buffer_descriptor(&self) -> *const c_void { unsafe { tsVKCompute_getBufferDescriptor(self.this) } }
	pub fn tracing_descriptor(&self) -> *const c_void { unsafe { tsVKCompute_getTracingDescriptor(self.this) } }
	pub fn texel_descriptor(&self) -> *const c_void { unsafe { tsVKCompute_getTexelDescriptor(self.this) } }
	pub fn update(&mut self) { unsafe { tsVKCompute_update(self.this) } }
}
impl ComputeTrait for VKCompute {
	fn platform(&self) -> Platform { unsafe { tsCompute_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCompute_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCompute_getIndex(self.this) } }
	fn set_kernel(&mut self, kernel: &mut Kernel) { unsafe { tsCompute_setKernel(self.this, kernel.this) } }
	fn kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsCompute_getKernel(self.this)) } }
	fn set_traversal(&mut self, traversal: &mut Traversal) { unsafe { tsCompute_setTraversal(self.this, traversal.this) } }
	fn traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsCompute_getTraversal(self.this)) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCompute_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCompute_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCompute_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCompute_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCompute_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCompute_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCompute_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCompute_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCompute_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCompute_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn dispatch_with_width(&mut self, width: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, 1, 1) } }
	fn dispatch_with_width_height(&mut self, width: u32, height: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, 1) } }
	fn dispatch_with_width_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, depth) } }
	fn dispatch(&mut self, texture: &Texture) { unsafe { tsCompute_dispatch_cT(self.this, texture.this) } }
	fn dispatch_with_size(&mut self, size: &Size) { unsafe { tsCompute_dispatch_cS(self.this, size) } }
	fn dispatch_indirect(&mut self) { unsafe { tsCompute_dispatchIndirect(self.this) } }
	fn set_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&mut self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsCompute_setBuffer_Bp(self.this, buffer.this, src) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&mut self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsCompute_copyBuffer_BB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&mut self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsCompute_clearBuffer_BFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&mut self, buffer: &mut Buffer) -> bool { unsafe { tsCompute_clearBuffer_B(self.this, buffer.this) != 0 } }
	fn set_texture_with_texture_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_texture_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_texture_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_texture_image(&mut self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsCompute_copyTexture_TcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&mut self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsCompute_copyTexture_TT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&mut self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&mut self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_TcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&mut self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_Tp(self.this, texture.this, src) != 0 } }
	fn barrier(&mut self, texture: &mut Texture) { unsafe { tsCompute_barrier_T(self.this, texture.this) } }
	fn barrier_with_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_barrier_B(self.this, buffer.this) } }
	fn barrier_with_textures(&mut self, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAT(self.this, textures_.as_ptr(), textures.len() as u32) }
	}
	fn barrier_with_buffers(&mut self, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAB(self.this, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCompute_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCompute_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCompute_endQuery(self.this, query.this) } }
}
impl Drop for VKCompute {
	fn drop(&mut self) { if self.owner { unsafe { tsVKCompute_delete(self.this) } } }
}
impl Clone for VKCompute {
	fn clone(&self) -> VKCompute { unsafe { VKCompute { this: tsVKCompute_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKCompute { }
impl fmt::Display for VKCompute {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKCompute ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKCompute_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKCompute_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKCompute_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKCompute_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKCompute_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKCompute_new() -> *mut c_void;
	fn tsVKCompute_delete(this: *mut c_void);
	fn tsVKCompute_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKCompute_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKCompute_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKCompute_clearPtr(this: *const c_void);
	fn tsVKCompute_destroyPtr(this: *const c_void);
	fn tsVKCompute_acquirePtr(this: *const c_void);
	fn tsVKCompute_unacquirePtr(this: *const c_void);
	fn tsVKCompute_isValidPtr(this: *const c_void) -> i32;
	fn tsVKCompute_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKCompute_isConstPtr(this: *const c_void) -> i32;
	fn tsVKCompute_getCountPtr(this: *const c_void) -> u32;
	fn tsVKCompute_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKCompute_equalComputePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKCompute_castComputePtr(this: *const c_void) -> *mut c_void;
	fn tsVKCompute_baseComputePtr(this: *const c_void) -> *mut c_void;
	fn tsVKCompute_getCommand(this: *const c_void) -> *const c_void;
	fn tsVKCompute_getSamplerDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCompute_getImageDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCompute_getBufferDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCompute_getTracingDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCompute_getTexelDescriptor(this: *const c_void) -> *const c_void;
	fn tsVKCompute_update(this: *mut c_void);
}

// Tellusim::FUCompute
pub struct FUCompute {
	this: *mut c_void,
	owner: bool,
}
impl FUCompute {
	pub fn null() -> FUCompute { FUCompute { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUCompute { unsafe { FUCompute { this: tsFUCompute_new(), owner: true } } }
	pub fn new_with_computes(computes: &[&mut Compute]) -> FUCompute {
		let mut computes_ = Vec::new();
		for ptr in computes { computes_.push(ptr.this); }
		unsafe { FUCompute { this: tsFUCompute_new_cACb(computes_.as_ptr(), computes.len() as u32, 0), owner: true } }
	}
	pub fn new_with_computes_owner(computes: &[&mut Compute], owner: bool) -> FUCompute {
		let mut computes_ = Vec::new();
		for ptr in computes { computes_.push(ptr.this); }
		unsafe { FUCompute { this: tsFUCompute_new_cACb(computes_.as_ptr(), computes.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUCompute { unsafe { FUCompute { this: ptr, owner: tsFUCompute_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUCompute { unsafe { FUCompute { this: tsFUCompute_copyPtr(self.this), owner: true } } }
	pub fn from_compute(ptr: &Compute) -> FUCompute { unsafe { FUCompute::new_ptr(tsFUCompute_castComputePtr(ptr.this)) } }
	pub fn to_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsFUCompute_baseComputePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUCompute) -> bool { unsafe { tsFUCompute_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUCompute { unsafe { FUCompute { this: tsFUCompute_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUCompute_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUCompute_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUCompute_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUCompute_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUCompute_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUCompute_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUCompute_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUCompute_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUCompute_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUCompute_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUCompute_getMask(self.this) } }
	pub fn num_computes(&self) -> u32 { unsafe { tsFUCompute_getNumComputes(self.this) } }
	pub fn compute(&self, index: u32) -> Compute { unsafe { Compute::new_ptr(tsFUCompute_getCompute_cu(self.this, index)) } }
	pub fn compute_mut(&mut self, index: u32) -> Compute { unsafe { Compute::new_ptr(tsFUCompute_getCompute_u(self.this, index)) } }
}
impl ComputeTrait for FUCompute {
	fn platform(&self) -> Platform { unsafe { tsCompute_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsCompute_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsCompute_getIndex(self.this) } }
	fn set_kernel(&mut self, kernel: &mut Kernel) { unsafe { tsCompute_setKernel(self.this, kernel.this) } }
	fn kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsCompute_getKernel(self.this)) } }
	fn set_traversal(&mut self, traversal: &mut Traversal) { unsafe { tsCompute_setTraversal(self.this, traversal.this) } }
	fn traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsCompute_getTraversal(self.this)) } }
	fn set_sampler(&mut self, index: u32, sampler: &mut Sampler) { unsafe { tsCompute_setSampler(self.this, index, sampler.this) } }
	fn set_samplers(&mut self, index: u32, samplers: &[&mut Sampler]) {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { tsCompute_setSamplers_ucAS(self.this, index, samplers_.as_ptr(), samplers.len() as u32) }
	}
	fn set_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setTexture_uT(self.this, index, texture.this) } }
	fn set_texture_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setTexture_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn set_surface_texture(&mut self, index: u32, texture: &mut Texture) { unsafe { tsCompute_setSurfaceTexture_uT(self.this, index, texture.this) } }
	fn set_surface_texture_with_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, Format::Unknown) }
	}
	fn set_surface_texture_with_slice_format(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>, format: Format) {
		let slice_ = Slice::default();
		unsafe { tsCompute_setSurfaceTexture_uTcSF(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }, format) }
	}
	fn set_surface_textures(&mut self, index: u32, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_setSurfaceTextures_ucAT(self.this, index, textures_.as_ptr(), textures.len() as u32) }
	}
	fn uniform_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getUniformData(self.this, index, size) } }
	fn set_uniform_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setUniformData(self.this, index, src, size) } }
	fn set_uniform_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_uniform_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_uniform_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setUniformBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_uniform_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, 0) } }
	fn set_uniform_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setUniformOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_uniform_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_uniform_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setUniformBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn storage_data(&mut self, index: u32, size: usize) -> *mut c_void { unsafe { tsCompute_getStorageData(self.this, index, size) } }
	fn set_storage_data(&mut self, index: u32, src: *const c_void, size: usize) { unsafe { tsCompute_setStorageData(self.this, index, src, size) } }
	fn set_storage_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, 0, 0) } }
	fn set_storage_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, 0) } }
	fn set_storage_buffer_with_offset_size(&mut self, index: u32, buffer: &mut Buffer, offset: usize, size: usize) { unsafe { tsCompute_setStorageBuffer(self.this, index, buffer.this, offset, size) } }
	fn set_storage_offset(&mut self, index: u32, offset: usize) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, 0) } }
	fn set_storage_offset_with_relative(&mut self, index: u32, offset: usize, relative: bool) { unsafe { tsCompute_setStorageOffset(self.this, index, offset, if relative {1} else {0}) } }
	fn set_storage_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_storage_buffers_with_offsets(&mut self, index: u32, buffers: &[&mut Buffer], offsets: &[usize]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setStorageBuffers_ucABcA(self.this, index, buffers_.as_ptr(), buffers.len() as u32, offsets.as_ptr(), offsets.len() as u32) }
	}
	fn set_tracing(&mut self, index: u32, tracing: &mut Tracing) { unsafe { tsCompute_setTracing(self.this, index, tracing.this) } }
	fn set_tracings(&mut self, index: u32, tracings: &[&mut Tracing]) {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsCompute_setTracings_ucAT(self.this, index, tracings_.as_ptr(), tracings.len() as u32) }
	}
	fn set_texel_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsCompute_setTexelBuffer(self.this, index, buffer.this) } }
	fn set_texel_buffers(&mut self, index: u32, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_setTexelBuffers_ucAB(self.this, index, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn set_texture_table(&mut self, index: u32, table: &mut TextureTable) { unsafe { tsCompute_setTextureTable(self.this, index, table.this) } }
	fn set_texture_tables(&mut self, index: u32, tables: &[&mut TextureTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setTextureTables_ucATT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn set_storage_table(&mut self, index: u32, table: &mut BufferTable) { unsafe { tsCompute_setStorageTable(self.this, index, table.this) } }
	fn set_storage_tables(&mut self, index: u32, tables: &[&mut BufferTable]) {
		let mut tables_ = Vec::new();
		for ptr in tables { tables_.push(ptr.this); }
		unsafe { tsCompute_setStorageTables_ucABT(self.this, index, tables_.as_ptr(), tables.len() as u32) }
	}
	fn indirect_data(&mut self, size: usize) -> *mut c_void { unsafe { tsCompute_getIndirectData(self.this, size) } }
	fn set_indirect_data(&mut self, src: *const c_void, size: usize) { unsafe { tsCompute_setIndirectData(self.this, src, size) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn set_indirect_offset(&mut self, offset: usize) { unsafe { tsCompute_setIndirectOffset(self.this, offset, 0) } }
	fn set_indirect_offset_with_relative(&mut self, offset: usize, relative: bool) { unsafe { tsCompute_setIndirectOffset(self.this, offset, if relative {1} else {0}) } }
	fn dispatch_with_width(&mut self, width: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, 1, 1) } }
	fn dispatch_with_width_height(&mut self, width: u32, height: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, 1) } }
	fn dispatch_with_width_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsCompute_dispatch_uuu(self.this, width, height, depth) } }
	fn dispatch(&mut self, texture: &Texture) { unsafe { tsCompute_dispatch_cT(self.this, texture.this) } }
	fn dispatch_with_size(&mut self, size: &Size) { unsafe { tsCompute_dispatch_cS(self.this, size) } }
	fn dispatch_indirect(&mut self) { unsafe { tsCompute_dispatchIndirect(self.this) } }
	fn set_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_setBuffer_Bpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&mut self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsCompute_setBuffer_Bp(self.this, buffer.this, src) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&mut self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&mut self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsCompute_copyBuffer_BBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&mut self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsCompute_copyBuffer_BB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&mut self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsCompute_clearBuffer_BFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&mut self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsCompute_clearBuffer_BFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&mut self, buffer: &mut Buffer) -> bool { unsafe { tsCompute_clearBuffer_B(self.this, buffer.this) != 0 } }
	fn set_texture_with_texture_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_texture_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_texture_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsCompute_setTexture_TcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_texture_image(&mut self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsCompute_setTexture_TcI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&mut self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&mut self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsCompute_copyTexture_TcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&mut self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsCompute_copyTexture_TcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&mut self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsCompute_copyTexture_TT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&mut self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&mut self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_TcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCompute_clearTexture_TcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&mut self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsCompute_clearTexture_Tp(self.this, texture.this, src) != 0 } }
	fn barrier(&mut self, texture: &mut Texture) { unsafe { tsCompute_barrier_T(self.this, texture.this) } }
	fn barrier_with_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsCompute_barrier_B(self.this, buffer.this) } }
	fn barrier_with_textures(&mut self, textures: &[&mut Texture]) {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAT(self.this, textures_.as_ptr(), textures.len() as u32) }
	}
	fn barrier_with_buffers(&mut self, buffers: &[&mut Buffer]) {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsCompute_barrier_cAB(self.this, buffers_.as_ptr(), buffers.len() as u32) }
	}
	fn begin_conditional(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsCompute_beginConditional(self.this, buffer.this, offset) } }
	fn end_conditional(&mut self) { unsafe { tsCompute_endConditional(self.this) } }
	fn begin_query(&mut self, query: &mut Query) -> bool { unsafe { tsCompute_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&mut self, query: &mut Query) { unsafe { tsCompute_endQuery(self.this, query.this) } }
}
impl Drop for FUCompute {
	fn drop(&mut self) { if self.owner { unsafe { tsFUCompute_delete(self.this) } } }
}
impl Clone for FUCompute {
	fn clone(&self) -> FUCompute { unsafe { FUCompute { this: tsFUCompute_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUCompute { }
impl fmt::Display for FUCompute {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUCompute ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUCompute_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUCompute_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUCompute_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUCompute_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUCompute_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUCompute_new() -> *mut c_void;
	fn tsFUCompute_new_cACb(computes: *const *mut c_void, computes_size: u32, owner: i32) -> *mut c_void;
	fn tsFUCompute_delete(this: *mut c_void);
	fn tsFUCompute_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUCompute_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUCompute_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUCompute_clearPtr(this: *const c_void);
	fn tsFUCompute_destroyPtr(this: *const c_void);
	fn tsFUCompute_acquirePtr(this: *const c_void);
	fn tsFUCompute_unacquirePtr(this: *const c_void);
	fn tsFUCompute_isValidPtr(this: *const c_void) -> i32;
	fn tsFUCompute_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUCompute_isConstPtr(this: *const c_void) -> i32;
	fn tsFUCompute_getCountPtr(this: *const c_void) -> u32;
	fn tsFUCompute_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUCompute_equalComputePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUCompute_castComputePtr(this: *const c_void) -> *mut c_void;
	fn tsFUCompute_baseComputePtr(this: *const c_void) -> *mut c_void;
	fn tsFUCompute_setMask(this: *mut c_void, mask: u32);
	fn tsFUCompute_getMask(this: *const c_void) -> u32;
	fn tsFUCompute_getNumComputes(this: *const c_void) -> u32;
	fn tsFUCompute_getCompute_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUCompute_getCompute_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Context
pub struct Context {
	this: *mut c_void,
	owner: bool,
}
impl Context {
	pub fn null() -> Context { Context { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Context { unsafe { Context { this: tsContext_new(), owner: true } } }
	pub fn new_with_platform(platform: Platform) -> Context { unsafe { Context { this: tsContext_new_Pu(platform, MAXU32), owner: true } } }
	pub fn new_with_platform_index(platform: Platform, index: u32) -> Context { unsafe { Context { this: tsContext_new_Pu(platform, index), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Context { unsafe { Context { this: ptr, owner: tsContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Context { unsafe { Context { this: tsContext_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Context) -> bool { unsafe { tsContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Context { unsafe { Context { this: tsContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ContextTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn is_created(&self) -> bool;
	fn create(&mut self) -> bool;
	fn flush(&mut self) -> bool;
	fn finish(&mut self) -> bool;
}
impl ContextTrait for Context {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for Context {
	fn drop(&mut self) { if self.owner { unsafe { tsContext_delete(self.this) } } }
}
impl Clone for Context {
	fn clone(&self) -> Context { unsafe { Context { this: tsContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Context { }
impl fmt::Display for Context {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Context ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsContext_new() -> *mut c_void;
	fn tsContext_new_Pu(platform: Platform, index: u32) -> *mut c_void;
	fn tsContext_delete(this: *mut c_void);
	fn tsContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsContext_clearPtr(this: *const c_void);
	fn tsContext_destroyPtr(this: *const c_void);
	fn tsContext_acquirePtr(this: *const c_void);
	fn tsContext_unacquirePtr(this: *const c_void);
	fn tsContext_isValidPtr(this: *const c_void) -> i32;
	fn tsContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsContext_isConstPtr(this: *const c_void) -> i32;
	fn tsContext_getCountPtr(this: *const c_void) -> u32;
	fn tsContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsContext_getPlatform(this: *const c_void) -> Platform;
	fn tsContext_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsContext_getIndex(this: *const c_void) -> u32;
	fn tsContext_isCreated(this: *const c_void) -> i32;
	fn tsContext_create(this: *mut c_void) -> i32;
	fn tsContext_flush(this: *mut c_void) -> i32;
	fn tsContext_finish(this: *mut c_void) -> i32;
}

// Tellusim::D3D12Context
pub struct D3D12Context {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Context {
	pub fn null() -> D3D12Context { D3D12Context { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Context { unsafe { D3D12Context { this: tsD3D12Context_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Context { unsafe { D3D12Context { this: ptr, owner: tsD3D12Context_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Context { unsafe { D3D12Context { this: tsD3D12Context_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> D3D12Context { unsafe { D3D12Context::new_ptr(tsD3D12Context_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsD3D12Context_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Context) -> bool { unsafe { tsD3D12Context_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Context { unsafe { D3D12Context { this: tsD3D12Context_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Context_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Context_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Context_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Context_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Context_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Context_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Context_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Context_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Context_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, device: *const c_void, queue: *const c_void) -> bool { unsafe { tsD3D12Context_create(self.this, device, queue) != 0 } }
	pub fn factory(&self) -> *const c_void { unsafe { tsD3D12Context_getFactory(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsD3D12Context_getDevice(self.this) } }
	pub fn queue(&self) -> *const c_void { unsafe { tsD3D12Context_getQueue(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsD3D12Context_getCommand(self.this) } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsD3D12Context_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsD3D12Context_error(result) != 0 } }
}
impl ContextTrait for D3D12Context {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for D3D12Context {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Context_delete(self.this) } } }
}
impl Clone for D3D12Context {
	fn clone(&self) -> D3D12Context { unsafe { D3D12Context { this: tsD3D12Context_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Context { }
impl fmt::Display for D3D12Context {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Context ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Context_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Context_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Context_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Context_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Context_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Context_new() -> *mut c_void;
	fn tsD3D12Context_delete(this: *mut c_void);
	fn tsD3D12Context_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Context_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Context_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Context_clearPtr(this: *const c_void);
	fn tsD3D12Context_destroyPtr(this: *const c_void);
	fn tsD3D12Context_acquirePtr(this: *const c_void);
	fn tsD3D12Context_unacquirePtr(this: *const c_void);
	fn tsD3D12Context_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Context_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Context_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Context_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Context_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Context_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Context_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Context_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Context_create(this: *mut c_void, device: *const c_void, queue: *const c_void) -> i32;
	fn tsD3D12Context_getFactory(this: *const c_void) -> *const c_void;
	fn tsD3D12Context_getDevice(this: *const c_void) -> *const c_void;
	fn tsD3D12Context_getQueue(this: *const c_void) -> *const c_void;
	fn tsD3D12Context_getCommand(this: *const c_void) -> *const c_void;
	fn tsD3D12Context_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsD3D12Context_error(result: u32) -> i32;
}

// Tellusim::D3D11Context
pub struct D3D11Context {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Context {
	pub fn null() -> D3D11Context { D3D11Context { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Context { unsafe { D3D11Context { this: tsD3D11Context_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Context { unsafe { D3D11Context { this: ptr, owner: tsD3D11Context_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Context { unsafe { D3D11Context { this: tsD3D11Context_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> D3D11Context { unsafe { D3D11Context::new_ptr(tsD3D11Context_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsD3D11Context_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Context) -> bool { unsafe { tsD3D11Context_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Context { unsafe { D3D11Context { this: tsD3D11Context_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Context_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Context_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Context_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Context_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Context_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Context_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Context_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Context_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Context_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, device: *const c_void) -> bool { unsafe { tsD3D11Context_create(self.this, device) != 0 } }
	pub fn factory(&self) -> *const c_void { unsafe { tsD3D11Context_getFactory(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsD3D11Context_getDevice(self.this) } }
	pub fn d3d11_context(&self) -> *const c_void { unsafe { tsD3D11Context_getD3D11Context(self.this) } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsD3D11Context_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsD3D11Context_error(result) != 0 } }
}
impl ContextTrait for D3D11Context {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for D3D11Context {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Context_delete(self.this) } } }
}
impl Clone for D3D11Context {
	fn clone(&self) -> D3D11Context { unsafe { D3D11Context { this: tsD3D11Context_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Context { }
impl fmt::Display for D3D11Context {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Context ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Context_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Context_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Context_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Context_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Context_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Context_new() -> *mut c_void;
	fn tsD3D11Context_delete(this: *mut c_void);
	fn tsD3D11Context_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Context_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Context_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Context_clearPtr(this: *const c_void);
	fn tsD3D11Context_destroyPtr(this: *const c_void);
	fn tsD3D11Context_acquirePtr(this: *const c_void);
	fn tsD3D11Context_unacquirePtr(this: *const c_void);
	fn tsD3D11Context_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Context_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Context_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Context_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Context_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Context_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Context_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Context_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Context_create(this: *mut c_void, device: *const c_void) -> i32;
	fn tsD3D11Context_getFactory(this: *const c_void) -> *const c_void;
	fn tsD3D11Context_getDevice(this: *const c_void) -> *const c_void;
	fn tsD3D11Context_getD3D11Context(this: *const c_void) -> *const c_void;
	fn tsD3D11Context_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsD3D11Context_error(result: u32) -> i32;
}

// Tellusim::MTLContext
pub struct MTLContext {
	this: *mut c_void,
	owner: bool,
}
impl MTLContext {
	pub fn null() -> MTLContext { MTLContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLContext { unsafe { MTLContext { this: tsMTLContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLContext { unsafe { MTLContext { this: ptr, owner: tsMTLContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLContext { unsafe { MTLContext { this: tsMTLContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> MTLContext { unsafe { MTLContext::new_ptr(tsMTLContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsMTLContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLContext) -> bool { unsafe { tsMTLContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLContext { unsafe { MTLContext { this: tsMTLContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, device: *mut c_void, queue: *mut c_void) -> bool { unsafe { tsMTLContext_create(self.this, device, queue) != 0 } }
	pub fn device(&self) -> *mut c_void { unsafe { tsMTLContext_getDevice(self.this) } }
	pub fn queue(&self) -> *mut c_void { unsafe { tsMTLContext_getQueue(self.this) } }
	pub fn command(&self) -> *mut c_void { unsafe { tsMTLContext_getCommand(self.this) } }
	pub fn encoder(&self) -> *mut c_void { unsafe { tsMTLContext_getEncoder(self.this) } }
	pub fn render_encoder(&self, descriptor: *mut c_void) -> *mut c_void { unsafe { tsMTLContext_getRenderEncoder(self.this, descriptor) } }
	pub fn compute_encoder(&self) -> *mut c_void { unsafe { tsMTLContext_getComputeEncoder(self.this) } }
	pub fn tracing_encoder(&self) -> *mut c_void { unsafe { tsMTLContext_getTracingEncoder(self.this) } }
	pub fn blit_encoder(&self) -> *mut c_void { unsafe { tsMTLContext_getBlitEncoder(self.this) } }
	pub fn end_encoder(&self) { unsafe { tsMTLContext_endEncoder(self.this) } }
}
impl ContextTrait for MTLContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for MTLContext {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLContext_delete(self.this) } } }
}
impl Clone for MTLContext {
	fn clone(&self) -> MTLContext { unsafe { MTLContext { this: tsMTLContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLContext { }
impl fmt::Display for MTLContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLContext_new() -> *mut c_void;
	fn tsMTLContext_delete(this: *mut c_void);
	fn tsMTLContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_clearPtr(this: *const c_void);
	fn tsMTLContext_destroyPtr(this: *const c_void);
	fn tsMTLContext_acquirePtr(this: *const c_void);
	fn tsMTLContext_unacquirePtr(this: *const c_void);
	fn tsMTLContext_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLContext_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLContext_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_create(this: *mut c_void, device: *mut c_void, queue: *mut c_void) -> i32;
	fn tsMTLContext_getDevice(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_getQueue(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_getCommand(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_getEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_getRenderEncoder(this: *const c_void, descriptor: *mut c_void) -> *mut c_void;
	fn tsMTLContext_getComputeEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_getTracingEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_getBlitEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLContext_endEncoder(this: *const c_void);
}

// Tellusim::VKContext
pub struct VKContext {
	this: *mut c_void,
	owner: bool,
}
impl VKContext {
	pub fn null() -> VKContext { VKContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKContext { unsafe { VKContext { this: tsVKContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKContext { unsafe { VKContext { this: ptr, owner: tsVKContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKContext { unsafe { VKContext { this: tsVKContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> VKContext { unsafe { VKContext::new_ptr(tsVKContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsVKContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKContext) -> bool { unsafe { tsVKContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKContext { unsafe { VKContext { this: tsVKContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, instance: *const c_void, func: *const c_void, adapter: *const c_void, device: *const c_void, family: u32, index: u32) -> bool { unsafe { tsVKContext_create(self.this, instance, func, adapter, device, family, index) != 0 } }
	pub fn instance(&self) -> *const c_void { unsafe { tsVKContext_getInstance(self.this) } }
	pub fn adapter(&self) -> *const c_void { unsafe { tsVKContext_getAdapter(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsVKContext_getDevice(self.this) } }
	pub fn queue(&self) -> *const c_void { unsafe { tsVKContext_getQueue(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsVKContext_getCommand(self.this) } }
	pub fn family(&self) -> u32 { unsafe { tsVKContext_getFamily(self.this) } }
	pub fn num_queues(&mut self) -> u32 { unsafe { tsVKContext_getNumQueues(self.this) } }
	pub fn queue_flags(&mut self, index: u32) -> u32 { unsafe { tsVKContext_getQueueFlags(self.this, index) } }
	pub fn queue_family(&mut self, index: u32) -> u32 { unsafe { tsVKContext_getQueueFamily(self.this, index) } }
	pub fn add_context_extension(name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsVKContext_addContextExtension(name_.as_ptr()) }
	}
	pub fn add_adapter_extension(name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsVKContext_addAdapterExtension(name_.as_ptr()) }
	}
	pub fn add_adapter_features(features: *mut c_void) { unsafe { tsVKContext_addAdapterFeatures(features) } }
	pub fn instance_proc_address() -> *const c_void { unsafe { tsVKContext_getInstanceProcAddress() } }
	pub fn device_proc_address() -> *const c_void { unsafe { tsVKContext_getDeviceProcAddress() } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsVKContext_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsVKContext_error(result) != 0 } }
}
impl ContextTrait for VKContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for VKContext {
	fn drop(&mut self) { if self.owner { unsafe { tsVKContext_delete(self.this) } } }
}
impl Clone for VKContext {
	fn clone(&self) -> VKContext { unsafe { VKContext { this: tsVKContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKContext { }
impl fmt::Display for VKContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKContext_new() -> *mut c_void;
	fn tsVKContext_delete(this: *mut c_void);
	fn tsVKContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKContext_clearPtr(this: *const c_void);
	fn tsVKContext_destroyPtr(this: *const c_void);
	fn tsVKContext_acquirePtr(this: *const c_void);
	fn tsVKContext_unacquirePtr(this: *const c_void);
	fn tsVKContext_isValidPtr(this: *const c_void) -> i32;
	fn tsVKContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKContext_isConstPtr(this: *const c_void) -> i32;
	fn tsVKContext_getCountPtr(this: *const c_void) -> u32;
	fn tsVKContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsVKContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsVKContext_create(this: *mut c_void, instance: *const c_void, func: *const c_void, adapter: *const c_void, device: *const c_void, family: u32, index: u32) -> i32;
	fn tsVKContext_getInstance(this: *const c_void) -> *const c_void;
	fn tsVKContext_getAdapter(this: *const c_void) -> *const c_void;
	fn tsVKContext_getDevice(this: *const c_void) -> *const c_void;
	fn tsVKContext_getQueue(this: *const c_void) -> *const c_void;
	fn tsVKContext_getCommand(this: *const c_void) -> *const c_void;
	fn tsVKContext_getFamily(this: *const c_void) -> u32;
	fn tsVKContext_getNumQueues(this: *mut c_void) -> u32;
	fn tsVKContext_getQueueFlags(this: *mut c_void, index: u32) -> u32;
	fn tsVKContext_getQueueFamily(this: *mut c_void, index: u32) -> u32;
	fn tsVKContext_addContextExtension(name: *const c_char);
	fn tsVKContext_addAdapterExtension(name: *const c_char);
	fn tsVKContext_addAdapterFeatures(features: *mut c_void);
	fn tsVKContext_getInstanceProcAddress() -> *const c_void;
	fn tsVKContext_getDeviceProcAddress() -> *const c_void;
	fn tsVKContext_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsVKContext_error(result: u32) -> i32;
}

// Tellusim::GLContext
pub struct GLContext {
	this: *mut c_void,
	owner: bool,
}
impl GLContext {
	pub fn null() -> GLContext { GLContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLContext { unsafe { GLContext { this: tsGLContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLContext { unsafe { GLContext { this: ptr, owner: tsGLContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLContext { unsafe { GLContext { this: tsGLContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> GLContext { unsafe { GLContext::new_ptr(tsGLContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsGLContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLContext) -> bool { unsafe { tsGLContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLContext { unsafe { GLContext { this: tsGLContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, context: *mut c_void) -> bool { unsafe { tsGLContext_create(self.this, context) != 0 } }
	pub fn gl_display(&self) -> *mut c_void { unsafe { tsGLContext_getGLDisplay(self.this) } }
	pub fn gl_visual(&self) -> *mut c_void { unsafe { tsGLContext_getGLVisual(self.this) } }
	pub fn gl_config(&self) -> *mut c_void { unsafe { tsGLContext_getGLConfig(self.this) } }
	pub fn gl_surface(&self) -> *mut c_void { unsafe { tsGLContext_getGLSurface(self.this) } }
	pub fn gl_context(&self) -> *mut c_void { unsafe { tsGLContext_getGLContext(self.this) } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsGLContext_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsGLContext_error(result) != 0 } }
	pub fn check() -> bool { unsafe { tsGLContext_check() != 0 } }
}
impl ContextTrait for GLContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for GLContext {
	fn drop(&mut self) { if self.owner { unsafe { tsGLContext_delete(self.this) } } }
}
impl Clone for GLContext {
	fn clone(&self) -> GLContext { unsafe { GLContext { this: tsGLContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLContext { }
impl fmt::Display for GLContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLContext_new() -> *mut c_void;
	fn tsGLContext_delete(this: *mut c_void);
	fn tsGLContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLContext_clearPtr(this: *const c_void);
	fn tsGLContext_destroyPtr(this: *const c_void);
	fn tsGLContext_acquirePtr(this: *const c_void);
	fn tsGLContext_unacquirePtr(this: *const c_void);
	fn tsGLContext_isValidPtr(this: *const c_void) -> i32;
	fn tsGLContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLContext_isConstPtr(this: *const c_void) -> i32;
	fn tsGLContext_getCountPtr(this: *const c_void) -> u32;
	fn tsGLContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsGLContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsGLContext_create(this: *mut c_void, context: *mut c_void) -> i32;
	fn tsGLContext_getGLDisplay(this: *const c_void) -> *mut c_void;
	fn tsGLContext_getGLVisual(this: *const c_void) -> *mut c_void;
	fn tsGLContext_getGLConfig(this: *const c_void) -> *mut c_void;
	fn tsGLContext_getGLSurface(this: *const c_void) -> *mut c_void;
	fn tsGLContext_getGLContext(this: *const c_void) -> *mut c_void;
	fn tsGLContext_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsGLContext_error(result: u32) -> i32;
	fn tsGLContext_check() -> i32;
}

// Tellusim::GLESContext
pub struct GLESContext {
	this: *mut c_void,
	owner: bool,
}
impl GLESContext {
	pub fn null() -> GLESContext { GLESContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLESContext { unsafe { GLESContext { this: tsGLESContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLESContext { unsafe { GLESContext { this: ptr, owner: tsGLESContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLESContext { unsafe { GLESContext { this: tsGLESContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> GLESContext { unsafe { GLESContext::new_ptr(tsGLESContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsGLESContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLESContext) -> bool { unsafe { tsGLESContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLESContext { unsafe { GLESContext { this: tsGLESContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLESContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLESContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLESContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLESContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLESContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLESContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLESContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLESContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLESContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, context: *mut c_void) -> bool { unsafe { tsGLESContext_create(self.this, context) != 0 } }
	pub fn gles_display(&self) -> *mut c_void { unsafe { tsGLESContext_getGLESDisplay(self.this) } }
	pub fn gles_config(&self) -> *mut c_void { unsafe { tsGLESContext_getGLESConfig(self.this) } }
	pub fn gles_context(&self) -> *mut c_void { unsafe { tsGLESContext_getGLESContext(self.this) } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsGLESContext_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsGLESContext_error(result) != 0 } }
	pub fn check() -> bool { unsafe { tsGLESContext_check() != 0 } }
}
impl ContextTrait for GLESContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for GLESContext {
	fn drop(&mut self) { if self.owner { unsafe { tsGLESContext_delete(self.this) } } }
}
impl Clone for GLESContext {
	fn clone(&self) -> GLESContext { unsafe { GLESContext { this: tsGLESContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLESContext { }
impl fmt::Display for GLESContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLESContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLESContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLESContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLESContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLESContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLESContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLESContext_new() -> *mut c_void;
	fn tsGLESContext_delete(this: *mut c_void);
	fn tsGLESContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_clearPtr(this: *const c_void);
	fn tsGLESContext_destroyPtr(this: *const c_void);
	fn tsGLESContext_acquirePtr(this: *const c_void);
	fn tsGLESContext_unacquirePtr(this: *const c_void);
	fn tsGLESContext_isValidPtr(this: *const c_void) -> i32;
	fn tsGLESContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLESContext_isConstPtr(this: *const c_void) -> i32;
	fn tsGLESContext_getCountPtr(this: *const c_void) -> u32;
	fn tsGLESContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_create(this: *mut c_void, context: *mut c_void) -> i32;
	fn tsGLESContext_getGLESDisplay(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_getGLESConfig(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_getGLESContext(this: *const c_void) -> *mut c_void;
	fn tsGLESContext_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsGLESContext_error(result: u32) -> i32;
	fn tsGLESContext_check() -> i32;
}

// Tellusim::WGContext
pub struct WGContext {
	this: *mut c_void,
	owner: bool,
}
impl WGContext {
	pub fn null() -> WGContext { WGContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> WGContext { unsafe { WGContext { this: tsWGContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> WGContext { unsafe { WGContext { this: ptr, owner: tsWGContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> WGContext { unsafe { WGContext { this: tsWGContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> WGContext { unsafe { WGContext::new_ptr(tsWGContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsWGContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: WGContext) -> bool { unsafe { tsWGContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> WGContext { unsafe { WGContext { this: tsWGContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsWGContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsWGContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsWGContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsWGContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsWGContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsWGContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsWGContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsWGContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsWGContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn open(instance: *const c_void, adapter: *const c_void, device: *const c_void) -> bool { unsafe { tsWGContext_open(instance, adapter, device) != 0 } }
	pub fn create(&mut self, instance: *const c_void, adapter: *const c_void, device: *const c_void) -> bool { unsafe { tsWGContext_create(self.this, instance, adapter, device) != 0 } }
	pub fn instance(&self) -> *const c_void { unsafe { tsWGContext_getInstance(self.this) } }
	pub fn adapter(&self) -> *const c_void { unsafe { tsWGContext_getAdapter(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsWGContext_getDevice(self.this) } }
}
impl ContextTrait for WGContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for WGContext {
	fn drop(&mut self) { if self.owner { unsafe { tsWGContext_delete(self.this) } } }
}
impl Clone for WGContext {
	fn clone(&self) -> WGContext { unsafe { WGContext { this: tsWGContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for WGContext { }
impl fmt::Display for WGContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::WGContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsWGContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsWGContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsWGContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsWGContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsWGContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsWGContext_new() -> *mut c_void;
	fn tsWGContext_delete(this: *mut c_void);
	fn tsWGContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsWGContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsWGContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsWGContext_clearPtr(this: *const c_void);
	fn tsWGContext_destroyPtr(this: *const c_void);
	fn tsWGContext_acquirePtr(this: *const c_void);
	fn tsWGContext_unacquirePtr(this: *const c_void);
	fn tsWGContext_isValidPtr(this: *const c_void) -> i32;
	fn tsWGContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsWGContext_isConstPtr(this: *const c_void) -> i32;
	fn tsWGContext_getCountPtr(this: *const c_void) -> u32;
	fn tsWGContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsWGContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsWGContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsWGContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsWGContext_open(instance: *const c_void, adapter: *const c_void, device: *const c_void) -> i32;
	fn tsWGContext_create(this: *mut c_void, instance: *const c_void, adapter: *const c_void, device: *const c_void) -> i32;
	fn tsWGContext_getInstance(this: *const c_void) -> *const c_void;
	fn tsWGContext_getAdapter(this: *const c_void) -> *const c_void;
	fn tsWGContext_getDevice(this: *const c_void) -> *const c_void;
}

// Tellusim::CUContext
pub struct CUContext {
	this: *mut c_void,
	owner: bool,
}
impl CUContext {
	pub fn null() -> CUContext { CUContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CUContext { unsafe { CUContext { this: tsCUContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CUContext { unsafe { CUContext { this: ptr, owner: tsCUContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CUContext { unsafe { CUContext { this: tsCUContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> CUContext { unsafe { CUContext::new_ptr(tsCUContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsCUContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CUContext) -> bool { unsafe { tsCUContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CUContext { unsafe { CUContext { this: tsCUContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCUContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCUContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCUContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCUContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCUContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCUContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCUContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCUContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCUContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn device(&self) -> i32 { unsafe { tsCUContext_getDevice(self.this) } }
	pub fn cu_context(&self) -> *const c_void { unsafe { tsCUContext_getCUContext(self.this) } }
	pub fn stream(&self) -> *const c_void { unsafe { tsCUContext_getStream(self.this) } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCUContext_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsCUContext_error(result) != 0 } }
}
impl ContextTrait for CUContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for CUContext {
	fn drop(&mut self) { if self.owner { unsafe { tsCUContext_delete(self.this) } } }
}
impl Clone for CUContext {
	fn clone(&self) -> CUContext { unsafe { CUContext { this: tsCUContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CUContext { }
impl fmt::Display for CUContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CUContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCUContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCUContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCUContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCUContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCUContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCUContext_new() -> *mut c_void;
	fn tsCUContext_delete(this: *mut c_void);
	fn tsCUContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCUContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCUContext_clearPtr(this: *const c_void);
	fn tsCUContext_destroyPtr(this: *const c_void);
	fn tsCUContext_acquirePtr(this: *const c_void);
	fn tsCUContext_unacquirePtr(this: *const c_void);
	fn tsCUContext_isValidPtr(this: *const c_void) -> i32;
	fn tsCUContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCUContext_isConstPtr(this: *const c_void) -> i32;
	fn tsCUContext_getCountPtr(this: *const c_void) -> u32;
	fn tsCUContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCUContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsCUContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsCUContext_getDevice(this: *const c_void) -> i32;
	fn tsCUContext_getCUContext(this: *const c_void) -> *const c_void;
	fn tsCUContext_getStream(this: *const c_void) -> *const c_void;
	fn tsCUContext_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsCUContext_error(result: u32) -> i32;
}

// Tellusim::HIPContext
pub struct HIPContext {
	this: *mut c_void,
	owner: bool,
}
impl HIPContext {
	pub fn null() -> HIPContext { HIPContext { this: ptr::null_mut(), owner: false } }
	pub fn new() -> HIPContext { unsafe { HIPContext { this: tsHIPContext_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> HIPContext { unsafe { HIPContext { this: ptr, owner: tsHIPContext_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> HIPContext { unsafe { HIPContext { this: tsHIPContext_copyPtr(self.this), owner: true } } }
	pub fn from_context(ptr: &Context) -> HIPContext { unsafe { HIPContext::new_ptr(tsHIPContext_castContextPtr(ptr.this)) } }
	pub fn to_context(&self) -> Context { unsafe { Context::new_ptr(tsHIPContext_baseContextPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: HIPContext) -> bool { unsafe { tsHIPContext_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> HIPContext { unsafe { HIPContext { this: tsHIPContext_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsHIPContext_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsHIPContext_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsHIPContext_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsHIPContext_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsHIPContext_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsHIPContext_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsHIPContext_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsHIPContext_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsHIPContext_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn device(&self) -> i32 { unsafe { tsHIPContext_getDevice(self.this) } }
	pub fn hip_context(&self) -> *mut c_void { unsafe { tsHIPContext_getHIPContext(self.this) } }
	pub fn stream(&self) -> *mut c_void { unsafe { tsHIPContext_getStream(self.this) } }
	pub fn proc_address(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsHIPContext_getProcAddress(name_.as_ptr()) }
	}
	pub fn error(result: u32) -> bool { unsafe { tsHIPContext_error(result) != 0 } }
}
impl ContextTrait for HIPContext {
	fn platform(&self) -> Platform { unsafe { tsContext_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsContext_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsContext_getIndex(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsContext_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsContext_create(self.this) != 0 } }
	fn flush(&mut self) -> bool { unsafe { tsContext_flush(self.this) != 0 } }
	fn finish(&mut self) -> bool { unsafe { tsContext_finish(self.this) != 0 } }
}
impl Drop for HIPContext {
	fn drop(&mut self) { if self.owner { unsafe { tsHIPContext_delete(self.this) } } }
}
impl Clone for HIPContext {
	fn clone(&self) -> HIPContext { unsafe { HIPContext { this: tsHIPContext_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for HIPContext { }
impl fmt::Display for HIPContext {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::HIPContext ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsHIPContext_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsHIPContext_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsHIPContext_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsHIPContext_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsHIPContext_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsHIPContext_new() -> *mut c_void;
	fn tsHIPContext_delete(this: *mut c_void);
	fn tsHIPContext_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPContext_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_clearPtr(this: *const c_void);
	fn tsHIPContext_destroyPtr(this: *const c_void);
	fn tsHIPContext_acquirePtr(this: *const c_void);
	fn tsHIPContext_unacquirePtr(this: *const c_void);
	fn tsHIPContext_isValidPtr(this: *const c_void) -> i32;
	fn tsHIPContext_isOwnerPtr(this: *const c_void) -> i32;
	fn tsHIPContext_isConstPtr(this: *const c_void) -> i32;
	fn tsHIPContext_getCountPtr(this: *const c_void) -> u32;
	fn tsHIPContext_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_equalContextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPContext_castContextPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_baseContextPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_getDevice(this: *const c_void) -> i32;
	fn tsHIPContext_getHIPContext(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_getStream(this: *const c_void) -> *mut c_void;
	fn tsHIPContext_getProcAddress(name: *const c_char) -> *mut c_void;
	fn tsHIPContext_error(result: u32) -> i32;
}

// Tellusim::Query
pub struct Query {
	this: *mut c_void,
	owner: bool,
}
impl Query {
	pub fn null() -> Query { Query { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Query { unsafe { Query { this: tsQuery_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Query { unsafe { Query { this: ptr, owner: tsQuery_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Query { unsafe { Query { this: tsQuery_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Query) -> bool { unsafe { tsQuery_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Query { unsafe { Query { this: tsQuery_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsQuery_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsQuery_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsQuery_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsQuery_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsQuery_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsQuery_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsQuery_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsQuery_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsQuery_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait QueryTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn is_available(&self) -> bool;
	fn is_began(&self) -> bool;
	fn is_ended(&self) -> bool;
	fn create(&mut self, type_: QueryType) -> bool;
	fn type_(&self) -> QueryType;
	fn type_name_with_type(type_: QueryType) -> string::String;
	fn type_name(&self) -> string::String;
	fn type_size(&self) -> usize;
	fn is_time(&self) -> bool;
	fn is_clock(&self) -> bool;
	fn is_samples(&self) -> bool;
	fn is_samples1(&self) -> bool;
	fn is_statistics(&self) -> bool;
	fn is_time_type(&self) -> bool;
	fn is_samples_type(&self) -> bool;
	fn get(&self, dest: *mut c_void, size: usize) -> bool;
	fn get_with_wait(&self, dest: *mut c_void, size: usize, wait: bool) -> bool;
	fn time(&self) -> u64;
	fn time_with_wait(&self, wait: bool) -> u64;
	fn time_with_wait_status(&self, wait: bool, status: *mut u8) -> u64;
	fn samples(&self) -> u32;
	fn samples_with_wait(&self, wait: bool) -> u32;
	fn samples_with_wait_status(&self, wait: bool, status: *mut u8) -> u32;
	fn statistics(&self) -> QueryStatistics;
	fn statistics_with_wait(&self, wait: bool) -> QueryStatistics;
	fn statistics_with_wait_status(&self, wait: bool, status: *mut u8) -> QueryStatistics;
}
impl QueryTrait for Query {
	fn platform(&self) -> Platform { unsafe { tsQuery_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsQuery_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsQuery_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsQuery_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsQuery_isCreated(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsQuery_isAvailable(self.this) != 0 } }
	fn is_began(&self) -> bool { unsafe { tsQuery_isBegan(self.this) != 0 } }
	fn is_ended(&self) -> bool { unsafe { tsQuery_isEnded(self.this) != 0 } }
	fn create(&mut self, type_: QueryType) -> bool { unsafe { tsQuery_create(self.this, type_) != 0 } }
	fn type_(&self) -> QueryType { unsafe { tsQuery_getType(self.this) } }
	fn type_name_with_type(type_: QueryType) -> string::String { unsafe { get_cstring(tsQuery_getTypeName_QT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsQuery_getTypeName_c(self.this)) } }
	fn type_size(&self) -> usize { unsafe { tsQuery_getTypeSize(self.this) } }
	fn is_time(&self) -> bool { unsafe { tsQuery_isTime(self.this) != 0 } }
	fn is_clock(&self) -> bool { unsafe { tsQuery_isClock(self.this) != 0 } }
	fn is_samples(&self) -> bool { unsafe { tsQuery_isSamples(self.this) != 0 } }
	fn is_samples1(&self) -> bool { unsafe { tsQuery_isSamples1(self.this) != 0 } }
	fn is_statistics(&self) -> bool { unsafe { tsQuery_isStatistics(self.this) != 0 } }
	fn is_time_type(&self) -> bool { unsafe { tsQuery_isTimeType(self.this) != 0 } }
	fn is_samples_type(&self) -> bool { unsafe { tsQuery_isSamplesType(self.this) != 0 } }
	fn get(&self, dest: *mut c_void, size: usize) -> bool { unsafe { tsQuery_get(self.this, dest, size, 1) != 0 } }
	fn get_with_wait(&self, dest: *mut c_void, size: usize, wait: bool) -> bool { unsafe { tsQuery_get(self.this, dest, size, if wait {1} else {0}) != 0 } }
	fn time(&self) -> u64 { unsafe { tsQuery_getTime(self.this, 1, ptr::null_mut()) } }
	fn time_with_wait(&self, wait: bool) -> u64 { unsafe { tsQuery_getTime(self.this, if wait {1} else {0}, ptr::null_mut()) } }
	fn time_with_wait_status(&self, wait: bool, status: *mut u8) -> u64 { unsafe { tsQuery_getTime(self.this, if wait {1} else {0}, status) } }
	fn samples(&self) -> u32 { unsafe { tsQuery_getSamples(self.this, 1, ptr::null_mut()) } }
	fn samples_with_wait(&self, wait: bool) -> u32 { unsafe { tsQuery_getSamples(self.this, if wait {1} else {0}, ptr::null_mut()) } }
	fn samples_with_wait_status(&self, wait: bool, status: *mut u8) -> u32 { unsafe { tsQuery_getSamples(self.this, if wait {1} else {0}, status) } }
	fn statistics(&self) -> QueryStatistics { unsafe { tsQuery_getStatistics(self.this, 1, ptr::null_mut()) } }
	fn statistics_with_wait(&self, wait: bool) -> QueryStatistics { unsafe { tsQuery_getStatistics(self.this, if wait {1} else {0}, ptr::null_mut()) } }
	fn statistics_with_wait_status(&self, wait: bool, status: *mut u8) -> QueryStatistics { unsafe { tsQuery_getStatistics(self.this, if wait {1} else {0}, status) } }
}
impl Drop for Query {
	fn drop(&mut self) { if self.owner { unsafe { tsQuery_delete(self.this) } } }
}
impl Clone for Query {
	fn clone(&self) -> Query { unsafe { Query { this: tsQuery_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Query { }
impl fmt::Display for Query {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Query ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsQuery_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsQuery_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsQuery_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsQuery_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsQuery_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsQuery_new() -> *mut c_void;
	fn tsQuery_delete(this: *mut c_void);
	fn tsQuery_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsQuery_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsQuery_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsQuery_clearPtr(this: *const c_void);
	fn tsQuery_destroyPtr(this: *const c_void);
	fn tsQuery_acquirePtr(this: *const c_void);
	fn tsQuery_unacquirePtr(this: *const c_void);
	fn tsQuery_isValidPtr(this: *const c_void) -> i32;
	fn tsQuery_isOwnerPtr(this: *const c_void) -> i32;
	fn tsQuery_isConstPtr(this: *const c_void) -> i32;
	fn tsQuery_getCountPtr(this: *const c_void) -> u32;
	fn tsQuery_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsQuery_getPlatform(this: *const c_void) -> Platform;
	fn tsQuery_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsQuery_getIndex(this: *const c_void) -> u32;
	fn tsQuery_clear(this: *mut c_void);
	fn tsQuery_isCreated(this: *const c_void) -> i32;
	fn tsQuery_isAvailable(this: *const c_void) -> i32;
	fn tsQuery_isBegan(this: *const c_void) -> i32;
	fn tsQuery_isEnded(this: *const c_void) -> i32;
	fn tsQuery_create(this: *mut c_void, type_: QueryType) -> i32;
	fn tsQuery_getType(this: *const c_void) -> QueryType;
	fn tsQuery_getTypeName_QT(type_: QueryType) -> *const c_char;
	fn tsQuery_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsQuery_getTypeSize(this: *const c_void) -> usize;
	fn tsQuery_isTime(this: *const c_void) -> i32;
	fn tsQuery_isClock(this: *const c_void) -> i32;
	fn tsQuery_isSamples(this: *const c_void) -> i32;
	fn tsQuery_isSamples1(this: *const c_void) -> i32;
	fn tsQuery_isStatistics(this: *const c_void) -> i32;
	fn tsQuery_isTimeType(this: *const c_void) -> i32;
	fn tsQuery_isSamplesType(this: *const c_void) -> i32;
	fn tsQuery_get(this: *const c_void, dest: *mut c_void, size: usize, wait: i32) -> i32;
	fn tsQuery_getTime(this: *const c_void, wait: i32, status: *mut u8) -> u64;
	fn tsQuery_getSamples(this: *const c_void, wait: i32, status: *mut u8) -> u32;
	fn tsQuery_getStatistics(this: *const c_void, wait: i32, status: *mut u8) -> QueryStatistics;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryStatistics {
	pub num_vertices: u64,
	pub num_primitives: u64,
	pub vertex_invocations: u64,
	pub control_invocations: u64,
	pub evaluate_invocations: u64,
	pub geometry_invocations: u64,
	pub geometry_primitives: u64,
	pub fragment_invocations: u64,
	pub compute_invocations: u64,
	pub clipping_invocations: u64,
	pub clipping_primitives: u64,
}
impl fmt::Display for QueryStatistics {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("num_vertices: {0}\n", self.num_vertices);
		ret += &format!("num_primitives: {0}\n", self.num_primitives);
		ret += &format!("vertex_invocations: {0}\n", self.vertex_invocations);
		ret += &format!("control_invocations: {0}\n", self.control_invocations);
		ret += &format!("evaluate_invocations: {0}\n", self.evaluate_invocations);
		ret += &format!("geometry_invocations: {0}\n", self.geometry_invocations);
		ret += &format!("geometry_primitives: {0}\n", self.geometry_primitives);
		ret += &format!("fragment_invocations: {0}\n", self.fragment_invocations);
		ret += &format!("compute_invocations: {0}\n", self.compute_invocations);
		ret += &format!("clipping_invocations: {0}\n", self.clipping_invocations);
		ret += &format!("clipping_primitives: {0}", self.clipping_primitives);
		write!(f, "{0}", ret)
	}
}

// Tellusim::FUQuery
pub struct FUQuery {
	this: *mut c_void,
	owner: bool,
}
impl FUQuery {
	pub fn null() -> FUQuery { FUQuery { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUQuery { unsafe { FUQuery { this: tsFUQuery_new(), owner: true } } }
	pub fn new_with_queries(queries: &[&mut Query]) -> FUQuery {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { FUQuery { this: tsFUQuery_new_cAQb(queries_.as_ptr(), queries.len() as u32, 0), owner: true } }
	}
	pub fn new_with_queries_owner(queries: &[&mut Query], owner: bool) -> FUQuery {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { FUQuery { this: tsFUQuery_new_cAQb(queries_.as_ptr(), queries.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUQuery { unsafe { FUQuery { this: ptr, owner: tsFUQuery_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUQuery { unsafe { FUQuery { this: tsFUQuery_copyPtr(self.this), owner: true } } }
	pub fn from_query(ptr: &Query) -> FUQuery { unsafe { FUQuery::new_ptr(tsFUQuery_castQueryPtr(ptr.this)) } }
	pub fn to_query(&self) -> Query { unsafe { Query::new_ptr(tsFUQuery_baseQueryPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUQuery) -> bool { unsafe { tsFUQuery_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUQuery { unsafe { FUQuery { this: tsFUQuery_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUQuery_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUQuery_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUQuery_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUQuery_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUQuery_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUQuery_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUQuery_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUQuery_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUQuery_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUQuery_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUQuery_getMask(self.this) } }
	pub fn num_queries(&self) -> u32 { unsafe { tsFUQuery_getNumQueries(self.this) } }
	pub fn query(&self, index: u32) -> Query { unsafe { Query::new_ptr(tsFUQuery_getQuery_cu(self.this, index)) } }
	pub fn query_mut(&mut self, index: u32) -> Query { unsafe { Query::new_ptr(tsFUQuery_getQuery_u(self.this, index)) } }
}
impl QueryTrait for FUQuery {
	fn platform(&self) -> Platform { unsafe { tsQuery_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsQuery_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsQuery_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsQuery_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsQuery_isCreated(self.this) != 0 } }
	fn is_available(&self) -> bool { unsafe { tsQuery_isAvailable(self.this) != 0 } }
	fn is_began(&self) -> bool { unsafe { tsQuery_isBegan(self.this) != 0 } }
	fn is_ended(&self) -> bool { unsafe { tsQuery_isEnded(self.this) != 0 } }
	fn create(&mut self, type_: QueryType) -> bool { unsafe { tsQuery_create(self.this, type_) != 0 } }
	fn type_(&self) -> QueryType { unsafe { tsQuery_getType(self.this) } }
	fn type_name_with_type(type_: QueryType) -> string::String { unsafe { get_cstring(tsQuery_getTypeName_QT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsQuery_getTypeName_c(self.this)) } }
	fn type_size(&self) -> usize { unsafe { tsQuery_getTypeSize(self.this) } }
	fn is_time(&self) -> bool { unsafe { tsQuery_isTime(self.this) != 0 } }
	fn is_clock(&self) -> bool { unsafe { tsQuery_isClock(self.this) != 0 } }
	fn is_samples(&self) -> bool { unsafe { tsQuery_isSamples(self.this) != 0 } }
	fn is_samples1(&self) -> bool { unsafe { tsQuery_isSamples1(self.this) != 0 } }
	fn is_statistics(&self) -> bool { unsafe { tsQuery_isStatistics(self.this) != 0 } }
	fn is_time_type(&self) -> bool { unsafe { tsQuery_isTimeType(self.this) != 0 } }
	fn is_samples_type(&self) -> bool { unsafe { tsQuery_isSamplesType(self.this) != 0 } }
	fn get(&self, dest: *mut c_void, size: usize) -> bool { unsafe { tsQuery_get(self.this, dest, size, 1) != 0 } }
	fn get_with_wait(&self, dest: *mut c_void, size: usize, wait: bool) -> bool { unsafe { tsQuery_get(self.this, dest, size, if wait {1} else {0}) != 0 } }
	fn time(&self) -> u64 { unsafe { tsQuery_getTime(self.this, 1, ptr::null_mut()) } }
	fn time_with_wait(&self, wait: bool) -> u64 { unsafe { tsQuery_getTime(self.this, if wait {1} else {0}, ptr::null_mut()) } }
	fn time_with_wait_status(&self, wait: bool, status: *mut u8) -> u64 { unsafe { tsQuery_getTime(self.this, if wait {1} else {0}, status) } }
	fn samples(&self) -> u32 { unsafe { tsQuery_getSamples(self.this, 1, ptr::null_mut()) } }
	fn samples_with_wait(&self, wait: bool) -> u32 { unsafe { tsQuery_getSamples(self.this, if wait {1} else {0}, ptr::null_mut()) } }
	fn samples_with_wait_status(&self, wait: bool, status: *mut u8) -> u32 { unsafe { tsQuery_getSamples(self.this, if wait {1} else {0}, status) } }
	fn statistics(&self) -> QueryStatistics { unsafe { tsQuery_getStatistics(self.this, 1, ptr::null_mut()) } }
	fn statistics_with_wait(&self, wait: bool) -> QueryStatistics { unsafe { tsQuery_getStatistics(self.this, if wait {1} else {0}, ptr::null_mut()) } }
	fn statistics_with_wait_status(&self, wait: bool, status: *mut u8) -> QueryStatistics { unsafe { tsQuery_getStatistics(self.this, if wait {1} else {0}, status) } }
}
impl Drop for FUQuery {
	fn drop(&mut self) { if self.owner { unsafe { tsFUQuery_delete(self.this) } } }
}
impl Clone for FUQuery {
	fn clone(&self) -> FUQuery { unsafe { FUQuery { this: tsFUQuery_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUQuery { }
impl fmt::Display for FUQuery {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUQuery ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUQuery_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUQuery_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUQuery_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUQuery_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUQuery_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUQuery_new() -> *mut c_void;
	fn tsFUQuery_new_cAQb(queries: *const *mut c_void, queries_size: u32, owner: i32) -> *mut c_void;
	fn tsFUQuery_delete(this: *mut c_void);
	fn tsFUQuery_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUQuery_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUQuery_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUQuery_clearPtr(this: *const c_void);
	fn tsFUQuery_destroyPtr(this: *const c_void);
	fn tsFUQuery_acquirePtr(this: *const c_void);
	fn tsFUQuery_unacquirePtr(this: *const c_void);
	fn tsFUQuery_isValidPtr(this: *const c_void) -> i32;
	fn tsFUQuery_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUQuery_isConstPtr(this: *const c_void) -> i32;
	fn tsFUQuery_getCountPtr(this: *const c_void) -> u32;
	fn tsFUQuery_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUQuery_equalQueryPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUQuery_castQueryPtr(this: *const c_void) -> *mut c_void;
	fn tsFUQuery_baseQueryPtr(this: *const c_void) -> *mut c_void;
	fn tsFUQuery_setMask(this: *mut c_void, mask: u32);
	fn tsFUQuery_getMask(this: *const c_void) -> u32;
	fn tsFUQuery_getNumQueries(this: *const c_void) -> u32;
	fn tsFUQuery_getQuery_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUQuery_getQuery_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Fence
pub struct Fence {
	this: *mut c_void,
	owner: bool,
}
impl Fence {
	pub fn null() -> Fence { Fence { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Fence { unsafe { Fence { this: tsFence_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Fence { unsafe { Fence { this: ptr, owner: tsFence_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Fence { unsafe { Fence { this: tsFence_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Fence) -> bool { unsafe { tsFence_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Fence { unsafe { Fence { this: tsFence_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFence_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFence_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFence_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFence_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFence_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFence_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFence_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFence_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFence_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait FenceTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn create(&mut self) -> bool;
	fn create_with_flags(&mut self, flags: FenceFlags) -> bool;
	fn flags(&self) -> FenceFlags;
	fn has_flag(&self, flags: FenceFlags) -> bool;
	fn has_flags(&self, flags: FenceFlags) -> bool;
	fn flags_name(&self) -> string::String;
	fn description(&self) -> string::String;
}
impl FenceTrait for Fence {
	fn platform(&self) -> Platform { unsafe { tsFence_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsFence_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsFence_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsFence_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsFence_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsFence_create(self.this, FenceFlags::None) != 0 } }
	fn create_with_flags(&mut self, flags: FenceFlags) -> bool { unsafe { tsFence_create(self.this, flags) != 0 } }
	fn flags(&self) -> FenceFlags { unsafe { tsFence_getFlags(self.this) } }
	fn has_flag(&self, flags: FenceFlags) -> bool { unsafe { tsFence_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: FenceFlags) -> bool { unsafe { tsFence_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsFence_getFlagsName(self.this)) } }
	fn description(&self) -> string::String { unsafe { get_string(tsFence_getDescription(self.this)) } }
}
impl Drop for Fence {
	fn drop(&mut self) { if self.owner { unsafe { tsFence_delete(self.this) } } }
}
impl Clone for Fence {
	fn clone(&self) -> Fence { unsafe { Fence { this: tsFence_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Fence { }
impl fmt::Display for Fence {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Fence ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFence_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFence_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFence_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFence_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFence_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFence_new() -> *mut c_void;
	fn tsFence_delete(this: *mut c_void);
	fn tsFence_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFence_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFence_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFence_clearPtr(this: *const c_void);
	fn tsFence_destroyPtr(this: *const c_void);
	fn tsFence_acquirePtr(this: *const c_void);
	fn tsFence_unacquirePtr(this: *const c_void);
	fn tsFence_isValidPtr(this: *const c_void) -> i32;
	fn tsFence_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFence_isConstPtr(this: *const c_void) -> i32;
	fn tsFence_getCountPtr(this: *const c_void) -> u32;
	fn tsFence_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFence_getPlatform(this: *const c_void) -> Platform;
	fn tsFence_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsFence_getIndex(this: *const c_void) -> u32;
	fn tsFence_clear(this: *mut c_void);
	fn tsFence_isCreated(this: *const c_void) -> i32;
	fn tsFence_create(this: *mut c_void, flags: FenceFlags) -> i32;
	fn tsFence_getFlags(this: *const c_void) -> FenceFlags;
	fn tsFence_hasFlag(this: *const c_void, flags: FenceFlags) -> i32;
	fn tsFence_hasFlags(this: *const c_void, flags: FenceFlags) -> i32;
	fn tsFence_getFlagsName(this: *const c_void) -> *mut c_void;
	fn tsFence_getDescription(this: *const c_void) -> *mut c_void;
}

// Tellusim::VKFence
pub struct VKFence {
	this: *mut c_void,
	owner: bool,
}
impl VKFence {
	pub fn null() -> VKFence { VKFence { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKFence { unsafe { VKFence { this: tsVKFence_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKFence { unsafe { VKFence { this: ptr, owner: tsVKFence_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKFence { unsafe { VKFence { this: tsVKFence_copyPtr(self.this), owner: true } } }
	pub fn from_fence(ptr: &Fence) -> VKFence { unsafe { VKFence::new_ptr(tsVKFence_castFencePtr(ptr.this)) } }
	pub fn to_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsVKFence_baseFencePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKFence) -> bool { unsafe { tsVKFence_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKFence { unsafe { VKFence { this: tsVKFence_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKFence_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKFence_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKFence_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKFence_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKFence_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKFence_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKFence_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKFence_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKFence_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn vk_fence(&self) -> *const c_void { unsafe { tsVKFence_getVKFence(self.this) } }
	pub fn semaphore(&self) -> *const c_void { unsafe { tsVKFence_getSemaphore(self.this) } }
	pub fn shared_handle(&self) -> *mut c_void { unsafe { tsVKFence_getSharedHandle(self.this) } }
}
impl FenceTrait for VKFence {
	fn platform(&self) -> Platform { unsafe { tsFence_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsFence_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsFence_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsFence_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsFence_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsFence_create(self.this, FenceFlags::None) != 0 } }
	fn create_with_flags(&mut self, flags: FenceFlags) -> bool { unsafe { tsFence_create(self.this, flags) != 0 } }
	fn flags(&self) -> FenceFlags { unsafe { tsFence_getFlags(self.this) } }
	fn has_flag(&self, flags: FenceFlags) -> bool { unsafe { tsFence_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: FenceFlags) -> bool { unsafe { tsFence_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsFence_getFlagsName(self.this)) } }
	fn description(&self) -> string::String { unsafe { get_string(tsFence_getDescription(self.this)) } }
}
impl Drop for VKFence {
	fn drop(&mut self) { if self.owner { unsafe { tsVKFence_delete(self.this) } } }
}
impl Clone for VKFence {
	fn clone(&self) -> VKFence { unsafe { VKFence { this: tsVKFence_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKFence { }
impl fmt::Display for VKFence {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKFence ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKFence_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKFence_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKFence_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKFence_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKFence_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKFence_new() -> *mut c_void;
	fn tsVKFence_delete(this: *mut c_void);
	fn tsVKFence_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKFence_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKFence_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKFence_clearPtr(this: *const c_void);
	fn tsVKFence_destroyPtr(this: *const c_void);
	fn tsVKFence_acquirePtr(this: *const c_void);
	fn tsVKFence_unacquirePtr(this: *const c_void);
	fn tsVKFence_isValidPtr(this: *const c_void) -> i32;
	fn tsVKFence_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKFence_isConstPtr(this: *const c_void) -> i32;
	fn tsVKFence_getCountPtr(this: *const c_void) -> u32;
	fn tsVKFence_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKFence_equalFencePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKFence_castFencePtr(this: *const c_void) -> *mut c_void;
	fn tsVKFence_baseFencePtr(this: *const c_void) -> *mut c_void;
	fn tsVKFence_getVKFence(this: *const c_void) -> *const c_void;
	fn tsVKFence_getSemaphore(this: *const c_void) -> *const c_void;
	fn tsVKFence_getSharedHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::FUFence
pub struct FUFence {
	this: *mut c_void,
	owner: bool,
}
impl FUFence {
	pub fn null() -> FUFence { FUFence { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUFence { unsafe { FUFence { this: tsFUFence_new(), owner: true } } }
	pub fn new_with_fences(fences: &[&mut Fence]) -> FUFence {
		let mut fences_ = Vec::new();
		for ptr in fences { fences_.push(ptr.this); }
		unsafe { FUFence { this: tsFUFence_new_cAFb(fences_.as_ptr(), fences.len() as u32, 0), owner: true } }
	}
	pub fn new_with_fences_owner(fences: &[&mut Fence], owner: bool) -> FUFence {
		let mut fences_ = Vec::new();
		for ptr in fences { fences_.push(ptr.this); }
		unsafe { FUFence { this: tsFUFence_new_cAFb(fences_.as_ptr(), fences.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUFence { unsafe { FUFence { this: ptr, owner: tsFUFence_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUFence { unsafe { FUFence { this: tsFUFence_copyPtr(self.this), owner: true } } }
	pub fn from_fence(ptr: &Fence) -> FUFence { unsafe { FUFence::new_ptr(tsFUFence_castFencePtr(ptr.this)) } }
	pub fn to_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsFUFence_baseFencePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUFence) -> bool { unsafe { tsFUFence_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUFence { unsafe { FUFence { this: tsFUFence_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUFence_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUFence_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUFence_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUFence_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUFence_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUFence_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUFence_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUFence_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUFence_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUFence_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUFence_getMask(self.this) } }
	pub fn num_fences(&self) -> u32 { unsafe { tsFUFence_getNumFences(self.this) } }
	pub fn fence(&self, index: u32) -> Fence { unsafe { Fence::new_ptr(tsFUFence_getFence_cu(self.this, index)) } }
	pub fn fence_mut(&mut self, index: u32) -> Fence { unsafe { Fence::new_ptr(tsFUFence_getFence_u(self.this, index)) } }
}
impl FenceTrait for FUFence {
	fn platform(&self) -> Platform { unsafe { tsFence_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsFence_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsFence_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsFence_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsFence_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsFence_create(self.this, FenceFlags::None) != 0 } }
	fn create_with_flags(&mut self, flags: FenceFlags) -> bool { unsafe { tsFence_create(self.this, flags) != 0 } }
	fn flags(&self) -> FenceFlags { unsafe { tsFence_getFlags(self.this) } }
	fn has_flag(&self, flags: FenceFlags) -> bool { unsafe { tsFence_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: FenceFlags) -> bool { unsafe { tsFence_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsFence_getFlagsName(self.this)) } }
	fn description(&self) -> string::String { unsafe { get_string(tsFence_getDescription(self.this)) } }
}
impl Drop for FUFence {
	fn drop(&mut self) { if self.owner { unsafe { tsFUFence_delete(self.this) } } }
}
impl Clone for FUFence {
	fn clone(&self) -> FUFence { unsafe { FUFence { this: tsFUFence_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUFence { }
impl fmt::Display for FUFence {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUFence ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUFence_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUFence_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUFence_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUFence_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUFence_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUFence_new() -> *mut c_void;
	fn tsFUFence_new_cAFb(fences: *const *mut c_void, fences_size: u32, owner: i32) -> *mut c_void;
	fn tsFUFence_delete(this: *mut c_void);
	fn tsFUFence_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUFence_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUFence_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUFence_clearPtr(this: *const c_void);
	fn tsFUFence_destroyPtr(this: *const c_void);
	fn tsFUFence_acquirePtr(this: *const c_void);
	fn tsFUFence_unacquirePtr(this: *const c_void);
	fn tsFUFence_isValidPtr(this: *const c_void) -> i32;
	fn tsFUFence_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUFence_isConstPtr(this: *const c_void) -> i32;
	fn tsFUFence_getCountPtr(this: *const c_void) -> u32;
	fn tsFUFence_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUFence_equalFencePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUFence_castFencePtr(this: *const c_void) -> *mut c_void;
	fn tsFUFence_baseFencePtr(this: *const c_void) -> *mut c_void;
	fn tsFUFence_setMask(this: *mut c_void, mask: u32);
	fn tsFUFence_getMask(this: *const c_void) -> u32;
	fn tsFUFence_getNumFences(this: *const c_void) -> u32;
	fn tsFUFence_getFence_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUFence_getFence_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Shader
pub struct Shader {
	this: *mut c_void,
	owner: bool,
}
impl Shader {
	pub fn null() -> Shader { Shader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Shader { unsafe { Shader { this: tsShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Shader { unsafe { Shader { this: ptr, owner: tsShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Shader { unsafe { Shader { this: tsShader_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Shader) -> bool { unsafe { tsShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Shader { unsafe { Shader { this: tsShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ShaderTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn save_state(&self, stream: &mut Stream) -> bool;
	fn type_(&self) -> ShaderType;
	fn type_name_with_type(type_: ShaderType) -> string::String;
	fn type_name(&self) -> string::String;
	fn is_vertex(&self) -> bool;
	fn is_control(&self) -> bool;
	fn is_evaluate(&self) -> bool;
	fn is_geometry(&self) -> bool;
	fn is_fragment(&self) -> bool;
	fn is_compute(&self) -> bool;
	fn is_task(&self) -> bool;
	fn is_mesh(&self) -> bool;
	fn is_ray_gen(&self) -> bool;
	fn is_ray_miss(&self) -> bool;
	fn is_closest(&self) -> bool;
	fn is_first_hit(&self) -> bool;
	fn is_intersection(&self) -> bool;
	fn is_callable(&self) -> bool;
	fn is_graphics_type(&self) -> bool;
	fn is_tessellation_type(&self) -> bool;
	fn is_tracing_type(&self) -> bool;
	fn is_mesh_type(&self) -> bool;
	fn name(&self) -> string::String;
	fn macros(&self) -> string::String;
	fn set_sampler_offset(&mut self, offset: i32);
	fn sampler_offset(&self) -> i32;
	fn set_texture_offset(&mut self, offset: i32);
	fn texture_offset(&self) -> i32;
	fn set_surface_offset(&mut self, offset: i32);
	fn surface_offset(&self) -> i32;
	fn set_uniform_offset(&mut self, offset: i32);
	fn uniform_offset(&self) -> i32;
	fn set_storage_offset(&mut self, offset: i32);
	fn storage_offset(&self) -> i32;
	fn set_tracing_offset(&mut self, offset: i32);
	fn tracing_offset(&self) -> i32;
	fn set_texel_offset(&mut self, offset: i32);
	fn texel_offset(&self) -> i32;
	fn set_table_offset(&mut self, offset: i32);
	fn table_offset(&self) -> i32;
	fn set_patch_size(&mut self, size: u32);
	fn patch_size(&self) -> u32;
	fn set_input_size(&mut self, size: u32);
	fn input_size(&self) -> u32;
	fn set_output_size(&mut self, size: u32);
	fn output_size(&self) -> u32;
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool;
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool;
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool;
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool;
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool;
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool;
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool;
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool;
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool;
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool;
	fn has_cache() -> bool;
	fn set_cache(name: &str) -> bool;
	fn load_cache(hash: &String, stream: &mut Stream) -> bool;
	fn save_cache(hash: &String, stream: &mut Stream) -> bool;
	fn clear_cache();
	fn is_macro(name: &str) -> bool;
	fn set_macro(name: &str, value: i32) -> bool;
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool;
	fn set_macro_with_value(name: &str, value: &str) -> bool;
	fn set_macros(macros: &str) -> bool;
	fn remove_macro(name: &str) -> bool;
	fn clear_macros();
	fn is_include(name: &str) -> bool;
	fn set_include(name: &str, src: &String) -> bool;
	fn remove_include(name: &str) -> bool;
	fn clear_includes();
	fn preprocessor(src: &str, format: &str) -> string::String;
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String;
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String;
}
impl ShaderTrait for Shader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for Shader {
	fn drop(&mut self) { if self.owner { unsafe { tsShader_delete(self.this) } } }
}
impl Clone for Shader {
	fn clone(&self) -> Shader { unsafe { Shader { this: tsShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Shader { }
impl fmt::Display for Shader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Shader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsShader_new() -> *mut c_void;
	fn tsShader_delete(this: *mut c_void);
	fn tsShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsShader_clearPtr(this: *const c_void);
	fn tsShader_destroyPtr(this: *const c_void);
	fn tsShader_acquirePtr(this: *const c_void);
	fn tsShader_unacquirePtr(this: *const c_void);
	fn tsShader_isValidPtr(this: *const c_void) -> i32;
	fn tsShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsShader_isConstPtr(this: *const c_void) -> i32;
	fn tsShader_getCountPtr(this: *const c_void) -> u32;
	fn tsShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsShader_getPlatform(this: *const c_void) -> Platform;
	fn tsShader_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsShader_getIndex(this: *const c_void) -> u32;
	fn tsShader_clear(this: *mut c_void);
	fn tsShader_isCreated(this: *const c_void) -> i32;
	fn tsShader_saveState(this: *const c_void, stream: *mut c_void) -> i32;
	fn tsShader_getType(this: *const c_void) -> ShaderType;
	fn tsShader_getTypeName_ST(type_: ShaderType) -> *const c_char;
	fn tsShader_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsShader_isVertex(this: *const c_void) -> i32;
	fn tsShader_isControl(this: *const c_void) -> i32;
	fn tsShader_isEvaluate(this: *const c_void) -> i32;
	fn tsShader_isGeometry(this: *const c_void) -> i32;
	fn tsShader_isFragment(this: *const c_void) -> i32;
	fn tsShader_isCompute(this: *const c_void) -> i32;
	fn tsShader_isTask(this: *const c_void) -> i32;
	fn tsShader_isMesh(this: *const c_void) -> i32;
	fn tsShader_isRayGen(this: *const c_void) -> i32;
	fn tsShader_isRayMiss(this: *const c_void) -> i32;
	fn tsShader_isClosest(this: *const c_void) -> i32;
	fn tsShader_isFirstHit(this: *const c_void) -> i32;
	fn tsShader_isIntersection(this: *const c_void) -> i32;
	fn tsShader_isCallable(this: *const c_void) -> i32;
	fn tsShader_isGraphicsType(this: *const c_void) -> i32;
	fn tsShader_isTessellationType(this: *const c_void) -> i32;
	fn tsShader_isTracingType(this: *const c_void) -> i32;
	fn tsShader_isMeshType(this: *const c_void) -> i32;
	fn tsShader_getName(this: *const c_void) -> *mut c_void;
	fn tsShader_getMacros(this: *const c_void) -> *mut c_void;
	fn tsShader_setSamplerOffset(this: *mut c_void, offset: i32);
	fn tsShader_getSamplerOffset(this: *const c_void) -> i32;
	fn tsShader_setTextureOffset(this: *mut c_void, offset: i32);
	fn tsShader_getTextureOffset(this: *const c_void) -> i32;
	fn tsShader_setSurfaceOffset(this: *mut c_void, offset: i32);
	fn tsShader_getSurfaceOffset(this: *const c_void) -> i32;
	fn tsShader_setUniformOffset(this: *mut c_void, offset: i32);
	fn tsShader_getUniformOffset(this: *const c_void) -> i32;
	fn tsShader_setStorageOffset(this: *mut c_void, offset: i32);
	fn tsShader_getStorageOffset(this: *const c_void) -> i32;
	fn tsShader_setTracingOffset(this: *mut c_void, offset: i32);
	fn tsShader_getTracingOffset(this: *const c_void) -> i32;
	fn tsShader_setTexelOffset(this: *mut c_void, offset: i32);
	fn tsShader_getTexelOffset(this: *const c_void) -> i32;
	fn tsShader_setTableOffset(this: *mut c_void, offset: i32);
	fn tsShader_getTableOffset(this: *const c_void) -> i32;
	fn tsShader_setPatchSize(this: *mut c_void, size: u32);
	fn tsShader_getPatchSize(this: *const c_void) -> u32;
	fn tsShader_setInputSize(this: *mut c_void, size: u32);
	fn tsShader_getInputSize(this: *const c_void) -> u32;
	fn tsShader_setOutputSize(this: *mut c_void, size: u32);
	fn tsShader_getOutputSize(this: *const c_void) -> u32;
	fn tsShader_load_STss(this: *mut c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> i32;
	fn tsShader_create_STss(this: *mut c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> i32;
	fn tsShader_load_STscSspu(this: *mut c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsShader_create_STscSspu(this: *mut c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsShader_loadGLSL_STss(this: *mut c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> i32;
	fn tsShader_createGLSL_STss(this: *mut c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> i32;
	fn tsShader_loadGLSL_STscSspu(this: *mut c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsShader_createGLSL_STscSspu(this: *mut c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsShader_loadSPIRV(this: *mut c_void, type_: ShaderType, name: *const c_char) -> i32;
	fn tsShader_createSPIRV(this: *mut c_void, type_: ShaderType, data: *const u32, data_size: u32) -> i32;
	fn tsShader_hasCache() -> i32;
	fn tsShader_setCache(name: *const c_char) -> i32;
	fn tsShader_loadCache(hash: *mut c_void, stream: *mut c_void) -> i32;
	fn tsShader_saveCache(hash: *mut c_void, stream: *mut c_void) -> i32;
	fn tsShader_clearCache();
	fn tsShader_isMacro(name: *const c_char) -> i32;
	fn tsShader_setMacro_si(name: *const c_char, value: i32) -> i32;
	fn tsShader_setMacro_su(name: *const c_char, value: u32) -> i32;
	fn tsShader_setMacro_ss(name: *const c_char, value: *const c_char) -> i32;
	fn tsShader_setMacros(macros: *const c_char) -> i32;
	fn tsShader_removeMacro(name: *const c_char) -> i32;
	fn tsShader_clearMacros();
	fn tsShader_isInclude(name: *const c_char) -> i32;
	fn tsShader_setInclude(name: *const c_char, src: *mut c_void) -> i32;
	fn tsShader_removeInclude(name: *const c_char) -> i32;
	fn tsShader_clearIncludes();
	fn tsShader_preprocessor_ss(src: *const c_char, format: *const c_char) -> *mut c_void;
	fn tsShader_preprocessor_scSspu(src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> *mut c_void;
}

// Tellusim::ShaderCompiler
pub struct ShaderCompiler {
	this: *mut c_void,
	owner: bool,
}
impl ShaderCompiler {
	pub fn null() -> ShaderCompiler { ShaderCompiler { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ShaderCompiler { unsafe { ShaderCompiler { this: tsShaderCompiler_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ShaderCompiler { unsafe { ShaderCompiler { this: ptr, owner: tsShaderCompiler_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ShaderCompiler { unsafe { ShaderCompiler { this: tsShaderCompiler_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> ShaderCompiler { unsafe { ShaderCompiler::new_ptr(tsShaderCompiler_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsShaderCompiler_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ShaderCompiler) -> bool { unsafe { tsShaderCompiler_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ShaderCompiler { unsafe { ShaderCompiler { this: tsShaderCompiler_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsShaderCompiler_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsShaderCompiler_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsShaderCompiler_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsShaderCompiler_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsShaderCompiler_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsShaderCompiler_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsShaderCompiler_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsShaderCompiler_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsShaderCompiler_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_flags(&mut self, flags: ShaderCompilerFlags) { unsafe { tsShaderCompiler_setFlags(self.this, flags) } }
	pub fn flags(&self) -> ShaderCompilerFlags { unsafe { tsShaderCompiler_getFlags(self.this) } }
	pub fn binary(&self, stream: &mut Stream) -> bool { unsafe { tsShaderCompiler_getBinary(self.this, stream.this, Platform::Unknown) != 0 } }
	pub fn binary_with_platform(&self, stream: &mut Stream, platform: Platform) -> bool { unsafe { tsShaderCompiler_getBinary(self.this, stream.this, platform) != 0 } }
	pub fn source(&self) -> string::String { unsafe { get_string(tsShaderCompiler_getSource(self.this, Platform::Unknown)) } }
	pub fn source_with_platform(&self, platform: Platform) -> string::String { unsafe { get_string(tsShaderCompiler_getSource(self.this, platform)) } }
}
impl ShaderTrait for ShaderCompiler {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for ShaderCompiler {
	fn drop(&mut self) { if self.owner { unsafe { tsShaderCompiler_delete(self.this) } } }
}
impl Clone for ShaderCompiler {
	fn clone(&self) -> ShaderCompiler { unsafe { ShaderCompiler { this: tsShaderCompiler_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ShaderCompiler { }
impl fmt::Display for ShaderCompiler {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ShaderCompiler ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsShaderCompiler_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsShaderCompiler_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsShaderCompiler_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsShaderCompiler_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsShaderCompiler_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsShaderCompiler_new() -> *mut c_void;
	fn tsShaderCompiler_delete(this: *mut c_void);
	fn tsShaderCompiler_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsShaderCompiler_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsShaderCompiler_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsShaderCompiler_clearPtr(this: *const c_void);
	fn tsShaderCompiler_destroyPtr(this: *const c_void);
	fn tsShaderCompiler_acquirePtr(this: *const c_void);
	fn tsShaderCompiler_unacquirePtr(this: *const c_void);
	fn tsShaderCompiler_isValidPtr(this: *const c_void) -> i32;
	fn tsShaderCompiler_isOwnerPtr(this: *const c_void) -> i32;
	fn tsShaderCompiler_isConstPtr(this: *const c_void) -> i32;
	fn tsShaderCompiler_getCountPtr(this: *const c_void) -> u32;
	fn tsShaderCompiler_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsShaderCompiler_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsShaderCompiler_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsShaderCompiler_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsShaderCompiler_setFlags(this: *mut c_void, flags: ShaderCompilerFlags);
	fn tsShaderCompiler_getFlags(this: *const c_void) -> ShaderCompilerFlags;
	fn tsShaderCompiler_getBinary(this: *const c_void, stream: *mut c_void, platform: Platform) -> i32;
	fn tsShaderCompiler_getSource(this: *const c_void, platform: Platform) -> *mut c_void;
}

// Tellusim::D3D12Shader
pub struct D3D12Shader {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Shader {
	pub fn null() -> D3D12Shader { D3D12Shader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Shader { unsafe { D3D12Shader { this: tsD3D12Shader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Shader { unsafe { D3D12Shader { this: ptr, owner: tsD3D12Shader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Shader { unsafe { D3D12Shader { this: tsD3D12Shader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> D3D12Shader { unsafe { D3D12Shader::new_ptr(tsD3D12Shader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsD3D12Shader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Shader) -> bool { unsafe { tsD3D12Shader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Shader { unsafe { D3D12Shader { this: tsD3D12Shader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Shader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Shader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Shader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Shader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Shader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Shader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Shader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Shader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Shader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn shader_blob(&self) -> *const c_void { unsafe { tsD3D12Shader_getShaderBlob(self.this) } }
}
impl ShaderTrait for D3D12Shader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for D3D12Shader {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Shader_delete(self.this) } } }
}
impl Clone for D3D12Shader {
	fn clone(&self) -> D3D12Shader { unsafe { D3D12Shader { this: tsD3D12Shader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Shader { }
impl fmt::Display for D3D12Shader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Shader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Shader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Shader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Shader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Shader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Shader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Shader_new() -> *mut c_void;
	fn tsD3D12Shader_delete(this: *mut c_void);
	fn tsD3D12Shader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Shader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Shader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Shader_clearPtr(this: *const c_void);
	fn tsD3D12Shader_destroyPtr(this: *const c_void);
	fn tsD3D12Shader_acquirePtr(this: *const c_void);
	fn tsD3D12Shader_unacquirePtr(this: *const c_void);
	fn tsD3D12Shader_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Shader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Shader_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Shader_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Shader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Shader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Shader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Shader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Shader_getShaderBlob(this: *const c_void) -> *const c_void;
}

// Tellusim::D3D11Shader
pub struct D3D11Shader {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Shader {
	pub fn null() -> D3D11Shader { D3D11Shader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Shader { unsafe { D3D11Shader { this: tsD3D11Shader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Shader { unsafe { D3D11Shader { this: ptr, owner: tsD3D11Shader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Shader { unsafe { D3D11Shader { this: tsD3D11Shader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> D3D11Shader { unsafe { D3D11Shader::new_ptr(tsD3D11Shader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsD3D11Shader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Shader) -> bool { unsafe { tsD3D11Shader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Shader { unsafe { D3D11Shader { this: tsD3D11Shader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Shader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Shader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Shader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Shader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Shader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Shader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Shader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Shader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Shader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn d3d11_shader(&self) -> *mut c_void { unsafe { tsD3D11Shader_getD3D11Shader(self.this) } }
	pub fn shader_blob(&self) -> *const c_void { unsafe { tsD3D11Shader_getShaderBlob(self.this) } }
}
impl ShaderTrait for D3D11Shader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for D3D11Shader {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Shader_delete(self.this) } } }
}
impl Clone for D3D11Shader {
	fn clone(&self) -> D3D11Shader { unsafe { D3D11Shader { this: tsD3D11Shader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Shader { }
impl fmt::Display for D3D11Shader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Shader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Shader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Shader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Shader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Shader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Shader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Shader_new() -> *mut c_void;
	fn tsD3D11Shader_delete(this: *mut c_void);
	fn tsD3D11Shader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Shader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Shader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Shader_clearPtr(this: *const c_void);
	fn tsD3D11Shader_destroyPtr(this: *const c_void);
	fn tsD3D11Shader_acquirePtr(this: *const c_void);
	fn tsD3D11Shader_unacquirePtr(this: *const c_void);
	fn tsD3D11Shader_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Shader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Shader_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Shader_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Shader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Shader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Shader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Shader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Shader_getD3D11Shader(this: *const c_void) -> *mut c_void;
	fn tsD3D11Shader_getShaderBlob(this: *const c_void) -> *const c_void;
}

// Tellusim::MTLShader
pub struct MTLShader {
	this: *mut c_void,
	owner: bool,
}
impl MTLShader {
	pub fn null() -> MTLShader { MTLShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLShader { unsafe { MTLShader { this: tsMTLShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLShader { unsafe { MTLShader { this: ptr, owner: tsMTLShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLShader { unsafe { MTLShader { this: tsMTLShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> MTLShader { unsafe { MTLShader::new_ptr(tsMTLShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsMTLShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLShader) -> bool { unsafe { tsMTLShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLShader { unsafe { MTLShader { this: tsMTLShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_indirect(&mut self, enabled: bool) { unsafe { tsMTLShader_setIndirect(self.this, if enabled {1} else {0}) } }
	pub fn is_indirect(&self) -> bool { unsafe { tsMTLShader_isIndirect(self.this) != 0 } }
	pub fn library(&self) -> *mut c_void { unsafe { tsMTLShader_getLibrary(self.this) } }
	pub fn function(&self) -> *mut c_void { unsafe { tsMTLShader_getFunction(self.this) } }
}
impl ShaderTrait for MTLShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for MTLShader {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLShader_delete(self.this) } } }
}
impl Clone for MTLShader {
	fn clone(&self) -> MTLShader { unsafe { MTLShader { this: tsMTLShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLShader { }
impl fmt::Display for MTLShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLShader_new() -> *mut c_void;
	fn tsMTLShader_delete(this: *mut c_void);
	fn tsMTLShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLShader_clearPtr(this: *const c_void);
	fn tsMTLShader_destroyPtr(this: *const c_void);
	fn tsMTLShader_acquirePtr(this: *const c_void);
	fn tsMTLShader_unacquirePtr(this: *const c_void);
	fn tsMTLShader_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLShader_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLShader_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLShader_setIndirect(this: *mut c_void, enabled: i32);
	fn tsMTLShader_isIndirect(this: *const c_void) -> i32;
	fn tsMTLShader_getLibrary(this: *const c_void) -> *mut c_void;
	fn tsMTLShader_getFunction(this: *const c_void) -> *mut c_void;
}

// Tellusim::VKShader
pub struct VKShader {
	this: *mut c_void,
	owner: bool,
}
impl VKShader {
	pub fn null() -> VKShader { VKShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKShader { unsafe { VKShader { this: tsVKShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKShader { unsafe { VKShader { this: ptr, owner: tsVKShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKShader { unsafe { VKShader { this: tsVKShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> VKShader { unsafe { VKShader::new_ptr(tsVKShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsVKShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKShader) -> bool { unsafe { tsVKShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKShader { unsafe { VKShader { this: tsVKShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn module(&self) -> *const c_void { unsafe { tsVKShader_getModule(self.this) } }
}
impl ShaderTrait for VKShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for VKShader {
	fn drop(&mut self) { if self.owner { unsafe { tsVKShader_delete(self.this) } } }
}
impl Clone for VKShader {
	fn clone(&self) -> VKShader { unsafe { VKShader { this: tsVKShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKShader { }
impl fmt::Display for VKShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKShader_new() -> *mut c_void;
	fn tsVKShader_delete(this: *mut c_void);
	fn tsVKShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKShader_clearPtr(this: *const c_void);
	fn tsVKShader_destroyPtr(this: *const c_void);
	fn tsVKShader_acquirePtr(this: *const c_void);
	fn tsVKShader_unacquirePtr(this: *const c_void);
	fn tsVKShader_isValidPtr(this: *const c_void) -> i32;
	fn tsVKShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKShader_isConstPtr(this: *const c_void) -> i32;
	fn tsVKShader_getCountPtr(this: *const c_void) -> u32;
	fn tsVKShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsVKShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsVKShader_getModule(this: *const c_void) -> *const c_void;
}

// Tellusim::GLShader
pub struct GLShader {
	this: *mut c_void,
	owner: bool,
}
impl GLShader {
	pub fn null() -> GLShader { GLShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLShader { unsafe { GLShader { this: tsGLShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLShader { unsafe { GLShader { this: ptr, owner: tsGLShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLShader { unsafe { GLShader { this: tsGLShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> GLShader { unsafe { GLShader::new_ptr(tsGLShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsGLShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLShader) -> bool { unsafe { tsGLShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLShader { unsafe { GLShader { this: tsGLShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn attach_shader(&mut self, program_id: u32) -> bool { unsafe { tsGLShader_attachShader(self.this, program_id) != 0 } }
	pub fn shader_type(&self) -> u32 { unsafe { tsGLShader_getShaderType(self.this) } }
	pub fn shader_id(&self) -> u32 { unsafe { tsGLShader_getShaderID(self.this) } }
}
impl ShaderTrait for GLShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for GLShader {
	fn drop(&mut self) { if self.owner { unsafe { tsGLShader_delete(self.this) } } }
}
impl Clone for GLShader {
	fn clone(&self) -> GLShader { unsafe { GLShader { this: tsGLShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLShader { }
impl fmt::Display for GLShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLShader_new() -> *mut c_void;
	fn tsGLShader_delete(this: *mut c_void);
	fn tsGLShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLShader_clearPtr(this: *const c_void);
	fn tsGLShader_destroyPtr(this: *const c_void);
	fn tsGLShader_acquirePtr(this: *const c_void);
	fn tsGLShader_unacquirePtr(this: *const c_void);
	fn tsGLShader_isValidPtr(this: *const c_void) -> i32;
	fn tsGLShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLShader_isConstPtr(this: *const c_void) -> i32;
	fn tsGLShader_getCountPtr(this: *const c_void) -> u32;
	fn tsGLShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsGLShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsGLShader_attachShader(this: *mut c_void, program_id: u32) -> i32;
	fn tsGLShader_getShaderType(this: *const c_void) -> u32;
	fn tsGLShader_getShaderID(this: *const c_void) -> u32;
}

// Tellusim::GLESShader
pub struct GLESShader {
	this: *mut c_void,
	owner: bool,
}
impl GLESShader {
	pub fn null() -> GLESShader { GLESShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLESShader { unsafe { GLESShader { this: tsGLESShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLESShader { unsafe { GLESShader { this: ptr, owner: tsGLESShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLESShader { unsafe { GLESShader { this: tsGLESShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> GLESShader { unsafe { GLESShader::new_ptr(tsGLESShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsGLESShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLESShader) -> bool { unsafe { tsGLESShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLESShader { unsafe { GLESShader { this: tsGLESShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLESShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLESShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLESShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLESShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLESShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLESShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLESShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLESShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLESShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn attach_shader(&mut self, program_id: u32) -> bool { unsafe { tsGLESShader_attachShader(self.this, program_id) != 0 } }
	pub fn shader_type(&self) -> u32 { unsafe { tsGLESShader_getShaderType(self.this) } }
	pub fn shader_id(&self) -> u32 { unsafe { tsGLESShader_getShaderID(self.this) } }
}
impl ShaderTrait for GLESShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for GLESShader {
	fn drop(&mut self) { if self.owner { unsafe { tsGLESShader_delete(self.this) } } }
}
impl Clone for GLESShader {
	fn clone(&self) -> GLESShader { unsafe { GLESShader { this: tsGLESShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLESShader { }
impl fmt::Display for GLESShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLESShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLESShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLESShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLESShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLESShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLESShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLESShader_new() -> *mut c_void;
	fn tsGLESShader_delete(this: *mut c_void);
	fn tsGLESShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESShader_clearPtr(this: *const c_void);
	fn tsGLESShader_destroyPtr(this: *const c_void);
	fn tsGLESShader_acquirePtr(this: *const c_void);
	fn tsGLESShader_unacquirePtr(this: *const c_void);
	fn tsGLESShader_isValidPtr(this: *const c_void) -> i32;
	fn tsGLESShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLESShader_isConstPtr(this: *const c_void) -> i32;
	fn tsGLESShader_getCountPtr(this: *const c_void) -> u32;
	fn tsGLESShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESShader_attachShader(this: *mut c_void, program_id: u32) -> i32;
	fn tsGLESShader_getShaderType(this: *const c_void) -> u32;
	fn tsGLESShader_getShaderID(this: *const c_void) -> u32;
}

// Tellusim::CUShader
pub struct CUShader {
	this: *mut c_void,
	owner: bool,
}
impl CUShader {
	pub fn null() -> CUShader { CUShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CUShader { unsafe { CUShader { this: tsCUShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CUShader { unsafe { CUShader { this: ptr, owner: tsCUShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CUShader { unsafe { CUShader { this: tsCUShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> CUShader { unsafe { CUShader::new_ptr(tsCUShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsCUShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CUShader) -> bool { unsafe { tsCUShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CUShader { unsafe { CUShader { this: tsCUShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCUShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCUShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCUShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCUShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCUShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCUShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCUShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCUShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCUShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn module(&self) -> *const c_void { unsafe { tsCUShader_getModule(self.this) } }
	pub fn function(&self) -> *const c_void { unsafe { tsCUShader_getFunction(self.this) } }
}
impl ShaderTrait for CUShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for CUShader {
	fn drop(&mut self) { if self.owner { unsafe { tsCUShader_delete(self.this) } } }
}
impl Clone for CUShader {
	fn clone(&self) -> CUShader { unsafe { CUShader { this: tsCUShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CUShader { }
impl fmt::Display for CUShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CUShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCUShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCUShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCUShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCUShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCUShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCUShader_new() -> *mut c_void;
	fn tsCUShader_delete(this: *mut c_void);
	fn tsCUShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCUShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCUShader_clearPtr(this: *const c_void);
	fn tsCUShader_destroyPtr(this: *const c_void);
	fn tsCUShader_acquirePtr(this: *const c_void);
	fn tsCUShader_unacquirePtr(this: *const c_void);
	fn tsCUShader_isValidPtr(this: *const c_void) -> i32;
	fn tsCUShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCUShader_isConstPtr(this: *const c_void) -> i32;
	fn tsCUShader_getCountPtr(this: *const c_void) -> u32;
	fn tsCUShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCUShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsCUShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsCUShader_getModule(this: *const c_void) -> *const c_void;
	fn tsCUShader_getFunction(this: *const c_void) -> *const c_void;
}

// Tellusim::HIPShader
pub struct HIPShader {
	this: *mut c_void,
	owner: bool,
}
impl HIPShader {
	pub fn null() -> HIPShader { HIPShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> HIPShader { unsafe { HIPShader { this: tsHIPShader_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> HIPShader { unsafe { HIPShader { this: ptr, owner: tsHIPShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> HIPShader { unsafe { HIPShader { this: tsHIPShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> HIPShader { unsafe { HIPShader::new_ptr(tsHIPShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsHIPShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: HIPShader) -> bool { unsafe { tsHIPShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> HIPShader { unsafe { HIPShader { this: tsHIPShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsHIPShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsHIPShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsHIPShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsHIPShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsHIPShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsHIPShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsHIPShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsHIPShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsHIPShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn module(&self) -> *mut c_void { unsafe { tsHIPShader_getModule(self.this) } }
	pub fn function(&self) -> *mut c_void { unsafe { tsHIPShader_getFunction(self.this) } }
}
impl ShaderTrait for HIPShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for HIPShader {
	fn drop(&mut self) { if self.owner { unsafe { tsHIPShader_delete(self.this) } } }
}
impl Clone for HIPShader {
	fn clone(&self) -> HIPShader { unsafe { HIPShader { this: tsHIPShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for HIPShader { }
impl fmt::Display for HIPShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::HIPShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsHIPShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsHIPShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsHIPShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsHIPShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsHIPShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsHIPShader_new() -> *mut c_void;
	fn tsHIPShader_delete(this: *mut c_void);
	fn tsHIPShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsHIPShader_clearPtr(this: *const c_void);
	fn tsHIPShader_destroyPtr(this: *const c_void);
	fn tsHIPShader_acquirePtr(this: *const c_void);
	fn tsHIPShader_unacquirePtr(this: *const c_void);
	fn tsHIPShader_isValidPtr(this: *const c_void) -> i32;
	fn tsHIPShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsHIPShader_isConstPtr(this: *const c_void) -> i32;
	fn tsHIPShader_getCountPtr(this: *const c_void) -> u32;
	fn tsHIPShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPShader_getModule(this: *const c_void) -> *mut c_void;
	fn tsHIPShader_getFunction(this: *const c_void) -> *mut c_void;
}

// Tellusim::FUShader
pub struct FUShader {
	this: *mut c_void,
	owner: bool,
}
impl FUShader {
	pub fn null() -> FUShader { FUShader { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUShader { unsafe { FUShader { this: tsFUShader_new(), owner: true } } }
	pub fn new_with_shaders(shaders: &[&mut Shader]) -> FUShader {
		let mut shaders_ = Vec::new();
		for ptr in shaders { shaders_.push(ptr.this); }
		unsafe { FUShader { this: tsFUShader_new_cASb(shaders_.as_ptr(), shaders.len() as u32, 0), owner: true } }
	}
	pub fn new_with_shaders_owner(shaders: &[&mut Shader], owner: bool) -> FUShader {
		let mut shaders_ = Vec::new();
		for ptr in shaders { shaders_.push(ptr.this); }
		unsafe { FUShader { this: tsFUShader_new_cASb(shaders_.as_ptr(), shaders.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUShader { unsafe { FUShader { this: ptr, owner: tsFUShader_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUShader { unsafe { FUShader { this: tsFUShader_copyPtr(self.this), owner: true } } }
	pub fn from_shader(ptr: &Shader) -> FUShader { unsafe { FUShader::new_ptr(tsFUShader_castShaderPtr(ptr.this)) } }
	pub fn to_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsFUShader_baseShaderPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUShader) -> bool { unsafe { tsFUShader_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUShader { unsafe { FUShader { this: tsFUShader_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUShader_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUShader_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUShader_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUShader_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUShader_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUShader_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUShader_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUShader_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUShader_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUShader_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUShader_getMask(self.this) } }
	pub fn num_shaders(&self) -> u32 { unsafe { tsFUShader_getNumShaders(self.this) } }
	pub fn shader(&self, index: u32) -> Shader { unsafe { Shader::new_ptr(tsFUShader_getShader_cu(self.this, index)) } }
	pub fn shader_mut(&mut self, index: u32) -> Shader { unsafe { Shader::new_ptr(tsFUShader_getShader_u(self.this, index)) } }
}
impl ShaderTrait for FUShader {
	fn platform(&self) -> Platform { unsafe { tsShader_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsShader_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsShader_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsShader_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsShader_isCreated(self.this) != 0 } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsShader_saveState(self.this, stream.this) != 0 } }
	fn type_(&self) -> ShaderType { unsafe { tsShader_getType(self.this) } }
	fn type_name_with_type(type_: ShaderType) -> string::String { unsafe { get_cstring(tsShader_getTypeName_ST(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsShader_getTypeName_c(self.this)) } }
	fn is_vertex(&self) -> bool { unsafe { tsShader_isVertex(self.this) != 0 } }
	fn is_control(&self) -> bool { unsafe { tsShader_isControl(self.this) != 0 } }
	fn is_evaluate(&self) -> bool { unsafe { tsShader_isEvaluate(self.this) != 0 } }
	fn is_geometry(&self) -> bool { unsafe { tsShader_isGeometry(self.this) != 0 } }
	fn is_fragment(&self) -> bool { unsafe { tsShader_isFragment(self.this) != 0 } }
	fn is_compute(&self) -> bool { unsafe { tsShader_isCompute(self.this) != 0 } }
	fn is_task(&self) -> bool { unsafe { tsShader_isTask(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsShader_isMesh(self.this) != 0 } }
	fn is_ray_gen(&self) -> bool { unsafe { tsShader_isRayGen(self.this) != 0 } }
	fn is_ray_miss(&self) -> bool { unsafe { tsShader_isRayMiss(self.this) != 0 } }
	fn is_closest(&self) -> bool { unsafe { tsShader_isClosest(self.this) != 0 } }
	fn is_first_hit(&self) -> bool { unsafe { tsShader_isFirstHit(self.this) != 0 } }
	fn is_intersection(&self) -> bool { unsafe { tsShader_isIntersection(self.this) != 0 } }
	fn is_callable(&self) -> bool { unsafe { tsShader_isCallable(self.this) != 0 } }
	fn is_graphics_type(&self) -> bool { unsafe { tsShader_isGraphicsType(self.this) != 0 } }
	fn is_tessellation_type(&self) -> bool { unsafe { tsShader_isTessellationType(self.this) != 0 } }
	fn is_tracing_type(&self) -> bool { unsafe { tsShader_isTracingType(self.this) != 0 } }
	fn is_mesh_type(&self) -> bool { unsafe { tsShader_isMeshType(self.this) != 0 } }
	fn name(&self) -> string::String { unsafe { get_string(tsShader_getName(self.this)) } }
	fn macros(&self) -> string::String { unsafe { get_string(tsShader_getMacros(self.this)) } }
	fn set_sampler_offset(&mut self, offset: i32) { unsafe { tsShader_setSamplerOffset(self.this, offset) } }
	fn sampler_offset(&self) -> i32 { unsafe { tsShader_getSamplerOffset(self.this) } }
	fn set_texture_offset(&mut self, offset: i32) { unsafe { tsShader_setTextureOffset(self.this, offset) } }
	fn texture_offset(&self) -> i32 { unsafe { tsShader_getTextureOffset(self.this) } }
	fn set_surface_offset(&mut self, offset: i32) { unsafe { tsShader_setSurfaceOffset(self.this, offset) } }
	fn surface_offset(&self) -> i32 { unsafe { tsShader_getSurfaceOffset(self.this) } }
	fn set_uniform_offset(&mut self, offset: i32) { unsafe { tsShader_setUniformOffset(self.this, offset) } }
	fn uniform_offset(&self) -> i32 { unsafe { tsShader_getUniformOffset(self.this) } }
	fn set_storage_offset(&mut self, offset: i32) { unsafe { tsShader_setStorageOffset(self.this, offset) } }
	fn storage_offset(&self) -> i32 { unsafe { tsShader_getStorageOffset(self.this) } }
	fn set_tracing_offset(&mut self, offset: i32) { unsafe { tsShader_setTracingOffset(self.this, offset) } }
	fn tracing_offset(&self) -> i32 { unsafe { tsShader_getTracingOffset(self.this) } }
	fn set_texel_offset(&mut self, offset: i32) { unsafe { tsShader_setTexelOffset(self.this, offset) } }
	fn texel_offset(&self) -> i32 { unsafe { tsShader_getTexelOffset(self.this) } }
	fn set_table_offset(&mut self, offset: i32) { unsafe { tsShader_setTableOffset(self.this, offset) } }
	fn table_offset(&self) -> i32 { unsafe { tsShader_getTableOffset(self.this) } }
	fn set_patch_size(&mut self, size: u32) { unsafe { tsShader_setPatchSize(self.this, size) } }
	fn patch_size(&self) -> u32 { unsafe { tsShader_getPatchSize(self.this) } }
	fn set_input_size(&mut self, size: u32) { unsafe { tsShader_setInputSize(self.this, size) } }
	fn input_size(&self) -> u32 { unsafe { tsShader_getInputSize(self.this) } }
	fn set_output_size(&mut self, size: u32) { unsafe { tsShader_setOutputSize(self.this, size) } }
	fn output_size(&self) -> u32 { unsafe { tsShader_getOutputSize(self.this) } }
	fn load(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_load_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_create_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_load_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_create_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_loadGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsShader_createGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_loadGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsShader_createGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_loadSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsShader_createSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn has_cache() -> bool { unsafe { tsShader_hasCache() != 0 } }
	fn set_cache(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setCache(name_.as_ptr()) != 0 }
	}
	fn load_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_loadCache(hash.this, stream.this) != 0 } }
	fn save_cache(hash: &String, stream: &mut Stream) -> bool { unsafe { tsShader_saveCache(hash.this, stream.this) != 0 } }
	fn clear_cache() { unsafe { tsShader_clearCache() } }
	fn is_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isMacro(name_.as_ptr()) != 0 }
	}
	fn set_macro(name: &str, value: i32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_si(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_valueu32(name: &str, value: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setMacro_su(name_.as_ptr(), value) != 0 }
	}
	fn set_macro_with_value(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsShader_setMacro_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	fn set_macros(macros: &str) -> bool {
		let macros_ = CString::new(macros).unwrap();
		unsafe { tsShader_setMacros(macros_.as_ptr()) != 0 }
	}
	fn remove_macro(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeMacro(name_.as_ptr()) != 0 }
	}
	fn clear_macros() { unsafe { tsShader_clearMacros() } }
	fn is_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_isInclude(name_.as_ptr()) != 0 }
	}
	fn set_include(name: &str, src: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_setInclude(name_.as_ptr(), src.this) != 0 }
	}
	fn remove_include(name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsShader_removeInclude(name_.as_ptr()) != 0 }
	}
	fn clear_includes() { unsafe { tsShader_clearIncludes() } }
	fn preprocessor(src: &str, format: &str) -> string::String {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { get_string(tsShader_preprocessor_ss(src_.as_ptr(), format_.as_ptr())) }
	}
	fn preprocessor_with_macros(src: &str, macros: &String) -> string::String {
		let src_ = CString::new(src).unwrap();
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, ptr::null_mut(), 0)) }
	}
	fn preprocessor_with_macros_includes(src: &str, macros: &String, includes: &[&str]) -> string::String {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { get_string(tsShader_preprocessor_scSspu(src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32)) }
	}
}
impl Drop for FUShader {
	fn drop(&mut self) { if self.owner { unsafe { tsFUShader_delete(self.this) } } }
}
impl Clone for FUShader {
	fn clone(&self) -> FUShader { unsafe { FUShader { this: tsFUShader_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUShader { }
impl fmt::Display for FUShader {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUShader ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUShader_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUShader_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUShader_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUShader_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUShader_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUShader_new() -> *mut c_void;
	fn tsFUShader_new_cASb(shaders: *const *mut c_void, shaders_size: u32, owner: i32) -> *mut c_void;
	fn tsFUShader_delete(this: *mut c_void);
	fn tsFUShader_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUShader_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUShader_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUShader_clearPtr(this: *const c_void);
	fn tsFUShader_destroyPtr(this: *const c_void);
	fn tsFUShader_acquirePtr(this: *const c_void);
	fn tsFUShader_unacquirePtr(this: *const c_void);
	fn tsFUShader_isValidPtr(this: *const c_void) -> i32;
	fn tsFUShader_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUShader_isConstPtr(this: *const c_void) -> i32;
	fn tsFUShader_getCountPtr(this: *const c_void) -> u32;
	fn tsFUShader_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUShader_equalShaderPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUShader_castShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsFUShader_baseShaderPtr(this: *const c_void) -> *mut c_void;
	fn tsFUShader_setMask(this: *mut c_void, mask: u32);
	fn tsFUShader_getMask(this: *const c_void) -> u32;
	fn tsFUShader_getNumShaders(this: *const c_void) -> u32;
	fn tsFUShader_getShader_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUShader_getShader_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Sampler
pub struct Sampler {
	this: *mut c_void,
	owner: bool,
}
impl Sampler {
	pub fn null() -> Sampler { Sampler { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Sampler { unsafe { Sampler { this: tsSampler_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Sampler { unsafe { Sampler { this: ptr, owner: tsSampler_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Sampler { unsafe { Sampler { this: tsSampler_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Sampler) -> bool { unsafe { tsSampler_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Sampler { unsafe { Sampler { this: tsSampler_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSampler_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSampler_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSampler_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSampler_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSampler_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSampler_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSampler_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSampler_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSampler_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait SamplerTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn create(&mut self) -> bool;
	fn set_parameters(&mut self, sampler: &Sampler);
	fn set_filter(&mut self, filter: SamplerFilter);
	fn filter(&self) -> SamplerFilter;
	fn is_point_filter(&self) -> bool;
	fn set_anisotropy(&mut self, anisotropy: u32);
	fn anisotropy(&self) -> u32;
	fn has_anisotropy(&self) -> bool;
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode);
	fn set_wrap_mode_with_modes(&mut self, mode_s: SamplerWrapMode, mode_t: SamplerWrapMode, mode_r: SamplerWrapMode);
	fn set_wrap_mode_s(&mut self, mode: SamplerWrapMode);
	fn wrap_mode_s(&self) -> SamplerWrapMode;
	fn set_wrap_mode_t(&mut self, mode: SamplerWrapMode);
	fn wrap_mode_t(&self) -> SamplerWrapMode;
	fn set_wrap_mode_r(&mut self, mode: SamplerWrapMode);
	fn wrap_mode_r(&self) -> SamplerWrapMode;
	fn set_lod(&mut self, min: f32, max: f32, bias: f32);
	fn set_lod_min(&mut self, min: f32);
	fn lod_min(&self) -> f32;
	fn set_lod_max(&mut self, max: f32);
	fn lod_max(&self) -> f32;
	fn set_lod_bias(&mut self, bias: f32);
	fn lod_bias(&self) -> f32;
	fn set_border_color(&mut self, color: &Color);
	fn set_border_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32);
	fn border_color(&self) -> Color;
	fn set_compare_func(&mut self, func: SamplerCompareFunc);
	fn compare_func(&self) -> SamplerCompareFunc;
	fn set_reduction_mode(&mut self, mode: SamplerReductionMode);
	fn reduction_mode(&self) -> SamplerReductionMode;
}
impl SamplerTrait for Sampler {
	fn platform(&self) -> Platform { unsafe { tsSampler_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSampler_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSampler_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsSampler_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsSampler_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsSampler_create(self.this) != 0 } }
	fn set_parameters(&mut self, sampler: &Sampler) { unsafe { tsSampler_setParameters(self.this, sampler.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsSampler_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsSampler_getFilter(self.this) } }
	fn is_point_filter(&self) -> bool { unsafe { tsSampler_isPointFilter(self.this) != 0 } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsSampler_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsSampler_getAnisotropy(self.this) } }
	fn has_anisotropy(&self) -> bool { unsafe { tsSampler_hasAnisotropy(self.this) != 0 } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapMode_SWM(self.this, mode) } }
	fn set_wrap_mode_with_modes(&mut self, mode_s: SamplerWrapMode, mode_t: SamplerWrapMode, mode_r: SamplerWrapMode) { unsafe { tsSampler_setWrapMode_SWMSWMSWM(self.this, mode_s, mode_t, mode_r) } }
	fn set_wrap_mode_s(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeS(self.this, mode) } }
	fn wrap_mode_s(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeS(self.this) } }
	fn set_wrap_mode_t(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeT(self.this, mode) } }
	fn wrap_mode_t(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeT(self.this) } }
	fn set_wrap_mode_r(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeR(self.this, mode) } }
	fn wrap_mode_r(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeR(self.this) } }
	fn set_lod(&mut self, min: f32, max: f32, bias: f32) { unsafe { tsSampler_setLod(self.this, min, max, bias) } }
	fn set_lod_min(&mut self, min: f32) { unsafe { tsSampler_setLodMin(self.this, min) } }
	fn lod_min(&self) -> f32 { unsafe { tsSampler_getLodMin(self.this) } }
	fn set_lod_max(&mut self, max: f32) { unsafe { tsSampler_setLodMax(self.this, max) } }
	fn lod_max(&self) -> f32 { unsafe { tsSampler_getLodMax(self.this) } }
	fn set_lod_bias(&mut self, bias: f32) { unsafe { tsSampler_setLodBias(self.this, bias) } }
	fn lod_bias(&self) -> f32 { unsafe { tsSampler_getLodBias(self.this) } }
	fn set_border_color(&mut self, color: &Color) { unsafe { tsSampler_setBorderColor_cC(self.this, color) } }
	fn set_border_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsSampler_setBorderColor_ffff(self.this, r, g, b, a) } }
	fn border_color(&self) -> Color { unsafe { tsSampler_getBorderColor(self.this) } }
	fn set_compare_func(&mut self, func: SamplerCompareFunc) { unsafe { tsSampler_setCompareFunc(self.this, func) } }
	fn compare_func(&self) -> SamplerCompareFunc { unsafe { tsSampler_getCompareFunc(self.this) } }
	fn set_reduction_mode(&mut self, mode: SamplerReductionMode) { unsafe { tsSampler_setReductionMode(self.this, mode) } }
	fn reduction_mode(&self) -> SamplerReductionMode { unsafe { tsSampler_getReductionMode(self.this) } }
}
impl Drop for Sampler {
	fn drop(&mut self) { if self.owner { unsafe { tsSampler_delete(self.this) } } }
}
impl Clone for Sampler {
	fn clone(&self) -> Sampler { unsafe { Sampler { this: tsSampler_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Sampler { }
impl fmt::Display for Sampler {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Sampler ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSampler_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSampler_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSampler_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSampler_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSampler_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSampler_new() -> *mut c_void;
	fn tsSampler_delete(this: *mut c_void);
	fn tsSampler_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSampler_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSampler_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSampler_clearPtr(this: *const c_void);
	fn tsSampler_destroyPtr(this: *const c_void);
	fn tsSampler_acquirePtr(this: *const c_void);
	fn tsSampler_unacquirePtr(this: *const c_void);
	fn tsSampler_isValidPtr(this: *const c_void) -> i32;
	fn tsSampler_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSampler_isConstPtr(this: *const c_void) -> i32;
	fn tsSampler_getCountPtr(this: *const c_void) -> u32;
	fn tsSampler_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSampler_getPlatform(this: *const c_void) -> Platform;
	fn tsSampler_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsSampler_getIndex(this: *const c_void) -> u32;
	fn tsSampler_clear(this: *mut c_void);
	fn tsSampler_isCreated(this: *const c_void) -> i32;
	fn tsSampler_create(this: *mut c_void) -> i32;
	fn tsSampler_setParameters(this: *mut c_void, sampler: *mut c_void);
	fn tsSampler_setFilter(this: *mut c_void, filter: SamplerFilter);
	fn tsSampler_getFilter(this: *const c_void) -> SamplerFilter;
	fn tsSampler_isPointFilter(this: *const c_void) -> i32;
	fn tsSampler_setAnisotropy(this: *mut c_void, anisotropy: u32);
	fn tsSampler_getAnisotropy(this: *const c_void) -> u32;
	fn tsSampler_hasAnisotropy(this: *const c_void) -> i32;
	fn tsSampler_setWrapMode_SWM(this: *mut c_void, mode: SamplerWrapMode);
	fn tsSampler_setWrapMode_SWMSWMSWM(this: *mut c_void, mode_s: SamplerWrapMode, mode_t: SamplerWrapMode, mode_r: SamplerWrapMode);
	fn tsSampler_setWrapModeS(this: *mut c_void, mode: SamplerWrapMode);
	fn tsSampler_getWrapModeS(this: *const c_void) -> SamplerWrapMode;
	fn tsSampler_setWrapModeT(this: *mut c_void, mode: SamplerWrapMode);
	fn tsSampler_getWrapModeT(this: *const c_void) -> SamplerWrapMode;
	fn tsSampler_setWrapModeR(this: *mut c_void, mode: SamplerWrapMode);
	fn tsSampler_getWrapModeR(this: *const c_void) -> SamplerWrapMode;
	fn tsSampler_setLod(this: *mut c_void, min: f32, max: f32, bias: f32);
	fn tsSampler_setLodMin(this: *mut c_void, min: f32);
	fn tsSampler_getLodMin(this: *const c_void) -> f32;
	fn tsSampler_setLodMax(this: *mut c_void, max: f32);
	fn tsSampler_getLodMax(this: *const c_void) -> f32;
	fn tsSampler_setLodBias(this: *mut c_void, bias: f32);
	fn tsSampler_getLodBias(this: *const c_void) -> f32;
	fn tsSampler_setBorderColor_cC(this: *mut c_void, color: *const Color);
	fn tsSampler_setBorderColor_ffff(this: *mut c_void, r: f32, g: f32, b: f32, a: f32);
	fn tsSampler_getBorderColor(this: *const c_void) -> Color;
	fn tsSampler_setCompareFunc(this: *mut c_void, func: SamplerCompareFunc);
	fn tsSampler_getCompareFunc(this: *const c_void) -> SamplerCompareFunc;
	fn tsSampler_setReductionMode(this: *mut c_void, mode: SamplerReductionMode);
	fn tsSampler_getReductionMode(this: *const c_void) -> SamplerReductionMode;
}

// Tellusim::MTLSampler
pub struct MTLSampler {
	this: *mut c_void,
	owner: bool,
}
impl MTLSampler {
	pub fn null() -> MTLSampler { MTLSampler { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLSampler { unsafe { MTLSampler { this: tsMTLSampler_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLSampler { unsafe { MTLSampler { this: ptr, owner: tsMTLSampler_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLSampler { unsafe { MTLSampler { this: tsMTLSampler_copyPtr(self.this), owner: true } } }
	pub fn from_sampler(ptr: &Sampler) -> MTLSampler { unsafe { MTLSampler::new_ptr(tsMTLSampler_castSamplerPtr(ptr.this)) } }
	pub fn to_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsMTLSampler_baseSamplerPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLSampler) -> bool { unsafe { tsMTLSampler_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLSampler { unsafe { MTLSampler { this: tsMTLSampler_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLSampler_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLSampler_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLSampler_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLSampler_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLSampler_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLSampler_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLSampler_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLSampler_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLSampler_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_indirect(&mut self, enabled: bool) { unsafe { tsMTLSampler_setIndirect(self.this, if enabled {1} else {0}) } }
	pub fn is_indirect(&self) -> bool { unsafe { tsMTLSampler_isIndirect(self.this) != 0 } }
}
impl SamplerTrait for MTLSampler {
	fn platform(&self) -> Platform { unsafe { tsSampler_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSampler_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSampler_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsSampler_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsSampler_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsSampler_create(self.this) != 0 } }
	fn set_parameters(&mut self, sampler: &Sampler) { unsafe { tsSampler_setParameters(self.this, sampler.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsSampler_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsSampler_getFilter(self.this) } }
	fn is_point_filter(&self) -> bool { unsafe { tsSampler_isPointFilter(self.this) != 0 } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsSampler_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsSampler_getAnisotropy(self.this) } }
	fn has_anisotropy(&self) -> bool { unsafe { tsSampler_hasAnisotropy(self.this) != 0 } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapMode_SWM(self.this, mode) } }
	fn set_wrap_mode_with_modes(&mut self, mode_s: SamplerWrapMode, mode_t: SamplerWrapMode, mode_r: SamplerWrapMode) { unsafe { tsSampler_setWrapMode_SWMSWMSWM(self.this, mode_s, mode_t, mode_r) } }
	fn set_wrap_mode_s(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeS(self.this, mode) } }
	fn wrap_mode_s(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeS(self.this) } }
	fn set_wrap_mode_t(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeT(self.this, mode) } }
	fn wrap_mode_t(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeT(self.this) } }
	fn set_wrap_mode_r(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeR(self.this, mode) } }
	fn wrap_mode_r(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeR(self.this) } }
	fn set_lod(&mut self, min: f32, max: f32, bias: f32) { unsafe { tsSampler_setLod(self.this, min, max, bias) } }
	fn set_lod_min(&mut self, min: f32) { unsafe { tsSampler_setLodMin(self.this, min) } }
	fn lod_min(&self) -> f32 { unsafe { tsSampler_getLodMin(self.this) } }
	fn set_lod_max(&mut self, max: f32) { unsafe { tsSampler_setLodMax(self.this, max) } }
	fn lod_max(&self) -> f32 { unsafe { tsSampler_getLodMax(self.this) } }
	fn set_lod_bias(&mut self, bias: f32) { unsafe { tsSampler_setLodBias(self.this, bias) } }
	fn lod_bias(&self) -> f32 { unsafe { tsSampler_getLodBias(self.this) } }
	fn set_border_color(&mut self, color: &Color) { unsafe { tsSampler_setBorderColor_cC(self.this, color) } }
	fn set_border_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsSampler_setBorderColor_ffff(self.this, r, g, b, a) } }
	fn border_color(&self) -> Color { unsafe { tsSampler_getBorderColor(self.this) } }
	fn set_compare_func(&mut self, func: SamplerCompareFunc) { unsafe { tsSampler_setCompareFunc(self.this, func) } }
	fn compare_func(&self) -> SamplerCompareFunc { unsafe { tsSampler_getCompareFunc(self.this) } }
	fn set_reduction_mode(&mut self, mode: SamplerReductionMode) { unsafe { tsSampler_setReductionMode(self.this, mode) } }
	fn reduction_mode(&self) -> SamplerReductionMode { unsafe { tsSampler_getReductionMode(self.this) } }
}
impl Drop for MTLSampler {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLSampler_delete(self.this) } } }
}
impl Clone for MTLSampler {
	fn clone(&self) -> MTLSampler { unsafe { MTLSampler { this: tsMTLSampler_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLSampler { }
impl fmt::Display for MTLSampler {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLSampler ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLSampler_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLSampler_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLSampler_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLSampler_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLSampler_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLSampler_new() -> *mut c_void;
	fn tsMTLSampler_delete(this: *mut c_void);
	fn tsMTLSampler_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLSampler_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSampler_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSampler_clearPtr(this: *const c_void);
	fn tsMTLSampler_destroyPtr(this: *const c_void);
	fn tsMTLSampler_acquirePtr(this: *const c_void);
	fn tsMTLSampler_unacquirePtr(this: *const c_void);
	fn tsMTLSampler_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLSampler_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLSampler_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLSampler_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLSampler_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSampler_equalSamplerPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLSampler_castSamplerPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSampler_baseSamplerPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSampler_setIndirect(this: *mut c_void, enabled: i32);
	fn tsMTLSampler_isIndirect(this: *const c_void) -> i32;
}

// Tellusim::FUSampler
pub struct FUSampler {
	this: *mut c_void,
	owner: bool,
}
impl FUSampler {
	pub fn null() -> FUSampler { FUSampler { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUSampler { unsafe { FUSampler { this: tsFUSampler_new(), owner: true } } }
	pub fn new_with_samplers(samplers: &[&mut Sampler]) -> FUSampler {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { FUSampler { this: tsFUSampler_new_cASb(samplers_.as_ptr(), samplers.len() as u32, 0), owner: true } }
	}
	pub fn new_with_samplers_owner(samplers: &[&mut Sampler], owner: bool) -> FUSampler {
		let mut samplers_ = Vec::new();
		for ptr in samplers { samplers_.push(ptr.this); }
		unsafe { FUSampler { this: tsFUSampler_new_cASb(samplers_.as_ptr(), samplers.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUSampler { unsafe { FUSampler { this: ptr, owner: tsFUSampler_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUSampler { unsafe { FUSampler { this: tsFUSampler_copyPtr(self.this), owner: true } } }
	pub fn from_sampler(ptr: &Sampler) -> FUSampler { unsafe { FUSampler::new_ptr(tsFUSampler_castSamplerPtr(ptr.this)) } }
	pub fn to_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsFUSampler_baseSamplerPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUSampler) -> bool { unsafe { tsFUSampler_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUSampler { unsafe { FUSampler { this: tsFUSampler_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUSampler_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUSampler_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUSampler_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUSampler_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUSampler_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUSampler_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUSampler_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUSampler_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUSampler_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUSampler_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUSampler_getMask(self.this) } }
	pub fn num_samplers(&self) -> u32 { unsafe { tsFUSampler_getNumSamplers(self.this) } }
	pub fn sampler(&self, index: u32) -> Sampler { unsafe { Sampler::new_ptr(tsFUSampler_getSampler_cu(self.this, index)) } }
	pub fn sampler_mut(&mut self, index: u32) -> Sampler { unsafe { Sampler::new_ptr(tsFUSampler_getSampler_u(self.this, index)) } }
}
impl SamplerTrait for FUSampler {
	fn platform(&self) -> Platform { unsafe { tsSampler_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSampler_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSampler_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsSampler_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsSampler_isCreated(self.this) != 0 } }
	fn create(&mut self) -> bool { unsafe { tsSampler_create(self.this) != 0 } }
	fn set_parameters(&mut self, sampler: &Sampler) { unsafe { tsSampler_setParameters(self.this, sampler.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsSampler_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsSampler_getFilter(self.this) } }
	fn is_point_filter(&self) -> bool { unsafe { tsSampler_isPointFilter(self.this) != 0 } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsSampler_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsSampler_getAnisotropy(self.this) } }
	fn has_anisotropy(&self) -> bool { unsafe { tsSampler_hasAnisotropy(self.this) != 0 } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapMode_SWM(self.this, mode) } }
	fn set_wrap_mode_with_modes(&mut self, mode_s: SamplerWrapMode, mode_t: SamplerWrapMode, mode_r: SamplerWrapMode) { unsafe { tsSampler_setWrapMode_SWMSWMSWM(self.this, mode_s, mode_t, mode_r) } }
	fn set_wrap_mode_s(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeS(self.this, mode) } }
	fn wrap_mode_s(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeS(self.this) } }
	fn set_wrap_mode_t(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeT(self.this, mode) } }
	fn wrap_mode_t(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeT(self.this) } }
	fn set_wrap_mode_r(&mut self, mode: SamplerWrapMode) { unsafe { tsSampler_setWrapModeR(self.this, mode) } }
	fn wrap_mode_r(&self) -> SamplerWrapMode { unsafe { tsSampler_getWrapModeR(self.this) } }
	fn set_lod(&mut self, min: f32, max: f32, bias: f32) { unsafe { tsSampler_setLod(self.this, min, max, bias) } }
	fn set_lod_min(&mut self, min: f32) { unsafe { tsSampler_setLodMin(self.this, min) } }
	fn lod_min(&self) -> f32 { unsafe { tsSampler_getLodMin(self.this) } }
	fn set_lod_max(&mut self, max: f32) { unsafe { tsSampler_setLodMax(self.this, max) } }
	fn lod_max(&self) -> f32 { unsafe { tsSampler_getLodMax(self.this) } }
	fn set_lod_bias(&mut self, bias: f32) { unsafe { tsSampler_setLodBias(self.this, bias) } }
	fn lod_bias(&self) -> f32 { unsafe { tsSampler_getLodBias(self.this) } }
	fn set_border_color(&mut self, color: &Color) { unsafe { tsSampler_setBorderColor_cC(self.this, color) } }
	fn set_border_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsSampler_setBorderColor_ffff(self.this, r, g, b, a) } }
	fn border_color(&self) -> Color { unsafe { tsSampler_getBorderColor(self.this) } }
	fn set_compare_func(&mut self, func: SamplerCompareFunc) { unsafe { tsSampler_setCompareFunc(self.this, func) } }
	fn compare_func(&self) -> SamplerCompareFunc { unsafe { tsSampler_getCompareFunc(self.this) } }
	fn set_reduction_mode(&mut self, mode: SamplerReductionMode) { unsafe { tsSampler_setReductionMode(self.this, mode) } }
	fn reduction_mode(&self) -> SamplerReductionMode { unsafe { tsSampler_getReductionMode(self.this) } }
}
impl Drop for FUSampler {
	fn drop(&mut self) { if self.owner { unsafe { tsFUSampler_delete(self.this) } } }
}
impl Clone for FUSampler {
	fn clone(&self) -> FUSampler { unsafe { FUSampler { this: tsFUSampler_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUSampler { }
impl fmt::Display for FUSampler {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUSampler ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUSampler_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUSampler_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUSampler_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUSampler_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUSampler_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUSampler_new() -> *mut c_void;
	fn tsFUSampler_new_cASb(samplers: *const *mut c_void, samplers_size: u32, owner: i32) -> *mut c_void;
	fn tsFUSampler_delete(this: *mut c_void);
	fn tsFUSampler_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUSampler_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUSampler_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUSampler_clearPtr(this: *const c_void);
	fn tsFUSampler_destroyPtr(this: *const c_void);
	fn tsFUSampler_acquirePtr(this: *const c_void);
	fn tsFUSampler_unacquirePtr(this: *const c_void);
	fn tsFUSampler_isValidPtr(this: *const c_void) -> i32;
	fn tsFUSampler_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUSampler_isConstPtr(this: *const c_void) -> i32;
	fn tsFUSampler_getCountPtr(this: *const c_void) -> u32;
	fn tsFUSampler_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUSampler_equalSamplerPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUSampler_castSamplerPtr(this: *const c_void) -> *mut c_void;
	fn tsFUSampler_baseSamplerPtr(this: *const c_void) -> *mut c_void;
	fn tsFUSampler_setMask(this: *mut c_void, mask: u32);
	fn tsFUSampler_getMask(this: *const c_void) -> u32;
	fn tsFUSampler_getNumSamplers(this: *const c_void) -> u32;
	fn tsFUSampler_getSampler_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUSampler_getSampler_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Texture
pub struct Texture {
	this: *mut c_void,
	owner: bool,
}
impl Texture {
	pub fn null() -> Texture { Texture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Texture { unsafe { Texture { this: tsTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Texture { unsafe { Texture { this: ptr, owner: tsTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Texture { unsafe { Texture { this: tsTexture_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Texture) -> bool { unsafe { tsTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Texture { unsafe { Texture { this: tsTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait TextureTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn name(&self) -> string::String;
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool;
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool;
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool;
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool;
	fn create3d(&mut self, format: Format, size: u32) -> bool;
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool;
	fn create_cube(&mut self, format: Format, size: u32) -> bool;
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool;
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool;
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool;
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool;
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool;
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool;
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool;
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool;
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool;
	fn type_(&self) -> TextureType;
	fn type_name_with_type(type_: TextureType) -> string::String;
	fn type_name(&self) -> string::String;
	fn is2d_type(&self) -> bool;
	fn is3d_type(&self) -> bool;
	fn is_cube_type(&self) -> bool;
	fn format(&self) -> Format;
	fn format_name(&self) -> string::String;
	fn is_color_format(&self) -> bool;
	fn is_depth_format(&self) -> bool;
	fn is_pixel_format(&self) -> bool;
	fn is_plain_format(&self) -> bool;
	fn is_mixed_format(&self) -> bool;
	fn is_block_format(&self) -> bool;
	fn is_stencil_format(&self) -> bool;
	fn is_norm_format(&self) -> bool;
	fn is_srgb_format(&self) -> bool;
	fn is_float_format(&self) -> bool;
	fn is_signed_format(&self) -> bool;
	fn is_unsigned_format(&self) -> bool;
	fn is_integer_format(&self) -> bool;
	fn isi8_format(&self) -> bool;
	fn isu8_format(&self) -> bool;
	fn is8_bit_format(&self) -> bool;
	fn isi16_format(&self) -> bool;
	fn isu16_format(&self) -> bool;
	fn isf16_format(&self) -> bool;
	fn is16_bit_format(&self) -> bool;
	fn isi32_format(&self) -> bool;
	fn isu32_format(&self) -> bool;
	fn isf32_format(&self) -> bool;
	fn is32_bit_format(&self) -> bool;
	fn isi64_format(&self) -> bool;
	fn isu64_format(&self) -> bool;
	fn isf64_format(&self) -> bool;
	fn is64_bit_format(&self) -> bool;
	fn is_bc15_format(&self) -> bool;
	fn is_bc67_format(&self) -> bool;
	fn is_etc2_format(&self) -> bool;
	fn is_astc_format(&self) -> bool;
	fn components(&self) -> u32;
	fn pixel_size(&self) -> u32;
	fn block_size(&self) -> u32;
	fn block_width(&self) -> u32;
	fn block_height(&self) -> u32;
	fn flags(&self) -> TextureFlags;
	fn has_flag(&self, flags: TextureFlags) -> bool;
	fn has_flags(&self, flags: TextureFlags) -> bool;
	fn flags_name(&self) -> string::String;
	fn multisample(&self) -> u32;
	fn has_multisample(&self) -> bool;
	fn width(&self) -> u32;
	fn height(&self) -> u32;
	fn depth(&self) -> u32;
	fn faces(&self) -> u32;
	fn layers(&self) -> u32;
	fn mipmaps(&self) -> u32;
	fn find_mipmap(&self, size: &Size) -> u32;
	fn width_with_mipmap(&self, mipmap: u32) -> u32;
	fn height_with_mipmap(&self, mipmap: u32) -> u32;
	fn depth_with_mipmap(&self, mipmap: u32) -> u32;
	fn has_faces(&self) -> bool;
	fn has_layers(&self) -> bool;
	fn has_mipmaps(&self) -> bool;
	fn size(&self) -> Size;
	fn region(&self) -> Region;
	fn slice(&self) -> Slice;
	fn size_with_mipmap(&self, mipmap: u32) -> Size;
	fn region_with_mipmap(&self, mipmap: u32) -> Region;
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice;
	fn tile_width(&self) -> u32;
	fn tile_height(&self) -> u32;
	fn tile_depth(&self) -> u32;
	fn tile_mipmaps(&self) -> u32;
	fn tile_size(&self) -> Size;
	fn description(&self) -> string::String;
	fn memory(&self) -> usize;
}
impl TextureTrait for Texture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for Texture {
	fn drop(&mut self) { if self.owner { unsafe { tsTexture_delete(self.this) } } }
}
impl Clone for Texture {
	fn clone(&self) -> Texture { unsafe { Texture { this: tsTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Texture { }
impl fmt::Display for Texture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Texture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsTexture_new() -> *mut c_void;
	fn tsTexture_delete(this: *mut c_void);
	fn tsTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsTexture_clearPtr(this: *const c_void);
	fn tsTexture_destroyPtr(this: *const c_void);
	fn tsTexture_acquirePtr(this: *const c_void);
	fn tsTexture_unacquirePtr(this: *const c_void);
	fn tsTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsTexture_getPlatform(this: *const c_void) -> Platform;
	fn tsTexture_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsTexture_getIndex(this: *const c_void) -> u32;
	fn tsTexture_clear(this: *mut c_void);
	fn tsTexture_isCreated(this: *const c_void) -> i32;
	fn tsTexture_setName(this: *mut c_void, name: *const c_char);
	fn tsTexture_getName(this: *const c_void) -> *mut c_void;
	fn tsTexture_create(this: *mut c_void, type_: TextureType, format: Format, size: *const Size, layers: u32, flags: TextureFlags) -> i32;
	fn tsTexture_create2D_FuTF(this: *mut c_void, format: Format, size: u32, flags: TextureFlags) -> i32;
	fn tsTexture_create3D_FuTF(this: *mut c_void, format: Format, size: u32, flags: TextureFlags) -> i32;
	fn tsTexture_createCube_FuTF(this: *mut c_void, format: Format, size: u32, flags: TextureFlags) -> i32;
	fn tsTexture_create2D_FuuTF(this: *mut c_void, format: Format, width: u32, height: u32, flags: TextureFlags) -> i32;
	fn tsTexture_create3D_FuuuTF(this: *mut c_void, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> i32;
	fn tsTexture_create2D_FuuuTF(this: *mut c_void, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> i32;
	fn tsTexture_createCube_FuuTF(this: *mut c_void, format: Format, size: u32, layers: u32, flags: TextureFlags) -> i32;
	fn tsTexture_getType(this: *const c_void) -> TextureType;
	fn tsTexture_getTypeName_TT(type_: TextureType) -> *const c_char;
	fn tsTexture_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsTexture_is2DType(this: *const c_void) -> i32;
	fn tsTexture_is3DType(this: *const c_void) -> i32;
	fn tsTexture_isCubeType(this: *const c_void) -> i32;
	fn tsTexture_getFormat(this: *const c_void) -> Format;
	fn tsTexture_getFormatName(this: *const c_void) -> *const c_char;
	fn tsTexture_isColorFormat(this: *const c_void) -> i32;
	fn tsTexture_isDepthFormat(this: *const c_void) -> i32;
	fn tsTexture_isPixelFormat(this: *const c_void) -> i32;
	fn tsTexture_isPlainFormat(this: *const c_void) -> i32;
	fn tsTexture_isMixedFormat(this: *const c_void) -> i32;
	fn tsTexture_isBlockFormat(this: *const c_void) -> i32;
	fn tsTexture_isStencilFormat(this: *const c_void) -> i32;
	fn tsTexture_isNormFormat(this: *const c_void) -> i32;
	fn tsTexture_isSRGBFormat(this: *const c_void) -> i32;
	fn tsTexture_isFloatFormat(this: *const c_void) -> i32;
	fn tsTexture_isSignedFormat(this: *const c_void) -> i32;
	fn tsTexture_isUnsignedFormat(this: *const c_void) -> i32;
	fn tsTexture_isIntegerFormat(this: *const c_void) -> i32;
	fn tsTexture_isi8Format(this: *const c_void) -> i32;
	fn tsTexture_isu8Format(this: *const c_void) -> i32;
	fn tsTexture_is8BitFormat(this: *const c_void) -> i32;
	fn tsTexture_isi16Format(this: *const c_void) -> i32;
	fn tsTexture_isu16Format(this: *const c_void) -> i32;
	fn tsTexture_isf16Format(this: *const c_void) -> i32;
	fn tsTexture_is16BitFormat(this: *const c_void) -> i32;
	fn tsTexture_isi32Format(this: *const c_void) -> i32;
	fn tsTexture_isu32Format(this: *const c_void) -> i32;
	fn tsTexture_isf32Format(this: *const c_void) -> i32;
	fn tsTexture_is32BitFormat(this: *const c_void) -> i32;
	fn tsTexture_isi64Format(this: *const c_void) -> i32;
	fn tsTexture_isu64Format(this: *const c_void) -> i32;
	fn tsTexture_isf64Format(this: *const c_void) -> i32;
	fn tsTexture_is64BitFormat(this: *const c_void) -> i32;
	fn tsTexture_isBC15Format(this: *const c_void) -> i32;
	fn tsTexture_isBC67Format(this: *const c_void) -> i32;
	fn tsTexture_isETC2Format(this: *const c_void) -> i32;
	fn tsTexture_isASTCFormat(this: *const c_void) -> i32;
	fn tsTexture_getComponents(this: *const c_void) -> u32;
	fn tsTexture_getPixelSize(this: *const c_void) -> u32;
	fn tsTexture_getBlockSize(this: *const c_void) -> u32;
	fn tsTexture_getBlockWidth(this: *const c_void) -> u32;
	fn tsTexture_getBlockHeight(this: *const c_void) -> u32;
	fn tsTexture_getFlags(this: *const c_void) -> TextureFlags;
	fn tsTexture_hasFlag(this: *const c_void, flags: TextureFlags) -> i32;
	fn tsTexture_hasFlags(this: *const c_void, flags: TextureFlags) -> i32;
	fn tsTexture_getFlagsName(this: *const c_void) -> *mut c_void;
	fn tsTexture_getMultisample(this: *const c_void) -> u32;
	fn tsTexture_hasMultisample(this: *const c_void) -> i32;
	fn tsTexture_getWidth_c(this: *const c_void) -> u32;
	fn tsTexture_getHeight_c(this: *const c_void) -> u32;
	fn tsTexture_getDepth_c(this: *const c_void) -> u32;
	fn tsTexture_getFaces(this: *const c_void) -> u32;
	fn tsTexture_getLayers(this: *const c_void) -> u32;
	fn tsTexture_getMipmaps(this: *const c_void) -> u32;
	fn tsTexture_findMipmap(this: *const c_void, size: *const Size) -> u32;
	fn tsTexture_getWidth_cu(this: *const c_void, mipmap: u32) -> u32;
	fn tsTexture_getHeight_cu(this: *const c_void, mipmap: u32) -> u32;
	fn tsTexture_getDepth_cu(this: *const c_void, mipmap: u32) -> u32;
	fn tsTexture_hasFaces(this: *const c_void) -> i32;
	fn tsTexture_hasLayers(this: *const c_void) -> i32;
	fn tsTexture_hasMipmaps(this: *const c_void) -> i32;
	fn tsTexture_getSize_c(this: *const c_void) -> Size;
	fn tsTexture_getRegion_c(this: *const c_void) -> Region;
	fn tsTexture_getSlice_c(this: *const c_void) -> Slice;
	fn tsTexture_getSize_cu(this: *const c_void, mipmap: u32) -> Size;
	fn tsTexture_getRegion_cu(this: *const c_void, mipmap: u32) -> Region;
	fn tsTexture_getSlice_cu(this: *const c_void, mipmap: u32) -> Slice;
	fn tsTexture_getTileWidth(this: *const c_void) -> u32;
	fn tsTexture_getTileHeight(this: *const c_void) -> u32;
	fn tsTexture_getTileDepth(this: *const c_void) -> u32;
	fn tsTexture_getTileMipmaps(this: *const c_void) -> u32;
	fn tsTexture_getTileSize(this: *const c_void) -> Size;
	fn tsTexture_getDescription(this: *const c_void) -> *mut c_void;
	fn tsTexture_getMemory(this: *const c_void) -> usize;
}

// Tellusim::TextureTable
pub struct TextureTable {
	this: *mut c_void,
	owner: bool,
}
impl TextureTable {
	pub fn null() -> TextureTable { TextureTable { this: ptr::null_mut(), owner: false } }
	pub fn new() -> TextureTable { unsafe { TextureTable { this: tsTextureTable_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> TextureTable { unsafe { TextureTable { this: ptr, owner: tsTextureTable_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> TextureTable { unsafe { TextureTable { this: tsTextureTable_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: TextureTable) -> bool { unsafe { tsTextureTable_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> TextureTable { unsafe { TextureTable { this: tsTextureTable_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsTextureTable_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsTextureTable_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsTextureTable_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsTextureTable_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsTextureTable_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsTextureTable_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsTextureTable_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsTextureTable_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsTextureTable_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn platform(&self) -> Platform { unsafe { tsTextureTable_getPlatform(self.this) } }
	pub fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTextureTable_getPlatformName(self.this)) } }
	pub fn index(&self) -> u32 { unsafe { tsTextureTable_getIndex(self.this) } }
	pub fn clear(&mut self) { unsafe { tsTextureTable_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsTextureTable_isCreated(self.this) != 0 } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTextureTable_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsTextureTable_getName(self.this)) } }
	pub fn create(&mut self, type_: TextureType, size: u32) -> bool { unsafe { tsTextureTable_create(self.this, type_, size) != 0 } }
	pub fn type_(&self) -> TextureType { unsafe { tsTextureTable_getType(self.this) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsTextureTable_getTypeName(self.this)) } }
	pub fn size(&self) -> u32 { unsafe { tsTextureTable_getSize(self.this) } }
	pub fn get(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTextureTable_get(self.this, index)) } }
	pub fn is_owner(&self, index: u32) -> bool { unsafe { tsTextureTable_isOwner(self.this, index) != 0 } }
	pub fn memory(&self) -> usize { unsafe { tsTextureTable_getMemory(self.this) } }
}
impl Drop for TextureTable {
	fn drop(&mut self) { if self.owner { unsafe { tsTextureTable_delete(self.this) } } }
}
impl Clone for TextureTable {
	fn clone(&self) -> TextureTable { unsafe { TextureTable { this: tsTextureTable_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for TextureTable { }
impl fmt::Display for TextureTable {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::TextureTable ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsTextureTable_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsTextureTable_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsTextureTable_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsTextureTable_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsTextureTable_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsTextureTable_new() -> *mut c_void;
	fn tsTextureTable_delete(this: *mut c_void);
	fn tsTextureTable_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsTextureTable_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsTextureTable_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsTextureTable_clearPtr(this: *const c_void);
	fn tsTextureTable_destroyPtr(this: *const c_void);
	fn tsTextureTable_acquirePtr(this: *const c_void);
	fn tsTextureTable_unacquirePtr(this: *const c_void);
	fn tsTextureTable_isValidPtr(this: *const c_void) -> i32;
	fn tsTextureTable_isOwnerPtr(this: *const c_void) -> i32;
	fn tsTextureTable_isConstPtr(this: *const c_void) -> i32;
	fn tsTextureTable_getCountPtr(this: *const c_void) -> u32;
	fn tsTextureTable_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsTextureTable_getPlatform(this: *const c_void) -> Platform;
	fn tsTextureTable_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsTextureTable_getIndex(this: *const c_void) -> u32;
	fn tsTextureTable_clear(this: *mut c_void);
	fn tsTextureTable_isCreated(this: *const c_void) -> i32;
	fn tsTextureTable_setName(this: *mut c_void, name: *const c_char);
	fn tsTextureTable_getName(this: *const c_void) -> *mut c_void;
	fn tsTextureTable_create(this: *mut c_void, type_: TextureType, size: u32) -> i32;
	fn tsTextureTable_getType(this: *const c_void) -> TextureType;
	fn tsTextureTable_getTypeName(this: *const c_void) -> *const c_char;
	fn tsTextureTable_getSize(this: *const c_void) -> u32;
	fn tsTextureTable_get(this: *const c_void, index: u32) -> *mut c_void;
	fn tsTextureTable_isOwner(this: *const c_void, index: u32) -> i32;
	fn tsTextureTable_getMemory(this: *const c_void) -> usize;
}

// Tellusim::D3D12Texture
pub struct D3D12Texture {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Texture {
	pub fn null() -> D3D12Texture { D3D12Texture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Texture { unsafe { D3D12Texture { this: tsD3D12Texture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Texture { unsafe { D3D12Texture { this: ptr, owner: tsD3D12Texture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Texture { unsafe { D3D12Texture { this: tsD3D12Texture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> D3D12Texture { unsafe { D3D12Texture::new_ptr(tsD3D12Texture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsD3D12Texture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Texture) -> bool { unsafe { tsD3D12Texture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Texture { unsafe { D3D12Texture { this: tsD3D12Texture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Texture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Texture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Texture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Texture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Texture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Texture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Texture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Texture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Texture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, type_: TextureType, texture: *const c_void, state: u32) -> bool { unsafe { tsD3D12Texture_create(self.this, type_, texture, state, TextureFlags::None, Format::Unknown) != 0 } }
	pub fn create_with_flags(&mut self, type_: TextureType, texture: *const c_void, state: u32, flags: TextureFlags) -> bool { unsafe { tsD3D12Texture_create(self.this, type_, texture, state, flags, Format::Unknown) != 0 } }
	pub fn create_with_flags_format(&mut self, type_: TextureType, texture: *const c_void, state: u32, flags: TextureFlags, format: Format) -> bool { unsafe { tsD3D12Texture_create(self.this, type_, texture, state, flags, format) != 0 } }
	pub fn dxgi_format(&self) -> u32 { unsafe { tsD3D12Texture_getDXGIFormat(self.this) } }
	pub fn d3d12_texture(&self) -> *const c_void { unsafe { tsD3D12Texture_getD3D12Texture(self.this) } }
	pub fn shader_resource_view(&self) -> usize { unsafe { tsD3D12Texture_getShaderResourceView(self.this) } }
	pub fn render_target_view(&self) -> usize { unsafe { tsD3D12Texture_getRenderTargetView(self.this) } }
	pub fn depth_stencil_view(&self) -> usize { unsafe { tsD3D12Texture_getDepthStencilView(self.this) } }
	pub fn unordered_access_view(&self) -> usize { unsafe { tsD3D12Texture_getUnorderedAccessView(self.this) } }
	pub fn set_texture_state(&mut self, state: u32) { unsafe { tsD3D12Texture_setTextureState(self.this, state) } }
	pub fn texture_state(&self) -> u32 { unsafe { tsD3D12Texture_getTextureState(self.this) } }
	pub fn shared_handle(&self) -> *mut c_void { unsafe { tsD3D12Texture_getSharedHandle(self.this) } }
	pub fn interop_handle(&self) -> *mut c_void { unsafe { tsD3D12Texture_getInteropHandle(self.this) } }
}
impl TextureTrait for D3D12Texture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for D3D12Texture {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Texture_delete(self.this) } } }
}
impl Clone for D3D12Texture {
	fn clone(&self) -> D3D12Texture { unsafe { D3D12Texture { this: tsD3D12Texture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Texture { }
impl fmt::Display for D3D12Texture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Texture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Texture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Texture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Texture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Texture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Texture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Texture_new() -> *mut c_void;
	fn tsD3D12Texture_delete(this: *mut c_void);
	fn tsD3D12Texture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Texture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Texture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Texture_clearPtr(this: *const c_void);
	fn tsD3D12Texture_destroyPtr(this: *const c_void);
	fn tsD3D12Texture_acquirePtr(this: *const c_void);
	fn tsD3D12Texture_unacquirePtr(this: *const c_void);
	fn tsD3D12Texture_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Texture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Texture_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Texture_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Texture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Texture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Texture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Texture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Texture_create(this: *mut c_void, type_: TextureType, texture: *const c_void, state: u32, flags: TextureFlags, format: Format) -> i32;
	fn tsD3D12Texture_getDXGIFormat(this: *const c_void) -> u32;
	fn tsD3D12Texture_getD3D12Texture(this: *const c_void) -> *const c_void;
	fn tsD3D12Texture_getShaderResourceView(this: *const c_void) -> usize;
	fn tsD3D12Texture_getRenderTargetView(this: *const c_void) -> usize;
	fn tsD3D12Texture_getDepthStencilView(this: *const c_void) -> usize;
	fn tsD3D12Texture_getUnorderedAccessView(this: *const c_void) -> usize;
	fn tsD3D12Texture_setTextureState(this: *mut c_void, state: u32);
	fn tsD3D12Texture_getTextureState(this: *const c_void) -> u32;
	fn tsD3D12Texture_getSharedHandle(this: *const c_void) -> *mut c_void;
	fn tsD3D12Texture_getInteropHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::D3D11Texture
pub struct D3D11Texture {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Texture {
	pub fn null() -> D3D11Texture { D3D11Texture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Texture { unsafe { D3D11Texture { this: tsD3D11Texture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Texture { unsafe { D3D11Texture { this: ptr, owner: tsD3D11Texture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Texture { unsafe { D3D11Texture { this: tsD3D11Texture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> D3D11Texture { unsafe { D3D11Texture::new_ptr(tsD3D11Texture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsD3D11Texture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Texture) -> bool { unsafe { tsD3D11Texture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Texture { unsafe { D3D11Texture { this: tsD3D11Texture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Texture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Texture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Texture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Texture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Texture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Texture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Texture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Texture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Texture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, type_: TextureType, texture: *const c_void) -> bool { unsafe { tsD3D11Texture_create(self.this, type_, texture, TextureFlags::None, Format::Unknown) != 0 } }
	pub fn create_with_flags(&mut self, type_: TextureType, texture: *const c_void, flags: TextureFlags) -> bool { unsafe { tsD3D11Texture_create(self.this, type_, texture, flags, Format::Unknown) != 0 } }
	pub fn create_with_flags_format(&mut self, type_: TextureType, texture: *const c_void, flags: TextureFlags, format: Format) -> bool { unsafe { tsD3D11Texture_create(self.this, type_, texture, flags, format) != 0 } }
	pub fn dxgi_format(&self) -> u32 { unsafe { tsD3D11Texture_getDXGIFormat(self.this) } }
	pub fn d3d11_texture(&self) -> *const c_void { unsafe { tsD3D11Texture_getD3D11Texture(self.this) } }
	pub fn shader_resource_view(&self) -> *const c_void { unsafe { tsD3D11Texture_getShaderResourceView(self.this) } }
	pub fn render_target_view(&self) -> *const c_void { unsafe { tsD3D11Texture_getRenderTargetView(self.this) } }
	pub fn depth_stencil_view(&self) -> *const c_void { unsafe { tsD3D11Texture_getDepthStencilView(self.this) } }
	pub fn unordered_access_view(&self) -> *const c_void { unsafe { tsD3D11Texture_getUnorderedAccessView(self.this) } }
	pub fn interop_handle(&self) -> *mut c_void { unsafe { tsD3D11Texture_getInteropHandle(self.this) } }
}
impl TextureTrait for D3D11Texture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for D3D11Texture {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Texture_delete(self.this) } } }
}
impl Clone for D3D11Texture {
	fn clone(&self) -> D3D11Texture { unsafe { D3D11Texture { this: tsD3D11Texture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Texture { }
impl fmt::Display for D3D11Texture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Texture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Texture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Texture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Texture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Texture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Texture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Texture_new() -> *mut c_void;
	fn tsD3D11Texture_delete(this: *mut c_void);
	fn tsD3D11Texture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Texture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Texture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Texture_clearPtr(this: *const c_void);
	fn tsD3D11Texture_destroyPtr(this: *const c_void);
	fn tsD3D11Texture_acquirePtr(this: *const c_void);
	fn tsD3D11Texture_unacquirePtr(this: *const c_void);
	fn tsD3D11Texture_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Texture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Texture_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Texture_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Texture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Texture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Texture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Texture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Texture_create(this: *mut c_void, type_: TextureType, texture: *const c_void, flags: TextureFlags, format: Format) -> i32;
	fn tsD3D11Texture_getDXGIFormat(this: *const c_void) -> u32;
	fn tsD3D11Texture_getD3D11Texture(this: *const c_void) -> *const c_void;
	fn tsD3D11Texture_getShaderResourceView(this: *const c_void) -> *const c_void;
	fn tsD3D11Texture_getRenderTargetView(this: *const c_void) -> *const c_void;
	fn tsD3D11Texture_getDepthStencilView(this: *const c_void) -> *const c_void;
	fn tsD3D11Texture_getUnorderedAccessView(this: *const c_void) -> *const c_void;
	fn tsD3D11Texture_getInteropHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::MTLTexture
pub struct MTLTexture {
	this: *mut c_void,
	owner: bool,
}
impl MTLTexture {
	pub fn null() -> MTLTexture { MTLTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLTexture { unsafe { MTLTexture { this: tsMTLTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLTexture { unsafe { MTLTexture { this: ptr, owner: tsMTLTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLTexture { unsafe { MTLTexture { this: tsMTLTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> MTLTexture { unsafe { MTLTexture::new_ptr(tsMTLTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsMTLTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLTexture) -> bool { unsafe { tsMTLTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLTexture { unsafe { MTLTexture { this: tsMTLTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, texture: *mut c_void) -> bool { unsafe { tsMTLTexture_create(self.this, texture, TextureFlags::None, Format::Unknown) != 0 } }
	pub fn create_with_flags(&mut self, texture: *mut c_void, flags: TextureFlags) -> bool { unsafe { tsMTLTexture_create(self.this, texture, flags, Format::Unknown) != 0 } }
	pub fn create_with_flags_format(&mut self, texture: *mut c_void, flags: TextureFlags, format: Format) -> bool { unsafe { tsMTLTexture_create(self.this, texture, flags, format) != 0 } }
	pub fn pixel_format(&self) -> u32 { unsafe { tsMTLTexture_getPixelFormat(self.this) } }
	pub fn texture_type(&self) -> u32 { unsafe { tsMTLTexture_getTextureType(self.this) } }
	pub fn mtl_texture(&self) -> *mut c_void { unsafe { tsMTLTexture_getMTLTexture(self.this) } }
	pub fn mtl_buffer(&self) -> *mut c_void { unsafe { tsMTLTexture_getMTLBuffer(self.this) } }
	pub fn shared_ptr(&self) -> *mut c_void { unsafe { tsMTLTexture_getSharedPtr(self.this) } }
}
impl TextureTrait for MTLTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for MTLTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLTexture_delete(self.this) } } }
}
impl Clone for MTLTexture {
	fn clone(&self) -> MTLTexture { unsafe { MTLTexture { this: tsMTLTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLTexture { }
impl fmt::Display for MTLTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLTexture_new() -> *mut c_void;
	fn tsMTLTexture_delete(this: *mut c_void);
	fn tsMTLTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_clearPtr(this: *const c_void);
	fn tsMTLTexture_destroyPtr(this: *const c_void);
	fn tsMTLTexture_acquirePtr(this: *const c_void);
	fn tsMTLTexture_unacquirePtr(this: *const c_void);
	fn tsMTLTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_create(this: *mut c_void, texture: *mut c_void, flags: TextureFlags, format: Format) -> i32;
	fn tsMTLTexture_getPixelFormat(this: *const c_void) -> u32;
	fn tsMTLTexture_getTextureType(this: *const c_void) -> u32;
	fn tsMTLTexture_getMTLTexture(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_getMTLBuffer(this: *const c_void) -> *mut c_void;
	fn tsMTLTexture_getSharedPtr(this: *const c_void) -> *mut c_void;
}

// Tellusim::VKTexture
pub struct VKTexture {
	this: *mut c_void,
	owner: bool,
}
impl VKTexture {
	pub fn null() -> VKTexture { VKTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKTexture { unsafe { VKTexture { this: tsVKTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKTexture { unsafe { VKTexture { this: ptr, owner: tsVKTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKTexture { unsafe { VKTexture { this: tsVKTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> VKTexture { unsafe { VKTexture::new_ptr(tsVKTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsVKTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKTexture) -> bool { unsafe { tsVKTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKTexture { unsafe { VKTexture { this: tsVKTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, type_: TextureType, format: u32, texture: *const c_void, layout: u32) -> bool { unsafe { tsVKTexture_create(self.this, type_, format, texture, layout, TextureFlags::None, Format::Unknown) != 0 } }
	pub fn create_with_flags(&mut self, type_: TextureType, format: u32, texture: *const c_void, layout: u32, flags: TextureFlags) -> bool { unsafe { tsVKTexture_create(self.this, type_, format, texture, layout, flags, Format::Unknown) != 0 } }
	pub fn create_with_flags_textureformat(&mut self, type_: TextureType, format: u32, texture: *const c_void, layout: u32, flags: TextureFlags, texture_format: Format) -> bool { unsafe { tsVKTexture_create(self.this, type_, format, texture, layout, flags, texture_format) != 0 } }
	pub fn pixel_format(&self) -> u32 { unsafe { tsVKTexture_getPixelFormat(self.this) } }
	pub fn vk_texture(&self) -> *const c_void { unsafe { tsVKTexture_getVKTexture(self.this) } }
	pub fn texture_view(&self) -> *const c_void { unsafe { tsVKTexture_getTextureView(self.this) } }
	pub fn set_texture_layout(&mut self, layout: u32) { unsafe { tsVKTexture_setTextureLayout(self.this, layout) } }
	pub fn texture_layout(&self) -> u32 { unsafe { tsVKTexture_getTextureLayout(self.this) } }
	pub fn texture_range(&self, range: *mut c_void, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsVKTexture_getTextureRange(self.this, range, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	pub fn shared_ptr(&self) -> *mut c_void { unsafe { tsVKTexture_getSharedPtr(self.this) } }
	pub fn interop_handle(&self) -> *mut c_void { unsafe { tsVKTexture_getInteropHandle(self.this) } }
}
impl TextureTrait for VKTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for VKTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsVKTexture_delete(self.this) } } }
}
impl Clone for VKTexture {
	fn clone(&self) -> VKTexture { unsafe { VKTexture { this: tsVKTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKTexture { }
impl fmt::Display for VKTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKTexture_new() -> *mut c_void;
	fn tsVKTexture_delete(this: *mut c_void);
	fn tsVKTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKTexture_clearPtr(this: *const c_void);
	fn tsVKTexture_destroyPtr(this: *const c_void);
	fn tsVKTexture_acquirePtr(this: *const c_void);
	fn tsVKTexture_unacquirePtr(this: *const c_void);
	fn tsVKTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsVKTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsVKTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsVKTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsVKTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsVKTexture_create(this: *mut c_void, type_: TextureType, format: u32, texture: *const c_void, layout: u32, flags: TextureFlags, texture_format: Format) -> i32;
	fn tsVKTexture_getPixelFormat(this: *const c_void) -> u32;
	fn tsVKTexture_getVKTexture(this: *const c_void) -> *const c_void;
	fn tsVKTexture_getTextureView(this: *const c_void) -> *const c_void;
	fn tsVKTexture_setTextureLayout(this: *mut c_void, layout: u32);
	fn tsVKTexture_getTextureLayout(this: *const c_void) -> u32;
	fn tsVKTexture_getTextureRange(this: *const c_void, range: *mut c_void, slice: *const Slice);
	fn tsVKTexture_getSharedPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTexture_getInteropHandle(this: *const c_void) -> *mut c_void;
}

// Tellusim::GLTexture
pub struct GLTexture {
	this: *mut c_void,
	owner: bool,
}
impl GLTexture {
	pub fn null() -> GLTexture { GLTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLTexture { unsafe { GLTexture { this: tsGLTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLTexture { unsafe { GLTexture { this: ptr, owner: tsGLTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLTexture { unsafe { GLTexture { this: tsGLTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> GLTexture { unsafe { GLTexture::new_ptr(tsGLTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsGLTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLTexture) -> bool { unsafe { tsGLTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLTexture { unsafe { GLTexture { this: tsGLTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, target: u32, texture_id: u32) -> bool { unsafe { tsGLTexture_create(self.this, target, texture_id, TextureFlags::None, Format::Unknown) != 0 } }
	pub fn create_with_flags(&mut self, target: u32, texture_id: u32, flags: TextureFlags) -> bool { unsafe { tsGLTexture_create(self.this, target, texture_id, flags, Format::Unknown) != 0 } }
	pub fn create_with_flags_format(&mut self, target: u32, texture_id: u32, flags: TextureFlags, format: Format) -> bool { unsafe { tsGLTexture_create(self.this, target, texture_id, flags, format) != 0 } }
	pub fn target(&self) -> u32 { unsafe { tsGLTexture_getTarget(self.this) } }
	pub fn internal_format(&self) -> u32 { unsafe { tsGLTexture_getInternalFormat(self.this) } }
	pub fn texture_id(&self) -> u32 { unsafe { tsGLTexture_getTextureID(self.this) } }
}
impl TextureTrait for GLTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for GLTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsGLTexture_delete(self.this) } } }
}
impl Clone for GLTexture {
	fn clone(&self) -> GLTexture { unsafe { GLTexture { this: tsGLTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLTexture { }
impl fmt::Display for GLTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLTexture_new() -> *mut c_void;
	fn tsGLTexture_delete(this: *mut c_void);
	fn tsGLTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLTexture_clearPtr(this: *const c_void);
	fn tsGLTexture_destroyPtr(this: *const c_void);
	fn tsGLTexture_acquirePtr(this: *const c_void);
	fn tsGLTexture_unacquirePtr(this: *const c_void);
	fn tsGLTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsGLTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsGLTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsGLTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsGLTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsGLTexture_create(this: *mut c_void, target: u32, texture_id: u32, flags: TextureFlags, format: Format) -> i32;
	fn tsGLTexture_getTarget(this: *const c_void) -> u32;
	fn tsGLTexture_getInternalFormat(this: *const c_void) -> u32;
	fn tsGLTexture_getTextureID(this: *const c_void) -> u32;
}

// Tellusim::GLESTexture
pub struct GLESTexture {
	this: *mut c_void,
	owner: bool,
}
impl GLESTexture {
	pub fn null() -> GLESTexture { GLESTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLESTexture { unsafe { GLESTexture { this: tsGLESTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLESTexture { unsafe { GLESTexture { this: ptr, owner: tsGLESTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLESTexture { unsafe { GLESTexture { this: tsGLESTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> GLESTexture { unsafe { GLESTexture::new_ptr(tsGLESTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsGLESTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLESTexture) -> bool { unsafe { tsGLESTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLESTexture { unsafe { GLESTexture { this: tsGLESTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLESTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLESTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLESTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLESTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLESTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLESTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLESTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLESTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLESTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn create(&mut self, target: u32, texture_id: u32) -> bool { unsafe { tsGLESTexture_create(self.this, target, texture_id, TextureFlags::None, Format::Unknown) != 0 } }
	pub fn create_with_flags(&mut self, target: u32, texture_id: u32, flags: TextureFlags) -> bool { unsafe { tsGLESTexture_create(self.this, target, texture_id, flags, Format::Unknown) != 0 } }
	pub fn create_with_flags_format(&mut self, target: u32, texture_id: u32, flags: TextureFlags, format: Format) -> bool { unsafe { tsGLESTexture_create(self.this, target, texture_id, flags, format) != 0 } }
	pub fn target(&self) -> u32 { unsafe { tsGLESTexture_getTarget(self.this) } }
	pub fn internal_format(&self) -> u32 { unsafe { tsGLESTexture_getInternalFormat(self.this) } }
	pub fn texture_id(&self) -> u32 { unsafe { tsGLESTexture_getTextureID(self.this) } }
}
impl TextureTrait for GLESTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for GLESTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsGLESTexture_delete(self.this) } } }
}
impl Clone for GLESTexture {
	fn clone(&self) -> GLESTexture { unsafe { GLESTexture { this: tsGLESTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLESTexture { }
impl fmt::Display for GLESTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLESTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLESTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLESTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLESTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLESTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLESTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLESTexture_new() -> *mut c_void;
	fn tsGLESTexture_delete(this: *mut c_void);
	fn tsGLESTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTexture_clearPtr(this: *const c_void);
	fn tsGLESTexture_destroyPtr(this: *const c_void);
	fn tsGLESTexture_acquirePtr(this: *const c_void);
	fn tsGLESTexture_unacquirePtr(this: *const c_void);
	fn tsGLESTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsGLESTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLESTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsGLESTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsGLESTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTexture_create(this: *mut c_void, target: u32, texture_id: u32, flags: TextureFlags, format: Format) -> i32;
	fn tsGLESTexture_getTarget(this: *const c_void) -> u32;
	fn tsGLESTexture_getInternalFormat(this: *const c_void) -> u32;
	fn tsGLESTexture_getTextureID(this: *const c_void) -> u32;
}

// Tellusim::CUTexture
pub struct CUTexture {
	this: *mut c_void,
	owner: bool,
}
impl CUTexture {
	pub fn null() -> CUTexture { CUTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CUTexture { unsafe { CUTexture { this: tsCUTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CUTexture { unsafe { CUTexture { this: ptr, owner: tsCUTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CUTexture { unsafe { CUTexture { this: tsCUTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> CUTexture { unsafe { CUTexture::new_ptr(tsCUTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCUTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CUTexture) -> bool { unsafe { tsCUTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CUTexture { unsafe { CUTexture { this: tsCUTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCUTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCUTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCUTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCUTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCUTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCUTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCUTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCUTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCUTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn texture_level(&self, index: u32) -> *const c_void { unsafe { tsCUTexture_getTextureLevel(self.this, index) } }
	pub fn array_format(&self) -> u32 { unsafe { tsCUTexture_getArrayFormat(self.this) } }
	pub fn array_channels(&self) -> u32 { unsafe { tsCUTexture_getArrayChannels(self.this) } }
	pub fn shared_memory(&self) -> *const c_void { unsafe { tsCUTexture_getSharedMemory(self.this) } }
}
impl TextureTrait for CUTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for CUTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsCUTexture_delete(self.this) } } }
}
impl Clone for CUTexture {
	fn clone(&self) -> CUTexture { unsafe { CUTexture { this: tsCUTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CUTexture { }
impl fmt::Display for CUTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CUTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCUTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCUTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCUTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCUTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCUTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCUTexture_new() -> *mut c_void;
	fn tsCUTexture_delete(this: *mut c_void);
	fn tsCUTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCUTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCUTexture_clearPtr(this: *const c_void);
	fn tsCUTexture_destroyPtr(this: *const c_void);
	fn tsCUTexture_acquirePtr(this: *const c_void);
	fn tsCUTexture_unacquirePtr(this: *const c_void);
	fn tsCUTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsCUTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCUTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsCUTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsCUTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCUTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCUTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsCUTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsCUTexture_getTextureLevel(this: *const c_void, index: u32) -> *const c_void;
	fn tsCUTexture_getArrayFormat(this: *const c_void) -> u32;
	fn tsCUTexture_getArrayChannels(this: *const c_void) -> u32;
	fn tsCUTexture_getSharedMemory(this: *const c_void) -> *const c_void;
}

// Tellusim::HIPTexture
pub struct HIPTexture {
	this: *mut c_void,
	owner: bool,
}
impl HIPTexture {
	pub fn null() -> HIPTexture { HIPTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> HIPTexture { unsafe { HIPTexture { this: tsHIPTexture_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> HIPTexture { unsafe { HIPTexture { this: ptr, owner: tsHIPTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> HIPTexture { unsafe { HIPTexture { this: tsHIPTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> HIPTexture { unsafe { HIPTexture::new_ptr(tsHIPTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsHIPTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: HIPTexture) -> bool { unsafe { tsHIPTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> HIPTexture { unsafe { HIPTexture { this: tsHIPTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsHIPTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsHIPTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsHIPTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsHIPTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsHIPTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsHIPTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsHIPTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsHIPTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsHIPTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn texture_array(&self) -> *mut c_void { unsafe { tsHIPTexture_getTextureArray(self.this) } }
	pub fn texture_level(&self, index: u32) -> *mut c_void { unsafe { tsHIPTexture_getTextureLevel(self.this, index) } }
	pub fn array_format(&self) -> u32 { unsafe { tsHIPTexture_getArrayFormat(self.this) } }
	pub fn array_channels(&self) -> u32 { unsafe { tsHIPTexture_getArrayChannels(self.this) } }
	pub fn shared_memory(&self) -> *mut c_void { unsafe { tsHIPTexture_getSharedMemory(self.this) } }
}
impl TextureTrait for HIPTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for HIPTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsHIPTexture_delete(self.this) } } }
}
impl Clone for HIPTexture {
	fn clone(&self) -> HIPTexture { unsafe { HIPTexture { this: tsHIPTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for HIPTexture { }
impl fmt::Display for HIPTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::HIPTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsHIPTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsHIPTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsHIPTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsHIPTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsHIPTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsHIPTexture_new() -> *mut c_void;
	fn tsHIPTexture_delete(this: *mut c_void);
	fn tsHIPTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsHIPTexture_clearPtr(this: *const c_void);
	fn tsHIPTexture_destroyPtr(this: *const c_void);
	fn tsHIPTexture_acquirePtr(this: *const c_void);
	fn tsHIPTexture_unacquirePtr(this: *const c_void);
	fn tsHIPTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsHIPTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsHIPTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsHIPTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsHIPTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsHIPTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsHIPTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsHIPTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsHIPTexture_getTextureArray(this: *const c_void) -> *mut c_void;
	fn tsHIPTexture_getTextureLevel(this: *const c_void, index: u32) -> *mut c_void;
	fn tsHIPTexture_getArrayFormat(this: *const c_void) -> u32;
	fn tsHIPTexture_getArrayChannels(this: *const c_void) -> u32;
	fn tsHIPTexture_getSharedMemory(this: *const c_void) -> *mut c_void;
}

// Tellusim::FUTexture
pub struct FUTexture {
	this: *mut c_void,
	owner: bool,
}
impl FUTexture {
	pub fn null() -> FUTexture { FUTexture { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUTexture { unsafe { FUTexture { this: tsFUTexture_new(), owner: true } } }
	pub fn new_with_textures(textures: &[&mut Texture]) -> FUTexture {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { FUTexture { this: tsFUTexture_new_cATb(textures_.as_ptr(), textures.len() as u32, 0), owner: true } }
	}
	pub fn new_with_textures_owner(textures: &[&mut Texture], owner: bool) -> FUTexture {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { FUTexture { this: tsFUTexture_new_cATb(textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUTexture { unsafe { FUTexture { this: ptr, owner: tsFUTexture_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUTexture { unsafe { FUTexture { this: tsFUTexture_copyPtr(self.this), owner: true } } }
	pub fn from_texture(ptr: &Texture) -> FUTexture { unsafe { FUTexture::new_ptr(tsFUTexture_castTexturePtr(ptr.this)) } }
	pub fn to_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsFUTexture_baseTexturePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUTexture) -> bool { unsafe { tsFUTexture_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUTexture { unsafe { FUTexture { this: tsFUTexture_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUTexture_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUTexture_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUTexture_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUTexture_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUTexture_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUTexture_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUTexture_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUTexture_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUTexture_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUTexture_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUTexture_getMask(self.this) } }
	pub fn num_textures(&self) -> u32 { unsafe { tsFUTexture_getNumTextures(self.this) } }
	pub fn texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsFUTexture_getTexture_cu(self.this, index)) } }
	pub fn texture_mut(&mut self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsFUTexture_getTexture_u(self.this, index)) } }
}
impl TextureTrait for FUTexture {
	fn platform(&self) -> Platform { unsafe { tsTexture_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTexture_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTexture_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTexture_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTexture_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTexture_getName(self.this)) } }
	fn create(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, TextureFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create(self.this, type_, format, size, layers, flags) != 0 } }
	fn create2d_with_size(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create2d_with_size_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuTF(self.this, format, size, flags) != 0 } }
	fn create3d(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create3d_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuTF(self.this, format, size, flags) != 0 } }
	fn create_cube(&mut self, format: Format, size: u32) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, TextureFlags::None) != 0 } }
	fn create_cube_with_flags(&mut self, format: Format, size: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuTF(self.this, format, size, flags) != 0 } }
	fn create2d_with_width(&mut self, format: Format, width: u32, height: u32) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, TextureFlags::None) != 0 } }
	fn create2d_with_width_flags(&mut self, format: Format, width: u32, height: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuTF(self.this, format, width, height, flags) != 0 } }
	fn create3d_with_width(&mut self, format: Format, width: u32, height: u32, depth: u32) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, TextureFlags::None) != 0 } }
	fn create3d_with_width_flags(&mut self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create3D_FuuuTF(self.this, format, width, height, depth, flags) != 0 } }
	fn create2d_with_width_layers(&mut self, format: Format, width: u32, height: u32, layers: u32) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, TextureFlags::None) != 0 } }
	fn create2d_with_width_layers_flags(&mut self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_create2D_FuuuTF(self.this, format, width, height, layers, flags) != 0 } }
	fn create_cube_with_layers(&mut self, format: Format, size: u32, layers: u32) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, TextureFlags::None) != 0 } }
	fn create_cube_with_layers_flags(&mut self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> bool { unsafe { tsTexture_createCube_FuuTF(self.this, format, size, layers, flags) != 0 } }
	fn type_(&self) -> TextureType { unsafe { tsTexture_getType(self.this) } }
	fn type_name_with_type(type_: TextureType) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getTypeName_c(self.this)) } }
	fn is2d_type(&self) -> bool { unsafe { tsTexture_is2DType(self.this) != 0 } }
	fn is3d_type(&self) -> bool { unsafe { tsTexture_is3DType(self.this) != 0 } }
	fn is_cube_type(&self) -> bool { unsafe { tsTexture_isCubeType(self.this) != 0 } }
	fn format(&self) -> Format { unsafe { tsTexture_getFormat(self.this) } }
	fn format_name(&self) -> string::String { unsafe { get_cstring(tsTexture_getFormatName(self.this)) } }
	fn is_color_format(&self) -> bool { unsafe { tsTexture_isColorFormat(self.this) != 0 } }
	fn is_depth_format(&self) -> bool { unsafe { tsTexture_isDepthFormat(self.this) != 0 } }
	fn is_pixel_format(&self) -> bool { unsafe { tsTexture_isPixelFormat(self.this) != 0 } }
	fn is_plain_format(&self) -> bool { unsafe { tsTexture_isPlainFormat(self.this) != 0 } }
	fn is_mixed_format(&self) -> bool { unsafe { tsTexture_isMixedFormat(self.this) != 0 } }
	fn is_block_format(&self) -> bool { unsafe { tsTexture_isBlockFormat(self.this) != 0 } }
	fn is_stencil_format(&self) -> bool { unsafe { tsTexture_isStencilFormat(self.this) != 0 } }
	fn is_norm_format(&self) -> bool { unsafe { tsTexture_isNormFormat(self.this) != 0 } }
	fn is_srgb_format(&self) -> bool { unsafe { tsTexture_isSRGBFormat(self.this) != 0 } }
	fn is_float_format(&self) -> bool { unsafe { tsTexture_isFloatFormat(self.this) != 0 } }
	fn is_signed_format(&self) -> bool { unsafe { tsTexture_isSignedFormat(self.this) != 0 } }
	fn is_unsigned_format(&self) -> bool { unsafe { tsTexture_isUnsignedFormat(self.this) != 0 } }
	fn is_integer_format(&self) -> bool { unsafe { tsTexture_isIntegerFormat(self.this) != 0 } }
	fn isi8_format(&self) -> bool { unsafe { tsTexture_isi8Format(self.this) != 0 } }
	fn isu8_format(&self) -> bool { unsafe { tsTexture_isu8Format(self.this) != 0 } }
	fn is8_bit_format(&self) -> bool { unsafe { tsTexture_is8BitFormat(self.this) != 0 } }
	fn isi16_format(&self) -> bool { unsafe { tsTexture_isi16Format(self.this) != 0 } }
	fn isu16_format(&self) -> bool { unsafe { tsTexture_isu16Format(self.this) != 0 } }
	fn isf16_format(&self) -> bool { unsafe { tsTexture_isf16Format(self.this) != 0 } }
	fn is16_bit_format(&self) -> bool { unsafe { tsTexture_is16BitFormat(self.this) != 0 } }
	fn isi32_format(&self) -> bool { unsafe { tsTexture_isi32Format(self.this) != 0 } }
	fn isu32_format(&self) -> bool { unsafe { tsTexture_isu32Format(self.this) != 0 } }
	fn isf32_format(&self) -> bool { unsafe { tsTexture_isf32Format(self.this) != 0 } }
	fn is32_bit_format(&self) -> bool { unsafe { tsTexture_is32BitFormat(self.this) != 0 } }
	fn isi64_format(&self) -> bool { unsafe { tsTexture_isi64Format(self.this) != 0 } }
	fn isu64_format(&self) -> bool { unsafe { tsTexture_isu64Format(self.this) != 0 } }
	fn isf64_format(&self) -> bool { unsafe { tsTexture_isf64Format(self.this) != 0 } }
	fn is64_bit_format(&self) -> bool { unsafe { tsTexture_is64BitFormat(self.this) != 0 } }
	fn is_bc15_format(&self) -> bool { unsafe { tsTexture_isBC15Format(self.this) != 0 } }
	fn is_bc67_format(&self) -> bool { unsafe { tsTexture_isBC67Format(self.this) != 0 } }
	fn is_etc2_format(&self) -> bool { unsafe { tsTexture_isETC2Format(self.this) != 0 } }
	fn is_astc_format(&self) -> bool { unsafe { tsTexture_isASTCFormat(self.this) != 0 } }
	fn components(&self) -> u32 { unsafe { tsTexture_getComponents(self.this) } }
	fn pixel_size(&self) -> u32 { unsafe { tsTexture_getPixelSize(self.this) } }
	fn block_size(&self) -> u32 { unsafe { tsTexture_getBlockSize(self.this) } }
	fn block_width(&self) -> u32 { unsafe { tsTexture_getBlockWidth(self.this) } }
	fn block_height(&self) -> u32 { unsafe { tsTexture_getBlockHeight(self.this) } }
	fn flags(&self) -> TextureFlags { unsafe { tsTexture_getFlags(self.this) } }
	fn has_flag(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlag(self.this, flags) != 0 } }
	fn has_flags(&self, flags: TextureFlags) -> bool { unsafe { tsTexture_hasFlags(self.this, flags) != 0 } }
	fn flags_name(&self) -> string::String { unsafe { get_string(tsTexture_getFlagsName(self.this)) } }
	fn multisample(&self) -> u32 { unsafe { tsTexture_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTexture_hasMultisample(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTexture_getWidth_c(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTexture_getHeight_c(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTexture_getDepth_c(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTexture_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTexture_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTexture_getMipmaps(self.this) } }
	fn find_mipmap(&self, size: &Size) -> u32 { unsafe { tsTexture_findMipmap(self.this, size) } }
	fn width_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getWidth_cu(self.this, mipmap) } }
	fn height_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getHeight_cu(self.this, mipmap) } }
	fn depth_with_mipmap(&self, mipmap: u32) -> u32 { unsafe { tsTexture_getDepth_cu(self.this, mipmap) } }
	fn has_faces(&self) -> bool { unsafe { tsTexture_hasFaces(self.this) != 0 } }
	fn has_layers(&self) -> bool { unsafe { tsTexture_hasLayers(self.this) != 0 } }
	fn has_mipmaps(&self) -> bool { unsafe { tsTexture_hasMipmaps(self.this) != 0 } }
	fn size(&self) -> Size { unsafe { tsTexture_getSize_c(self.this) } }
	fn region(&self) -> Region { unsafe { tsTexture_getRegion_c(self.this) } }
	fn slice(&self) -> Slice { unsafe { tsTexture_getSlice_c(self.this) } }
	fn size_with_mipmap(&self, mipmap: u32) -> Size { unsafe { tsTexture_getSize_cu(self.this, mipmap) } }
	fn region_with_mipmap(&self, mipmap: u32) -> Region { unsafe { tsTexture_getRegion_cu(self.this, mipmap) } }
	fn slice_with_mipmap(&self, mipmap: u32) -> Slice { unsafe { tsTexture_getSlice_cu(self.this, mipmap) } }
	fn tile_width(&self) -> u32 { unsafe { tsTexture_getTileWidth(self.this) } }
	fn tile_height(&self) -> u32 { unsafe { tsTexture_getTileHeight(self.this) } }
	fn tile_depth(&self) -> u32 { unsafe { tsTexture_getTileDepth(self.this) } }
	fn tile_mipmaps(&self) -> u32 { unsafe { tsTexture_getTileMipmaps(self.this) } }
	fn tile_size(&self) -> Size { unsafe { tsTexture_getTileSize(self.this) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTexture_getDescription(self.this)) } }
	fn memory(&self) -> usize { unsafe { tsTexture_getMemory(self.this) } }
}
impl Drop for FUTexture {
	fn drop(&mut self) { if self.owner { unsafe { tsFUTexture_delete(self.this) } } }
}
impl Clone for FUTexture {
	fn clone(&self) -> FUTexture { unsafe { FUTexture { this: tsFUTexture_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUTexture { }
impl fmt::Display for FUTexture {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUTexture ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUTexture_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUTexture_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUTexture_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUTexture_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUTexture_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUTexture_new() -> *mut c_void;
	fn tsFUTexture_new_cATb(textures: *const *mut c_void, textures_size: u32, owner: i32) -> *mut c_void;
	fn tsFUTexture_delete(this: *mut c_void);
	fn tsFUTexture_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTexture_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTexture_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUTexture_clearPtr(this: *const c_void);
	fn tsFUTexture_destroyPtr(this: *const c_void);
	fn tsFUTexture_acquirePtr(this: *const c_void);
	fn tsFUTexture_unacquirePtr(this: *const c_void);
	fn tsFUTexture_isValidPtr(this: *const c_void) -> i32;
	fn tsFUTexture_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUTexture_isConstPtr(this: *const c_void) -> i32;
	fn tsFUTexture_getCountPtr(this: *const c_void) -> u32;
	fn tsFUTexture_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTexture_equalTexturePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTexture_castTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsFUTexture_baseTexturePtr(this: *const c_void) -> *mut c_void;
	fn tsFUTexture_setMask(this: *mut c_void, mask: u32);
	fn tsFUTexture_getMask(this: *const c_void) -> u32;
	fn tsFUTexture_getNumTextures(this: *const c_void) -> u32;
	fn tsFUTexture_getTexture_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUTexture_getTexture_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Tracing
pub struct Tracing {
	this: *mut c_void,
	owner: bool,
}
impl Tracing {
	pub fn null() -> Tracing { Tracing { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Tracing { unsafe { Tracing { this: tsTracing_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Tracing { unsafe { Tracing { this: ptr, owner: tsTracing_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Tracing { unsafe { Tracing { this: tsTracing_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Tracing) -> bool { unsafe { tsTracing_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Tracing { unsafe { Tracing { this: tsTracing_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsTracing_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsTracing_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsTracing_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsTracing_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsTracing_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsTracing_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsTracing_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsTracing_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsTracing_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait TracingTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn is_built(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn name(&self) -> string::String;
	fn create(&mut self, type_: TracingType) -> bool;
	fn create_with_flags(&mut self, type_: TracingType, flags: TracingFlags) -> bool;
	fn type_(&self) -> TracingType;
	fn type_name_with_type(type_: TracingType) -> string::String;
	fn type_name(&self) -> string::String;
	fn is_instance_type(&self) -> bool;
	fn is_triangle_type(&self) -> bool;
	fn is_bound_type(&self) -> bool;
	fn is_geometry_type(&self) -> bool;
	fn set_parameters(&mut self, tracing: &Tracing);
	fn num_geometries(&self) -> u32;
	fn set_instance_buffer_with_instances(&mut self, num_instances: u32, buffer: &mut Buffer);
	fn set_instance_buffer_with_instances_offset(&mut self, num_instances: u32, buffer: &mut Buffer, offset: usize);
	fn set_instance_buffer(&mut self, buffer: &mut Buffer);
	fn set_instance_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize);
	fn set_num_instances(&mut self, num_instances: u32);
	fn num_instances(&self) -> u32;
	fn instance_buffer(&self) -> Buffer;
	fn instance_offset(&self) -> usize;
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer);
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize);
	fn indirect_buffer(&self) -> Buffer;
	fn indirect_offset(&self) -> usize;
	fn add_vertex_buffer(&mut self, num_vertices: u32, format: Format, stride: usize) -> u32;
	fn add_vertex_buffer_with_buffer(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer) -> u32;
	fn add_vertex_buffer_with_buffer_offset(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer, offset: usize) -> u32;
	fn set_vertex_buffer_with_vertices(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer);
	fn set_vertex_buffer_with_vertices_offset(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer, offset: usize);
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_num_vertices(&mut self, index: u32, num_vertices: u32);
	fn num_vertices(&self, index: u32) -> u32;
	fn vertex_format(&self, index: u32) -> Format;
	fn vertex_stride(&self, index: u32) -> u32;
	fn vertex_buffer(&self, index: u32) -> Buffer;
	fn vertex_offset(&self, index: u32) -> usize;
	fn add_index_buffer(&mut self, num_indices: u32, format: Format) -> u32;
	fn add_index_buffer_with_buffer(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer) -> u32;
	fn add_index_buffer_with_buffer_offset(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer, offset: usize) -> u32;
	fn set_index_buffer_with_indices(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer);
	fn set_index_buffer_with_indices_offset(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer, offset: usize);
	fn set_index_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_index_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_num_indices(&mut self, index: u32, num_indices: u32);
	fn num_indices(&self, index: u32) -> u32;
	fn index_format(&self, index: u32) -> Format;
	fn index_buffer(&self, index: u32) -> Buffer;
	fn index_offset(&self, index: u32) -> usize;
	fn add_bound_buffer(&mut self, num_bounds: u32, stride: usize) -> u32;
	fn add_bound_buffer_with_buffer(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer) -> u32;
	fn add_bound_buffer_with_buffer_offset(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer, offset: usize) -> u32;
	fn set_bound_buffer_with_bounds(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer);
	fn set_bound_buffer_with_bounds_offset(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer, offset: usize);
	fn set_bound_buffer(&mut self, index: u32, buffer: &mut Buffer);
	fn set_bound_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize);
	fn set_num_bounds(&mut self, index: u32, num_bounds: u32);
	fn num_bounds(&self, index: u32) -> u32;
	fn bound_stride(&self, index: u32) -> u32;
	fn bound_buffer(&self, index: u32) -> Buffer;
	fn bound_offset(&self, index: u32) -> usize;
	fn description(&self) -> string::String;
	fn tracing_address(&self) -> u64;
	fn build_size(&self) -> usize;
	fn update_size(&self) -> usize;
	fn memory(&self) -> usize;
}
impl TracingTrait for Tracing {
	fn platform(&self) -> Platform { unsafe { tsTracing_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTracing_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTracing_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTracing_isCreated(self.this) != 0 } }
	fn is_built(&self) -> bool { unsafe { tsTracing_isBuilt(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTracing_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTracing_getName(self.this)) } }
	fn create(&mut self, type_: TracingType) -> bool { unsafe { tsTracing_create(self.this, type_, TracingFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TracingType, flags: TracingFlags) -> bool { unsafe { tsTracing_create(self.this, type_, flags) != 0 } }
	fn type_(&self) -> TracingType { unsafe { tsTracing_getType(self.this) } }
	fn type_name_with_type(type_: TracingType) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_c(self.this)) } }
	fn is_instance_type(&self) -> bool { unsafe { tsTracing_isInstanceType(self.this) != 0 } }
	fn is_triangle_type(&self) -> bool { unsafe { tsTracing_isTriangleType(self.this) != 0 } }
	fn is_bound_type(&self) -> bool { unsafe { tsTracing_isBoundType(self.this) != 0 } }
	fn is_geometry_type(&self) -> bool { unsafe { tsTracing_isGeometryType(self.this) != 0 } }
	fn set_parameters(&mut self, tracing: &Tracing) { unsafe { tsTracing_setParameters(self.this, tracing.this) } }
	fn num_geometries(&self) -> u32 { unsafe { tsTracing_getNumGeometries(self.this) } }
	fn set_instance_buffer_with_instances(&mut self, num_instances: u32, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, 0) } }
	fn set_instance_buffer_with_instances_offset(&mut self, num_instances: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, offset) } }
	fn set_instance_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, 0) } }
	fn set_instance_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, offset) } }
	fn set_num_instances(&mut self, num_instances: u32) { unsafe { tsTracing_setNumInstances(self.this, num_instances) } }
	fn num_instances(&self) -> u32 { unsafe { tsTracing_getNumInstances(self.this) } }
	fn instance_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getInstanceBuffer(self.this)) } }
	fn instance_offset(&self) -> usize { unsafe { tsTracing_getInstanceOffset(self.this) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn indirect_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndirectBuffer(self.this)) } }
	fn indirect_offset(&self) -> usize { unsafe { tsTracing_getIndirectOffset(self.this) } }
	fn add_vertex_buffer(&mut self, num_vertices: u32, format: Format, stride: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, ptr::null_mut(), 0) } }
	fn add_vertex_buffer_with_buffer(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, 0) } }
	fn add_vertex_buffer_with_buffer_offset(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, offset) } }
	fn set_vertex_buffer_with_vertices(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, 0) } }
	fn set_vertex_buffer_with_vertices_offset(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, offset) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_vertices(&mut self, index: u32, num_vertices: u32) { unsafe { tsTracing_setNumVertices(self.this, index, num_vertices) } }
	fn num_vertices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumVertices(self.this, index) } }
	fn vertex_format(&self, index: u32) -> Format { unsafe { tsTracing_getVertexFormat(self.this, index) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getVertexStride(self.this, index) } }
	fn vertex_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getVertexBuffer(self.this, index)) } }
	fn vertex_offset(&self, index: u32) -> usize { unsafe { tsTracing_getVertexOffset(self.this, index) } }
	fn add_index_buffer(&mut self, num_indices: u32, format: Format) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, ptr::null_mut(), 0) } }
	fn add_index_buffer_with_buffer(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, 0) } }
	fn add_index_buffer_with_buffer_offset(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, offset) } }
	fn set_index_buffer_with_indices(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, 0) } }
	fn set_index_buffer_with_indices_offset(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, offset) } }
	fn set_index_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_indices(&mut self, index: u32, num_indices: u32) { unsafe { tsTracing_setNumIndices(self.this, index, num_indices) } }
	fn num_indices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumIndices(self.this, index) } }
	fn index_format(&self, index: u32) -> Format { unsafe { tsTracing_getIndexFormat(self.this, index) } }
	fn index_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndexBuffer(self.this, index)) } }
	fn index_offset(&self, index: u32) -> usize { unsafe { tsTracing_getIndexOffset(self.this, index) } }
	fn add_bound_buffer(&mut self, num_bounds: u32, stride: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, ptr::null_mut(), 0) } }
	fn add_bound_buffer_with_buffer(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, 0) } }
	fn add_bound_buffer_with_buffer_offset(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, offset) } }
	fn set_bound_buffer_with_bounds(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, 0) } }
	fn set_bound_buffer_with_bounds_offset(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, offset) } }
	fn set_bound_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_bound_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_bounds(&mut self, index: u32, num_bounds: u32) { unsafe { tsTracing_setNumBounds(self.this, index, num_bounds) } }
	fn num_bounds(&self, index: u32) -> u32 { unsafe { tsTracing_getNumBounds(self.this, index) } }
	fn bound_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getBoundStride(self.this, index) } }
	fn bound_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getBoundBuffer(self.this, index)) } }
	fn bound_offset(&self, index: u32) -> usize { unsafe { tsTracing_getBoundOffset(self.this, index) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTracing_getDescription(self.this)) } }
	fn tracing_address(&self) -> u64 { unsafe { tsTracing_getTracingAddress(self.this) } }
	fn build_size(&self) -> usize { unsafe { tsTracing_getBuildSize(self.this) } }
	fn update_size(&self) -> usize { unsafe { tsTracing_getUpdateSize(self.this) } }
	fn memory(&self) -> usize { unsafe { tsTracing_getMemory(self.this) } }
}
impl Drop for Tracing {
	fn drop(&mut self) { if self.owner { unsafe { tsTracing_delete(self.this) } } }
}
impl Clone for Tracing {
	fn clone(&self) -> Tracing { unsafe { Tracing { this: tsTracing_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Tracing { }
impl fmt::Display for Tracing {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Tracing ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsTracing_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsTracing_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsTracing_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsTracing_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsTracing_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsTracing_new() -> *mut c_void;
	fn tsTracing_delete(this: *mut c_void);
	fn tsTracing_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsTracing_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsTracing_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsTracing_clearPtr(this: *const c_void);
	fn tsTracing_destroyPtr(this: *const c_void);
	fn tsTracing_acquirePtr(this: *const c_void);
	fn tsTracing_unacquirePtr(this: *const c_void);
	fn tsTracing_isValidPtr(this: *const c_void) -> i32;
	fn tsTracing_isOwnerPtr(this: *const c_void) -> i32;
	fn tsTracing_isConstPtr(this: *const c_void) -> i32;
	fn tsTracing_getCountPtr(this: *const c_void) -> u32;
	fn tsTracing_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsTracing_getPlatform(this: *const c_void) -> Platform;
	fn tsTracing_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsTracing_getIndex(this: *const c_void) -> u32;
	fn tsTracing_clear(this: *mut c_void);
	fn tsTracing_isCreated(this: *const c_void) -> i32;
	fn tsTracing_isBuilt(this: *const c_void) -> i32;
	fn tsTracing_setName(this: *mut c_void, name: *const c_char);
	fn tsTracing_getName(this: *const c_void) -> *mut c_void;
	fn tsTracing_create(this: *mut c_void, type_: TracingType, flags: TracingFlags) -> i32;
	fn tsTracing_getType(this: *const c_void) -> TracingType;
	fn tsTracing_getTypeName_TT(type_: TracingType) -> *const c_char;
	fn tsTracing_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsTracing_isInstanceType(this: *const c_void) -> i32;
	fn tsTracing_isTriangleType(this: *const c_void) -> i32;
	fn tsTracing_isBoundType(this: *const c_void) -> i32;
	fn tsTracing_isGeometryType(this: *const c_void) -> i32;
	fn tsTracing_setParameters(this: *mut c_void, tracing: *mut c_void);
	fn tsTracing_getNumGeometries(this: *const c_void) -> u32;
	fn tsTracing_setInstanceBuffer_uBz(this: *mut c_void, num_instances: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setInstanceBuffer_Bz(this: *mut c_void, buffer: *mut c_void, offset: usize);
	fn tsTracing_setNumInstances(this: *mut c_void, num_instances: u32);
	fn tsTracing_getNumInstances(this: *const c_void) -> u32;
	fn tsTracing_getInstanceBuffer(this: *const c_void) -> *mut c_void;
	fn tsTracing_getInstanceOffset(this: *const c_void) -> usize;
	fn tsTracing_setIndirectBuffer(this: *mut c_void, buffer: *mut c_void, offset: usize);
	fn tsTracing_getIndirectBuffer(this: *const c_void) -> *mut c_void;
	fn tsTracing_getIndirectOffset(this: *const c_void) -> usize;
	fn tsTracing_addVertexBuffer(this: *mut c_void, num_vertices: u32, format: Format, stride: usize, buffer: *mut c_void, offset: usize) -> u32;
	fn tsTracing_setVertexBuffer_uuBz(this: *mut c_void, index: u32, num_vertices: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setVertexBuffer_uBz(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setNumVertices(this: *mut c_void, index: u32, num_vertices: u32);
	fn tsTracing_getNumVertices(this: *const c_void, index: u32) -> u32;
	fn tsTracing_getVertexFormat(this: *const c_void, index: u32) -> Format;
	fn tsTracing_getVertexStride(this: *const c_void, index: u32) -> u32;
	fn tsTracing_getVertexBuffer(this: *const c_void, index: u32) -> *mut c_void;
	fn tsTracing_getVertexOffset(this: *const c_void, index: u32) -> usize;
	fn tsTracing_addIndexBuffer(this: *mut c_void, num_indices: u32, format: Format, buffer: *mut c_void, offset: usize) -> u32;
	fn tsTracing_setIndexBuffer_uuBz(this: *mut c_void, index: u32, num_indices: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setIndexBuffer_uBz(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setNumIndices(this: *mut c_void, index: u32, num_indices: u32);
	fn tsTracing_getNumIndices(this: *const c_void, index: u32) -> u32;
	fn tsTracing_getIndexFormat(this: *const c_void, index: u32) -> Format;
	fn tsTracing_getIndexBuffer(this: *const c_void, index: u32) -> *mut c_void;
	fn tsTracing_getIndexOffset(this: *const c_void, index: u32) -> usize;
	fn tsTracing_addBoundBuffer(this: *mut c_void, num_bounds: u32, stride: usize, buffer: *mut c_void, offset: usize) -> u32;
	fn tsTracing_setBoundBuffer_uuBz(this: *mut c_void, index: u32, num_bounds: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setBoundBuffer_uBz(this: *mut c_void, index: u32, buffer: *mut c_void, offset: usize);
	fn tsTracing_setNumBounds(this: *mut c_void, index: u32, num_bounds: u32);
	fn tsTracing_getNumBounds(this: *const c_void, index: u32) -> u32;
	fn tsTracing_getBoundStride(this: *const c_void, index: u32) -> u32;
	fn tsTracing_getBoundBuffer(this: *const c_void, index: u32) -> *mut c_void;
	fn tsTracing_getBoundOffset(this: *const c_void, index: u32) -> usize;
	fn tsTracing_getDescription(this: *const c_void) -> *mut c_void;
	fn tsTracing_getTracingAddress(this: *const c_void) -> u64;
	fn tsTracing_getBuildSize(this: *const c_void) -> usize;
	fn tsTracing_getUpdateSize(this: *const c_void) -> usize;
	fn tsTracing_getMemory(this: *const c_void) -> usize;
}
#[repr(C, align(16))]
#[derive(Copy, Clone)]
pub struct TracingInstance {
	pub transform: Matrix4x3f,
	pub data: u32,
	pub mask: u32,
	pub flags: u32,
	pub offset: u32,
	pub tracing: *mut c_void,
}
impl fmt::Display for TracingInstance {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("transform: {0}\n", self.transform);
		ret += &format!("data: {0}\n", self.data);
		ret += &format!("mask: {0}\n", self.mask);
		ret += &format!("flags: {0}\n", self.flags);
		ret += &format!("offset: {0}\n", self.offset);
		ret += &format!("tracing: {0}", self.tracing as u64);
		write!(f, "{0}", ret)
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TracingBuildIndirect {
	pub num_primitives: u32,
	pub base_primitive: u32,
	pub base_vertex: u32,
	pub base_transform: u32,
}
impl fmt::Display for TracingBuildIndirect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("num_primitives: {0}\n", self.num_primitives);
		ret += &format!("base_primitive: {0}\n", self.base_primitive);
		ret += &format!("base_vertex: {0}\n", self.base_vertex);
		ret += &format!("base_transform: {0}", self.base_transform);
		write!(f, "{0}", ret)
	}
}

// Tellusim::D3D12Tracing
pub struct D3D12Tracing {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Tracing {
	pub fn null() -> D3D12Tracing { D3D12Tracing { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Tracing { unsafe { D3D12Tracing { this: tsD3D12Tracing_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Tracing { unsafe { D3D12Tracing { this: ptr, owner: tsD3D12Tracing_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Tracing { unsafe { D3D12Tracing { this: tsD3D12Tracing_copyPtr(self.this), owner: true } } }
	pub fn from_tracing(ptr: &Tracing) -> D3D12Tracing { unsafe { D3D12Tracing::new_ptr(tsD3D12Tracing_castTracingPtr(ptr.this)) } }
	pub fn to_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsD3D12Tracing_baseTracingPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Tracing) -> bool { unsafe { tsD3D12Tracing_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Tracing { unsafe { D3D12Tracing { this: tsD3D12Tracing_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Tracing_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Tracing_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Tracing_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Tracing_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Tracing_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Tracing_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Tracing_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Tracing_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Tracing_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn geometry_desc(&self, index: u32) -> *mut c_void { unsafe { tsD3D12Tracing_getGeometryDesc(self.this, index) } }
	pub fn build_inputs(&self) -> *mut c_void { unsafe { tsD3D12Tracing_getBuildInputs(self.this) } }
	pub fn prebuild_info(&self) -> *mut c_void { unsafe { tsD3D12Tracing_getPrebuildInfo(self.this) } }
	pub fn build_desc(&self) -> *mut c_void { unsafe { tsD3D12Tracing_getBuildDesc(self.this) } }
	pub fn tracing_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsD3D12Tracing_getTracingBuffer(self.this)) } }
	pub fn shader_resource_view(&self) -> usize { unsafe { tsD3D12Tracing_getShaderResourceView(self.this) } }
}
impl TracingTrait for D3D12Tracing {
	fn platform(&self) -> Platform { unsafe { tsTracing_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTracing_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTracing_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTracing_isCreated(self.this) != 0 } }
	fn is_built(&self) -> bool { unsafe { tsTracing_isBuilt(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTracing_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTracing_getName(self.this)) } }
	fn create(&mut self, type_: TracingType) -> bool { unsafe { tsTracing_create(self.this, type_, TracingFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TracingType, flags: TracingFlags) -> bool { unsafe { tsTracing_create(self.this, type_, flags) != 0 } }
	fn type_(&self) -> TracingType { unsafe { tsTracing_getType(self.this) } }
	fn type_name_with_type(type_: TracingType) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_c(self.this)) } }
	fn is_instance_type(&self) -> bool { unsafe { tsTracing_isInstanceType(self.this) != 0 } }
	fn is_triangle_type(&self) -> bool { unsafe { tsTracing_isTriangleType(self.this) != 0 } }
	fn is_bound_type(&self) -> bool { unsafe { tsTracing_isBoundType(self.this) != 0 } }
	fn is_geometry_type(&self) -> bool { unsafe { tsTracing_isGeometryType(self.this) != 0 } }
	fn set_parameters(&mut self, tracing: &Tracing) { unsafe { tsTracing_setParameters(self.this, tracing.this) } }
	fn num_geometries(&self) -> u32 { unsafe { tsTracing_getNumGeometries(self.this) } }
	fn set_instance_buffer_with_instances(&mut self, num_instances: u32, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, 0) } }
	fn set_instance_buffer_with_instances_offset(&mut self, num_instances: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, offset) } }
	fn set_instance_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, 0) } }
	fn set_instance_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, offset) } }
	fn set_num_instances(&mut self, num_instances: u32) { unsafe { tsTracing_setNumInstances(self.this, num_instances) } }
	fn num_instances(&self) -> u32 { unsafe { tsTracing_getNumInstances(self.this) } }
	fn instance_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getInstanceBuffer(self.this)) } }
	fn instance_offset(&self) -> usize { unsafe { tsTracing_getInstanceOffset(self.this) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn indirect_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndirectBuffer(self.this)) } }
	fn indirect_offset(&self) -> usize { unsafe { tsTracing_getIndirectOffset(self.this) } }
	fn add_vertex_buffer(&mut self, num_vertices: u32, format: Format, stride: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, ptr::null_mut(), 0) } }
	fn add_vertex_buffer_with_buffer(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, 0) } }
	fn add_vertex_buffer_with_buffer_offset(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, offset) } }
	fn set_vertex_buffer_with_vertices(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, 0) } }
	fn set_vertex_buffer_with_vertices_offset(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, offset) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_vertices(&mut self, index: u32, num_vertices: u32) { unsafe { tsTracing_setNumVertices(self.this, index, num_vertices) } }
	fn num_vertices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumVertices(self.this, index) } }
	fn vertex_format(&self, index: u32) -> Format { unsafe { tsTracing_getVertexFormat(self.this, index) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getVertexStride(self.this, index) } }
	fn vertex_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getVertexBuffer(self.this, index)) } }
	fn vertex_offset(&self, index: u32) -> usize { unsafe { tsTracing_getVertexOffset(self.this, index) } }
	fn add_index_buffer(&mut self, num_indices: u32, format: Format) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, ptr::null_mut(), 0) } }
	fn add_index_buffer_with_buffer(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, 0) } }
	fn add_index_buffer_with_buffer_offset(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, offset) } }
	fn set_index_buffer_with_indices(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, 0) } }
	fn set_index_buffer_with_indices_offset(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, offset) } }
	fn set_index_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_indices(&mut self, index: u32, num_indices: u32) { unsafe { tsTracing_setNumIndices(self.this, index, num_indices) } }
	fn num_indices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumIndices(self.this, index) } }
	fn index_format(&self, index: u32) -> Format { unsafe { tsTracing_getIndexFormat(self.this, index) } }
	fn index_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndexBuffer(self.this, index)) } }
	fn index_offset(&self, index: u32) -> usize { unsafe { tsTracing_getIndexOffset(self.this, index) } }
	fn add_bound_buffer(&mut self, num_bounds: u32, stride: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, ptr::null_mut(), 0) } }
	fn add_bound_buffer_with_buffer(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, 0) } }
	fn add_bound_buffer_with_buffer_offset(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, offset) } }
	fn set_bound_buffer_with_bounds(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, 0) } }
	fn set_bound_buffer_with_bounds_offset(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, offset) } }
	fn set_bound_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_bound_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_bounds(&mut self, index: u32, num_bounds: u32) { unsafe { tsTracing_setNumBounds(self.this, index, num_bounds) } }
	fn num_bounds(&self, index: u32) -> u32 { unsafe { tsTracing_getNumBounds(self.this, index) } }
	fn bound_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getBoundStride(self.this, index) } }
	fn bound_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getBoundBuffer(self.this, index)) } }
	fn bound_offset(&self, index: u32) -> usize { unsafe { tsTracing_getBoundOffset(self.this, index) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTracing_getDescription(self.this)) } }
	fn tracing_address(&self) -> u64 { unsafe { tsTracing_getTracingAddress(self.this) } }
	fn build_size(&self) -> usize { unsafe { tsTracing_getBuildSize(self.this) } }
	fn update_size(&self) -> usize { unsafe { tsTracing_getUpdateSize(self.this) } }
	fn memory(&self) -> usize { unsafe { tsTracing_getMemory(self.this) } }
}
impl Drop for D3D12Tracing {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Tracing_delete(self.this) } } }
}
impl Clone for D3D12Tracing {
	fn clone(&self) -> D3D12Tracing { unsafe { D3D12Tracing { this: tsD3D12Tracing_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Tracing { }
impl fmt::Display for D3D12Tracing {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Tracing ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Tracing_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Tracing_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Tracing_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Tracing_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Tracing_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Tracing_new() -> *mut c_void;
	fn tsD3D12Tracing_delete(this: *mut c_void);
	fn tsD3D12Tracing_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Tracing_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_clearPtr(this: *const c_void);
	fn tsD3D12Tracing_destroyPtr(this: *const c_void);
	fn tsD3D12Tracing_acquirePtr(this: *const c_void);
	fn tsD3D12Tracing_unacquirePtr(this: *const c_void);
	fn tsD3D12Tracing_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Tracing_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Tracing_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Tracing_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Tracing_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_equalTracingPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Tracing_castTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_baseTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_getGeometryDesc(this: *const c_void, index: u32) -> *mut c_void;
	fn tsD3D12Tracing_getBuildInputs(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_getPrebuildInfo(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_getBuildDesc(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_getTracingBuffer(this: *const c_void) -> *mut c_void;
	fn tsD3D12Tracing_getShaderResourceView(this: *const c_void) -> usize;
}

// Tellusim::MTLTracing
pub struct MTLTracing {
	this: *mut c_void,
	owner: bool,
}
impl MTLTracing {
	pub fn null() -> MTLTracing { MTLTracing { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLTracing { unsafe { MTLTracing { this: tsMTLTracing_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLTracing { unsafe { MTLTracing { this: ptr, owner: tsMTLTracing_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLTracing { unsafe { MTLTracing { this: tsMTLTracing_copyPtr(self.this), owner: true } } }
	pub fn from_tracing(ptr: &Tracing) -> MTLTracing { unsafe { MTLTracing::new_ptr(tsMTLTracing_castTracingPtr(ptr.this)) } }
	pub fn to_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsMTLTracing_baseTracingPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLTracing) -> bool { unsafe { tsMTLTracing_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLTracing { unsafe { MTLTracing { this: tsMTLTracing_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLTracing_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLTracing_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLTracing_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLTracing_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLTracing_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLTracing_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLTracing_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLTracing_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLTracing_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn geometry_desc(&self, index: u32) -> *mut c_void { unsafe { tsMTLTracing_getGeometryDesc(self.this, index) } }
	pub fn primitive_desc(&self) -> *mut c_void { unsafe { tsMTLTracing_getPrimitiveDesc(self.this) } }
	pub fn instance_desc(&self) -> *mut c_void { unsafe { tsMTLTracing_getInstanceDesc(self.this) } }
	pub fn acceleration_structure(&self) -> *mut c_void { unsafe { tsMTLTracing_getAccelerationStructure(self.this) } }
}
impl TracingTrait for MTLTracing {
	fn platform(&self) -> Platform { unsafe { tsTracing_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTracing_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTracing_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTracing_isCreated(self.this) != 0 } }
	fn is_built(&self) -> bool { unsafe { tsTracing_isBuilt(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTracing_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTracing_getName(self.this)) } }
	fn create(&mut self, type_: TracingType) -> bool { unsafe { tsTracing_create(self.this, type_, TracingFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TracingType, flags: TracingFlags) -> bool { unsafe { tsTracing_create(self.this, type_, flags) != 0 } }
	fn type_(&self) -> TracingType { unsafe { tsTracing_getType(self.this) } }
	fn type_name_with_type(type_: TracingType) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_c(self.this)) } }
	fn is_instance_type(&self) -> bool { unsafe { tsTracing_isInstanceType(self.this) != 0 } }
	fn is_triangle_type(&self) -> bool { unsafe { tsTracing_isTriangleType(self.this) != 0 } }
	fn is_bound_type(&self) -> bool { unsafe { tsTracing_isBoundType(self.this) != 0 } }
	fn is_geometry_type(&self) -> bool { unsafe { tsTracing_isGeometryType(self.this) != 0 } }
	fn set_parameters(&mut self, tracing: &Tracing) { unsafe { tsTracing_setParameters(self.this, tracing.this) } }
	fn num_geometries(&self) -> u32 { unsafe { tsTracing_getNumGeometries(self.this) } }
	fn set_instance_buffer_with_instances(&mut self, num_instances: u32, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, 0) } }
	fn set_instance_buffer_with_instances_offset(&mut self, num_instances: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, offset) } }
	fn set_instance_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, 0) } }
	fn set_instance_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, offset) } }
	fn set_num_instances(&mut self, num_instances: u32) { unsafe { tsTracing_setNumInstances(self.this, num_instances) } }
	fn num_instances(&self) -> u32 { unsafe { tsTracing_getNumInstances(self.this) } }
	fn instance_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getInstanceBuffer(self.this)) } }
	fn instance_offset(&self) -> usize { unsafe { tsTracing_getInstanceOffset(self.this) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn indirect_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndirectBuffer(self.this)) } }
	fn indirect_offset(&self) -> usize { unsafe { tsTracing_getIndirectOffset(self.this) } }
	fn add_vertex_buffer(&mut self, num_vertices: u32, format: Format, stride: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, ptr::null_mut(), 0) } }
	fn add_vertex_buffer_with_buffer(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, 0) } }
	fn add_vertex_buffer_with_buffer_offset(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, offset) } }
	fn set_vertex_buffer_with_vertices(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, 0) } }
	fn set_vertex_buffer_with_vertices_offset(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, offset) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_vertices(&mut self, index: u32, num_vertices: u32) { unsafe { tsTracing_setNumVertices(self.this, index, num_vertices) } }
	fn num_vertices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumVertices(self.this, index) } }
	fn vertex_format(&self, index: u32) -> Format { unsafe { tsTracing_getVertexFormat(self.this, index) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getVertexStride(self.this, index) } }
	fn vertex_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getVertexBuffer(self.this, index)) } }
	fn vertex_offset(&self, index: u32) -> usize { unsafe { tsTracing_getVertexOffset(self.this, index) } }
	fn add_index_buffer(&mut self, num_indices: u32, format: Format) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, ptr::null_mut(), 0) } }
	fn add_index_buffer_with_buffer(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, 0) } }
	fn add_index_buffer_with_buffer_offset(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, offset) } }
	fn set_index_buffer_with_indices(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, 0) } }
	fn set_index_buffer_with_indices_offset(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, offset) } }
	fn set_index_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_indices(&mut self, index: u32, num_indices: u32) { unsafe { tsTracing_setNumIndices(self.this, index, num_indices) } }
	fn num_indices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumIndices(self.this, index) } }
	fn index_format(&self, index: u32) -> Format { unsafe { tsTracing_getIndexFormat(self.this, index) } }
	fn index_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndexBuffer(self.this, index)) } }
	fn index_offset(&self, index: u32) -> usize { unsafe { tsTracing_getIndexOffset(self.this, index) } }
	fn add_bound_buffer(&mut self, num_bounds: u32, stride: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, ptr::null_mut(), 0) } }
	fn add_bound_buffer_with_buffer(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, 0) } }
	fn add_bound_buffer_with_buffer_offset(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, offset) } }
	fn set_bound_buffer_with_bounds(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, 0) } }
	fn set_bound_buffer_with_bounds_offset(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, offset) } }
	fn set_bound_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_bound_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_bounds(&mut self, index: u32, num_bounds: u32) { unsafe { tsTracing_setNumBounds(self.this, index, num_bounds) } }
	fn num_bounds(&self, index: u32) -> u32 { unsafe { tsTracing_getNumBounds(self.this, index) } }
	fn bound_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getBoundStride(self.this, index) } }
	fn bound_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getBoundBuffer(self.this, index)) } }
	fn bound_offset(&self, index: u32) -> usize { unsafe { tsTracing_getBoundOffset(self.this, index) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTracing_getDescription(self.this)) } }
	fn tracing_address(&self) -> u64 { unsafe { tsTracing_getTracingAddress(self.this) } }
	fn build_size(&self) -> usize { unsafe { tsTracing_getBuildSize(self.this) } }
	fn update_size(&self) -> usize { unsafe { tsTracing_getUpdateSize(self.this) } }
	fn memory(&self) -> usize { unsafe { tsTracing_getMemory(self.this) } }
}
impl Drop for MTLTracing {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLTracing_delete(self.this) } } }
}
impl Clone for MTLTracing {
	fn clone(&self) -> MTLTracing { unsafe { MTLTracing { this: tsMTLTracing_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLTracing { }
impl fmt::Display for MTLTracing {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLTracing ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLTracing_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLTracing_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLTracing_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLTracing_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLTracing_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLTracing_new() -> *mut c_void;
	fn tsMTLTracing_delete(this: *mut c_void);
	fn tsMTLTracing_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLTracing_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_clearPtr(this: *const c_void);
	fn tsMTLTracing_destroyPtr(this: *const c_void);
	fn tsMTLTracing_acquirePtr(this: *const c_void);
	fn tsMTLTracing_unacquirePtr(this: *const c_void);
	fn tsMTLTracing_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLTracing_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLTracing_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLTracing_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLTracing_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_equalTracingPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLTracing_castTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_baseTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_getGeometryDesc(this: *const c_void, index: u32) -> *mut c_void;
	fn tsMTLTracing_getPrimitiveDesc(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_getInstanceDesc(this: *const c_void) -> *mut c_void;
	fn tsMTLTracing_getAccelerationStructure(this: *const c_void) -> *mut c_void;
}

// Tellusim::VKTracing
pub struct VKTracing {
	this: *mut c_void,
	owner: bool,
}
impl VKTracing {
	pub fn null() -> VKTracing { VKTracing { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKTracing { unsafe { VKTracing { this: tsVKTracing_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKTracing { unsafe { VKTracing { this: ptr, owner: tsVKTracing_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKTracing { unsafe { VKTracing { this: tsVKTracing_copyPtr(self.this), owner: true } } }
	pub fn from_tracing(ptr: &Tracing) -> VKTracing { unsafe { VKTracing::new_ptr(tsVKTracing_castTracingPtr(ptr.this)) } }
	pub fn to_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsVKTracing_baseTracingPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKTracing) -> bool { unsafe { tsVKTracing_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKTracing { unsafe { VKTracing { this: tsVKTracing_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKTracing_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKTracing_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKTracing_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKTracing_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKTracing_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKTracing_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKTracing_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKTracing_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKTracing_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn build_geometry_info(&self) -> *mut c_void { unsafe { tsVKTracing_getBuildGeometryInfo(self.this) } }
	pub fn build_size_info(&self) -> *mut c_void { unsafe { tsVKTracing_getBuildSizeInfo(self.this) } }
	pub fn tracing_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsVKTracing_getTracingBuffer(self.this)) } }
	pub fn acceleration_structure(&self) -> *const c_void { unsafe { tsVKTracing_getAccelerationStructure(self.this) } }
}
impl TracingTrait for VKTracing {
	fn platform(&self) -> Platform { unsafe { tsTracing_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTracing_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTracing_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTracing_isCreated(self.this) != 0 } }
	fn is_built(&self) -> bool { unsafe { tsTracing_isBuilt(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTracing_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTracing_getName(self.this)) } }
	fn create(&mut self, type_: TracingType) -> bool { unsafe { tsTracing_create(self.this, type_, TracingFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TracingType, flags: TracingFlags) -> bool { unsafe { tsTracing_create(self.this, type_, flags) != 0 } }
	fn type_(&self) -> TracingType { unsafe { tsTracing_getType(self.this) } }
	fn type_name_with_type(type_: TracingType) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_c(self.this)) } }
	fn is_instance_type(&self) -> bool { unsafe { tsTracing_isInstanceType(self.this) != 0 } }
	fn is_triangle_type(&self) -> bool { unsafe { tsTracing_isTriangleType(self.this) != 0 } }
	fn is_bound_type(&self) -> bool { unsafe { tsTracing_isBoundType(self.this) != 0 } }
	fn is_geometry_type(&self) -> bool { unsafe { tsTracing_isGeometryType(self.this) != 0 } }
	fn set_parameters(&mut self, tracing: &Tracing) { unsafe { tsTracing_setParameters(self.this, tracing.this) } }
	fn num_geometries(&self) -> u32 { unsafe { tsTracing_getNumGeometries(self.this) } }
	fn set_instance_buffer_with_instances(&mut self, num_instances: u32, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, 0) } }
	fn set_instance_buffer_with_instances_offset(&mut self, num_instances: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, offset) } }
	fn set_instance_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, 0) } }
	fn set_instance_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, offset) } }
	fn set_num_instances(&mut self, num_instances: u32) { unsafe { tsTracing_setNumInstances(self.this, num_instances) } }
	fn num_instances(&self) -> u32 { unsafe { tsTracing_getNumInstances(self.this) } }
	fn instance_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getInstanceBuffer(self.this)) } }
	fn instance_offset(&self) -> usize { unsafe { tsTracing_getInstanceOffset(self.this) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn indirect_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndirectBuffer(self.this)) } }
	fn indirect_offset(&self) -> usize { unsafe { tsTracing_getIndirectOffset(self.this) } }
	fn add_vertex_buffer(&mut self, num_vertices: u32, format: Format, stride: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, ptr::null_mut(), 0) } }
	fn add_vertex_buffer_with_buffer(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, 0) } }
	fn add_vertex_buffer_with_buffer_offset(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, offset) } }
	fn set_vertex_buffer_with_vertices(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, 0) } }
	fn set_vertex_buffer_with_vertices_offset(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, offset) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_vertices(&mut self, index: u32, num_vertices: u32) { unsafe { tsTracing_setNumVertices(self.this, index, num_vertices) } }
	fn num_vertices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumVertices(self.this, index) } }
	fn vertex_format(&self, index: u32) -> Format { unsafe { tsTracing_getVertexFormat(self.this, index) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getVertexStride(self.this, index) } }
	fn vertex_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getVertexBuffer(self.this, index)) } }
	fn vertex_offset(&self, index: u32) -> usize { unsafe { tsTracing_getVertexOffset(self.this, index) } }
	fn add_index_buffer(&mut self, num_indices: u32, format: Format) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, ptr::null_mut(), 0) } }
	fn add_index_buffer_with_buffer(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, 0) } }
	fn add_index_buffer_with_buffer_offset(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, offset) } }
	fn set_index_buffer_with_indices(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, 0) } }
	fn set_index_buffer_with_indices_offset(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, offset) } }
	fn set_index_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_indices(&mut self, index: u32, num_indices: u32) { unsafe { tsTracing_setNumIndices(self.this, index, num_indices) } }
	fn num_indices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumIndices(self.this, index) } }
	fn index_format(&self, index: u32) -> Format { unsafe { tsTracing_getIndexFormat(self.this, index) } }
	fn index_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndexBuffer(self.this, index)) } }
	fn index_offset(&self, index: u32) -> usize { unsafe { tsTracing_getIndexOffset(self.this, index) } }
	fn add_bound_buffer(&mut self, num_bounds: u32, stride: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, ptr::null_mut(), 0) } }
	fn add_bound_buffer_with_buffer(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, 0) } }
	fn add_bound_buffer_with_buffer_offset(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, offset) } }
	fn set_bound_buffer_with_bounds(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, 0) } }
	fn set_bound_buffer_with_bounds_offset(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, offset) } }
	fn set_bound_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_bound_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_bounds(&mut self, index: u32, num_bounds: u32) { unsafe { tsTracing_setNumBounds(self.this, index, num_bounds) } }
	fn num_bounds(&self, index: u32) -> u32 { unsafe { tsTracing_getNumBounds(self.this, index) } }
	fn bound_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getBoundStride(self.this, index) } }
	fn bound_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getBoundBuffer(self.this, index)) } }
	fn bound_offset(&self, index: u32) -> usize { unsafe { tsTracing_getBoundOffset(self.this, index) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTracing_getDescription(self.this)) } }
	fn tracing_address(&self) -> u64 { unsafe { tsTracing_getTracingAddress(self.this) } }
	fn build_size(&self) -> usize { unsafe { tsTracing_getBuildSize(self.this) } }
	fn update_size(&self) -> usize { unsafe { tsTracing_getUpdateSize(self.this) } }
	fn memory(&self) -> usize { unsafe { tsTracing_getMemory(self.this) } }
}
impl Drop for VKTracing {
	fn drop(&mut self) { if self.owner { unsafe { tsVKTracing_delete(self.this) } } }
}
impl Clone for VKTracing {
	fn clone(&self) -> VKTracing { unsafe { VKTracing { this: tsVKTracing_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKTracing { }
impl fmt::Display for VKTracing {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKTracing ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKTracing_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKTracing_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKTracing_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKTracing_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKTracing_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKTracing_new() -> *mut c_void;
	fn tsVKTracing_delete(this: *mut c_void);
	fn tsVKTracing_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKTracing_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_clearPtr(this: *const c_void);
	fn tsVKTracing_destroyPtr(this: *const c_void);
	fn tsVKTracing_acquirePtr(this: *const c_void);
	fn tsVKTracing_unacquirePtr(this: *const c_void);
	fn tsVKTracing_isValidPtr(this: *const c_void) -> i32;
	fn tsVKTracing_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKTracing_isConstPtr(this: *const c_void) -> i32;
	fn tsVKTracing_getCountPtr(this: *const c_void) -> u32;
	fn tsVKTracing_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_equalTracingPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKTracing_castTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_baseTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_getBuildGeometryInfo(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_getBuildSizeInfo(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_getTracingBuffer(this: *const c_void) -> *mut c_void;
	fn tsVKTracing_getAccelerationStructure(this: *const c_void) -> *const c_void;
}

// Tellusim::FUTracing
pub struct FUTracing {
	this: *mut c_void,
	owner: bool,
}
impl FUTracing {
	pub fn null() -> FUTracing { FUTracing { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUTracing { unsafe { FUTracing { this: tsFUTracing_new(), owner: true } } }
	pub fn new_with_tracings(tracings: &[&mut Tracing]) -> FUTracing {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { FUTracing { this: tsFUTracing_new_cATb(tracings_.as_ptr(), tracings.len() as u32, 0), owner: true } }
	}
	pub fn new_with_tracings_owner(tracings: &[&mut Tracing], owner: bool) -> FUTracing {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { FUTracing { this: tsFUTracing_new_cATb(tracings_.as_ptr(), tracings.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUTracing { unsafe { FUTracing { this: ptr, owner: tsFUTracing_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUTracing { unsafe { FUTracing { this: tsFUTracing_copyPtr(self.this), owner: true } } }
	pub fn from_tracing(ptr: &Tracing) -> FUTracing { unsafe { FUTracing::new_ptr(tsFUTracing_castTracingPtr(ptr.this)) } }
	pub fn to_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsFUTracing_baseTracingPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUTracing) -> bool { unsafe { tsFUTracing_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUTracing { unsafe { FUTracing { this: tsFUTracing_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUTracing_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUTracing_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUTracing_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUTracing_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUTracing_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUTracing_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUTracing_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUTracing_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUTracing_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUTracing_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUTracing_getMask(self.this) } }
	pub fn num_tracings(&self) -> u32 { unsafe { tsFUTracing_getNumTracings(self.this) } }
	pub fn tracing(&self, index: u32) -> Tracing { unsafe { Tracing::new_ptr(tsFUTracing_getTracing_cu(self.this, index)) } }
	pub fn tracing_mut(&mut self, index: u32) -> Tracing { unsafe { Tracing::new_ptr(tsFUTracing_getTracing_u(self.this, index)) } }
}
impl TracingTrait for FUTracing {
	fn platform(&self) -> Platform { unsafe { tsTracing_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTracing_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTracing_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTracing_isCreated(self.this) != 0 } }
	fn is_built(&self) -> bool { unsafe { tsTracing_isBuilt(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTracing_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTracing_getName(self.this)) } }
	fn create(&mut self, type_: TracingType) -> bool { unsafe { tsTracing_create(self.this, type_, TracingFlags::None) != 0 } }
	fn create_with_flags(&mut self, type_: TracingType, flags: TracingFlags) -> bool { unsafe { tsTracing_create(self.this, type_, flags) != 0 } }
	fn type_(&self) -> TracingType { unsafe { tsTracing_getType(self.this) } }
	fn type_name_with_type(type_: TracingType) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_TT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsTracing_getTypeName_c(self.this)) } }
	fn is_instance_type(&self) -> bool { unsafe { tsTracing_isInstanceType(self.this) != 0 } }
	fn is_triangle_type(&self) -> bool { unsafe { tsTracing_isTriangleType(self.this) != 0 } }
	fn is_bound_type(&self) -> bool { unsafe { tsTracing_isBoundType(self.this) != 0 } }
	fn is_geometry_type(&self) -> bool { unsafe { tsTracing_isGeometryType(self.this) != 0 } }
	fn set_parameters(&mut self, tracing: &Tracing) { unsafe { tsTracing_setParameters(self.this, tracing.this) } }
	fn num_geometries(&self) -> u32 { unsafe { tsTracing_getNumGeometries(self.this) } }
	fn set_instance_buffer_with_instances(&mut self, num_instances: u32, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, 0) } }
	fn set_instance_buffer_with_instances_offset(&mut self, num_instances: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_uBz(self.this, num_instances, buffer.this, offset) } }
	fn set_instance_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, 0) } }
	fn set_instance_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setInstanceBuffer_Bz(self.this, buffer.this, offset) } }
	fn set_num_instances(&mut self, num_instances: u32) { unsafe { tsTracing_setNumInstances(self.this, num_instances) } }
	fn num_instances(&self) -> u32 { unsafe { tsTracing_getNumInstances(self.this) } }
	fn instance_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getInstanceBuffer(self.this)) } }
	fn instance_offset(&self) -> usize { unsafe { tsTracing_getInstanceOffset(self.this) } }
	fn set_indirect_buffer(&mut self, buffer: &mut Buffer) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, 0) } }
	fn set_indirect_buffer_with_offset(&mut self, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndirectBuffer(self.this, buffer.this, offset) } }
	fn indirect_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndirectBuffer(self.this)) } }
	fn indirect_offset(&self) -> usize { unsafe { tsTracing_getIndirectOffset(self.this) } }
	fn add_vertex_buffer(&mut self, num_vertices: u32, format: Format, stride: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, ptr::null_mut(), 0) } }
	fn add_vertex_buffer_with_buffer(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, 0) } }
	fn add_vertex_buffer_with_buffer_offset(&mut self, num_vertices: u32, format: Format, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addVertexBuffer(self.this, num_vertices, format, stride, buffer.this, offset) } }
	fn set_vertex_buffer_with_vertices(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, 0) } }
	fn set_vertex_buffer_with_vertices_offset(&mut self, index: u32, num_vertices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uuBz(self.this, index, num_vertices, buffer.this, offset) } }
	fn set_vertex_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_vertex_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setVertexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_vertices(&mut self, index: u32, num_vertices: u32) { unsafe { tsTracing_setNumVertices(self.this, index, num_vertices) } }
	fn num_vertices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumVertices(self.this, index) } }
	fn vertex_format(&self, index: u32) -> Format { unsafe { tsTracing_getVertexFormat(self.this, index) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getVertexStride(self.this, index) } }
	fn vertex_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getVertexBuffer(self.this, index)) } }
	fn vertex_offset(&self, index: u32) -> usize { unsafe { tsTracing_getVertexOffset(self.this, index) } }
	fn add_index_buffer(&mut self, num_indices: u32, format: Format) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, ptr::null_mut(), 0) } }
	fn add_index_buffer_with_buffer(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, 0) } }
	fn add_index_buffer_with_buffer_offset(&mut self, num_indices: u32, format: Format, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addIndexBuffer(self.this, num_indices, format, buffer.this, offset) } }
	fn set_index_buffer_with_indices(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, 0) } }
	fn set_index_buffer_with_indices_offset(&mut self, index: u32, num_indices: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uuBz(self.this, index, num_indices, buffer.this, offset) } }
	fn set_index_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_index_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setIndexBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_indices(&mut self, index: u32, num_indices: u32) { unsafe { tsTracing_setNumIndices(self.this, index, num_indices) } }
	fn num_indices(&self, index: u32) -> u32 { unsafe { tsTracing_getNumIndices(self.this, index) } }
	fn index_format(&self, index: u32) -> Format { unsafe { tsTracing_getIndexFormat(self.this, index) } }
	fn index_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getIndexBuffer(self.this, index)) } }
	fn index_offset(&self, index: u32) -> usize { unsafe { tsTracing_getIndexOffset(self.this, index) } }
	fn add_bound_buffer(&mut self, num_bounds: u32, stride: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, ptr::null_mut(), 0) } }
	fn add_bound_buffer_with_buffer(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, 0) } }
	fn add_bound_buffer_with_buffer_offset(&mut self, num_bounds: u32, stride: usize, buffer: &mut Buffer, offset: usize) -> u32 { unsafe { tsTracing_addBoundBuffer(self.this, num_bounds, stride, buffer.this, offset) } }
	fn set_bound_buffer_with_bounds(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, 0) } }
	fn set_bound_buffer_with_bounds_offset(&mut self, index: u32, num_bounds: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uuBz(self.this, index, num_bounds, buffer.this, offset) } }
	fn set_bound_buffer(&mut self, index: u32, buffer: &mut Buffer) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, 0) } }
	fn set_bound_buffer_with_offset(&mut self, index: u32, buffer: &mut Buffer, offset: usize) { unsafe { tsTracing_setBoundBuffer_uBz(self.this, index, buffer.this, offset) } }
	fn set_num_bounds(&mut self, index: u32, num_bounds: u32) { unsafe { tsTracing_setNumBounds(self.this, index, num_bounds) } }
	fn num_bounds(&self, index: u32) -> u32 { unsafe { tsTracing_getNumBounds(self.this, index) } }
	fn bound_stride(&self, index: u32) -> u32 { unsafe { tsTracing_getBoundStride(self.this, index) } }
	fn bound_buffer(&self, index: u32) -> Buffer { unsafe { Buffer::new_ptr(tsTracing_getBoundBuffer(self.this, index)) } }
	fn bound_offset(&self, index: u32) -> usize { unsafe { tsTracing_getBoundOffset(self.this, index) } }
	fn description(&self) -> string::String { unsafe { get_string(tsTracing_getDescription(self.this)) } }
	fn tracing_address(&self) -> u64 { unsafe { tsTracing_getTracingAddress(self.this) } }
	fn build_size(&self) -> usize { unsafe { tsTracing_getBuildSize(self.this) } }
	fn update_size(&self) -> usize { unsafe { tsTracing_getUpdateSize(self.this) } }
	fn memory(&self) -> usize { unsafe { tsTracing_getMemory(self.this) } }
}
impl Drop for FUTracing {
	fn drop(&mut self) { if self.owner { unsafe { tsFUTracing_delete(self.this) } } }
}
impl Clone for FUTracing {
	fn clone(&self) -> FUTracing { unsafe { FUTracing { this: tsFUTracing_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUTracing { }
impl fmt::Display for FUTracing {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUTracing ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUTracing_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUTracing_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUTracing_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUTracing_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUTracing_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUTracing_new() -> *mut c_void;
	fn tsFUTracing_new_cATb(tracings: *const *mut c_void, tracings_size: u32, owner: i32) -> *mut c_void;
	fn tsFUTracing_delete(this: *mut c_void);
	fn tsFUTracing_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTracing_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTracing_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUTracing_clearPtr(this: *const c_void);
	fn tsFUTracing_destroyPtr(this: *const c_void);
	fn tsFUTracing_acquirePtr(this: *const c_void);
	fn tsFUTracing_unacquirePtr(this: *const c_void);
	fn tsFUTracing_isValidPtr(this: *const c_void) -> i32;
	fn tsFUTracing_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUTracing_isConstPtr(this: *const c_void) -> i32;
	fn tsFUTracing_getCountPtr(this: *const c_void) -> u32;
	fn tsFUTracing_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTracing_equalTracingPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTracing_castTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTracing_baseTracingPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTracing_setMask(this: *mut c_void, mask: u32);
	fn tsFUTracing_getMask(this: *const c_void) -> u32;
	fn tsFUTracing_getNumTracings(this: *const c_void) -> u32;
	fn tsFUTracing_getTracing_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUTracing_getTracing_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Target
pub struct Target {
	this: *mut c_void,
	owner: bool,
}
impl Target {
	pub fn null() -> Target { Target { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Target { unsafe { Target { this: tsTarget_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Target { unsafe { Target { this: ptr, owner: tsTarget_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Target { unsafe { Target { this: tsTarget_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Target) -> bool { unsafe { tsTarget_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Target { unsafe { Target { this: tsTarget_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsTarget_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsTarget_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsTarget_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsTarget_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsTarget_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsTarget_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsTarget_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsTarget_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsTarget_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait TargetTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool;
	fn begin(&mut self) -> bool;
	fn end_with_fence(&mut self, fence: &mut Fence);
	fn end(&mut self);
	fn swap(&mut self, surface: &mut Surface);
	fn is_enabled(&self) -> bool;
	fn color_format(&self) -> Format;
	fn color_format_with_index(&self, index: u32) -> Format;
	fn depth_format(&self) -> Format;
	fn multisample(&self) -> u32;
	fn has_multisample(&self) -> bool;
	fn is_flipped(&self) -> bool;
	fn is_atomic(&self) -> bool;
	fn width(&self) -> u32;
	fn height(&self) -> u32;
	fn depth(&self) -> u32;
	fn faces(&self) -> u32;
	fn layers(&self) -> u32;
	fn mipmaps(&self) -> u32;
	fn set_clear_color_with_color(&mut self, color: &Color);
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color);
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32);
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32);
	fn set_color_texture(&mut self, texture: &mut Texture);
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation);
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>);
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture);
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation);
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>);
	fn set_color_resolve(&mut self, texture: &mut Texture);
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>);
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture);
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>);
	fn num_targets(&self) -> u32;
	fn clear_color(&self) -> Color;
	fn clear_color_with_index(&self, index: u32) -> Color;
	fn color_op(&self) -> TargetOperation;
	fn color_op_with_index(&self, index: u32) -> TargetOperation;
	fn color_texture(&self, index: u32) -> Texture;
	fn color_resolve(&self, index: u32) -> Texture;
	fn color_texture_slice(&self, index: u32) -> Slice;
	fn color_resolve_slice(&self, index: u32) -> Slice;
	fn set_clear_depth(&mut self, depth: f32);
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32);
	fn set_depth_texture(&mut self, texture: &mut Texture);
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation);
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>);
	fn set_depth_resolve(&mut self, texture: &mut Texture);
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>);
	fn clear_depth(&self) -> f32;
	fn clear_stencil(&self) -> u32;
	fn depth_op(&self) -> TargetOperation;
	fn depth_texture(&self) -> Texture;
	fn depth_resolve(&self) -> Texture;
	fn depth_texture_slice(&self) -> Slice;
	fn depth_resolve_slice(&self) -> Slice;
}
impl TargetTrait for Target {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for Target {
	fn drop(&mut self) { if self.owner { unsafe { tsTarget_delete(self.this) } } }
}
impl Clone for Target {
	fn clone(&self) -> Target { unsafe { Target { this: tsTarget_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Target { }
impl fmt::Display for Target {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Target ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsTarget_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsTarget_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsTarget_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsTarget_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsTarget_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsTarget_new() -> *mut c_void;
	fn tsTarget_delete(this: *mut c_void);
	fn tsTarget_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsTarget_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsTarget_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsTarget_clearPtr(this: *const c_void);
	fn tsTarget_destroyPtr(this: *const c_void);
	fn tsTarget_acquirePtr(this: *const c_void);
	fn tsTarget_unacquirePtr(this: *const c_void);
	fn tsTarget_isValidPtr(this: *const c_void) -> i32;
	fn tsTarget_isOwnerPtr(this: *const c_void) -> i32;
	fn tsTarget_isConstPtr(this: *const c_void) -> i32;
	fn tsTarget_getCountPtr(this: *const c_void) -> u32;
	fn tsTarget_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsTarget_getPlatform(this: *const c_void) -> Platform;
	fn tsTarget_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsTarget_getIndex(this: *const c_void) -> u32;
	fn tsTarget_begin_F(this: *mut c_void, fence: *mut c_void) -> i32;
	fn tsTarget_begin(this: *mut c_void) -> i32;
	fn tsTarget_end_F(this: *mut c_void, fence: *mut c_void);
	fn tsTarget_end(this: *mut c_void);
	fn tsTarget_swap(this: *mut c_void, surface: *mut c_void);
	fn tsTarget_isEnabled(this: *const c_void) -> i32;
	fn tsTarget_getColorFormat(this: *const c_void, index: u32) -> Format;
	fn tsTarget_getDepthFormat(this: *const c_void) -> Format;
	fn tsTarget_getMultisample(this: *const c_void) -> u32;
	fn tsTarget_hasMultisample(this: *const c_void) -> i32;
	fn tsTarget_isFlipped(this: *const c_void) -> i32;
	fn tsTarget_isAtomic(this: *const c_void) -> i32;
	fn tsTarget_getWidth(this: *const c_void) -> u32;
	fn tsTarget_getHeight(this: *const c_void) -> u32;
	fn tsTarget_getDepth(this: *const c_void) -> u32;
	fn tsTarget_getFaces(this: *const c_void) -> u32;
	fn tsTarget_getLayers(this: *const c_void) -> u32;
	fn tsTarget_getMipmaps(this: *const c_void) -> u32;
	fn tsTarget_setClearColor_cC(this: *mut c_void, color: *const Color);
	fn tsTarget_setClearColor_ucC(this: *mut c_void, index: u32, color: *const Color);
	fn tsTarget_setClearColor_ffff(this: *mut c_void, r: f32, g: f32, b: f32, a: f32);
	fn tsTarget_setClearColor_uffff(this: *mut c_void, index: u32, r: f32, g: f32, b: f32, a: f32);
	fn tsTarget_setColorTexture_TTOcS(this: *mut c_void, texture: *mut c_void, op: TargetOperation, slice: *const Slice);
	fn tsTarget_setColorTexture_uTTOcS(this: *mut c_void, index: u32, texture: *mut c_void, op: TargetOperation, slice: *const Slice);
	fn tsTarget_setColorResolve_TcS(this: *mut c_void, texture: *mut c_void, slice: *const Slice);
	fn tsTarget_setColorResolve_uTcS(this: *mut c_void, index: u32, texture: *mut c_void, slice: *const Slice);
	fn tsTarget_getNumTargets(this: *const c_void) -> u32;
	fn tsTarget_getClearColor(this: *const c_void, index: u32) -> Color;
	fn tsTarget_getColorOp(this: *const c_void, index: u32) -> TargetOperation;
	fn tsTarget_getColorTexture(this: *const c_void, index: u32) -> *mut c_void;
	fn tsTarget_getColorResolve(this: *const c_void, index: u32) -> *mut c_void;
	fn tsTarget_getColorTextureSlice(this: *const c_void, index: u32) -> Slice;
	fn tsTarget_getColorResolveSlice(this: *const c_void, index: u32) -> Slice;
	fn tsTarget_setClearDepth(this: *mut c_void, depth: f32, stencil: u32);
	fn tsTarget_setDepthTexture(this: *mut c_void, texture: *mut c_void, op: TargetOperation, slice: *const Slice);
	fn tsTarget_setDepthResolve(this: *mut c_void, texture: *mut c_void, slice: *const Slice);
	fn tsTarget_getClearDepth(this: *const c_void) -> f32;
	fn tsTarget_getClearStencil(this: *const c_void) -> u32;
	fn tsTarget_getDepthOp(this: *const c_void) -> TargetOperation;
	fn tsTarget_getDepthTexture(this: *const c_void) -> *mut c_void;
	fn tsTarget_getDepthResolve(this: *const c_void) -> *mut c_void;
	fn tsTarget_getDepthTextureSlice(this: *const c_void) -> Slice;
	fn tsTarget_getDepthResolveSlice(this: *const c_void) -> Slice;
}

// Tellusim::D3D12Target
pub struct D3D12Target {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Target {
	pub fn null() -> D3D12Target { D3D12Target { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Target { unsafe { D3D12Target { this: tsD3D12Target_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Target { unsafe { D3D12Target { this: ptr, owner: tsD3D12Target_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Target { unsafe { D3D12Target { this: tsD3D12Target_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> D3D12Target { unsafe { D3D12Target::new_ptr(tsD3D12Target_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsD3D12Target_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Target) -> bool { unsafe { tsD3D12Target_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Target { unsafe { D3D12Target { this: tsD3D12Target_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Target_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Target_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Target_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Target_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Target_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Target_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Target_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Target_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Target_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn render_target_views(&self) -> *mut usize { unsafe { tsD3D12Target_getRenderTargetViews(self.this) } }
	pub fn depth_stencil_view(&self) -> usize { unsafe { tsD3D12Target_getDepthStencilView(self.this) } }
}
impl TargetTrait for D3D12Target {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for D3D12Target {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Target_delete(self.this) } } }
}
impl Clone for D3D12Target {
	fn clone(&self) -> D3D12Target { unsafe { D3D12Target { this: tsD3D12Target_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Target { }
impl fmt::Display for D3D12Target {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Target ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Target_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Target_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Target_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Target_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Target_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Target_new() -> *mut c_void;
	fn tsD3D12Target_delete(this: *mut c_void);
	fn tsD3D12Target_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Target_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Target_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Target_clearPtr(this: *const c_void);
	fn tsD3D12Target_destroyPtr(this: *const c_void);
	fn tsD3D12Target_acquirePtr(this: *const c_void);
	fn tsD3D12Target_unacquirePtr(this: *const c_void);
	fn tsD3D12Target_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Target_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Target_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Target_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Target_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Target_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Target_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Target_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Target_getRenderTargetViews(this: *const c_void) -> *mut usize;
	fn tsD3D12Target_getDepthStencilView(this: *const c_void) -> usize;
}

// Tellusim::D3D11Target
pub struct D3D11Target {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Target {
	pub fn null() -> D3D11Target { D3D11Target { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Target { unsafe { D3D11Target { this: tsD3D11Target_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Target { unsafe { D3D11Target { this: ptr, owner: tsD3D11Target_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Target { unsafe { D3D11Target { this: tsD3D11Target_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> D3D11Target { unsafe { D3D11Target::new_ptr(tsD3D11Target_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsD3D11Target_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Target) -> bool { unsafe { tsD3D11Target_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Target { unsafe { D3D11Target { this: tsD3D11Target_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Target_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Target_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Target_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Target_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Target_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Target_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Target_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Target_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Target_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn render_target_views(&self) -> *const *const c_void { unsafe { tsD3D11Target_getRenderTargetViews(self.this) } }
	pub fn depth_stencil_view(&self) -> *const c_void { unsafe { tsD3D11Target_getDepthStencilView(self.this) } }
}
impl TargetTrait for D3D11Target {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for D3D11Target {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Target_delete(self.this) } } }
}
impl Clone for D3D11Target {
	fn clone(&self) -> D3D11Target { unsafe { D3D11Target { this: tsD3D11Target_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Target { }
impl fmt::Display for D3D11Target {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Target ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Target_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Target_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Target_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Target_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Target_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Target_new() -> *mut c_void;
	fn tsD3D11Target_delete(this: *mut c_void);
	fn tsD3D11Target_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Target_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Target_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Target_clearPtr(this: *const c_void);
	fn tsD3D11Target_destroyPtr(this: *const c_void);
	fn tsD3D11Target_acquirePtr(this: *const c_void);
	fn tsD3D11Target_unacquirePtr(this: *const c_void);
	fn tsD3D11Target_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Target_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Target_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Target_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Target_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Target_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Target_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Target_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Target_getRenderTargetViews(this: *const c_void) -> *const *const c_void;
	fn tsD3D11Target_getDepthStencilView(this: *const c_void) -> *const c_void;
}

// Tellusim::MTLTarget
pub struct MTLTarget {
	this: *mut c_void,
	owner: bool,
}
impl MTLTarget {
	pub fn null() -> MTLTarget { MTLTarget { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLTarget { unsafe { MTLTarget { this: tsMTLTarget_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLTarget { unsafe { MTLTarget { this: ptr, owner: tsMTLTarget_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLTarget { unsafe { MTLTarget { this: tsMTLTarget_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> MTLTarget { unsafe { MTLTarget::new_ptr(tsMTLTarget_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsMTLTarget_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLTarget) -> bool { unsafe { tsMTLTarget_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLTarget { unsafe { MTLTarget { this: tsMTLTarget_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLTarget_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLTarget_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLTarget_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLTarget_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLTarget_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLTarget_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLTarget_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLTarget_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLTarget_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn descriptor(&self) -> *mut c_void { unsafe { tsMTLTarget_getDescriptor(self.this) } }
}
impl TargetTrait for MTLTarget {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for MTLTarget {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLTarget_delete(self.this) } } }
}
impl Clone for MTLTarget {
	fn clone(&self) -> MTLTarget { unsafe { MTLTarget { this: tsMTLTarget_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLTarget { }
impl fmt::Display for MTLTarget {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLTarget ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLTarget_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLTarget_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLTarget_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLTarget_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLTarget_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLTarget_new() -> *mut c_void;
	fn tsMTLTarget_delete(this: *mut c_void);
	fn tsMTLTarget_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLTarget_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTarget_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTarget_clearPtr(this: *const c_void);
	fn tsMTLTarget_destroyPtr(this: *const c_void);
	fn tsMTLTarget_acquirePtr(this: *const c_void);
	fn tsMTLTarget_unacquirePtr(this: *const c_void);
	fn tsMTLTarget_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLTarget_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLTarget_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLTarget_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLTarget_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTarget_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLTarget_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTarget_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLTarget_getDescriptor(this: *const c_void) -> *mut c_void;
}

// Tellusim::VKTarget
pub struct VKTarget {
	this: *mut c_void,
	owner: bool,
}
impl VKTarget {
	pub fn null() -> VKTarget { VKTarget { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKTarget { unsafe { VKTarget { this: tsVKTarget_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKTarget { unsafe { VKTarget { this: ptr, owner: tsVKTarget_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKTarget { unsafe { VKTarget { this: tsVKTarget_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> VKTarget { unsafe { VKTarget::new_ptr(tsVKTarget_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsVKTarget_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKTarget) -> bool { unsafe { tsVKTarget_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKTarget { unsafe { VKTarget { this: tsVKTarget_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKTarget_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKTarget_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKTarget_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKTarget_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKTarget_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKTarget_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKTarget_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKTarget_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKTarget_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn render_pass(&self) -> *const c_void { unsafe { tsVKTarget_getRenderPass(self.this) } }
	pub fn framebuffer(&self) -> *const c_void { unsafe { tsVKTarget_getFramebuffer(self.this) } }
}
impl TargetTrait for VKTarget {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for VKTarget {
	fn drop(&mut self) { if self.owner { unsafe { tsVKTarget_delete(self.this) } } }
}
impl Clone for VKTarget {
	fn clone(&self) -> VKTarget { unsafe { VKTarget { this: tsVKTarget_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKTarget { }
impl fmt::Display for VKTarget {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKTarget ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKTarget_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKTarget_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKTarget_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKTarget_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKTarget_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKTarget_new() -> *mut c_void;
	fn tsVKTarget_delete(this: *mut c_void);
	fn tsVKTarget_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKTarget_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTarget_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKTarget_clearPtr(this: *const c_void);
	fn tsVKTarget_destroyPtr(this: *const c_void);
	fn tsVKTarget_acquirePtr(this: *const c_void);
	fn tsVKTarget_unacquirePtr(this: *const c_void);
	fn tsVKTarget_isValidPtr(this: *const c_void) -> i32;
	fn tsVKTarget_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKTarget_isConstPtr(this: *const c_void) -> i32;
	fn tsVKTarget_getCountPtr(this: *const c_void) -> u32;
	fn tsVKTarget_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTarget_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKTarget_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTarget_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsVKTarget_getRenderPass(this: *const c_void) -> *const c_void;
	fn tsVKTarget_getFramebuffer(this: *const c_void) -> *const c_void;
}

// Tellusim::GLTarget
pub struct GLTarget {
	this: *mut c_void,
	owner: bool,
}
impl GLTarget {
	pub fn null() -> GLTarget { GLTarget { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLTarget { unsafe { GLTarget { this: tsGLTarget_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLTarget { unsafe { GLTarget { this: ptr, owner: tsGLTarget_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLTarget { unsafe { GLTarget { this: tsGLTarget_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> GLTarget { unsafe { GLTarget::new_ptr(tsGLTarget_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsGLTarget_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLTarget) -> bool { unsafe { tsGLTarget_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLTarget { unsafe { GLTarget { this: tsGLTarget_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLTarget_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLTarget_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLTarget_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLTarget_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLTarget_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLTarget_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLTarget_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLTarget_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLTarget_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn framebuffer_id(&self) -> u32 { unsafe { tsGLTarget_getFramebufferID(self.this) } }
}
impl TargetTrait for GLTarget {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for GLTarget {
	fn drop(&mut self) { if self.owner { unsafe { tsGLTarget_delete(self.this) } } }
}
impl Clone for GLTarget {
	fn clone(&self) -> GLTarget { unsafe { GLTarget { this: tsGLTarget_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLTarget { }
impl fmt::Display for GLTarget {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLTarget ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLTarget_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLTarget_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLTarget_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLTarget_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLTarget_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLTarget_new() -> *mut c_void;
	fn tsGLTarget_delete(this: *mut c_void);
	fn tsGLTarget_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLTarget_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLTarget_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLTarget_clearPtr(this: *const c_void);
	fn tsGLTarget_destroyPtr(this: *const c_void);
	fn tsGLTarget_acquirePtr(this: *const c_void);
	fn tsGLTarget_unacquirePtr(this: *const c_void);
	fn tsGLTarget_isValidPtr(this: *const c_void) -> i32;
	fn tsGLTarget_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLTarget_isConstPtr(this: *const c_void) -> i32;
	fn tsGLTarget_getCountPtr(this: *const c_void) -> u32;
	fn tsGLTarget_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLTarget_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLTarget_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsGLTarget_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsGLTarget_getFramebufferID(this: *const c_void) -> u32;
}

// Tellusim::GLESTarget
pub struct GLESTarget {
	this: *mut c_void,
	owner: bool,
}
impl GLESTarget {
	pub fn null() -> GLESTarget { GLESTarget { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLESTarget { unsafe { GLESTarget { this: tsGLESTarget_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLESTarget { unsafe { GLESTarget { this: ptr, owner: tsGLESTarget_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLESTarget { unsafe { GLESTarget { this: tsGLESTarget_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> GLESTarget { unsafe { GLESTarget::new_ptr(tsGLESTarget_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsGLESTarget_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLESTarget) -> bool { unsafe { tsGLESTarget_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLESTarget { unsafe { GLESTarget { this: tsGLESTarget_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLESTarget_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLESTarget_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLESTarget_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLESTarget_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLESTarget_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLESTarget_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLESTarget_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLESTarget_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLESTarget_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn framebuffer_id(&self) -> u32 { unsafe { tsGLESTarget_getFramebufferID(self.this) } }
}
impl TargetTrait for GLESTarget {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for GLESTarget {
	fn drop(&mut self) { if self.owner { unsafe { tsGLESTarget_delete(self.this) } } }
}
impl Clone for GLESTarget {
	fn clone(&self) -> GLESTarget { unsafe { GLESTarget { this: tsGLESTarget_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLESTarget { }
impl fmt::Display for GLESTarget {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLESTarget ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLESTarget_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLESTarget_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLESTarget_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLESTarget_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLESTarget_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLESTarget_new() -> *mut c_void;
	fn tsGLESTarget_delete(this: *mut c_void);
	fn tsGLESTarget_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESTarget_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTarget_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTarget_clearPtr(this: *const c_void);
	fn tsGLESTarget_destroyPtr(this: *const c_void);
	fn tsGLESTarget_acquirePtr(this: *const c_void);
	fn tsGLESTarget_unacquirePtr(this: *const c_void);
	fn tsGLESTarget_isValidPtr(this: *const c_void) -> i32;
	fn tsGLESTarget_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLESTarget_isConstPtr(this: *const c_void) -> i32;
	fn tsGLESTarget_getCountPtr(this: *const c_void) -> u32;
	fn tsGLESTarget_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTarget_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESTarget_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTarget_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESTarget_getFramebufferID(this: *const c_void) -> u32;
}

// Tellusim::FUTarget
pub struct FUTarget {
	this: *mut c_void,
	owner: bool,
}
impl FUTarget {
	pub fn null() -> FUTarget { FUTarget { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUTarget { unsafe { FUTarget { this: tsFUTarget_new(), owner: true } } }
	pub fn new_with_targets(targets: &[&mut Target]) -> FUTarget {
		let mut targets_ = Vec::new();
		for ptr in targets { targets_.push(ptr.this); }
		unsafe { FUTarget { this: tsFUTarget_new_cATb(targets_.as_ptr(), targets.len() as u32, 0), owner: true } }
	}
	pub fn new_with_targets_owner(targets: &[&mut Target], owner: bool) -> FUTarget {
		let mut targets_ = Vec::new();
		for ptr in targets { targets_.push(ptr.this); }
		unsafe { FUTarget { this: tsFUTarget_new_cATb(targets_.as_ptr(), targets.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUTarget { unsafe { FUTarget { this: ptr, owner: tsFUTarget_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUTarget { unsafe { FUTarget { this: tsFUTarget_copyPtr(self.this), owner: true } } }
	pub fn from_target(ptr: &Target) -> FUTarget { unsafe { FUTarget::new_ptr(tsFUTarget_castTargetPtr(ptr.this)) } }
	pub fn to_target(&self) -> Target { unsafe { Target::new_ptr(tsFUTarget_baseTargetPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUTarget) -> bool { unsafe { tsFUTarget_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUTarget { unsafe { FUTarget { this: tsFUTarget_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUTarget_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUTarget_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUTarget_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUTarget_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUTarget_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUTarget_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUTarget_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUTarget_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUTarget_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUTarget_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUTarget_getMask(self.this) } }
	pub fn num_targets(&self) -> u32 { unsafe { tsFUTarget_getNumTargets(self.this) } }
	pub fn target(&self, index: u32) -> Target { unsafe { Target::new_ptr(tsFUTarget_getTarget_cu(self.this, index)) } }
	pub fn target_mut(&mut self, index: u32) -> Target { unsafe { Target::new_ptr(tsFUTarget_getTarget_u(self.this, index)) } }
}
impl TargetTrait for FUTarget {
	fn platform(&self) -> Platform { unsafe { tsTarget_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTarget_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTarget_getIndex(self.this) } }
	fn begin_with_fence(&mut self, fence: &mut Fence) -> bool { unsafe { tsTarget_begin_F(self.this, fence.this) != 0 } }
	fn begin(&mut self) -> bool { unsafe { tsTarget_begin(self.this) != 0 } }
	fn end_with_fence(&mut self, fence: &mut Fence) { unsafe { tsTarget_end_F(self.this, fence.this) } }
	fn end(&mut self) { unsafe { tsTarget_end(self.this) } }
	fn swap(&mut self, surface: &mut Surface) { unsafe { tsTarget_swap(self.this, surface.this) } }
	fn is_enabled(&self) -> bool { unsafe { tsTarget_isEnabled(self.this) != 0 } }
	fn color_format(&self) -> Format { unsafe { tsTarget_getColorFormat(self.this, 0) } }
	fn color_format_with_index(&self, index: u32) -> Format { unsafe { tsTarget_getColorFormat(self.this, index) } }
	fn depth_format(&self) -> Format { unsafe { tsTarget_getDepthFormat(self.this) } }
	fn multisample(&self) -> u32 { unsafe { tsTarget_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsTarget_hasMultisample(self.this) != 0 } }
	fn is_flipped(&self) -> bool { unsafe { tsTarget_isFlipped(self.this) != 0 } }
	fn is_atomic(&self) -> bool { unsafe { tsTarget_isAtomic(self.this) != 0 } }
	fn width(&self) -> u32 { unsafe { tsTarget_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsTarget_getHeight(self.this) } }
	fn depth(&self) -> u32 { unsafe { tsTarget_getDepth(self.this) } }
	fn faces(&self) -> u32 { unsafe { tsTarget_getFaces(self.this) } }
	fn layers(&self) -> u32 { unsafe { tsTarget_getLayers(self.this) } }
	fn mipmaps(&self) -> u32 { unsafe { tsTarget_getMipmaps(self.this) } }
	fn set_clear_color_with_color(&mut self, color: &Color) { unsafe { tsTarget_setClearColor_cC(self.this, color) } }
	fn set_clear_color_with_index(&mut self, index: u32, color: &Color) { unsafe { tsTarget_setClearColor_ucC(self.this, index, color) } }
	fn set_clear_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_ffff(self.this, r, g, b, a) } }
	fn set_clear_color_with_index_r(&mut self, index: u32, r: f32, g: f32, b: f32, a: f32) { unsafe { tsTarget_setClearColor_uffff(self.this, index, r, g, b, a) } }
	fn set_color_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_TTOcS(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_texture_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_color_texture_with_index_op(&mut self, index: u32, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, &Slice::default()) } }
	fn set_color_texture_with_index_op_slice(&mut self, index: u32, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorTexture_uTTOcS(self.this, index, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_TcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_color_resolve_with_index(&mut self, index: u32, texture: &mut Texture) { unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, &Slice::default()) } }
	fn set_color_resolve_with_index_slice(&mut self, index: u32, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setColorResolve_uTcS(self.this, index, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn num_targets(&self) -> u32 { unsafe { tsTarget_getNumTargets(self.this) } }
	fn clear_color(&self) -> Color { unsafe { tsTarget_getClearColor(self.this, 0) } }
	fn clear_color_with_index(&self, index: u32) -> Color { unsafe { tsTarget_getClearColor(self.this, index) } }
	fn color_op(&self) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, 0) } }
	fn color_op_with_index(&self, index: u32) -> TargetOperation { unsafe { tsTarget_getColorOp(self.this, index) } }
	fn color_texture(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorTexture(self.this, index)) } }
	fn color_resolve(&self, index: u32) -> Texture { unsafe { Texture::new_ptr(tsTarget_getColorResolve(self.this, index)) } }
	fn color_texture_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorTextureSlice(self.this, index) } }
	fn color_resolve_slice(&self, index: u32) -> Slice { unsafe { tsTarget_getColorResolveSlice(self.this, index) } }
	fn set_clear_depth(&mut self, depth: f32) { unsafe { tsTarget_setClearDepth(self.this, depth, 0) } }
	fn set_clear_depth_with_stencil(&mut self, depth: f32, stencil: u32) { unsafe { tsTarget_setClearDepth(self.this, depth, stencil) } }
	fn set_depth_texture(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, TargetOperation::OpClearStore, &Slice::default()) } }
	fn set_depth_texture_with_op(&mut self, texture: &mut Texture, op: TargetOperation) { unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, &Slice::default()) } }
	fn set_depth_texture_with_op_slice(&mut self, texture: &mut Texture, op: TargetOperation, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthTexture(self.this, texture.this, op, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn set_depth_resolve(&mut self, texture: &mut Texture) { unsafe { tsTarget_setDepthResolve(self.this, texture.this, &Slice::default()) } }
	fn set_depth_resolve_with_slice(&mut self, texture: &mut Texture, slice: Option<&Slice>) {
		let slice_ = Slice::default();
		unsafe { tsTarget_setDepthResolve(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) }
	}
	fn clear_depth(&self) -> f32 { unsafe { tsTarget_getClearDepth(self.this) } }
	fn clear_stencil(&self) -> u32 { unsafe { tsTarget_getClearStencil(self.this) } }
	fn depth_op(&self) -> TargetOperation { unsafe { tsTarget_getDepthOp(self.this) } }
	fn depth_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthTexture(self.this)) } }
	fn depth_resolve(&self) -> Texture { unsafe { Texture::new_ptr(tsTarget_getDepthResolve(self.this)) } }
	fn depth_texture_slice(&self) -> Slice { unsafe { tsTarget_getDepthTextureSlice(self.this) } }
	fn depth_resolve_slice(&self) -> Slice { unsafe { tsTarget_getDepthResolveSlice(self.this) } }
}
impl Drop for FUTarget {
	fn drop(&mut self) { if self.owner { unsafe { tsFUTarget_delete(self.this) } } }
}
impl Clone for FUTarget {
	fn clone(&self) -> FUTarget { unsafe { FUTarget { this: tsFUTarget_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUTarget { }
impl fmt::Display for FUTarget {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUTarget ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUTarget_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUTarget_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUTarget_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUTarget_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUTarget_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUTarget_new() -> *mut c_void;
	fn tsFUTarget_new_cATb(targets: *const *mut c_void, targets_size: u32, owner: i32) -> *mut c_void;
	fn tsFUTarget_delete(this: *mut c_void);
	fn tsFUTarget_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTarget_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTarget_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUTarget_clearPtr(this: *const c_void);
	fn tsFUTarget_destroyPtr(this: *const c_void);
	fn tsFUTarget_acquirePtr(this: *const c_void);
	fn tsFUTarget_unacquirePtr(this: *const c_void);
	fn tsFUTarget_isValidPtr(this: *const c_void) -> i32;
	fn tsFUTarget_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUTarget_isConstPtr(this: *const c_void) -> i32;
	fn tsFUTarget_getCountPtr(this: *const c_void) -> u32;
	fn tsFUTarget_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTarget_equalTargetPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTarget_castTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTarget_baseTargetPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTarget_setMask(this: *mut c_void, mask: u32);
	fn tsFUTarget_getMask(this: *const c_void) -> u32;
	fn tsFUTarget_getNumTargets(this: *const c_void) -> u32;
	fn tsFUTarget_getTarget_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUTarget_getTarget_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Device
pub struct Device {
	this: *mut c_void,
	owner: bool,
}
impl Device {
	pub fn null() -> Device { Device { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Device { unsafe { Device { this: tsDevice_new(), owner: true } } }
	pub fn new_with_context(context: &mut Context) -> Device { unsafe { Device { this: tsDevice_new_C(context.this), owner: true } } }
	pub fn new_with_surface(surface: &mut Surface) -> Device { unsafe { Device { this: tsDevice_new_S(surface.this), owner: true } } }
	pub fn new_with_window(window: &mut Window) -> Device { unsafe { Device { this: tsDevice_new_W(window.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Device { unsafe { Device { this: ptr, owner: tsDevice_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Device { unsafe { Device { this: tsDevice_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Device) -> bool { unsafe { tsDevice_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Device { unsafe { Device { this: tsDevice_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDevice_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDevice_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDevice_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDevice_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDevice_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDevice_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDevice_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDevice_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDevice_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait DeviceTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn name(&self) -> string::String;
	fn vendor(&self) -> string::String;
	fn version(&self) -> string::String;
	fn features(&self) -> DeviceFeatures;
	fn has_query(&self, type_: QueryType) -> bool;
	fn has_shader(&self, type_: ShaderType) -> bool;
	fn has_target(&self, format: Format) -> bool;
	fn has_texture(&self, format: Format) -> bool;
	fn has_surface(&self, format: Format) -> bool;
	fn create_device(&self, index: u32) -> Device;
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device;
	fn create_command_device(&self) -> Device;
	fn create_command_device_with_frames(&self, frames: u32) -> Device;
	fn create_compute_device(&self) -> Device;
	fn create_compute_device_with_frames(&self, frames: u32) -> Device;
	fn create_copy_device(&self) -> Device;
	fn create_copy_device_with_frames(&self, frames: u32) -> Device;
	fn create_query(&self) -> Query;
	fn create_query_with_type(&self, type_: QueryType) -> Query;
	fn create_fence(&self) -> Fence;
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence;
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence;
	fn create_buffer(&self) -> Buffer;
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer;
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer;
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer;
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer;
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer;
	fn create_sampler(&self) -> Sampler;
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler;
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler;
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler;
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler;
	fn create_texture(&self) -> Texture;
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture;
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture;
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture;
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture;
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture;
	fn create_texture_with_image(&self, image: &Image) -> Texture;
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture;
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture;
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture;
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture;
	fn create_texture3d(&self, format: Format, size: u32) -> Texture;
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture;
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture;
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture;
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture;
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture;
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture;
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture;
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture;
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture;
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture;
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture;
	fn load_texture(&self, name: &str) -> Texture;
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture;
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture;
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture;
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture;
	fn load_texture_with_name(&self, name: &String) -> Texture;
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture;
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture;
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture;
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture;
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture;
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture;
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture;
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture;
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture;
	fn create_tracing(&self) -> Tracing;
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing;
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing;
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing;
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing;
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing;
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing;
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing;
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing;
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing;
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing;
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing;
	fn create_buffer_table(&self) -> BufferTable;
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable;
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable;
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable;
	fn create_texture_table(&self) -> TextureTable;
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable;
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable;
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable;
	fn create_shader(&self) -> Shader;
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader;
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader;
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader;
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader;
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader;
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader;
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader;
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader;
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader;
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader;
	fn create_kernel(&self) -> Kernel;
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel;
	fn release_kernel(&self, kernel: &mut Kernel);
	fn create_pipeline(&self) -> Pipeline;
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline;
	fn release_pipeline(&self, pipeline: &mut Pipeline);
	fn create_traversal(&self) -> Traversal;
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal;
	fn release_traversal(&self, traversal: &mut Traversal);
	fn create_target(&self) -> Target;
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target;
	fn create_target_with_window(&self, window: &mut Window) -> Target;
	fn create_compute(&self) -> Compute;
	fn create_command(&self) -> Command;
	fn create_command_with_target(&self, target: &mut Target) -> Command;
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool;
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool;
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool;
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool;
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool;
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool;
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void;
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void;
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void;
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool;
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool;
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool;
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool;
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool;
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool;
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool;
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool;
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool;
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool;
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool;
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool;
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool;
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool;
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool;
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool;
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool;
	fn release_buffer(&self, buffer: &mut Buffer);
	fn release_sampler(&self, sampler: &mut Sampler);
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool;
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool;
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool;
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool;
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool;
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool;
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool;
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool;
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool;
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool;
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool;
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool;
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool;
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool;
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool;
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool;
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool;
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool;
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool;
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool;
	fn create_mipmaps(&self, texture: &mut Texture) -> bool;
	fn flush_texture(&self, texture: &mut Texture) -> bool;
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool;
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool;
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool;
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool;
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool;
	fn release_texture(&self, texture: &mut Texture);
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool;
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool;
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool;
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool;
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool;
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool;
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool;
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool;
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool;
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool;
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool;
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool;
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool;
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool;
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool;
	fn release_tracing(&self, tracing: &mut Tracing);
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool;
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool;
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool;
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool;
	fn release_buffer_table(&self, table: &mut BufferTable);
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool;
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool;
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool;
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool;
	fn release_texture_table(&self, table: &mut TextureTable);
	fn begin_query(&self, query: &mut Query) -> bool;
	fn end_query(&self, query: &mut Query);
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool;
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool;
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool;
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool;
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool;
	fn wait_fence(&self, fence: &mut Fence) -> bool;
	fn signal_fence(&self, fence: &mut Fence) -> bool;
	fn execute(&self, device: &mut Device) -> bool;
	fn flip_with_fence(&self, fence: &mut Fence) -> bool;
	fn flip(&self) -> bool;
	fn flush(&self) -> bool;
	fn finish(&self) -> bool;
	fn check(&self) -> bool;
}
impl DeviceTrait for Device {
	fn platform(&self) -> Platform { unsafe { tsDevice_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsDevice_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsDevice_getIndex(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsDevice_getName(self.this)) } }
	fn vendor(&self) -> string::String { unsafe { get_string(tsDevice_getVendor(self.this)) } }
	fn version(&self) -> string::String { unsafe { get_string(tsDevice_getVersion(self.this)) } }
	fn features(&self) -> DeviceFeatures { unsafe { tsDevice_getFeatures(self.this) } }
	fn has_query(&self, type_: QueryType) -> bool { unsafe { tsDevice_hasQuery(self.this, type_) != 0 } }
	fn has_shader(&self, type_: ShaderType) -> bool { unsafe { tsDevice_hasShader(self.this, type_) != 0 } }
	fn has_target(&self, format: Format) -> bool { unsafe { tsDevice_hasTarget(self.this, format) != 0 } }
	fn has_texture(&self, format: Format) -> bool { unsafe { tsDevice_hasTexture(self.this, format) != 0 } }
	fn has_surface(&self, format: Format) -> bool { unsafe { tsDevice_hasSurface(self.this, format) != 0 } }
	fn create_device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, 3)) } }
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, frames)) } }
	fn create_command_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, 3)) } }
	fn create_command_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, frames)) } }
	fn create_compute_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, 3)) } }
	fn create_compute_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, frames)) } }
	fn create_copy_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, 3)) } }
	fn create_copy_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, frames)) } }
	fn create_query(&self) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_c(self.this)) } }
	fn create_query_with_type(&self, type_: QueryType) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_cQT(self.this, type_)) } }
	fn create_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_c(self.this)) } }
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cF(self.this, shared.this)) } }
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cFF(self.this, flags)) } }
	fn create_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_c(self.this)) } }
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cB(self.this, shared.this)) } }
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, Format::Unknown)) } }
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, format)) } }
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, Format::Unknown)) } }
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, format)) } }
	fn create_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_c(self.this)) } }
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_ccS(self.this, sampler.this)) } }
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, SamplerWrapMode::Repeat, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, anisotropy)) } }
	fn create_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_c(self.this)) } }
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cT(self.this, shared.this)) } }
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, TextureFlags::None)) } }
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, flags)) } }
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, TextureFlags::None)) } }
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, flags)) } }
	fn create_texture_with_image(&self, image: &Image) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, TextureFlags::None, ptr::null_mut())) } }
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, ptr::null_mut())) } }
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture3d(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, flags)) } }
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, TextureFlags::None)) } }
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, flags)) } }
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, TextureFlags::None)) } }
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, flags)) } }
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, TextureFlags::None)) } }
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, flags)) } }
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, TextureFlags::None)) } }
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, flags)) } }
	fn load_texture(&self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) }
	}
	fn load_texture_with_name(&self, name: &String) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_c(self.this)) } }
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_ccT(self.this, tracing.this)) } }
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, flags)) } }
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, TracingFlags::None)) } }
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)) } }
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, flags)) } }
	fn create_buffer_table(&self) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_c(self.this)) } }
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_cu(self.this, size)) } }
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, 0)) }
	}
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0})) }
	}
	fn create_texture_table(&self) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_c(self.this)) } }
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_cTTu(self.this, type_, size)) } }
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, 0)) }
	}
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0})) }
	}
	fn create_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShader_c(self.this)) } }
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderSPIRV(self.this, type_, name_.as_ptr())) }
	}
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32)) } }
	fn create_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_c(self.this)) } }
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_ccK(self.this, kernel.this)) } }
	fn release_kernel(&self, kernel: &mut Kernel) { unsafe { tsDevice_releaseKernel(self.this, kernel.this) } }
	fn create_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_c(self.this)) } }
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_ccP(self.this, pipeline.this)) } }
	fn release_pipeline(&self, pipeline: &mut Pipeline) { unsafe { tsDevice_releasePipeline(self.this, pipeline.this) } }
	fn create_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_c(self.this)) } }
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_ccT(self.this, traversal.this)) } }
	fn release_traversal(&self, traversal: &mut Traversal) { unsafe { tsDevice_releaseTraversal(self.this, traversal.this) } }
	fn create_target(&self) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_c(self.this)) } }
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cS(self.this, surface.this)) } }
	fn create_target_with_window(&self, window: &mut Window) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cW(self.this, window.this)) } }
	fn create_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsDevice_createCompute(self.this)) } }
	fn create_command(&self) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_c(self.this)) } }
	fn create_command_with_target(&self, target: &mut Target) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_cT(self.this, target.this)) } }
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsDevice_setBuffer_cBp(self.this, buffer.this, src) != 0 } }
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBzprz(self.this, buffer.this, offset, dest, size) != 0 } }
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBprz(self.this, buffer.this, dest, size) != 0 } }
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool { unsafe { tsDevice_getBuffer_cBpr(self.this, buffer.this, dest) != 0 } }
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBzz(self.this, buffer.this, offset, size) } }
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBz(self.this, buffer.this, size) } }
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void { unsafe { tsDevice_mapBuffer_cB(self.this, buffer.this) } }
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_unmapBuffer(self.this, buffer.this) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsDevice_copyBuffer_cBB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsDevice_clearBuffer_cBFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_clearBuffer_cB(self.this, buffer.this) != 0 } }
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAbF(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAb(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBzzbF(self.this, buffer.this, offset, size, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBzzb(self.this, buffer.this, offset, size, if commit {1} else {0}) != 0 } }
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, BufferFlags::None) != 0 } }
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, flags) != 0 } }
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, BufferFlags::None) != 0 }
	}
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, flags) != 0 }
	}
	fn release_buffer(&self, buffer: &mut Buffer) { unsafe { tsDevice_releaseBuffer(self.this, buffer.this) } }
	fn release_sampler(&self, sampler: &mut Sampler) { unsafe { tsDevice_releaseSampler(self.this, sampler.this) } }
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcI(self.this, texture.this, image.this) != 0 } }
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTcSIcS(self.this, texture.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTIcS(self.this, texture.this, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool { unsafe { tsDevice_getTexture_cTI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsDevice_copyTexture_cTcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDevice_copyTexture_cTT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTp(self.this, texture.this, src) != 0 } }
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindTexture_cTcRucSubF(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool { unsafe { tsDevice_bindTexture_cTcRucSub(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSbF(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}, fence.this) != 0 }
	}
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSb(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}) != 0 }
	}
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_createMipmaps_cTcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	fn create_mipmaps(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_createMipmaps_cT(self.this, texture.this) != 0 } }
	fn flush_texture(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, TextureFlags::None) != 0 } }
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, flags) != 0 } }
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, TextureFlags::None) != 0 }
	}
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, flags) != 0 }
	}
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, TextureFlags::None) != 0 }
	}
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, flags) != 0 }
	}
	fn release_texture(&self, texture: &mut Texture) { unsafe { tsDevice_releaseTexture(self.this, texture.this) } }
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool { unsafe { tsDevice_setTracing(self.this, tracing.this, instances.as_ptr(), instances.len() as u32) != 0 } }
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, TracingFlags::None) != 0 } }
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, flags) != 0 } }
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, TracingFlags::None) != 0 } }
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, flags) != 0 } }
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, flags) != 0 }
	}
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, flags) != 0 }
	}
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, 0) != 0 } }
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, offset) != 0 } }
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool { unsafe { tsDevice_flushTracing(self.this, tracing.this) != 0 } }
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_flushTracings(self.this, tracings_.as_ptr(), tracings.len() as u32) != 0 }
	}
	fn release_tracing(&self, tracing: &mut Tracing) { unsafe { tsDevice_releaseTracing(self.this, tracing.this) } }
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, 0) != 0 } }
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, if owner {1} else {0}) != 0 } }
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, 0) != 0 }
	}
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_buffer_table(&self, table: &mut BufferTable) { unsafe { tsDevice_releaseBufferTable(self.this, table.this) } }
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, 0) != 0 } }
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, if owner {1} else {0}) != 0 } }
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, 0) != 0 }
	}
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_texture_table(&self, table: &mut TextureTable) { unsafe { tsDevice_releaseTextureTable(self.this, table.this) } }
	fn begin_query(&self, query: &mut Query) -> bool { unsafe { tsDevice_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&self, query: &mut Query) { unsafe { tsDevice_endQuery(self.this, query.this) } }
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, 0) != 0 } }
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, offset) != 0 } }
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, 0, 0) != 0 }
	}
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn wait_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_waitFence(self.this, fence.this) != 0 } }
	fn signal_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_signalFence(self.this, fence.this) != 0 } }
	fn execute(&self, device: &mut Device) -> bool { unsafe { tsDevice_execute(self.this, device.this) != 0 } }
	fn flip_with_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_flip_cF(self.this, fence.this) != 0 } }
	fn flip(&self) -> bool { unsafe { tsDevice_flip_c(self.this) != 0 } }
	fn flush(&self) -> bool { unsafe { tsDevice_flush(self.this) != 0 } }
	fn finish(&self) -> bool { unsafe { tsDevice_finish(self.this) != 0 } }
	fn check(&self) -> bool { unsafe { tsDevice_check(self.this) != 0 } }
}
impl Drop for Device {
	fn drop(&mut self) { if self.owner { unsafe { tsDevice_delete(self.this) } } }
}
impl Clone for Device {
	fn clone(&self) -> Device { unsafe { Device { this: tsDevice_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Device { }
impl fmt::Display for Device {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Device ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDevice_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDevice_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDevice_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDevice_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDevice_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDevice_new() -> *mut c_void;
	fn tsDevice_new_C(context: *mut c_void) -> *mut c_void;
	fn tsDevice_new_S(surface: *mut c_void) -> *mut c_void;
	fn tsDevice_new_W(window: *mut c_void) -> *mut c_void;
	fn tsDevice_delete(this: *mut c_void);
	fn tsDevice_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDevice_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDevice_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDevice_clearPtr(this: *const c_void);
	fn tsDevice_destroyPtr(this: *const c_void);
	fn tsDevice_acquirePtr(this: *const c_void);
	fn tsDevice_unacquirePtr(this: *const c_void);
	fn tsDevice_isValidPtr(this: *const c_void) -> i32;
	fn tsDevice_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDevice_isConstPtr(this: *const c_void) -> i32;
	fn tsDevice_getCountPtr(this: *const c_void) -> u32;
	fn tsDevice_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDevice_getPlatform(this: *const c_void) -> Platform;
	fn tsDevice_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsDevice_getIndex(this: *const c_void) -> u32;
	fn tsDevice_getName(this: *const c_void) -> *mut c_void;
	fn tsDevice_getVendor(this: *const c_void) -> *mut c_void;
	fn tsDevice_getVersion(this: *const c_void) -> *mut c_void;
	fn tsDevice_getFeatures(this: *const c_void) -> DeviceFeatures;
	fn tsDevice_hasQuery(this: *const c_void, type_: QueryType) -> i32;
	fn tsDevice_hasShader(this: *const c_void, type_: ShaderType) -> i32;
	fn tsDevice_hasTarget(this: *const c_void, format: Format) -> i32;
	fn tsDevice_hasTexture(this: *const c_void, format: Format) -> i32;
	fn tsDevice_hasSurface(this: *const c_void, format: Format) -> i32;
	fn tsDevice_createDevice(this: *const c_void, index: u32, frames: u32) -> *mut c_void;
	fn tsDevice_createCommandDevice(this: *const c_void, frames: u32) -> *mut c_void;
	fn tsDevice_createComputeDevice(this: *const c_void, frames: u32) -> *mut c_void;
	fn tsDevice_createCopyDevice(this: *const c_void, frames: u32) -> *mut c_void;
	fn tsDevice_createQuery_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createQuery_cQT(this: *const c_void, type_: QueryType) -> *mut c_void;
	fn tsDevice_createFence_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createFence_cF(this: *const c_void, shared: *mut c_void) -> *mut c_void;
	fn tsDevice_createFence_cFF(this: *const c_void, flags: FenceFlags) -> *mut c_void;
	fn tsDevice_createBuffer_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createBuffer_cB(this: *const c_void, shared: *mut c_void) -> *mut c_void;
	fn tsDevice_createBuffer_cBFzF(this: *const c_void, flags: BufferFlags, size: usize, format: Format) -> *mut c_void;
	fn tsDevice_createBuffer_cBFpzF(this: *const c_void, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> *mut c_void;
	fn tsDevice_createSampler_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createSampler_ccS(this: *const c_void, sampler: *mut c_void) -> *mut c_void;
	fn tsDevice_createSampler_cSFSWMu(this: *const c_void, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> *mut c_void;
	fn tsDevice_createTexture_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createTexture_cT(this: *const c_void, shared: *mut c_void) -> *mut c_void;
	fn tsDevice_createTexture_cTTFcSuTF(this: *const c_void, type_: TextureType, format: Format, size: *const Size, layers: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTexture_cTTFcSTF(this: *const c_void, type_: TextureType, format: Format, size: *const Size, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTexture_ccITFA(this: *const c_void, image: *mut c_void, flags: TextureFlags, async_: *const *mut c_void) -> *mut c_void;
	fn tsDevice_createTexture2D_cFuTF(this: *const c_void, format: Format, size: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTexture3D_cFuTF(this: *const c_void, format: Format, size: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTextureCube_cFuTF(this: *const c_void, format: Format, size: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTexture2D_cFuuTF(this: *const c_void, format: Format, width: u32, height: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTexture3D_cFuuuTF(this: *const c_void, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTexture2D_cFuuuTF(this: *const c_void, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_createTextureCube_cFuuTF(this: *const c_void, format: Format, size: u32, layers: u32, flags: TextureFlags) -> *mut c_void;
	fn tsDevice_loadTexture_csTFIFuA(this: *const c_void, name: *const c_char, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> *mut c_void;
	fn tsDevice_loadTexture_ccSTFIFuA(this: *const c_void, name: *mut c_void, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> *mut c_void;
	fn tsDevice_loadTexture_cStTFIFuA(this: *const c_void, stream: *mut c_void, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: *const *mut c_void) -> *mut c_void;
	fn tsDevice_createTracing_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createTracing_ccT(this: *const c_void, tracing: *mut c_void) -> *mut c_void;
	fn tsDevice_createTracing_cuBzTF(this: *const c_void, num_instances: u32, instance_buffer: *mut c_void, instance_offset: usize, flags: TracingFlags) -> *mut c_void;
	fn tsDevice_createTracing_cuFzuFTF(this: *const c_void, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> *mut c_void;
	fn tsDevice_createTracing_cuzBzTF(this: *const c_void, num_bounds: u32, bound_stride: usize, bound_buffer: *mut c_void, bound_offset: usize, flags: TracingFlags) -> *mut c_void;
	fn tsDevice_createBufferTable_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createBufferTable_cu(this: *const c_void, size: u32) -> *mut c_void;
	fn tsDevice_createBufferTable_ccABb(this: *const c_void, buffers: *const *mut c_void, buffers_size: u32, owner: i32) -> *mut c_void;
	fn tsDevice_createTextureTable_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createTextureTable_cTTu(this: *const c_void, type_: TextureType, size: u32) -> *mut c_void;
	fn tsDevice_createTextureTable_ccATb(this: *const c_void, textures: *const *mut c_void, textures_size: u32, owner: i32) -> *mut c_void;
	fn tsDevice_createShader_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_loadShader_cSTss(this: *const c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> *mut c_void;
	fn tsDevice_loadShaderGLSL_cSTss(this: *const c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> *mut c_void;
	fn tsDevice_loadShader_cSTscS(this: *const c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void) -> *mut c_void;
	fn tsDevice_loadShaderGLSL_cSTscS(this: *const c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void) -> *mut c_void;
	fn tsDevice_loadShaderSPIRV(this: *const c_void, type_: ShaderType, name: *const c_char) -> *mut c_void;
	fn tsDevice_createShader_cSTss(this: *const c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> *mut c_void;
	fn tsDevice_createShaderGLSL_cSTss(this: *const c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> *mut c_void;
	fn tsDevice_createShader_cSTscS(this: *const c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void) -> *mut c_void;
	fn tsDevice_createShaderGLSL_cSTscS(this: *const c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void) -> *mut c_void;
	fn tsDevice_createShaderSPIRV(this: *const c_void, type_: ShaderType, data: *const u32, data_size: u32) -> *mut c_void;
	fn tsDevice_createKernel_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createKernel_ccK(this: *const c_void, kernel: *mut c_void) -> *mut c_void;
	fn tsDevice_releaseKernel(this: *const c_void, kernel: *mut c_void);
	fn tsDevice_createPipeline_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createPipeline_ccP(this: *const c_void, pipeline: *mut c_void) -> *mut c_void;
	fn tsDevice_releasePipeline(this: *const c_void, pipeline: *mut c_void);
	fn tsDevice_createTraversal_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createTraversal_ccT(this: *const c_void, traversal: *mut c_void) -> *mut c_void;
	fn tsDevice_releaseTraversal(this: *const c_void, traversal: *mut c_void);
	fn tsDevice_createTarget_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createTarget_cS(this: *const c_void, surface: *mut c_void) -> *mut c_void;
	fn tsDevice_createTarget_cW(this: *const c_void, window: *mut c_void) -> *mut c_void;
	fn tsDevice_createCompute(this: *const c_void) -> *mut c_void;
	fn tsDevice_createCommand_c(this: *const c_void) -> *mut c_void;
	fn tsDevice_createCommand_cT(this: *const c_void, target: *mut c_void) -> *mut c_void;
	fn tsDevice_setBuffer_cBzpz(this: *const c_void, buffer: *mut c_void, offset: usize, src: *const c_void, size: usize) -> i32;
	fn tsDevice_setBuffer_cBpz(this: *const c_void, buffer: *mut c_void, src: *const c_void, size: usize) -> i32;
	fn tsDevice_setBuffer_cBp(this: *const c_void, buffer: *mut c_void, src: *const c_void) -> i32;
	fn tsDevice_getBuffer_cBzprz(this: *const c_void, buffer: *mut c_void, offset: usize, dest: *mut c_void, size: usize) -> i32;
	fn tsDevice_getBuffer_cBprz(this: *const c_void, buffer: *mut c_void, dest: *mut c_void, size: usize) -> i32;
	fn tsDevice_getBuffer_cBpr(this: *const c_void, buffer: *mut c_void, dest: *mut c_void) -> i32;
	fn tsDevice_mapBuffer_cBzz(this: *const c_void, buffer: *mut c_void, offset: usize, size: usize) -> *mut c_void;
	fn tsDevice_mapBuffer_cBz(this: *const c_void, buffer: *mut c_void, size: usize) -> *mut c_void;
	fn tsDevice_mapBuffer_cB(this: *const c_void, buffer: *mut c_void) -> *mut c_void;
	fn tsDevice_unmapBuffer(this: *const c_void, buffer: *mut c_void) -> i32;
	fn tsDevice_copyBuffer_cBzBzz(this: *const c_void, buffer: *mut c_void, dest_offset: usize, src: *mut c_void, src_offset: usize, size: usize) -> i32;
	fn tsDevice_copyBuffer_cBzBz(this: *const c_void, buffer: *mut c_void, dest_offset: usize, src: *mut c_void, size: usize) -> i32;
	fn tsDevice_copyBuffer_cBBz(this: *const c_void, buffer: *mut c_void, src: *mut c_void, size: usize) -> i32;
	fn tsDevice_copyBuffer_cBB(this: *const c_void, buffer: *mut c_void, src: *mut c_void) -> i32;
	fn tsDevice_clearBuffer_cBFzpz(this: *const c_void, buffer: *mut c_void, format: Format, offset: usize, src: *const c_void, size: usize) -> i32;
	fn tsDevice_clearBuffer_cBFpz(this: *const c_void, buffer: *mut c_void, format: Format, src: *const c_void, size: usize) -> i32;
	fn tsDevice_clearBuffer_cBFp(this: *const c_void, buffer: *mut c_void, format: Format, src: *const c_void) -> i32;
	fn tsDevice_clearBuffer_cB(this: *const c_void, buffer: *mut c_void) -> i32;
	fn tsDevice_bindBuffer_cBcAcAbF(this: *const c_void, buffer: *mut c_void, offsets: *const usize, offsets_size: u32, sizes: *const usize, sizes_size: u32, commit: i32, fence: *mut c_void) -> i32;
	fn tsDevice_bindBuffer_cBcAcAb(this: *const c_void, buffer: *mut c_void, offsets: *const usize, offsets_size: u32, sizes: *const usize, sizes_size: u32, commit: i32) -> i32;
	fn tsDevice_bindBuffer_cBzzbF(this: *const c_void, buffer: *mut c_void, offset: usize, size: usize, commit: i32, fence: *mut c_void) -> i32;
	fn tsDevice_bindBuffer_cBzzb(this: *const c_void, buffer: *mut c_void, offset: usize, size: usize, commit: i32) -> i32;
	fn tsDevice_flushBuffer(this: *const c_void, buffer: *mut c_void, flags: BufferFlags) -> i32;
	fn tsDevice_flushBuffers_ccABBF(this: *const c_void, buffers: *const *mut c_void, buffers_size: u32, flags: BufferFlags) -> i32;
	fn tsDevice_releaseBuffer(this: *const c_void, buffer: *mut c_void);
	fn tsDevice_releaseSampler(this: *const c_void, sampler: *mut c_void);
	fn tsDevice_setTexture_cTcOcScIcS(this: *const c_void, texture: *mut c_void, dest_origin: *const Origin, dest_slice: *const Slice, image: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsDevice_setTexture_cTcOcI(this: *const c_void, texture: *mut c_void, dest_origin: *const Origin, image: *mut c_void) -> i32;
	fn tsDevice_setTexture_cTcScI(this: *const c_void, texture: *mut c_void, dest_slice: *const Slice, image: *mut c_void) -> i32;
	fn tsDevice_setTexture_cTcI(this: *const c_void, texture: *mut c_void, image: *mut c_void) -> i32;
	fn tsDevice_getTexture_cTcSIcS(this: *const c_void, texture: *mut c_void, src_slice: *const Slice, image: *mut c_void, dest_slice: *const Slice) -> i32;
	fn tsDevice_getTexture_cTIcS(this: *const c_void, texture: *mut c_void, image: *mut c_void, dest_slice: *const Slice) -> i32;
	fn tsDevice_getTexture_cTI(this: *const c_void, texture: *mut c_void, image: *mut c_void) -> i32;
	fn tsDevice_copyTexture_cTcOcSTcRcS(this: *const c_void, texture: *mut c_void, dest_origin: *const Origin, dest_slice: *const Slice, src: *mut c_void, src_region: *const Region, src_slice: *const Slice) -> i32;
	fn tsDevice_copyTexture_cTcOTcR(this: *const c_void, texture: *mut c_void, dest_origin: *const Origin, src: *mut c_void, src_region: *const Region) -> i32;
	fn tsDevice_copyTexture_cTcSTcS(this: *const c_void, texture: *mut c_void, dest_slice: *const Slice, src: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsDevice_copyTexture_cTT(this: *const c_void, texture: *mut c_void, src: *mut c_void) -> i32;
	fn tsDevice_clearTexture_cTcRcSp(this: *const c_void, texture: *mut c_void, region: *const Region, slice: *const Slice, src: *const c_void) -> i32;
	fn tsDevice_clearTexture_cTcRp(this: *const c_void, texture: *mut c_void, region: *const Region, src: *const c_void) -> i32;
	fn tsDevice_clearTexture_cTcSp(this: *const c_void, texture: *mut c_void, slice: *const Slice, src: *const c_void) -> i32;
	fn tsDevice_clearTexture_cTp(this: *const c_void, texture: *mut c_void, src: *const c_void) -> i32;
	fn tsDevice_bindTexture_cTcRucSubF(this: *const c_void, texture: *mut c_void, regions: *const Region, num_regions: u32, slices: *const Slice, num_slices: u32, commit: i32, fence: *mut c_void) -> i32;
	fn tsDevice_bindTexture_cTcRucSub(this: *const c_void, texture: *mut c_void, regions: *const Region, num_regions: u32, slices: *const Slice, num_slices: u32, commit: i32) -> i32;
	fn tsDevice_bindTexture_cTcRcSbF(this: *const c_void, texture: *mut c_void, region: *const Region, slice: *const Slice, commit: i32, fence: *mut c_void) -> i32;
	fn tsDevice_bindTexture_cTcRcSb(this: *const c_void, texture: *mut c_void, region: *const Region, slice: *const Slice, commit: i32) -> i32;
	fn tsDevice_createMipmaps_cTcS(this: *const c_void, texture: *mut c_void, slice: *const Slice) -> i32;
	fn tsDevice_createMipmaps_cT(this: *const c_void, texture: *mut c_void) -> i32;
	fn tsDevice_flushTexture_cTTF(this: *const c_void, texture: *mut c_void, flags: TextureFlags) -> i32;
	fn tsDevice_flushTexture_cTcSTF(this: *const c_void, texture: *mut c_void, slice: *const Slice, flags: TextureFlags) -> i32;
	fn tsDevice_flushTextures_ccATTF(this: *const c_void, textures: *const *mut c_void, textures_size: u32, flags: TextureFlags) -> i32;
	fn tsDevice_releaseTexture(this: *const c_void, texture: *mut c_void);
	fn tsDevice_setTracing(this: *const c_void, tracing: *mut c_void, instances: *const TracingInstance, num_instances: u32) -> i32;
	fn tsDevice_buildTracing_cTBTF(this: *const c_void, tracing: *mut c_void, buffer: *mut c_void, flags: TracingFlags) -> i32;
	fn tsDevice_buildTracing_cTBzTF(this: *const c_void, tracing: *mut c_void, buffer: *mut c_void, offset: usize, flags: TracingFlags) -> i32;
	fn tsDevice_buildTracings_ccATBTF(this: *const c_void, tracings: *const *mut c_void, tracings_size: u32, buffer: *mut c_void, flags: TracingFlags) -> i32;
	fn tsDevice_buildTracings_ccATBzTF(this: *const c_void, tracings: *const *mut c_void, tracings_size: u32, buffer: *mut c_void, offset: usize, flags: TracingFlags) -> i32;
	fn tsDevice_copyTracing(this: *const c_void, tracing: *mut c_void, buffer: *mut c_void, offset: usize) -> i32;
	fn tsDevice_copyTracings(this: *const c_void, tracings: *const *mut c_void, tracings_size: u32, buffer: *mut c_void, offset: usize, stride: usize) -> i32;
	fn tsDevice_flushTracing(this: *const c_void, tracing: *mut c_void) -> i32;
	fn tsDevice_flushTracings(this: *const c_void, tracings: *const *mut c_void, tracings_size: u32) -> i32;
	fn tsDevice_releaseTracing(this: *const c_void, tracing: *mut c_void);
	fn tsDevice_setBufferTable_cBTuBb(this: *const c_void, table: *mut c_void, index: u32, buffer: *mut c_void, owner: i32) -> i32;
	fn tsDevice_setBufferTable_cBTucABb(this: *const c_void, table: *mut c_void, index: u32, buffers: *const *mut c_void, buffers_size: u32, owner: i32) -> i32;
	fn tsDevice_releaseBufferTable(this: *const c_void, table: *mut c_void);
	fn tsDevice_setTextureTable_cTTuTb(this: *const c_void, table: *mut c_void, index: u32, texture: *mut c_void, owner: i32) -> i32;
	fn tsDevice_setTextureTable_cTTucATb(this: *const c_void, table: *mut c_void, index: u32, textures: *const *mut c_void, textures_size: u32, owner: i32) -> i32;
	fn tsDevice_releaseTextureTable(this: *const c_void, table: *mut c_void);
	fn tsDevice_beginQuery(this: *const c_void, query: *mut c_void) -> i32;
	fn tsDevice_endQuery(this: *const c_void, query: *mut c_void);
	fn tsDevice_copyQuery(this: *const c_void, query: *mut c_void, buffer: *mut c_void, offset: usize) -> i32;
	fn tsDevice_copyQueries_ccAQBzz(this: *const c_void, queries: *const *mut c_void, queries_size: u32, buffer: *mut c_void, offset: usize, stride: usize) -> i32;
	fn tsDevice_waitFence(this: *const c_void, fence: *mut c_void) -> i32;
	fn tsDevice_signalFence(this: *const c_void, fence: *mut c_void) -> i32;
	fn tsDevice_execute(this: *const c_void, device: *mut c_void) -> i32;
	fn tsDevice_flip_cF(this: *const c_void, fence: *mut c_void) -> i32;
	fn tsDevice_flip_c(this: *const c_void) -> i32;
	fn tsDevice_flush(this: *const c_void) -> i32;
	fn tsDevice_finish(this: *const c_void) -> i32;
	fn tsDevice_check(this: *const c_void) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceFeatures {
	pub thread_access: u8,
	pub sparse_buffer: u8,
	pub buffer_table: u8,
	pub sparse_texture: u8,
	pub sparse_array_texture: u8,
	pub cube_array_texture: u8,
	pub texture_table: u8,
	pub base_instance_index: u8,
	pub draw_indirect_index: u8,
	pub draw_indirect_count: u8,
	pub task_indirect_count: u8,
	pub vertex_storage: u8,
	pub vertex_index_layer: u8,
	pub geometry_passthrough: u8,
	pub fragment_barycentric: u8,
	pub fragment_stencil_export: u8,
	pub dual_source_blending: u8,
	pub depth_range_one_to_one: u8,
	pub conservative_raster: u8,
	pub conditional_rendering: u8,
	pub ray_tracing: u8,
	pub compute_tracing: u8,
	pub fragment_tracing: u8,
	pub indirect_tracing: u8,
	pub recursion_depth: u32,
	pub subgroup_vote: u8,
	pub subgroup_math: u8,
	pub subgroup_shuffle: u8,
	pub subgroup_size: u32,
	pub min_subgroup_size: u32,
	pub max_subgroup_size: u32,
	pub shaderu8: u8,
	pub shaderf16: u8,
	pub shaderu16: u8,
	pub shaderf64: u8,
	pub shaderu64: u8,
	pub atomic_groupf32: u8,
	pub atomic_groupu64: u8,
	pub atomic_bufferf32: u8,
	pub atomic_bufferu64: u8,
	pub atomic_texturef32: u8,
	pub atomic_textureu32: u8,
	pub atomic_textureu64: u8,
	pub matrix16f16: u8,
	pub matrix16x8x8f16: u8,
	pub matrix16x8x16f16: u8,
	pub matrix16f16f32: u8,
	pub matrix16x8x8f16f32: u8,
	pub matrix16x8x16f16f32: u8,
	pub uniform_alignment: u32,
	pub storage_alignment: u32,
	pub max_texture_samples: u32,
	pub max_texture2d_size: u32,
	pub max_texture3d_size: u32,
	pub max_texture_layers: u32,
	pub max_group_size_x: u32,
	pub max_group_size_y: u32,
	pub max_group_size_z: u32,
	pub max_group_count_x: u32,
	pub max_group_count_y: u32,
	pub max_group_count_z: u32,
	pub max_task_count: u32,
	pub max_task_memory: u32,
	pub max_task_meshes: u32,
	pub max_mesh_memory: u32,
	pub max_mesh_vertices: u32,
	pub max_mesh_primitives: u32,
	pub max_viewport_count: u32,
	pub max_clip_cull_count: u32,
	pub max_uniform_size: u64,
	pub max_storage_size: u64,
	pub group_memory: u32,
	pub video_memory: u64,
	pub vendor_id: u32,
	pub device_id: u32,
	pub pci_bus_id: u32,
	pub pci_domain_id: u32,
	pub pci_device_id: u32,
}
impl fmt::Display for DeviceFeatures {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("thread_access: {0}\n", self.thread_access);
		ret += &format!("sparse_buffer: {0}\n", self.sparse_buffer);
		ret += &format!("buffer_table: {0}\n", self.buffer_table);
		ret += &format!("sparse_texture: {0}\n", self.sparse_texture);
		ret += &format!("sparse_array_texture: {0}\n", self.sparse_array_texture);
		ret += &format!("cube_array_texture: {0}\n", self.cube_array_texture);
		ret += &format!("texture_table: {0}\n", self.texture_table);
		ret += &format!("base_instance_index: {0}\n", self.base_instance_index);
		ret += &format!("draw_indirect_index: {0}\n", self.draw_indirect_index);
		ret += &format!("draw_indirect_count: {0}\n", self.draw_indirect_count);
		ret += &format!("task_indirect_count: {0}\n", self.task_indirect_count);
		ret += &format!("vertex_storage: {0}\n", self.vertex_storage);
		ret += &format!("vertex_index_layer: {0}\n", self.vertex_index_layer);
		ret += &format!("geometry_passthrough: {0}\n", self.geometry_passthrough);
		ret += &format!("fragment_barycentric: {0}\n", self.fragment_barycentric);
		ret += &format!("fragment_stencil_export: {0}\n", self.fragment_stencil_export);
		ret += &format!("dual_source_blending: {0}\n", self.dual_source_blending);
		ret += &format!("depth_range_one_to_one: {0}\n", self.depth_range_one_to_one);
		ret += &format!("conservative_raster: {0}\n", self.conservative_raster);
		ret += &format!("conditional_rendering: {0}\n", self.conditional_rendering);
		ret += &format!("ray_tracing: {0}\n", self.ray_tracing);
		ret += &format!("compute_tracing: {0}\n", self.compute_tracing);
		ret += &format!("fragment_tracing: {0}\n", self.fragment_tracing);
		ret += &format!("indirect_tracing: {0}\n", self.indirect_tracing);
		ret += &format!("recursion_depth: {0}\n", self.recursion_depth);
		ret += &format!("subgroup_vote: {0}\n", self.subgroup_vote);
		ret += &format!("subgroup_math: {0}\n", self.subgroup_math);
		ret += &format!("subgroup_shuffle: {0}\n", self.subgroup_shuffle);
		ret += &format!("subgroup_size: {0}\n", self.subgroup_size);
		ret += &format!("min_subgroup_size: {0}\n", self.min_subgroup_size);
		ret += &format!("max_subgroup_size: {0}\n", self.max_subgroup_size);
		ret += &format!("shaderu8: {0}\n", self.shaderu8);
		ret += &format!("shaderf16: {0}\n", self.shaderf16);
		ret += &format!("shaderu16: {0}\n", self.shaderu16);
		ret += &format!("shaderf64: {0}\n", self.shaderf64);
		ret += &format!("shaderu64: {0}\n", self.shaderu64);
		ret += &format!("atomic_groupf32: {0}\n", self.atomic_groupf32);
		ret += &format!("atomic_groupu64: {0}\n", self.atomic_groupu64);
		ret += &format!("atomic_bufferf32: {0}\n", self.atomic_bufferf32);
		ret += &format!("atomic_bufferu64: {0}\n", self.atomic_bufferu64);
		ret += &format!("atomic_texturef32: {0}\n", self.atomic_texturef32);
		ret += &format!("atomic_textureu32: {0}\n", self.atomic_textureu32);
		ret += &format!("atomic_textureu64: {0}\n", self.atomic_textureu64);
		ret += &format!("matrix16f16: {0}\n", self.matrix16f16);
		ret += &format!("matrix16x8x8f16: {0}\n", self.matrix16x8x8f16);
		ret += &format!("matrix16x8x16f16: {0}\n", self.matrix16x8x16f16);
		ret += &format!("matrix16f16f32: {0}\n", self.matrix16f16f32);
		ret += &format!("matrix16x8x8f16f32: {0}\n", self.matrix16x8x8f16f32);
		ret += &format!("matrix16x8x16f16f32: {0}\n", self.matrix16x8x16f16f32);
		ret += &format!("uniform_alignment: {0}\n", self.uniform_alignment);
		ret += &format!("storage_alignment: {0}\n", self.storage_alignment);
		ret += &format!("max_texture_samples: {0}\n", self.max_texture_samples);
		ret += &format!("max_texture2d_size: {0}\n", self.max_texture2d_size);
		ret += &format!("max_texture3d_size: {0}\n", self.max_texture3d_size);
		ret += &format!("max_texture_layers: {0}\n", self.max_texture_layers);
		ret += &format!("max_group_size_x: {0}\n", self.max_group_size_x);
		ret += &format!("max_group_size_y: {0}\n", self.max_group_size_y);
		ret += &format!("max_group_size_z: {0}\n", self.max_group_size_z);
		ret += &format!("max_group_count_x: {0}\n", self.max_group_count_x);
		ret += &format!("max_group_count_y: {0}\n", self.max_group_count_y);
		ret += &format!("max_group_count_z: {0}\n", self.max_group_count_z);
		ret += &format!("max_task_count: {0}\n", self.max_task_count);
		ret += &format!("max_task_memory: {0}\n", self.max_task_memory);
		ret += &format!("max_task_meshes: {0}\n", self.max_task_meshes);
		ret += &format!("max_mesh_memory: {0}\n", self.max_mesh_memory);
		ret += &format!("max_mesh_vertices: {0}\n", self.max_mesh_vertices);
		ret += &format!("max_mesh_primitives: {0}\n", self.max_mesh_primitives);
		ret += &format!("max_viewport_count: {0}\n", self.max_viewport_count);
		ret += &format!("max_clip_cull_count: {0}\n", self.max_clip_cull_count);
		ret += &format!("max_uniform_size: {0}\n", self.max_uniform_size);
		ret += &format!("max_storage_size: {0}\n", self.max_storage_size);
		ret += &format!("group_memory: {0}\n", self.group_memory);
		ret += &format!("video_memory: {0}\n", self.video_memory);
		ret += &format!("vendor_id: 0x{0:x}\n", self.vendor_id);
		ret += &format!("device_id: 0x{0:x}\n", self.device_id);
		ret += &format!("pci_bus_id: 0x{0:x}\n", self.pci_bus_id);
		ret += &format!("pci_domain_id: 0x{0:x}\n", self.pci_domain_id);
		ret += &format!("pci_device_id: 0x{0:x}", self.pci_device_id);
		write!(f, "{0}", ret)
	}
}

// Tellusim::D3D12Device
pub struct D3D12Device {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Device {
	pub fn null() -> D3D12Device { D3D12Device { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_new(), owner: true } } }
	pub fn new_with_context(context: &mut Context) -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_new_C(context.this), owner: true } } }
	pub fn new_with_surface(surface: &mut Surface) -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_new_S(surface.this), owner: true } } }
	pub fn new_with_window(window: &mut Window) -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_new_W(window.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Device { unsafe { D3D12Device { this: ptr, owner: tsD3D12Device_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_copyPtr(self.this), owner: true } } }
	pub fn from_device(ptr: &Device) -> D3D12Device { unsafe { D3D12Device::new_ptr(tsD3D12Device_castDevicePtr(ptr.this)) } }
	pub fn to_device(&self) -> Device { unsafe { Device::new_ptr(tsD3D12Device_baseDevicePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Device) -> bool { unsafe { tsD3D12Device_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Device_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Device_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Device_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Device_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Device_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Device_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Device_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Device_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Device_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_buffer_state(&mut self, buffer: &mut Buffer, state: u32) { unsafe { tsD3D12Device_setBufferState(self.this, buffer.this, state) } }
	pub fn set_texture_state(&mut self, texture: &mut Texture, state: u32) { unsafe { tsD3D12Device_setTextureState(self.this, texture.this, state) } }
	pub fn d3d12_device(&self) -> *const c_void { unsafe { tsD3D12Device_getD3D12Device(self.this) } }
	pub fn queue(&self) -> *const c_void { unsafe { tsD3D12Device_getQueue(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsD3D12Device_getCommand(self.this) } }
}
impl DeviceTrait for D3D12Device {
	fn platform(&self) -> Platform { unsafe { tsDevice_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsDevice_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsDevice_getIndex(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsDevice_getName(self.this)) } }
	fn vendor(&self) -> string::String { unsafe { get_string(tsDevice_getVendor(self.this)) } }
	fn version(&self) -> string::String { unsafe { get_string(tsDevice_getVersion(self.this)) } }
	fn features(&self) -> DeviceFeatures { unsafe { tsDevice_getFeatures(self.this) } }
	fn has_query(&self, type_: QueryType) -> bool { unsafe { tsDevice_hasQuery(self.this, type_) != 0 } }
	fn has_shader(&self, type_: ShaderType) -> bool { unsafe { tsDevice_hasShader(self.this, type_) != 0 } }
	fn has_target(&self, format: Format) -> bool { unsafe { tsDevice_hasTarget(self.this, format) != 0 } }
	fn has_texture(&self, format: Format) -> bool { unsafe { tsDevice_hasTexture(self.this, format) != 0 } }
	fn has_surface(&self, format: Format) -> bool { unsafe { tsDevice_hasSurface(self.this, format) != 0 } }
	fn create_device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, 3)) } }
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, frames)) } }
	fn create_command_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, 3)) } }
	fn create_command_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, frames)) } }
	fn create_compute_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, 3)) } }
	fn create_compute_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, frames)) } }
	fn create_copy_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, 3)) } }
	fn create_copy_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, frames)) } }
	fn create_query(&self) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_c(self.this)) } }
	fn create_query_with_type(&self, type_: QueryType) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_cQT(self.this, type_)) } }
	fn create_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_c(self.this)) } }
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cF(self.this, shared.this)) } }
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cFF(self.this, flags)) } }
	fn create_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_c(self.this)) } }
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cB(self.this, shared.this)) } }
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, Format::Unknown)) } }
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, format)) } }
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, Format::Unknown)) } }
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, format)) } }
	fn create_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_c(self.this)) } }
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_ccS(self.this, sampler.this)) } }
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, SamplerWrapMode::Repeat, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, anisotropy)) } }
	fn create_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_c(self.this)) } }
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cT(self.this, shared.this)) } }
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, TextureFlags::None)) } }
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, flags)) } }
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, TextureFlags::None)) } }
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, flags)) } }
	fn create_texture_with_image(&self, image: &Image) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, TextureFlags::None, ptr::null_mut())) } }
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, ptr::null_mut())) } }
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture3d(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, flags)) } }
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, TextureFlags::None)) } }
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, flags)) } }
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, TextureFlags::None)) } }
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, flags)) } }
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, TextureFlags::None)) } }
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, flags)) } }
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, TextureFlags::None)) } }
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, flags)) } }
	fn load_texture(&self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) }
	}
	fn load_texture_with_name(&self, name: &String) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_c(self.this)) } }
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_ccT(self.this, tracing.this)) } }
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, flags)) } }
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, TracingFlags::None)) } }
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)) } }
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, flags)) } }
	fn create_buffer_table(&self) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_c(self.this)) } }
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_cu(self.this, size)) } }
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, 0)) }
	}
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0})) }
	}
	fn create_texture_table(&self) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_c(self.this)) } }
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_cTTu(self.this, type_, size)) } }
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, 0)) }
	}
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0})) }
	}
	fn create_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShader_c(self.this)) } }
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderSPIRV(self.this, type_, name_.as_ptr())) }
	}
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32)) } }
	fn create_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_c(self.this)) } }
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_ccK(self.this, kernel.this)) } }
	fn release_kernel(&self, kernel: &mut Kernel) { unsafe { tsDevice_releaseKernel(self.this, kernel.this) } }
	fn create_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_c(self.this)) } }
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_ccP(self.this, pipeline.this)) } }
	fn release_pipeline(&self, pipeline: &mut Pipeline) { unsafe { tsDevice_releasePipeline(self.this, pipeline.this) } }
	fn create_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_c(self.this)) } }
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_ccT(self.this, traversal.this)) } }
	fn release_traversal(&self, traversal: &mut Traversal) { unsafe { tsDevice_releaseTraversal(self.this, traversal.this) } }
	fn create_target(&self) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_c(self.this)) } }
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cS(self.this, surface.this)) } }
	fn create_target_with_window(&self, window: &mut Window) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cW(self.this, window.this)) } }
	fn create_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsDevice_createCompute(self.this)) } }
	fn create_command(&self) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_c(self.this)) } }
	fn create_command_with_target(&self, target: &mut Target) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_cT(self.this, target.this)) } }
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsDevice_setBuffer_cBp(self.this, buffer.this, src) != 0 } }
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBzprz(self.this, buffer.this, offset, dest, size) != 0 } }
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBprz(self.this, buffer.this, dest, size) != 0 } }
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool { unsafe { tsDevice_getBuffer_cBpr(self.this, buffer.this, dest) != 0 } }
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBzz(self.this, buffer.this, offset, size) } }
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBz(self.this, buffer.this, size) } }
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void { unsafe { tsDevice_mapBuffer_cB(self.this, buffer.this) } }
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_unmapBuffer(self.this, buffer.this) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsDevice_copyBuffer_cBB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsDevice_clearBuffer_cBFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_clearBuffer_cB(self.this, buffer.this) != 0 } }
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAbF(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAb(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBzzbF(self.this, buffer.this, offset, size, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBzzb(self.this, buffer.this, offset, size, if commit {1} else {0}) != 0 } }
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, BufferFlags::None) != 0 } }
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, flags) != 0 } }
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, BufferFlags::None) != 0 }
	}
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, flags) != 0 }
	}
	fn release_buffer(&self, buffer: &mut Buffer) { unsafe { tsDevice_releaseBuffer(self.this, buffer.this) } }
	fn release_sampler(&self, sampler: &mut Sampler) { unsafe { tsDevice_releaseSampler(self.this, sampler.this) } }
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcI(self.this, texture.this, image.this) != 0 } }
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTcSIcS(self.this, texture.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTIcS(self.this, texture.this, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool { unsafe { tsDevice_getTexture_cTI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsDevice_copyTexture_cTcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDevice_copyTexture_cTT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTp(self.this, texture.this, src) != 0 } }
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindTexture_cTcRucSubF(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool { unsafe { tsDevice_bindTexture_cTcRucSub(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSbF(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}, fence.this) != 0 }
	}
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSb(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}) != 0 }
	}
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_createMipmaps_cTcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	fn create_mipmaps(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_createMipmaps_cT(self.this, texture.this) != 0 } }
	fn flush_texture(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, TextureFlags::None) != 0 } }
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, flags) != 0 } }
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, TextureFlags::None) != 0 }
	}
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, flags) != 0 }
	}
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, TextureFlags::None) != 0 }
	}
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, flags) != 0 }
	}
	fn release_texture(&self, texture: &mut Texture) { unsafe { tsDevice_releaseTexture(self.this, texture.this) } }
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool { unsafe { tsDevice_setTracing(self.this, tracing.this, instances.as_ptr(), instances.len() as u32) != 0 } }
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, TracingFlags::None) != 0 } }
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, flags) != 0 } }
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, TracingFlags::None) != 0 } }
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, flags) != 0 } }
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, flags) != 0 }
	}
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, flags) != 0 }
	}
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, 0) != 0 } }
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, offset) != 0 } }
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool { unsafe { tsDevice_flushTracing(self.this, tracing.this) != 0 } }
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_flushTracings(self.this, tracings_.as_ptr(), tracings.len() as u32) != 0 }
	}
	fn release_tracing(&self, tracing: &mut Tracing) { unsafe { tsDevice_releaseTracing(self.this, tracing.this) } }
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, 0) != 0 } }
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, if owner {1} else {0}) != 0 } }
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, 0) != 0 }
	}
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_buffer_table(&self, table: &mut BufferTable) { unsafe { tsDevice_releaseBufferTable(self.this, table.this) } }
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, 0) != 0 } }
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, if owner {1} else {0}) != 0 } }
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, 0) != 0 }
	}
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_texture_table(&self, table: &mut TextureTable) { unsafe { tsDevice_releaseTextureTable(self.this, table.this) } }
	fn begin_query(&self, query: &mut Query) -> bool { unsafe { tsDevice_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&self, query: &mut Query) { unsafe { tsDevice_endQuery(self.this, query.this) } }
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, 0) != 0 } }
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, offset) != 0 } }
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, 0, 0) != 0 }
	}
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn wait_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_waitFence(self.this, fence.this) != 0 } }
	fn signal_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_signalFence(self.this, fence.this) != 0 } }
	fn execute(&self, device: &mut Device) -> bool { unsafe { tsDevice_execute(self.this, device.this) != 0 } }
	fn flip_with_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_flip_cF(self.this, fence.this) != 0 } }
	fn flip(&self) -> bool { unsafe { tsDevice_flip_c(self.this) != 0 } }
	fn flush(&self) -> bool { unsafe { tsDevice_flush(self.this) != 0 } }
	fn finish(&self) -> bool { unsafe { tsDevice_finish(self.this) != 0 } }
	fn check(&self) -> bool { unsafe { tsDevice_check(self.this) != 0 } }
}
impl Drop for D3D12Device {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Device_delete(self.this) } } }
}
impl Clone for D3D12Device {
	fn clone(&self) -> D3D12Device { unsafe { D3D12Device { this: tsD3D12Device_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Device { }
impl fmt::Display for D3D12Device {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Device ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Device_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Device_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Device_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Device_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Device_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Device_new() -> *mut c_void;
	fn tsD3D12Device_new_C(context: *mut c_void) -> *mut c_void;
	fn tsD3D12Device_new_S(surface: *mut c_void) -> *mut c_void;
	fn tsD3D12Device_new_W(window: *mut c_void) -> *mut c_void;
	fn tsD3D12Device_delete(this: *mut c_void);
	fn tsD3D12Device_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Device_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Device_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Device_clearPtr(this: *const c_void);
	fn tsD3D12Device_destroyPtr(this: *const c_void);
	fn tsD3D12Device_acquirePtr(this: *const c_void);
	fn tsD3D12Device_unacquirePtr(this: *const c_void);
	fn tsD3D12Device_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Device_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Device_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Device_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Device_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Device_equalDevicePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Device_castDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Device_baseDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Device_setBufferState(this: *mut c_void, buffer: *mut c_void, state: u32);
	fn tsD3D12Device_setTextureState(this: *mut c_void, texture: *mut c_void, state: u32);
	fn tsD3D12Device_getD3D12Device(this: *const c_void) -> *const c_void;
	fn tsD3D12Device_getQueue(this: *const c_void) -> *const c_void;
	fn tsD3D12Device_getCommand(this: *const c_void) -> *const c_void;
}

// Tellusim::D3D11Device
pub struct D3D11Device {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Device {
	pub fn null() -> D3D11Device { D3D11Device { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_new(), owner: true } } }
	pub fn new_with_context(context: &mut Context) -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_new_C(context.this), owner: true } } }
	pub fn new_with_surface(surface: &mut Surface) -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_new_S(surface.this), owner: true } } }
	pub fn new_with_window(window: &mut Window) -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_new_W(window.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Device { unsafe { D3D11Device { this: ptr, owner: tsD3D11Device_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_copyPtr(self.this), owner: true } } }
	pub fn from_device(ptr: &Device) -> D3D11Device { unsafe { D3D11Device::new_ptr(tsD3D11Device_castDevicePtr(ptr.this)) } }
	pub fn to_device(&self) -> Device { unsafe { Device::new_ptr(tsD3D11Device_baseDevicePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Device) -> bool { unsafe { tsD3D11Device_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Device_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Device_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Device_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Device_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Device_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Device_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Device_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Device_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Device_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn d3d11_device(&self) -> *const c_void { unsafe { tsD3D11Device_getD3D11Device(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsD3D11Device_getCommand(self.this) } }
}
impl DeviceTrait for D3D11Device {
	fn platform(&self) -> Platform { unsafe { tsDevice_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsDevice_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsDevice_getIndex(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsDevice_getName(self.this)) } }
	fn vendor(&self) -> string::String { unsafe { get_string(tsDevice_getVendor(self.this)) } }
	fn version(&self) -> string::String { unsafe { get_string(tsDevice_getVersion(self.this)) } }
	fn features(&self) -> DeviceFeatures { unsafe { tsDevice_getFeatures(self.this) } }
	fn has_query(&self, type_: QueryType) -> bool { unsafe { tsDevice_hasQuery(self.this, type_) != 0 } }
	fn has_shader(&self, type_: ShaderType) -> bool { unsafe { tsDevice_hasShader(self.this, type_) != 0 } }
	fn has_target(&self, format: Format) -> bool { unsafe { tsDevice_hasTarget(self.this, format) != 0 } }
	fn has_texture(&self, format: Format) -> bool { unsafe { tsDevice_hasTexture(self.this, format) != 0 } }
	fn has_surface(&self, format: Format) -> bool { unsafe { tsDevice_hasSurface(self.this, format) != 0 } }
	fn create_device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, 3)) } }
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, frames)) } }
	fn create_command_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, 3)) } }
	fn create_command_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, frames)) } }
	fn create_compute_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, 3)) } }
	fn create_compute_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, frames)) } }
	fn create_copy_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, 3)) } }
	fn create_copy_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, frames)) } }
	fn create_query(&self) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_c(self.this)) } }
	fn create_query_with_type(&self, type_: QueryType) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_cQT(self.this, type_)) } }
	fn create_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_c(self.this)) } }
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cF(self.this, shared.this)) } }
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cFF(self.this, flags)) } }
	fn create_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_c(self.this)) } }
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cB(self.this, shared.this)) } }
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, Format::Unknown)) } }
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, format)) } }
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, Format::Unknown)) } }
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, format)) } }
	fn create_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_c(self.this)) } }
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_ccS(self.this, sampler.this)) } }
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, SamplerWrapMode::Repeat, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, anisotropy)) } }
	fn create_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_c(self.this)) } }
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cT(self.this, shared.this)) } }
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, TextureFlags::None)) } }
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, flags)) } }
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, TextureFlags::None)) } }
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, flags)) } }
	fn create_texture_with_image(&self, image: &Image) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, TextureFlags::None, ptr::null_mut())) } }
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, ptr::null_mut())) } }
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture3d(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, flags)) } }
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, TextureFlags::None)) } }
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, flags)) } }
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, TextureFlags::None)) } }
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, flags)) } }
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, TextureFlags::None)) } }
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, flags)) } }
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, TextureFlags::None)) } }
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, flags)) } }
	fn load_texture(&self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) }
	}
	fn load_texture_with_name(&self, name: &String) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_c(self.this)) } }
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_ccT(self.this, tracing.this)) } }
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, flags)) } }
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, TracingFlags::None)) } }
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)) } }
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, flags)) } }
	fn create_buffer_table(&self) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_c(self.this)) } }
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_cu(self.this, size)) } }
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, 0)) }
	}
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0})) }
	}
	fn create_texture_table(&self) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_c(self.this)) } }
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_cTTu(self.this, type_, size)) } }
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, 0)) }
	}
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0})) }
	}
	fn create_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShader_c(self.this)) } }
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderSPIRV(self.this, type_, name_.as_ptr())) }
	}
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32)) } }
	fn create_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_c(self.this)) } }
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_ccK(self.this, kernel.this)) } }
	fn release_kernel(&self, kernel: &mut Kernel) { unsafe { tsDevice_releaseKernel(self.this, kernel.this) } }
	fn create_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_c(self.this)) } }
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_ccP(self.this, pipeline.this)) } }
	fn release_pipeline(&self, pipeline: &mut Pipeline) { unsafe { tsDevice_releasePipeline(self.this, pipeline.this) } }
	fn create_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_c(self.this)) } }
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_ccT(self.this, traversal.this)) } }
	fn release_traversal(&self, traversal: &mut Traversal) { unsafe { tsDevice_releaseTraversal(self.this, traversal.this) } }
	fn create_target(&self) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_c(self.this)) } }
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cS(self.this, surface.this)) } }
	fn create_target_with_window(&self, window: &mut Window) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cW(self.this, window.this)) } }
	fn create_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsDevice_createCompute(self.this)) } }
	fn create_command(&self) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_c(self.this)) } }
	fn create_command_with_target(&self, target: &mut Target) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_cT(self.this, target.this)) } }
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsDevice_setBuffer_cBp(self.this, buffer.this, src) != 0 } }
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBzprz(self.this, buffer.this, offset, dest, size) != 0 } }
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBprz(self.this, buffer.this, dest, size) != 0 } }
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool { unsafe { tsDevice_getBuffer_cBpr(self.this, buffer.this, dest) != 0 } }
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBzz(self.this, buffer.this, offset, size) } }
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBz(self.this, buffer.this, size) } }
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void { unsafe { tsDevice_mapBuffer_cB(self.this, buffer.this) } }
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_unmapBuffer(self.this, buffer.this) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsDevice_copyBuffer_cBB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsDevice_clearBuffer_cBFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_clearBuffer_cB(self.this, buffer.this) != 0 } }
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAbF(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAb(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBzzbF(self.this, buffer.this, offset, size, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBzzb(self.this, buffer.this, offset, size, if commit {1} else {0}) != 0 } }
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, BufferFlags::None) != 0 } }
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, flags) != 0 } }
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, BufferFlags::None) != 0 }
	}
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, flags) != 0 }
	}
	fn release_buffer(&self, buffer: &mut Buffer) { unsafe { tsDevice_releaseBuffer(self.this, buffer.this) } }
	fn release_sampler(&self, sampler: &mut Sampler) { unsafe { tsDevice_releaseSampler(self.this, sampler.this) } }
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcI(self.this, texture.this, image.this) != 0 } }
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTcSIcS(self.this, texture.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTIcS(self.this, texture.this, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool { unsafe { tsDevice_getTexture_cTI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsDevice_copyTexture_cTcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDevice_copyTexture_cTT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTp(self.this, texture.this, src) != 0 } }
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindTexture_cTcRucSubF(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool { unsafe { tsDevice_bindTexture_cTcRucSub(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSbF(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}, fence.this) != 0 }
	}
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSb(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}) != 0 }
	}
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_createMipmaps_cTcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	fn create_mipmaps(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_createMipmaps_cT(self.this, texture.this) != 0 } }
	fn flush_texture(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, TextureFlags::None) != 0 } }
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, flags) != 0 } }
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, TextureFlags::None) != 0 }
	}
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, flags) != 0 }
	}
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, TextureFlags::None) != 0 }
	}
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, flags) != 0 }
	}
	fn release_texture(&self, texture: &mut Texture) { unsafe { tsDevice_releaseTexture(self.this, texture.this) } }
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool { unsafe { tsDevice_setTracing(self.this, tracing.this, instances.as_ptr(), instances.len() as u32) != 0 } }
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, TracingFlags::None) != 0 } }
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, flags) != 0 } }
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, TracingFlags::None) != 0 } }
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, flags) != 0 } }
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, flags) != 0 }
	}
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, flags) != 0 }
	}
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, 0) != 0 } }
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, offset) != 0 } }
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool { unsafe { tsDevice_flushTracing(self.this, tracing.this) != 0 } }
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_flushTracings(self.this, tracings_.as_ptr(), tracings.len() as u32) != 0 }
	}
	fn release_tracing(&self, tracing: &mut Tracing) { unsafe { tsDevice_releaseTracing(self.this, tracing.this) } }
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, 0) != 0 } }
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, if owner {1} else {0}) != 0 } }
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, 0) != 0 }
	}
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_buffer_table(&self, table: &mut BufferTable) { unsafe { tsDevice_releaseBufferTable(self.this, table.this) } }
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, 0) != 0 } }
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, if owner {1} else {0}) != 0 } }
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, 0) != 0 }
	}
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_texture_table(&self, table: &mut TextureTable) { unsafe { tsDevice_releaseTextureTable(self.this, table.this) } }
	fn begin_query(&self, query: &mut Query) -> bool { unsafe { tsDevice_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&self, query: &mut Query) { unsafe { tsDevice_endQuery(self.this, query.this) } }
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, 0) != 0 } }
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, offset) != 0 } }
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, 0, 0) != 0 }
	}
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn wait_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_waitFence(self.this, fence.this) != 0 } }
	fn signal_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_signalFence(self.this, fence.this) != 0 } }
	fn execute(&self, device: &mut Device) -> bool { unsafe { tsDevice_execute(self.this, device.this) != 0 } }
	fn flip_with_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_flip_cF(self.this, fence.this) != 0 } }
	fn flip(&self) -> bool { unsafe { tsDevice_flip_c(self.this) != 0 } }
	fn flush(&self) -> bool { unsafe { tsDevice_flush(self.this) != 0 } }
	fn finish(&self) -> bool { unsafe { tsDevice_finish(self.this) != 0 } }
	fn check(&self) -> bool { unsafe { tsDevice_check(self.this) != 0 } }
}
impl Drop for D3D11Device {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Device_delete(self.this) } } }
}
impl Clone for D3D11Device {
	fn clone(&self) -> D3D11Device { unsafe { D3D11Device { this: tsD3D11Device_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Device { }
impl fmt::Display for D3D11Device {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Device ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Device_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Device_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Device_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Device_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Device_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Device_new() -> *mut c_void;
	fn tsD3D11Device_new_C(context: *mut c_void) -> *mut c_void;
	fn tsD3D11Device_new_S(surface: *mut c_void) -> *mut c_void;
	fn tsD3D11Device_new_W(window: *mut c_void) -> *mut c_void;
	fn tsD3D11Device_delete(this: *mut c_void);
	fn tsD3D11Device_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Device_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Device_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Device_clearPtr(this: *const c_void);
	fn tsD3D11Device_destroyPtr(this: *const c_void);
	fn tsD3D11Device_acquirePtr(this: *const c_void);
	fn tsD3D11Device_unacquirePtr(this: *const c_void);
	fn tsD3D11Device_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Device_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Device_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Device_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Device_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Device_equalDevicePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Device_castDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Device_baseDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Device_getD3D11Device(this: *const c_void) -> *const c_void;
	fn tsD3D11Device_getCommand(this: *const c_void) -> *const c_void;
}

// Tellusim::MTLDevice
pub struct MTLDevice {
	this: *mut c_void,
	owner: bool,
}
impl MTLDevice {
	pub fn null() -> MTLDevice { MTLDevice { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_new(), owner: true } } }
	pub fn new_with_context(context: &mut Context) -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_new_C(context.this), owner: true } } }
	pub fn new_with_surface(surface: &mut Surface) -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_new_S(surface.this), owner: true } } }
	pub fn new_with_window(window: &mut Window) -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_new_W(window.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLDevice { unsafe { MTLDevice { this: ptr, owner: tsMTLDevice_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_copyPtr(self.this), owner: true } } }
	pub fn from_device(ptr: &Device) -> MTLDevice { unsafe { MTLDevice::new_ptr(tsMTLDevice_castDevicePtr(ptr.this)) } }
	pub fn to_device(&self) -> Device { unsafe { Device::new_ptr(tsMTLDevice_baseDevicePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLDevice) -> bool { unsafe { tsMTLDevice_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLDevice_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLDevice_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLDevice_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLDevice_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLDevice_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLDevice_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLDevice_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLDevice_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLDevice_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn mtl_device(&self) -> *mut c_void { unsafe { tsMTLDevice_getMTLDevice(self.this) } }
	pub fn queue(&self) -> *mut c_void { unsafe { tsMTLDevice_getQueue(self.this) } }
	pub fn command(&self) -> *mut c_void { unsafe { tsMTLDevice_getCommand(self.this) } }
	pub fn encoder(&self) -> *mut c_void { unsafe { tsMTLDevice_getEncoder(self.this) } }
	pub fn render_encoder(&self, descriptor: *mut c_void) -> *mut c_void { unsafe { tsMTLDevice_getRenderEncoder(self.this, descriptor) } }
	pub fn compute_encoder(&self) -> *mut c_void { unsafe { tsMTLDevice_getComputeEncoder(self.this) } }
	pub fn tracing_encoder(&self) -> *mut c_void { unsafe { tsMTLDevice_getTracingEncoder(self.this) } }
	pub fn blit_encoder(&self) -> *mut c_void { unsafe { tsMTLDevice_getBlitEncoder(self.this) } }
	pub fn end_encoder(&self) { unsafe { tsMTLDevice_endEncoder(self.this) } }
}
impl DeviceTrait for MTLDevice {
	fn platform(&self) -> Platform { unsafe { tsDevice_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsDevice_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsDevice_getIndex(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsDevice_getName(self.this)) } }
	fn vendor(&self) -> string::String { unsafe { get_string(tsDevice_getVendor(self.this)) } }
	fn version(&self) -> string::String { unsafe { get_string(tsDevice_getVersion(self.this)) } }
	fn features(&self) -> DeviceFeatures { unsafe { tsDevice_getFeatures(self.this) } }
	fn has_query(&self, type_: QueryType) -> bool { unsafe { tsDevice_hasQuery(self.this, type_) != 0 } }
	fn has_shader(&self, type_: ShaderType) -> bool { unsafe { tsDevice_hasShader(self.this, type_) != 0 } }
	fn has_target(&self, format: Format) -> bool { unsafe { tsDevice_hasTarget(self.this, format) != 0 } }
	fn has_texture(&self, format: Format) -> bool { unsafe { tsDevice_hasTexture(self.this, format) != 0 } }
	fn has_surface(&self, format: Format) -> bool { unsafe { tsDevice_hasSurface(self.this, format) != 0 } }
	fn create_device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, 3)) } }
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, frames)) } }
	fn create_command_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, 3)) } }
	fn create_command_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, frames)) } }
	fn create_compute_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, 3)) } }
	fn create_compute_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, frames)) } }
	fn create_copy_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, 3)) } }
	fn create_copy_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, frames)) } }
	fn create_query(&self) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_c(self.this)) } }
	fn create_query_with_type(&self, type_: QueryType) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_cQT(self.this, type_)) } }
	fn create_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_c(self.this)) } }
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cF(self.this, shared.this)) } }
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cFF(self.this, flags)) } }
	fn create_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_c(self.this)) } }
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cB(self.this, shared.this)) } }
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, Format::Unknown)) } }
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, format)) } }
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, Format::Unknown)) } }
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, format)) } }
	fn create_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_c(self.this)) } }
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_ccS(self.this, sampler.this)) } }
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, SamplerWrapMode::Repeat, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, anisotropy)) } }
	fn create_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_c(self.this)) } }
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cT(self.this, shared.this)) } }
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, TextureFlags::None)) } }
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, flags)) } }
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, TextureFlags::None)) } }
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, flags)) } }
	fn create_texture_with_image(&self, image: &Image) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, TextureFlags::None, ptr::null_mut())) } }
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, ptr::null_mut())) } }
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture3d(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, flags)) } }
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, TextureFlags::None)) } }
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, flags)) } }
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, TextureFlags::None)) } }
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, flags)) } }
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, TextureFlags::None)) } }
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, flags)) } }
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, TextureFlags::None)) } }
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, flags)) } }
	fn load_texture(&self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) }
	}
	fn load_texture_with_name(&self, name: &String) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_c(self.this)) } }
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_ccT(self.this, tracing.this)) } }
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, flags)) } }
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, TracingFlags::None)) } }
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)) } }
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, flags)) } }
	fn create_buffer_table(&self) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_c(self.this)) } }
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_cu(self.this, size)) } }
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, 0)) }
	}
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0})) }
	}
	fn create_texture_table(&self) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_c(self.this)) } }
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_cTTu(self.this, type_, size)) } }
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, 0)) }
	}
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0})) }
	}
	fn create_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShader_c(self.this)) } }
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderSPIRV(self.this, type_, name_.as_ptr())) }
	}
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32)) } }
	fn create_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_c(self.this)) } }
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_ccK(self.this, kernel.this)) } }
	fn release_kernel(&self, kernel: &mut Kernel) { unsafe { tsDevice_releaseKernel(self.this, kernel.this) } }
	fn create_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_c(self.this)) } }
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_ccP(self.this, pipeline.this)) } }
	fn release_pipeline(&self, pipeline: &mut Pipeline) { unsafe { tsDevice_releasePipeline(self.this, pipeline.this) } }
	fn create_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_c(self.this)) } }
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_ccT(self.this, traversal.this)) } }
	fn release_traversal(&self, traversal: &mut Traversal) { unsafe { tsDevice_releaseTraversal(self.this, traversal.this) } }
	fn create_target(&self) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_c(self.this)) } }
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cS(self.this, surface.this)) } }
	fn create_target_with_window(&self, window: &mut Window) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cW(self.this, window.this)) } }
	fn create_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsDevice_createCompute(self.this)) } }
	fn create_command(&self) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_c(self.this)) } }
	fn create_command_with_target(&self, target: &mut Target) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_cT(self.this, target.this)) } }
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsDevice_setBuffer_cBp(self.this, buffer.this, src) != 0 } }
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBzprz(self.this, buffer.this, offset, dest, size) != 0 } }
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBprz(self.this, buffer.this, dest, size) != 0 } }
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool { unsafe { tsDevice_getBuffer_cBpr(self.this, buffer.this, dest) != 0 } }
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBzz(self.this, buffer.this, offset, size) } }
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBz(self.this, buffer.this, size) } }
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void { unsafe { tsDevice_mapBuffer_cB(self.this, buffer.this) } }
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_unmapBuffer(self.this, buffer.this) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsDevice_copyBuffer_cBB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsDevice_clearBuffer_cBFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_clearBuffer_cB(self.this, buffer.this) != 0 } }
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAbF(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAb(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBzzbF(self.this, buffer.this, offset, size, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBzzb(self.this, buffer.this, offset, size, if commit {1} else {0}) != 0 } }
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, BufferFlags::None) != 0 } }
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, flags) != 0 } }
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, BufferFlags::None) != 0 }
	}
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, flags) != 0 }
	}
	fn release_buffer(&self, buffer: &mut Buffer) { unsafe { tsDevice_releaseBuffer(self.this, buffer.this) } }
	fn release_sampler(&self, sampler: &mut Sampler) { unsafe { tsDevice_releaseSampler(self.this, sampler.this) } }
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcI(self.this, texture.this, image.this) != 0 } }
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTcSIcS(self.this, texture.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTIcS(self.this, texture.this, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool { unsafe { tsDevice_getTexture_cTI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsDevice_copyTexture_cTcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDevice_copyTexture_cTT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTp(self.this, texture.this, src) != 0 } }
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindTexture_cTcRucSubF(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool { unsafe { tsDevice_bindTexture_cTcRucSub(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSbF(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}, fence.this) != 0 }
	}
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSb(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}) != 0 }
	}
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_createMipmaps_cTcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	fn create_mipmaps(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_createMipmaps_cT(self.this, texture.this) != 0 } }
	fn flush_texture(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, TextureFlags::None) != 0 } }
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, flags) != 0 } }
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, TextureFlags::None) != 0 }
	}
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, flags) != 0 }
	}
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, TextureFlags::None) != 0 }
	}
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, flags) != 0 }
	}
	fn release_texture(&self, texture: &mut Texture) { unsafe { tsDevice_releaseTexture(self.this, texture.this) } }
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool { unsafe { tsDevice_setTracing(self.this, tracing.this, instances.as_ptr(), instances.len() as u32) != 0 } }
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, TracingFlags::None) != 0 } }
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, flags) != 0 } }
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, TracingFlags::None) != 0 } }
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, flags) != 0 } }
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, flags) != 0 }
	}
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, flags) != 0 }
	}
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, 0) != 0 } }
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, offset) != 0 } }
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool { unsafe { tsDevice_flushTracing(self.this, tracing.this) != 0 } }
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_flushTracings(self.this, tracings_.as_ptr(), tracings.len() as u32) != 0 }
	}
	fn release_tracing(&self, tracing: &mut Tracing) { unsafe { tsDevice_releaseTracing(self.this, tracing.this) } }
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, 0) != 0 } }
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, if owner {1} else {0}) != 0 } }
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, 0) != 0 }
	}
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_buffer_table(&self, table: &mut BufferTable) { unsafe { tsDevice_releaseBufferTable(self.this, table.this) } }
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, 0) != 0 } }
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, if owner {1} else {0}) != 0 } }
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, 0) != 0 }
	}
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_texture_table(&self, table: &mut TextureTable) { unsafe { tsDevice_releaseTextureTable(self.this, table.this) } }
	fn begin_query(&self, query: &mut Query) -> bool { unsafe { tsDevice_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&self, query: &mut Query) { unsafe { tsDevice_endQuery(self.this, query.this) } }
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, 0) != 0 } }
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, offset) != 0 } }
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, 0, 0) != 0 }
	}
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn wait_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_waitFence(self.this, fence.this) != 0 } }
	fn signal_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_signalFence(self.this, fence.this) != 0 } }
	fn execute(&self, device: &mut Device) -> bool { unsafe { tsDevice_execute(self.this, device.this) != 0 } }
	fn flip_with_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_flip_cF(self.this, fence.this) != 0 } }
	fn flip(&self) -> bool { unsafe { tsDevice_flip_c(self.this) != 0 } }
	fn flush(&self) -> bool { unsafe { tsDevice_flush(self.this) != 0 } }
	fn finish(&self) -> bool { unsafe { tsDevice_finish(self.this) != 0 } }
	fn check(&self) -> bool { unsafe { tsDevice_check(self.this) != 0 } }
}
impl Drop for MTLDevice {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLDevice_delete(self.this) } } }
}
impl Clone for MTLDevice {
	fn clone(&self) -> MTLDevice { unsafe { MTLDevice { this: tsMTLDevice_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLDevice { }
impl fmt::Display for MTLDevice {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLDevice ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLDevice_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLDevice_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLDevice_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLDevice_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLDevice_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLDevice_new() -> *mut c_void;
	fn tsMTLDevice_new_C(context: *mut c_void) -> *mut c_void;
	fn tsMTLDevice_new_S(surface: *mut c_void) -> *mut c_void;
	fn tsMTLDevice_new_W(window: *mut c_void) -> *mut c_void;
	fn tsMTLDevice_delete(this: *mut c_void);
	fn tsMTLDevice_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLDevice_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_clearPtr(this: *const c_void);
	fn tsMTLDevice_destroyPtr(this: *const c_void);
	fn tsMTLDevice_acquirePtr(this: *const c_void);
	fn tsMTLDevice_unacquirePtr(this: *const c_void);
	fn tsMTLDevice_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLDevice_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLDevice_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLDevice_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLDevice_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_equalDevicePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLDevice_castDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_baseDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getMTLDevice(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getQueue(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getCommand(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getRenderEncoder(this: *const c_void, descriptor: *mut c_void) -> *mut c_void;
	fn tsMTLDevice_getComputeEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getTracingEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_getBlitEncoder(this: *const c_void) -> *mut c_void;
	fn tsMTLDevice_endEncoder(this: *const c_void);
}

// Tellusim::VKDevice
pub struct VKDevice {
	this: *mut c_void,
	owner: bool,
}
impl VKDevice {
	pub fn null() -> VKDevice { VKDevice { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKDevice { unsafe { VKDevice { this: tsVKDevice_new(), owner: true } } }
	pub fn new_with_context(context: &mut Context) -> VKDevice { unsafe { VKDevice { this: tsVKDevice_new_C(context.this), owner: true } } }
	pub fn new_with_surface(surface: &mut Surface) -> VKDevice { unsafe { VKDevice { this: tsVKDevice_new_S(surface.this), owner: true } } }
	pub fn new_with_window(window: &mut Window) -> VKDevice { unsafe { VKDevice { this: tsVKDevice_new_W(window.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKDevice { unsafe { VKDevice { this: ptr, owner: tsVKDevice_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKDevice { unsafe { VKDevice { this: tsVKDevice_copyPtr(self.this), owner: true } } }
	pub fn from_device(ptr: &Device) -> VKDevice { unsafe { VKDevice::new_ptr(tsVKDevice_castDevicePtr(ptr.this)) } }
	pub fn to_device(&self) -> Device { unsafe { Device::new_ptr(tsVKDevice_baseDevicePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKDevice) -> bool { unsafe { tsVKDevice_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKDevice { unsafe { VKDevice { this: tsVKDevice_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKDevice_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKDevice_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKDevice_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKDevice_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKDevice_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKDevice_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKDevice_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKDevice_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKDevice_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_buffer_access(&mut self, buffer: &mut Buffer, access: u32) { unsafe { tsVKDevice_setBufferAccess(self.this, buffer.this, access) } }
	pub fn set_texture_layout(&mut self, texture: &mut Texture, layout: u32) { unsafe { tsVKDevice_setTextureLayout(self.this, texture.this, layout) } }
	pub fn wait_vk_fence(&self, fence: *mut c_void, timeout: u64, reset: bool) -> bool { unsafe { tsVKDevice_waitVKFence(self.this, fence, timeout, if reset {1} else {0}) != 0 } }
	pub fn signal_vk_fence(&self, fence: *mut c_void) -> bool { unsafe { tsVKDevice_signalVKFence(self.this, fence) != 0 } }
	pub fn wait_semaphore(&self, semaphore: *mut c_void, mask: u32) { unsafe { tsVKDevice_waitSemaphore(self.this, semaphore, mask) } }
	pub fn signal_semaphore(&self, semaphore: *mut c_void) { unsafe { tsVKDevice_signalSemaphore(self.this, semaphore) } }
	pub fn has_memory_type(&self, flags: u32) -> bool { unsafe { tsVKDevice_hasMemoryType(self.this, flags) != 0 } }
	pub fn memory_index(&self, types: u32, flags: u32) -> u32 { unsafe { tsVKDevice_getMemoryIndex(self.this, types, flags) } }
	pub fn instance(&self) -> *const c_void { unsafe { tsVKDevice_getInstance(self.this) } }
	pub fn adapter(&self) -> *const c_void { unsafe { tsVKDevice_getAdapter(self.this) } }
	pub fn vk_device(&self) -> *const c_void { unsafe { tsVKDevice_getVKDevice(self.this) } }
	pub fn queue(&self) -> *const c_void { unsafe { tsVKDevice_getQueue(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsVKDevice_getCommand(self.this) } }
	pub fn family(&self) -> u32 { unsafe { tsVKDevice_getFamily(self.this) } }
}
impl DeviceTrait for VKDevice {
	fn platform(&self) -> Platform { unsafe { tsDevice_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsDevice_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsDevice_getIndex(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsDevice_getName(self.this)) } }
	fn vendor(&self) -> string::String { unsafe { get_string(tsDevice_getVendor(self.this)) } }
	fn version(&self) -> string::String { unsafe { get_string(tsDevice_getVersion(self.this)) } }
	fn features(&self) -> DeviceFeatures { unsafe { tsDevice_getFeatures(self.this) } }
	fn has_query(&self, type_: QueryType) -> bool { unsafe { tsDevice_hasQuery(self.this, type_) != 0 } }
	fn has_shader(&self, type_: ShaderType) -> bool { unsafe { tsDevice_hasShader(self.this, type_) != 0 } }
	fn has_target(&self, format: Format) -> bool { unsafe { tsDevice_hasTarget(self.this, format) != 0 } }
	fn has_texture(&self, format: Format) -> bool { unsafe { tsDevice_hasTexture(self.this, format) != 0 } }
	fn has_surface(&self, format: Format) -> bool { unsafe { tsDevice_hasSurface(self.this, format) != 0 } }
	fn create_device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, 3)) } }
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, frames)) } }
	fn create_command_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, 3)) } }
	fn create_command_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, frames)) } }
	fn create_compute_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, 3)) } }
	fn create_compute_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, frames)) } }
	fn create_copy_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, 3)) } }
	fn create_copy_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, frames)) } }
	fn create_query(&self) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_c(self.this)) } }
	fn create_query_with_type(&self, type_: QueryType) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_cQT(self.this, type_)) } }
	fn create_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_c(self.this)) } }
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cF(self.this, shared.this)) } }
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cFF(self.this, flags)) } }
	fn create_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_c(self.this)) } }
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cB(self.this, shared.this)) } }
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, Format::Unknown)) } }
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, format)) } }
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, Format::Unknown)) } }
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, format)) } }
	fn create_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_c(self.this)) } }
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_ccS(self.this, sampler.this)) } }
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, SamplerWrapMode::Repeat, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, anisotropy)) } }
	fn create_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_c(self.this)) } }
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cT(self.this, shared.this)) } }
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, TextureFlags::None)) } }
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, flags)) } }
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, TextureFlags::None)) } }
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, flags)) } }
	fn create_texture_with_image(&self, image: &Image) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, TextureFlags::None, ptr::null_mut())) } }
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, ptr::null_mut())) } }
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture3d(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, flags)) } }
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, TextureFlags::None)) } }
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, flags)) } }
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, TextureFlags::None)) } }
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, flags)) } }
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, TextureFlags::None)) } }
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, flags)) } }
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, TextureFlags::None)) } }
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, flags)) } }
	fn load_texture(&self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) }
	}
	fn load_texture_with_name(&self, name: &String) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_c(self.this)) } }
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_ccT(self.this, tracing.this)) } }
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, flags)) } }
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, TracingFlags::None)) } }
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)) } }
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, flags)) } }
	fn create_buffer_table(&self) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_c(self.this)) } }
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_cu(self.this, size)) } }
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, 0)) }
	}
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0})) }
	}
	fn create_texture_table(&self) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_c(self.this)) } }
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_cTTu(self.this, type_, size)) } }
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, 0)) }
	}
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0})) }
	}
	fn create_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShader_c(self.this)) } }
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderSPIRV(self.this, type_, name_.as_ptr())) }
	}
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32)) } }
	fn create_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_c(self.this)) } }
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_ccK(self.this, kernel.this)) } }
	fn release_kernel(&self, kernel: &mut Kernel) { unsafe { tsDevice_releaseKernel(self.this, kernel.this) } }
	fn create_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_c(self.this)) } }
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_ccP(self.this, pipeline.this)) } }
	fn release_pipeline(&self, pipeline: &mut Pipeline) { unsafe { tsDevice_releasePipeline(self.this, pipeline.this) } }
	fn create_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_c(self.this)) } }
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_ccT(self.this, traversal.this)) } }
	fn release_traversal(&self, traversal: &mut Traversal) { unsafe { tsDevice_releaseTraversal(self.this, traversal.this) } }
	fn create_target(&self) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_c(self.this)) } }
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cS(self.this, surface.this)) } }
	fn create_target_with_window(&self, window: &mut Window) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cW(self.this, window.this)) } }
	fn create_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsDevice_createCompute(self.this)) } }
	fn create_command(&self) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_c(self.this)) } }
	fn create_command_with_target(&self, target: &mut Target) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_cT(self.this, target.this)) } }
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsDevice_setBuffer_cBp(self.this, buffer.this, src) != 0 } }
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBzprz(self.this, buffer.this, offset, dest, size) != 0 } }
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBprz(self.this, buffer.this, dest, size) != 0 } }
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool { unsafe { tsDevice_getBuffer_cBpr(self.this, buffer.this, dest) != 0 } }
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBzz(self.this, buffer.this, offset, size) } }
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBz(self.this, buffer.this, size) } }
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void { unsafe { tsDevice_mapBuffer_cB(self.this, buffer.this) } }
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_unmapBuffer(self.this, buffer.this) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsDevice_copyBuffer_cBB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsDevice_clearBuffer_cBFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_clearBuffer_cB(self.this, buffer.this) != 0 } }
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAbF(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAb(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBzzbF(self.this, buffer.this, offset, size, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBzzb(self.this, buffer.this, offset, size, if commit {1} else {0}) != 0 } }
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, BufferFlags::None) != 0 } }
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, flags) != 0 } }
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, BufferFlags::None) != 0 }
	}
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, flags) != 0 }
	}
	fn release_buffer(&self, buffer: &mut Buffer) { unsafe { tsDevice_releaseBuffer(self.this, buffer.this) } }
	fn release_sampler(&self, sampler: &mut Sampler) { unsafe { tsDevice_releaseSampler(self.this, sampler.this) } }
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcI(self.this, texture.this, image.this) != 0 } }
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTcSIcS(self.this, texture.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTIcS(self.this, texture.this, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool { unsafe { tsDevice_getTexture_cTI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsDevice_copyTexture_cTcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDevice_copyTexture_cTT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTp(self.this, texture.this, src) != 0 } }
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindTexture_cTcRucSubF(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool { unsafe { tsDevice_bindTexture_cTcRucSub(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSbF(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}, fence.this) != 0 }
	}
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSb(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}) != 0 }
	}
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_createMipmaps_cTcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	fn create_mipmaps(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_createMipmaps_cT(self.this, texture.this) != 0 } }
	fn flush_texture(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, TextureFlags::None) != 0 } }
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, flags) != 0 } }
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, TextureFlags::None) != 0 }
	}
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, flags) != 0 }
	}
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, TextureFlags::None) != 0 }
	}
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, flags) != 0 }
	}
	fn release_texture(&self, texture: &mut Texture) { unsafe { tsDevice_releaseTexture(self.this, texture.this) } }
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool { unsafe { tsDevice_setTracing(self.this, tracing.this, instances.as_ptr(), instances.len() as u32) != 0 } }
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, TracingFlags::None) != 0 } }
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, flags) != 0 } }
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, TracingFlags::None) != 0 } }
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, flags) != 0 } }
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, flags) != 0 }
	}
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, flags) != 0 }
	}
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, 0) != 0 } }
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, offset) != 0 } }
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool { unsafe { tsDevice_flushTracing(self.this, tracing.this) != 0 } }
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_flushTracings(self.this, tracings_.as_ptr(), tracings.len() as u32) != 0 }
	}
	fn release_tracing(&self, tracing: &mut Tracing) { unsafe { tsDevice_releaseTracing(self.this, tracing.this) } }
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, 0) != 0 } }
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, if owner {1} else {0}) != 0 } }
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, 0) != 0 }
	}
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_buffer_table(&self, table: &mut BufferTable) { unsafe { tsDevice_releaseBufferTable(self.this, table.this) } }
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, 0) != 0 } }
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, if owner {1} else {0}) != 0 } }
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, 0) != 0 }
	}
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_texture_table(&self, table: &mut TextureTable) { unsafe { tsDevice_releaseTextureTable(self.this, table.this) } }
	fn begin_query(&self, query: &mut Query) -> bool { unsafe { tsDevice_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&self, query: &mut Query) { unsafe { tsDevice_endQuery(self.this, query.this) } }
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, 0) != 0 } }
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, offset) != 0 } }
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, 0, 0) != 0 }
	}
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn wait_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_waitFence(self.this, fence.this) != 0 } }
	fn signal_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_signalFence(self.this, fence.this) != 0 } }
	fn execute(&self, device: &mut Device) -> bool { unsafe { tsDevice_execute(self.this, device.this) != 0 } }
	fn flip_with_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_flip_cF(self.this, fence.this) != 0 } }
	fn flip(&self) -> bool { unsafe { tsDevice_flip_c(self.this) != 0 } }
	fn flush(&self) -> bool { unsafe { tsDevice_flush(self.this) != 0 } }
	fn finish(&self) -> bool { unsafe { tsDevice_finish(self.this) != 0 } }
	fn check(&self) -> bool { unsafe { tsDevice_check(self.this) != 0 } }
}
impl Drop for VKDevice {
	fn drop(&mut self) { if self.owner { unsafe { tsVKDevice_delete(self.this) } } }
}
impl Clone for VKDevice {
	fn clone(&self) -> VKDevice { unsafe { VKDevice { this: tsVKDevice_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKDevice { }
impl fmt::Display for VKDevice {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKDevice ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKDevice_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKDevice_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKDevice_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKDevice_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKDevice_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKDevice_new() -> *mut c_void;
	fn tsVKDevice_new_C(context: *mut c_void) -> *mut c_void;
	fn tsVKDevice_new_S(surface: *mut c_void) -> *mut c_void;
	fn tsVKDevice_new_W(window: *mut c_void) -> *mut c_void;
	fn tsVKDevice_delete(this: *mut c_void);
	fn tsVKDevice_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKDevice_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKDevice_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKDevice_clearPtr(this: *const c_void);
	fn tsVKDevice_destroyPtr(this: *const c_void);
	fn tsVKDevice_acquirePtr(this: *const c_void);
	fn tsVKDevice_unacquirePtr(this: *const c_void);
	fn tsVKDevice_isValidPtr(this: *const c_void) -> i32;
	fn tsVKDevice_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKDevice_isConstPtr(this: *const c_void) -> i32;
	fn tsVKDevice_getCountPtr(this: *const c_void) -> u32;
	fn tsVKDevice_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKDevice_equalDevicePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKDevice_castDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsVKDevice_baseDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsVKDevice_setBufferAccess(this: *mut c_void, buffer: *mut c_void, access: u32);
	fn tsVKDevice_setTextureLayout(this: *mut c_void, texture: *mut c_void, layout: u32);
	fn tsVKDevice_waitVKFence(this: *const c_void, fence: *mut c_void, timeout: u64, reset: i32) -> i32;
	fn tsVKDevice_signalVKFence(this: *const c_void, fence: *mut c_void) -> i32;
	fn tsVKDevice_waitSemaphore(this: *const c_void, semaphore: *mut c_void, mask: u32);
	fn tsVKDevice_signalSemaphore(this: *const c_void, semaphore: *mut c_void);
	fn tsVKDevice_hasMemoryType(this: *const c_void, flags: u32) -> i32;
	fn tsVKDevice_getMemoryIndex(this: *const c_void, types: u32, flags: u32) -> u32;
	fn tsVKDevice_getInstance(this: *const c_void) -> *const c_void;
	fn tsVKDevice_getAdapter(this: *const c_void) -> *const c_void;
	fn tsVKDevice_getVKDevice(this: *const c_void) -> *const c_void;
	fn tsVKDevice_getQueue(this: *const c_void) -> *const c_void;
	fn tsVKDevice_getCommand(this: *const c_void) -> *const c_void;
	fn tsVKDevice_getFamily(this: *const c_void) -> u32;
}

// Tellusim::FUDevice
pub struct FUDevice {
	this: *mut c_void,
	owner: bool,
}
impl FUDevice {
	pub fn null() -> FUDevice { FUDevice { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUDevice { unsafe { FUDevice { this: tsFUDevice_new(), owner: true } } }
	pub fn new_with_devices(devices: &[&mut Device]) -> FUDevice {
		let mut devices_ = Vec::new();
		for ptr in devices { devices_.push(ptr.this); }
		unsafe { FUDevice { this: tsFUDevice_new_cADb(devices_.as_ptr(), devices.len() as u32, 0), owner: true } }
	}
	pub fn new_with_devices_owner(devices: &[&mut Device], owner: bool) -> FUDevice {
		let mut devices_ = Vec::new();
		for ptr in devices { devices_.push(ptr.this); }
		unsafe { FUDevice { this: tsFUDevice_new_cADb(devices_.as_ptr(), devices.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUDevice { unsafe { FUDevice { this: ptr, owner: tsFUDevice_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUDevice { unsafe { FUDevice { this: tsFUDevice_copyPtr(self.this), owner: true } } }
	pub fn from_device(ptr: &Device) -> FUDevice { unsafe { FUDevice::new_ptr(tsFUDevice_castDevicePtr(ptr.this)) } }
	pub fn to_device(&self) -> Device { unsafe { Device::new_ptr(tsFUDevice_baseDevicePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUDevice) -> bool { unsafe { tsFUDevice_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUDevice { unsafe { FUDevice { this: tsFUDevice_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUDevice_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUDevice_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUDevice_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUDevice_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUDevice_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUDevice_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUDevice_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUDevice_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUDevice_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUDevice_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUDevice_getMask(self.this) } }
	pub fn num_devices(&self) -> u32 { unsafe { tsFUDevice_getNumDevices(self.this) } }
	pub fn device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsFUDevice_getDevice_cu(self.this, index)) } }
	pub fn device_mut(&mut self, index: u32) -> Device { unsafe { Device::new_ptr(tsFUDevice_getDevice_u(self.this, index)) } }
}
impl DeviceTrait for FUDevice {
	fn platform(&self) -> Platform { unsafe { tsDevice_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsDevice_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsDevice_getIndex(self.this) } }
	fn name(&self) -> string::String { unsafe { get_string(tsDevice_getName(self.this)) } }
	fn vendor(&self) -> string::String { unsafe { get_string(tsDevice_getVendor(self.this)) } }
	fn version(&self) -> string::String { unsafe { get_string(tsDevice_getVersion(self.this)) } }
	fn features(&self) -> DeviceFeatures { unsafe { tsDevice_getFeatures(self.this) } }
	fn has_query(&self, type_: QueryType) -> bool { unsafe { tsDevice_hasQuery(self.this, type_) != 0 } }
	fn has_shader(&self, type_: ShaderType) -> bool { unsafe { tsDevice_hasShader(self.this, type_) != 0 } }
	fn has_target(&self, format: Format) -> bool { unsafe { tsDevice_hasTarget(self.this, format) != 0 } }
	fn has_texture(&self, format: Format) -> bool { unsafe { tsDevice_hasTexture(self.this, format) != 0 } }
	fn has_surface(&self, format: Format) -> bool { unsafe { tsDevice_hasSurface(self.this, format) != 0 } }
	fn create_device(&self, index: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, 3)) } }
	fn create_device_with_frames(&self, index: u32, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createDevice(self.this, index, frames)) } }
	fn create_command_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, 3)) } }
	fn create_command_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCommandDevice(self.this, frames)) } }
	fn create_compute_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, 3)) } }
	fn create_compute_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createComputeDevice(self.this, frames)) } }
	fn create_copy_device(&self) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, 3)) } }
	fn create_copy_device_with_frames(&self, frames: u32) -> Device { unsafe { Device::new_ptr(tsDevice_createCopyDevice(self.this, frames)) } }
	fn create_query(&self) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_c(self.this)) } }
	fn create_query_with_type(&self, type_: QueryType) -> Query { unsafe { Query::new_ptr(tsDevice_createQuery_cQT(self.this, type_)) } }
	fn create_fence(&self) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_c(self.this)) } }
	fn create_fence_with_shared(&self, shared: &mut Fence) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cF(self.this, shared.this)) } }
	fn create_fence_with_flags(&self, flags: FenceFlags) -> Fence { unsafe { Fence::new_ptr(tsDevice_createFence_cFF(self.this, flags)) } }
	fn create_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_c(self.this)) } }
	fn create_buffer_with_shared(&self, shared: &mut Buffer) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cB(self.this, shared.this)) } }
	fn create_buffer_with_flags(&self, flags: BufferFlags, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, Format::Unknown)) } }
	fn create_buffer_with_flags_format(&self, flags: BufferFlags, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFzF(self.this, flags, size, format)) } }
	fn create_buffer_with_flags_src(&self, flags: BufferFlags, src: *const c_void, size: usize) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, Format::Unknown)) } }
	fn create_buffer_with_flags_src_format(&self, flags: BufferFlags, src: *const c_void, size: usize, format: Format) -> Buffer { unsafe { Buffer::new_ptr(tsDevice_createBuffer_cBFpzF(self.this, flags, src, size, format)) } }
	fn create_sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_c(self.this)) } }
	fn create_sampler_with_sampler(&self, sampler: &Sampler) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_ccS(self.this, sampler.this)) } }
	fn create_sampler_with_filter(&self, filter: SamplerFilter) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, SamplerWrapMode::Repeat, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode(&self, filter: SamplerFilter, mode: SamplerWrapMode) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, SamplerCommon::MaxAnisotropy as u32)) } }
	fn create_sampler_with_filter_mode_anisotropy(&self, filter: SamplerFilter, mode: SamplerWrapMode, anisotropy: u32) -> Sampler { unsafe { Sampler::new_ptr(tsDevice_createSampler_cSFSWMu(self.this, filter, mode, anisotropy)) } }
	fn create_texture(&self) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_c(self.this)) } }
	fn create_texture_with_shared(&self, shared: &mut Texture) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cT(self.this, shared.this)) } }
	fn create_texture_with_type_layers(&self, type_: TextureType, format: Format, size: &Size, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, TextureFlags::None)) } }
	fn create_texture_with_type_layers_flags(&self, type_: TextureType, format: Format, size: &Size, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSuTF(self.this, type_, format, size, layers, flags)) } }
	fn create_texture_with_type(&self, type_: TextureType, format: Format, size: &Size) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, TextureFlags::None)) } }
	fn create_texture_with_type_flags(&self, type_: TextureType, format: Format, size: &Size, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_cTTFcSTF(self.this, type_, format, size, flags)) } }
	fn create_texture_with_image(&self, image: &Image) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, TextureFlags::None, ptr::null_mut())) } }
	fn create_texture_with_image_flags(&self, image: &Image, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, ptr::null_mut())) } }
	fn create_texture_with_image_flags_async(&self, image: &Image, flags: TextureFlags, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture_ccITFA(self.this, image.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_texture2d_with_size(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture2d_with_size_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture3d(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture3d_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuTF(self.this, format, size, flags)) } }
	fn create_texture_cube(&self, format: Format, size: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, TextureFlags::None)) } }
	fn create_texture_cube_with_flags(&self, format: Format, size: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuTF(self.this, format, size, flags)) } }
	fn create_texture2d_with_width(&self, format: Format, width: u32, height: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, TextureFlags::None)) } }
	fn create_texture2d_with_width_flags(&self, format: Format, width: u32, height: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuTF(self.this, format, width, height, flags)) } }
	fn create_texture3d_with_width(&self, format: Format, width: u32, height: u32, depth: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, TextureFlags::None)) } }
	fn create_texture3d_with_width_flags(&self, format: Format, width: u32, height: u32, depth: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture3D_cFuuuTF(self.this, format, width, height, depth, flags)) } }
	fn create_texture2d_with_width_layers(&self, format: Format, width: u32, height: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, TextureFlags::None)) } }
	fn create_texture2d_with_width_layers_flags(&self, format: Format, width: u32, height: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTexture2D_cFuuuTF(self.this, format, width, height, layers, flags)) } }
	fn create_texture_cube_with_layers(&self, format: Format, size: u32, layers: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, TextureFlags::None)) } }
	fn create_texture_cube_with_layers_flags(&self, format: Format, size: u32, layers: u32, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_createTextureCube_cFuuTF(self.this, format, size, layers, flags)) } }
	fn load_texture(&self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags(&self, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, ImageFlags::None, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, 0, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, ptr::null_mut())) }
	}
	fn load_texture_with_flags_imageflags_offset_async(&self, name: &str, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDevice_loadTexture_csTFIFuA(self.this, name_.as_ptr(), flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) }
	}
	fn load_texture_with_name(&self, name: &String) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags(&self, name: &String, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_name_flags_imageflags_offset_async(&self, name: &String, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_ccSTFIFuA(self.this, name.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn load_texture_with_stream(&self, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, TextureFlags::None, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags(&self, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, ImageFlags::None, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, 0, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, ptr::null_mut())) } }
	fn load_texture_with_stream_flags_imageflags_offset_async(&self, stream: &mut Stream, flags: TextureFlags, image_flags: ImageFlags, offset: u32, async_: Option<&Async>) -> Texture { unsafe { Texture::new_ptr(tsDevice_loadTexture_cStTFIFuA(self.this, stream.this, flags, image_flags, offset, match async_ { Some(async_) => &async_.this, None => ptr::null() })) } }
	fn create_tracing(&self) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_c(self.this)) } }
	fn create_tracing_with_tracing(&self, tracing: &Tracing) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_ccT(self.this, tracing.this)) } }
	fn create_tracing_with_instances(&self, num_instances: u32) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer(&self, num_instances: u32, instance_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, TracingFlags::None)) } }
	fn create_tracing_with_instances_instancebuffer_instanceoffset_flags(&self, num_instances: u32, instance_buffer: &mut Buffer, instance_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuBzTF(self.this, num_instances, instance_buffer.this, instance_offset, flags)) } }
	fn create_tracing_with_vertices(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, TracingFlags::None)) } }
	fn create_tracing_with_vertices_flags(&self, num_vertices: u32, vertex_format: Format, vertex_stride: usize, num_indices: u32, index_format: Format, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuFzuFTF(self.this, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)) } }
	fn create_tracing_with_bounds(&self, num_bounds: u32, bound_stride: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, ptr::null_mut(), 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, 0, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, TracingFlags::None)) } }
	fn create_tracing_with_bounds_boundbuffer_boundoffset_flags(&self, num_bounds: u32, bound_stride: usize, bound_buffer: &mut Buffer, bound_offset: usize, flags: TracingFlags) -> Tracing { unsafe { Tracing::new_ptr(tsDevice_createTracing_cuzBzTF(self.this, num_bounds, bound_stride, bound_buffer.this, bound_offset, flags)) } }
	fn create_buffer_table(&self) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_c(self.this)) } }
	fn create_buffer_table_with_size(&self, size: u32) -> BufferTable { unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_cu(self.this, size)) } }
	fn create_buffer_table_with_buffers(&self, buffers: &[&mut Buffer]) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, 0)) }
	}
	fn create_buffer_table_with_buffers_owner(&self, buffers: &[&mut Buffer], owner: bool) -> BufferTable {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { BufferTable::new_ptr(tsDevice_createBufferTable_ccABb(self.this, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0})) }
	}
	fn create_texture_table(&self) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_c(self.this)) } }
	fn create_texture_table_with_type(&self, type_: TextureType, size: u32) -> TextureTable { unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_cTTu(self.this, type_, size)) } }
	fn create_texture_table_with_textures(&self, textures: &[&mut Texture]) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, 0)) }
	}
	fn create_texture_table_with_textures_owner(&self, textures: &[&mut Texture], owner: bool) -> TextureTable {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { TextureTable::new_ptr(tsDevice_createTextureTable_ccATb(self.this, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0})) }
	}
	fn create_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShader_c(self.this)) } }
	fn load_shader(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_glsl(&self, type_: ShaderType, name: &str, format: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTss(self.this, type_, name_.as_ptr(), format_.as_ptr())) }
	}
	fn load_shader_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShader_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_glsl_with_macros(&self, type_: ShaderType, name: &str, macros: &String) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderGLSL_cSTscS(self.this, type_, name_.as_ptr(), macros.this)) }
	}
	fn load_shader_spirv(&self, type_: ShaderType, name: &str) -> Shader {
		let name_ = CString::new(name).unwrap();
		unsafe { Shader::new_ptr(tsDevice_loadShaderSPIRV(self.this, type_, name_.as_ptr())) }
	}
	fn create_shader_with_type(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_glsl(&self, type_: ShaderType, src: &str, format: &str) -> Shader {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTss(self.this, type_, src_.as_ptr(), format_.as_ptr())) }
	}
	fn create_shader_with_type_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShader_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_glsl_with_macros(&self, type_: ShaderType, src: &str, macros: &String) -> Shader {
		let src_ = CString::new(src).unwrap();
		unsafe { Shader::new_ptr(tsDevice_createShaderGLSL_cSTscS(self.this, type_, src_.as_ptr(), macros.this)) }
	}
	fn create_shader_spirv(&self, type_: ShaderType, data: &[u32]) -> Shader { unsafe { Shader::new_ptr(tsDevice_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32)) } }
	fn create_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_c(self.this)) } }
	fn create_kernel_with_kernel(&self, kernel: &Kernel) -> Kernel { unsafe { Kernel::new_ptr(tsDevice_createKernel_ccK(self.this, kernel.this)) } }
	fn release_kernel(&self, kernel: &mut Kernel) { unsafe { tsDevice_releaseKernel(self.this, kernel.this) } }
	fn create_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_c(self.this)) } }
	fn create_pipeline_with_pipeline(&self, pipeline: &Pipeline) -> Pipeline { unsafe { Pipeline::new_ptr(tsDevice_createPipeline_ccP(self.this, pipeline.this)) } }
	fn release_pipeline(&self, pipeline: &mut Pipeline) { unsafe { tsDevice_releasePipeline(self.this, pipeline.this) } }
	fn create_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_c(self.this)) } }
	fn create_traversal_with_traversal(&self, traversal: &Traversal) -> Traversal { unsafe { Traversal::new_ptr(tsDevice_createTraversal_ccT(self.this, traversal.this)) } }
	fn release_traversal(&self, traversal: &mut Traversal) { unsafe { tsDevice_releaseTraversal(self.this, traversal.this) } }
	fn create_target(&self) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_c(self.this)) } }
	fn create_target_with_surface(&self, surface: &mut Surface) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cS(self.this, surface.this)) } }
	fn create_target_with_window(&self, window: &mut Window) -> Target { unsafe { Target::new_ptr(tsDevice_createTarget_cW(self.this, window.this)) } }
	fn create_compute(&self) -> Compute { unsafe { Compute::new_ptr(tsDevice_createCompute(self.this)) } }
	fn create_command(&self) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_c(self.this)) } }
	fn create_command_with_target(&self, target: &mut Target) -> Command { unsafe { Command::new_ptr(tsDevice_createCommand_cT(self.this, target.this)) } }
	fn set_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBzpz(self.this, buffer.this, offset, src, size) != 0 } }
	fn set_buffer_with_src_size(&self, buffer: &mut Buffer, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_setBuffer_cBpz(self.this, buffer.this, src, size) != 0 } }
	fn set_buffer_with_src(&self, buffer: &mut Buffer, src: *const c_void) -> bool { unsafe { tsDevice_setBuffer_cBp(self.this, buffer.this, src) != 0 } }
	fn buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBzprz(self.this, buffer.this, offset, dest, size) != 0 } }
	fn buffer_with_dest_size(&self, buffer: &mut Buffer, dest: *mut c_void, size: usize) -> bool { unsafe { tsDevice_getBuffer_cBprz(self.this, buffer.this, dest, size) != 0 } }
	fn buffer_with_dest(&self, buffer: &mut Buffer, dest: *mut c_void) -> bool { unsafe { tsDevice_getBuffer_cBpr(self.this, buffer.this, dest) != 0 } }
	fn map_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBzz(self.this, buffer.this, offset, size) } }
	fn map_buffer_with_size(&self, buffer: &mut Buffer, size: usize) -> *mut c_void { unsafe { tsDevice_mapBuffer_cBz(self.this, buffer.this, size) } }
	fn map_buffer(&self, buffer: &mut Buffer) -> *mut c_void { unsafe { tsDevice_mapBuffer_cB(self.this, buffer.this) } }
	fn unmap_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_unmapBuffer(self.this, buffer.this) != 0 } }
	fn copy_buffer_with_destoffset_srcoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, src_offset: usize, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBzz(self.this, buffer.this, dest_offset, src.this, src_offset, size) != 0 } }
	fn copy_buffer_with_destoffset(&self, buffer: &mut Buffer, dest_offset: usize, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBzBz(self.this, buffer.this, dest_offset, src.this, size) != 0 } }
	fn copy_buffer_with_src_size(&self, buffer: &mut Buffer, src: &mut Buffer, size: usize) -> bool { unsafe { tsDevice_copyBuffer_cBBz(self.this, buffer.this, src.this, size) != 0 } }
	fn copy_buffer_with_src(&self, buffer: &mut Buffer, src: &mut Buffer) -> bool { unsafe { tsDevice_copyBuffer_cBB(self.this, buffer.this, src.this) != 0 } }
	fn clear_buffer_with_format_offset(&self, buffer: &mut Buffer, format: Format, offset: usize, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFzpz(self.this, buffer.this, format, offset, src, size) != 0 } }
	fn clear_buffer_with_format_src_size(&self, buffer: &mut Buffer, format: Format, src: *const c_void, size: usize) -> bool { unsafe { tsDevice_clearBuffer_cBFpz(self.this, buffer.this, format, src, size) != 0 } }
	fn clear_buffer_with_format_src(&self, buffer: &mut Buffer, format: Format, src: *const c_void) -> bool { unsafe { tsDevice_clearBuffer_cBFp(self.this, buffer.this, format, src) != 0 } }
	fn clear_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_clearBuffer_cB(self.this, buffer.this) != 0 } }
	fn bind_buffer_with_offsets_fence(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAbF(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offsets(&self, buffer: &mut Buffer, offsets: &[usize], sizes: &[usize], commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBcAcAb(self.this, buffer.this, offsets.as_ptr(), offsets.len() as u32, sizes.as_ptr(), sizes.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_buffer_with_offset_fence(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindBuffer_cBzzbF(self.this, buffer.this, offset, size, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_buffer_with_offset(&self, buffer: &mut Buffer, offset: usize, size: usize, commit: bool) -> bool { unsafe { tsDevice_bindBuffer_cBzzb(self.this, buffer.this, offset, size, if commit {1} else {0}) != 0 } }
	fn flush_buffer(&self, buffer: &mut Buffer) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, BufferFlags::None) != 0 } }
	fn flush_buffer_with_flags(&self, buffer: &mut Buffer, flags: BufferFlags) -> bool { unsafe { tsDevice_flushBuffer(self.this, buffer.this, flags) != 0 } }
	fn flush_buffers(&self, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, BufferFlags::None) != 0 }
	}
	fn flush_buffers_with_flags(&self, buffers: &[&mut Buffer], flags: BufferFlags) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_flushBuffers_ccABBF(self.this, buffers_.as_ptr(), buffers.len() as u32, flags) != 0 }
	}
	fn release_buffer(&self, buffer: &mut Buffer) { unsafe { tsDevice_releaseBuffer(self.this, buffer.this) } }
	fn release_sampler(&self, sampler: &mut Sampler) { unsafe { tsDevice_releaseSampler(self.this, sampler.this) } }
	fn set_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, image: &Image, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcOcScIcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn set_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcOcI(self.this, texture.this, dest_origin, image.this) != 0 } }
	fn set_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, image: &Image) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_setTexture_cTcScI(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, image.this) != 0 }
	}
	fn set_texture_with_image(&self, texture: &mut Texture, image: &Image) -> bool { unsafe { tsDevice_setTexture_cTcI(self.this, texture.this, image.this) != 0 } }
	fn texture_with_srcslice(&self, texture: &mut Texture, src_slice: Option<&Slice>, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTcSIcS(self.this, texture.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image_destslice(&self, texture: &mut Texture, image: &mut Image, dest_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		unsafe { tsDevice_getTexture_cTIcS(self.this, texture.this, image.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }) != 0 }
	}
	fn texture_with_image(&self, texture: &mut Texture, image: &mut Image) -> bool { unsafe { tsDevice_getTexture_cTI(self.this, texture.this, image.this) != 0 } }
	fn copy_texture_with_destorigin_destslice(&self, texture: &mut Texture, dest_origin: &Origin, dest_slice: Option<&Slice>, src: &mut Texture, src_region: &Region, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcOcSTcRcS(self.this, texture.this, dest_origin, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, src_region, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_destorigin(&self, texture: &mut Texture, dest_origin: &Origin, src: &mut Texture, src_region: &Region) -> bool { unsafe { tsDevice_copyTexture_cTcOTcR(self.this, texture.this, dest_origin, src.this, src_region) != 0 } }
	fn copy_texture_with_destslice(&self, texture: &mut Texture, dest_slice: Option<&Slice>, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDevice_copyTexture_cTcSTcS(self.this, texture.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	fn copy_texture_with_src(&self, texture: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDevice_copyTexture_cTT(self.this, texture.this, src.this) != 0 } }
	fn clear_texture_with_region_slice(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcRcSp(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_region(&self, texture: &mut Texture, region: &Region, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTcRp(self.this, texture.this, region, src) != 0 } }
	fn clear_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>, src: *const c_void) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_clearTexture_cTcSp(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, src) != 0 }
	}
	fn clear_texture_with_src(&self, texture: &mut Texture, src: *const c_void) -> bool { unsafe { tsDevice_clearTexture_cTp(self.this, texture.this, src) != 0 } }
	fn bind_texture_with_regions_fence(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool, fence: &mut Fence) -> bool { unsafe { tsDevice_bindTexture_cTcRucSubF(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}, fence.this) != 0 } }
	fn bind_texture_with_regions(&self, texture: &mut Texture, regions: &[Region], slices: &[Slice], commit: bool) -> bool { unsafe { tsDevice_bindTexture_cTcRucSub(self.this, texture.this, regions.as_ptr(), regions.len() as u32, slices.as_ptr(), slices.len() as u32, if commit {1} else {0}) != 0 } }
	fn bind_texture_with_region_fence(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool, fence: &mut Fence) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSbF(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}, fence.this) != 0 }
	}
	fn bind_texture_with_region(&self, texture: &mut Texture, region: &Region, slice: Option<&Slice>, commit: bool) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_bindTexture_cTcRcSb(self.this, texture.this, region, match slice { Some(slice) => slice, None => &slice_ }, if commit {1} else {0}) != 0 }
	}
	fn create_mipmaps_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_createMipmaps_cTcS(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	fn create_mipmaps(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_createMipmaps_cT(self.this, texture.this) != 0 } }
	fn flush_texture(&self, texture: &mut Texture) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, TextureFlags::None) != 0 } }
	fn flush_texture_with_flags(&self, texture: &mut Texture, flags: TextureFlags) -> bool { unsafe { tsDevice_flushTexture_cTTF(self.this, texture.this, flags) != 0 } }
	fn flush_texture_with_slice(&self, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, TextureFlags::None) != 0 }
	}
	fn flush_texture_with_slice_flags(&self, texture: &mut Texture, slice: Option<&Slice>, flags: TextureFlags) -> bool {
		let slice_ = Slice::default();
		unsafe { tsDevice_flushTexture_cTcSTF(self.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, flags) != 0 }
	}
	fn flush_textures(&self, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, TextureFlags::None) != 0 }
	}
	fn flush_textures_with_flags(&self, textures: &[&mut Texture], flags: TextureFlags) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_flushTextures_ccATTF(self.this, textures_.as_ptr(), textures.len() as u32, flags) != 0 }
	}
	fn release_texture(&self, texture: &mut Texture) { unsafe { tsDevice_releaseTexture(self.this, texture.this) } }
	fn set_tracing(&self, tracing: &mut Tracing, instances: &[TracingInstance]) -> bool { unsafe { tsDevice_setTracing(self.this, tracing.this, instances.as_ptr(), instances.len() as u32) != 0 } }
	fn build_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, TracingFlags::None) != 0 } }
	fn build_tracing_with_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBTF(self.this, tracing.this, buffer.this, flags) != 0 } }
	fn build_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, TracingFlags::None) != 0 } }
	fn build_tracing_with_offset_flags(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool { unsafe { tsDevice_buildTracing_cTBzTF(self.this, tracing.this, buffer.this, offset, flags) != 0 } }
	fn build_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, flags) != 0 }
	}
	fn build_tracings_with_offset(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, TracingFlags::None) != 0 }
	}
	fn build_tracings_with_offset_flags(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, flags: TracingFlags) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_buildTracings_ccATBzTF(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, flags) != 0 }
	}
	fn copy_tracing(&self, tracing: &mut Tracing, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, 0) != 0 } }
	fn copy_tracing_with_offset(&self, tracing: &mut Tracing, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyTracing(self.this, tracing.this, buffer.this, offset) != 0 } }
	fn copy_tracings(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_tracings_with_stride(&self, tracings: &[&mut Tracing], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_copyTracings(self.this, tracings_.as_ptr(), tracings.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn flush_tracing(&self, tracing: &mut Tracing) -> bool { unsafe { tsDevice_flushTracing(self.this, tracing.this) != 0 } }
	fn flush_tracings(&self, tracings: &[&mut Tracing]) -> bool {
		let mut tracings_ = Vec::new();
		for ptr in tracings { tracings_.push(ptr.this); }
		unsafe { tsDevice_flushTracings(self.this, tracings_.as_ptr(), tracings.len() as u32) != 0 }
	}
	fn release_tracing(&self, tracing: &mut Tracing) { unsafe { tsDevice_releaseTracing(self.this, tracing.this) } }
	fn set_buffer_table(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, 0) != 0 } }
	fn set_buffer_table_with_owner(&self, table: &mut BufferTable, index: u32, buffer: &mut Buffer, owner: bool) -> bool { unsafe { tsDevice_setBufferTable_cBTuBb(self.this, table.this, index, buffer.this, if owner {1} else {0}) != 0 } }
	fn set_buffer_table_with_buffers(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer]) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, 0) != 0 }
	}
	fn set_buffer_table_with_buffers_owner(&self, table: &mut BufferTable, index: u32, buffers: &[&mut Buffer], owner: bool) -> bool {
		let mut buffers_ = Vec::new();
		for ptr in buffers { buffers_.push(ptr.this); }
		unsafe { tsDevice_setBufferTable_cBTucABb(self.this, table.this, index, buffers_.as_ptr(), buffers.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_buffer_table(&self, table: &mut BufferTable) { unsafe { tsDevice_releaseBufferTable(self.this, table.this) } }
	fn set_texture_table(&self, table: &mut TextureTable, index: u32, texture: &mut Texture) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, 0) != 0 } }
	fn set_texture_table_with_owner(&self, table: &mut TextureTable, index: u32, texture: &mut Texture, owner: bool) -> bool { unsafe { tsDevice_setTextureTable_cTTuTb(self.this, table.this, index, texture.this, if owner {1} else {0}) != 0 } }
	fn set_texture_table_with_textures(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture]) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, 0) != 0 }
	}
	fn set_texture_table_with_textures_owner(&self, table: &mut TextureTable, index: u32, textures: &[&mut Texture], owner: bool) -> bool {
		let mut textures_ = Vec::new();
		for ptr in textures { textures_.push(ptr.this); }
		unsafe { tsDevice_setTextureTable_cTTucATb(self.this, table.this, index, textures_.as_ptr(), textures.len() as u32, if owner {1} else {0}) != 0 }
	}
	fn release_texture_table(&self, table: &mut TextureTable) { unsafe { tsDevice_releaseTextureTable(self.this, table.this) } }
	fn begin_query(&self, query: &mut Query) -> bool { unsafe { tsDevice_beginQuery(self.this, query.this) != 0 } }
	fn end_query(&self, query: &mut Query) { unsafe { tsDevice_endQuery(self.this, query.this) } }
	fn copy_query(&self, query: &mut Query, buffer: &mut Buffer) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, 0) != 0 } }
	fn copy_query_with_offset(&self, query: &mut Query, buffer: &mut Buffer, offset: usize) -> bool { unsafe { tsDevice_copyQuery(self.this, query.this, buffer.this, offset) != 0 } }
	fn copy_queries(&self, queries: &[&mut Query], buffer: &mut Buffer) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, 0, 0) != 0 }
	}
	fn copy_queries_with_offset(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, 0) != 0 }
	}
	fn copy_queries_with_offset_stride(&self, queries: &[&mut Query], buffer: &mut Buffer, offset: usize, stride: usize) -> bool {
		let mut queries_ = Vec::new();
		for ptr in queries { queries_.push(ptr.this); }
		unsafe { tsDevice_copyQueries_ccAQBzz(self.this, queries_.as_ptr(), queries.len() as u32, buffer.this, offset, stride) != 0 }
	}
	fn wait_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_waitFence(self.this, fence.this) != 0 } }
	fn signal_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_signalFence(self.this, fence.this) != 0 } }
	fn execute(&self, device: &mut Device) -> bool { unsafe { tsDevice_execute(self.this, device.this) != 0 } }
	fn flip_with_fence(&self, fence: &mut Fence) -> bool { unsafe { tsDevice_flip_cF(self.this, fence.this) != 0 } }
	fn flip(&self) -> bool { unsafe { tsDevice_flip_c(self.this) != 0 } }
	fn flush(&self) -> bool { unsafe { tsDevice_flush(self.this) != 0 } }
	fn finish(&self) -> bool { unsafe { tsDevice_finish(self.this) != 0 } }
	fn check(&self) -> bool { unsafe { tsDevice_check(self.this) != 0 } }
}
impl Drop for FUDevice {
	fn drop(&mut self) { if self.owner { unsafe { tsFUDevice_delete(self.this) } } }
}
impl Clone for FUDevice {
	fn clone(&self) -> FUDevice { unsafe { FUDevice { this: tsFUDevice_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUDevice { }
impl fmt::Display for FUDevice {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUDevice ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUDevice_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUDevice_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUDevice_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUDevice_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUDevice_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUDevice_new() -> *mut c_void;
	fn tsFUDevice_new_cADb(devices: *const *mut c_void, devices_size: u32, owner: i32) -> *mut c_void;
	fn tsFUDevice_delete(this: *mut c_void);
	fn tsFUDevice_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUDevice_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUDevice_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUDevice_clearPtr(this: *const c_void);
	fn tsFUDevice_destroyPtr(this: *const c_void);
	fn tsFUDevice_acquirePtr(this: *const c_void);
	fn tsFUDevice_unacquirePtr(this: *const c_void);
	fn tsFUDevice_isValidPtr(this: *const c_void) -> i32;
	fn tsFUDevice_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUDevice_isConstPtr(this: *const c_void) -> i32;
	fn tsFUDevice_getCountPtr(this: *const c_void) -> u32;
	fn tsFUDevice_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUDevice_equalDevicePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUDevice_castDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsFUDevice_baseDevicePtr(this: *const c_void) -> *mut c_void;
	fn tsFUDevice_setMask(this: *mut c_void, mask: u32);
	fn tsFUDevice_getMask(this: *const c_void) -> u32;
	fn tsFUDevice_getNumDevices(this: *const c_void) -> u32;
	fn tsFUDevice_getDevice_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUDevice_getDevice_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Kernel
pub struct Kernel {
	this: *mut c_void,
	owner: bool,
}
impl Kernel {
	pub fn null() -> Kernel { Kernel { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Kernel { unsafe { Kernel { this: tsKernel_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Kernel { unsafe { Kernel { this: ptr, owner: tsKernel_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Kernel { unsafe { Kernel { this: tsKernel_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Kernel) -> bool { unsafe { tsKernel_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Kernel { unsafe { Kernel { this: tsKernel_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsKernel_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsKernel_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsKernel_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsKernel_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsKernel_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsKernel_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsKernel_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsKernel_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsKernel_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait KernelTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn name(&self) -> string::String;
	fn create(&mut self) -> bool;
	fn set_parameters(&mut self, kernel: &Kernel);
	fn save_state(&self, stream: &mut Stream) -> bool;
	fn set_shader(&mut self, shader: &mut Shader);
	fn set_shader_with_owner(&mut self, shader: &mut Shader, owner: bool);
	fn compute_shader(&self) -> Shader;
	fn load_shader(&mut self, name: &str, format: &str) -> bool;
	fn load_shader_glsl(&mut self, name: &str, format: &str) -> bool;
	fn load_shader_with_macros(&mut self, name: &str, macros: &String) -> bool;
	fn load_shader_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_shader_glsl_with_macros(&mut self, name: &str, macros: &String) -> bool;
	fn load_shader_glsl_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_shader_spirv(&mut self, name: &str) -> bool;
	fn create_shader(&mut self, src: &str, format: &str) -> bool;
	fn create_shader_glsl(&mut self, src: &str, format: &str) -> bool;
	fn create_shader_with_macros(&mut self, src: &str, macros: &String) -> bool;
	fn create_shader_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_shader_glsl_with_macros(&mut self, src: &str, macros: &String) -> bool;
	fn create_shader_glsl_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_shader_spirv(&mut self, data: &[u32]) -> bool;
	fn add_sampler(&mut self) -> u32;
	fn set_samplers(&mut self, num: u32) -> Kernel;
	fn num_samplers(&self) -> u32;
	fn set_sampler_offset(&mut self, offset: u32) -> Kernel;
	fn sampler_offset(&self) -> u32;
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Kernel;
	fn sampler_array(&self, index: u32) -> u32;
	fn add_texture(&mut self) -> u32;
	fn set_textures(&mut self, num: u32) -> Kernel;
	fn num_textures(&self) -> u32;
	fn set_texture_offset(&mut self, offset: u32) -> Kernel;
	fn texture_offset(&self) -> u32;
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Kernel;
	fn texture_array(&self, index: u32) -> u32;
	fn add_surface(&mut self) -> u32;
	fn set_surfaces(&mut self, num: u32) -> Kernel;
	fn num_surfaces(&self) -> u32;
	fn set_surface_offset(&mut self, offset: u32) -> Kernel;
	fn surface_offset(&self) -> u32;
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Kernel;
	fn surface_array(&self, index: u32) -> u32;
	fn add_uniform(&mut self) -> u32;
	fn add_uniform_with_flags(&mut self, flags: BindFlags) -> u32;
	fn set_uniforms(&mut self, num: u32) -> Kernel;
	fn set_uniforms_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel;
	fn num_uniforms(&self) -> u32;
	fn set_uniform_offset(&mut self, offset: u32) -> Kernel;
	fn uniform_offset(&self) -> u32;
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Kernel;
	fn uniform_flags(&self, index: u32) -> BindFlags;
	fn add_storage(&mut self) -> u32;
	fn add_storage_with_flags(&mut self, flags: BindFlags) -> u32;
	fn set_storages(&mut self, num: u32) -> Kernel;
	fn set_storages_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel;
	fn num_storages(&self) -> u32;
	fn set_storage_offset(&mut self, offset: u32) -> Kernel;
	fn storage_offset(&self) -> u32;
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Kernel;
	fn storage_flags(&self, index: u32) -> BindFlags;
	fn add_tracing(&mut self) -> u32;
	fn set_tracings(&mut self, num: u32) -> Kernel;
	fn num_tracings(&self) -> u32;
	fn set_tracing_offset(&mut self, offset: u32) -> Kernel;
	fn tracing_offset(&self) -> u32;
	fn add_texel(&mut self) -> u32;
	fn set_texels(&mut self, num: u32) -> Kernel;
	fn num_texels(&self) -> u32;
	fn set_texel_offset(&mut self, offset: u32) -> Kernel;
	fn texel_offset(&self) -> u32;
	fn add_table(&mut self, type_: TableType, size: u32) -> u32;
	fn num_tables(&self) -> u32;
	fn set_table_offset(&mut self, offset: u32) -> Kernel;
	fn table_offset(&self) -> u32;
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32) -> Kernel;
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, flags: BindFlags) -> Kernel;
	fn table_type(&self, index: u32) -> TableType;
	fn table_size(&self, index: u32) -> u32;
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Kernel;
	fn table_flags(&self, index: u32) -> BindFlags;
	fn set_group_size(&mut self, width: u32);
	fn set_group_size_with_height(&mut self, width: u32, height: u32);
	fn set_group_size_with_height_depth(&mut self, width: u32, height: u32, depth: u32);
	fn group_size_x(&self) -> u32;
	fn group_size_y(&self) -> u32;
	fn group_size_z(&self) -> u32;
}
impl KernelTrait for Kernel {
	fn platform(&self) -> Platform { unsafe { tsKernel_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsKernel_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsKernel_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsKernel_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsKernel_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsKernel_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsKernel_create(self.this) != 0 } }
	fn set_parameters(&mut self, kernel: &Kernel) { unsafe { tsKernel_setParameters(self.this, kernel.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsKernel_saveState(self.this, stream.this) != 0 } }
	fn set_shader(&mut self, shader: &mut Shader) { unsafe { tsKernel_setShader(self.this, shader.this, 0) } }
	fn set_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsKernel_setShader(self.this, shader.this, if owner {1} else {0}) } }
	fn compute_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsKernel_getComputeShader(self.this)) } }
	fn load_shader(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShader_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShaderGLSL_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderSPIRV(self.this, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShader_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShaderGLSL_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, data: &[u32]) -> bool { unsafe { tsKernel_createShaderSPIRV(self.this, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self) -> u32 { unsafe { tsKernel_addSampler(self.this) } }
	fn set_samplers(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplers(self.this, num)) } }
	fn num_samplers(&self) -> u32 { unsafe { tsKernel_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsKernel_getSamplerOffset(self.this) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self) -> u32 { unsafe { tsKernel_addTexture(self.this) } }
	fn set_textures(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextures(self.this, num)) } }
	fn num_textures(&self) -> u32 { unsafe { tsKernel_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsKernel_getTextureOffset(self.this) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsKernel_getTextureArray(self.this, index) } }
	fn add_surface(&mut self) -> u32 { unsafe { tsKernel_addSurface(self.this) } }
	fn set_surfaces(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaces(self.this, num)) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsKernel_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsKernel_getSurfaceOffset(self.this) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self) -> u32 { unsafe { tsKernel_addUniform(self.this, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addUniform(self.this, flags) } }
	fn set_uniforms(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_uniforms_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, flags)) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsKernel_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsKernel_getUniformOffset(self.this) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self) -> u32 { unsafe { tsKernel_addStorage(self.this, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addStorage(self.this, flags) } }
	fn set_storages(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_storages_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, flags)) } }
	fn num_storages(&self) -> u32 { unsafe { tsKernel_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsKernel_getStorageOffset(self.this) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self) -> u32 { unsafe { tsKernel_addTracing(self.this) } }
	fn set_tracings(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracings(self.this, num)) } }
	fn num_tracings(&self) -> u32 { unsafe { tsKernel_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsKernel_getTracingOffset(self.this) } }
	fn add_texel(&mut self) -> u32 { unsafe { tsKernel_addTexel(self.this) } }
	fn set_texels(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexels(self.this, num)) } }
	fn num_texels(&self) -> u32 { unsafe { tsKernel_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsKernel_getTexelOffset(self.this) } }
	fn add_table(&mut self, type_: TableType, size: u32) -> u32 { unsafe { tsKernel_addTable(self.this, type_, size) } }
	fn num_tables(&self) -> u32 { unsafe { tsKernel_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsKernel_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsKernel_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsKernel_getTableSize(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getTableFlags(self.this, index) } }
	fn set_group_size(&mut self, width: u32) { unsafe { tsKernel_setGroupSize(self.this, width, 1, 1) } }
	fn set_group_size_with_height(&mut self, width: u32, height: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, 1) } }
	fn set_group_size_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, depth) } }
	fn group_size_x(&self) -> u32 { unsafe { tsKernel_getGroupSizeX(self.this) } }
	fn group_size_y(&self) -> u32 { unsafe { tsKernel_getGroupSizeY(self.this) } }
	fn group_size_z(&self) -> u32 { unsafe { tsKernel_getGroupSizeZ(self.this) } }
}
impl Drop for Kernel {
	fn drop(&mut self) { if self.owner { unsafe { tsKernel_delete(self.this) } } }
}
impl Clone for Kernel {
	fn clone(&self) -> Kernel { unsafe { Kernel { this: tsKernel_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Kernel { }
impl fmt::Display for Kernel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Kernel ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsKernel_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsKernel_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsKernel_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsKernel_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsKernel_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsKernel_new() -> *mut c_void;
	fn tsKernel_delete(this: *mut c_void);
	fn tsKernel_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsKernel_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsKernel_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsKernel_clearPtr(this: *const c_void);
	fn tsKernel_destroyPtr(this: *const c_void);
	fn tsKernel_acquirePtr(this: *const c_void);
	fn tsKernel_unacquirePtr(this: *const c_void);
	fn tsKernel_isValidPtr(this: *const c_void) -> i32;
	fn tsKernel_isOwnerPtr(this: *const c_void) -> i32;
	fn tsKernel_isConstPtr(this: *const c_void) -> i32;
	fn tsKernel_getCountPtr(this: *const c_void) -> u32;
	fn tsKernel_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsKernel_getPlatform(this: *const c_void) -> Platform;
	fn tsKernel_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsKernel_getIndex(this: *const c_void) -> u32;
	fn tsKernel_clear(this: *mut c_void);
	fn tsKernel_isCreated(this: *const c_void) -> i32;
	fn tsKernel_setName(this: *mut c_void, name: *const c_char);
	fn tsKernel_getName(this: *const c_void) -> *mut c_void;
	fn tsKernel_create(this: *mut c_void) -> i32;
	fn tsKernel_setParameters(this: *mut c_void, kernel: *mut c_void);
	fn tsKernel_saveState(this: *const c_void, stream: *mut c_void) -> i32;
	fn tsKernel_setShader(this: *mut c_void, shader: *mut c_void, owner: i32);
	fn tsKernel_getComputeShader(this: *const c_void) -> *mut c_void;
	fn tsKernel_loadShader_ss(this: *mut c_void, name: *const c_char, format: *const c_char) -> i32;
	fn tsKernel_loadShaderGLSL_ss(this: *mut c_void, name: *const c_char, format: *const c_char) -> i32;
	fn tsKernel_loadShader_scSspu(this: *mut c_void, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsKernel_loadShaderGLSL_scSspu(this: *mut c_void, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsKernel_loadShaderSPIRV(this: *mut c_void, name: *const c_char) -> i32;
	fn tsKernel_createShader_ss(this: *mut c_void, src: *const c_char, format: *const c_char) -> i32;
	fn tsKernel_createShaderGLSL_ss(this: *mut c_void, src: *const c_char, format: *const c_char) -> i32;
	fn tsKernel_createShader_scSspu(this: *mut c_void, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsKernel_createShaderGLSL_scSspu(this: *mut c_void, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsKernel_createShaderSPIRV(this: *mut c_void, data: *const u32, data_size: u32) -> i32;
	fn tsKernel_addSampler(this: *mut c_void) -> u32;
	fn tsKernel_setSamplers(this: *mut c_void, num: u32) -> *mut c_void;
	fn tsKernel_getNumSamplers(this: *const c_void) -> u32;
	fn tsKernel_setSamplerOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getSamplerOffset(this: *const c_void) -> u32;
	fn tsKernel_setSamplerArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsKernel_getSamplerArray(this: *const c_void, index: u32) -> u32;
	fn tsKernel_addTexture(this: *mut c_void) -> u32;
	fn tsKernel_setTextures(this: *mut c_void, num: u32) -> *mut c_void;
	fn tsKernel_getNumTextures(this: *const c_void) -> u32;
	fn tsKernel_setTextureOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getTextureOffset(this: *const c_void) -> u32;
	fn tsKernel_setTextureArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsKernel_getTextureArray(this: *const c_void, index: u32) -> u32;
	fn tsKernel_addSurface(this: *mut c_void) -> u32;
	fn tsKernel_setSurfaces(this: *mut c_void, num: u32) -> *mut c_void;
	fn tsKernel_getNumSurfaces(this: *const c_void) -> u32;
	fn tsKernel_setSurfaceOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getSurfaceOffset(this: *const c_void) -> u32;
	fn tsKernel_setSurfaceArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsKernel_getSurfaceArray(this: *const c_void, index: u32) -> u32;
	fn tsKernel_addUniform(this: *mut c_void, flags: BindFlags) -> u32;
	fn tsKernel_setUniforms(this: *mut c_void, num: u32, flags: BindFlags) -> *mut c_void;
	fn tsKernel_getNumUniforms(this: *const c_void) -> u32;
	fn tsKernel_setUniformOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getUniformOffset(this: *const c_void) -> u32;
	fn tsKernel_setUniformFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsKernel_getUniformFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsKernel_addStorage(this: *mut c_void, flags: BindFlags) -> u32;
	fn tsKernel_setStorages(this: *mut c_void, num: u32, flags: BindFlags) -> *mut c_void;
	fn tsKernel_getNumStorages(this: *const c_void) -> u32;
	fn tsKernel_setStorageOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getStorageOffset(this: *const c_void) -> u32;
	fn tsKernel_setStorageFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsKernel_getStorageFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsKernel_addTracing(this: *mut c_void) -> u32;
	fn tsKernel_setTracings(this: *mut c_void, num: u32) -> *mut c_void;
	fn tsKernel_getNumTracings(this: *const c_void) -> u32;
	fn tsKernel_setTracingOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getTracingOffset(this: *const c_void) -> u32;
	fn tsKernel_addTexel(this: *mut c_void) -> u32;
	fn tsKernel_setTexels(this: *mut c_void, num: u32) -> *mut c_void;
	fn tsKernel_getNumTexels(this: *const c_void) -> u32;
	fn tsKernel_setTexelOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getTexelOffset(this: *const c_void) -> u32;
	fn tsKernel_addTable(this: *mut c_void, type_: TableType, size: u32) -> u32;
	fn tsKernel_getNumTables(this: *const c_void) -> u32;
	fn tsKernel_setTableOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsKernel_getTableOffset(this: *const c_void) -> u32;
	fn tsKernel_setTableType(this: *mut c_void, index: u32, type_: TableType, size: u32, flags: BindFlags) -> *mut c_void;
	fn tsKernel_getTableType(this: *const c_void, index: u32) -> TableType;
	fn tsKernel_getTableSize(this: *const c_void, index: u32) -> u32;
	fn tsKernel_setTableFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsKernel_getTableFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsKernel_setGroupSize(this: *mut c_void, width: u32, height: u32, depth: u32);
	fn tsKernel_getGroupSizeX(this: *const c_void) -> u32;
	fn tsKernel_getGroupSizeY(this: *const c_void) -> u32;
	fn tsKernel_getGroupSizeZ(this: *const c_void) -> u32;
}

// Tellusim::D3D12Kernel
pub struct D3D12Kernel {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Kernel {
	pub fn null() -> D3D12Kernel { D3D12Kernel { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Kernel { unsafe { D3D12Kernel { this: tsD3D12Kernel_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Kernel { unsafe { D3D12Kernel { this: ptr, owner: tsD3D12Kernel_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Kernel { unsafe { D3D12Kernel { this: tsD3D12Kernel_copyPtr(self.this), owner: true } } }
	pub fn from_kernel(ptr: &Kernel) -> D3D12Kernel { unsafe { D3D12Kernel::new_ptr(tsD3D12Kernel_castKernelPtr(ptr.this)) } }
	pub fn to_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsD3D12Kernel_baseKernelPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Kernel) -> bool { unsafe { tsD3D12Kernel_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Kernel { unsafe { D3D12Kernel { this: tsD3D12Kernel_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Kernel_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Kernel_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Kernel_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Kernel_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Kernel_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Kernel_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Kernel_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Kernel_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Kernel_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn root_signature(&self) -> *const c_void { unsafe { tsD3D12Kernel_getRootSignature(self.this) } }
}
impl KernelTrait for D3D12Kernel {
	fn platform(&self) -> Platform { unsafe { tsKernel_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsKernel_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsKernel_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsKernel_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsKernel_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsKernel_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsKernel_create(self.this) != 0 } }
	fn set_parameters(&mut self, kernel: &Kernel) { unsafe { tsKernel_setParameters(self.this, kernel.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsKernel_saveState(self.this, stream.this) != 0 } }
	fn set_shader(&mut self, shader: &mut Shader) { unsafe { tsKernel_setShader(self.this, shader.this, 0) } }
	fn set_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsKernel_setShader(self.this, shader.this, if owner {1} else {0}) } }
	fn compute_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsKernel_getComputeShader(self.this)) } }
	fn load_shader(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShader_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShaderGLSL_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderSPIRV(self.this, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShader_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShaderGLSL_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, data: &[u32]) -> bool { unsafe { tsKernel_createShaderSPIRV(self.this, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self) -> u32 { unsafe { tsKernel_addSampler(self.this) } }
	fn set_samplers(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplers(self.this, num)) } }
	fn num_samplers(&self) -> u32 { unsafe { tsKernel_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsKernel_getSamplerOffset(self.this) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self) -> u32 { unsafe { tsKernel_addTexture(self.this) } }
	fn set_textures(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextures(self.this, num)) } }
	fn num_textures(&self) -> u32 { unsafe { tsKernel_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsKernel_getTextureOffset(self.this) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsKernel_getTextureArray(self.this, index) } }
	fn add_surface(&mut self) -> u32 { unsafe { tsKernel_addSurface(self.this) } }
	fn set_surfaces(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaces(self.this, num)) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsKernel_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsKernel_getSurfaceOffset(self.this) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self) -> u32 { unsafe { tsKernel_addUniform(self.this, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addUniform(self.this, flags) } }
	fn set_uniforms(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_uniforms_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, flags)) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsKernel_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsKernel_getUniformOffset(self.this) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self) -> u32 { unsafe { tsKernel_addStorage(self.this, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addStorage(self.this, flags) } }
	fn set_storages(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_storages_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, flags)) } }
	fn num_storages(&self) -> u32 { unsafe { tsKernel_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsKernel_getStorageOffset(self.this) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self) -> u32 { unsafe { tsKernel_addTracing(self.this) } }
	fn set_tracings(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracings(self.this, num)) } }
	fn num_tracings(&self) -> u32 { unsafe { tsKernel_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsKernel_getTracingOffset(self.this) } }
	fn add_texel(&mut self) -> u32 { unsafe { tsKernel_addTexel(self.this) } }
	fn set_texels(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexels(self.this, num)) } }
	fn num_texels(&self) -> u32 { unsafe { tsKernel_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsKernel_getTexelOffset(self.this) } }
	fn add_table(&mut self, type_: TableType, size: u32) -> u32 { unsafe { tsKernel_addTable(self.this, type_, size) } }
	fn num_tables(&self) -> u32 { unsafe { tsKernel_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsKernel_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsKernel_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsKernel_getTableSize(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getTableFlags(self.this, index) } }
	fn set_group_size(&mut self, width: u32) { unsafe { tsKernel_setGroupSize(self.this, width, 1, 1) } }
	fn set_group_size_with_height(&mut self, width: u32, height: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, 1) } }
	fn set_group_size_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, depth) } }
	fn group_size_x(&self) -> u32 { unsafe { tsKernel_getGroupSizeX(self.this) } }
	fn group_size_y(&self) -> u32 { unsafe { tsKernel_getGroupSizeY(self.this) } }
	fn group_size_z(&self) -> u32 { unsafe { tsKernel_getGroupSizeZ(self.this) } }
}
impl Drop for D3D12Kernel {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Kernel_delete(self.this) } } }
}
impl Clone for D3D12Kernel {
	fn clone(&self) -> D3D12Kernel { unsafe { D3D12Kernel { this: tsD3D12Kernel_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Kernel { }
impl fmt::Display for D3D12Kernel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Kernel ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Kernel_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Kernel_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Kernel_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Kernel_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Kernel_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Kernel_new() -> *mut c_void;
	fn tsD3D12Kernel_delete(this: *mut c_void);
	fn tsD3D12Kernel_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Kernel_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Kernel_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Kernel_clearPtr(this: *const c_void);
	fn tsD3D12Kernel_destroyPtr(this: *const c_void);
	fn tsD3D12Kernel_acquirePtr(this: *const c_void);
	fn tsD3D12Kernel_unacquirePtr(this: *const c_void);
	fn tsD3D12Kernel_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Kernel_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Kernel_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Kernel_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Kernel_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Kernel_equalKernelPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Kernel_castKernelPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Kernel_baseKernelPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Kernel_getRootSignature(this: *const c_void) -> *const c_void;
}

// Tellusim::MTLKernel
pub struct MTLKernel {
	this: *mut c_void,
	owner: bool,
}
impl MTLKernel {
	pub fn null() -> MTLKernel { MTLKernel { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLKernel { unsafe { MTLKernel { this: tsMTLKernel_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLKernel { unsafe { MTLKernel { this: ptr, owner: tsMTLKernel_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLKernel { unsafe { MTLKernel { this: tsMTLKernel_copyPtr(self.this), owner: true } } }
	pub fn from_kernel(ptr: &Kernel) -> MTLKernel { unsafe { MTLKernel::new_ptr(tsMTLKernel_castKernelPtr(ptr.this)) } }
	pub fn to_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsMTLKernel_baseKernelPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLKernel) -> bool { unsafe { tsMTLKernel_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLKernel { unsafe { MTLKernel { this: tsMTLKernel_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLKernel_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLKernel_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLKernel_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLKernel_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLKernel_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLKernel_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLKernel_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLKernel_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLKernel_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_indirect(&mut self, enabled: bool) { unsafe { tsMTLKernel_setIndirect(self.this, if enabled {1} else {0}) } }
	pub fn is_indirect(&self) -> bool { unsafe { tsMTLKernel_isIndirect(self.this) != 0 } }
	pub fn compute_function(&self) -> *mut c_void { unsafe { tsMTLKernel_getComputeFunction(self.this) } }
}
impl KernelTrait for MTLKernel {
	fn platform(&self) -> Platform { unsafe { tsKernel_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsKernel_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsKernel_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsKernel_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsKernel_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsKernel_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsKernel_create(self.this) != 0 } }
	fn set_parameters(&mut self, kernel: &Kernel) { unsafe { tsKernel_setParameters(self.this, kernel.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsKernel_saveState(self.this, stream.this) != 0 } }
	fn set_shader(&mut self, shader: &mut Shader) { unsafe { tsKernel_setShader(self.this, shader.this, 0) } }
	fn set_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsKernel_setShader(self.this, shader.this, if owner {1} else {0}) } }
	fn compute_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsKernel_getComputeShader(self.this)) } }
	fn load_shader(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShader_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShaderGLSL_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderSPIRV(self.this, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShader_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShaderGLSL_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, data: &[u32]) -> bool { unsafe { tsKernel_createShaderSPIRV(self.this, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self) -> u32 { unsafe { tsKernel_addSampler(self.this) } }
	fn set_samplers(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplers(self.this, num)) } }
	fn num_samplers(&self) -> u32 { unsafe { tsKernel_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsKernel_getSamplerOffset(self.this) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self) -> u32 { unsafe { tsKernel_addTexture(self.this) } }
	fn set_textures(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextures(self.this, num)) } }
	fn num_textures(&self) -> u32 { unsafe { tsKernel_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsKernel_getTextureOffset(self.this) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsKernel_getTextureArray(self.this, index) } }
	fn add_surface(&mut self) -> u32 { unsafe { tsKernel_addSurface(self.this) } }
	fn set_surfaces(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaces(self.this, num)) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsKernel_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsKernel_getSurfaceOffset(self.this) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self) -> u32 { unsafe { tsKernel_addUniform(self.this, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addUniform(self.this, flags) } }
	fn set_uniforms(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_uniforms_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, flags)) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsKernel_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsKernel_getUniformOffset(self.this) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self) -> u32 { unsafe { tsKernel_addStorage(self.this, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addStorage(self.this, flags) } }
	fn set_storages(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_storages_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, flags)) } }
	fn num_storages(&self) -> u32 { unsafe { tsKernel_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsKernel_getStorageOffset(self.this) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self) -> u32 { unsafe { tsKernel_addTracing(self.this) } }
	fn set_tracings(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracings(self.this, num)) } }
	fn num_tracings(&self) -> u32 { unsafe { tsKernel_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsKernel_getTracingOffset(self.this) } }
	fn add_texel(&mut self) -> u32 { unsafe { tsKernel_addTexel(self.this) } }
	fn set_texels(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexels(self.this, num)) } }
	fn num_texels(&self) -> u32 { unsafe { tsKernel_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsKernel_getTexelOffset(self.this) } }
	fn add_table(&mut self, type_: TableType, size: u32) -> u32 { unsafe { tsKernel_addTable(self.this, type_, size) } }
	fn num_tables(&self) -> u32 { unsafe { tsKernel_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsKernel_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsKernel_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsKernel_getTableSize(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getTableFlags(self.this, index) } }
	fn set_group_size(&mut self, width: u32) { unsafe { tsKernel_setGroupSize(self.this, width, 1, 1) } }
	fn set_group_size_with_height(&mut self, width: u32, height: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, 1) } }
	fn set_group_size_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, depth) } }
	fn group_size_x(&self) -> u32 { unsafe { tsKernel_getGroupSizeX(self.this) } }
	fn group_size_y(&self) -> u32 { unsafe { tsKernel_getGroupSizeY(self.this) } }
	fn group_size_z(&self) -> u32 { unsafe { tsKernel_getGroupSizeZ(self.this) } }
}
impl Drop for MTLKernel {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLKernel_delete(self.this) } } }
}
impl Clone for MTLKernel {
	fn clone(&self) -> MTLKernel { unsafe { MTLKernel { this: tsMTLKernel_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLKernel { }
impl fmt::Display for MTLKernel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLKernel ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLKernel_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLKernel_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLKernel_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLKernel_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLKernel_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLKernel_new() -> *mut c_void;
	fn tsMTLKernel_delete(this: *mut c_void);
	fn tsMTLKernel_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLKernel_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLKernel_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLKernel_clearPtr(this: *const c_void);
	fn tsMTLKernel_destroyPtr(this: *const c_void);
	fn tsMTLKernel_acquirePtr(this: *const c_void);
	fn tsMTLKernel_unacquirePtr(this: *const c_void);
	fn tsMTLKernel_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLKernel_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLKernel_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLKernel_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLKernel_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLKernel_equalKernelPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLKernel_castKernelPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLKernel_baseKernelPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLKernel_setIndirect(this: *mut c_void, enabled: i32);
	fn tsMTLKernel_isIndirect(this: *const c_void) -> i32;
	fn tsMTLKernel_getComputeFunction(this: *const c_void) -> *mut c_void;
}

// Tellusim::FUKernel
pub struct FUKernel {
	this: *mut c_void,
	owner: bool,
}
impl FUKernel {
	pub fn null() -> FUKernel { FUKernel { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUKernel { unsafe { FUKernel { this: tsFUKernel_new(), owner: true } } }
	pub fn new_with_kernels(kernels: &[&mut Kernel]) -> FUKernel {
		let mut kernels_ = Vec::new();
		for ptr in kernels { kernels_.push(ptr.this); }
		unsafe { FUKernel { this: tsFUKernel_new_cAKb(kernels_.as_ptr(), kernels.len() as u32, 0), owner: true } }
	}
	pub fn new_with_kernels_owner(kernels: &[&mut Kernel], owner: bool) -> FUKernel {
		let mut kernels_ = Vec::new();
		for ptr in kernels { kernels_.push(ptr.this); }
		unsafe { FUKernel { this: tsFUKernel_new_cAKb(kernels_.as_ptr(), kernels.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUKernel { unsafe { FUKernel { this: ptr, owner: tsFUKernel_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUKernel { unsafe { FUKernel { this: tsFUKernel_copyPtr(self.this), owner: true } } }
	pub fn from_kernel(ptr: &Kernel) -> FUKernel { unsafe { FUKernel::new_ptr(tsFUKernel_castKernelPtr(ptr.this)) } }
	pub fn to_kernel(&self) -> Kernel { unsafe { Kernel::new_ptr(tsFUKernel_baseKernelPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUKernel) -> bool { unsafe { tsFUKernel_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUKernel { unsafe { FUKernel { this: tsFUKernel_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUKernel_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUKernel_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUKernel_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUKernel_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUKernel_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUKernel_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUKernel_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUKernel_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUKernel_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUKernel_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUKernel_getMask(self.this) } }
	pub fn num_kernels(&self) -> u32 { unsafe { tsFUKernel_getNumKernels(self.this) } }
	pub fn kernel(&self, index: u32) -> Kernel { unsafe { Kernel::new_ptr(tsFUKernel_getKernel_cu(self.this, index)) } }
	pub fn kernel_mut(&mut self, index: u32) -> Kernel { unsafe { Kernel::new_ptr(tsFUKernel_getKernel_u(self.this, index)) } }
}
impl KernelTrait for FUKernel {
	fn platform(&self) -> Platform { unsafe { tsKernel_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsKernel_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsKernel_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsKernel_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsKernel_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsKernel_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsKernel_create(self.this) != 0 } }
	fn set_parameters(&mut self, kernel: &Kernel) { unsafe { tsKernel_setParameters(self.this, kernel.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsKernel_saveState(self.this, stream.this) != 0 } }
	fn set_shader(&mut self, shader: &mut Shader) { unsafe { tsKernel_setShader(self.this, shader.this, 0) } }
	fn set_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsKernel_setShader(self.this, shader.this, if owner {1} else {0}) } }
	fn compute_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsKernel_getComputeShader(self.this)) } }
	fn load_shader(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShader_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_loadShaderGLSL_ss(self.this, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShader_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_loadShaderGLSL_scSspu(self.this, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsKernel_loadShaderSPIRV(self.this, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShader_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsKernel_createShaderGLSL_ss(self.this, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShader_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsKernel_createShaderGLSL_scSspu(self.this, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, data: &[u32]) -> bool { unsafe { tsKernel_createShaderSPIRV(self.this, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self) -> u32 { unsafe { tsKernel_addSampler(self.this) } }
	fn set_samplers(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplers(self.this, num)) } }
	fn num_samplers(&self) -> u32 { unsafe { tsKernel_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsKernel_getSamplerOffset(self.this) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self) -> u32 { unsafe { tsKernel_addTexture(self.this) } }
	fn set_textures(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextures(self.this, num)) } }
	fn num_textures(&self) -> u32 { unsafe { tsKernel_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsKernel_getTextureOffset(self.this) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsKernel_getTextureArray(self.this, index) } }
	fn add_surface(&mut self) -> u32 { unsafe { tsKernel_addSurface(self.this) } }
	fn set_surfaces(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaces(self.this, num)) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsKernel_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsKernel_getSurfaceOffset(self.this) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsKernel_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self) -> u32 { unsafe { tsKernel_addUniform(self.this, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addUniform(self.this, flags) } }
	fn set_uniforms(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_uniforms_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniforms(self.this, num, flags)) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsKernel_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsKernel_getUniformOffset(self.this) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self) -> u32 { unsafe { tsKernel_addStorage(self.this, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, flags: BindFlags) -> u32 { unsafe { tsKernel_addStorage(self.this, flags) } }
	fn set_storages(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, BindFlags::BindFlagNone)) } }
	fn set_storages_with_flags(&mut self, num: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorages(self.this, num, flags)) } }
	fn num_storages(&self) -> u32 { unsafe { tsKernel_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsKernel_getStorageOffset(self.this) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self) -> u32 { unsafe { tsKernel_addTracing(self.this) } }
	fn set_tracings(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracings(self.this, num)) } }
	fn num_tracings(&self) -> u32 { unsafe { tsKernel_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsKernel_getTracingOffset(self.this) } }
	fn add_texel(&mut self) -> u32 { unsafe { tsKernel_addTexel(self.this) } }
	fn set_texels(&mut self, num: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexels(self.this, num)) } }
	fn num_texels(&self) -> u32 { unsafe { tsKernel_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsKernel_getTexelOffset(self.this) } }
	fn add_table(&mut self, type_: TableType, size: u32) -> u32 { unsafe { tsKernel_addTable(self.this, type_, size) } }
	fn num_tables(&self) -> u32 { unsafe { tsKernel_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsKernel_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableType(self.this, index, type_, size, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsKernel_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsKernel_getTableSize(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Kernel { unsafe { Kernel::new_ptr(tsKernel_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsKernel_getTableFlags(self.this, index) } }
	fn set_group_size(&mut self, width: u32) { unsafe { tsKernel_setGroupSize(self.this, width, 1, 1) } }
	fn set_group_size_with_height(&mut self, width: u32, height: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, 1) } }
	fn set_group_size_with_height_depth(&mut self, width: u32, height: u32, depth: u32) { unsafe { tsKernel_setGroupSize(self.this, width, height, depth) } }
	fn group_size_x(&self) -> u32 { unsafe { tsKernel_getGroupSizeX(self.this) } }
	fn group_size_y(&self) -> u32 { unsafe { tsKernel_getGroupSizeY(self.this) } }
	fn group_size_z(&self) -> u32 { unsafe { tsKernel_getGroupSizeZ(self.this) } }
}
impl Drop for FUKernel {
	fn drop(&mut self) { if self.owner { unsafe { tsFUKernel_delete(self.this) } } }
}
impl Clone for FUKernel {
	fn clone(&self) -> FUKernel { unsafe { FUKernel { this: tsFUKernel_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUKernel { }
impl fmt::Display for FUKernel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUKernel ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUKernel_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUKernel_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUKernel_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUKernel_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUKernel_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUKernel_new() -> *mut c_void;
	fn tsFUKernel_new_cAKb(kernels: *const *mut c_void, kernels_size: u32, owner: i32) -> *mut c_void;
	fn tsFUKernel_delete(this: *mut c_void);
	fn tsFUKernel_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUKernel_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUKernel_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUKernel_clearPtr(this: *const c_void);
	fn tsFUKernel_destroyPtr(this: *const c_void);
	fn tsFUKernel_acquirePtr(this: *const c_void);
	fn tsFUKernel_unacquirePtr(this: *const c_void);
	fn tsFUKernel_isValidPtr(this: *const c_void) -> i32;
	fn tsFUKernel_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUKernel_isConstPtr(this: *const c_void) -> i32;
	fn tsFUKernel_getCountPtr(this: *const c_void) -> u32;
	fn tsFUKernel_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUKernel_equalKernelPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUKernel_castKernelPtr(this: *const c_void) -> *mut c_void;
	fn tsFUKernel_baseKernelPtr(this: *const c_void) -> *mut c_void;
	fn tsFUKernel_setMask(this: *mut c_void, mask: u32);
	fn tsFUKernel_getMask(this: *const c_void) -> u32;
	fn tsFUKernel_getNumKernels(this: *const c_void) -> u32;
	fn tsFUKernel_getKernel_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUKernel_getKernel_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Pipeline
pub struct Pipeline {
	this: *mut c_void,
	owner: bool,
}
impl Pipeline {
	pub fn null() -> Pipeline { Pipeline { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Pipeline { unsafe { Pipeline { this: tsPipeline_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Pipeline { unsafe { Pipeline { this: ptr, owner: tsPipeline_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Pipeline { unsafe { Pipeline { this: tsPipeline_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Pipeline) -> bool { unsafe { tsPipeline_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Pipeline { unsafe { Pipeline { this: tsPipeline_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsPipeline_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsPipeline_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsPipeline_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsPipeline_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsPipeline_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsPipeline_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsPipeline_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsPipeline_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsPipeline_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait PipelineTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn name(&self) -> string::String;
	fn create(&mut self) -> bool;
	fn set_parameters(&mut self, pipeline: &Pipeline);
	fn save_state(&self, stream: &mut Stream) -> bool;
	fn add_shader(&mut self, shader: &mut Shader);
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool);
	fn vertex_shader(&self) -> Shader;
	fn control_shader(&self) -> Shader;
	fn evaluate_shader(&self) -> Shader;
	fn geometry_shader(&self) -> Shader;
	fn fragment_shader(&self) -> Shader;
	fn task_shader(&self) -> Shader;
	fn mesh_shader(&self) -> Shader;
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool;
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool;
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool;
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool;
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool;
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool;
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool;
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool;
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool;
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool;
	fn add_sampler(&mut self, mask: ShaderMask) -> u32;
	fn num_samplers(&self) -> u32;
	fn set_sampler_offset(&mut self, offset: u32) -> Pipeline;
	fn sampler_offset(&self) -> u32;
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn sampler_mask(&self, index: u32) -> ShaderMask;
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline;
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline;
	fn sampler_array(&self, index: u32) -> u32;
	fn add_texture(&mut self, mask: ShaderMask) -> u32;
	fn num_textures(&self) -> u32;
	fn set_texture_offset(&mut self, offset: u32) -> Pipeline;
	fn texture_offset(&self) -> u32;
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn texture_mask(&self, index: u32) -> ShaderMask;
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline;
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline;
	fn texture_array(&self, index: u32) -> u32;
	fn add_surface(&mut self, mask: ShaderMask) -> u32;
	fn num_surfaces(&self) -> u32;
	fn set_surface_offset(&mut self, offset: u32) -> Pipeline;
	fn surface_offset(&self) -> u32;
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn surface_mask(&self, index: u32) -> ShaderMask;
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline;
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline;
	fn surface_array(&self, index: u32) -> u32;
	fn add_uniform(&mut self, mask: ShaderMask) -> u32;
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32;
	fn num_uniforms(&self) -> u32;
	fn set_uniform_offset(&mut self, offset: u32) -> Pipeline;
	fn uniform_offset(&self) -> u32;
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline;
	fn uniform_mask(&self, index: u32) -> ShaderMask;
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline;
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline;
	fn uniform_flags(&self, index: u32) -> BindFlags;
	fn add_storage(&mut self, mask: ShaderMask) -> u32;
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32;
	fn num_storages(&self) -> u32;
	fn set_storage_offset(&mut self, offset: u32) -> Pipeline;
	fn storage_offset(&self) -> u32;
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline;
	fn storage_mask(&self, index: u32) -> ShaderMask;
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline;
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline;
	fn storage_flags(&self, index: u32) -> BindFlags;
	fn add_tracing(&mut self, mask: ShaderMask) -> u32;
	fn num_tracings(&self) -> u32;
	fn set_tracing_offset(&mut self, offset: u32) -> Pipeline;
	fn tracing_offset(&self) -> u32;
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn tracing_mask(&self, index: u32) -> ShaderMask;
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn add_texel(&mut self, mask: ShaderMask) -> u32;
	fn num_texels(&self) -> u32;
	fn set_texel_offset(&mut self, offset: u32) -> Pipeline;
	fn texel_offset(&self) -> u32;
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn texel_mask(&self, index: u32) -> ShaderMask;
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline;
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32;
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32;
	fn num_tables(&self) -> u32;
	fn set_table_offset(&mut self, offset: u32) -> Pipeline;
	fn table_offset(&self) -> u32;
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Pipeline;
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline;
	fn table_type(&self, index: u32) -> TableType;
	fn table_size(&self, index: u32) -> u32;
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline;
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline;
	fn table_mask(&self, index: u32) -> ShaderMask;
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline;
	fn table_flags(&self, index: u32) -> BindFlags;
	fn num_vertices(&self) -> u32;
	fn vertex_stride(&self, index: u32) -> u32;
	fn vertex_rate(&self, index: u32) -> u32;
	fn add_attribute(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> u32;
	fn add_attribute_with_rate(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> u32;
	fn set_attribute(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> Pipeline;
	fn set_attribute_with_rate(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> Pipeline;
	fn set_attribute_type(&mut self, index: u32, attribute: PipelineAttribute) -> Pipeline;
	fn set_attribute_format(&mut self, index: u32, format: Format) -> Pipeline;
	fn set_attribute_vertex(&mut self, index: u32, vertex: u32) -> Pipeline;
	fn set_attribute_offset(&mut self, index: u32, offset: usize) -> Pipeline;
	fn set_attribute_stride(&mut self, index: u32, stride: usize) -> Pipeline;
	fn set_attribute_rate(&mut self, index: u32, rate: u32) -> Pipeline;
	fn num_attributes(&self) -> u32;
	fn attribute_type(&self, index: u32) -> PipelineAttribute;
	fn attribute_format(&self, index: u32) -> Format;
	fn attribute_vertex(&self, index: u32) -> u32;
	fn attribute_offset(&self, index: u32) -> u32;
	fn attribute_stride(&self, index: u32) -> u32;
	fn attribute_rate(&self, index: u32) -> u32;
	fn set_primitive(&mut self, primitive: PipelinePrimitive);
	fn primitive(&self) -> PipelinePrimitive;
	fn set_fill_mode(&mut self, mode: PipelineFillMode);
	fn fill_mode(&self) -> PipelineFillMode;
	fn set_cull_mode(&mut self, mode: PipelineCullMode);
	fn cull_mode(&self) -> PipelineCullMode;
	fn set_front_mode(&mut self, mode: PipelineFrontMode);
	fn front_mode(&self) -> PipelineFrontMode;
	fn set_depth_bias(&mut self, bias: f32, slope: f32);
	fn set_depth_bias_with_clamp(&mut self, bias: f32, slope: f32, clamp: f32);
	fn depth_bias(&self) -> f32;
	fn depth_slope(&self) -> f32;
	fn depth_clamp(&self) -> f32;
	fn set_multisample(&mut self, multisample: u32);
	fn multisample(&self) -> u32;
	fn set_sample_mask(&mut self, sample_mask: u32);
	fn sample_mask(&self) -> u32;
	fn set_depth_clip(&mut self, enabled: bool);
	fn depth_clip(&self) -> bool;
	fn set_depth_replace(&mut self, enabled: bool);
	fn depth_replace(&self) -> bool;
	fn set_scissor_test(&mut self, enabled: bool);
	fn scissor_test(&self) -> bool;
	fn set_raster_discard(&mut self, enabled: bool);
	fn raster_discard(&self) -> bool;
	fn set_sample_shading(&mut self, enabled: bool);
	fn sample_shading(&self) -> bool;
	fn set_alpha_to_coverage(&mut self, enabled: bool);
	fn alpha_to_coverage(&self) -> bool;
	fn set_multisample_raster(&mut self, enabled: bool);
	fn multisample_raster(&self) -> bool;
	fn set_conservative_raster(&mut self, enabled: bool);
	fn conservative_raster(&self) -> bool;
	fn set_num_viewports(&mut self, num_viewports: u32);
	fn num_targets(&self) -> u32;
	fn num_viewports(&self) -> u32;
	fn set_num_clip_distances(&mut self, num_distances: u32);
	fn num_clip_distances(&self) -> u32;
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn set_blend_color(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn set_blend_alpha(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn set_blend_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn set_blend_color_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn set_blend_alpha_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn blend_color_op(&self, index: u32) -> PipelineBlendOp;
	fn blend_alpha_op(&self, index: u32) -> PipelineBlendOp;
	fn blend_src_color_func(&self, index: u32) -> PipelineBlendFunc;
	fn blend_src_alpha_func(&self, index: u32) -> PipelineBlendFunc;
	fn blend_dest_color_func(&self, index: u32) -> PipelineBlendFunc;
	fn blend_dest_alpha_func(&self, index: u32) -> PipelineBlendFunc;
	fn set_color_mask(&mut self, mask: PipelineColorMask);
	fn set_color_mask_with_index(&mut self, index: u32, mask: PipelineColorMask);
	fn set_color_format(&mut self, index: u32, format: Format);
	fn set_color_format_with_format(&mut self, format: Format);
	fn set_color_format_with_format_num(&mut self, format: Format, num: u32);
	fn color_mask(&self, index: u32) -> PipelineColorMask;
	fn color_format(&self, index: u32) -> Format;
	fn set_depth_mask(&mut self, mask: PipelineDepthMask);
	fn set_depth_func(&mut self, func: PipelineDepthFunc);
	fn set_depth_format(&mut self, format: Format);
	fn depth_mask(&self) -> PipelineDepthMask;
	fn depth_func(&self) -> PipelineDepthFunc;
	fn depth_format(&self) -> Format;
	fn set_stencil_mask(&mut self, mask: u32);
	fn set_stencil_back_mask(&mut self, mask: u32);
	fn set_stencil_front_mask(&mut self, mask: u32);
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp);
	fn set_stencil_back_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp);
	fn set_stencil_front_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp);
	fn set_stencil_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn set_stencil_back_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn set_stencil_front_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn stencil_back_mask(&self) -> u32;
	fn stencil_back_func(&self) -> PipelineStencilFunc;
	fn stencil_back_fail_op(&self) -> PipelineStencilOp;
	fn stencil_back_depth_fail_op(&self) -> PipelineStencilOp;
	fn stencil_back_depth_pass_op(&self) -> PipelineStencilOp;
	fn stencil_front_mask(&self) -> u32;
	fn stencil_front_func(&self) -> PipelineStencilFunc;
	fn stencil_front_fail_op(&self) -> PipelineStencilOp;
	fn stencil_front_depth_fail_op(&self) -> PipelineStencilOp;
	fn stencil_front_depth_pass_op(&self) -> PipelineStencilOp;
}
impl PipelineTrait for Pipeline {
	fn platform(&self) -> Platform { unsafe { tsPipeline_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsPipeline_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsPipeline_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsPipeline_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsPipeline_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsPipeline_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsPipeline_create(self.this) != 0 } }
	fn set_parameters(&mut self, pipeline: &Pipeline) { unsafe { tsPipeline_setParameters(self.this, pipeline.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsPipeline_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsPipeline_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsPipeline_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn vertex_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getVertexShader(self.this)) } }
	fn control_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getControlShader(self.this)) } }
	fn evaluate_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getEvaluateShader(self.this)) } }
	fn geometry_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getGeometryShader(self.this)) } }
	fn fragment_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getFragmentShader(self.this)) } }
	fn task_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getTaskShader(self.this)) } }
	fn mesh_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getMeshShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsPipeline_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsPipeline_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsPipeline_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsPipeline_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsPipeline_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsPipeline_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsPipeline_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsPipeline_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsPipeline_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsPipeline_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsPipeline_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsPipeline_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsPipeline_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsPipeline_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsPipeline_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsPipeline_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsPipeline_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsPipeline_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsPipeline_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getTableFlags(self.this, index) } }
	fn num_vertices(&self) -> u32 { unsafe { tsPipeline_getNumVertices(self.this) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexStride(self.this, index) } }
	fn vertex_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexRate(self.this, index) } }
	fn add_attribute(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, 0) } }
	fn add_attribute_with_rate(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, rate) } }
	fn set_attribute(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, 0)) } }
	fn set_attribute_with_rate(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, rate)) } }
	fn set_attribute_type(&mut self, index: u32, attribute: PipelineAttribute) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeType(self.this, index, attribute)) } }
	fn set_attribute_format(&mut self, index: u32, format: Format) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeFormat(self.this, index, format)) } }
	fn set_attribute_vertex(&mut self, index: u32, vertex: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeVertex(self.this, index, vertex)) } }
	fn set_attribute_offset(&mut self, index: u32, offset: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeOffset(self.this, index, offset)) } }
	fn set_attribute_stride(&mut self, index: u32, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeStride(self.this, index, stride)) } }
	fn set_attribute_rate(&mut self, index: u32, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeRate(self.this, index, rate)) } }
	fn num_attributes(&self) -> u32 { unsafe { tsPipeline_getNumAttributes(self.this) } }
	fn attribute_type(&self, index: u32) -> PipelineAttribute { unsafe { tsPipeline_getAttributeType(self.this, index) } }
	fn attribute_format(&self, index: u32) -> Format { unsafe { tsPipeline_getAttributeFormat(self.this, index) } }
	fn attribute_vertex(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeVertex(self.this, index) } }
	fn attribute_offset(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeOffset(self.this, index) } }
	fn attribute_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeStride(self.this, index) } }
	fn attribute_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeRate(self.this, index) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsPipeline_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsPipeline_getPrimitive(self.this) } }
	fn set_fill_mode(&mut self, mode: PipelineFillMode) { unsafe { tsPipeline_setFillMode(self.this, mode) } }
	fn fill_mode(&self) -> PipelineFillMode { unsafe { tsPipeline_getFillMode(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsPipeline_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsPipeline_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsPipeline_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsPipeline_getFrontMode(self.this) } }
	fn set_depth_bias(&mut self, bias: f32, slope: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, 0.0) } }
	fn set_depth_bias_with_clamp(&mut self, bias: f32, slope: f32, clamp: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, clamp) } }
	fn depth_bias(&self) -> f32 { unsafe { tsPipeline_getDepthBias(self.this) } }
	fn depth_slope(&self) -> f32 { unsafe { tsPipeline_getDepthSlope(self.this) } }
	fn depth_clamp(&self) -> f32 { unsafe { tsPipeline_getDepthClamp(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsPipeline_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsPipeline_getMultisample(self.this) } }
	fn set_sample_mask(&mut self, sample_mask: u32) { unsafe { tsPipeline_setSampleMask(self.this, sample_mask) } }
	fn sample_mask(&self) -> u32 { unsafe { tsPipeline_getSampleMask(self.this) } }
	fn set_depth_clip(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthClip(self.this, if enabled {1} else {0}) } }
	fn depth_clip(&self) -> bool { unsafe { tsPipeline_getDepthClip(self.this) != 0 } }
	fn set_depth_replace(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthReplace(self.this, if enabled {1} else {0}) } }
	fn depth_replace(&self) -> bool { unsafe { tsPipeline_getDepthReplace(self.this) != 0 } }
	fn set_scissor_test(&mut self, enabled: bool) { unsafe { tsPipeline_setScissorTest(self.this, if enabled {1} else {0}) } }
	fn scissor_test(&self) -> bool { unsafe { tsPipeline_getScissorTest(self.this) != 0 } }
	fn set_raster_discard(&mut self, enabled: bool) { unsafe { tsPipeline_setRasterDiscard(self.this, if enabled {1} else {0}) } }
	fn raster_discard(&self) -> bool { unsafe { tsPipeline_getRasterDiscard(self.this) != 0 } }
	fn set_sample_shading(&mut self, enabled: bool) { unsafe { tsPipeline_setSampleShading(self.this, if enabled {1} else {0}) } }
	fn sample_shading(&self) -> bool { unsafe { tsPipeline_getSampleShading(self.this) != 0 } }
	fn set_alpha_to_coverage(&mut self, enabled: bool) { unsafe { tsPipeline_setAlphaToCoverage(self.this, if enabled {1} else {0}) } }
	fn alpha_to_coverage(&self) -> bool { unsafe { tsPipeline_getAlphaToCoverage(self.this) != 0 } }
	fn set_multisample_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setMultisampleRaster(self.this, if enabled {1} else {0}) } }
	fn multisample_raster(&self) -> bool { unsafe { tsPipeline_getMultisampleRaster(self.this) != 0 } }
	fn set_conservative_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setConservativeRaster(self.this, if enabled {1} else {0}) } }
	fn conservative_raster(&self) -> bool { unsafe { tsPipeline_getConservativeRaster(self.this) != 0 } }
	fn set_num_viewports(&mut self, num_viewports: u32) { unsafe { tsPipeline_setNumViewports(self.this, num_viewports) } }
	fn num_targets(&self) -> u32 { unsafe { tsPipeline_getNumTargets(self.this) } }
	fn num_viewports(&self) -> u32 { unsafe { tsPipeline_getNumViewports(self.this) } }
	fn set_num_clip_distances(&mut self, num_distances: u32) { unsafe { tsPipeline_setNumClipDistances(self.this, num_distances) } }
	fn num_clip_distances(&self) -> u32 { unsafe { tsPipeline_getNumClipDistances(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_color(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_alpha(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_color_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_alpha_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn blend_color_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendColorOp(self.this, index) } }
	fn blend_alpha_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendAlphaOp(self.this, index) } }
	fn blend_src_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcColorFunc(self.this, index) } }
	fn blend_src_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcAlphaFunc(self.this, index) } }
	fn blend_dest_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestColorFunc(self.this, index) } }
	fn blend_dest_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestAlphaFunc(self.this, index) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_PCM(self.this, mask) } }
	fn set_color_mask_with_index(&mut self, index: u32, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_uPCM(self.this, index, mask) } }
	fn set_color_format(&mut self, index: u32, format: Format) { unsafe { tsPipeline_setColorFormat_uF(self.this, index, format) } }
	fn set_color_format_with_format(&mut self, format: Format) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, 1) } }
	fn set_color_format_with_format_num(&mut self, format: Format, num: u32) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, num) } }
	fn color_mask(&self, index: u32) -> PipelineColorMask { unsafe { tsPipeline_getColorMask(self.this, index) } }
	fn color_format(&self, index: u32) -> Format { unsafe { tsPipeline_getColorFormat(self.this, index) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsPipeline_setDepthMask(self.this, mask) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsPipeline_setDepthFunc(self.this, func) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsPipeline_setDepthFormat(self.this, format) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsPipeline_getDepthMask(self.this) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsPipeline_getDepthFunc(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsPipeline_getDepthFormat(self.this) } }
	fn set_stencil_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilMask(self.this, mask) } }
	fn set_stencil_back_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilBackMask(self.this, mask) } }
	fn set_stencil_front_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilFrontMask(self.this, mask) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_back_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_front_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_back_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_front_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_back_mask(&self) -> u32 { unsafe { tsPipeline_getStencilBackMask(self.this) } }
	fn stencil_back_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilBackFunc(self.this) } }
	fn stencil_back_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackFailOp(self.this) } }
	fn stencil_back_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthFailOp(self.this) } }
	fn stencil_back_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthPassOp(self.this) } }
	fn stencil_front_mask(&self) -> u32 { unsafe { tsPipeline_getStencilFrontMask(self.this) } }
	fn stencil_front_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilFrontFunc(self.this) } }
	fn stencil_front_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontFailOp(self.this) } }
	fn stencil_front_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthFailOp(self.this) } }
	fn stencil_front_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthPassOp(self.this) } }
}
impl Drop for Pipeline {
	fn drop(&mut self) { if self.owner { unsafe { tsPipeline_delete(self.this) } } }
}
impl Clone for Pipeline {
	fn clone(&self) -> Pipeline { unsafe { Pipeline { this: tsPipeline_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Pipeline { }
impl fmt::Display for Pipeline {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Pipeline ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsPipeline_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsPipeline_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsPipeline_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsPipeline_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsPipeline_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsPipeline_new() -> *mut c_void;
	fn tsPipeline_delete(this: *mut c_void);
	fn tsPipeline_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsPipeline_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsPipeline_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsPipeline_clearPtr(this: *const c_void);
	fn tsPipeline_destroyPtr(this: *const c_void);
	fn tsPipeline_acquirePtr(this: *const c_void);
	fn tsPipeline_unacquirePtr(this: *const c_void);
	fn tsPipeline_isValidPtr(this: *const c_void) -> i32;
	fn tsPipeline_isOwnerPtr(this: *const c_void) -> i32;
	fn tsPipeline_isConstPtr(this: *const c_void) -> i32;
	fn tsPipeline_getCountPtr(this: *const c_void) -> u32;
	fn tsPipeline_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getPlatform(this: *const c_void) -> Platform;
	fn tsPipeline_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsPipeline_getIndex(this: *const c_void) -> u32;
	fn tsPipeline_clear(this: *mut c_void);
	fn tsPipeline_isCreated(this: *const c_void) -> i32;
	fn tsPipeline_setName(this: *mut c_void, name: *const c_char);
	fn tsPipeline_getName(this: *const c_void) -> *mut c_void;
	fn tsPipeline_create(this: *mut c_void) -> i32;
	fn tsPipeline_setParameters(this: *mut c_void, pipeline: *mut c_void);
	fn tsPipeline_saveState(this: *const c_void, stream: *mut c_void) -> i32;
	fn tsPipeline_addShader(this: *mut c_void, shader: *mut c_void, owner: i32);
	fn tsPipeline_getVertexShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getControlShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getEvaluateShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getGeometryShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getFragmentShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getTaskShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_getMeshShader(this: *const c_void) -> *mut c_void;
	fn tsPipeline_loadShader_STss(this: *mut c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> i32;
	fn tsPipeline_loadShaderGLSL_STss(this: *mut c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> i32;
	fn tsPipeline_loadShader_STscSspu(this: *mut c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsPipeline_loadShaderGLSL_STscSspu(this: *mut c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsPipeline_loadShaderSPIRV(this: *mut c_void, type_: ShaderType, name: *const c_char) -> i32;
	fn tsPipeline_createShader_STss(this: *mut c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> i32;
	fn tsPipeline_createShaderGLSL_STss(this: *mut c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> i32;
	fn tsPipeline_createShader_STscSspu(this: *mut c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsPipeline_createShaderGLSL_STscSspu(this: *mut c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsPipeline_createShaderSPIRV(this: *mut c_void, type_: ShaderType, data: *const u32, data_size: u32) -> i32;
	fn tsPipeline_addSampler(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsPipeline_getNumSamplers(this: *const c_void) -> u32;
	fn tsPipeline_setSamplerOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getSamplerOffset(this: *const c_void) -> u32;
	fn tsPipeline_setSamplerMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getSamplerMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setSamplerMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, array: i32) -> *mut c_void;
	fn tsPipeline_getSamplerMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_setSamplerArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsPipeline_getSamplerArray(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_addTexture(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsPipeline_getNumTextures(this: *const c_void) -> u32;
	fn tsPipeline_setTextureOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getTextureOffset(this: *const c_void) -> u32;
	fn tsPipeline_setTextureMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getTextureMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setTextureMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, array: i32) -> *mut c_void;
	fn tsPipeline_getTextureMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_setTextureArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsPipeline_getTextureArray(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_addSurface(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsPipeline_getNumSurfaces(this: *const c_void) -> u32;
	fn tsPipeline_setSurfaceOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getSurfaceOffset(this: *const c_void) -> u32;
	fn tsPipeline_setSurfaceMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getSurfaceMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setSurfaceMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, array: i32) -> *mut c_void;
	fn tsPipeline_getSurfaceMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_setSurfaceArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsPipeline_getSurfaceArray(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_addUniform(this: *mut c_void, mask: ShaderMask, flags: BindFlags) -> u32;
	fn tsPipeline_getNumUniforms(this: *const c_void) -> u32;
	fn tsPipeline_setUniformOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getUniformOffset(this: *const c_void) -> u32;
	fn tsPipeline_setUniformMask(this: *mut c_void, index: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getUniformMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setUniformMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getUniformMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_setUniformFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getUniformFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsPipeline_addStorage(this: *mut c_void, mask: ShaderMask, flags: BindFlags) -> u32;
	fn tsPipeline_getNumStorages(this: *const c_void) -> u32;
	fn tsPipeline_setStorageOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getStorageOffset(this: *const c_void) -> u32;
	fn tsPipeline_setStorageMask(this: *mut c_void, index: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getStorageMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setStorageMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getStorageMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_setStorageFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getStorageFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsPipeline_addTracing(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsPipeline_getNumTracings(this: *const c_void) -> u32;
	fn tsPipeline_setTracingOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getTracingOffset(this: *const c_void) -> u32;
	fn tsPipeline_setTracingMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getTracingMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setTracingMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getTracingMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_addTexel(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsPipeline_getNumTexels(this: *const c_void) -> u32;
	fn tsPipeline_setTexelOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getTexelOffset(this: *const c_void) -> u32;
	fn tsPipeline_setTexelMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getTexelMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setTexelMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask) -> *mut c_void;
	fn tsPipeline_getTexelMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsPipeline_addTable(this: *mut c_void, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32;
	fn tsPipeline_getNumTables(this: *const c_void) -> u32;
	fn tsPipeline_setTableOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsPipeline_getTableOffset(this: *const c_void) -> u32;
	fn tsPipeline_setTableType(this: *mut c_void, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getTableType(this: *const c_void, index: u32) -> TableType;
	fn tsPipeline_getTableSize(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_setTableMask(this: *mut c_void, index: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getTableMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsPipeline_setTableFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsPipeline_getTableFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsPipeline_getNumVertices(this: *const c_void) -> u32;
	fn tsPipeline_getVertexStride(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_getVertexRate(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_addAttribute(this: *mut c_void, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> u32;
	fn tsPipeline_setAttribute(this: *mut c_void, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> *mut c_void;
	fn tsPipeline_setAttributeType(this: *mut c_void, index: u32, attribute: PipelineAttribute) -> *mut c_void;
	fn tsPipeline_setAttributeFormat(this: *mut c_void, index: u32, format: Format) -> *mut c_void;
	fn tsPipeline_setAttributeVertex(this: *mut c_void, index: u32, vertex: u32) -> *mut c_void;
	fn tsPipeline_setAttributeOffset(this: *mut c_void, index: u32, offset: usize) -> *mut c_void;
	fn tsPipeline_setAttributeStride(this: *mut c_void, index: u32, stride: usize) -> *mut c_void;
	fn tsPipeline_setAttributeRate(this: *mut c_void, index: u32, rate: u32) -> *mut c_void;
	fn tsPipeline_getNumAttributes(this: *const c_void) -> u32;
	fn tsPipeline_getAttributeType(this: *const c_void, index: u32) -> PipelineAttribute;
	fn tsPipeline_getAttributeFormat(this: *const c_void, index: u32) -> Format;
	fn tsPipeline_getAttributeVertex(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_getAttributeOffset(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_getAttributeStride(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_getAttributeRate(this: *const c_void, index: u32) -> u32;
	fn tsPipeline_setPrimitive(this: *mut c_void, primitive: PipelinePrimitive);
	fn tsPipeline_getPrimitive(this: *const c_void) -> PipelinePrimitive;
	fn tsPipeline_setFillMode(this: *mut c_void, mode: PipelineFillMode);
	fn tsPipeline_getFillMode(this: *const c_void) -> PipelineFillMode;
	fn tsPipeline_setCullMode(this: *mut c_void, mode: PipelineCullMode);
	fn tsPipeline_getCullMode(this: *const c_void) -> PipelineCullMode;
	fn tsPipeline_setFrontMode(this: *mut c_void, mode: PipelineFrontMode);
	fn tsPipeline_getFrontMode(this: *const c_void) -> PipelineFrontMode;
	fn tsPipeline_setDepthBias(this: *mut c_void, bias: f32, slope: f32, clamp: f32);
	fn tsPipeline_getDepthBias(this: *const c_void) -> f32;
	fn tsPipeline_getDepthSlope(this: *const c_void) -> f32;
	fn tsPipeline_getDepthClamp(this: *const c_void) -> f32;
	fn tsPipeline_setMultisample(this: *mut c_void, multisample: u32);
	fn tsPipeline_getMultisample(this: *const c_void) -> u32;
	fn tsPipeline_setSampleMask(this: *mut c_void, sample_mask: u32);
	fn tsPipeline_getSampleMask(this: *const c_void) -> u32;
	fn tsPipeline_setDepthClip(this: *mut c_void, enabled: i32);
	fn tsPipeline_getDepthClip(this: *const c_void) -> i32;
	fn tsPipeline_setDepthReplace(this: *mut c_void, enabled: i32);
	fn tsPipeline_getDepthReplace(this: *const c_void) -> i32;
	fn tsPipeline_setScissorTest(this: *mut c_void, enabled: i32);
	fn tsPipeline_getScissorTest(this: *const c_void) -> i32;
	fn tsPipeline_setRasterDiscard(this: *mut c_void, enabled: i32);
	fn tsPipeline_getRasterDiscard(this: *const c_void) -> i32;
	fn tsPipeline_setSampleShading(this: *mut c_void, enabled: i32);
	fn tsPipeline_getSampleShading(this: *const c_void) -> i32;
	fn tsPipeline_setAlphaToCoverage(this: *mut c_void, enabled: i32);
	fn tsPipeline_getAlphaToCoverage(this: *const c_void) -> i32;
	fn tsPipeline_setMultisampleRaster(this: *mut c_void, enabled: i32);
	fn tsPipeline_getMultisampleRaster(this: *const c_void) -> i32;
	fn tsPipeline_setConservativeRaster(this: *mut c_void, enabled: i32);
	fn tsPipeline_getConservativeRaster(this: *const c_void) -> i32;
	fn tsPipeline_setNumViewports(this: *mut c_void, num_viewports: u32);
	fn tsPipeline_getNumTargets(this: *const c_void) -> u32;
	fn tsPipeline_getNumViewports(this: *const c_void) -> u32;
	fn tsPipeline_setNumClipDistances(this: *mut c_void, num_distances: u32);
	fn tsPipeline_getNumClipDistances(this: *const c_void) -> u32;
	fn tsPipeline_setBlend_PBOPBFPBF(this: *mut c_void, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsPipeline_setBlendColor_PBOPBFPBF(this: *mut c_void, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsPipeline_setBlendAlpha_PBOPBFPBF(this: *mut c_void, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsPipeline_setBlend_uPBOPBFPBF(this: *mut c_void, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsPipeline_setBlendColor_uPBOPBFPBF(this: *mut c_void, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsPipeline_setBlendAlpha_uPBOPBFPBF(this: *mut c_void, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsPipeline_getBlendColorOp(this: *const c_void, index: u32) -> PipelineBlendOp;
	fn tsPipeline_getBlendAlphaOp(this: *const c_void, index: u32) -> PipelineBlendOp;
	fn tsPipeline_getBlendSrcColorFunc(this: *const c_void, index: u32) -> PipelineBlendFunc;
	fn tsPipeline_getBlendSrcAlphaFunc(this: *const c_void, index: u32) -> PipelineBlendFunc;
	fn tsPipeline_getBlendDestColorFunc(this: *const c_void, index: u32) -> PipelineBlendFunc;
	fn tsPipeline_getBlendDestAlphaFunc(this: *const c_void, index: u32) -> PipelineBlendFunc;
	fn tsPipeline_setColorMask_PCM(this: *mut c_void, mask: PipelineColorMask);
	fn tsPipeline_setColorMask_uPCM(this: *mut c_void, index: u32, mask: PipelineColorMask);
	fn tsPipeline_setColorFormat_uF(this: *mut c_void, index: u32, format: Format);
	fn tsPipeline_setColorFormat_Fu(this: *mut c_void, format: Format, num: u32);
	fn tsPipeline_getColorMask(this: *const c_void, index: u32) -> PipelineColorMask;
	fn tsPipeline_getColorFormat(this: *const c_void, index: u32) -> Format;
	fn tsPipeline_setDepthMask(this: *mut c_void, mask: PipelineDepthMask);
	fn tsPipeline_setDepthFunc(this: *mut c_void, func: PipelineDepthFunc);
	fn tsPipeline_setDepthFormat(this: *mut c_void, format: Format);
	fn tsPipeline_getDepthMask(this: *const c_void) -> PipelineDepthMask;
	fn tsPipeline_getDepthFunc(this: *const c_void) -> PipelineDepthFunc;
	fn tsPipeline_getDepthFormat(this: *const c_void) -> Format;
	fn tsPipeline_setStencilMask(this: *mut c_void, mask: u32);
	fn tsPipeline_setStencilBackMask(this: *mut c_void, mask: u32);
	fn tsPipeline_setStencilFrontMask(this: *mut c_void, mask: u32);
	fn tsPipeline_setStencilFunc_PSFPSO(this: *mut c_void, func: PipelineStencilFunc, dpass_op: PipelineStencilOp);
	fn tsPipeline_setStencilBackFunc_PSFPSO(this: *mut c_void, func: PipelineStencilFunc, dpass_op: PipelineStencilOp);
	fn tsPipeline_setStencilFrontFunc_PSFPSO(this: *mut c_void, func: PipelineStencilFunc, dpass_op: PipelineStencilOp);
	fn tsPipeline_setStencilFunc_PSFPSOPSOPSO(this: *mut c_void, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(this: *mut c_void, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(this: *mut c_void, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn tsPipeline_getStencilBackMask(this: *const c_void) -> u32;
	fn tsPipeline_getStencilBackFunc(this: *const c_void) -> PipelineStencilFunc;
	fn tsPipeline_getStencilBackFailOp(this: *const c_void) -> PipelineStencilOp;
	fn tsPipeline_getStencilBackDepthFailOp(this: *const c_void) -> PipelineStencilOp;
	fn tsPipeline_getStencilBackDepthPassOp(this: *const c_void) -> PipelineStencilOp;
	fn tsPipeline_getStencilFrontMask(this: *const c_void) -> u32;
	fn tsPipeline_getStencilFrontFunc(this: *const c_void) -> PipelineStencilFunc;
	fn tsPipeline_getStencilFrontFailOp(this: *const c_void) -> PipelineStencilOp;
	fn tsPipeline_getStencilFrontDepthFailOp(this: *const c_void) -> PipelineStencilOp;
	fn tsPipeline_getStencilFrontDepthPassOp(this: *const c_void) -> PipelineStencilOp;
}

// Tellusim::D3D12Pipeline
pub struct D3D12Pipeline {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Pipeline {
	pub fn null() -> D3D12Pipeline { D3D12Pipeline { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Pipeline { unsafe { D3D12Pipeline { this: tsD3D12Pipeline_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Pipeline { unsafe { D3D12Pipeline { this: ptr, owner: tsD3D12Pipeline_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Pipeline { unsafe { D3D12Pipeline { this: tsD3D12Pipeline_copyPtr(self.this), owner: true } } }
	pub fn from_pipeline(ptr: &Pipeline) -> D3D12Pipeline { unsafe { D3D12Pipeline::new_ptr(tsD3D12Pipeline_castPipelinePtr(ptr.this)) } }
	pub fn to_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsD3D12Pipeline_basePipelinePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Pipeline) -> bool { unsafe { tsD3D12Pipeline_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Pipeline { unsafe { D3D12Pipeline { this: tsD3D12Pipeline_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Pipeline_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Pipeline_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Pipeline_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Pipeline_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Pipeline_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Pipeline_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Pipeline_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Pipeline_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Pipeline_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn root_signature(&self) -> *const c_void { unsafe { tsD3D12Pipeline_getRootSignature(self.this) } }
}
impl PipelineTrait for D3D12Pipeline {
	fn platform(&self) -> Platform { unsafe { tsPipeline_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsPipeline_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsPipeline_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsPipeline_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsPipeline_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsPipeline_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsPipeline_create(self.this) != 0 } }
	fn set_parameters(&mut self, pipeline: &Pipeline) { unsafe { tsPipeline_setParameters(self.this, pipeline.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsPipeline_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsPipeline_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsPipeline_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn vertex_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getVertexShader(self.this)) } }
	fn control_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getControlShader(self.this)) } }
	fn evaluate_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getEvaluateShader(self.this)) } }
	fn geometry_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getGeometryShader(self.this)) } }
	fn fragment_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getFragmentShader(self.this)) } }
	fn task_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getTaskShader(self.this)) } }
	fn mesh_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getMeshShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsPipeline_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsPipeline_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsPipeline_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsPipeline_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsPipeline_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsPipeline_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsPipeline_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsPipeline_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsPipeline_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsPipeline_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsPipeline_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsPipeline_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsPipeline_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsPipeline_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsPipeline_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsPipeline_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsPipeline_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsPipeline_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsPipeline_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getTableFlags(self.this, index) } }
	fn num_vertices(&self) -> u32 { unsafe { tsPipeline_getNumVertices(self.this) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexStride(self.this, index) } }
	fn vertex_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexRate(self.this, index) } }
	fn add_attribute(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, 0) } }
	fn add_attribute_with_rate(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, rate) } }
	fn set_attribute(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, 0)) } }
	fn set_attribute_with_rate(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, rate)) } }
	fn set_attribute_type(&mut self, index: u32, attribute: PipelineAttribute) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeType(self.this, index, attribute)) } }
	fn set_attribute_format(&mut self, index: u32, format: Format) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeFormat(self.this, index, format)) } }
	fn set_attribute_vertex(&mut self, index: u32, vertex: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeVertex(self.this, index, vertex)) } }
	fn set_attribute_offset(&mut self, index: u32, offset: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeOffset(self.this, index, offset)) } }
	fn set_attribute_stride(&mut self, index: u32, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeStride(self.this, index, stride)) } }
	fn set_attribute_rate(&mut self, index: u32, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeRate(self.this, index, rate)) } }
	fn num_attributes(&self) -> u32 { unsafe { tsPipeline_getNumAttributes(self.this) } }
	fn attribute_type(&self, index: u32) -> PipelineAttribute { unsafe { tsPipeline_getAttributeType(self.this, index) } }
	fn attribute_format(&self, index: u32) -> Format { unsafe { tsPipeline_getAttributeFormat(self.this, index) } }
	fn attribute_vertex(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeVertex(self.this, index) } }
	fn attribute_offset(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeOffset(self.this, index) } }
	fn attribute_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeStride(self.this, index) } }
	fn attribute_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeRate(self.this, index) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsPipeline_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsPipeline_getPrimitive(self.this) } }
	fn set_fill_mode(&mut self, mode: PipelineFillMode) { unsafe { tsPipeline_setFillMode(self.this, mode) } }
	fn fill_mode(&self) -> PipelineFillMode { unsafe { tsPipeline_getFillMode(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsPipeline_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsPipeline_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsPipeline_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsPipeline_getFrontMode(self.this) } }
	fn set_depth_bias(&mut self, bias: f32, slope: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, 0.0) } }
	fn set_depth_bias_with_clamp(&mut self, bias: f32, slope: f32, clamp: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, clamp) } }
	fn depth_bias(&self) -> f32 { unsafe { tsPipeline_getDepthBias(self.this) } }
	fn depth_slope(&self) -> f32 { unsafe { tsPipeline_getDepthSlope(self.this) } }
	fn depth_clamp(&self) -> f32 { unsafe { tsPipeline_getDepthClamp(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsPipeline_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsPipeline_getMultisample(self.this) } }
	fn set_sample_mask(&mut self, sample_mask: u32) { unsafe { tsPipeline_setSampleMask(self.this, sample_mask) } }
	fn sample_mask(&self) -> u32 { unsafe { tsPipeline_getSampleMask(self.this) } }
	fn set_depth_clip(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthClip(self.this, if enabled {1} else {0}) } }
	fn depth_clip(&self) -> bool { unsafe { tsPipeline_getDepthClip(self.this) != 0 } }
	fn set_depth_replace(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthReplace(self.this, if enabled {1} else {0}) } }
	fn depth_replace(&self) -> bool { unsafe { tsPipeline_getDepthReplace(self.this) != 0 } }
	fn set_scissor_test(&mut self, enabled: bool) { unsafe { tsPipeline_setScissorTest(self.this, if enabled {1} else {0}) } }
	fn scissor_test(&self) -> bool { unsafe { tsPipeline_getScissorTest(self.this) != 0 } }
	fn set_raster_discard(&mut self, enabled: bool) { unsafe { tsPipeline_setRasterDiscard(self.this, if enabled {1} else {0}) } }
	fn raster_discard(&self) -> bool { unsafe { tsPipeline_getRasterDiscard(self.this) != 0 } }
	fn set_sample_shading(&mut self, enabled: bool) { unsafe { tsPipeline_setSampleShading(self.this, if enabled {1} else {0}) } }
	fn sample_shading(&self) -> bool { unsafe { tsPipeline_getSampleShading(self.this) != 0 } }
	fn set_alpha_to_coverage(&mut self, enabled: bool) { unsafe { tsPipeline_setAlphaToCoverage(self.this, if enabled {1} else {0}) } }
	fn alpha_to_coverage(&self) -> bool { unsafe { tsPipeline_getAlphaToCoverage(self.this) != 0 } }
	fn set_multisample_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setMultisampleRaster(self.this, if enabled {1} else {0}) } }
	fn multisample_raster(&self) -> bool { unsafe { tsPipeline_getMultisampleRaster(self.this) != 0 } }
	fn set_conservative_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setConservativeRaster(self.this, if enabled {1} else {0}) } }
	fn conservative_raster(&self) -> bool { unsafe { tsPipeline_getConservativeRaster(self.this) != 0 } }
	fn set_num_viewports(&mut self, num_viewports: u32) { unsafe { tsPipeline_setNumViewports(self.this, num_viewports) } }
	fn num_targets(&self) -> u32 { unsafe { tsPipeline_getNumTargets(self.this) } }
	fn num_viewports(&self) -> u32 { unsafe { tsPipeline_getNumViewports(self.this) } }
	fn set_num_clip_distances(&mut self, num_distances: u32) { unsafe { tsPipeline_setNumClipDistances(self.this, num_distances) } }
	fn num_clip_distances(&self) -> u32 { unsafe { tsPipeline_getNumClipDistances(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_color(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_alpha(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_color_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_alpha_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn blend_color_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendColorOp(self.this, index) } }
	fn blend_alpha_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendAlphaOp(self.this, index) } }
	fn blend_src_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcColorFunc(self.this, index) } }
	fn blend_src_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcAlphaFunc(self.this, index) } }
	fn blend_dest_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestColorFunc(self.this, index) } }
	fn blend_dest_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestAlphaFunc(self.this, index) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_PCM(self.this, mask) } }
	fn set_color_mask_with_index(&mut self, index: u32, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_uPCM(self.this, index, mask) } }
	fn set_color_format(&mut self, index: u32, format: Format) { unsafe { tsPipeline_setColorFormat_uF(self.this, index, format) } }
	fn set_color_format_with_format(&mut self, format: Format) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, 1) } }
	fn set_color_format_with_format_num(&mut self, format: Format, num: u32) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, num) } }
	fn color_mask(&self, index: u32) -> PipelineColorMask { unsafe { tsPipeline_getColorMask(self.this, index) } }
	fn color_format(&self, index: u32) -> Format { unsafe { tsPipeline_getColorFormat(self.this, index) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsPipeline_setDepthMask(self.this, mask) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsPipeline_setDepthFunc(self.this, func) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsPipeline_setDepthFormat(self.this, format) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsPipeline_getDepthMask(self.this) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsPipeline_getDepthFunc(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsPipeline_getDepthFormat(self.this) } }
	fn set_stencil_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilMask(self.this, mask) } }
	fn set_stencil_back_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilBackMask(self.this, mask) } }
	fn set_stencil_front_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilFrontMask(self.this, mask) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_back_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_front_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_back_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_front_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_back_mask(&self) -> u32 { unsafe { tsPipeline_getStencilBackMask(self.this) } }
	fn stencil_back_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilBackFunc(self.this) } }
	fn stencil_back_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackFailOp(self.this) } }
	fn stencil_back_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthFailOp(self.this) } }
	fn stencil_back_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthPassOp(self.this) } }
	fn stencil_front_mask(&self) -> u32 { unsafe { tsPipeline_getStencilFrontMask(self.this) } }
	fn stencil_front_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilFrontFunc(self.this) } }
	fn stencil_front_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontFailOp(self.this) } }
	fn stencil_front_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthFailOp(self.this) } }
	fn stencil_front_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthPassOp(self.this) } }
}
impl Drop for D3D12Pipeline {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Pipeline_delete(self.this) } } }
}
impl Clone for D3D12Pipeline {
	fn clone(&self) -> D3D12Pipeline { unsafe { D3D12Pipeline { this: tsD3D12Pipeline_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Pipeline { }
impl fmt::Display for D3D12Pipeline {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Pipeline ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Pipeline_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Pipeline_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Pipeline_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Pipeline_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Pipeline_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Pipeline_new() -> *mut c_void;
	fn tsD3D12Pipeline_delete(this: *mut c_void);
	fn tsD3D12Pipeline_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Pipeline_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Pipeline_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Pipeline_clearPtr(this: *const c_void);
	fn tsD3D12Pipeline_destroyPtr(this: *const c_void);
	fn tsD3D12Pipeline_acquirePtr(this: *const c_void);
	fn tsD3D12Pipeline_unacquirePtr(this: *const c_void);
	fn tsD3D12Pipeline_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Pipeline_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Pipeline_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Pipeline_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Pipeline_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Pipeline_equalPipelinePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Pipeline_castPipelinePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Pipeline_basePipelinePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Pipeline_getRootSignature(this: *const c_void) -> *const c_void;
}

// Tellusim::MTLPipeline
pub struct MTLPipeline {
	this: *mut c_void,
	owner: bool,
}
impl MTLPipeline {
	pub fn null() -> MTLPipeline { MTLPipeline { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLPipeline { unsafe { MTLPipeline { this: tsMTLPipeline_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLPipeline { unsafe { MTLPipeline { this: ptr, owner: tsMTLPipeline_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLPipeline { unsafe { MTLPipeline { this: tsMTLPipeline_copyPtr(self.this), owner: true } } }
	pub fn from_pipeline(ptr: &Pipeline) -> MTLPipeline { unsafe { MTLPipeline::new_ptr(tsMTLPipeline_castPipelinePtr(ptr.this)) } }
	pub fn to_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsMTLPipeline_basePipelinePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLPipeline) -> bool { unsafe { tsMTLPipeline_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLPipeline { unsafe { MTLPipeline { this: tsMTLPipeline_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLPipeline_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLPipeline_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLPipeline_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLPipeline_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLPipeline_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLPipeline_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLPipeline_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLPipeline_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLPipeline_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_indirect(&mut self, enabled: bool) { unsafe { tsMTLPipeline_setIndirect(self.this, if enabled {1} else {0}) } }
	pub fn is_indirect(&self) -> bool { unsafe { tsMTLPipeline_isIndirect(self.this) != 0 } }
	pub fn vertex_function(&self) -> *mut c_void { unsafe { tsMTLPipeline_getVertexFunction(self.this) } }
	pub fn fragment_function(&self) -> *mut c_void { unsafe { tsMTLPipeline_getFragmentFunction(self.this) } }
}
impl PipelineTrait for MTLPipeline {
	fn platform(&self) -> Platform { unsafe { tsPipeline_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsPipeline_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsPipeline_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsPipeline_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsPipeline_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsPipeline_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsPipeline_create(self.this) != 0 } }
	fn set_parameters(&mut self, pipeline: &Pipeline) { unsafe { tsPipeline_setParameters(self.this, pipeline.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsPipeline_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsPipeline_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsPipeline_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn vertex_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getVertexShader(self.this)) } }
	fn control_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getControlShader(self.this)) } }
	fn evaluate_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getEvaluateShader(self.this)) } }
	fn geometry_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getGeometryShader(self.this)) } }
	fn fragment_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getFragmentShader(self.this)) } }
	fn task_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getTaskShader(self.this)) } }
	fn mesh_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getMeshShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsPipeline_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsPipeline_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsPipeline_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsPipeline_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsPipeline_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsPipeline_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsPipeline_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsPipeline_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsPipeline_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsPipeline_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsPipeline_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsPipeline_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsPipeline_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsPipeline_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsPipeline_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsPipeline_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsPipeline_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsPipeline_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsPipeline_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getTableFlags(self.this, index) } }
	fn num_vertices(&self) -> u32 { unsafe { tsPipeline_getNumVertices(self.this) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexStride(self.this, index) } }
	fn vertex_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexRate(self.this, index) } }
	fn add_attribute(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, 0) } }
	fn add_attribute_with_rate(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, rate) } }
	fn set_attribute(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, 0)) } }
	fn set_attribute_with_rate(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, rate)) } }
	fn set_attribute_type(&mut self, index: u32, attribute: PipelineAttribute) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeType(self.this, index, attribute)) } }
	fn set_attribute_format(&mut self, index: u32, format: Format) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeFormat(self.this, index, format)) } }
	fn set_attribute_vertex(&mut self, index: u32, vertex: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeVertex(self.this, index, vertex)) } }
	fn set_attribute_offset(&mut self, index: u32, offset: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeOffset(self.this, index, offset)) } }
	fn set_attribute_stride(&mut self, index: u32, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeStride(self.this, index, stride)) } }
	fn set_attribute_rate(&mut self, index: u32, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeRate(self.this, index, rate)) } }
	fn num_attributes(&self) -> u32 { unsafe { tsPipeline_getNumAttributes(self.this) } }
	fn attribute_type(&self, index: u32) -> PipelineAttribute { unsafe { tsPipeline_getAttributeType(self.this, index) } }
	fn attribute_format(&self, index: u32) -> Format { unsafe { tsPipeline_getAttributeFormat(self.this, index) } }
	fn attribute_vertex(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeVertex(self.this, index) } }
	fn attribute_offset(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeOffset(self.this, index) } }
	fn attribute_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeStride(self.this, index) } }
	fn attribute_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeRate(self.this, index) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsPipeline_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsPipeline_getPrimitive(self.this) } }
	fn set_fill_mode(&mut self, mode: PipelineFillMode) { unsafe { tsPipeline_setFillMode(self.this, mode) } }
	fn fill_mode(&self) -> PipelineFillMode { unsafe { tsPipeline_getFillMode(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsPipeline_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsPipeline_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsPipeline_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsPipeline_getFrontMode(self.this) } }
	fn set_depth_bias(&mut self, bias: f32, slope: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, 0.0) } }
	fn set_depth_bias_with_clamp(&mut self, bias: f32, slope: f32, clamp: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, clamp) } }
	fn depth_bias(&self) -> f32 { unsafe { tsPipeline_getDepthBias(self.this) } }
	fn depth_slope(&self) -> f32 { unsafe { tsPipeline_getDepthSlope(self.this) } }
	fn depth_clamp(&self) -> f32 { unsafe { tsPipeline_getDepthClamp(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsPipeline_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsPipeline_getMultisample(self.this) } }
	fn set_sample_mask(&mut self, sample_mask: u32) { unsafe { tsPipeline_setSampleMask(self.this, sample_mask) } }
	fn sample_mask(&self) -> u32 { unsafe { tsPipeline_getSampleMask(self.this) } }
	fn set_depth_clip(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthClip(self.this, if enabled {1} else {0}) } }
	fn depth_clip(&self) -> bool { unsafe { tsPipeline_getDepthClip(self.this) != 0 } }
	fn set_depth_replace(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthReplace(self.this, if enabled {1} else {0}) } }
	fn depth_replace(&self) -> bool { unsafe { tsPipeline_getDepthReplace(self.this) != 0 } }
	fn set_scissor_test(&mut self, enabled: bool) { unsafe { tsPipeline_setScissorTest(self.this, if enabled {1} else {0}) } }
	fn scissor_test(&self) -> bool { unsafe { tsPipeline_getScissorTest(self.this) != 0 } }
	fn set_raster_discard(&mut self, enabled: bool) { unsafe { tsPipeline_setRasterDiscard(self.this, if enabled {1} else {0}) } }
	fn raster_discard(&self) -> bool { unsafe { tsPipeline_getRasterDiscard(self.this) != 0 } }
	fn set_sample_shading(&mut self, enabled: bool) { unsafe { tsPipeline_setSampleShading(self.this, if enabled {1} else {0}) } }
	fn sample_shading(&self) -> bool { unsafe { tsPipeline_getSampleShading(self.this) != 0 } }
	fn set_alpha_to_coverage(&mut self, enabled: bool) { unsafe { tsPipeline_setAlphaToCoverage(self.this, if enabled {1} else {0}) } }
	fn alpha_to_coverage(&self) -> bool { unsafe { tsPipeline_getAlphaToCoverage(self.this) != 0 } }
	fn set_multisample_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setMultisampleRaster(self.this, if enabled {1} else {0}) } }
	fn multisample_raster(&self) -> bool { unsafe { tsPipeline_getMultisampleRaster(self.this) != 0 } }
	fn set_conservative_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setConservativeRaster(self.this, if enabled {1} else {0}) } }
	fn conservative_raster(&self) -> bool { unsafe { tsPipeline_getConservativeRaster(self.this) != 0 } }
	fn set_num_viewports(&mut self, num_viewports: u32) { unsafe { tsPipeline_setNumViewports(self.this, num_viewports) } }
	fn num_targets(&self) -> u32 { unsafe { tsPipeline_getNumTargets(self.this) } }
	fn num_viewports(&self) -> u32 { unsafe { tsPipeline_getNumViewports(self.this) } }
	fn set_num_clip_distances(&mut self, num_distances: u32) { unsafe { tsPipeline_setNumClipDistances(self.this, num_distances) } }
	fn num_clip_distances(&self) -> u32 { unsafe { tsPipeline_getNumClipDistances(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_color(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_alpha(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_color_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_alpha_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn blend_color_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendColorOp(self.this, index) } }
	fn blend_alpha_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendAlphaOp(self.this, index) } }
	fn blend_src_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcColorFunc(self.this, index) } }
	fn blend_src_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcAlphaFunc(self.this, index) } }
	fn blend_dest_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestColorFunc(self.this, index) } }
	fn blend_dest_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestAlphaFunc(self.this, index) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_PCM(self.this, mask) } }
	fn set_color_mask_with_index(&mut self, index: u32, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_uPCM(self.this, index, mask) } }
	fn set_color_format(&mut self, index: u32, format: Format) { unsafe { tsPipeline_setColorFormat_uF(self.this, index, format) } }
	fn set_color_format_with_format(&mut self, format: Format) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, 1) } }
	fn set_color_format_with_format_num(&mut self, format: Format, num: u32) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, num) } }
	fn color_mask(&self, index: u32) -> PipelineColorMask { unsafe { tsPipeline_getColorMask(self.this, index) } }
	fn color_format(&self, index: u32) -> Format { unsafe { tsPipeline_getColorFormat(self.this, index) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsPipeline_setDepthMask(self.this, mask) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsPipeline_setDepthFunc(self.this, func) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsPipeline_setDepthFormat(self.this, format) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsPipeline_getDepthMask(self.this) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsPipeline_getDepthFunc(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsPipeline_getDepthFormat(self.this) } }
	fn set_stencil_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilMask(self.this, mask) } }
	fn set_stencil_back_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilBackMask(self.this, mask) } }
	fn set_stencil_front_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilFrontMask(self.this, mask) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_back_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_front_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_back_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_front_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_back_mask(&self) -> u32 { unsafe { tsPipeline_getStencilBackMask(self.this) } }
	fn stencil_back_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilBackFunc(self.this) } }
	fn stencil_back_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackFailOp(self.this) } }
	fn stencil_back_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthFailOp(self.this) } }
	fn stencil_back_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthPassOp(self.this) } }
	fn stencil_front_mask(&self) -> u32 { unsafe { tsPipeline_getStencilFrontMask(self.this) } }
	fn stencil_front_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilFrontFunc(self.this) } }
	fn stencil_front_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontFailOp(self.this) } }
	fn stencil_front_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthFailOp(self.this) } }
	fn stencil_front_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthPassOp(self.this) } }
}
impl Drop for MTLPipeline {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLPipeline_delete(self.this) } } }
}
impl Clone for MTLPipeline {
	fn clone(&self) -> MTLPipeline { unsafe { MTLPipeline { this: tsMTLPipeline_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLPipeline { }
impl fmt::Display for MTLPipeline {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLPipeline ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLPipeline_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLPipeline_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLPipeline_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLPipeline_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLPipeline_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLPipeline_new() -> *mut c_void;
	fn tsMTLPipeline_delete(this: *mut c_void);
	fn tsMTLPipeline_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLPipeline_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLPipeline_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLPipeline_clearPtr(this: *const c_void);
	fn tsMTLPipeline_destroyPtr(this: *const c_void);
	fn tsMTLPipeline_acquirePtr(this: *const c_void);
	fn tsMTLPipeline_unacquirePtr(this: *const c_void);
	fn tsMTLPipeline_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLPipeline_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLPipeline_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLPipeline_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLPipeline_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLPipeline_equalPipelinePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLPipeline_castPipelinePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLPipeline_basePipelinePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLPipeline_setIndirect(this: *mut c_void, enabled: i32);
	fn tsMTLPipeline_isIndirect(this: *const c_void) -> i32;
	fn tsMTLPipeline_getVertexFunction(this: *const c_void) -> *mut c_void;
	fn tsMTLPipeline_getFragmentFunction(this: *const c_void) -> *mut c_void;
}

// Tellusim::FUPipeline
pub struct FUPipeline {
	this: *mut c_void,
	owner: bool,
}
impl FUPipeline {
	pub fn null() -> FUPipeline { FUPipeline { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUPipeline { unsafe { FUPipeline { this: tsFUPipeline_new(), owner: true } } }
	pub fn new_with_pipelines(pipelines: &[&mut Pipeline]) -> FUPipeline {
		let mut pipelines_ = Vec::new();
		for ptr in pipelines { pipelines_.push(ptr.this); }
		unsafe { FUPipeline { this: tsFUPipeline_new_cAPb(pipelines_.as_ptr(), pipelines.len() as u32, 0), owner: true } }
	}
	pub fn new_with_pipelines_owner(pipelines: &[&mut Pipeline], owner: bool) -> FUPipeline {
		let mut pipelines_ = Vec::new();
		for ptr in pipelines { pipelines_.push(ptr.this); }
		unsafe { FUPipeline { this: tsFUPipeline_new_cAPb(pipelines_.as_ptr(), pipelines.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUPipeline { unsafe { FUPipeline { this: ptr, owner: tsFUPipeline_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUPipeline { unsafe { FUPipeline { this: tsFUPipeline_copyPtr(self.this), owner: true } } }
	pub fn from_pipeline(ptr: &Pipeline) -> FUPipeline { unsafe { FUPipeline::new_ptr(tsFUPipeline_castPipelinePtr(ptr.this)) } }
	pub fn to_pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsFUPipeline_basePipelinePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUPipeline) -> bool { unsafe { tsFUPipeline_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUPipeline { unsafe { FUPipeline { this: tsFUPipeline_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUPipeline_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUPipeline_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUPipeline_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUPipeline_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUPipeline_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUPipeline_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUPipeline_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUPipeline_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUPipeline_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUPipeline_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUPipeline_getMask(self.this) } }
	pub fn num_pipelines(&self) -> u32 { unsafe { tsFUPipeline_getNumPipelines(self.this) } }
	pub fn pipeline(&self, index: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsFUPipeline_getPipeline_cu(self.this, index)) } }
	pub fn pipeline_mut(&mut self, index: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsFUPipeline_getPipeline_u(self.this, index)) } }
}
impl PipelineTrait for FUPipeline {
	fn platform(&self) -> Platform { unsafe { tsPipeline_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsPipeline_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsPipeline_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsPipeline_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsPipeline_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsPipeline_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsPipeline_create(self.this) != 0 } }
	fn set_parameters(&mut self, pipeline: &Pipeline) { unsafe { tsPipeline_setParameters(self.this, pipeline.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsPipeline_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsPipeline_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsPipeline_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn vertex_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getVertexShader(self.this)) } }
	fn control_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getControlShader(self.this)) } }
	fn evaluate_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getEvaluateShader(self.this)) } }
	fn geometry_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getGeometryShader(self.this)) } }
	fn fragment_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getFragmentShader(self.this)) } }
	fn task_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getTaskShader(self.this)) } }
	fn mesh_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsPipeline_getMeshShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsPipeline_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsPipeline_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsPipeline_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsPipeline_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsPipeline_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsPipeline_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsPipeline_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsPipeline_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsPipeline_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsPipeline_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsPipeline_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsPipeline_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsPipeline_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsPipeline_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsPipeline_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsPipeline_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsPipeline_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsPipeline_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsPipeline_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsPipeline_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsPipeline_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsPipeline_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsPipeline_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsPipeline_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsPipeline_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsPipeline_getTableFlags(self.this, index) } }
	fn num_vertices(&self) -> u32 { unsafe { tsPipeline_getNumVertices(self.this) } }
	fn vertex_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexStride(self.this, index) } }
	fn vertex_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getVertexRate(self.this, index) } }
	fn add_attribute(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, 0) } }
	fn add_attribute_with_rate(&mut self, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> u32 { unsafe { tsPipeline_addAttribute(self.this, attribute, format, vertex, offset, stride, rate) } }
	fn set_attribute(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, 0)) } }
	fn set_attribute_with_rate(&mut self, index: u32, attribute: PipelineAttribute, format: Format, vertex: u32, offset: usize, stride: usize, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttribute(self.this, index, attribute, format, vertex, offset, stride, rate)) } }
	fn set_attribute_type(&mut self, index: u32, attribute: PipelineAttribute) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeType(self.this, index, attribute)) } }
	fn set_attribute_format(&mut self, index: u32, format: Format) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeFormat(self.this, index, format)) } }
	fn set_attribute_vertex(&mut self, index: u32, vertex: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeVertex(self.this, index, vertex)) } }
	fn set_attribute_offset(&mut self, index: u32, offset: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeOffset(self.this, index, offset)) } }
	fn set_attribute_stride(&mut self, index: u32, stride: usize) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeStride(self.this, index, stride)) } }
	fn set_attribute_rate(&mut self, index: u32, rate: u32) -> Pipeline { unsafe { Pipeline::new_ptr(tsPipeline_setAttributeRate(self.this, index, rate)) } }
	fn num_attributes(&self) -> u32 { unsafe { tsPipeline_getNumAttributes(self.this) } }
	fn attribute_type(&self, index: u32) -> PipelineAttribute { unsafe { tsPipeline_getAttributeType(self.this, index) } }
	fn attribute_format(&self, index: u32) -> Format { unsafe { tsPipeline_getAttributeFormat(self.this, index) } }
	fn attribute_vertex(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeVertex(self.this, index) } }
	fn attribute_offset(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeOffset(self.this, index) } }
	fn attribute_stride(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeStride(self.this, index) } }
	fn attribute_rate(&self, index: u32) -> u32 { unsafe { tsPipeline_getAttributeRate(self.this, index) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsPipeline_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsPipeline_getPrimitive(self.this) } }
	fn set_fill_mode(&mut self, mode: PipelineFillMode) { unsafe { tsPipeline_setFillMode(self.this, mode) } }
	fn fill_mode(&self) -> PipelineFillMode { unsafe { tsPipeline_getFillMode(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsPipeline_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsPipeline_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsPipeline_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsPipeline_getFrontMode(self.this) } }
	fn set_depth_bias(&mut self, bias: f32, slope: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, 0.0) } }
	fn set_depth_bias_with_clamp(&mut self, bias: f32, slope: f32, clamp: f32) { unsafe { tsPipeline_setDepthBias(self.this, bias, slope, clamp) } }
	fn depth_bias(&self) -> f32 { unsafe { tsPipeline_getDepthBias(self.this) } }
	fn depth_slope(&self) -> f32 { unsafe { tsPipeline_getDepthSlope(self.this) } }
	fn depth_clamp(&self) -> f32 { unsafe { tsPipeline_getDepthClamp(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsPipeline_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsPipeline_getMultisample(self.this) } }
	fn set_sample_mask(&mut self, sample_mask: u32) { unsafe { tsPipeline_setSampleMask(self.this, sample_mask) } }
	fn sample_mask(&self) -> u32 { unsafe { tsPipeline_getSampleMask(self.this) } }
	fn set_depth_clip(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthClip(self.this, if enabled {1} else {0}) } }
	fn depth_clip(&self) -> bool { unsafe { tsPipeline_getDepthClip(self.this) != 0 } }
	fn set_depth_replace(&mut self, enabled: bool) { unsafe { tsPipeline_setDepthReplace(self.this, if enabled {1} else {0}) } }
	fn depth_replace(&self) -> bool { unsafe { tsPipeline_getDepthReplace(self.this) != 0 } }
	fn set_scissor_test(&mut self, enabled: bool) { unsafe { tsPipeline_setScissorTest(self.this, if enabled {1} else {0}) } }
	fn scissor_test(&self) -> bool { unsafe { tsPipeline_getScissorTest(self.this) != 0 } }
	fn set_raster_discard(&mut self, enabled: bool) { unsafe { tsPipeline_setRasterDiscard(self.this, if enabled {1} else {0}) } }
	fn raster_discard(&self) -> bool { unsafe { tsPipeline_getRasterDiscard(self.this) != 0 } }
	fn set_sample_shading(&mut self, enabled: bool) { unsafe { tsPipeline_setSampleShading(self.this, if enabled {1} else {0}) } }
	fn sample_shading(&self) -> bool { unsafe { tsPipeline_getSampleShading(self.this) != 0 } }
	fn set_alpha_to_coverage(&mut self, enabled: bool) { unsafe { tsPipeline_setAlphaToCoverage(self.this, if enabled {1} else {0}) } }
	fn alpha_to_coverage(&self) -> bool { unsafe { tsPipeline_getAlphaToCoverage(self.this) != 0 } }
	fn set_multisample_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setMultisampleRaster(self.this, if enabled {1} else {0}) } }
	fn multisample_raster(&self) -> bool { unsafe { tsPipeline_getMultisampleRaster(self.this) != 0 } }
	fn set_conservative_raster(&mut self, enabled: bool) { unsafe { tsPipeline_setConservativeRaster(self.this, if enabled {1} else {0}) } }
	fn conservative_raster(&self) -> bool { unsafe { tsPipeline_getConservativeRaster(self.this) != 0 } }
	fn set_num_viewports(&mut self, num_viewports: u32) { unsafe { tsPipeline_setNumViewports(self.this, num_viewports) } }
	fn num_targets(&self) -> u32 { unsafe { tsPipeline_getNumTargets(self.this) } }
	fn num_viewports(&self) -> u32 { unsafe { tsPipeline_getNumViewports(self.this) } }
	fn set_num_clip_distances(&mut self, num_distances: u32) { unsafe { tsPipeline_setNumClipDistances(self.this, num_distances) } }
	fn num_clip_distances(&self) -> u32 { unsafe { tsPipeline_getNumClipDistances(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_color(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_alpha(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_PBOPBFPBF(self.this, op, src, dest) } }
	fn set_blend_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlend_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_color_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendColor_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn set_blend_alpha_with_index(&mut self, index: u32, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsPipeline_setBlendAlpha_uPBOPBFPBF(self.this, index, op, src, dest) } }
	fn blend_color_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendColorOp(self.this, index) } }
	fn blend_alpha_op(&self, index: u32) -> PipelineBlendOp { unsafe { tsPipeline_getBlendAlphaOp(self.this, index) } }
	fn blend_src_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcColorFunc(self.this, index) } }
	fn blend_src_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendSrcAlphaFunc(self.this, index) } }
	fn blend_dest_color_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestColorFunc(self.this, index) } }
	fn blend_dest_alpha_func(&self, index: u32) -> PipelineBlendFunc { unsafe { tsPipeline_getBlendDestAlphaFunc(self.this, index) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_PCM(self.this, mask) } }
	fn set_color_mask_with_index(&mut self, index: u32, mask: PipelineColorMask) { unsafe { tsPipeline_setColorMask_uPCM(self.this, index, mask) } }
	fn set_color_format(&mut self, index: u32, format: Format) { unsafe { tsPipeline_setColorFormat_uF(self.this, index, format) } }
	fn set_color_format_with_format(&mut self, format: Format) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, 1) } }
	fn set_color_format_with_format_num(&mut self, format: Format, num: u32) { unsafe { tsPipeline_setColorFormat_Fu(self.this, format, num) } }
	fn color_mask(&self, index: u32) -> PipelineColorMask { unsafe { tsPipeline_getColorMask(self.this, index) } }
	fn color_format(&self, index: u32) -> Format { unsafe { tsPipeline_getColorFormat(self.this, index) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsPipeline_setDepthMask(self.this, mask) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsPipeline_setDepthFunc(self.this, func) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsPipeline_setDepthFormat(self.this, format) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsPipeline_getDepthMask(self.this) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsPipeline_getDepthFunc(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsPipeline_getDepthFormat(self.this) } }
	fn set_stencil_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilMask(self.this, mask) } }
	fn set_stencil_back_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilBackMask(self.this, mask) } }
	fn set_stencil_front_mask(&mut self, mask: u32) { unsafe { tsPipeline_setStencilFrontMask(self.this, mask) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_back_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_front_func(&mut self, func: PipelineStencilFunc, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSO(self.this, func, dpass_op) } }
	fn set_stencil_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_back_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn set_stencil_front_func_with_failop(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_back_mask(&self) -> u32 { unsafe { tsPipeline_getStencilBackMask(self.this) } }
	fn stencil_back_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilBackFunc(self.this) } }
	fn stencil_back_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackFailOp(self.this) } }
	fn stencil_back_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthFailOp(self.this) } }
	fn stencil_back_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilBackDepthPassOp(self.this) } }
	fn stencil_front_mask(&self) -> u32 { unsafe { tsPipeline_getStencilFrontMask(self.this) } }
	fn stencil_front_func(&self) -> PipelineStencilFunc { unsafe { tsPipeline_getStencilFrontFunc(self.this) } }
	fn stencil_front_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontFailOp(self.this) } }
	fn stencil_front_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthFailOp(self.this) } }
	fn stencil_front_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsPipeline_getStencilFrontDepthPassOp(self.this) } }
}
impl Drop for FUPipeline {
	fn drop(&mut self) { if self.owner { unsafe { tsFUPipeline_delete(self.this) } } }
}
impl Clone for FUPipeline {
	fn clone(&self) -> FUPipeline { unsafe { FUPipeline { this: tsFUPipeline_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUPipeline { }
impl fmt::Display for FUPipeline {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUPipeline ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUPipeline_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUPipeline_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUPipeline_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUPipeline_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUPipeline_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUPipeline_new() -> *mut c_void;
	fn tsFUPipeline_new_cAPb(pipelines: *const *mut c_void, pipelines_size: u32, owner: i32) -> *mut c_void;
	fn tsFUPipeline_delete(this: *mut c_void);
	fn tsFUPipeline_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUPipeline_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUPipeline_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUPipeline_clearPtr(this: *const c_void);
	fn tsFUPipeline_destroyPtr(this: *const c_void);
	fn tsFUPipeline_acquirePtr(this: *const c_void);
	fn tsFUPipeline_unacquirePtr(this: *const c_void);
	fn tsFUPipeline_isValidPtr(this: *const c_void) -> i32;
	fn tsFUPipeline_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUPipeline_isConstPtr(this: *const c_void) -> i32;
	fn tsFUPipeline_getCountPtr(this: *const c_void) -> u32;
	fn tsFUPipeline_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUPipeline_equalPipelinePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUPipeline_castPipelinePtr(this: *const c_void) -> *mut c_void;
	fn tsFUPipeline_basePipelinePtr(this: *const c_void) -> *mut c_void;
	fn tsFUPipeline_setMask(this: *mut c_void, mask: u32);
	fn tsFUPipeline_getMask(this: *const c_void) -> u32;
	fn tsFUPipeline_getNumPipelines(this: *const c_void) -> u32;
	fn tsFUPipeline_getPipeline_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUPipeline_getPipeline_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Traversal
pub struct Traversal {
	this: *mut c_void,
	owner: bool,
}
impl Traversal {
	pub fn null() -> Traversal { Traversal { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Traversal { unsafe { Traversal { this: tsTraversal_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Traversal { unsafe { Traversal { this: ptr, owner: tsTraversal_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Traversal { unsafe { Traversal { this: tsTraversal_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Traversal) -> bool { unsafe { tsTraversal_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Traversal { unsafe { Traversal { this: tsTraversal_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsTraversal_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsTraversal_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsTraversal_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsTraversal_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsTraversal_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsTraversal_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsTraversal_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsTraversal_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsTraversal_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait TraversalTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn clear(&mut self);
	fn is_created(&self) -> bool;
	fn set_name(&mut self, name: &str);
	fn name(&self) -> string::String;
	fn create(&mut self) -> bool;
	fn set_parameters(&mut self, traversal: &Traversal);
	fn save_state(&self, stream: &mut Stream) -> bool;
	fn add_shader(&mut self, shader: &mut Shader);
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool);
	fn ray_gen_shader(&self) -> Shader;
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool;
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool;
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool;
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool;
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool;
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool;
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool;
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool;
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool;
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool;
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool;
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool;
	fn add_sampler(&mut self, mask: ShaderMask) -> u32;
	fn num_samplers(&self) -> u32;
	fn set_sampler_offset(&mut self, offset: u32) -> Traversal;
	fn sampler_offset(&self) -> u32;
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn sampler_mask(&self, index: u32) -> ShaderMask;
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal;
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Traversal;
	fn sampler_array(&self, index: u32) -> u32;
	fn add_texture(&mut self, mask: ShaderMask) -> u32;
	fn num_textures(&self) -> u32;
	fn set_texture_offset(&mut self, offset: u32) -> Traversal;
	fn texture_offset(&self) -> u32;
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn texture_mask(&self, index: u32) -> ShaderMask;
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal;
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Traversal;
	fn texture_array(&self, index: u32) -> u32;
	fn add_surface(&mut self, mask: ShaderMask) -> u32;
	fn num_surfaces(&self) -> u32;
	fn set_surface_offset(&mut self, offset: u32) -> Traversal;
	fn surface_offset(&self) -> u32;
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn surface_mask(&self, index: u32) -> ShaderMask;
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal;
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Traversal;
	fn surface_array(&self, index: u32) -> u32;
	fn add_uniform(&mut self, mask: ShaderMask) -> u32;
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32;
	fn num_uniforms(&self) -> u32;
	fn set_uniform_offset(&mut self, offset: u32) -> Traversal;
	fn uniform_offset(&self) -> u32;
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal;
	fn uniform_mask(&self, index: u32) -> ShaderMask;
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal;
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Traversal;
	fn uniform_flags(&self, index: u32) -> BindFlags;
	fn add_storage(&mut self, mask: ShaderMask) -> u32;
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32;
	fn num_storages(&self) -> u32;
	fn set_storage_offset(&mut self, offset: u32) -> Traversal;
	fn storage_offset(&self) -> u32;
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal;
	fn storage_mask(&self, index: u32) -> ShaderMask;
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal;
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Traversal;
	fn storage_flags(&self, index: u32) -> BindFlags;
	fn add_tracing(&mut self, mask: ShaderMask) -> u32;
	fn num_tracings(&self) -> u32;
	fn set_tracing_offset(&mut self, offset: u32) -> Traversal;
	fn tracing_offset(&self) -> u32;
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn tracing_mask(&self, index: u32) -> ShaderMask;
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn add_texel(&mut self, mask: ShaderMask) -> u32;
	fn num_texels(&self) -> u32;
	fn set_texel_offset(&mut self, offset: u32) -> Traversal;
	fn texel_offset(&self) -> u32;
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn texel_mask(&self, index: u32) -> ShaderMask;
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal;
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask;
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32;
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32;
	fn num_tables(&self) -> u32;
	fn set_table_offset(&mut self, offset: u32) -> Traversal;
	fn table_offset(&self) -> u32;
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Traversal;
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Traversal;
	fn table_type(&self, index: u32) -> TableType;
	fn table_size(&self, index: u32) -> u32;
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal;
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal;
	fn table_mask(&self, index: u32) -> ShaderMask;
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Traversal;
	fn table_flags(&self, index: u32) -> BindFlags;
	fn set_recursion_depth(&mut self, depth: u32);
	fn recursion_depth(&self) -> u32;
}
impl TraversalTrait for Traversal {
	fn platform(&self) -> Platform { unsafe { tsTraversal_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTraversal_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTraversal_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTraversal_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTraversal_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTraversal_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsTraversal_create(self.this) != 0 } }
	fn set_parameters(&mut self, traversal: &Traversal) { unsafe { tsTraversal_setParameters(self.this, traversal.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsTraversal_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsTraversal_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsTraversal_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn ray_gen_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsTraversal_getRayGenShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsTraversal_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsTraversal_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsTraversal_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsTraversal_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsTraversal_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsTraversal_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsTraversal_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsTraversal_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsTraversal_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsTraversal_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsTraversal_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsTraversal_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsTraversal_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsTraversal_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsTraversal_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsTraversal_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsTraversal_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsTraversal_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsTraversal_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsTraversal_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsTraversal_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getTableFlags(self.this, index) } }
	fn set_recursion_depth(&mut self, depth: u32) { unsafe { tsTraversal_setRecursionDepth(self.this, depth) } }
	fn recursion_depth(&self) -> u32 { unsafe { tsTraversal_getRecursionDepth(self.this) } }
}
impl Drop for Traversal {
	fn drop(&mut self) { if self.owner { unsafe { tsTraversal_delete(self.this) } } }
}
impl Clone for Traversal {
	fn clone(&self) -> Traversal { unsafe { Traversal { this: tsTraversal_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Traversal { }
impl fmt::Display for Traversal {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Traversal ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsTraversal_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsTraversal_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsTraversal_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsTraversal_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsTraversal_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsTraversal_new() -> *mut c_void;
	fn tsTraversal_delete(this: *mut c_void);
	fn tsTraversal_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsTraversal_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsTraversal_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsTraversal_clearPtr(this: *const c_void);
	fn tsTraversal_destroyPtr(this: *const c_void);
	fn tsTraversal_acquirePtr(this: *const c_void);
	fn tsTraversal_unacquirePtr(this: *const c_void);
	fn tsTraversal_isValidPtr(this: *const c_void) -> i32;
	fn tsTraversal_isOwnerPtr(this: *const c_void) -> i32;
	fn tsTraversal_isConstPtr(this: *const c_void) -> i32;
	fn tsTraversal_getCountPtr(this: *const c_void) -> u32;
	fn tsTraversal_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsTraversal_getPlatform(this: *const c_void) -> Platform;
	fn tsTraversal_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsTraversal_getIndex(this: *const c_void) -> u32;
	fn tsTraversal_clear(this: *mut c_void);
	fn tsTraversal_isCreated(this: *const c_void) -> i32;
	fn tsTraversal_setName(this: *mut c_void, name: *const c_char);
	fn tsTraversal_getName(this: *const c_void) -> *mut c_void;
	fn tsTraversal_create(this: *mut c_void) -> i32;
	fn tsTraversal_setParameters(this: *mut c_void, traversal: *mut c_void);
	fn tsTraversal_saveState(this: *const c_void, stream: *mut c_void) -> i32;
	fn tsTraversal_addShader(this: *mut c_void, shader: *mut c_void, owner: i32);
	fn tsTraversal_getRayGenShader(this: *const c_void) -> *mut c_void;
	fn tsTraversal_loadShader_STss(this: *mut c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> i32;
	fn tsTraversal_loadShaderGLSL_STss(this: *mut c_void, type_: ShaderType, name: *const c_char, format: *const c_char) -> i32;
	fn tsTraversal_loadShader_STscSspu(this: *mut c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsTraversal_loadShaderGLSL_STscSspu(this: *mut c_void, type_: ShaderType, name: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsTraversal_loadShaderSPIRV(this: *mut c_void, type_: ShaderType, name: *const c_char) -> i32;
	fn tsTraversal_createShader_STss(this: *mut c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> i32;
	fn tsTraversal_createShaderGLSL_STss(this: *mut c_void, type_: ShaderType, src: *const c_char, format: *const c_char) -> i32;
	fn tsTraversal_createShader_STscSspu(this: *mut c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsTraversal_createShaderGLSL_STscSspu(this: *mut c_void, type_: ShaderType, src: *const c_char, macros: *mut c_void, includes: *const *const c_char, size: u32) -> i32;
	fn tsTraversal_createShaderSPIRV(this: *mut c_void, type_: ShaderType, data: *const u32, data_size: u32) -> i32;
	fn tsTraversal_addSampler(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsTraversal_getNumSamplers(this: *const c_void) -> u32;
	fn tsTraversal_setSamplerOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getSamplerOffset(this: *const c_void) -> u32;
	fn tsTraversal_setSamplerMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getSamplerMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setSamplerMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, array: i32) -> *mut c_void;
	fn tsTraversal_getSamplerMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_setSamplerArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsTraversal_getSamplerArray(this: *const c_void, index: u32) -> u32;
	fn tsTraversal_addTexture(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsTraversal_getNumTextures(this: *const c_void) -> u32;
	fn tsTraversal_setTextureOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getTextureOffset(this: *const c_void) -> u32;
	fn tsTraversal_setTextureMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getTextureMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setTextureMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, array: i32) -> *mut c_void;
	fn tsTraversal_getTextureMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_setTextureArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsTraversal_getTextureArray(this: *const c_void, index: u32) -> u32;
	fn tsTraversal_addSurface(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsTraversal_getNumSurfaces(this: *const c_void) -> u32;
	fn tsTraversal_setSurfaceOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getSurfaceOffset(this: *const c_void) -> u32;
	fn tsTraversal_setSurfaceMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getSurfaceMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setSurfaceMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, array: i32) -> *mut c_void;
	fn tsTraversal_getSurfaceMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_setSurfaceArray(this: *mut c_void, index: u32, num: u32, array: i32) -> *mut c_void;
	fn tsTraversal_getSurfaceArray(this: *const c_void, index: u32) -> u32;
	fn tsTraversal_addUniform(this: *mut c_void, mask: ShaderMask, flags: BindFlags) -> u32;
	fn tsTraversal_getNumUniforms(this: *const c_void) -> u32;
	fn tsTraversal_setUniformOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getUniformOffset(this: *const c_void) -> u32;
	fn tsTraversal_setUniformMask(this: *mut c_void, index: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getUniformMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setUniformMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getUniformMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_setUniformFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getUniformFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsTraversal_addStorage(this: *mut c_void, mask: ShaderMask, flags: BindFlags) -> u32;
	fn tsTraversal_getNumStorages(this: *const c_void) -> u32;
	fn tsTraversal_setStorageOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getStorageOffset(this: *const c_void) -> u32;
	fn tsTraversal_setStorageMask(this: *mut c_void, index: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getStorageMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setStorageMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getStorageMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_setStorageFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getStorageFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsTraversal_addTracing(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsTraversal_getNumTracings(this: *const c_void) -> u32;
	fn tsTraversal_setTracingOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getTracingOffset(this: *const c_void) -> u32;
	fn tsTraversal_setTracingMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getTracingMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setTracingMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getTracingMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_addTexel(this: *mut c_void, mask: ShaderMask) -> u32;
	fn tsTraversal_getNumTexels(this: *const c_void) -> u32;
	fn tsTraversal_setTexelOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getTexelOffset(this: *const c_void) -> u32;
	fn tsTraversal_setTexelMask(this: *mut c_void, index: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getTexelMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setTexelMasks(this: *mut c_void, index: u32, num: u32, mask: ShaderMask) -> *mut c_void;
	fn tsTraversal_getTexelMasks(this: *const c_void, index: u32, num: u32) -> ShaderMask;
	fn tsTraversal_addTable(this: *mut c_void, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32;
	fn tsTraversal_getNumTables(this: *const c_void) -> u32;
	fn tsTraversal_setTableOffset(this: *mut c_void, offset: u32) -> *mut c_void;
	fn tsTraversal_getTableOffset(this: *const c_void) -> u32;
	fn tsTraversal_setTableType(this: *mut c_void, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getTableType(this: *const c_void, index: u32) -> TableType;
	fn tsTraversal_getTableSize(this: *const c_void, index: u32) -> u32;
	fn tsTraversal_setTableMask(this: *mut c_void, index: u32, mask: ShaderMask, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getTableMask(this: *const c_void, index: u32) -> ShaderMask;
	fn tsTraversal_setTableFlags(this: *mut c_void, index: u32, flags: BindFlags) -> *mut c_void;
	fn tsTraversal_getTableFlags(this: *const c_void, index: u32) -> BindFlags;
	fn tsTraversal_setRecursionDepth(this: *mut c_void, depth: u32);
	fn tsTraversal_getRecursionDepth(this: *const c_void) -> u32;
}

// Tellusim::D3D12Traversal
pub struct D3D12Traversal {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Traversal {
	pub fn null() -> D3D12Traversal { D3D12Traversal { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Traversal { unsafe { D3D12Traversal { this: tsD3D12Traversal_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Traversal { unsafe { D3D12Traversal { this: ptr, owner: tsD3D12Traversal_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Traversal { unsafe { D3D12Traversal { this: tsD3D12Traversal_copyPtr(self.this), owner: true } } }
	pub fn from_traversal(ptr: &Traversal) -> D3D12Traversal { unsafe { D3D12Traversal::new_ptr(tsD3D12Traversal_castTraversalPtr(ptr.this)) } }
	pub fn to_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsD3D12Traversal_baseTraversalPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Traversal) -> bool { unsafe { tsD3D12Traversal_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Traversal { unsafe { D3D12Traversal { this: tsD3D12Traversal_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Traversal_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Traversal_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Traversal_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Traversal_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Traversal_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Traversal_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Traversal_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Traversal_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Traversal_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn root_signature(&self) -> *const c_void { unsafe { tsD3D12Traversal_getRootSignature(self.this) } }
}
impl TraversalTrait for D3D12Traversal {
	fn platform(&self) -> Platform { unsafe { tsTraversal_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTraversal_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTraversal_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTraversal_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTraversal_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTraversal_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsTraversal_create(self.this) != 0 } }
	fn set_parameters(&mut self, traversal: &Traversal) { unsafe { tsTraversal_setParameters(self.this, traversal.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsTraversal_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsTraversal_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsTraversal_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn ray_gen_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsTraversal_getRayGenShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsTraversal_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsTraversal_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsTraversal_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsTraversal_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsTraversal_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsTraversal_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsTraversal_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsTraversal_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsTraversal_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsTraversal_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsTraversal_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsTraversal_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsTraversal_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsTraversal_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsTraversal_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsTraversal_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsTraversal_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsTraversal_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsTraversal_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsTraversal_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsTraversal_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getTableFlags(self.this, index) } }
	fn set_recursion_depth(&mut self, depth: u32) { unsafe { tsTraversal_setRecursionDepth(self.this, depth) } }
	fn recursion_depth(&self) -> u32 { unsafe { tsTraversal_getRecursionDepth(self.this) } }
}
impl Drop for D3D12Traversal {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Traversal_delete(self.this) } } }
}
impl Clone for D3D12Traversal {
	fn clone(&self) -> D3D12Traversal { unsafe { D3D12Traversal { this: tsD3D12Traversal_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Traversal { }
impl fmt::Display for D3D12Traversal {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Traversal ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Traversal_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Traversal_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Traversal_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Traversal_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Traversal_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Traversal_new() -> *mut c_void;
	fn tsD3D12Traversal_delete(this: *mut c_void);
	fn tsD3D12Traversal_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Traversal_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Traversal_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Traversal_clearPtr(this: *const c_void);
	fn tsD3D12Traversal_destroyPtr(this: *const c_void);
	fn tsD3D12Traversal_acquirePtr(this: *const c_void);
	fn tsD3D12Traversal_unacquirePtr(this: *const c_void);
	fn tsD3D12Traversal_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Traversal_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Traversal_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Traversal_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Traversal_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Traversal_equalTraversalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Traversal_castTraversalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Traversal_baseTraversalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Traversal_getRootSignature(this: *const c_void) -> *const c_void;
}

// Tellusim::FUTraversal
pub struct FUTraversal {
	this: *mut c_void,
	owner: bool,
}
impl FUTraversal {
	pub fn null() -> FUTraversal { FUTraversal { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FUTraversal { unsafe { FUTraversal { this: tsFUTraversal_new(), owner: true } } }
	pub fn new_with_traversals(traversals: &[&mut Traversal]) -> FUTraversal {
		let mut traversals_ = Vec::new();
		for ptr in traversals { traversals_.push(ptr.this); }
		unsafe { FUTraversal { this: tsFUTraversal_new_cATb(traversals_.as_ptr(), traversals.len() as u32, 0), owner: true } }
	}
	pub fn new_with_traversals_owner(traversals: &[&mut Traversal], owner: bool) -> FUTraversal {
		let mut traversals_ = Vec::new();
		for ptr in traversals { traversals_.push(ptr.this); }
		unsafe { FUTraversal { this: tsFUTraversal_new_cATb(traversals_.as_ptr(), traversals.len() as u32, if owner {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> FUTraversal { unsafe { FUTraversal { this: ptr, owner: tsFUTraversal_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FUTraversal { unsafe { FUTraversal { this: tsFUTraversal_copyPtr(self.this), owner: true } } }
	pub fn from_traversal(ptr: &Traversal) -> FUTraversal { unsafe { FUTraversal::new_ptr(tsFUTraversal_castTraversalPtr(ptr.this)) } }
	pub fn to_traversal(&self) -> Traversal { unsafe { Traversal::new_ptr(tsFUTraversal_baseTraversalPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: FUTraversal) -> bool { unsafe { tsFUTraversal_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FUTraversal { unsafe { FUTraversal { this: tsFUTraversal_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFUTraversal_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFUTraversal_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFUTraversal_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFUTraversal_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFUTraversal_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFUTraversal_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFUTraversal_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFUTraversal_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFUTraversal_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_mask(&mut self, mask: u32) { unsafe { tsFUTraversal_setMask(self.this, mask) } }
	pub fn mask(&self) -> u32 { unsafe { tsFUTraversal_getMask(self.this) } }
	pub fn num_traversals(&self) -> u32 { unsafe { tsFUTraversal_getNumTraversals(self.this) } }
	pub fn traversal(&self, index: u32) -> Traversal { unsafe { Traversal::new_ptr(tsFUTraversal_getTraversal_cu(self.this, index)) } }
	pub fn traversal_mut(&mut self, index: u32) -> Traversal { unsafe { Traversal::new_ptr(tsFUTraversal_getTraversal_u(self.this, index)) } }
}
impl TraversalTrait for FUTraversal {
	fn platform(&self) -> Platform { unsafe { tsTraversal_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsTraversal_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsTraversal_getIndex(self.this) } }
	fn clear(&mut self) { unsafe { tsTraversal_clear(self.this) } }
	fn is_created(&self) -> bool { unsafe { tsTraversal_isCreated(self.this) != 0 } }
	fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_setName(self.this, name_.as_ptr()) }
	}
	fn name(&self) -> string::String { unsafe { get_string(tsTraversal_getName(self.this)) } }
	fn create(&mut self) -> bool { unsafe { tsTraversal_create(self.this) != 0 } }
	fn set_parameters(&mut self, traversal: &Traversal) { unsafe { tsTraversal_setParameters(self.this, traversal.this) } }
	fn save_state(&self, stream: &mut Stream) -> bool { unsafe { tsTraversal_saveState(self.this, stream.this) != 0 } }
	fn add_shader(&mut self, shader: &mut Shader) { unsafe { tsTraversal_addShader(self.this, shader.this, 0) } }
	fn add_shader_with_owner(&mut self, shader: &mut Shader, owner: bool) { unsafe { tsTraversal_addShader(self.this, shader.this, if owner {1} else {0}) } }
	fn ray_gen_shader(&self) -> Shader { unsafe { Shader::new_ptr(tsTraversal_getRayGenShader(self.this)) } }
	fn load_shader(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_loadShader_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_glsl(&mut self, type_: ShaderType, name: &str, format: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_loadShaderGLSL_STss(self.this, type_, name_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn load_shader_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_loadShader_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_glsl_with_macros(&mut self, type_: ShaderType, name: &str, macros: &String) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn load_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, name: &str, macros: &String, includes: &[&str]) -> bool {
		let name_ = CString::new(name).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_loadShaderGLSL_STscSspu(self.this, type_, name_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn load_shader_spirv(&mut self, type_: ShaderType, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsTraversal_loadShaderSPIRV(self.this, type_, name_.as_ptr()) != 0 }
	}
	fn create_shader(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_createShader_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_glsl(&mut self, type_: ShaderType, src: &str, format: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		let format_ = CString::new(format).unwrap();
		unsafe { tsTraversal_createShaderGLSL_STss(self.this, type_, src_.as_ptr(), format_.as_ptr()) != 0 }
	}
	fn create_shader_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsTraversal_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_createShader_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_glsl_with_macros(&mut self, type_: ShaderType, src: &str, macros: &String) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsTraversal_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, ptr::null_mut(), 0) != 0 }
	}
	fn create_shader_glsl_with_macros_includes(&mut self, type_: ShaderType, src: &str, macros: &String, includes: &[&str]) -> bool {
		let src_ = CString::new(src).unwrap();
		let mut includes_ = Vec::new();
		let mut includes__ = Vec::new();
		for it in includes {
			includes_.push(CString::new(*it).unwrap());
			includes__.push(includes_.last().unwrap().as_ptr());
		}
		unsafe { tsTraversal_createShaderGLSL_STscSspu(self.this, type_, src_.as_ptr(), macros.this, includes__.as_ptr(), includes__.len() as u32) != 0 }
	}
	fn create_shader_spirv(&mut self, type_: ShaderType, data: &[u32]) -> bool { unsafe { tsTraversal_createShaderSPIRV(self.this, type_, data.as_ptr(), data.len() as u32) != 0 } }
	fn add_sampler(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addSampler(self.this, mask) } }
	fn num_samplers(&self) -> u32 { unsafe { tsTraversal_getNumSamplers(self.this) } }
	fn set_sampler_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerOffset(self.this, offset)) } }
	fn sampler_offset(&self) -> u32 { unsafe { tsTraversal_getSamplerOffset(self.this) } }
	fn set_sampler_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMask(self.this, index, mask)) } }
	fn sampler_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getSamplerMask(self.this, index) } }
	fn set_sampler_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMasks(self.this, index, num, mask, 0)) } }
	fn set_sampler_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn sampler_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getSamplerMasks(self.this, index, num) } }
	fn set_sampler_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSamplerArray(self.this, index, num, if array {1} else {0})) } }
	fn sampler_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getSamplerArray(self.this, index) } }
	fn add_texture(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTexture(self.this, mask) } }
	fn num_textures(&self) -> u32 { unsafe { tsTraversal_getNumTextures(self.this) } }
	fn set_texture_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureOffset(self.this, offset)) } }
	fn texture_offset(&self) -> u32 { unsafe { tsTraversal_getTextureOffset(self.this) } }
	fn set_texture_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMask(self.this, index, mask)) } }
	fn texture_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTextureMask(self.this, index) } }
	fn set_texture_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMasks(self.this, index, num, mask, 0)) } }
	fn set_texture_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn texture_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTextureMasks(self.this, index, num) } }
	fn set_texture_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTextureArray(self.this, index, num, if array {1} else {0})) } }
	fn texture_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getTextureArray(self.this, index) } }
	fn add_surface(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addSurface(self.this, mask) } }
	fn num_surfaces(&self) -> u32 { unsafe { tsTraversal_getNumSurfaces(self.this) } }
	fn set_surface_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceOffset(self.this, offset)) } }
	fn surface_offset(&self) -> u32 { unsafe { tsTraversal_getSurfaceOffset(self.this) } }
	fn set_surface_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMask(self.this, index, mask)) } }
	fn surface_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getSurfaceMask(self.this, index) } }
	fn set_surface_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMasks(self.this, index, num, mask, 0)) } }
	fn set_surface_masks_with_array(&mut self, index: u32, num: u32, mask: ShaderMask, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceMasks(self.this, index, num, mask, if array {1} else {0})) } }
	fn surface_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getSurfaceMasks(self.this, index, num) } }
	fn set_surface_array(&mut self, index: u32, num: u32, array: bool) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setSurfaceArray(self.this, index, num, if array {1} else {0})) } }
	fn surface_array(&self, index: u32) -> u32 { unsafe { tsTraversal_getSurfaceArray(self.this, index) } }
	fn add_uniform(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addUniform(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_uniform_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addUniform(self.this, mask, flags) } }
	fn num_uniforms(&self) -> u32 { unsafe { tsTraversal_getNumUniforms(self.this) } }
	fn set_uniform_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformOffset(self.this, offset)) } }
	fn uniform_offset(&self) -> u32 { unsafe { tsTraversal_getUniformOffset(self.this) } }
	fn set_uniform_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMask(self.this, index, mask, flags)) } }
	fn uniform_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getUniformMask(self.this, index) } }
	fn set_uniform_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_uniform_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformMasks(self.this, index, num, mask, flags)) } }
	fn uniform_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getUniformMasks(self.this, index, num) } }
	fn set_uniform_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setUniformFlags(self.this, index, flags)) } }
	fn uniform_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getUniformFlags(self.this, index) } }
	fn add_storage(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addStorage(self.this, mask, BindFlags::BindFlagNone) } }
	fn add_storage_with_flags(&mut self, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addStorage(self.this, mask, flags) } }
	fn num_storages(&self) -> u32 { unsafe { tsTraversal_getNumStorages(self.this) } }
	fn set_storage_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageOffset(self.this, offset)) } }
	fn storage_offset(&self) -> u32 { unsafe { tsTraversal_getStorageOffset(self.this) } }
	fn set_storage_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMask(self.this, index, mask, flags)) } }
	fn storage_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getStorageMask(self.this, index) } }
	fn set_storage_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMasks(self.this, index, num, mask, BindFlags::BindFlagNone)) } }
	fn set_storage_masks_with_flags(&mut self, index: u32, num: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageMasks(self.this, index, num, mask, flags)) } }
	fn storage_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getStorageMasks(self.this, index, num) } }
	fn set_storage_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setStorageFlags(self.this, index, flags)) } }
	fn storage_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getStorageFlags(self.this, index) } }
	fn add_tracing(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTracing(self.this, mask) } }
	fn num_tracings(&self) -> u32 { unsafe { tsTraversal_getNumTracings(self.this) } }
	fn set_tracing_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingOffset(self.this, offset)) } }
	fn tracing_offset(&self) -> u32 { unsafe { tsTraversal_getTracingOffset(self.this) } }
	fn set_tracing_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingMask(self.this, index, mask)) } }
	fn tracing_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTracingMask(self.this, index) } }
	fn set_tracing_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTracingMasks(self.this, index, num, mask)) } }
	fn tracing_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTracingMasks(self.this, index, num) } }
	fn add_texel(&mut self, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTexel(self.this, mask) } }
	fn num_texels(&self) -> u32 { unsafe { tsTraversal_getNumTexels(self.this) } }
	fn set_texel_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelOffset(self.this, offset)) } }
	fn texel_offset(&self) -> u32 { unsafe { tsTraversal_getTexelOffset(self.this) } }
	fn set_texel_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelMask(self.this, index, mask)) } }
	fn texel_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTexelMask(self.this, index) } }
	fn set_texel_masks(&mut self, index: u32, num: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTexelMasks(self.this, index, num, mask)) } }
	fn texel_masks(&self, index: u32, num: u32) -> ShaderMask { unsafe { tsTraversal_getTexelMasks(self.this, index, num) } }
	fn add_table(&mut self, type_: TableType, size: u32, mask: ShaderMask) -> u32 { unsafe { tsTraversal_addTable(self.this, type_, size, mask, BindFlags::BindFlagNone) } }
	fn add_table_with_flags(&mut self, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> u32 { unsafe { tsTraversal_addTable(self.this, type_, size, mask, flags) } }
	fn num_tables(&self) -> u32 { unsafe { tsTraversal_getNumTables(self.this) } }
	fn set_table_offset(&mut self, offset: u32) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableOffset(self.this, offset)) } }
	fn table_offset(&self) -> u32 { unsafe { tsTraversal_getTableOffset(self.this) } }
	fn set_table_type(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableType(self.this, index, type_, size, mask, BindFlags::BindFlagNone)) } }
	fn set_table_type_with_flags(&mut self, index: u32, type_: TableType, size: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableType(self.this, index, type_, size, mask, flags)) } }
	fn table_type(&self, index: u32) -> TableType { unsafe { tsTraversal_getTableType(self.this, index) } }
	fn table_size(&self, index: u32) -> u32 { unsafe { tsTraversal_getTableSize(self.this, index) } }
	fn set_table_mask(&mut self, index: u32, mask: ShaderMask) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableMask(self.this, index, mask, BindFlags::BindFlagNone)) } }
	fn set_table_mask_with_flags(&mut self, index: u32, mask: ShaderMask, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableMask(self.this, index, mask, flags)) } }
	fn table_mask(&self, index: u32) -> ShaderMask { unsafe { tsTraversal_getTableMask(self.this, index) } }
	fn set_table_flags(&mut self, index: u32, flags: BindFlags) -> Traversal { unsafe { Traversal::new_ptr(tsTraversal_setTableFlags(self.this, index, flags)) } }
	fn table_flags(&self, index: u32) -> BindFlags { unsafe { tsTraversal_getTableFlags(self.this, index) } }
	fn set_recursion_depth(&mut self, depth: u32) { unsafe { tsTraversal_setRecursionDepth(self.this, depth) } }
	fn recursion_depth(&self) -> u32 { unsafe { tsTraversal_getRecursionDepth(self.this) } }
}
impl Drop for FUTraversal {
	fn drop(&mut self) { if self.owner { unsafe { tsFUTraversal_delete(self.this) } } }
}
impl Clone for FUTraversal {
	fn clone(&self) -> FUTraversal { unsafe { FUTraversal { this: tsFUTraversal_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FUTraversal { }
impl fmt::Display for FUTraversal {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FUTraversal ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFUTraversal_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFUTraversal_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFUTraversal_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFUTraversal_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFUTraversal_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFUTraversal_new() -> *mut c_void;
	fn tsFUTraversal_new_cATb(traversals: *const *mut c_void, traversals_size: u32, owner: i32) -> *mut c_void;
	fn tsFUTraversal_delete(this: *mut c_void);
	fn tsFUTraversal_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTraversal_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTraversal_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFUTraversal_clearPtr(this: *const c_void);
	fn tsFUTraversal_destroyPtr(this: *const c_void);
	fn tsFUTraversal_acquirePtr(this: *const c_void);
	fn tsFUTraversal_unacquirePtr(this: *const c_void);
	fn tsFUTraversal_isValidPtr(this: *const c_void) -> i32;
	fn tsFUTraversal_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFUTraversal_isConstPtr(this: *const c_void) -> i32;
	fn tsFUTraversal_getCountPtr(this: *const c_void) -> u32;
	fn tsFUTraversal_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTraversal_equalTraversalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFUTraversal_castTraversalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTraversal_baseTraversalPtr(this: *const c_void) -> *mut c_void;
	fn tsFUTraversal_setMask(this: *mut c_void, mask: u32);
	fn tsFUTraversal_getMask(this: *const c_void) -> u32;
	fn tsFUTraversal_getNumTraversals(this: *const c_void) -> u32;
	fn tsFUTraversal_getTraversal_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsFUTraversal_getTraversal_u(this: *mut c_void, index: u32) -> *mut c_void;
}

// Tellusim::Surface
pub struct Surface {
	this: *mut c_void,
	owner: bool,
}
impl Surface {
	pub fn null() -> Surface { Surface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Surface { unsafe { Surface { this: tsSurface_new(), owner: true } } }
	pub fn new_with_context(context: &mut Context) -> Surface { unsafe { Surface { this: tsSurface_new_C(context.this), owner: true } } }
	pub fn new_with_platform(platform: Platform) -> Surface { unsafe { Surface { this: tsSurface_new_P(platform), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Surface { unsafe { Surface { this: ptr, owner: tsSurface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Surface { unsafe { Surface { this: tsSurface_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Surface) -> bool { unsafe { tsSurface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Surface { unsafe { Surface { this: tsSurface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSurface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSurface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSurface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSurface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSurface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSurface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSurface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSurface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSurface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait SurfaceTrait {
	fn platform(&self) -> Platform;
	fn platform_name(&self) -> string::String;
	fn index(&self) -> u32;
	fn set_size(&mut self, width: u32, height: u32);
	fn width(&self) -> u32;
	fn height(&self) -> u32;
	fn set_multisample(&mut self, multisample: u32);
	fn multisample(&self) -> u32;
	fn has_multisample(&self) -> bool;
	fn set_color_layer(&mut self, layer: u32, layers: u32);
	fn set_depth_layer(&mut self, layer: u32, layers: u32);
	fn color_layer(&self) -> u32;
	fn depth_layer(&self) -> u32;
	fn color_layers(&self) -> u32;
	fn depth_layers(&self) -> u32;
	fn has_color_layers(&self) -> bool;
	fn has_depth_layers(&self) -> bool;
	fn set_color_format(&mut self, format: Format);
	fn set_depth_format(&mut self, format: Format);
	fn color_format(&self) -> Format;
	fn depth_format(&self) -> Format;
}
impl SurfaceTrait for Surface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for Surface {
	fn drop(&mut self) { if self.owner { unsafe { tsSurface_delete(self.this) } } }
}
impl Clone for Surface {
	fn clone(&self) -> Surface { unsafe { Surface { this: tsSurface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Surface { }
impl fmt::Display for Surface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Surface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSurface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSurface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSurface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSurface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSurface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSurface_new() -> *mut c_void;
	fn tsSurface_new_C(context: *mut c_void) -> *mut c_void;
	fn tsSurface_new_P(platform: Platform) -> *mut c_void;
	fn tsSurface_delete(this: *mut c_void);
	fn tsSurface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSurface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSurface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSurface_clearPtr(this: *const c_void);
	fn tsSurface_destroyPtr(this: *const c_void);
	fn tsSurface_acquirePtr(this: *const c_void);
	fn tsSurface_unacquirePtr(this: *const c_void);
	fn tsSurface_isValidPtr(this: *const c_void) -> i32;
	fn tsSurface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSurface_isConstPtr(this: *const c_void) -> i32;
	fn tsSurface_getCountPtr(this: *const c_void) -> u32;
	fn tsSurface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSurface_getPlatform(this: *const c_void) -> Platform;
	fn tsSurface_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsSurface_getIndex(this: *const c_void) -> u32;
	fn tsSurface_setSize(this: *mut c_void, width: u32, height: u32);
	fn tsSurface_getWidth(this: *const c_void) -> u32;
	fn tsSurface_getHeight(this: *const c_void) -> u32;
	fn tsSurface_setMultisample(this: *mut c_void, multisample: u32);
	fn tsSurface_getMultisample(this: *const c_void) -> u32;
	fn tsSurface_hasMultisample(this: *const c_void) -> i32;
	fn tsSurface_setColorLayer(this: *mut c_void, layer: u32, layers: u32);
	fn tsSurface_setDepthLayer(this: *mut c_void, layer: u32, layers: u32);
	fn tsSurface_getColorLayer(this: *const c_void) -> u32;
	fn tsSurface_getDepthLayer(this: *const c_void) -> u32;
	fn tsSurface_getColorLayers(this: *const c_void) -> u32;
	fn tsSurface_getDepthLayers(this: *const c_void) -> u32;
	fn tsSurface_hasColorLayers(this: *const c_void) -> i32;
	fn tsSurface_hasDepthLayers(this: *const c_void) -> i32;
	fn tsSurface_setColorFormat(this: *mut c_void, format: Format);
	fn tsSurface_setDepthFormat(this: *mut c_void, format: Format);
	fn tsSurface_getColorFormat(this: *const c_void) -> Format;
	fn tsSurface_getDepthFormat(this: *const c_void) -> Format;
}

// Tellusim::D3D12Surface
pub struct D3D12Surface {
	this: *mut c_void,
	owner: bool,
}
impl D3D12Surface {
	pub fn null() -> D3D12Surface { D3D12Surface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D12Surface { unsafe { D3D12Surface { this: tsD3D12Surface_new(), owner: true } } }
	pub fn new_with_context(context: &mut D3D12Context) -> D3D12Surface { unsafe { D3D12Surface { this: tsD3D12Surface_new_D3D12C(context.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D12Surface { unsafe { D3D12Surface { this: ptr, owner: tsD3D12Surface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D12Surface { unsafe { D3D12Surface { this: tsD3D12Surface_copyPtr(self.this), owner: true } } }
	pub fn from_surface(ptr: &Surface) -> D3D12Surface { unsafe { D3D12Surface::new_ptr(tsD3D12Surface_castSurfacePtr(ptr.this)) } }
	pub fn to_surface(&self) -> Surface { unsafe { Surface::new_ptr(tsD3D12Surface_baseSurfacePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D12Surface) -> bool { unsafe { tsD3D12Surface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D12Surface { unsafe { D3D12Surface { this: tsD3D12Surface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D12Surface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D12Surface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D12Surface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D12Surface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D12Surface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D12Surface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D12Surface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D12Surface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D12Surface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn factory(&self) -> *const c_void { unsafe { tsD3D12Surface_getFactory(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsD3D12Surface_getDevice(self.this) } }
	pub fn queue(&self) -> *const c_void { unsafe { tsD3D12Surface_getQueue(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsD3D12Surface_getCommand(self.this) } }
	pub fn set_swap_chain(&mut self, swap_chain: *const c_void) { unsafe { tsD3D12Surface_setSwapChain(self.this, swap_chain) } }
	pub fn swap_chain(&self) -> *const c_void { unsafe { tsD3D12Surface_getSwapChain(self.this) } }
	pub fn set_render_target(&mut self, render_target: *const c_void) { unsafe { tsD3D12Surface_setRenderTarget(self.this, render_target) } }
	pub fn set_depth_stencil(&mut self, depth_stencil: *const c_void) { unsafe { tsD3D12Surface_setDepthStencil(self.this, depth_stencil) } }
	pub fn render_target(&self) -> *const c_void { unsafe { tsD3D12Surface_getRenderTarget(self.this) } }
	pub fn depth_stencil(&self) -> *const c_void { unsafe { tsD3D12Surface_getDepthStencil(self.this) } }
	pub fn set_render_target_view(&mut self, render_target_view: usize) { unsafe { tsD3D12Surface_setRenderTargetView(self.this, render_target_view) } }
	pub fn set_depth_stencil_view(&mut self, depth_stencil_view: usize) { unsafe { tsD3D12Surface_setDepthStencilView(self.this, depth_stencil_view) } }
	pub fn render_target_view(&self) -> usize { unsafe { tsD3D12Surface_getRenderTargetView(self.this) } }
	pub fn depth_stencil_view(&self) -> usize { unsafe { tsD3D12Surface_getDepthStencilView(self.this) } }
	pub fn color_dxgi_format(&self) -> u32 { unsafe { tsD3D12Surface_getColorDXGIFormat(self.this) } }
	pub fn depth_dxgi_format(&self) -> u32 { unsafe { tsD3D12Surface_getDepthDXGIFormat(self.this) } }
}
impl SurfaceTrait for D3D12Surface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for D3D12Surface {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D12Surface_delete(self.this) } } }
}
impl Clone for D3D12Surface {
	fn clone(&self) -> D3D12Surface { unsafe { D3D12Surface { this: tsD3D12Surface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D12Surface { }
impl fmt::Display for D3D12Surface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D12Surface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D12Surface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D12Surface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D12Surface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D12Surface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D12Surface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D12Surface_new() -> *mut c_void;
	fn tsD3D12Surface_new_D3D12C(context: *mut c_void) -> *mut c_void;
	fn tsD3D12Surface_delete(this: *mut c_void);
	fn tsD3D12Surface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Surface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Surface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Surface_clearPtr(this: *const c_void);
	fn tsD3D12Surface_destroyPtr(this: *const c_void);
	fn tsD3D12Surface_acquirePtr(this: *const c_void);
	fn tsD3D12Surface_unacquirePtr(this: *const c_void);
	fn tsD3D12Surface_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D12Surface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D12Surface_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D12Surface_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D12Surface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Surface_equalSurfacePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D12Surface_castSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Surface_baseSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D12Surface_getFactory(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_getDevice(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_getQueue(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_getCommand(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_setSwapChain(this: *mut c_void, swap_chain: *const c_void);
	fn tsD3D12Surface_getSwapChain(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_setRenderTarget(this: *mut c_void, render_target: *const c_void);
	fn tsD3D12Surface_setDepthStencil(this: *mut c_void, depth_stencil: *const c_void);
	fn tsD3D12Surface_getRenderTarget(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_getDepthStencil(this: *const c_void) -> *const c_void;
	fn tsD3D12Surface_setRenderTargetView(this: *mut c_void, render_target_view: usize);
	fn tsD3D12Surface_setDepthStencilView(this: *mut c_void, depth_stencil_view: usize);
	fn tsD3D12Surface_getRenderTargetView(this: *const c_void) -> usize;
	fn tsD3D12Surface_getDepthStencilView(this: *const c_void) -> usize;
	fn tsD3D12Surface_getColorDXGIFormat(this: *const c_void) -> u32;
	fn tsD3D12Surface_getDepthDXGIFormat(this: *const c_void) -> u32;
}

// Tellusim::D3D11Surface
pub struct D3D11Surface {
	this: *mut c_void,
	owner: bool,
}
impl D3D11Surface {
	pub fn null() -> D3D11Surface { D3D11Surface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> D3D11Surface { unsafe { D3D11Surface { this: tsD3D11Surface_new(), owner: true } } }
	pub fn new_with_context(context: &mut D3D11Context) -> D3D11Surface { unsafe { D3D11Surface { this: tsD3D11Surface_new_D3D11C(context.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> D3D11Surface { unsafe { D3D11Surface { this: ptr, owner: tsD3D11Surface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> D3D11Surface { unsafe { D3D11Surface { this: tsD3D11Surface_copyPtr(self.this), owner: true } } }
	pub fn from_surface(ptr: &Surface) -> D3D11Surface { unsafe { D3D11Surface::new_ptr(tsD3D11Surface_castSurfacePtr(ptr.this)) } }
	pub fn to_surface(&self) -> Surface { unsafe { Surface::new_ptr(tsD3D11Surface_baseSurfacePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: D3D11Surface) -> bool { unsafe { tsD3D11Surface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> D3D11Surface { unsafe { D3D11Surface { this: tsD3D11Surface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsD3D11Surface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsD3D11Surface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsD3D11Surface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsD3D11Surface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsD3D11Surface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsD3D11Surface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsD3D11Surface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsD3D11Surface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsD3D11Surface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn factory(&self) -> *const c_void { unsafe { tsD3D11Surface_getFactory(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsD3D11Surface_getDevice(self.this) } }
	pub fn context(&self) -> *const c_void { unsafe { tsD3D11Surface_getContext(self.this) } }
	pub fn set_swap_chain(&mut self, swap_chain: *const c_void) { unsafe { tsD3D11Surface_setSwapChain(self.this, swap_chain) } }
	pub fn swap_chain(&self) -> *const c_void { unsafe { tsD3D11Surface_getSwapChain(self.this) } }
	pub fn set_render_target(&mut self, render_target: *const c_void) { unsafe { tsD3D11Surface_setRenderTarget(self.this, render_target) } }
	pub fn set_depth_stencil(&mut self, depth_stencil: *const c_void) { unsafe { tsD3D11Surface_setDepthStencil(self.this, depth_stencil) } }
	pub fn render_target(&self) -> *const c_void { unsafe { tsD3D11Surface_getRenderTarget(self.this) } }
	pub fn depth_stencil(&self) -> *const c_void { unsafe { tsD3D11Surface_getDepthStencil(self.this) } }
	pub fn set_render_target_view(&mut self, render_target_view: *const c_void) { unsafe { tsD3D11Surface_setRenderTargetView(self.this, render_target_view) } }
	pub fn set_depth_stencil_view(&mut self, depth_stencil_view: *const c_void) { unsafe { tsD3D11Surface_setDepthStencilView(self.this, depth_stencil_view) } }
	pub fn render_target_view(&self) -> *const c_void { unsafe { tsD3D11Surface_getRenderTargetView(self.this) } }
	pub fn depth_stencil_view(&self) -> *const c_void { unsafe { tsD3D11Surface_getDepthStencilView(self.this) } }
	pub fn color_dxgi_format(&self) -> u32 { unsafe { tsD3D11Surface_getColorDXGIFormat(self.this) } }
	pub fn depth_dxgi_format(&self) -> u32 { unsafe { tsD3D11Surface_getDepthDXGIFormat(self.this) } }
}
impl SurfaceTrait for D3D11Surface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for D3D11Surface {
	fn drop(&mut self) { if self.owner { unsafe { tsD3D11Surface_delete(self.this) } } }
}
impl Clone for D3D11Surface {
	fn clone(&self) -> D3D11Surface { unsafe { D3D11Surface { this: tsD3D11Surface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for D3D11Surface { }
impl fmt::Display for D3D11Surface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::D3D11Surface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsD3D11Surface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsD3D11Surface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsD3D11Surface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsD3D11Surface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsD3D11Surface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsD3D11Surface_new() -> *mut c_void;
	fn tsD3D11Surface_new_D3D11C(context: *mut c_void) -> *mut c_void;
	fn tsD3D11Surface_delete(this: *mut c_void);
	fn tsD3D11Surface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Surface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Surface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Surface_clearPtr(this: *const c_void);
	fn tsD3D11Surface_destroyPtr(this: *const c_void);
	fn tsD3D11Surface_acquirePtr(this: *const c_void);
	fn tsD3D11Surface_unacquirePtr(this: *const c_void);
	fn tsD3D11Surface_isValidPtr(this: *const c_void) -> i32;
	fn tsD3D11Surface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsD3D11Surface_isConstPtr(this: *const c_void) -> i32;
	fn tsD3D11Surface_getCountPtr(this: *const c_void) -> u32;
	fn tsD3D11Surface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Surface_equalSurfacePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsD3D11Surface_castSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Surface_baseSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsD3D11Surface_getFactory(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_getDevice(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_getContext(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_setSwapChain(this: *mut c_void, swap_chain: *const c_void);
	fn tsD3D11Surface_getSwapChain(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_setRenderTarget(this: *mut c_void, render_target: *const c_void);
	fn tsD3D11Surface_setDepthStencil(this: *mut c_void, depth_stencil: *const c_void);
	fn tsD3D11Surface_getRenderTarget(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_getDepthStencil(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_setRenderTargetView(this: *mut c_void, render_target_view: *const c_void);
	fn tsD3D11Surface_setDepthStencilView(this: *mut c_void, depth_stencil_view: *const c_void);
	fn tsD3D11Surface_getRenderTargetView(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_getDepthStencilView(this: *const c_void) -> *const c_void;
	fn tsD3D11Surface_getColorDXGIFormat(this: *const c_void) -> u32;
	fn tsD3D11Surface_getDepthDXGIFormat(this: *const c_void) -> u32;
}

// Tellusim::MTLSurface
pub struct MTLSurface {
	this: *mut c_void,
	owner: bool,
}
impl MTLSurface {
	pub fn null() -> MTLSurface { MTLSurface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MTLSurface { unsafe { MTLSurface { this: tsMTLSurface_new(), owner: true } } }
	pub fn new_with_context(context: &mut MTLContext) -> MTLSurface { unsafe { MTLSurface { this: tsMTLSurface_new_M(context.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MTLSurface { unsafe { MTLSurface { this: ptr, owner: tsMTLSurface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> MTLSurface { unsafe { MTLSurface { this: tsMTLSurface_copyPtr(self.this), owner: true } } }
	pub fn from_surface(ptr: &Surface) -> MTLSurface { unsafe { MTLSurface::new_ptr(tsMTLSurface_castSurfacePtr(ptr.this)) } }
	pub fn to_surface(&self) -> Surface { unsafe { Surface::new_ptr(tsMTLSurface_baseSurfacePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: MTLSurface) -> bool { unsafe { tsMTLSurface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> MTLSurface { unsafe { MTLSurface { this: tsMTLSurface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsMTLSurface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsMTLSurface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsMTLSurface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsMTLSurface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsMTLSurface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsMTLSurface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsMTLSurface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsMTLSurface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsMTLSurface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn device(&self) -> *mut c_void { unsafe { tsMTLSurface_getDevice(self.this) } }
	pub fn queue(&self) -> *mut c_void { unsafe { tsMTLSurface_getQueue(self.this) } }
	pub fn command(&self) -> *mut c_void { unsafe { tsMTLSurface_getCommand(self.this) } }
	pub fn set_descriptor(&mut self, descriptor: *mut c_void) { unsafe { tsMTLSurface_setDescriptor(self.this, descriptor) } }
	pub fn descriptor(&self) -> *mut c_void { unsafe { tsMTLSurface_getDescriptor(self.this) } }
	pub fn color_pixel_format(&self) -> u32 { unsafe { tsMTLSurface_getColorPixelFormat(self.this) } }
	pub fn depth_pixel_format(&self) -> u32 { unsafe { tsMTLSurface_getDepthPixelFormat(self.this) } }
}
impl SurfaceTrait for MTLSurface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for MTLSurface {
	fn drop(&mut self) { if self.owner { unsafe { tsMTLSurface_delete(self.this) } } }
}
impl Clone for MTLSurface {
	fn clone(&self) -> MTLSurface { unsafe { MTLSurface { this: tsMTLSurface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for MTLSurface { }
impl fmt::Display for MTLSurface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MTLSurface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsMTLSurface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsMTLSurface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsMTLSurface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsMTLSurface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsMTLSurface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMTLSurface_new() -> *mut c_void;
	fn tsMTLSurface_new_M(context: *mut c_void) -> *mut c_void;
	fn tsMTLSurface_delete(this: *mut c_void);
	fn tsMTLSurface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLSurface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_clearPtr(this: *const c_void);
	fn tsMTLSurface_destroyPtr(this: *const c_void);
	fn tsMTLSurface_acquirePtr(this: *const c_void);
	fn tsMTLSurface_unacquirePtr(this: *const c_void);
	fn tsMTLSurface_isValidPtr(this: *const c_void) -> i32;
	fn tsMTLSurface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsMTLSurface_isConstPtr(this: *const c_void) -> i32;
	fn tsMTLSurface_getCountPtr(this: *const c_void) -> u32;
	fn tsMTLSurface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_equalSurfacePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsMTLSurface_castSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_baseSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_getDevice(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_getQueue(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_getCommand(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_setDescriptor(this: *mut c_void, descriptor: *mut c_void);
	fn tsMTLSurface_getDescriptor(this: *const c_void) -> *mut c_void;
	fn tsMTLSurface_getColorPixelFormat(this: *const c_void) -> u32;
	fn tsMTLSurface_getDepthPixelFormat(this: *const c_void) -> u32;
}

// Tellusim::VKSurface
pub struct VKSurface {
	this: *mut c_void,
	owner: bool,
}
impl VKSurface {
	pub fn null() -> VKSurface { VKSurface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> VKSurface { unsafe { VKSurface { this: tsVKSurface_new(), owner: true } } }
	pub fn new_with_context(context: &mut VKContext) -> VKSurface { unsafe { VKSurface { this: tsVKSurface_new_V(context.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> VKSurface { unsafe { VKSurface { this: ptr, owner: tsVKSurface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> VKSurface { unsafe { VKSurface { this: tsVKSurface_copyPtr(self.this), owner: true } } }
	pub fn from_surface(ptr: &Surface) -> VKSurface { unsafe { VKSurface::new_ptr(tsVKSurface_castSurfacePtr(ptr.this)) } }
	pub fn to_surface(&self) -> Surface { unsafe { Surface::new_ptr(tsVKSurface_baseSurfacePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: VKSurface) -> bool { unsafe { tsVKSurface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> VKSurface { unsafe { VKSurface { this: tsVKSurface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsVKSurface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsVKSurface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsVKSurface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsVKSurface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsVKSurface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsVKSurface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsVKSurface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsVKSurface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsVKSurface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn instance(&self) -> *const c_void { unsafe { tsVKSurface_getInstance(self.this) } }
	pub fn adapter(&self) -> *const c_void { unsafe { tsVKSurface_getAdapter(self.this) } }
	pub fn device(&self) -> *const c_void { unsafe { tsVKSurface_getDevice(self.this) } }
	pub fn queue(&self) -> *const c_void { unsafe { tsVKSurface_getQueue(self.this) } }
	pub fn command(&self) -> *const c_void { unsafe { tsVKSurface_getCommand(self.this) } }
	pub fn family(&self) -> u32 { unsafe { tsVKSurface_getFamily(self.this) } }
	pub fn set_color_image(&mut self, image: *const c_void) { unsafe { tsVKSurface_setColorImage(self.this, image) } }
	pub fn set_depth_image(&mut self, image: *const c_void) { unsafe { tsVKSurface_setDepthImage(self.this, image) } }
	pub fn color_image(&self) -> *const c_void { unsafe { tsVKSurface_getColorImage(self.this) } }
	pub fn depth_image(&self) -> *const c_void { unsafe { tsVKSurface_getDepthImage(self.this) } }
	pub fn set_color_image_view(&mut self, image_view: *const c_void) { unsafe { tsVKSurface_setColorImageView(self.this, image_view) } }
	pub fn set_depth_image_view(&mut self, image_view: *const c_void) { unsafe { tsVKSurface_setDepthImageView(self.this, image_view) } }
	pub fn color_image_view(&self) -> *const c_void { unsafe { tsVKSurface_getColorImageView(self.this) } }
	pub fn depth_image_view(&self) -> *const c_void { unsafe { tsVKSurface_getDepthImageView(self.this) } }
	pub fn set_render_pass(&mut self, render_pass: *const c_void) { unsafe { tsVKSurface_setRenderPass(self.this, render_pass) } }
	pub fn set_framebuffer(&mut self, framebuffer: *const c_void) { unsafe { tsVKSurface_setFramebuffer(self.this, framebuffer) } }
	pub fn render_pass(&self) -> *const c_void { unsafe { tsVKSurface_getRenderPass(self.this) } }
	pub fn framebuffer(&self) -> *const c_void { unsafe { tsVKSurface_getFramebuffer(self.this) } }
	pub fn color_pixel_format(&self) -> u32 { unsafe { tsVKSurface_getColorPixelFormat(self.this) } }
	pub fn depth_pixel_format(&self) -> u32 { unsafe { tsVKSurface_getDepthPixelFormat(self.this) } }
}
impl SurfaceTrait for VKSurface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for VKSurface {
	fn drop(&mut self) { if self.owner { unsafe { tsVKSurface_delete(self.this) } } }
}
impl Clone for VKSurface {
	fn clone(&self) -> VKSurface { unsafe { VKSurface { this: tsVKSurface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for VKSurface { }
impl fmt::Display for VKSurface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::VKSurface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsVKSurface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsVKSurface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsVKSurface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsVKSurface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsVKSurface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsVKSurface_new() -> *mut c_void;
	fn tsVKSurface_new_V(context: *mut c_void) -> *mut c_void;
	fn tsVKSurface_delete(this: *mut c_void);
	fn tsVKSurface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKSurface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsVKSurface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsVKSurface_clearPtr(this: *const c_void);
	fn tsVKSurface_destroyPtr(this: *const c_void);
	fn tsVKSurface_acquirePtr(this: *const c_void);
	fn tsVKSurface_unacquirePtr(this: *const c_void);
	fn tsVKSurface_isValidPtr(this: *const c_void) -> i32;
	fn tsVKSurface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsVKSurface_isConstPtr(this: *const c_void) -> i32;
	fn tsVKSurface_getCountPtr(this: *const c_void) -> u32;
	fn tsVKSurface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsVKSurface_equalSurfacePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsVKSurface_castSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsVKSurface_baseSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsVKSurface_getInstance(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getAdapter(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getDevice(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getQueue(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getCommand(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getFamily(this: *const c_void) -> u32;
	fn tsVKSurface_setColorImage(this: *mut c_void, image: *const c_void);
	fn tsVKSurface_setDepthImage(this: *mut c_void, image: *const c_void);
	fn tsVKSurface_getColorImage(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getDepthImage(this: *const c_void) -> *const c_void;
	fn tsVKSurface_setColorImageView(this: *mut c_void, image_view: *const c_void);
	fn tsVKSurface_setDepthImageView(this: *mut c_void, image_view: *const c_void);
	fn tsVKSurface_getColorImageView(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getDepthImageView(this: *const c_void) -> *const c_void;
	fn tsVKSurface_setRenderPass(this: *mut c_void, render_pass: *const c_void);
	fn tsVKSurface_setFramebuffer(this: *mut c_void, framebuffer: *const c_void);
	fn tsVKSurface_getRenderPass(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getFramebuffer(this: *const c_void) -> *const c_void;
	fn tsVKSurface_getColorPixelFormat(this: *const c_void) -> u32;
	fn tsVKSurface_getDepthPixelFormat(this: *const c_void) -> u32;
}

// Tellusim::GLSurface
pub struct GLSurface {
	this: *mut c_void,
	owner: bool,
}
impl GLSurface {
	pub fn null() -> GLSurface { GLSurface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLSurface { unsafe { GLSurface { this: tsGLSurface_new(), owner: true } } }
	pub fn new_with_context(context: &mut GLContext) -> GLSurface { unsafe { GLSurface { this: tsGLSurface_new_G(context.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLSurface { unsafe { GLSurface { this: ptr, owner: tsGLSurface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLSurface { unsafe { GLSurface { this: tsGLSurface_copyPtr(self.this), owner: true } } }
	pub fn from_surface(ptr: &Surface) -> GLSurface { unsafe { GLSurface::new_ptr(tsGLSurface_castSurfacePtr(ptr.this)) } }
	pub fn to_surface(&self) -> Surface { unsafe { Surface::new_ptr(tsGLSurface_baseSurfacePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLSurface) -> bool { unsafe { tsGLSurface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLSurface { unsafe { GLSurface { this: tsGLSurface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLSurface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLSurface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLSurface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLSurface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLSurface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLSurface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLSurface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLSurface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLSurface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn context(&self) -> *mut c_void { unsafe { tsGLSurface_getContext(self.this) } }
	pub fn set_color_texture_id(&mut self, texture_id: u32) { unsafe { tsGLSurface_setColorTextureID(self.this, texture_id) } }
	pub fn set_depth_texture_id(&mut self, texture_id: u32) { unsafe { tsGLSurface_setDepthTextureID(self.this, texture_id) } }
	pub fn color_texture_id(&self) -> u32 { unsafe { tsGLSurface_getColorTextureID(self.this) } }
	pub fn depth_texture_id(&self) -> u32 { unsafe { tsGLSurface_getDepthTextureID(self.this) } }
	pub fn set_framebuffer_id(&mut self, framebuffer_id: u32) { unsafe { tsGLSurface_setFramebufferID(self.this, framebuffer_id) } }
	pub fn framebuffer_id(&self) -> u32 { unsafe { tsGLSurface_getFramebufferID(self.this) } }
	pub fn color_internal_format(&self) -> u32 { unsafe { tsGLSurface_getColorInternalFormat(self.this) } }
	pub fn depth_internal_format(&self) -> u32 { unsafe { tsGLSurface_getDepthInternalFormat(self.this) } }
}
impl SurfaceTrait for GLSurface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for GLSurface {
	fn drop(&mut self) { if self.owner { unsafe { tsGLSurface_delete(self.this) } } }
}
impl Clone for GLSurface {
	fn clone(&self) -> GLSurface { unsafe { GLSurface { this: tsGLSurface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLSurface { }
impl fmt::Display for GLSurface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLSurface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLSurface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLSurface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLSurface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLSurface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLSurface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLSurface_new() -> *mut c_void;
	fn tsGLSurface_new_G(context: *mut c_void) -> *mut c_void;
	fn tsGLSurface_delete(this: *mut c_void);
	fn tsGLSurface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLSurface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLSurface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLSurface_clearPtr(this: *const c_void);
	fn tsGLSurface_destroyPtr(this: *const c_void);
	fn tsGLSurface_acquirePtr(this: *const c_void);
	fn tsGLSurface_unacquirePtr(this: *const c_void);
	fn tsGLSurface_isValidPtr(this: *const c_void) -> i32;
	fn tsGLSurface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLSurface_isConstPtr(this: *const c_void) -> i32;
	fn tsGLSurface_getCountPtr(this: *const c_void) -> u32;
	fn tsGLSurface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLSurface_equalSurfacePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLSurface_castSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsGLSurface_baseSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsGLSurface_getContext(this: *const c_void) -> *mut c_void;
	fn tsGLSurface_setColorTextureID(this: *mut c_void, texture_id: u32);
	fn tsGLSurface_setDepthTextureID(this: *mut c_void, texture_id: u32);
	fn tsGLSurface_getColorTextureID(this: *const c_void) -> u32;
	fn tsGLSurface_getDepthTextureID(this: *const c_void) -> u32;
	fn tsGLSurface_setFramebufferID(this: *mut c_void, framebuffer_id: u32);
	fn tsGLSurface_getFramebufferID(this: *const c_void) -> u32;
	fn tsGLSurface_getColorInternalFormat(this: *const c_void) -> u32;
	fn tsGLSurface_getDepthInternalFormat(this: *const c_void) -> u32;
}

// Tellusim::GLESSurface
pub struct GLESSurface {
	this: *mut c_void,
	owner: bool,
}
impl GLESSurface {
	pub fn null() -> GLESSurface { GLESSurface { this: ptr::null_mut(), owner: false } }
	pub fn new() -> GLESSurface { unsafe { GLESSurface { this: tsGLESSurface_new(), owner: true } } }
	pub fn new_with_context(context: &mut GLESContext) -> GLESSurface { unsafe { GLESSurface { this: tsGLESSurface_new_G(context.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> GLESSurface { unsafe { GLESSurface { this: ptr, owner: tsGLESSurface_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> GLESSurface { unsafe { GLESSurface { this: tsGLESSurface_copyPtr(self.this), owner: true } } }
	pub fn from_surface(ptr: &Surface) -> GLESSurface { unsafe { GLESSurface::new_ptr(tsGLESSurface_castSurfacePtr(ptr.this)) } }
	pub fn to_surface(&self) -> Surface { unsafe { Surface::new_ptr(tsGLESSurface_baseSurfacePtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: GLESSurface) -> bool { unsafe { tsGLESSurface_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> GLESSurface { unsafe { GLESSurface { this: tsGLESSurface_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsGLESSurface_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsGLESSurface_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsGLESSurface_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsGLESSurface_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsGLESSurface_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsGLESSurface_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsGLESSurface_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsGLESSurface_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsGLESSurface_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn context(&self) -> *mut c_void { unsafe { tsGLESSurface_getContext(self.this) } }
	pub fn set_color_texture_id(&mut self, texture_id: u32) { unsafe { tsGLESSurface_setColorTextureID(self.this, texture_id) } }
	pub fn set_depth_texture_id(&mut self, texture_id: u32) { unsafe { tsGLESSurface_setDepthTextureID(self.this, texture_id) } }
	pub fn color_texture_id(&self) -> u32 { unsafe { tsGLESSurface_getColorTextureID(self.this) } }
	pub fn depth_texture_id(&self) -> u32 { unsafe { tsGLESSurface_getDepthTextureID(self.this) } }
	pub fn set_framebuffer_id(&mut self, framebuffer_id: u32) { unsafe { tsGLESSurface_setFramebufferID(self.this, framebuffer_id) } }
	pub fn framebuffer_id(&self) -> u32 { unsafe { tsGLESSurface_getFramebufferID(self.this) } }
	pub fn color_internal_format(&self) -> u32 { unsafe { tsGLESSurface_getColorInternalFormat(self.this) } }
	pub fn depth_internal_format(&self) -> u32 { unsafe { tsGLESSurface_getDepthInternalFormat(self.this) } }
}
impl SurfaceTrait for GLESSurface {
	fn platform(&self) -> Platform { unsafe { tsSurface_getPlatform(self.this) } }
	fn platform_name(&self) -> string::String { unsafe { get_cstring(tsSurface_getPlatformName(self.this)) } }
	fn index(&self) -> u32 { unsafe { tsSurface_getIndex(self.this) } }
	fn set_size(&mut self, width: u32, height: u32) { unsafe { tsSurface_setSize(self.this, width, height) } }
	fn width(&self) -> u32 { unsafe { tsSurface_getWidth(self.this) } }
	fn height(&self) -> u32 { unsafe { tsSurface_getHeight(self.this) } }
	fn set_multisample(&mut self, multisample: u32) { unsafe { tsSurface_setMultisample(self.this, multisample) } }
	fn multisample(&self) -> u32 { unsafe { tsSurface_getMultisample(self.this) } }
	fn has_multisample(&self) -> bool { unsafe { tsSurface_hasMultisample(self.this) != 0 } }
	fn set_color_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setColorLayer(self.this, layer, layers) } }
	fn set_depth_layer(&mut self, layer: u32, layers: u32) { unsafe { tsSurface_setDepthLayer(self.this, layer, layers) } }
	fn color_layer(&self) -> u32 { unsafe { tsSurface_getColorLayer(self.this) } }
	fn depth_layer(&self) -> u32 { unsafe { tsSurface_getDepthLayer(self.this) } }
	fn color_layers(&self) -> u32 { unsafe { tsSurface_getColorLayers(self.this) } }
	fn depth_layers(&self) -> u32 { unsafe { tsSurface_getDepthLayers(self.this) } }
	fn has_color_layers(&self) -> bool { unsafe { tsSurface_hasColorLayers(self.this) != 0 } }
	fn has_depth_layers(&self) -> bool { unsafe { tsSurface_hasDepthLayers(self.this) != 0 } }
	fn set_color_format(&mut self, format: Format) { unsafe { tsSurface_setColorFormat(self.this, format) } }
	fn set_depth_format(&mut self, format: Format) { unsafe { tsSurface_setDepthFormat(self.this, format) } }
	fn color_format(&self) -> Format { unsafe { tsSurface_getColorFormat(self.this) } }
	fn depth_format(&self) -> Format { unsafe { tsSurface_getDepthFormat(self.this) } }
}
impl Drop for GLESSurface {
	fn drop(&mut self) { if self.owner { unsafe { tsGLESSurface_delete(self.this) } } }
}
impl Clone for GLESSurface {
	fn clone(&self) -> GLESSurface { unsafe { GLESSurface { this: tsGLESSurface_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for GLESSurface { }
impl fmt::Display for GLESSurface {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::GLESSurface ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsGLESSurface_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsGLESSurface_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsGLESSurface_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsGLESSurface_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsGLESSurface_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsGLESSurface_new() -> *mut c_void;
	fn tsGLESSurface_new_G(context: *mut c_void) -> *mut c_void;
	fn tsGLESSurface_delete(this: *mut c_void);
	fn tsGLESSurface_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESSurface_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESSurface_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESSurface_clearPtr(this: *const c_void);
	fn tsGLESSurface_destroyPtr(this: *const c_void);
	fn tsGLESSurface_acquirePtr(this: *const c_void);
	fn tsGLESSurface_unacquirePtr(this: *const c_void);
	fn tsGLESSurface_isValidPtr(this: *const c_void) -> i32;
	fn tsGLESSurface_isOwnerPtr(this: *const c_void) -> i32;
	fn tsGLESSurface_isConstPtr(this: *const c_void) -> i32;
	fn tsGLESSurface_getCountPtr(this: *const c_void) -> u32;
	fn tsGLESSurface_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsGLESSurface_equalSurfacePtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsGLESSurface_castSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESSurface_baseSurfacePtr(this: *const c_void) -> *mut c_void;
	fn tsGLESSurface_getContext(this: *const c_void) -> *mut c_void;
	fn tsGLESSurface_setColorTextureID(this: *mut c_void, texture_id: u32);
	fn tsGLESSurface_setDepthTextureID(this: *mut c_void, texture_id: u32);
	fn tsGLESSurface_getColorTextureID(this: *const c_void) -> u32;
	fn tsGLESSurface_getDepthTextureID(this: *const c_void) -> u32;
	fn tsGLESSurface_setFramebufferID(this: *mut c_void, framebuffer_id: u32);
	fn tsGLESSurface_getFramebufferID(this: *const c_void) -> u32;
	fn tsGLESSurface_getColorInternalFormat(this: *const c_void) -> u32;
	fn tsGLESSurface_getDepthInternalFormat(this: *const c_void) -> u32;
}

// Tellusim::Window
pub struct Window {
	this: *mut c_void,
	owner: bool,
}
type WindowMousePressedCallback = unsafe extern "C" fn(button: WindowButton, data_: *mut c_void);
unsafe extern "C" fn window_mouse_pressed_callback_func<Func>(button: WindowButton, data_: *mut c_void) where Func: FnMut(WindowButton) {
	let func = &mut *(data_ as *mut Func);
	func(button)
}
type WindowMouseReleasedCallback = unsafe extern "C" fn(button: WindowButton, data_: *mut c_void);
unsafe extern "C" fn window_mouse_released_callback_func<Func>(button: WindowButton, data_: *mut c_void) where Func: FnMut(WindowButton) {
	let func = &mut *(data_ as *mut Func);
	func(button)
}
type WindowMouseChangedCallback = unsafe extern "C" fn(x: i32, y: i32, data_: *mut c_void);
unsafe extern "C" fn window_mouse_changed_callback_func<Func>(x: i32, y: i32, data_: *mut c_void) where Func: FnMut(i32, i32) {
	let func = &mut *(data_ as *mut Func);
	func(x, y)
}
type WindowMouseRotatedCallback = unsafe extern "C" fn(axis: WindowAxis, delta: f32, data_: *mut c_void);
unsafe extern "C" fn window_mouse_rotated_callback_func<Func>(axis: WindowAxis, delta: f32, data_: *mut c_void) where Func: FnMut(WindowAxis, f32) {
	let func = &mut *(data_ as *mut Func);
	func(axis, delta)
}
type WindowTouchChangedCallback = unsafe extern "C" fn(data_: *mut c_void);
unsafe extern "C" fn window_touch_changed_callback_func<Func>(data_: *mut c_void) where Func: FnMut() {
	let func = &mut *(data_ as *mut Func);
	func()
}
type WindowKeyboardPressedCallback = unsafe extern "C" fn(key: u32, code: u32, data_: *mut c_void);
unsafe extern "C" fn window_keyboard_pressed_callback_func<Func>(key: u32, code: u32, data_: *mut c_void) where Func: FnMut(u32, u32) {
	let func = &mut *(data_ as *mut Func);
	func(key, code)
}
type WindowKeyboardReleasedCallback = unsafe extern "C" fn(key: u32, data_: *mut c_void);
unsafe extern "C" fn window_keyboard_released_callback_func<Func>(key: u32, data_: *mut c_void) where Func: FnMut(u32) {
	let func = &mut *(data_ as *mut Func);
	func(key)
}
type WindowSizeChangedCallback = unsafe extern "C" fn(width: u32, height: u32, data_: *mut c_void);
unsafe extern "C" fn window_size_changed_callback_func<Func>(width: u32, height: u32, data_: *mut c_void) where Func: FnMut(u32, u32) {
	let func = &mut *(data_ as *mut Func);
	func(width, height)
}
type WindowFocusChangedCallback = unsafe extern "C" fn(changed: i32, data_: *mut c_void);
unsafe extern "C" fn window_focus_changed_callback_func<Func>(changed: i32, data_: *mut c_void) where Func: FnMut(bool) {
	let func = &mut *(data_ as *mut Func);
	func(changed != 0)
}
type WindowCloseClickedCallback = unsafe extern "C" fn(data_: *mut c_void);
unsafe extern "C" fn window_close_clicked_callback_func<Func>(data_: *mut c_void) where Func: FnMut() {
	let func = &mut *(data_ as *mut Func);
	func()
}
type WindowPauseChangedCallback = unsafe extern "C" fn(paused: i32, data_: *mut c_void);
unsafe extern "C" fn window_pause_changed_callback_func<Func>(paused: i32, data_: *mut c_void) where Func: FnMut(bool) {
	let func = &mut *(data_ as *mut Func);
	func(paused != 0)
}
type WindowFileDroppedCallback = unsafe extern "C" fn(name: *const c_char, remain: u32, data_: *mut c_void);
unsafe extern "C" fn window_file_dropped_callback_func<Func>(name: *const c_char, remain: u32, data_: *mut c_void) where Func: FnMut(&str, u32) {
	let func = &mut *(data_ as *mut Func);
	let name_ = get_cstring(name);
	func(&name_, remain)
}
type WindowUpdateCallback = unsafe extern "C" fn(data_: *mut c_void);
unsafe extern "C" fn window_update_callback_func<Func>(data_: *mut c_void) where Func: FnMut() {
	let func = &mut *(data_ as *mut Func);
	func()
}
type WindowPresentCallback = unsafe extern "C" fn(data_: *mut c_void);
unsafe extern "C" fn window_present_callback_func<Func>(data_: *mut c_void) where Func: FnMut() {
	let func = &mut *(data_ as *mut Func);
	func()
}
type WindowMainLoopCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn window_main_loop_callback_null(_data_: *mut c_void) -> i32 { 1 }
unsafe extern "C" fn window_main_loop_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl Window {
	pub fn null() -> Window { Window { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Window { unsafe { Window { this: tsWindow_new(), owner: true } } }
	pub fn new_with_platform(platform: Platform) -> Window { unsafe { Window { this: tsWindow_new_Pu(platform, MAXU32), owner: true } } }
	pub fn new_with_platform_index(platform: Platform, index: u32) -> Window { unsafe { Window { this: tsWindow_new_Pu(platform, index), owner: true } } }
	pub fn new_with_surface(surface: &mut Surface) -> Window { unsafe { Window { this: tsWindow_new_S(surface.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Window { unsafe { Window { this: ptr, owner: tsWindow_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Window { unsafe { Window { this: tsWindow_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Window) -> bool { unsafe { tsWindow_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Window { unsafe { Window { this: tsWindow_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsWindow_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsWindow_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsWindow_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsWindow_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsWindow_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsWindow_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsWindow_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsWindow_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsWindow_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn num_windows() -> u32 { unsafe { tsWindow_getNumWindows() } }
	pub fn window(index: u32) -> Window { unsafe { Window::new_ptr(tsWindow_getWindow(index)) } }
	pub fn update() { unsafe { tsWindow_update(0) } }
	pub fn update_with_wait(wait: bool) { unsafe { tsWindow_update(if wait {1} else {0}) } }
	pub fn platform(&self) -> Platform { unsafe { tsWindow_getPlatform(self.this) } }
	pub fn platform_name(&self) -> string::String { unsafe { get_cstring(tsWindow_getPlatformName(self.this)) } }
	pub fn index(&self) -> u32 { unsafe { tsWindow_getIndex(self.this) } }
	pub fn set_surface(&mut self, surface: &mut Surface) { unsafe { tsWindow_setSurface(self.this, surface.this) } }
	pub fn surface(&self) -> Surface { unsafe { Surface::new_ptr(tsWindow_getSurface(self.this)) } }
	pub fn handle(&self) -> *mut c_void { unsafe { tsWindow_getHandle(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsWindow_isCreated(self.this) != 0 } }
	pub fn create_with_title(&mut self, title: &str) -> bool {
		let title_ = CString::new(title).unwrap();
		unsafe { tsWindow_create_sWF(self.this, title_.as_ptr(), WindowFlags::Default) != 0 }
	}
	pub fn create_with_title_flags(&mut self, title: &str, flags: WindowFlags) -> bool {
		let title_ = CString::new(title).unwrap();
		unsafe { tsWindow_create_sWF(self.this, title_.as_ptr(), flags) != 0 }
	}
	pub fn create_with_titles(&mut self, title: &String) -> bool { unsafe { tsWindow_create_cSWF(self.this, title.this, WindowFlags::Default) != 0 } }
	pub fn create_with_titles_flags(&mut self, title: &String, flags: WindowFlags) -> bool { unsafe { tsWindow_create_cSWF(self.this, title.this, flags) != 0 } }
	pub fn create(&mut self) -> bool { unsafe { tsWindow_create_WF(self.this, WindowFlags::Default) != 0 } }
	pub fn create_with_flags(&mut self, flags: WindowFlags) -> bool { unsafe { tsWindow_create_WF(self.this, flags) != 0 } }
	pub fn release(&mut self) { unsafe { tsWindow_release(self.this) } }
	pub fn clear(&mut self, color: &Color) -> bool { unsafe { tsWindow_clear(self.this, color) != 0 } }
	pub fn grab(&self, image: &mut Image) -> bool { unsafe { tsWindow_grab(self.this, image.this) != 0 } }
	pub fn render(&mut self) -> bool { unsafe { tsWindow_render(self.this) != 0 } }
	pub fn present(&mut self) -> bool { unsafe { tsWindow_present(self.this) != 0 } }
	pub fn finish(&mut self) -> bool { unsafe { tsWindow_finish(self.this) != 0 } }
	pub fn color_format(&self) -> Format { unsafe { tsWindow_getColorFormat(self.this) } }
	pub fn depth_format(&self) -> Format { unsafe { tsWindow_getDepthFormat(self.this) } }
	pub fn multisample(&self) -> u32 { unsafe { tsWindow_getMultisample(self.this) } }
	pub fn has_multisample(&self) -> bool { unsafe { tsWindow_hasMultisample(self.this) != 0 } }
	pub fn set_flags(&mut self, flags: WindowFlags) { unsafe { tsWindow_setFlags(self.this, flags) } }
	pub fn flags(&self) -> WindowFlags { unsafe { tsWindow_getFlags(self.this) } }
	pub fn has_flag(&self, flags: WindowFlags) -> bool { unsafe { tsWindow_hasFlag(self.this, flags) != 0 } }
	pub fn has_flags(&self, flags: WindowFlags) -> bool { unsafe { tsWindow_hasFlags(self.this, flags) != 0 } }
	pub fn set_refresh_rate(&mut self, rate: u32) { unsafe { tsWindow_setRefreshRate(self.this, rate) } }
	pub fn refresh_rate(&self) -> u32 { unsafe { tsWindow_getRefreshRate(self.this) } }
	pub fn set_hidden(&mut self, hidden: bool) -> bool { unsafe { tsWindow_setHidden(self.this, if hidden {1} else {0}) != 0 } }
	pub fn is_hidden(&self) -> bool { unsafe { tsWindow_isHidden(self.this) != 0 } }
	pub fn set_focused(&mut self, focused: bool) -> bool { unsafe { tsWindow_setFocused(self.this, if focused {1} else {0}) != 0 } }
	pub fn is_focused(&self) -> bool { unsafe { tsWindow_isFocused(self.this) != 0 } }
	pub fn set_minimized(&mut self, minimized: bool) -> bool { unsafe { tsWindow_setMinimized(self.this, if minimized {1} else {0}) != 0 } }
	pub fn is_minimized(&self) -> bool { unsafe { tsWindow_isMinimized(self.this) != 0 } }
	pub fn set_fullscreen(&mut self, fullscreen: bool) -> bool { unsafe { tsWindow_setFullscreen(self.this, if fullscreen {1} else {0}) != 0 } }
	pub fn is_fullscreen(&self) -> bool { unsafe { tsWindow_isFullscreen(self.this) != 0 } }
	pub fn is_occluded(&self) -> bool { unsafe { tsWindow_isOccluded(self.this) != 0 } }
	pub fn set_title(&mut self, title: &str) -> bool {
		let title_ = CString::new(title).unwrap();
		unsafe { tsWindow_setTitle_s(self.this, title_.as_ptr()) != 0 }
	}
	pub fn set_title_with_title(&mut self, title: &String) -> bool { unsafe { tsWindow_setTitle_cS(self.this, title.this) != 0 } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsWindow_getTitle(self.this)) } }
	pub fn set_icon(&mut self, image: &Image) -> bool { unsafe { tsWindow_setIcon(self.this, image.this) != 0 } }
	pub fn icon(&self) -> Image { unsafe { Image::new_ptr(tsWindow_getIcon(self.this)) } }
	pub fn set_geometry(&mut self, x: i32, y: i32, width: u32, height: u32) -> bool { unsafe { tsWindow_setGeometry(self.this, x, y, width, height, 0) != 0 } }
	pub fn set_geometry_with_force(&mut self, x: i32, y: i32, width: u32, height: u32, force: bool) -> bool { unsafe { tsWindow_setGeometry(self.this, x, y, width, height, if force {1} else {0}) != 0 } }
	pub fn set_position(&mut self, x: i32, y: i32) -> bool { unsafe { tsWindow_setPosition(self.this, x, y, 0) != 0 } }
	pub fn set_position_with_force(&mut self, x: i32, y: i32, force: bool) -> bool { unsafe { tsWindow_setPosition(self.this, x, y, if force {1} else {0}) != 0 } }
	pub fn position_x(&self) -> i32 { unsafe { tsWindow_getPositionX(self.this, 0) } }
	pub fn position_x_with_title(&self, title: bool) -> i32 { unsafe { tsWindow_getPositionX(self.this, if title {1} else {0}) } }
	pub fn position_y(&self) -> i32 { unsafe { tsWindow_getPositionY(self.this, 0) } }
	pub fn position_y_with_title(&self, title: bool) -> i32 { unsafe { tsWindow_getPositionY(self.this, if title {1} else {0}) } }
	pub fn set_size(&mut self, width: u32, height: u32) -> bool { unsafe { tsWindow_setSize(self.this, width, height, 0) != 0 } }
	pub fn set_size_with_force(&mut self, width: u32, height: u32, force: bool) -> bool { unsafe { tsWindow_setSize(self.this, width, height, if force {1} else {0}) != 0 } }
	pub fn width(&self) -> u32 { unsafe { tsWindow_getWidth(self.this) } }
	pub fn height(&self) -> u32 { unsafe { tsWindow_getHeight(self.this) } }
	pub fn scale(&self) -> f32 { unsafe { tsWindow_getScale(self.this) } }
	pub fn dpi_x(&self) -> u32 { unsafe { tsWindow_getDpiX(self.this) } }
	pub fn dpi_y(&self) -> u32 { unsafe { tsWindow_getDpiY(self.this) } }
	pub fn set_min_size(&mut self, width: u32, height: u32) -> bool { unsafe { tsWindow_setMinSize(self.this, width, height, 0) != 0 } }
	pub fn set_min_size_with_force(&mut self, width: u32, height: u32, force: bool) -> bool { unsafe { tsWindow_setMinSize(self.this, width, height, if force {1} else {0}) != 0 } }
	pub fn min_width(&self) -> u32 { unsafe { tsWindow_getMinWidth(self.this) } }
	pub fn min_height(&self) -> u32 { unsafe { tsWindow_getMinHeight(self.this) } }
	pub fn set_max_size(&mut self, width: u32, height: u32) -> bool { unsafe { tsWindow_setMaxSize(self.this, width, height, 0) != 0 } }
	pub fn set_max_size_with_force(&mut self, width: u32, height: u32, force: bool) -> bool { unsafe { tsWindow_setMaxSize(self.this, width, height, if force {1} else {0}) != 0 } }
	pub fn max_width(&self) -> u32 { unsafe { tsWindow_getMaxWidth(self.this) } }
	pub fn max_height(&self) -> u32 { unsafe { tsWindow_getMaxHeight(self.this) } }
	pub fn set_mouse(&mut self, x: i32, y: i32) -> bool { unsafe { tsWindow_setMouse(self.this, x, y, 0) != 0 } }
	pub fn set_mouse_with_force(&mut self, x: i32, y: i32, force: bool) -> bool { unsafe { tsWindow_setMouse(self.this, x, y, if force {1} else {0}) != 0 } }
	pub fn mouse_x(&self) -> i32 { unsafe { tsWindow_getMouseX(self.this) } }
	pub fn mouse_y(&self) -> i32 { unsafe { tsWindow_getMouseY(self.this) } }
	pub fn set_mouse_delta(&mut self, dx: i32, dy: i32) -> bool { unsafe { tsWindow_setMouseDelta(self.this, dx, dy) != 0 } }
	pub fn mouse_dx(&self) -> i32 { unsafe { tsWindow_getMouseDX(self.this) } }
	pub fn mouse_dy(&self) -> i32 { unsafe { tsWindow_getMouseDY(self.this) } }
	pub fn set_mouse_hidden(&mut self, hidden: bool) -> bool { unsafe { tsWindow_setMouseHidden(self.this, if hidden {1} else {0}, 0) != 0 } }
	pub fn set_mouse_hidden_with_force(&mut self, hidden: bool, force: bool) -> bool { unsafe { tsWindow_setMouseHidden(self.this, if hidden {1} else {0}, if force {1} else {0}) != 0 } }
	pub fn is_mouse_hidden(&self) -> bool { unsafe { tsWindow_isMouseHidden(self.this) != 0 } }
	pub fn set_mouse_clipped(&mut self, clipped: bool) -> bool { unsafe { tsWindow_setMouseClipped(self.this, if clipped {1} else {0}, 0) != 0 } }
	pub fn set_mouse_clipped_with_force(&mut self, clipped: bool, force: bool) -> bool { unsafe { tsWindow_setMouseClipped(self.this, if clipped {1} else {0}, if force {1} else {0}) != 0 } }
	pub fn is_mouse_clipped(&self) -> bool { unsafe { tsWindow_isMouseClipped(self.this) != 0 } }
	pub fn is_mouse_inside(&self) -> bool { unsafe { tsWindow_isMouseInside(self.this) != 0 } }
	pub fn set_mouse_cursor(&mut self, cursor: WindowCursor) -> bool { unsafe { tsWindow_setMouseCursor(self.this, cursor, 0) != 0 } }
	pub fn set_mouse_cursor_with_force(&mut self, cursor: WindowCursor, force: bool) -> bool { unsafe { tsWindow_setMouseCursor(self.this, cursor, if force {1} else {0}) != 0 } }
	pub fn mouse_cursor(&self) -> WindowCursor { unsafe { tsWindow_getMouseCursor(self.this) } }
	pub fn set_mouse_buttons(&mut self, buttons: WindowButton) -> bool { unsafe { tsWindow_setMouseButtons(self.this, buttons) != 0 } }
	pub fn mouse_buttons(&self) -> WindowButton { unsafe { tsWindow_getMouseButtons(self.this) } }
	pub fn set_mouse_button(&mut self, button: WindowButton, value: bool) -> bool { unsafe { tsWindow_setMouseButton(self.this, button, if value {1} else {0}) != 0 } }
	pub fn mouse_button(&self, button: WindowButton) -> bool { unsafe { tsWindow_getMouseButton(self.this, button, 0) != 0 } }
	pub fn mouse_button_with_clear(&self, button: WindowButton, clear: bool) -> bool { unsafe { tsWindow_getMouseButton(self.this, button, if clear {1} else {0}) != 0 } }
	pub fn release_mouse_buttons(&mut self, buttons: WindowButton) { unsafe { tsWindow_releaseMouseButtons(self.this, buttons) } }
	pub fn clear_mouse_buttons(&mut self) -> WindowButton { unsafe { tsWindow_clearMouseButtons(self.this) } }
	pub fn set_mouse_axis(&mut self, axis: WindowAxis, value: f32) -> bool { unsafe { tsWindow_setMouseAxis(self.this, axis, value) != 0 } }
	pub fn mouse_axis(&self, axis: WindowAxis) -> f32 { unsafe { tsWindow_getMouseAxis(self.this, axis) } }
	pub fn clear_mouse_axis(&mut self, axis: WindowAxis) -> f32 { unsafe { tsWindow_clearMouseAxis(self.this, axis) } }
	pub fn set_mouse_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(WindowButton) {
		let func = Box::leak(Box::new(func));
		let func_ = window_mouse_pressed_callback_func::<Func>;
		unsafe { tsWindow_setMousePressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_mouse_released_callback<Func>(&mut self, func: Func) where Func: FnMut(WindowButton) {
		let func = Box::leak(Box::new(func));
		let func_ = window_mouse_released_callback_func::<Func>;
		unsafe { tsWindow_setMouseReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_mouse_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(i32, i32) {
		let func = Box::leak(Box::new(func));
		let func_ = window_mouse_changed_callback_func::<Func>;
		unsafe { tsWindow_setMouseChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_mouse_rotated_callback<Func>(&mut self, func: Func) where Func: FnMut(WindowAxis, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = window_mouse_rotated_callback_func::<Func>;
		unsafe { tsWindow_setMouseRotatedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn num_touches(&self) -> u32 { unsafe { tsWindow_getNumTouches(self.this) } }
	pub fn add_touch(&mut self, x: i32, y: i32) -> u32 { unsafe { tsWindow_addTouch(self.this, x, y) } }
	pub fn touch_x(&self, touch: u32) -> i32 { unsafe { tsWindow_getTouchX(self.this, touch) } }
	pub fn touch_y(&self, touch: u32) -> i32 { unsafe { tsWindow_getTouchY(self.this, touch) } }
	pub fn find_touch(&self, x: i32, y: i32) -> u32 { unsafe { tsWindow_findTouch(self.this, x, y) } }
	pub fn clear_touches(&mut self) { unsafe { tsWindow_clearTouches(self.this) } }
	pub fn set_touch_changed_callback<Func>(&mut self, func: Func) where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = window_touch_changed_callback_func::<Func>;
		unsafe { tsWindow_setTouchChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_keyboard_key(&mut self, key: u32, value: bool) { unsafe { tsWindow_setKeyboardKey(self.this, key, if value {1} else {0}) } }
	pub fn keyboard_key(&self, key: u32) -> bool { unsafe { tsWindow_getKeyboardKey(self.this, key, 0) != 0 } }
	pub fn keyboard_key_with_clear(&self, key: u32, clear: bool) -> bool { unsafe { tsWindow_getKeyboardKey(self.this, key, if clear {1} else {0}) != 0 } }
	pub fn set_keyboard_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(u32, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = window_keyboard_pressed_callback_func::<Func>;
		unsafe { tsWindow_setKeyboardPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_keyboard_released_callback<Func>(&mut self, func: Func) where Func: FnMut(u32) {
		let func = Box::leak(Box::new(func));
		let func_ = window_keyboard_released_callback_func::<Func>;
		unsafe { tsWindow_setKeyboardReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_size_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(u32, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = window_size_changed_callback_func::<Func>;
		unsafe { tsWindow_setSizeChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_focus_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(bool) {
		let func = Box::leak(Box::new(func));
		let func_ = window_focus_changed_callback_func::<Func>;
		unsafe { tsWindow_setFocusChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_close_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = window_close_clicked_callback_func::<Func>;
		unsafe { tsWindow_setCloseClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_pause_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(bool) {
		let func = Box::leak(Box::new(func));
		let func_ = window_pause_changed_callback_func::<Func>;
		unsafe { tsWindow_setPauseChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_file_dropped_callback<Func>(&mut self, func: Func) where Func: FnMut(&str, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = window_file_dropped_callback_func::<Func>;
		unsafe { tsWindow_setFileDroppedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = window_update_callback_func::<Func>;
		unsafe { tsWindow_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_present_callback<Func>(&mut self, func: Func) where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = window_present_callback_func::<Func>;
		unsafe { tsWindow_setPresentCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run<Func>(&mut self, func: Func) -> bool where Func: FnMut() -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = window_main_loop_callback_func::<Func>;
		let ret = unsafe { tsWindow_run(self.this, func_, func as *mut _ as *mut c_void) != 0 };
		unsafe { tsWindow_finish(self.this); }
		ret
	}
	pub fn is_running(&self) -> bool { unsafe { tsWindow_isRunning(self.this) != 0 } }
	pub fn stop(&mut self) { unsafe { tsWindow_stop(self.this) } }
	pub fn set_copy_text(&mut self, text: &str) -> bool {
		let text_ = CString::new(text).unwrap();
		unsafe { tsWindow_setCopyText_s(self.this, text_.as_ptr()) != 0 }
	}
	pub fn set_copy_text_with_text(&mut self, text: &String) -> bool { unsafe { tsWindow_setCopyText_cS(self.this, text.this) != 0 } }
	pub fn paste_text(&self) -> string::String { unsafe { get_string(tsWindow_getPasteText(self.this)) } }
}
impl Drop for Window {
	fn drop(&mut self) { if self.owner { unsafe { tsWindow_delete(self.this) } } }
}
impl Clone for Window {
	fn clone(&self) -> Window { unsafe { Window { this: tsWindow_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Window { }
impl fmt::Display for Window {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Window ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsWindow_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsWindow_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsWindow_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsWindow_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsWindow_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsWindow_new() -> *mut c_void;
	fn tsWindow_new_Pu(platform: Platform, index: u32) -> *mut c_void;
	fn tsWindow_new_S(surface: *mut c_void) -> *mut c_void;
	fn tsWindow_delete(this: *mut c_void);
	fn tsWindow_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsWindow_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsWindow_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsWindow_clearPtr(this: *const c_void);
	fn tsWindow_destroyPtr(this: *const c_void);
	fn tsWindow_acquirePtr(this: *const c_void);
	fn tsWindow_unacquirePtr(this: *const c_void);
	fn tsWindow_isValidPtr(this: *const c_void) -> i32;
	fn tsWindow_isOwnerPtr(this: *const c_void) -> i32;
	fn tsWindow_isConstPtr(this: *const c_void) -> i32;
	fn tsWindow_getCountPtr(this: *const c_void) -> u32;
	fn tsWindow_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsWindow_getNumWindows() -> u32;
	fn tsWindow_getWindow(index: u32) -> *mut c_void;
	fn tsWindow_update(wait: i32);
	fn tsWindow_getPlatform(this: *const c_void) -> Platform;
	fn tsWindow_getPlatformName(this: *const c_void) -> *const c_char;
	fn tsWindow_getIndex(this: *const c_void) -> u32;
	fn tsWindow_setSurface(this: *mut c_void, surface: *mut c_void);
	fn tsWindow_getSurface(this: *const c_void) -> *mut c_void;
	fn tsWindow_getHandle(this: *const c_void) -> *mut c_void;
	fn tsWindow_isCreated(this: *const c_void) -> i32;
	fn tsWindow_create_sWF(this: *mut c_void, title: *const c_char, flags: WindowFlags) -> i32;
	fn tsWindow_create_cSWF(this: *mut c_void, title: *mut c_void, flags: WindowFlags) -> i32;
	fn tsWindow_create_WF(this: *mut c_void, flags: WindowFlags) -> i32;
	fn tsWindow_release(this: *mut c_void);
	fn tsWindow_clear(this: *mut c_void, color: *const Color) -> i32;
	fn tsWindow_grab(this: *const c_void, image: *mut c_void) -> i32;
	fn tsWindow_render(this: *mut c_void) -> i32;
	fn tsWindow_present(this: *mut c_void) -> i32;
	fn tsWindow_finish(this: *mut c_void) -> i32;
	fn tsWindow_getColorFormat(this: *const c_void) -> Format;
	fn tsWindow_getDepthFormat(this: *const c_void) -> Format;
	fn tsWindow_getMultisample(this: *const c_void) -> u32;
	fn tsWindow_hasMultisample(this: *const c_void) -> i32;
	fn tsWindow_setFlags(this: *mut c_void, flags: WindowFlags);
	fn tsWindow_getFlags(this: *const c_void) -> WindowFlags;
	fn tsWindow_hasFlag(this: *const c_void, flags: WindowFlags) -> i32;
	fn tsWindow_hasFlags(this: *const c_void, flags: WindowFlags) -> i32;
	fn tsWindow_setRefreshRate(this: *mut c_void, rate: u32);
	fn tsWindow_getRefreshRate(this: *const c_void) -> u32;
	fn tsWindow_setHidden(this: *mut c_void, hidden: i32) -> i32;
	fn tsWindow_isHidden(this: *const c_void) -> i32;
	fn tsWindow_setFocused(this: *mut c_void, focused: i32) -> i32;
	fn tsWindow_isFocused(this: *const c_void) -> i32;
	fn tsWindow_setMinimized(this: *mut c_void, minimized: i32) -> i32;
	fn tsWindow_isMinimized(this: *const c_void) -> i32;
	fn tsWindow_setFullscreen(this: *mut c_void, fullscreen: i32) -> i32;
	fn tsWindow_isFullscreen(this: *const c_void) -> i32;
	fn tsWindow_isOccluded(this: *const c_void) -> i32;
	fn tsWindow_setTitle_s(this: *mut c_void, title: *const c_char) -> i32;
	fn tsWindow_setTitle_cS(this: *mut c_void, title: *mut c_void) -> i32;
	fn tsWindow_getTitle(this: *const c_void) -> *mut c_void;
	fn tsWindow_setIcon(this: *mut c_void, image: *mut c_void) -> i32;
	fn tsWindow_getIcon(this: *const c_void) -> *mut c_void;
	fn tsWindow_setGeometry(this: *mut c_void, x: i32, y: i32, width: u32, height: u32, force: i32) -> i32;
	fn tsWindow_setPosition(this: *mut c_void, x: i32, y: i32, force: i32) -> i32;
	fn tsWindow_getPositionX(this: *const c_void, title: i32) -> i32;
	fn tsWindow_getPositionY(this: *const c_void, title: i32) -> i32;
	fn tsWindow_setSize(this: *mut c_void, width: u32, height: u32, force: i32) -> i32;
	fn tsWindow_getWidth(this: *const c_void) -> u32;
	fn tsWindow_getHeight(this: *const c_void) -> u32;
	fn tsWindow_getScale(this: *const c_void) -> f32;
	fn tsWindow_getDpiX(this: *const c_void) -> u32;
	fn tsWindow_getDpiY(this: *const c_void) -> u32;
	fn tsWindow_setMinSize(this: *mut c_void, width: u32, height: u32, force: i32) -> i32;
	fn tsWindow_getMinWidth(this: *const c_void) -> u32;
	fn tsWindow_getMinHeight(this: *const c_void) -> u32;
	fn tsWindow_setMaxSize(this: *mut c_void, width: u32, height: u32, force: i32) -> i32;
	fn tsWindow_getMaxWidth(this: *const c_void) -> u32;
	fn tsWindow_getMaxHeight(this: *const c_void) -> u32;
	fn tsWindow_setMouse(this: *mut c_void, x: i32, y: i32, force: i32) -> i32;
	fn tsWindow_getMouseX(this: *const c_void) -> i32;
	fn tsWindow_getMouseY(this: *const c_void) -> i32;
	fn tsWindow_setMouseDelta(this: *mut c_void, dx: i32, dy: i32) -> i32;
	fn tsWindow_getMouseDX(this: *const c_void) -> i32;
	fn tsWindow_getMouseDY(this: *const c_void) -> i32;
	fn tsWindow_setMouseHidden(this: *mut c_void, hidden: i32, force: i32) -> i32;
	fn tsWindow_isMouseHidden(this: *const c_void) -> i32;
	fn tsWindow_setMouseClipped(this: *mut c_void, clipped: i32, force: i32) -> i32;
	fn tsWindow_isMouseClipped(this: *const c_void) -> i32;
	fn tsWindow_isMouseInside(this: *const c_void) -> i32;
	fn tsWindow_setMouseCursor(this: *mut c_void, cursor: WindowCursor, force: i32) -> i32;
	fn tsWindow_getMouseCursor(this: *const c_void) -> WindowCursor;
	fn tsWindow_setMouseButtons(this: *mut c_void, buttons: WindowButton) -> i32;
	fn tsWindow_getMouseButtons(this: *const c_void) -> WindowButton;
	fn tsWindow_setMouseButton(this: *mut c_void, button: WindowButton, value: i32) -> i32;
	fn tsWindow_getMouseButton(this: *const c_void, button: WindowButton, clear: i32) -> i32;
	fn tsWindow_releaseMouseButtons(this: *mut c_void, buttons: WindowButton);
	fn tsWindow_clearMouseButtons(this: *mut c_void) -> WindowButton;
	fn tsWindow_setMouseAxis(this: *mut c_void, axis: WindowAxis, value: f32) -> i32;
	fn tsWindow_getMouseAxis(this: *const c_void, axis: WindowAxis) -> f32;
	fn tsWindow_clearMouseAxis(this: *mut c_void, axis: WindowAxis) -> f32;
	fn tsWindow_setMousePressedCallback(this: *mut c_void, func: WindowMousePressedCallback, data_: *mut c_void);
	fn tsWindow_setMouseReleasedCallback(this: *mut c_void, func: WindowMouseReleasedCallback, data_: *mut c_void);
	fn tsWindow_setMouseChangedCallback(this: *mut c_void, func: WindowMouseChangedCallback, data_: *mut c_void);
	fn tsWindow_setMouseRotatedCallback(this: *mut c_void, func: WindowMouseRotatedCallback, data_: *mut c_void);
	fn tsWindow_getNumTouches(this: *const c_void) -> u32;
	fn tsWindow_addTouch(this: *mut c_void, x: i32, y: i32) -> u32;
	fn tsWindow_getTouchX(this: *const c_void, touch: u32) -> i32;
	fn tsWindow_getTouchY(this: *const c_void, touch: u32) -> i32;
	fn tsWindow_findTouch(this: *const c_void, x: i32, y: i32) -> u32;
	fn tsWindow_clearTouches(this: *mut c_void);
	fn tsWindow_setTouchChangedCallback(this: *mut c_void, func: WindowTouchChangedCallback, data_: *mut c_void);
	fn tsWindow_setKeyboardKey(this: *mut c_void, key: u32, value: i32);
	fn tsWindow_getKeyboardKey(this: *const c_void, key: u32, clear: i32) -> i32;
	fn tsWindow_setKeyboardPressedCallback(this: *mut c_void, func: WindowKeyboardPressedCallback, data_: *mut c_void);
	fn tsWindow_setKeyboardReleasedCallback(this: *mut c_void, func: WindowKeyboardReleasedCallback, data_: *mut c_void);
	fn tsWindow_setSizeChangedCallback(this: *mut c_void, func: WindowSizeChangedCallback, data_: *mut c_void);
	fn tsWindow_setFocusChangedCallback(this: *mut c_void, func: WindowFocusChangedCallback, data_: *mut c_void);
	fn tsWindow_setCloseClickedCallback(this: *mut c_void, func: WindowCloseClickedCallback, data_: *mut c_void);
	fn tsWindow_setPauseChangedCallback(this: *mut c_void, func: WindowPauseChangedCallback, data_: *mut c_void);
	fn tsWindow_setFileDroppedCallback(this: *mut c_void, func: WindowFileDroppedCallback, data_: *mut c_void);
	fn tsWindow_setUpdateCallback(this: *mut c_void, func: WindowUpdateCallback, data_: *mut c_void);
	fn tsWindow_setPresentCallback(this: *mut c_void, func: WindowPresentCallback, data_: *mut c_void);
	fn tsWindow_run(this: *mut c_void, func: WindowMainLoopCallback, data_: *mut c_void) -> i32;
	fn tsWindow_isRunning(this: *const c_void) -> i32;
	fn tsWindow_stop(this: *mut c_void);
	fn tsWindow_setCopyText_s(this: *mut c_void, text: *const c_char) -> i32;
	fn tsWindow_setCopyText_cS(this: *mut c_void, text: *mut c_void) -> i32;
	fn tsWindow_getPasteText(this: *const c_void) -> *mut c_void;
}

// Tellusim::Font
pub struct Font {
	this: *mut c_void,
	owner: bool,
}
impl Font {
	pub fn null() -> Font { Font { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Font { unsafe { Font { this: tsFont_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Font { unsafe { Font { this: ptr, owner: tsFont_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Font { unsafe { Font { this: tsFont_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Font) -> bool { unsafe { tsFont_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Font { unsafe { Font { this: tsFont_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFont_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFont_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFont_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFont_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFont_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFont_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFont_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFont_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFont_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsFont_clear(self.this) } }
	pub fn is_loaded(&self) -> bool { unsafe { tsFont_isLoaded(self.this) != 0 } }
	pub fn load(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsFont_load_s(self.this, name_.as_ptr()) != 0 }
	}
	pub fn load_with_stream(&mut self, stream: &mut Stream) -> bool { unsafe { tsFont_load_St(self.this, stream.this) != 0 } }
	pub fn advance(&mut self, style: &FontStyle, code: u32) -> f32 { unsafe { tsFont_getAdvance(self.this, style, code) } }
	pub fn rect_with_position(&mut self, position: &Vector3f, style: &FontStyle, str: &str) -> Rect {
		let str_ = CString::new(str).unwrap();
		unsafe { tsFont_getRect_cV3cFSs(self.this, position, style, str_.as_ptr()) }
	}
	pub fn rect_with_position_str(&mut self, position: &Vector3f, style: &FontStyle, str: *const u32) -> Rect { unsafe { tsFont_getRect_cV3cFSup(self.this, position, style, str) } }
	pub fn create_with_style(&mut self, device: &Device, style: &FontStyle, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsFont_create_cDcFSs(self.this, device.this, style, str_.as_ptr()) }
	}
	pub fn create_with_style_str(&mut self, device: &Device, style: &FontStyle, str: *const u32) { unsafe { tsFont_create_cDcFSup(self.this, device.this, style, str) } }
	pub fn draw_with_position(&mut self, command: &mut Command, position: &Vector3f, style: &FontStyle, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsFont_draw_CcV3cFSs(self.this, command.this, position, style, str_.as_ptr()) }
	}
	pub fn draw_with_position_str(&mut self, command: &mut Command, position: &Vector3f, style: &FontStyle, str: *const u32) { unsafe { tsFont_draw_CcV3cFSup(self.this, command.this, position, style, str) } }
	pub fn flush(&mut self, device: &Device) -> bool { unsafe { tsFont_flush(self.this, device.this) != 0 } }
}
impl Drop for Font {
	fn drop(&mut self) { if self.owner { unsafe { tsFont_delete(self.this) } } }
}
impl Clone for Font {
	fn clone(&self) -> Font { unsafe { Font { this: tsFont_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Font { }
impl fmt::Display for Font {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Font ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFont_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFont_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFont_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFont_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFont_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFont_new() -> *mut c_void;
	fn tsFont_delete(this: *mut c_void);
	fn tsFont_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFont_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFont_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFont_clearPtr(this: *const c_void);
	fn tsFont_destroyPtr(this: *const c_void);
	fn tsFont_acquirePtr(this: *const c_void);
	fn tsFont_unacquirePtr(this: *const c_void);
	fn tsFont_isValidPtr(this: *const c_void) -> i32;
	fn tsFont_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFont_isConstPtr(this: *const c_void) -> i32;
	fn tsFont_getCountPtr(this: *const c_void) -> u32;
	fn tsFont_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFont_clear(this: *mut c_void);
	fn tsFont_isLoaded(this: *const c_void) -> i32;
	fn tsFont_load_s(this: *mut c_void, name: *const c_char) -> i32;
	fn tsFont_load_St(this: *mut c_void, stream: *mut c_void) -> i32;
	fn tsFont_getAdvance(this: *mut c_void, style: *const FontStyle, code: u32) -> f32;
	fn tsFont_getRect_cV3cFSs(this: *mut c_void, position: *const Vector3f, style: *const FontStyle, str: *const c_char) -> Rect;
	fn tsFont_getRect_cV3cFSup(this: *mut c_void, position: *const Vector3f, style: *const FontStyle, str: *const u32) -> Rect;
	fn tsFont_create_cDcFSs(this: *mut c_void, device: *mut c_void, style: *const FontStyle, str: *const c_char);
	fn tsFont_create_cDcFSup(this: *mut c_void, device: *mut c_void, style: *const FontStyle, str: *const u32);
	fn tsFont_draw_CcV3cFSs(this: *mut c_void, command: *mut c_void, position: *const Vector3f, style: *const FontStyle, str: *const c_char);
	fn tsFont_draw_CcV3cFSup(this: *mut c_void, command: *mut c_void, position: *const Vector3f, style: *const FontStyle, str: *const u32);
	fn tsFont_flush(this: *mut c_void, device: *mut c_void) -> i32;
}

// Tellusim::CanvasElement
pub struct CanvasElement {
	this: *mut c_void,
	owner: bool,
}
type CanvasElementDrawCallback = unsafe extern "C" fn(command: *mut c_void, element: *mut c_void, data_: *mut c_void) -> i32;
unsafe extern "C" fn canvas_element_draw_callback_func<Func>(command: *mut c_void, element: *mut c_void, data_: *mut c_void) -> i32 where Func: FnMut(Command, CanvasElement) -> bool {
	let func = &mut *(data_ as *mut Func);
	let command_ = Command::new_ptr(command);
	let element_ = CanvasElement::new_ptr(element);
	if func(command_, element_) {1} else {0}
}
impl CanvasElement {
	pub fn null() -> CanvasElement { CanvasElement { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasElement { unsafe { CanvasElement { this: tsCanvasElement_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasElement { unsafe { CanvasElement { this: ptr, owner: tsCanvasElement_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasElement { unsafe { CanvasElement { this: tsCanvasElement_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: CanvasElement) -> bool { unsafe { tsCanvasElement_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasElement { unsafe { CanvasElement { this: tsCanvasElement_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasElement_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasElement_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasElement_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasElement_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasElement_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasElement_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasElement_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasElement_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasElement_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait CanvasElementTrait {
	fn type_(&self) -> CanvasElementType;
	fn type_name_with_type(type_: CanvasElementType) -> string::String;
	fn type_name(&self) -> string::String;
	fn is_text(&self) -> bool;
	fn is_mesh(&self) -> bool;
	fn is_rect(&self) -> bool;
	fn is_triangle(&self) -> bool;
	fn is_ellipse(&self) -> bool;
	fn is_shape(&self) -> bool;
	fn is_strip(&self) -> bool;
	fn set_canvas(&mut self, canvas: &mut Canvas);
	fn canvas(&self) -> Canvas;
	fn canvas_mut(&mut self) -> Canvas;
	fn set_mode(&mut self, mode: CanvasElementMode);
	fn mode(&self) -> CanvasElementMode;
	fn set_align(&mut self, align: CanvasElementAlign);
	fn align(&self) -> CanvasElementAlign;
	fn has_align(&self, align: CanvasElementAlign) -> bool;
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool;
	fn set_order(&mut self, order: i32);
	fn order(&self) -> i32;
	fn set_enabled(&mut self, enabled: bool);
	fn is_enabled(&self) -> bool;
	fn clear_color(&mut self);
	fn set_color(&mut self, op: CanvasElementStack);
	fn set_color_with_color(&mut self, color: &Color);
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack);
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32);
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack);
	fn color(&self) -> Color;
	fn color_op(&self) -> CanvasElementStack;
	fn clear_transform(&mut self);
	fn set_transform(&mut self, op: CanvasElementStack);
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f);
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack);
	fn transform(&self) -> Matrix4x4f;
	fn transform_op(&self) -> CanvasElementStack;
	fn clear_scissor(&mut self);
	fn set_scissor(&mut self, op: CanvasElementStack);
	fn set_scissor_with_scissor(&mut self, scissor: &Rect);
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack);
	fn scissor(&self) -> Rect;
	fn scissor_op(&self) -> CanvasElementStack;
	fn set_mipmap(&mut self, mipmap: f32);
	fn mipmap(&self) -> f32;
	fn set_sampler(&mut self, sampler: &mut Sampler);
	fn sampler(&self) -> Sampler;
	fn set_filter(&mut self, filter: SamplerFilter);
	fn filter(&self) -> SamplerFilter;
	fn set_anisotropy(&mut self, anisotropy: u32);
	fn anisotropy(&self) -> u32;
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode);
	fn wrap_mode(&self) -> SamplerWrapMode;
	fn set_texture(&mut self, texture: &mut Texture);
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool);
	fn texture(&self) -> Texture;
	fn texture_linear(&self) -> bool;
	fn set_pipeline(&mut self, pipeline: &mut Pipeline);
	fn pipeline(&self) -> Pipeline;
	fn set_primitive(&mut self, primitive: PipelinePrimitive);
	fn primitive(&self) -> PipelinePrimitive;
	fn set_cull_mode(&mut self, mode: PipelineCullMode);
	fn cull_mode(&self) -> PipelineCullMode;
	fn set_front_mode(&mut self, mode: PipelineFrontMode);
	fn front_mode(&self) -> PipelineFrontMode;
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn blend_op(&self) -> PipelineBlendOp;
	fn blend_src_func(&self) -> PipelineBlendFunc;
	fn blend_dest_func(&self) -> PipelineBlendFunc;
	fn set_color_mask(&mut self, mask: PipelineColorMask);
	fn color_mask(&self) -> PipelineColorMask;
	fn set_depth_mask(&mut self, mask: PipelineDepthMask);
	fn depth_mask(&self) -> PipelineDepthMask;
	fn set_depth_func(&mut self, func: PipelineDepthFunc);
	fn depth_func(&self) -> PipelineDepthFunc;
	fn set_stencil_ref(&mut self, ref_: u32);
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn stencil_ref(&self) -> u32;
	fn stencil_func(&self) -> PipelineStencilFunc;
	fn stencil_fail_op(&self) -> PipelineStencilOp;
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp;
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp;
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool;
	fn rect(&mut self) -> Rect;
}
impl CanvasElementTrait for CanvasElement {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasElement {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasElement_delete(self.this) } } }
}
impl Clone for CanvasElement {
	fn clone(&self) -> CanvasElement { unsafe { CanvasElement { this: tsCanvasElement_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasElement { }
impl fmt::Display for CanvasElement {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasElement ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasElement_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasElement_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasElement_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasElement_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasElement_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasElement_new() -> *mut c_void;
	fn tsCanvasElement_delete(this: *mut c_void);
	fn tsCanvasElement_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasElement_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_clearPtr(this: *const c_void);
	fn tsCanvasElement_destroyPtr(this: *const c_void);
	fn tsCanvasElement_acquirePtr(this: *const c_void);
	fn tsCanvasElement_unacquirePtr(this: *const c_void);
	fn tsCanvasElement_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasElement_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasElement_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasElement_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasElement_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_getType(this: *const c_void) -> CanvasElementType;
	fn tsCanvasElement_getTypeName_CET(type_: CanvasElementType) -> *const c_char;
	fn tsCanvasElement_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsCanvasElement_isText(this: *const c_void) -> i32;
	fn tsCanvasElement_isMesh(this: *const c_void) -> i32;
	fn tsCanvasElement_isRect(this: *const c_void) -> i32;
	fn tsCanvasElement_isTriangle(this: *const c_void) -> i32;
	fn tsCanvasElement_isEllipse(this: *const c_void) -> i32;
	fn tsCanvasElement_isShape(this: *const c_void) -> i32;
	fn tsCanvasElement_isStrip(this: *const c_void) -> i32;
	fn tsCanvasElement_setCanvas(this: *mut c_void, canvas: *mut c_void);
	fn tsCanvasElement_getCanvas_c(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_getCanvas(this: *mut c_void) -> *mut c_void;
	fn tsCanvasElement_setMode(this: *mut c_void, mode: CanvasElementMode);
	fn tsCanvasElement_getMode(this: *const c_void) -> CanvasElementMode;
	fn tsCanvasElement_setAlign(this: *mut c_void, align: CanvasElementAlign);
	fn tsCanvasElement_getAlign(this: *const c_void) -> CanvasElementAlign;
	fn tsCanvasElement_hasAlign(this: *const c_void, align: CanvasElementAlign) -> i32;
	fn tsCanvasElement_hasAligns(this: *const c_void, aligns: CanvasElementAlign) -> i32;
	fn tsCanvasElement_setOrder(this: *mut c_void, order: i32);
	fn tsCanvasElement_getOrder(this: *const c_void) -> i32;
	fn tsCanvasElement_setEnabled(this: *mut c_void, enabled: i32);
	fn tsCanvasElement_isEnabled(this: *const c_void) -> i32;
	fn tsCanvasElement_clearColor(this: *mut c_void);
	fn tsCanvasElement_setColor_CES(this: *mut c_void, op: CanvasElementStack);
	fn tsCanvasElement_setColor_cCCES(this: *mut c_void, color: *const Color, op: CanvasElementStack);
	fn tsCanvasElement_setColor_ffffCES(this: *mut c_void, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack);
	fn tsCanvasElement_getColor(this: *const c_void) -> Color;
	fn tsCanvasElement_getColorOp(this: *const c_void) -> CanvasElementStack;
	fn tsCanvasElement_clearTransform(this: *mut c_void);
	fn tsCanvasElement_setTransform_CES(this: *mut c_void, op: CanvasElementStack);
	fn tsCanvasElement_setTransform_cM44CES(this: *mut c_void, transform: *const Matrix4x4f, op: CanvasElementStack);
	fn tsCanvasElement_getTransform(this: *const c_void) -> Matrix4x4f;
	fn tsCanvasElement_getTransformOp(this: *const c_void) -> CanvasElementStack;
	fn tsCanvasElement_clearScissor(this: *mut c_void);
	fn tsCanvasElement_setScissor_CES(this: *mut c_void, op: CanvasElementStack);
	fn tsCanvasElement_setScissor_cRCES(this: *mut c_void, scissor: *const Rect, op: CanvasElementStack);
	fn tsCanvasElement_getScissor(this: *const c_void) -> Rect;
	fn tsCanvasElement_getScissorOp(this: *const c_void) -> CanvasElementStack;
	fn tsCanvasElement_setMipmap(this: *mut c_void, mipmap: f32);
	fn tsCanvasElement_getMipmap(this: *const c_void) -> f32;
	fn tsCanvasElement_setSampler(this: *mut c_void, sampler: *mut c_void);
	fn tsCanvasElement_getSampler(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_setFilter(this: *mut c_void, filter: SamplerFilter);
	fn tsCanvasElement_getFilter(this: *const c_void) -> SamplerFilter;
	fn tsCanvasElement_setAnisotropy(this: *mut c_void, anisotropy: u32);
	fn tsCanvasElement_getAnisotropy(this: *const c_void) -> u32;
	fn tsCanvasElement_setWrapMode(this: *mut c_void, mode: SamplerWrapMode);
	fn tsCanvasElement_getWrapMode(this: *const c_void) -> SamplerWrapMode;
	fn tsCanvasElement_setTexture(this: *mut c_void, texture: *mut c_void, linear: i32);
	fn tsCanvasElement_getTexture(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_getTextureLinear(this: *const c_void) -> i32;
	fn tsCanvasElement_setPipeline(this: *mut c_void, pipeline: *mut c_void);
	fn tsCanvasElement_getPipeline(this: *const c_void) -> *mut c_void;
	fn tsCanvasElement_setPrimitive(this: *mut c_void, primitive: PipelinePrimitive);
	fn tsCanvasElement_getPrimitive(this: *const c_void) -> PipelinePrimitive;
	fn tsCanvasElement_setCullMode(this: *mut c_void, mode: PipelineCullMode);
	fn tsCanvasElement_getCullMode(this: *const c_void) -> PipelineCullMode;
	fn tsCanvasElement_setFrontMode(this: *mut c_void, mode: PipelineFrontMode);
	fn tsCanvasElement_getFrontMode(this: *const c_void) -> PipelineFrontMode;
	fn tsCanvasElement_setBlend(this: *mut c_void, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsCanvasElement_getBlendOp(this: *const c_void) -> PipelineBlendOp;
	fn tsCanvasElement_getBlendSrcFunc(this: *const c_void) -> PipelineBlendFunc;
	fn tsCanvasElement_getBlendDestFunc(this: *const c_void) -> PipelineBlendFunc;
	fn tsCanvasElement_setColorMask(this: *mut c_void, mask: PipelineColorMask);
	fn tsCanvasElement_getColorMask(this: *const c_void) -> PipelineColorMask;
	fn tsCanvasElement_setDepthMask(this: *mut c_void, mask: PipelineDepthMask);
	fn tsCanvasElement_getDepthMask(this: *const c_void) -> PipelineDepthMask;
	fn tsCanvasElement_setDepthFunc(this: *mut c_void, func: PipelineDepthFunc);
	fn tsCanvasElement_getDepthFunc(this: *const c_void) -> PipelineDepthFunc;
	fn tsCanvasElement_setStencilRef(this: *mut c_void, ref_: u32);
	fn tsCanvasElement_setStencilFunc(this: *mut c_void, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp);
	fn tsCanvasElement_getStencilRef(this: *const c_void) -> u32;
	fn tsCanvasElement_getStencilFunc(this: *const c_void) -> PipelineStencilFunc;
	fn tsCanvasElement_getStencilFailOp(this: *const c_void) -> PipelineStencilOp;
	fn tsCanvasElement_getStencilDepthFailOp(this: *const c_void) -> PipelineStencilOp;
	fn tsCanvasElement_getStencilDepthPassOp(this: *const c_void) -> PipelineStencilOp;
	fn tsCanvasElement_setDrawCallback(this: *mut c_void, func: CanvasElementDrawCallback, data_: *mut c_void);
	fn tsCanvasElement_getRect(this: *mut c_void) -> Rect;
}

// Tellusim::CanvasText
pub struct CanvasText {
	this: *mut c_void,
	owner: bool,
}
impl CanvasText {
	pub fn null() -> CanvasText { CanvasText { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasText { unsafe { CanvasText { this: tsCanvasText_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasText { unsafe { CanvasText { this: tsCanvasText_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_text(canvas: &mut Canvas, text: &str) -> CanvasText {
		let text_ = CString::new(text).unwrap();
		unsafe { CanvasText { this: tsCanvasText_new_Cs(canvas.this, text_.as_ptr()), owner: true } }
	}
	pub fn new_with_canvas_texts(canvas: &mut Canvas, text: &String) -> CanvasText { unsafe { CanvasText { this: tsCanvasText_new_CcS(canvas.this, text.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasText { unsafe { CanvasText { this: ptr, owner: tsCanvasText_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasText { unsafe { CanvasText { this: tsCanvasText_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasText { unsafe { CanvasText::new_ptr(tsCanvasText_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasText_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasText) -> bool { unsafe { tsCanvasText_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasText { unsafe { CanvasText { this: tsCanvasText_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasText_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasText_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasText_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasText_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasText_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasText_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasText_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasText_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasText_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvasText_setFontName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsCanvasText_setFontName_cS(self.this, name.this) } }
	pub fn font_name(&self) -> string::String { unsafe { get_string(tsCanvasText_getFontName(self.this)) } }
	pub fn set_font_color(&mut self, color: &Color) { unsafe { tsCanvasText_setFontColor(self.this, color) } }
	pub fn font_color(&self) -> Color { unsafe { tsCanvasText_getFontColor(self.this) } }
	pub fn set_font_size(&mut self, scale: u32) -> bool { unsafe { tsCanvasText_setFontSize(self.this, scale) != 0 } }
	pub fn font_size(&self) -> u32 { unsafe { tsCanvasText_getFontSize(self.this) } }
	pub fn set_font_scale(&mut self, scale: u32) -> bool { unsafe { tsCanvasText_setFontScale(self.this, scale) != 0 } }
	pub fn font_scale(&self) -> u32 { unsafe { tsCanvasText_getFontScale(self.this) } }
	pub fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsCanvasText_setFontStyle(self.this, style) != 0 } }
	pub fn font_style_const(&self) -> FontStyle { unsafe { tsCanvasText_getFontStyleConst(self.this) } }
	pub fn font_style(&self) -> FontStyle { unsafe { tsCanvasText_getFontStyle_c(self.this) } }
	pub fn font_style_mut(&mut self) -> FontStyle { unsafe { tsCanvasText_getFontStyle(self.this) } }
	pub fn set_position(&mut self, position: &Vector3f) { unsafe { tsCanvasText_setPosition_cV3(self.this, position) } }
	pub fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasText_setPosition_fff(self.this, x, y, 0.0) } }
	pub fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasText_setPosition_fff(self.this, x, y, z) } }
	pub fn position(&self) -> Vector3f { unsafe { tsCanvasText_getPosition(self.this) } }
	pub fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsCanvasText_setText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_text_with_text(&mut self, text: &String) { unsafe { tsCanvasText_setText_cS(self.this, text.this) } }
	pub fn text(&self) -> string::String { unsafe { get_string(tsCanvasText_getText(self.this)) } }
	pub fn clear_batches(&mut self) { unsafe { tsCanvasText_clearBatches(self.this) } }
}
impl CanvasElementTrait for CanvasText {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasText {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasText_delete(self.this) } } }
}
impl Clone for CanvasText {
	fn clone(&self) -> CanvasText { unsafe { CanvasText { this: tsCanvasText_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasText { }
impl fmt::Display for CanvasText {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasText ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasText_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasText_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasText_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasText_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasText_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasText_new() -> *mut c_void;
	fn tsCanvasText_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasText_new_Cs(canvas: *mut c_void, text: *const c_char) -> *mut c_void;
	fn tsCanvasText_new_CcS(canvas: *mut c_void, text: *mut c_void) -> *mut c_void;
	fn tsCanvasText_delete(this: *mut c_void);
	fn tsCanvasText_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasText_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_clearPtr(this: *const c_void);
	fn tsCanvasText_destroyPtr(this: *const c_void);
	fn tsCanvasText_acquirePtr(this: *const c_void);
	fn tsCanvasText_unacquirePtr(this: *const c_void);
	fn tsCanvasText_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasText_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasText_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasText_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasText_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasText_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_setFontName_s(this: *mut c_void, name: *const c_char);
	fn tsCanvasText_setFontName_cS(this: *mut c_void, name: *mut c_void);
	fn tsCanvasText_getFontName(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_setFontColor(this: *mut c_void, color: *const Color);
	fn tsCanvasText_getFontColor(this: *const c_void) -> Color;
	fn tsCanvasText_setFontSize(this: *mut c_void, scale: u32) -> i32;
	fn tsCanvasText_getFontSize(this: *const c_void) -> u32;
	fn tsCanvasText_setFontScale(this: *mut c_void, scale: u32) -> i32;
	fn tsCanvasText_getFontScale(this: *const c_void) -> u32;
	fn tsCanvasText_setFontStyle(this: *mut c_void, style: *const FontStyle) -> i32;
	fn tsCanvasText_getFontStyleConst(this: *const c_void) -> FontStyle;
	fn tsCanvasText_getFontStyle_c(this: *const c_void) -> FontStyle;
	fn tsCanvasText_getFontStyle(this: *mut c_void) -> FontStyle;
	fn tsCanvasText_setPosition_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasText_setPosition_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasText_getPosition(this: *const c_void) -> Vector3f;
	fn tsCanvasText_setText_s(this: *mut c_void, text: *const c_char);
	fn tsCanvasText_setText_cS(this: *mut c_void, text: *mut c_void);
	fn tsCanvasText_getText(this: *const c_void) -> *mut c_void;
	fn tsCanvasText_clearBatches(this: *mut c_void);
}

// Tellusim::CanvasMesh
pub struct CanvasMesh {
	this: *mut c_void,
	owner: bool,
}
impl CanvasMesh {
	pub fn null() -> CanvasMesh { CanvasMesh { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasMesh { unsafe { CanvasMesh { this: tsCanvasMesh_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasMesh { unsafe { CanvasMesh { this: tsCanvasMesh_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_mode(canvas: &mut Canvas, mode: CanvasElementMode) -> CanvasMesh { unsafe { CanvasMesh { this: tsCanvasMesh_new_CCEM(canvas.this, mode), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasMesh { unsafe { CanvasMesh { this: ptr, owner: tsCanvasMesh_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasMesh { unsafe { CanvasMesh { this: tsCanvasMesh_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsCanvasMesh_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasMesh_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasMesh) -> bool { unsafe { tsCanvasMesh_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasMesh { unsafe { CanvasMesh { this: tsCanvasMesh_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasMesh_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasMesh_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasMesh_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasMesh_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasMesh_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasMesh_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasMesh_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasMesh_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasMesh_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvasMesh_setTextureName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsCanvasMesh_setTextureName_cS(self.this, name.this) } }
	pub fn texture_name(&self) -> string::String { unsafe { get_string(tsCanvasMesh_getTextureName(self.this)) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsCanvasMesh_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsCanvasMesh_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsCanvasMesh_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsCanvasMesh_getGradientStyle(self.this) } }
	pub fn clear_vertices(&mut self) { unsafe { tsCanvasMesh_clearVertices(self.this) } }
	pub fn set_num_vertices(&mut self, num_vertices: u32) { unsafe { tsCanvasMesh_setNumVertices(self.this, num_vertices) } }
	pub fn reserve_vertices(&mut self, num_vertices: u32) { unsafe { tsCanvasMesh_reserveVertices(self.this, num_vertices) } }
	pub fn num_vertices(&self) -> u32 { unsafe { tsCanvasMesh_getNumVertices(self.this) } }
	pub fn set_vertices(&mut self, vertices: &[CanvasVertex]) { unsafe { tsCanvasMesh_setVertices(self.this, vertices.as_ptr(), vertices.len() as u32) } }
	pub fn add_vertices(&mut self, vertices: &[CanvasVertex]) { unsafe { tsCanvasMesh_addVertices(self.this, vertices.as_ptr(), vertices.len() as u32) } }
	pub fn vertices(&self) -> *const CanvasVertex { unsafe { tsCanvasMesh_getVertices_c(self.this) } }
	pub fn vertices_mut(&mut self) -> *mut CanvasVertex { unsafe { tsCanvasMesh_getVertices(self.this) } }
	pub fn set_vertex(&mut self, index: u32, vertex: &CanvasVertex) { unsafe { tsCanvasMesh_setVertex(self.this, index, vertex) } }
	pub fn vertex(&self, index: u32) -> CanvasVertex { unsafe { tsCanvasMesh_getVertex_cu(self.this, index) } }
	pub fn vertex_mut(&mut self, index: u32) -> CanvasVertex { unsafe { tsCanvasMesh_getVertex_u(self.this, index) } }
	pub fn set_vertex_position(&mut self, index: u32, position: &Vector3f) { unsafe { tsCanvasMesh_setVertexPosition_ucV3(self.this, index, position) } }
	pub fn set_vertex_position_with_xy(&mut self, index: u32, x: f32, y: f32) { unsafe { tsCanvasMesh_setVertexPosition_ufff(self.this, index, x, y, 0.0) } }
	pub fn set_vertex_position_with_xyz(&mut self, index: u32, x: f32, y: f32, z: f32) { unsafe { tsCanvasMesh_setVertexPosition_ufff(self.this, index, x, y, z) } }
	pub fn vertex_position(&self, index: u32) -> Vector3f { unsafe { tsCanvasMesh_getVertexPosition(self.this, index) } }
	pub fn set_vertex_tex_coord(&mut self, index: u32, texcoord: &Vector2f) { unsafe { tsCanvasMesh_setVertexTexCoord_ucV2(self.this, index, texcoord) } }
	pub fn set_vertex_tex_coord_with_s(&mut self, index: u32, s: f32, t: f32) { unsafe { tsCanvasMesh_setVertexTexCoord_uff(self.this, index, s, t) } }
	pub fn vertex_tex_coord(&self, index: u32) -> Vector2f { unsafe { tsCanvasMesh_getVertexTexCoord(self.this, index) } }
	pub fn set_vertex_color(&mut self, index: u32, color: &Color) { unsafe { tsCanvasMesh_setVertexColor_ucC(self.this, index, color) } }
	pub fn set_vertex_color_with_color(&mut self, index: u32, color: u32) { unsafe { tsCanvasMesh_setVertexColor_uu(self.this, index, color) } }
	pub fn vertex_color(&self, index: u32) -> u32 { unsafe { tsCanvasMesh_getVertexColor(self.this, index) } }
	pub fn add_vertex_with_position(&mut self, position: &Vector3f) -> u32 { unsafe { tsCanvasMesh_addVertex_cV3(self.this, position) } }
	pub fn add_vertex_with_position_color(&mut self, position: &Vector3f, color: u32) -> u32 { unsafe { tsCanvasMesh_addVertex_cV3u(self.this, position, color) } }
	pub fn add_vertex_with_position_texcoord(&mut self, position: &Vector3f, texcoord: &Vector2f) -> u32 { unsafe { tsCanvasMesh_addVertex_cV3cV2(self.this, position, texcoord) } }
	pub fn add_vertex_with_position_texcoord_color(&mut self, position: &Vector3f, texcoord: &Vector2f, color: u32) -> u32 { unsafe { tsCanvasMesh_addVertex_cV3cV2u(self.this, position, texcoord, color) } }
	pub fn add_vertex_with_xyz_st(&mut self, x: f32, y: f32, z: f32, s: f32, t: f32) -> u32 { unsafe { tsCanvasMesh_addVertex_fffffu(self.this, x, y, z, s, t, 0xffffffff) } }
	pub fn add_vertex_with_xyz_st_color(&mut self, x: f32, y: f32, z: f32, s: f32, t: f32, color: u32) -> u32 { unsafe { tsCanvasMesh_addVertex_fffffu(self.this, x, y, z, s, t, color) } }
	pub fn add_vertex_with_xyz(&mut self, x: f32, y: f32, z: f32) -> u32 { unsafe { tsCanvasMesh_addVertex_fffu(self.this, x, y, z, 0xffffffff) } }
	pub fn add_vertex_with_xyz_color(&mut self, x: f32, y: f32, z: f32, color: u32) -> u32 { unsafe { tsCanvasMesh_addVertex_fffu(self.this, x, y, z, color) } }
	pub fn add_vertex_with_xy_color(&mut self, x: f32, y: f32, color: u32) -> u32 { unsafe { tsCanvasMesh_addVertex_ffu(self.this, x, y, color) } }
	pub fn clear_indices(&mut self) { unsafe { tsCanvasMesh_clearIndices(self.this) } }
	pub fn set_num_indices(&mut self, num_indices: u32) { unsafe { tsCanvasMesh_setNumIndices(self.this, num_indices) } }
	pub fn reserve_indices(&mut self, num_indices: u32) { unsafe { tsCanvasMesh_reserveIndices(self.this, num_indices) } }
	pub fn num_indices(&self) -> u32 { unsafe { tsCanvasMesh_getNumIndices(self.this) } }
	pub fn set_indices(&mut self, indices: *const u32, num_indices: u32) { unsafe { tsCanvasMesh_setIndices(self.this, indices, num_indices) } }
	pub fn add_indices_with_indices(&mut self, indices: *const u32, num_indices: u32) { unsafe { tsCanvasMesh_addIndices_upu(self.this, indices, num_indices) } }
	pub fn indices(&self) -> *const u32 { unsafe { tsCanvasMesh_getIndices_c(self.this) } }
	pub fn indices_mut(&mut self) -> *mut u32 { unsafe { tsCanvasMesh_getIndices(self.this) } }
	pub fn set_index(&mut self, index: u32, value: u32) { unsafe { tsCanvasMesh_setIndex(self.this, index, value) } }
	pub fn index(&self, index: u32) -> u32 { unsafe { tsCanvasMesh_getIndex(self.this, index) } }
	pub fn add_index(&mut self, i0: u32) { unsafe { tsCanvasMesh_addIndex(self.this, i0) } }
	pub fn add_indices2(&mut self, i0: u32, i1: u32) { unsafe { tsCanvasMesh_addIndices_uu(self.this, i0, i1) } }
	pub fn add_indices3(&mut self, i0: u32, i1: u32, i2: u32) { unsafe { tsCanvasMesh_addIndices_uuu(self.this, i0, i1, i2) } }
	pub fn add_indices4(&mut self, i0: u32, i1: u32, i2: u32, i3: u32) { unsafe { tsCanvasMesh_addIndices_uuuu(self.this, i0, i1, i2, i3) } }
	pub fn set_rect(&mut self, rect: &Rect) { unsafe { tsCanvasMesh_setRect(self.this, rect) } }
}
impl CanvasElementTrait for CanvasMesh {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasMesh {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasMesh_delete(self.this) } } }
}
impl Clone for CanvasMesh {
	fn clone(&self) -> CanvasMesh { unsafe { CanvasMesh { this: tsCanvasMesh_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasMesh { }
impl fmt::Display for CanvasMesh {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasMesh ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasMesh_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasMesh_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasMesh_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasMesh_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasMesh_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasMesh_new() -> *mut c_void;
	fn tsCanvasMesh_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasMesh_new_CCEM(canvas: *mut c_void, mode: CanvasElementMode) -> *mut c_void;
	fn tsCanvasMesh_delete(this: *mut c_void);
	fn tsCanvasMesh_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasMesh_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasMesh_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasMesh_clearPtr(this: *const c_void);
	fn tsCanvasMesh_destroyPtr(this: *const c_void);
	fn tsCanvasMesh_acquirePtr(this: *const c_void);
	fn tsCanvasMesh_unacquirePtr(this: *const c_void);
	fn tsCanvasMesh_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasMesh_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasMesh_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasMesh_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasMesh_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasMesh_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasMesh_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasMesh_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasMesh_setTextureName_s(this: *mut c_void, name: *const c_char);
	fn tsCanvasMesh_setTextureName_cS(this: *mut c_void, name: *mut c_void);
	fn tsCanvasMesh_getTextureName(this: *const c_void) -> *mut c_void;
	fn tsCanvasMesh_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsCanvasMesh_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsCanvasMesh_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsCanvasMesh_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsCanvasMesh_clearVertices(this: *mut c_void);
	fn tsCanvasMesh_setNumVertices(this: *mut c_void, num_vertices: u32);
	fn tsCanvasMesh_reserveVertices(this: *mut c_void, num_vertices: u32);
	fn tsCanvasMesh_getNumVertices(this: *const c_void) -> u32;
	fn tsCanvasMesh_setVertices(this: *mut c_void, vertices: *const CanvasVertex, num_vertices: u32);
	fn tsCanvasMesh_addVertices(this: *mut c_void, vertices: *const CanvasVertex, num_vertices: u32);
	fn tsCanvasMesh_getVertices_c(this: *const c_void) -> *const CanvasVertex;
	fn tsCanvasMesh_getVertices(this: *mut c_void) -> *mut CanvasVertex;
	fn tsCanvasMesh_setVertex(this: *mut c_void, index: u32, vertex: *const CanvasVertex);
	fn tsCanvasMesh_getVertex_cu(this: *const c_void, index: u32) -> CanvasVertex;
	fn tsCanvasMesh_getVertex_u(this: *mut c_void, index: u32) -> CanvasVertex;
	fn tsCanvasMesh_setVertexPosition_ucV3(this: *mut c_void, index: u32, position: *const Vector3f);
	fn tsCanvasMesh_setVertexPosition_ufff(this: *mut c_void, index: u32, x: f32, y: f32, z: f32);
	fn tsCanvasMesh_getVertexPosition(this: *const c_void, index: u32) -> Vector3f;
	fn tsCanvasMesh_setVertexTexCoord_ucV2(this: *mut c_void, index: u32, texcoord: *const Vector2f);
	fn tsCanvasMesh_setVertexTexCoord_uff(this: *mut c_void, index: u32, s: f32, t: f32);
	fn tsCanvasMesh_getVertexTexCoord(this: *const c_void, index: u32) -> Vector2f;
	fn tsCanvasMesh_setVertexColor_ucC(this: *mut c_void, index: u32, color: *const Color);
	fn tsCanvasMesh_setVertexColor_uu(this: *mut c_void, index: u32, color: u32);
	fn tsCanvasMesh_getVertexColor(this: *const c_void, index: u32) -> u32;
	fn tsCanvasMesh_addVertex_cV3(this: *mut c_void, position: *const Vector3f) -> u32;
	fn tsCanvasMesh_addVertex_cV3u(this: *mut c_void, position: *const Vector3f, color: u32) -> u32;
	fn tsCanvasMesh_addVertex_cV3cV2(this: *mut c_void, position: *const Vector3f, texcoord: *const Vector2f) -> u32;
	fn tsCanvasMesh_addVertex_cV3cV2u(this: *mut c_void, position: *const Vector3f, texcoord: *const Vector2f, color: u32) -> u32;
	fn tsCanvasMesh_addVertex_fffffu(this: *mut c_void, x: f32, y: f32, z: f32, s: f32, t: f32, color: u32) -> u32;
	fn tsCanvasMesh_addVertex_fffu(this: *mut c_void, x: f32, y: f32, z: f32, color: u32) -> u32;
	fn tsCanvasMesh_addVertex_ffu(this: *mut c_void, x: f32, y: f32, color: u32) -> u32;
	fn tsCanvasMesh_clearIndices(this: *mut c_void);
	fn tsCanvasMesh_setNumIndices(this: *mut c_void, num_indices: u32);
	fn tsCanvasMesh_reserveIndices(this: *mut c_void, num_indices: u32);
	fn tsCanvasMesh_getNumIndices(this: *const c_void) -> u32;
	fn tsCanvasMesh_setIndices(this: *mut c_void, indices: *const u32, num_indices: u32);
	fn tsCanvasMesh_addIndices_upu(this: *mut c_void, indices: *const u32, num_indices: u32);
	fn tsCanvasMesh_getIndices_c(this: *const c_void) -> *const u32;
	fn tsCanvasMesh_getIndices(this: *mut c_void) -> *mut u32;
	fn tsCanvasMesh_setIndex(this: *mut c_void, index: u32, value: u32);
	fn tsCanvasMesh_getIndex(this: *const c_void, index: u32) -> u32;
	fn tsCanvasMesh_addIndex(this: *mut c_void, i0: u32);
	fn tsCanvasMesh_addIndices_uu(this: *mut c_void, i0: u32, i1: u32);
	fn tsCanvasMesh_addIndices_uuu(this: *mut c_void, i0: u32, i1: u32, i2: u32);
	fn tsCanvasMesh_addIndices_uuuu(this: *mut c_void, i0: u32, i1: u32, i2: u32, i3: u32);
	fn tsCanvasMesh_setRect(this: *mut c_void, rect: *const Rect);
}

// Tellusim::CanvasRect
pub struct CanvasRect {
	this: *mut c_void,
	owner: bool,
}
impl CanvasRect {
	pub fn null() -> CanvasRect { CanvasRect { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_radius(canvas: &mut Canvas, radius: f32) -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_new_Cf(canvas.this, radius), owner: true } } }
	pub fn new_with_canvas_radius_size(canvas: &mut Canvas, radius: f32, size: &Vector2f) -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_new_CfcV2(canvas.this, radius, size), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasRect { unsafe { CanvasRect { this: ptr, owner: tsCanvasRect_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsCanvasRect_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasRect_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasRect) -> bool { unsafe { tsCanvasRect_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasRect_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasRect_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasRect_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasRect_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasRect_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasRect_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasRect_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasRect_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasRect_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_radius(&mut self, radius: f32) { unsafe { tsCanvasRect_setRadius(self.this, radius) } }
	pub fn radius(&self) -> f32 { unsafe { tsCanvasRect_getRadius(self.this) } }
	pub fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvasRect_setTextureName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsCanvasRect_setTextureName_cS(self.this, name.this) } }
	pub fn texture_name(&self) -> string::String { unsafe { get_string(tsCanvasRect_getTextureName(self.this)) } }
	pub fn set_stroke_color(&mut self, color: &Color) { unsafe { tsCanvasRect_setStrokeColor(self.this, color) } }
	pub fn stroke_color(&mut self) -> Color { unsafe { tsCanvasRect_getStrokeColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsCanvasRect_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsCanvasRect_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsCanvasRect_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsCanvasRect_getStrokeStyle(self.this) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsCanvasRect_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsCanvasRect_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsCanvasRect_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsCanvasRect_getGradientStyle(self.this) } }
	pub fn set_size(&mut self, size: &Vector2f) { unsafe { tsCanvasRect_setSize_cV2(self.this, size) } }
	pub fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsCanvasRect_setSize_ff(self.this, width, height) } }
	pub fn size(&self) -> Vector2f { unsafe { tsCanvasRect_getSize(self.this) } }
	pub fn width(&self) -> f32 { unsafe { tsCanvasRect_getWidth(self.this) } }
	pub fn height(&self) -> f32 { unsafe { tsCanvasRect_getHeight(self.this) } }
	pub fn set_position(&mut self, position: &Vector3f) { unsafe { tsCanvasRect_setPosition_cV3(self.this, position) } }
	pub fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasRect_setPosition_fff(self.this, x, y, 0.0) } }
	pub fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasRect_setPosition_fff(self.this, x, y, z) } }
	pub fn position(&self) -> Vector3f { unsafe { tsCanvasRect_getPosition(self.this) } }
	pub fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsCanvasRect_setTexCoord_cR(self.this, texcoord) } }
	pub fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsCanvasRect_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	pub fn tex_coord(&self) -> Rect { unsafe { tsCanvasRect_getTexCoord(self.this) } }
}
impl CanvasElementTrait for CanvasRect {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasRect {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasRect_delete(self.this) } } }
}
impl Clone for CanvasRect {
	fn clone(&self) -> CanvasRect { unsafe { CanvasRect { this: tsCanvasRect_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasRect { }
impl fmt::Display for CanvasRect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasRect ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasRect_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasRect_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasRect_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasRect_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasRect_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasRect_new() -> *mut c_void;
	fn tsCanvasRect_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasRect_new_Cf(canvas: *mut c_void, radius: f32) -> *mut c_void;
	fn tsCanvasRect_new_CfcV2(canvas: *mut c_void, radius: f32, size: *const Vector2f) -> *mut c_void;
	fn tsCanvasRect_delete(this: *mut c_void);
	fn tsCanvasRect_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasRect_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasRect_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasRect_clearPtr(this: *const c_void);
	fn tsCanvasRect_destroyPtr(this: *const c_void);
	fn tsCanvasRect_acquirePtr(this: *const c_void);
	fn tsCanvasRect_unacquirePtr(this: *const c_void);
	fn tsCanvasRect_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasRect_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasRect_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasRect_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasRect_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasRect_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasRect_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasRect_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasRect_setRadius(this: *mut c_void, radius: f32);
	fn tsCanvasRect_getRadius(this: *const c_void) -> f32;
	fn tsCanvasRect_setTextureName_s(this: *mut c_void, name: *const c_char);
	fn tsCanvasRect_setTextureName_cS(this: *mut c_void, name: *mut c_void);
	fn tsCanvasRect_getTextureName(this: *const c_void) -> *mut c_void;
	fn tsCanvasRect_setStrokeColor(this: *mut c_void, color: *const Color);
	fn tsCanvasRect_getStrokeColor(this: *mut c_void) -> Color;
	fn tsCanvasRect_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsCanvasRect_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsCanvasRect_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsCanvasRect_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsCanvasRect_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsCanvasRect_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsCanvasRect_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsCanvasRect_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsCanvasRect_setSize_cV2(this: *mut c_void, size: *const Vector2f);
	fn tsCanvasRect_setSize_ff(this: *mut c_void, width: f32, height: f32);
	fn tsCanvasRect_getSize(this: *const c_void) -> Vector2f;
	fn tsCanvasRect_getWidth(this: *const c_void) -> f32;
	fn tsCanvasRect_getHeight(this: *const c_void) -> f32;
	fn tsCanvasRect_setPosition_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasRect_setPosition_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasRect_getPosition(this: *const c_void) -> Vector3f;
	fn tsCanvasRect_setTexCoord_cR(this: *mut c_void, texcoord: *const Rect);
	fn tsCanvasRect_setTexCoord_ffff(this: *mut c_void, left: f32, right: f32, bottom: f32, top: f32);
	fn tsCanvasRect_getTexCoord(this: *const c_void) -> Rect;
}

// Tellusim::CanvasTriangle
pub struct CanvasTriangle {
	this: *mut c_void,
	owner: bool,
}
impl CanvasTriangle {
	pub fn null() -> CanvasTriangle { CanvasTriangle { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasTriangle { unsafe { CanvasTriangle { this: tsCanvasTriangle_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasTriangle { unsafe { CanvasTriangle { this: tsCanvasTriangle_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_radius(canvas: &mut Canvas, radius: f32) -> CanvasTriangle { unsafe { CanvasTriangle { this: tsCanvasTriangle_new_Cf(canvas.this, radius), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasTriangle { unsafe { CanvasTriangle { this: ptr, owner: tsCanvasTriangle_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasTriangle { unsafe { CanvasTriangle { this: tsCanvasTriangle_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasTriangle { unsafe { CanvasTriangle::new_ptr(tsCanvasTriangle_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasTriangle_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasTriangle) -> bool { unsafe { tsCanvasTriangle_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasTriangle { unsafe { CanvasTriangle { this: tsCanvasTriangle_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasTriangle_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasTriangle_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasTriangle_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasTriangle_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasTriangle_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasTriangle_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasTriangle_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasTriangle_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasTriangle_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_radius(&mut self, radius: f32) { unsafe { tsCanvasTriangle_setRadius(self.this, radius) } }
	pub fn radius(&self) -> f32 { unsafe { tsCanvasTriangle_getRadius(self.this) } }
	pub fn set_stroke_color(&mut self, color: &Color) { unsafe { tsCanvasTriangle_setStrokeColor(self.this, color) } }
	pub fn stroke_color(&self) -> Color { unsafe { tsCanvasTriangle_getStrokeColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsCanvasTriangle_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsCanvasTriangle_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsCanvasTriangle_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsCanvasTriangle_getStrokeStyle(self.this) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsCanvasTriangle_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsCanvasTriangle_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsCanvasTriangle_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsCanvasTriangle_getGradientStyle(self.this) } }
	pub fn set_position0(&mut self, position: &Vector3f) { unsafe { tsCanvasTriangle_setPosition0_cV3(self.this, position) } }
	pub fn set_position1(&mut self, position: &Vector3f) { unsafe { tsCanvasTriangle_setPosition1_cV3(self.this, position) } }
	pub fn set_position2(&mut self, position: &Vector3f) { unsafe { tsCanvasTriangle_setPosition2_cV3(self.this, position) } }
	pub fn set_position0_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasTriangle_setPosition0_fff(self.this, x, y, 0.0) } }
	pub fn set_position0_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasTriangle_setPosition0_fff(self.this, x, y, z) } }
	pub fn set_position1_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasTriangle_setPosition1_fff(self.this, x, y, 0.0) } }
	pub fn set_position1_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasTriangle_setPosition1_fff(self.this, x, y, z) } }
	pub fn set_position2_with_x(&mut self, x: f32, y: f32) { unsafe { tsCanvasTriangle_setPosition2_fff(self.this, x, y, 0.0) } }
	pub fn set_position2_with_x_z(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasTriangle_setPosition2_fff(self.this, x, y, z) } }
	pub fn set_position(&mut self, position_0: &Vector3f, position_1: &Vector3f, position_2: &Vector3f) { unsafe { tsCanvasTriangle_setPosition(self.this, position_0, position_1, position_2) } }
	pub fn position0(&self) -> Vector3f { unsafe { tsCanvasTriangle_getPosition0(self.this) } }
	pub fn position1(&self) -> Vector3f { unsafe { tsCanvasTriangle_getPosition1(self.this) } }
	pub fn position2(&self) -> Vector3f { unsafe { tsCanvasTriangle_getPosition2(self.this) } }
}
impl CanvasElementTrait for CanvasTriangle {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasTriangle {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasTriangle_delete(self.this) } } }
}
impl Clone for CanvasTriangle {
	fn clone(&self) -> CanvasTriangle { unsafe { CanvasTriangle { this: tsCanvasTriangle_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasTriangle { }
impl fmt::Display for CanvasTriangle {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasTriangle ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasTriangle_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasTriangle_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasTriangle_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasTriangle_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasTriangle_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasTriangle_new() -> *mut c_void;
	fn tsCanvasTriangle_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasTriangle_new_Cf(canvas: *mut c_void, radius: f32) -> *mut c_void;
	fn tsCanvasTriangle_delete(this: *mut c_void);
	fn tsCanvasTriangle_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasTriangle_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasTriangle_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasTriangle_clearPtr(this: *const c_void);
	fn tsCanvasTriangle_destroyPtr(this: *const c_void);
	fn tsCanvasTriangle_acquirePtr(this: *const c_void);
	fn tsCanvasTriangle_unacquirePtr(this: *const c_void);
	fn tsCanvasTriangle_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasTriangle_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasTriangle_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasTriangle_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasTriangle_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasTriangle_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasTriangle_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasTriangle_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasTriangle_setRadius(this: *mut c_void, radius: f32);
	fn tsCanvasTriangle_getRadius(this: *const c_void) -> f32;
	fn tsCanvasTriangle_setStrokeColor(this: *mut c_void, color: *const Color);
	fn tsCanvasTriangle_getStrokeColor(this: *const c_void) -> Color;
	fn tsCanvasTriangle_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsCanvasTriangle_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsCanvasTriangle_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsCanvasTriangle_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsCanvasTriangle_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsCanvasTriangle_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsCanvasTriangle_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsCanvasTriangle_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsCanvasTriangle_setPosition0_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasTriangle_setPosition1_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasTriangle_setPosition2_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasTriangle_setPosition0_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasTriangle_setPosition1_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasTriangle_setPosition2_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasTriangle_setPosition(this: *mut c_void, position_0: *const Vector3f, position_1: *const Vector3f, position_2: *const Vector3f);
	fn tsCanvasTriangle_getPosition0(this: *const c_void) -> Vector3f;
	fn tsCanvasTriangle_getPosition1(this: *const c_void) -> Vector3f;
	fn tsCanvasTriangle_getPosition2(this: *const c_void) -> Vector3f;
}

// Tellusim::CanvasEllipse
pub struct CanvasEllipse {
	this: *mut c_void,
	owner: bool,
}
impl CanvasEllipse {
	pub fn null() -> CanvasEllipse { CanvasEllipse { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasEllipse { unsafe { CanvasEllipse { this: tsCanvasEllipse_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasEllipse { unsafe { CanvasEllipse { this: tsCanvasEllipse_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_radius(canvas: &mut Canvas, radius: f32) -> CanvasEllipse { unsafe { CanvasEllipse { this: tsCanvasEllipse_new_Cf(canvas.this, radius), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasEllipse { unsafe { CanvasEllipse { this: ptr, owner: tsCanvasEllipse_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasEllipse { unsafe { CanvasEllipse { this: tsCanvasEllipse_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasEllipse { unsafe { CanvasEllipse::new_ptr(tsCanvasEllipse_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasEllipse_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasEllipse) -> bool { unsafe { tsCanvasEllipse_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasEllipse { unsafe { CanvasEllipse { this: tsCanvasEllipse_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasEllipse_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasEllipse_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasEllipse_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasEllipse_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasEllipse_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasEllipse_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasEllipse_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasEllipse_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasEllipse_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_radius(&mut self, radius: f32) { unsafe { tsCanvasEllipse_setRadius(self.this, radius) } }
	pub fn radius(&self) -> f32 { unsafe { tsCanvasEllipse_getRadius(self.this) } }
	pub fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvasEllipse_setTextureName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsCanvasEllipse_setTextureName_cS(self.this, name.this) } }
	pub fn texture_name(&self) -> string::String { unsafe { get_string(tsCanvasEllipse_getTextureName(self.this)) } }
	pub fn set_stroke_color(&mut self, color: &Color) { unsafe { tsCanvasEllipse_setStrokeColor(self.this, color) } }
	pub fn stroke_color(&self) -> Color { unsafe { tsCanvasEllipse_getStrokeColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsCanvasEllipse_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsCanvasEllipse_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsCanvasEllipse_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsCanvasEllipse_getStrokeStyle(self.this) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsCanvasEllipse_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsCanvasEllipse_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsCanvasEllipse_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsCanvasEllipse_getGradientStyle(self.this) } }
	pub fn set_position(&mut self, position: &Vector3f) { unsafe { tsCanvasEllipse_setPosition_cV3(self.this, position) } }
	pub fn set_position0(&mut self, position: &Vector3f) { unsafe { tsCanvasEllipse_setPosition0_cV3(self.this, position) } }
	pub fn set_position1(&mut self, position: &Vector3f) { unsafe { tsCanvasEllipse_setPosition1_cV3(self.this, position) } }
	pub fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasEllipse_setPosition_fff(self.this, x, y, 0.0) } }
	pub fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasEllipse_setPosition_fff(self.this, x, y, z) } }
	pub fn set_position0_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasEllipse_setPosition0_fff(self.this, x, y, 0.0) } }
	pub fn set_position0_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasEllipse_setPosition0_fff(self.this, x, y, z) } }
	pub fn set_position1_with_xy(&mut self, x: f32, y: f32) { unsafe { tsCanvasEllipse_setPosition1_fff(self.this, x, y, 0.0) } }
	pub fn set_position1_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsCanvasEllipse_setPosition1_fff(self.this, x, y, z) } }
	pub fn set_position_with_position0(&mut self, position_0: &Vector3f, position_1: &Vector3f) { unsafe { tsCanvasEllipse_setPosition_cV3cV3(self.this, position_0, position_1) } }
	pub fn position0(&self) -> Vector3f { unsafe { tsCanvasEllipse_getPosition0(self.this) } }
	pub fn position1(&self) -> Vector3f { unsafe { tsCanvasEllipse_getPosition1(self.this) } }
	pub fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsCanvasEllipse_setTexCoord_cR(self.this, texcoord) } }
	pub fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsCanvasEllipse_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	pub fn tex_coord(&self) -> Rect { unsafe { tsCanvasEllipse_getTexCoord(self.this) } }
}
impl CanvasElementTrait for CanvasEllipse {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasEllipse {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasEllipse_delete(self.this) } } }
}
impl Clone for CanvasEllipse {
	fn clone(&self) -> CanvasEllipse { unsafe { CanvasEllipse { this: tsCanvasEllipse_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasEllipse { }
impl fmt::Display for CanvasEllipse {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasEllipse ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasEllipse_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasEllipse_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasEllipse_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasEllipse_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasEllipse_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasEllipse_new() -> *mut c_void;
	fn tsCanvasEllipse_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasEllipse_new_Cf(canvas: *mut c_void, radius: f32) -> *mut c_void;
	fn tsCanvasEllipse_delete(this: *mut c_void);
	fn tsCanvasEllipse_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasEllipse_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasEllipse_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasEllipse_clearPtr(this: *const c_void);
	fn tsCanvasEllipse_destroyPtr(this: *const c_void);
	fn tsCanvasEllipse_acquirePtr(this: *const c_void);
	fn tsCanvasEllipse_unacquirePtr(this: *const c_void);
	fn tsCanvasEllipse_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasEllipse_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasEllipse_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasEllipse_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasEllipse_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasEllipse_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasEllipse_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasEllipse_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasEllipse_setRadius(this: *mut c_void, radius: f32);
	fn tsCanvasEllipse_getRadius(this: *const c_void) -> f32;
	fn tsCanvasEllipse_setTextureName_s(this: *mut c_void, name: *const c_char);
	fn tsCanvasEllipse_setTextureName_cS(this: *mut c_void, name: *mut c_void);
	fn tsCanvasEllipse_getTextureName(this: *const c_void) -> *mut c_void;
	fn tsCanvasEllipse_setStrokeColor(this: *mut c_void, color: *const Color);
	fn tsCanvasEllipse_getStrokeColor(this: *const c_void) -> Color;
	fn tsCanvasEllipse_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsCanvasEllipse_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsCanvasEllipse_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsCanvasEllipse_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsCanvasEllipse_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsCanvasEllipse_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsCanvasEllipse_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsCanvasEllipse_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsCanvasEllipse_setPosition_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasEllipse_setPosition0_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasEllipse_setPosition1_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsCanvasEllipse_setPosition_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasEllipse_setPosition0_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasEllipse_setPosition1_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsCanvasEllipse_setPosition_cV3cV3(this: *mut c_void, position_0: *const Vector3f, position_1: *const Vector3f);
	fn tsCanvasEllipse_getPosition0(this: *const c_void) -> Vector3f;
	fn tsCanvasEllipse_getPosition1(this: *const c_void) -> Vector3f;
	fn tsCanvasEllipse_setTexCoord_cR(this: *mut c_void, texcoord: *const Rect);
	fn tsCanvasEllipse_setTexCoord_ffff(this: *mut c_void, left: f32, right: f32, bottom: f32, top: f32);
	fn tsCanvasEllipse_getTexCoord(this: *const c_void) -> Rect;
}

// Tellusim::CanvasShape
pub struct CanvasShape {
	this: *mut c_void,
	owner: bool,
}
impl CanvasShape {
	pub fn null() -> CanvasShape { CanvasShape { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasShape { unsafe { CanvasShape { this: tsCanvasShape_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasShape { unsafe { CanvasShape { this: tsCanvasShape_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_cubic(canvas: &mut Canvas, cubic: bool) -> CanvasShape { unsafe { CanvasShape { this: tsCanvasShape_new_Cb(canvas.this, if cubic {1} else {0}), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasShape { unsafe { CanvasShape { this: ptr, owner: tsCanvasShape_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasShape { unsafe { CanvasShape { this: tsCanvasShape_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasShape { unsafe { CanvasShape::new_ptr(tsCanvasShape_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasShape_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasShape) -> bool { unsafe { tsCanvasShape_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasShape { unsafe { CanvasShape { this: tsCanvasShape_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasShape_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasShape_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasShape_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasShape_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasShape_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasShape_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasShape_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasShape_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasShape_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_cubic(&mut self, cubic: bool) { unsafe { tsCanvasShape_setCubic(self.this, if cubic {1} else {0}) } }
	pub fn is_cubic(&self) -> bool { unsafe { tsCanvasShape_isCubic(self.this) != 0 } }
	pub fn set_threshold(&mut self, threshold: f32) { unsafe { tsCanvasShape_setThreshold(self.this, threshold) } }
	pub fn threshold(&self) -> f32 { unsafe { tsCanvasShape_getThreshold(self.this) } }
	pub fn set_stroke_color(&mut self, color: &Color) { unsafe { tsCanvasShape_setStrokeColor(self.this, color) } }
	pub fn stroke_color(&self) -> Color { unsafe { tsCanvasShape_getStrokeColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsCanvasShape_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsCanvasShape_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsCanvasShape_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsCanvasShape_getStrokeStyle(self.this) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsCanvasShape_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsCanvasShape_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsCanvasShape_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsCanvasShape_getGradientStyle(self.this) } }
	pub fn create_svg(&mut self, src: &str) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsCanvasShape_createSVG(self.this, src_.as_ptr(), 1.0) != 0 }
	}
	pub fn create_svg_with_scale(&mut self, src: &str, scale: f32) -> bool {
		let src_ = CString::new(src).unwrap();
		unsafe { tsCanvasShape_createSVG(self.this, src_.as_ptr(), scale) != 0 }
	}
	pub fn clear_positions(&mut self) { unsafe { tsCanvasShape_clearPositions(self.this) } }
	pub fn set_num_positions(&mut self, num_positions: u32) { unsafe { tsCanvasShape_setNumPositions(self.this, num_positions) } }
	pub fn reserve_positions(&mut self, num_positions: u32) { unsafe { tsCanvasShape_reservePositions(self.this, num_positions) } }
	pub fn num_positions(&self) -> u32 { unsafe { tsCanvasShape_getNumPositions(self.this) } }
	pub fn set_positions(&mut self, positions: &[Vector3f]) { unsafe { tsCanvasShape_setPositions(self.this, positions.as_ptr(), positions.len() as u32) } }
	pub fn add_positions(&mut self, positions: &[Vector3f]) { unsafe { tsCanvasShape_addPositions(self.this, positions.as_ptr(), positions.len() as u32) } }
	pub fn positions(&self) -> *const Vector3f { unsafe { tsCanvasShape_getPositions_c(self.this) } }
	pub fn positions_mut(&mut self) -> *mut Vector3f { unsafe { tsCanvasShape_getPositions(self.this) } }
	pub fn set_position(&mut self, index: u32, position: &Vector3f) { unsafe { tsCanvasShape_setPosition_ucV3(self.this, index, position) } }
	pub fn set_position_with_xy(&mut self, index: u32, x: f32, y: f32) { unsafe { tsCanvasShape_setPosition_ufff(self.this, index, x, y, 0.0) } }
	pub fn set_position_with_xyz(&mut self, index: u32, x: f32, y: f32, z: f32) { unsafe { tsCanvasShape_setPosition_ufff(self.this, index, x, y, z) } }
	pub fn position(&self, index: u32) -> Vector3f { unsafe { tsCanvasShape_getPosition_cu(self.this, index) } }
	pub fn position_mut(&mut self, index: u32) -> Vector3f { unsafe { tsCanvasShape_getPosition_u(self.this, index) } }
	pub fn add_position(&mut self, position: &Vector2f) -> u32 { unsafe { tsCanvasShape_addPosition_cV2(self.this, position) } }
	pub fn add_position_with_position(&mut self, position: &Vector3f) -> u32 { unsafe { tsCanvasShape_addPosition_cV3(self.this, position) } }
	pub fn add_position_with_xy(&mut self, x: f32, y: f32) -> u32 { unsafe { tsCanvasShape_addPosition_fff(self.this, x, y, 0.0) } }
	pub fn add_position_with_xyz(&mut self, x: f32, y: f32, z: f32) -> u32 { unsafe { tsCanvasShape_addPosition_fff(self.this, x, y, z) } }
	pub fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsCanvasShape_setTexCoord_cR(self.this, texcoord) } }
	pub fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsCanvasShape_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	pub fn tex_coord(&self) -> Rect { unsafe { tsCanvasShape_getTexCoord(self.this) } }
}
impl CanvasElementTrait for CanvasShape {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasShape {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasShape_delete(self.this) } } }
}
impl Clone for CanvasShape {
	fn clone(&self) -> CanvasShape { unsafe { CanvasShape { this: tsCanvasShape_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasShape { }
impl fmt::Display for CanvasShape {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasShape ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasShape_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasShape_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasShape_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasShape_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasShape_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasShape_new() -> *mut c_void;
	fn tsCanvasShape_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasShape_new_Cb(canvas: *mut c_void, cubic: i32) -> *mut c_void;
	fn tsCanvasShape_delete(this: *mut c_void);
	fn tsCanvasShape_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasShape_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasShape_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasShape_clearPtr(this: *const c_void);
	fn tsCanvasShape_destroyPtr(this: *const c_void);
	fn tsCanvasShape_acquirePtr(this: *const c_void);
	fn tsCanvasShape_unacquirePtr(this: *const c_void);
	fn tsCanvasShape_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasShape_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasShape_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasShape_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasShape_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasShape_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasShape_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasShape_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasShape_setCubic(this: *mut c_void, cubic: i32);
	fn tsCanvasShape_isCubic(this: *const c_void) -> i32;
	fn tsCanvasShape_setThreshold(this: *mut c_void, threshold: f32);
	fn tsCanvasShape_getThreshold(this: *const c_void) -> f32;
	fn tsCanvasShape_setStrokeColor(this: *mut c_void, color: *const Color);
	fn tsCanvasShape_getStrokeColor(this: *const c_void) -> Color;
	fn tsCanvasShape_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsCanvasShape_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsCanvasShape_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsCanvasShape_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsCanvasShape_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsCanvasShape_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsCanvasShape_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsCanvasShape_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsCanvasShape_createSVG(this: *mut c_void, src: *const c_char, scale: f32) -> i32;
	fn tsCanvasShape_clearPositions(this: *mut c_void);
	fn tsCanvasShape_setNumPositions(this: *mut c_void, num_positions: u32);
	fn tsCanvasShape_reservePositions(this: *mut c_void, num_positions: u32);
	fn tsCanvasShape_getNumPositions(this: *const c_void) -> u32;
	fn tsCanvasShape_setPositions(this: *mut c_void, positions: *const Vector3f, num_positions: u32);
	fn tsCanvasShape_addPositions(this: *mut c_void, positions: *const Vector3f, num_positions: u32);
	fn tsCanvasShape_getPositions_c(this: *const c_void) -> *const Vector3f;
	fn tsCanvasShape_getPositions(this: *mut c_void) -> *mut Vector3f;
	fn tsCanvasShape_setPosition_ucV3(this: *mut c_void, index: u32, position: *const Vector3f);
	fn tsCanvasShape_setPosition_ufff(this: *mut c_void, index: u32, x: f32, y: f32, z: f32);
	fn tsCanvasShape_getPosition_cu(this: *const c_void, index: u32) -> Vector3f;
	fn tsCanvasShape_getPosition_u(this: *mut c_void, index: u32) -> Vector3f;
	fn tsCanvasShape_addPosition_cV2(this: *mut c_void, position: *const Vector2f) -> u32;
	fn tsCanvasShape_addPosition_cV3(this: *mut c_void, position: *const Vector3f) -> u32;
	fn tsCanvasShape_addPosition_fff(this: *mut c_void, x: f32, y: f32, z: f32) -> u32;
	fn tsCanvasShape_setTexCoord_cR(this: *mut c_void, texcoord: *const Rect);
	fn tsCanvasShape_setTexCoord_ffff(this: *mut c_void, left: f32, right: f32, bottom: f32, top: f32);
	fn tsCanvasShape_getTexCoord(this: *const c_void) -> Rect;
}

// Tellusim::CanvasStrip
pub struct CanvasStrip {
	this: *mut c_void,
	owner: bool,
}
impl CanvasStrip {
	pub fn null() -> CanvasStrip { CanvasStrip { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CanvasStrip { unsafe { CanvasStrip { this: tsCanvasStrip_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> CanvasStrip { unsafe { CanvasStrip { this: tsCanvasStrip_new_C(canvas.this), owner: true } } }
	pub fn new_with_canvas_width(canvas: &mut Canvas, width: f32) -> CanvasStrip { unsafe { CanvasStrip { this: tsCanvasStrip_new_Cf(canvas.this, width), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CanvasStrip { unsafe { CanvasStrip { this: ptr, owner: tsCanvasStrip_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CanvasStrip { unsafe { CanvasStrip { this: tsCanvasStrip_copyPtr(self.this), owner: true } } }
	pub fn from_canvas_element(ptr: &CanvasElement) -> CanvasStrip { unsafe { CanvasStrip::new_ptr(tsCanvasStrip_castCanvasElementPtr(ptr.this)) } }
	pub fn to_canvas_element(&self) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvasStrip_baseCanvasElementPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: CanvasStrip) -> bool { unsafe { tsCanvasStrip_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CanvasStrip { unsafe { CanvasStrip { this: tsCanvasStrip_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvasStrip_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvasStrip_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvasStrip_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvasStrip_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvasStrip_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvasStrip_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvasStrip_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvasStrip_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvasStrip_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_width(&mut self, width: f32) { unsafe { tsCanvasStrip_setWidth(self.this, width) } }
	pub fn width(&self) -> f32 { unsafe { tsCanvasStrip_getWidth(self.this) } }
	pub fn set_offset(&mut self, offset: f32) { unsafe { tsCanvasStrip_setOffset(self.this, offset) } }
	pub fn offset(&self) -> f32 { unsafe { tsCanvasStrip_getOffset(self.this) } }
	pub fn set_stroke_color(&mut self, color: &Color) { unsafe { tsCanvasStrip_setStrokeColor(self.this, color) } }
	pub fn stroke_color(&self) -> Color { unsafe { tsCanvasStrip_getStrokeColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsCanvasStrip_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsCanvasStrip_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsCanvasStrip_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsCanvasStrip_getStrokeStyle(self.this) } }
	pub fn create_quadratic(&mut self, p0: &Vector2f, p1: &Vector2f, p2: &Vector2f) { unsafe { tsCanvasStrip_createQuadratic_cV2cV2cV2f(self.this, p0, p1, p2, 1.0) } }
	pub fn create_quadratic_with_threshold(&mut self, p0: &Vector2f, p1: &Vector2f, p2: &Vector2f, threshold: f32) { unsafe { tsCanvasStrip_createQuadratic_cV2cV2cV2f(self.this, p0, p1, p2, threshold) } }
	pub fn create_quadratic_with_p0(&mut self, p0: &Vector3f, p1: &Vector3f, p2: &Vector3f) { unsafe { tsCanvasStrip_createQuadratic_cV3cV3cV3f(self.this, p0, p1, p2, 1.0) } }
	pub fn create_quadratic_with_p0_threshold(&mut self, p0: &Vector3f, p1: &Vector3f, p2: &Vector3f, threshold: f32) { unsafe { tsCanvasStrip_createQuadratic_cV3cV3cV3f(self.this, p0, p1, p2, threshold) } }
	pub fn create_cubic(&mut self, p0: &Vector2f, p1: &Vector2f, p2: &Vector2f, p3: &Vector2f) { unsafe { tsCanvasStrip_createCubic_cV2cV2cV2cV2f(self.this, p0, p1, p2, p3, 1.0) } }
	pub fn create_cubic_with_threshold(&mut self, p0: &Vector2f, p1: &Vector2f, p2: &Vector2f, p3: &Vector2f, threshold: f32) { unsafe { tsCanvasStrip_createCubic_cV2cV2cV2cV2f(self.this, p0, p1, p2, p3, threshold) } }
	pub fn create_cubic_with_p0(&mut self, p0: &Vector3f, p1: &Vector3f, p2: &Vector3f, p3: &Vector3f) { unsafe { tsCanvasStrip_createCubic_cV3cV3cV3cV3f(self.this, p0, p1, p2, p3, 1.0) } }
	pub fn create_cubic_with_p0_threshold(&mut self, p0: &Vector3f, p1: &Vector3f, p2: &Vector3f, p3: &Vector3f, threshold: f32) { unsafe { tsCanvasStrip_createCubic_cV3cV3cV3cV3f(self.this, p0, p1, p2, p3, threshold) } }
	pub fn clear_positions(&mut self) { unsafe { tsCanvasStrip_clearPositions(self.this) } }
	pub fn set_num_positions(&mut self, num_positions: u32) { unsafe { tsCanvasStrip_setNumPositions(self.this, num_positions) } }
	pub fn reserve_positions(&mut self, num_positions: u32) { unsafe { tsCanvasStrip_reservePositions(self.this, num_positions) } }
	pub fn num_positions(&self) -> u32 { unsafe { tsCanvasStrip_getNumPositions(self.this) } }
	pub fn set_positions(&mut self, positions: &[Vector3f]) { unsafe { tsCanvasStrip_setPositions(self.this, positions.as_ptr(), positions.len() as u32) } }
	pub fn add_positions(&mut self, positions: &[Vector3f]) { unsafe { tsCanvasStrip_addPositions(self.this, positions.as_ptr(), positions.len() as u32) } }
	pub fn positions(&self) -> *const Vector3f { unsafe { tsCanvasStrip_getPositions_c(self.this) } }
	pub fn positions_mut(&mut self) -> *mut Vector3f { unsafe { tsCanvasStrip_getPositions(self.this) } }
	pub fn set_position(&mut self, index: u32, position: &Vector3f) { unsafe { tsCanvasStrip_setPosition_ucV3(self.this, index, position) } }
	pub fn set_position_with_xy(&mut self, index: u32, x: f32, y: f32) { unsafe { tsCanvasStrip_setPosition_ufff(self.this, index, x, y, 0.0) } }
	pub fn set_position_with_xyz(&mut self, index: u32, x: f32, y: f32, z: f32) { unsafe { tsCanvasStrip_setPosition_ufff(self.this, index, x, y, z) } }
	pub fn position(&self, index: u32) -> Vector3f { unsafe { tsCanvasStrip_getPosition_cu(self.this, index) } }
	pub fn position_mut(&mut self, index: u32) -> Vector3f { unsafe { tsCanvasStrip_getPosition_u(self.this, index) } }
	pub fn add_position(&mut self, position: &Vector2f) -> u32 { unsafe { tsCanvasStrip_addPosition_cV2(self.this, position) } }
	pub fn add_position_with_position(&mut self, position: &Vector3f) -> u32 { unsafe { tsCanvasStrip_addPosition_cV3(self.this, position) } }
	pub fn add_position_with_xy(&mut self, x: f32, y: f32) -> u32 { unsafe { tsCanvasStrip_addPosition_fff(self.this, x, y, 0.0) } }
	pub fn add_position_with_xyz(&mut self, x: f32, y: f32, z: f32) -> u32 { unsafe { tsCanvasStrip_addPosition_fff(self.this, x, y, z) } }
}
impl CanvasElementTrait for CanvasStrip {
	fn type_(&self) -> CanvasElementType { unsafe { tsCanvasElement_getType(self.this) } }
	fn type_name_with_type(type_: CanvasElementType) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_CET(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsCanvasElement_getTypeName_c(self.this)) } }
	fn is_text(&self) -> bool { unsafe { tsCanvasElement_isText(self.this) != 0 } }
	fn is_mesh(&self) -> bool { unsafe { tsCanvasElement_isMesh(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsCanvasElement_isRect(self.this) != 0 } }
	fn is_triangle(&self) -> bool { unsafe { tsCanvasElement_isTriangle(self.this) != 0 } }
	fn is_ellipse(&self) -> bool { unsafe { tsCanvasElement_isEllipse(self.this) != 0 } }
	fn is_shape(&self) -> bool { unsafe { tsCanvasElement_isShape(self.this) != 0 } }
	fn is_strip(&self) -> bool { unsafe { tsCanvasElement_isStrip(self.this) != 0 } }
	fn set_canvas(&mut self, canvas: &mut Canvas) { unsafe { tsCanvasElement_setCanvas(self.this, canvas.this) } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas_c(self.this)) } }
	fn canvas_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvasElement_getCanvas(self.this)) } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsCanvasElement_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsCanvasElement_getMode(self.this) } }
	fn set_align(&mut self, align: CanvasElementAlign) { unsafe { tsCanvasElement_setAlign(self.this, align) } }
	fn align(&self) -> CanvasElementAlign { unsafe { tsCanvasElement_getAlign(self.this) } }
	fn has_align(&self, align: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: CanvasElementAlign) -> bool { unsafe { tsCanvasElement_hasAligns(self.this, aligns) != 0 } }
	fn set_order(&mut self, order: i32) { unsafe { tsCanvasElement_setOrder(self.this, order) } }
	fn order(&self) -> i32 { unsafe { tsCanvasElement_getOrder(self.this) } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvasElement_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsCanvasElement_isEnabled(self.this) != 0 } }
	fn clear_color(&mut self) { unsafe { tsCanvasElement_clearColor(self.this) } }
	fn set_color(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_CES(self.this, op) } }
	fn set_color_with_color(&mut self, color: &Color) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, CanvasElementStack::None) } }
	fn set_color_with_color_op(&mut self, color: &Color, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_cCCES(self.this, color, op) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, CanvasElementStack::None) } }
	fn set_color_with_rgba_op(&mut self, r: f32, g: f32, b: f32, a: f32, op: CanvasElementStack) { unsafe { tsCanvasElement_setColor_ffffCES(self.this, r, g, b, a, op) } }
	fn color(&self) -> Color { unsafe { tsCanvasElement_getColor(self.this) } }
	fn color_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getColorOp(self.this) } }
	fn clear_transform(&mut self) { unsafe { tsCanvasElement_clearTransform(self.this) } }
	fn set_transform(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_CES(self.this, op) } }
	fn set_transform_with_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, CanvasElementStack::None) } }
	fn set_transform_with_transform_op(&mut self, transform: &Matrix4x4f, op: CanvasElementStack) { unsafe { tsCanvasElement_setTransform_cM44CES(self.this, transform, op) } }
	fn transform(&self) -> Matrix4x4f { unsafe { tsCanvasElement_getTransform(self.this) } }
	fn transform_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getTransformOp(self.this) } }
	fn clear_scissor(&mut self) { unsafe { tsCanvasElement_clearScissor(self.this) } }
	fn set_scissor(&mut self, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_CES(self.this, op) } }
	fn set_scissor_with_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, CanvasElementStack::None) } }
	fn set_scissor_with_scissor_op(&mut self, scissor: &Rect, op: CanvasElementStack) { unsafe { tsCanvasElement_setScissor_cRCES(self.this, scissor, op) } }
	fn scissor(&self) -> Rect { unsafe { tsCanvasElement_getScissor(self.this) } }
	fn scissor_op(&self) -> CanvasElementStack { unsafe { tsCanvasElement_getScissorOp(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsCanvasElement_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsCanvasElement_getMipmap(self.this) } }
	fn set_sampler(&mut self, sampler: &mut Sampler) { unsafe { tsCanvasElement_setSampler(self.this, sampler.this) } }
	fn sampler(&self) -> Sampler { unsafe { Sampler::new_ptr(tsCanvasElement_getSampler(self.this)) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsCanvasElement_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsCanvasElement_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsCanvasElement_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsCanvasElement_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsCanvasElement_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsCanvasElement_getWrapMode(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsCanvasElement_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsCanvasElement_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsCanvasElement_getTextureLinear(self.this) != 0 } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsCanvasElement_setPipeline(self.this, pipeline.this) } }
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsCanvasElement_getPipeline(self.this)) } }
	fn set_primitive(&mut self, primitive: PipelinePrimitive) { unsafe { tsCanvasElement_setPrimitive(self.this, primitive) } }
	fn primitive(&self) -> PipelinePrimitive { unsafe { tsCanvasElement_getPrimitive(self.this) } }
	fn set_cull_mode(&mut self, mode: PipelineCullMode) { unsafe { tsCanvasElement_setCullMode(self.this, mode) } }
	fn cull_mode(&self) -> PipelineCullMode { unsafe { tsCanvasElement_getCullMode(self.this) } }
	fn set_front_mode(&mut self, mode: PipelineFrontMode) { unsafe { tsCanvasElement_setFrontMode(self.this, mode) } }
	fn front_mode(&self) -> PipelineFrontMode { unsafe { tsCanvasElement_getFrontMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsCanvasElement_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsCanvasElement_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsCanvasElement_getBlendDestFunc(self.this) } }
	fn set_color_mask(&mut self, mask: PipelineColorMask) { unsafe { tsCanvasElement_setColorMask(self.this, mask) } }
	fn color_mask(&self) -> PipelineColorMask { unsafe { tsCanvasElement_getColorMask(self.this) } }
	fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvasElement_setDepthMask(self.this, mask) } }
	fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvasElement_getDepthMask(self.this) } }
	fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvasElement_setDepthFunc(self.this, func) } }
	fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvasElement_getDepthFunc(self.this) } }
	fn set_stencil_ref(&mut self, ref_: u32) { unsafe { tsCanvasElement_setStencilRef(self.this, ref_) } }
	fn set_stencil_func(&mut self, func: PipelineStencilFunc, fail_op: PipelineStencilOp, dfail_op: PipelineStencilOp, dpass_op: PipelineStencilOp) { unsafe { tsCanvasElement_setStencilFunc(self.this, func, fail_op, dfail_op, dpass_op) } }
	fn stencil_ref(&self) -> u32 { unsafe { tsCanvasElement_getStencilRef(self.this) } }
	fn stencil_func(&self) -> PipelineStencilFunc { unsafe { tsCanvasElement_getStencilFunc(self.this) } }
	fn stencil_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilFailOp(self.this) } }
	fn stencil_depth_fail_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthFailOp(self.this) } }
	fn stencil_depth_pass_op(&self) -> PipelineStencilOp { unsafe { tsCanvasElement_getStencilDepthPassOp(self.this) } }
	fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsCanvasElement_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn rect(&mut self) -> Rect { unsafe { tsCanvasElement_getRect(self.this) } }
}
impl Drop for CanvasStrip {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvasStrip_delete(self.this) } } }
}
impl Clone for CanvasStrip {
	fn clone(&self) -> CanvasStrip { unsafe { CanvasStrip { this: tsCanvasStrip_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CanvasStrip { }
impl fmt::Display for CanvasStrip {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CanvasStrip ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvasStrip_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvasStrip_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvasStrip_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvasStrip_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvasStrip_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvasStrip_new() -> *mut c_void;
	fn tsCanvasStrip_new_C(canvas: *mut c_void) -> *mut c_void;
	fn tsCanvasStrip_new_Cf(canvas: *mut c_void, width: f32) -> *mut c_void;
	fn tsCanvasStrip_delete(this: *mut c_void);
	fn tsCanvasStrip_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasStrip_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasStrip_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasStrip_clearPtr(this: *const c_void);
	fn tsCanvasStrip_destroyPtr(this: *const c_void);
	fn tsCanvasStrip_acquirePtr(this: *const c_void);
	fn tsCanvasStrip_unacquirePtr(this: *const c_void);
	fn tsCanvasStrip_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvasStrip_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvasStrip_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvasStrip_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvasStrip_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasStrip_equalCanvasElementPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvasStrip_castCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasStrip_baseCanvasElementPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvasStrip_setWidth(this: *mut c_void, width: f32);
	fn tsCanvasStrip_getWidth(this: *const c_void) -> f32;
	fn tsCanvasStrip_setOffset(this: *mut c_void, offset: f32);
	fn tsCanvasStrip_getOffset(this: *const c_void) -> f32;
	fn tsCanvasStrip_setStrokeColor(this: *mut c_void, color: *const Color);
	fn tsCanvasStrip_getStrokeColor(this: *const c_void) -> Color;
	fn tsCanvasStrip_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsCanvasStrip_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsCanvasStrip_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsCanvasStrip_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsCanvasStrip_createQuadratic_cV2cV2cV2f(this: *mut c_void, p0: *const Vector2f, p1: *const Vector2f, p2: *const Vector2f, threshold: f32);
	fn tsCanvasStrip_createQuadratic_cV3cV3cV3f(this: *mut c_void, p0: *const Vector3f, p1: *const Vector3f, p2: *const Vector3f, threshold: f32);
	fn tsCanvasStrip_createCubic_cV2cV2cV2cV2f(this: *mut c_void, p0: *const Vector2f, p1: *const Vector2f, p2: *const Vector2f, p3: *const Vector2f, threshold: f32);
	fn tsCanvasStrip_createCubic_cV3cV3cV3cV3f(this: *mut c_void, p0: *const Vector3f, p1: *const Vector3f, p2: *const Vector3f, p3: *const Vector3f, threshold: f32);
	fn tsCanvasStrip_clearPositions(this: *mut c_void);
	fn tsCanvasStrip_setNumPositions(this: *mut c_void, num_positions: u32);
	fn tsCanvasStrip_reservePositions(this: *mut c_void, num_positions: u32);
	fn tsCanvasStrip_getNumPositions(this: *const c_void) -> u32;
	fn tsCanvasStrip_setPositions(this: *mut c_void, positions: *const Vector3f, num_positions: u32);
	fn tsCanvasStrip_addPositions(this: *mut c_void, positions: *const Vector3f, num_positions: u32);
	fn tsCanvasStrip_getPositions_c(this: *const c_void) -> *const Vector3f;
	fn tsCanvasStrip_getPositions(this: *mut c_void) -> *mut Vector3f;
	fn tsCanvasStrip_setPosition_ucV3(this: *mut c_void, index: u32, position: *const Vector3f);
	fn tsCanvasStrip_setPosition_ufff(this: *mut c_void, index: u32, x: f32, y: f32, z: f32);
	fn tsCanvasStrip_getPosition_cu(this: *const c_void, index: u32) -> Vector3f;
	fn tsCanvasStrip_getPosition_u(this: *mut c_void, index: u32) -> Vector3f;
	fn tsCanvasStrip_addPosition_cV2(this: *mut c_void, position: *const Vector2f) -> u32;
	fn tsCanvasStrip_addPosition_cV3(this: *mut c_void, position: *const Vector3f) -> u32;
	fn tsCanvasStrip_addPosition_fff(this: *mut c_void, x: f32, y: f32, z: f32) -> u32;
}

// Tellusim::Canvas
pub struct Canvas {
	this: *mut c_void,
	owner: bool,
}
type CanvasCreateCallback = unsafe extern "C" fn(device: *mut c_void, canvas: *mut c_void, scale: u32, data_: *mut c_void) -> i32;
unsafe extern "C" fn canvas_create_callback_func<Func>(device: *mut c_void, canvas: *mut c_void, scale: u32, data_: *mut c_void) -> i32 where Func: FnMut(Device, Canvas, u32) -> bool {
	let func = &mut *(data_ as *mut Func);
	let device_ = Device::new_ptr(device);
	let canvas_ = Canvas::new_ptr(canvas);
	if func(device_, canvas_, scale) {1} else {0}
}
type CanvasPipelineCallback = unsafe extern "C" fn(pipeline: *mut c_void, canvas: *mut c_void, element: *mut c_void, data_: *mut c_void) -> i32;
unsafe extern "C" fn canvas_pipeline_callback_func<Func>(pipeline: *mut c_void, canvas: *mut c_void, element: *mut c_void, data_: *mut c_void) -> i32 where Func: FnMut(Pipeline, Canvas, CanvasElement) -> bool {
	let func = &mut *(data_ as *mut Func);
	let pipeline_ = Pipeline::new_ptr(pipeline);
	let canvas_ = Canvas::new_ptr(canvas);
	let element_ = CanvasElement::new_ptr(element);
	if func(pipeline_, canvas_, element_) {1} else {0}
}
type CanvasBeginCallback = unsafe extern "C" fn(command: *mut c_void, canvas: *mut c_void, data_: *mut c_void) -> i32;
unsafe extern "C" fn canvas_begin_callback_func<Func>(command: *mut c_void, canvas: *mut c_void, data_: *mut c_void) -> i32 where Func: FnMut(Command, Canvas) -> bool {
	let func = &mut *(data_ as *mut Func);
	let command_ = Command::new_ptr(command);
	let canvas_ = Canvas::new_ptr(canvas);
	if func(command_, canvas_) {1} else {0}
}
type CanvasDrawCallback = unsafe extern "C" fn(command: *mut c_void, canvas: *mut c_void, data_: *mut c_void) -> i32;
unsafe extern "C" fn canvas_draw_callback_func<Func>(command: *mut c_void, canvas: *mut c_void, data_: *mut c_void) -> i32 where Func: FnMut(Command, Canvas) -> bool {
	let func = &mut *(data_ as *mut Func);
	let command_ = Command::new_ptr(command);
	let canvas_ = Canvas::new_ptr(canvas);
	if func(command_, canvas_) {1} else {0}
}
impl Canvas {
	pub fn null() -> Canvas { Canvas { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Canvas { unsafe { Canvas { this: tsCanvas_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Canvas>) -> Canvas { unsafe { Canvas { this: tsCanvas_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Canvas { unsafe { Canvas { this: ptr, owner: tsCanvas_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Canvas { unsafe { Canvas { this: tsCanvas_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Canvas) -> bool { unsafe { tsCanvas_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Canvas { unsafe { Canvas { this: tsCanvas_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCanvas_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCanvas_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCanvas_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCanvas_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCanvas_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCanvas_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCanvas_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCanvas_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCanvas_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsCanvas_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsCanvas_isCreated(self.this) != 0 } }
	pub fn scale(&self, target: &Target) -> u32 { unsafe { tsCanvas_getScale(self.this, target.this, 100) } }
	pub fn scale_with_scale(&self, target: &Target, scale: u32) -> u32 { unsafe { tsCanvas_getScale(self.this, target.this, scale) } }
	pub fn create_with_color(&mut self, device: &Device, color: Format, depth: Format) -> bool { unsafe { tsCanvas_create_cDFFuu(self.this, device.this, color, depth, 1, 0) != 0 } }
	pub fn create_with_color_multisample(&mut self, device: &Device, color: Format, depth: Format, multisample: u32) -> bool { unsafe { tsCanvas_create_cDFFuu(self.this, device.this, color, depth, multisample, 0) != 0 } }
	pub fn create_with_color_multisample_scale(&mut self, device: &Device, color: Format, depth: Format, multisample: u32, scale: u32) -> bool { unsafe { tsCanvas_create_cDFFuu(self.this, device.this, color, depth, multisample, scale) != 0 } }
	pub fn create(&mut self, device: &Device, target: &Target) -> bool { unsafe { tsCanvas_create_cDcTu(self.this, device.this, target.this, 0) != 0 } }
	pub fn create_with_scale(&mut self, device: &Device, target: &Target, scale: u32) -> bool { unsafe { tsCanvas_create_cDcTu(self.this, device.this, target.this, scale) != 0 } }
	pub fn set_pipeline_hash(&mut self, hash: u32) { unsafe { tsCanvas_setPipelineHash(self.this, hash) } }
	pub fn pipeline_hash(&self) -> u32 { unsafe { tsCanvas_getPipelineHash(self.this) } }
	pub fn color_format(&self) -> Format { unsafe { tsCanvas_getColorFormat(self.this) } }
	pub fn depth_format(&self) -> Format { unsafe { tsCanvas_getDepthFormat(self.this) } }
	pub fn multisample(&self) -> u32 { unsafe { tsCanvas_getMultisample(self.this) } }
	pub fn set_order(&mut self, order: i32) { unsafe { tsCanvas_setOrder(self.this, order) } }
	pub fn order(&self) -> i32 { unsafe { tsCanvas_getOrder(self.this) } }
	pub fn set_enabled(&mut self, enabled: bool) { unsafe { tsCanvas_setEnabled(self.this, if enabled {1} else {0}) } }
	pub fn is_enabled(&self) -> bool { unsafe { tsCanvas_isEnabled(self.this) != 0 } }
	pub fn set_viewport(&mut self, viewport: &Viewport) { unsafe { tsCanvas_setViewport_cV(self.this, viewport) } }
	pub fn set_viewportu32(&mut self, width: u32, height: u32) { unsafe { tsCanvas_setViewport_uu(self.this, width, height) } }
	pub fn set_viewportf32(&mut self, width: f32, height: f32) { unsafe { tsCanvas_setViewport_ff(self.this, width, height) } }
	pub fn viewport(&self) -> Viewport { unsafe { tsCanvas_getViewport(self.this) } }
	pub fn width(&self) -> f32 { unsafe { tsCanvas_getWidth(self.this) } }
	pub fn height(&self) -> f32 { unsafe { tsCanvas_getHeight(self.this) } }
	pub fn clear_color(&mut self) { unsafe { tsCanvas_clearColor(self.this) } }
	pub fn set_color(&mut self, color: &Color) { unsafe { tsCanvas_setColor_cC(self.this, color) } }
	pub fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsCanvas_setColor_ffff(self.this, r, g, b, a) } }
	pub fn color(&self) -> Color { unsafe { tsCanvas_getColor(self.this) } }
	pub fn clear_scissor(&mut self) { unsafe { tsCanvas_clearScissor(self.this) } }
	pub fn set_scissor(&mut self, scissor: &Rect) { unsafe { tsCanvas_setScissor(self.this, scissor) } }
	pub fn scissor(&self) -> Rect { unsafe { tsCanvas_getScissor(self.this) } }
	pub fn clear_transform(&mut self) { unsafe { tsCanvas_clearTransform(self.this) } }
	pub fn set_transform(&mut self, transform: &Matrix4x4f) { unsafe { tsCanvas_setTransform(self.this, transform) } }
	pub fn transform(&self) -> Matrix4x4f { unsafe { tsCanvas_getTransform(self.this) } }
	pub fn set_parent(&mut self, parent: &mut Canvas) -> u32 { unsafe { tsCanvas_setParent(self.this, parent.this) } }
	pub fn parent(&self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvas_getParent_c(self.this)) } }
	pub fn parent_mut(&mut self) -> Canvas { unsafe { Canvas::new_ptr(tsCanvas_getParent(self.this)) } }
	pub fn add_child(&mut self, child: &mut Canvas) -> u32 { unsafe { tsCanvas_addChild(self.this, child.this) } }
	pub fn remove_child(&mut self, child: &mut Canvas) -> bool { unsafe { tsCanvas_removeChild(self.this, child.this) != 0 } }
	pub fn raise_child(&mut self, child: &mut Canvas) -> bool { unsafe { tsCanvas_raiseChild(self.this, child.this) != 0 } }
	pub fn lower_child(&mut self, child: &mut Canvas) -> bool { unsafe { tsCanvas_lowerChild(self.this, child.this) != 0 } }
	pub fn release_children(&mut self) { unsafe { tsCanvas_releaseChildren(self.this) } }
	pub fn find_child(&self, child: &Canvas) -> u32 { unsafe { tsCanvas_findChild(self.this, child.this) } }
	pub fn is_child(&self, child: &Canvas) -> bool { unsafe { tsCanvas_isChild(self.this, child.this) != 0 } }
	pub fn num_children(&self) -> u32 { unsafe { tsCanvas_getNumChildren(self.this) } }
	pub fn child(&self, index: u32) -> Canvas { unsafe { Canvas::new_ptr(tsCanvas_getChild_cu(self.this, index)) } }
	pub fn child_mut(&mut self, index: u32) -> Canvas { unsafe { Canvas::new_ptr(tsCanvas_getChild_u(self.this, index)) } }
	pub fn add_element(&mut self, element: &mut CanvasElement) -> u32 { unsafe { tsCanvas_addElement(self.this, element.this) } }
	pub fn remove_element(&mut self, element: &mut CanvasElement) -> bool { unsafe { tsCanvas_removeElement(self.this, element.this) != 0 } }
	pub fn raise_element(&mut self, element: &mut CanvasElement) -> bool { unsafe { tsCanvas_raiseElement(self.this, element.this) != 0 } }
	pub fn lower_element(&mut self, element: &mut CanvasElement) -> bool { unsafe { tsCanvas_lowerElement(self.this, element.this) != 0 } }
	pub fn find_element(&self, element: &CanvasElement) -> u32 { unsafe { tsCanvas_findElement(self.this, element.this) } }
	pub fn is_element(&self, element: &CanvasElement) -> bool { unsafe { tsCanvas_isElement(self.this, element.this) != 0 } }
	pub fn num_elements(&self) -> u32 { unsafe { tsCanvas_getNumElements(self.this) } }
	pub fn element(&self, index: u32) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvas_getElement_cu(self.this, index)) } }
	pub fn element_mut(&mut self, index: u32) -> CanvasElement { unsafe { CanvasElement::new_ptr(tsCanvas_getElement_u(self.this, index)) } }
	pub fn is_font(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_isFont(self.this, name_.as_ptr()) != 0 }
	}
	pub fn add_font(&mut self, name: &str, stream: &mut Stream) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_addFont_sSt(self.this, name_.as_ptr(), stream.this) != 0 }
	}
	pub fn add_font_with_blob(&mut self, name: &str, blob: *const *const u8) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_addFont_sbl(self.this, name_.as_ptr(), blob) != 0 }
	}
	pub fn remove_font(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_removeFont(self.this, name_.as_ptr()) }
	}
	pub fn font(&mut self, name: &str) -> Font {
		let name_ = CString::new(name).unwrap();
		unsafe { Font::new_ptr(tsCanvas_getFont(self.this, name_.as_ptr())) }
	}
	pub fn is_texture(&self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_isTexture(self.this, name_.as_ptr()) != 0 }
	}
	pub fn add_texture(&mut self, name: &str, stream: &mut Stream) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_addTexture_sSt(self.this, name_.as_ptr(), stream.this) != 0 }
	}
	pub fn add_texture_with_texture(&mut self, name: &str, texture: &mut Texture) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_addTexture_sT(self.this, name_.as_ptr(), texture.this) != 0 }
	}
	pub fn add_texture_with_blob(&mut self, name: &str, blob: *const *const u8) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_addTexture_sbl(self.this, name_.as_ptr(), blob) != 0 }
	}
	pub fn remove_texture(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsCanvas_removeTexture(self.this, name_.as_ptr()) }
	}
	pub fn texture(&mut self, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsCanvas_getTexture(self.this, name_.as_ptr())) }
	}
	pub fn set_depth_mask(&mut self, mask: PipelineDepthMask) { unsafe { tsCanvas_setDepthMask(self.this, mask) } }
	pub fn depth_mask(&self) -> PipelineDepthMask { unsafe { tsCanvas_getDepthMask(self.this) } }
	pub fn set_depth_func(&mut self, func: PipelineDepthFunc) { unsafe { tsCanvas_setDepthFunc(self.this, func) } }
	pub fn depth_func(&self) -> PipelineDepthFunc { unsafe { tsCanvas_getDepthFunc(self.this) } }
	pub fn draw_with_target(&mut self, command: &mut Command, target: &Target) { unsafe { tsCanvas_draw_CcT(self.this, command.this, target.this) } }
	pub fn draw(&mut self, command: &mut Command) { unsafe { tsCanvas_draw_C(self.this, command.this) } }
	pub fn set_create_callback<Func>(&mut self, func: Func) where Func: FnMut(Device, Canvas, u32) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_create_callback_func::<Func>;
		unsafe { tsCanvas_setCreateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_pipeline_callback<Func>(&mut self, func: Func) where Func: FnMut(Pipeline, Canvas, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_pipeline_callback_func::<Func>;
		unsafe { tsCanvas_setPipelineCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_begin_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, Canvas) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_begin_callback_func::<Func>;
		unsafe { tsCanvas_setBeginCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_draw_callback<Func>(&mut self, func: Func) where Func: FnMut(Command, Canvas) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_draw_callback_func::<Func>;
		unsafe { tsCanvas_setDrawCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn num_draw_pipelines(&self) -> u32 { unsafe { tsCanvas_getNumDrawPipelines(self.this) } }
	pub fn num_draw_elements(&self) -> u32 { unsafe { tsCanvas_getNumDrawElements(self.this) } }
	pub fn num_draw_commands(&self) -> u32 { unsafe { tsCanvas_getNumDrawCommands(self.this) } }
	pub fn rect(&self) -> Rect { unsafe { tsCanvas_getRect(self.this) } }
}
impl Drop for Canvas {
	fn drop(&mut self) { if self.owner { unsafe { tsCanvas_delete(self.this) } } }
}
impl Clone for Canvas {
	fn clone(&self) -> Canvas { unsafe { Canvas { this: tsCanvas_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Canvas { }
impl fmt::Display for Canvas {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Canvas ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCanvas_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCanvas_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCanvas_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCanvas_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCanvas_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCanvas_new() -> *mut c_void;
	fn tsCanvas_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsCanvas_delete(this: *mut c_void);
	fn tsCanvas_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCanvas_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvas_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCanvas_clearPtr(this: *const c_void);
	fn tsCanvas_destroyPtr(this: *const c_void);
	fn tsCanvas_acquirePtr(this: *const c_void);
	fn tsCanvas_unacquirePtr(this: *const c_void);
	fn tsCanvas_isValidPtr(this: *const c_void) -> i32;
	fn tsCanvas_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCanvas_isConstPtr(this: *const c_void) -> i32;
	fn tsCanvas_getCountPtr(this: *const c_void) -> u32;
	fn tsCanvas_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCanvas_clear(this: *mut c_void);
	fn tsCanvas_isCreated(this: *const c_void) -> i32;
	fn tsCanvas_getScale(this: *const c_void, target: *mut c_void, scale: u32) -> u32;
	fn tsCanvas_create_cDFFuu(this: *mut c_void, device: *mut c_void, color: Format, depth: Format, multisample: u32, scale: u32) -> i32;
	fn tsCanvas_create_cDcTu(this: *mut c_void, device: *mut c_void, target: *mut c_void, scale: u32) -> i32;
	fn tsCanvas_setPipelineHash(this: *mut c_void, hash: u32);
	fn tsCanvas_getPipelineHash(this: *const c_void) -> u32;
	fn tsCanvas_getColorFormat(this: *const c_void) -> Format;
	fn tsCanvas_getDepthFormat(this: *const c_void) -> Format;
	fn tsCanvas_getMultisample(this: *const c_void) -> u32;
	fn tsCanvas_setOrder(this: *mut c_void, order: i32);
	fn tsCanvas_getOrder(this: *const c_void) -> i32;
	fn tsCanvas_setEnabled(this: *mut c_void, enabled: i32);
	fn tsCanvas_isEnabled(this: *const c_void) -> i32;
	fn tsCanvas_setViewport_cV(this: *mut c_void, viewport: *const Viewport);
	fn tsCanvas_setViewport_uu(this: *mut c_void, width: u32, height: u32);
	fn tsCanvas_setViewport_ff(this: *mut c_void, width: f32, height: f32);
	fn tsCanvas_getViewport(this: *const c_void) -> Viewport;
	fn tsCanvas_getWidth(this: *const c_void) -> f32;
	fn tsCanvas_getHeight(this: *const c_void) -> f32;
	fn tsCanvas_clearColor(this: *mut c_void);
	fn tsCanvas_setColor_cC(this: *mut c_void, color: *const Color);
	fn tsCanvas_setColor_ffff(this: *mut c_void, r: f32, g: f32, b: f32, a: f32);
	fn tsCanvas_getColor(this: *const c_void) -> Color;
	fn tsCanvas_clearScissor(this: *mut c_void);
	fn tsCanvas_setScissor(this: *mut c_void, scissor: *const Rect);
	fn tsCanvas_getScissor(this: *const c_void) -> Rect;
	fn tsCanvas_clearTransform(this: *mut c_void);
	fn tsCanvas_setTransform(this: *mut c_void, transform: *const Matrix4x4f);
	fn tsCanvas_getTransform(this: *const c_void) -> Matrix4x4f;
	fn tsCanvas_setParent(this: *mut c_void, parent: *mut c_void) -> u32;
	fn tsCanvas_getParent_c(this: *const c_void) -> *mut c_void;
	fn tsCanvas_getParent(this: *mut c_void) -> *mut c_void;
	fn tsCanvas_addChild(this: *mut c_void, child: *mut c_void) -> u32;
	fn tsCanvas_removeChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsCanvas_raiseChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsCanvas_lowerChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsCanvas_releaseChildren(this: *mut c_void);
	fn tsCanvas_findChild(this: *const c_void, child: *mut c_void) -> u32;
	fn tsCanvas_isChild(this: *const c_void, child: *mut c_void) -> i32;
	fn tsCanvas_getNumChildren(this: *const c_void) -> u32;
	fn tsCanvas_getChild_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsCanvas_getChild_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsCanvas_addElement(this: *mut c_void, element: *mut c_void) -> u32;
	fn tsCanvas_removeElement(this: *mut c_void, element: *mut c_void) -> i32;
	fn tsCanvas_raiseElement(this: *mut c_void, element: *mut c_void) -> i32;
	fn tsCanvas_lowerElement(this: *mut c_void, element: *mut c_void) -> i32;
	fn tsCanvas_findElement(this: *const c_void, element: *mut c_void) -> u32;
	fn tsCanvas_isElement(this: *const c_void, element: *mut c_void) -> i32;
	fn tsCanvas_getNumElements(this: *const c_void) -> u32;
	fn tsCanvas_getElement_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsCanvas_getElement_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsCanvas_isFont(this: *const c_void, name: *const c_char) -> i32;
	fn tsCanvas_addFont_sSt(this: *mut c_void, name: *const c_char, stream: *mut c_void) -> i32;
	fn tsCanvas_addFont_sbl(this: *mut c_void, name: *const c_char, blob: *const *const u8) -> i32;
	fn tsCanvas_removeFont(this: *mut c_void, name: *const c_char);
	fn tsCanvas_getFont(this: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsCanvas_isTexture(this: *const c_void, name: *const c_char) -> i32;
	fn tsCanvas_addTexture_sSt(this: *mut c_void, name: *const c_char, stream: *mut c_void) -> i32;
	fn tsCanvas_addTexture_sT(this: *mut c_void, name: *const c_char, texture: *mut c_void) -> i32;
	fn tsCanvas_addTexture_sbl(this: *mut c_void, name: *const c_char, blob: *const *const u8) -> i32;
	fn tsCanvas_removeTexture(this: *mut c_void, name: *const c_char);
	fn tsCanvas_getTexture(this: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsCanvas_setDepthMask(this: *mut c_void, mask: PipelineDepthMask);
	fn tsCanvas_getDepthMask(this: *const c_void) -> PipelineDepthMask;
	fn tsCanvas_setDepthFunc(this: *mut c_void, func: PipelineDepthFunc);
	fn tsCanvas_getDepthFunc(this: *const c_void) -> PipelineDepthFunc;
	fn tsCanvas_draw_CcT(this: *mut c_void, command: *mut c_void, target: *mut c_void);
	fn tsCanvas_draw_C(this: *mut c_void, command: *mut c_void);
	fn tsCanvas_setCreateCallback(this: *mut c_void, func: CanvasCreateCallback, data_: *mut c_void);
	fn tsCanvas_setPipelineCallback(this: *mut c_void, func: CanvasPipelineCallback, data_: *mut c_void);
	fn tsCanvas_setBeginCallback(this: *mut c_void, func: CanvasBeginCallback, data_: *mut c_void);
	fn tsCanvas_setDrawCallback(this: *mut c_void, func: CanvasDrawCallback, data_: *mut c_void);
	fn tsCanvas_getNumDrawPipelines(this: *const c_void) -> u32;
	fn tsCanvas_getNumDrawElements(this: *const c_void) -> u32;
	fn tsCanvas_getNumDrawCommands(this: *const c_void) -> u32;
	fn tsCanvas_getRect(this: *const c_void) -> Rect;
}

// Tellusim::Control
pub struct Control {
	this: *mut c_void,
	owner: bool,
}
impl Control {
	pub fn null() -> Control { Control { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Control { unsafe { Control { this: tsControl_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> Control { unsafe { Control { this: tsControl_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_width(parent: Option<&Control>, width: f32) -> Control { unsafe { Control { this: tsControl_new_Cff(match parent { Some(parent) => &parent.this, None => ptr::null() }, width, 0.0), owner: true } } }
	pub fn new_with_parent_width_height(parent: Option<&Control>, width: f32, height: f32) -> Control { unsafe { Control { this: tsControl_new_Cff(match parent { Some(parent) => &parent.this, None => ptr::null() }, width, height), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Control { unsafe { Control { this: ptr, owner: tsControl_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Control { unsafe { Control { this: tsControl_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Control) -> bool { unsafe { tsControl_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Control { unsafe { Control { this: tsControl_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControl_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControl_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControl_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControl_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControl_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControl_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControl_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControl_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControl_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ControlTrait {
	fn type_(&self) -> ControlType;
	fn type_name_with_type(type_: ControlType) -> string::String;
	fn type_name(&self) -> string::String;
	fn is_unknown(&self) -> bool;
	fn is_root(&self) -> bool;
	fn is_text(&self) -> bool;
	fn is_rect(&self) -> bool;
	fn is_grid(&self) -> bool;
	fn is_group(&self) -> bool;
	fn is_panel(&self) -> bool;
	fn is_dialog(&self) -> bool;
	fn is_window(&self) -> bool;
	fn is_check(&self) -> bool;
	fn is_combo(&self) -> bool;
	fn is_button(&self) -> bool;
	fn is_slider(&self) -> bool;
	fn is_scroll(&self) -> bool;
	fn is_split(&self) -> bool;
	fn is_area(&self) -> bool;
	fn is_tree(&self) -> bool;
	fn is_edit(&self) -> bool;
	fn set_align(&mut self, align: ControlAlign);
	fn align(&self) -> ControlAlign;
	fn has_align(&self, align: ControlAlign) -> bool;
	fn has_aligns(&self, aligns: ControlAlign) -> bool;
	fn is_spacer(&self) -> bool;
	fn set_created(&mut self, created: bool);
	fn is_created(&self) -> bool;
	fn set_enabled(&mut self, enabled: bool);
	fn is_enabled(&self) -> bool;
	fn was_enabled(&self) -> bool;
	fn was_updated(&self) -> bool;
	fn set_disabled(&mut self, disabled: bool);
	fn is_disabled(&self) -> bool;
	fn canvas(&self) -> Canvas;
	fn root(&self) -> ControlRoot;
	fn root_mut(&mut self) -> ControlRoot;
	fn panel(&self) -> ControlPanel;
	fn panel_mut(&mut self) -> ControlPanel;
	fn set_parent(&mut self, parent: &mut Control) -> u32;
	fn parent(&self) -> Control;
	fn parent_mut(&mut self) -> Control;
	fn is_parent_enabled(&self) -> bool;
	fn is_parent_disabled(&self) -> bool;
	fn add_child(&mut self, child: &mut Control) -> u32;
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control;
	fn raise_child(&mut self, child: &mut Control) -> bool;
	fn lower_child(&mut self, child: &mut Control) -> bool;
	fn remove_child(&mut self, child: &mut Control) -> bool;
	fn release_children(&mut self);
	fn find_child(&self, child: &Control) -> u32;
	fn is_child(&self, child: &Control) -> bool;
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool;
	fn num_children(&self) -> u32;
	fn child(&self, index: u32) -> Control;
	fn child_mut(&mut self, index: u32) -> Control;
	fn set_size(&mut self, size: &Vector2f);
	fn set_size_with_width(&mut self, width: f32, height: f32);
	fn size(&self) -> Vector2f;
	fn width(&self) -> f32;
	fn height(&self) -> f32;
	fn set_position(&mut self, position: &Vector3f);
	fn set_position_with_xy(&mut self, x: f32, y: f32);
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32);
	fn position(&self) -> Vector3f;
	fn position_x(&self) -> f32;
	fn position_y(&self) -> f32;
	fn set_offset(&mut self, offset: &Vector3f);
	fn set_offset_with_xy(&mut self, x: f32, y: f32);
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32);
	fn offset(&self) -> Vector3f;
	fn offset_x(&self) -> f32;
	fn offset_y(&self) -> f32;
	fn set_margin(&mut self, value: f32);
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32);
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32);
	fn set_margin_with_margin(&mut self, margin: &Rect);
	fn margin(&self) -> Rect;
	fn rect(&self) -> Rect;
	fn state(&self) -> ControlState;
}
impl ControlTrait for Control {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for Control {
	fn drop(&mut self) { if self.owner { unsafe { tsControl_delete(self.this) } } }
}
impl Clone for Control {
	fn clone(&self) -> Control { unsafe { Control { this: tsControl_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Control { }
impl fmt::Display for Control {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Control ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControl_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControl_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControl_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControl_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControl_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControl_new() -> *mut c_void;
	fn tsControl_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControl_new_Cff(parent: *const *mut c_void, width: f32, height: f32) -> *mut c_void;
	fn tsControl_delete(this: *mut c_void);
	fn tsControl_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControl_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControl_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControl_clearPtr(this: *const c_void);
	fn tsControl_destroyPtr(this: *const c_void);
	fn tsControl_acquirePtr(this: *const c_void);
	fn tsControl_unacquirePtr(this: *const c_void);
	fn tsControl_isValidPtr(this: *const c_void) -> i32;
	fn tsControl_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControl_isConstPtr(this: *const c_void) -> i32;
	fn tsControl_getCountPtr(this: *const c_void) -> u32;
	fn tsControl_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControl_getType(this: *const c_void) -> ControlType;
	fn tsControl_getTypeName_CT(type_: ControlType) -> *const c_char;
	fn tsControl_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsControl_isUnknown(this: *const c_void) -> i32;
	fn tsControl_isRoot(this: *const c_void) -> i32;
	fn tsControl_isText(this: *const c_void) -> i32;
	fn tsControl_isRect(this: *const c_void) -> i32;
	fn tsControl_isGrid(this: *const c_void) -> i32;
	fn tsControl_isGroup(this: *const c_void) -> i32;
	fn tsControl_isPanel(this: *const c_void) -> i32;
	fn tsControl_isDialog(this: *const c_void) -> i32;
	fn tsControl_isWindow(this: *const c_void) -> i32;
	fn tsControl_isCheck(this: *const c_void) -> i32;
	fn tsControl_isCombo(this: *const c_void) -> i32;
	fn tsControl_isButton(this: *const c_void) -> i32;
	fn tsControl_isSlider(this: *const c_void) -> i32;
	fn tsControl_isScroll(this: *const c_void) -> i32;
	fn tsControl_isSplit(this: *const c_void) -> i32;
	fn tsControl_isArea(this: *const c_void) -> i32;
	fn tsControl_isTree(this: *const c_void) -> i32;
	fn tsControl_isEdit(this: *const c_void) -> i32;
	fn tsControl_setAlign(this: *mut c_void, align: ControlAlign);
	fn tsControl_getAlign(this: *const c_void) -> ControlAlign;
	fn tsControl_hasAlign(this: *const c_void, align: ControlAlign) -> i32;
	fn tsControl_hasAligns(this: *const c_void, aligns: ControlAlign) -> i32;
	fn tsControl_isSpacer(this: *const c_void) -> i32;
	fn tsControl_setCreated(this: *mut c_void, created: i32);
	fn tsControl_isCreated(this: *const c_void) -> i32;
	fn tsControl_setEnabled(this: *mut c_void, enabled: i32);
	fn tsControl_isEnabled(this: *const c_void) -> i32;
	fn tsControl_wasEnabled(this: *const c_void) -> i32;
	fn tsControl_wasUpdated(this: *const c_void) -> i32;
	fn tsControl_setDisabled(this: *mut c_void, disabled: i32);
	fn tsControl_isDisabled(this: *const c_void) -> i32;
	fn tsControl_getCanvas(this: *const c_void) -> *mut c_void;
	fn tsControl_getRoot_c(this: *const c_void) -> *mut c_void;
	fn tsControl_getRoot(this: *mut c_void) -> *mut c_void;
	fn tsControl_getPanel_c(this: *const c_void) -> *mut c_void;
	fn tsControl_getPanel(this: *mut c_void) -> *mut c_void;
	fn tsControl_setParent(this: *mut c_void, parent: *mut c_void) -> u32;
	fn tsControl_getParent_c(this: *const c_void) -> *mut c_void;
	fn tsControl_getParent(this: *mut c_void) -> *mut c_void;
	fn tsControl_isParentEnabled(this: *const c_void) -> i32;
	fn tsControl_isParentDisabled(this: *const c_void) -> i32;
	fn tsControl_addChild(this: *mut c_void, child: *mut c_void) -> u32;
	fn tsControl_setChild(this: *mut c_void, index: u32, child: *mut c_void) -> *mut c_void;
	fn tsControl_raiseChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsControl_lowerChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsControl_removeChild(this: *mut c_void, child: *mut c_void) -> i32;
	fn tsControl_releaseChildren(this: *mut c_void);
	fn tsControl_findChild(this: *const c_void, child: *mut c_void) -> u32;
	fn tsControl_isChild(this: *const c_void, child: *mut c_void, hierarchy: i32) -> i32;
	fn tsControl_getNumChildren(this: *const c_void) -> u32;
	fn tsControl_getChild_cu(this: *const c_void, index: u32) -> *mut c_void;
	fn tsControl_getChild_u(this: *mut c_void, index: u32) -> *mut c_void;
	fn tsControl_setSize_cV2(this: *mut c_void, size: *const Vector2f);
	fn tsControl_setSize_ff(this: *mut c_void, width: f32, height: f32);
	fn tsControl_getSize(this: *const c_void) -> Vector2f;
	fn tsControl_getWidth(this: *const c_void) -> f32;
	fn tsControl_getHeight(this: *const c_void) -> f32;
	fn tsControl_setPosition_cV3(this: *mut c_void, position: *const Vector3f);
	fn tsControl_setPosition_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsControl_getPosition(this: *const c_void) -> Vector3f;
	fn tsControl_getPositionX(this: *const c_void) -> f32;
	fn tsControl_getPositionY(this: *const c_void) -> f32;
	fn tsControl_setOffset_cV3(this: *mut c_void, offset: *const Vector3f);
	fn tsControl_setOffset_fff(this: *mut c_void, x: f32, y: f32, z: f32);
	fn tsControl_getOffset(this: *const c_void) -> Vector3f;
	fn tsControl_getOffsetX(this: *const c_void) -> f32;
	fn tsControl_getOffsetY(this: *const c_void) -> f32;
	fn tsControl_setMargin_f(this: *mut c_void, value: f32);
	fn tsControl_setMargin_ff(this: *mut c_void, horizontal: f32, vertical: f32);
	fn tsControl_setMargin_ffff(this: *mut c_void, left: f32, right: f32, bottom: f32, top: f32);
	fn tsControl_setMargin_cR(this: *mut c_void, margin: *const Rect);
	fn tsControl_getMargin(this: *const c_void) -> Rect;
	fn tsControl_getRect(this: *const c_void) -> Rect;
	fn tsControl_getState(this: *const c_void) -> ControlState;
}

// Tellusim::ControlRoot
pub struct ControlRoot {
	this: *mut c_void,
	owner: bool,
}
type ControlRootCopyCallback = unsafe extern "C" fn(a0: *mut c_void, text: *const c_char, data_: *mut c_void);
unsafe extern "C" fn control_root_copy_callback_func<Func>(a0: *mut c_void, text: *const c_char, data_: *mut c_void) where Func: FnMut(ControlRoot, &str) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlRoot::new_ptr(a0);
	let text_ = get_cstring(text);
	func(a0_, &text_)
}
type ControlRootPasteCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void) -> *mut c_void;
unsafe extern "C" fn control_root_paste_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) -> *mut c_void where Func: FnMut(ControlRoot) -> string::String {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlRoot::new_ptr(a0);
	let ret = CString::new(func(a0_)).unwrap();
	tsString_new_su(ret.as_ptr(), MAXU32)
}
impl ControlRoot {
	pub fn null() -> ControlRoot { ControlRoot { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlRoot { unsafe { ControlRoot { this: tsControlRoot_new(), owner: true } } }
	pub fn new_with_canvas(canvas: &mut Canvas) -> ControlRoot { unsafe { ControlRoot { this: tsControlRoot_new_Cb(canvas.this, 0), owner: true } } }
	pub fn new_with_canvas_blob(canvas: &mut Canvas, blob: bool) -> ControlRoot { unsafe { ControlRoot { this: tsControlRoot_new_Cb(canvas.this, if blob {1} else {0}), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlRoot { unsafe { ControlRoot { this: ptr, owner: tsControlRoot_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlRoot { unsafe { ControlRoot { this: tsControlRoot_copyPtr(self.this), owner: true } } }
	pub fn from_control(ptr: &Control) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControlRoot_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRoot_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlRoot) -> bool { unsafe { tsControlRoot_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlRoot { unsafe { ControlRoot { this: tsControlRoot_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlRoot_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlRoot_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlRoot_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlRoot_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlRoot_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlRoot_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlRoot_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlRoot_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlRoot_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_viewport(&mut self, viewport: &Viewport) { unsafe { tsControlRoot_setViewport_cV(self.this, viewport) } }
	pub fn set_viewportu32(&mut self, width: u32, height: u32) { unsafe { tsControlRoot_setViewport_uu(self.this, width, height) } }
	pub fn set_viewportf32(&mut self, width: f32, height: f32) { unsafe { tsControlRoot_setViewport_ff(self.this, width, height) } }
	pub fn viewport(&self) -> Viewport { unsafe { tsControlRoot_getViewport(self.this) } }
	pub fn font_name(&self) -> string::String { unsafe { get_string(tsControlRoot_getFontName(self.this)) } }
	pub fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setFontName_s(self.this, name_.as_ptr()) }
	}
	pub fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlRoot_setFontName_cS(self.this, name.this) } }
	pub fn set_font_blob(&mut self, blob: *const *const u8) -> bool { unsafe { tsControlRoot_setFontBlob(self.this, blob, ptr::null_mut()) != 0 } }
	pub fn set_font_blob_with_name(&mut self, blob: *const *const u8, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setFontBlob(self.this, blob, name_.as_ptr()) != 0 }
	}
	pub fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlRoot_setFontSize(self.this, size, 0) != 0 } }
	pub fn set_font_size_with_update(&mut self, size: u32, update: bool) -> bool { unsafe { tsControlRoot_setFontSize(self.this, size, if update {1} else {0}) != 0 } }
	pub fn font_size(&self) -> u32 { unsafe { tsControlRoot_getFontSize(self.this) } }
	pub fn set_font_scale(&mut self, scale: u32) -> bool { unsafe { tsControlRoot_setFontScale(self.this, scale, 0) != 0 } }
	pub fn set_font_scale_with_update(&mut self, scale: u32, update: bool) -> bool { unsafe { tsControlRoot_setFontScale(self.this, scale, if update {1} else {0}) != 0 } }
	pub fn font_scale(&self) -> u32 { unsafe { tsControlRoot_getFontScale(self.this) } }
	pub fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlRoot_setFontStyle(self.this, style, 0) != 0 } }
	pub fn set_font_style_with_update(&mut self, style: &FontStyle, update: bool) -> bool { unsafe { tsControlRoot_setFontStyle(self.this, style, if update {1} else {0}) != 0 } }
	pub fn font_style(&self) -> FontStyle { unsafe { tsControlRoot_getFontStyle_c(self.this) } }
	pub fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlRoot_getFontStyle(self.this) } }
	pub fn texture_name(&self) -> string::String { unsafe { get_string(tsControlRoot_getTextureName(self.this)) } }
	pub fn set_texture_name(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureName_suuf(self.this, name_.as_ptr(), 0, 0, 0.0) != 0 }
	}
	pub fn set_texture_name_with_width(&mut self, name: &str, width: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureName_suuf(self.this, name_.as_ptr(), width, 0, 0.0) != 0 }
	}
	pub fn set_texture_name_with_width_height(&mut self, name: &str, width: u32, height: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureName_suuf(self.this, name_.as_ptr(), width, height, 0.0) != 0 }
	}
	pub fn set_texture_name_with_width_height_border(&mut self, name: &str, width: u32, height: u32, border: f32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureName_suuf(self.this, name_.as_ptr(), width, height, border) != 0 }
	}
	pub fn set_texture_name_with_name(&mut self, name: &String) -> bool { unsafe { tsControlRoot_setTextureName_cSuuf(self.this, name.this, 0, 0, 0.0) != 0 } }
	pub fn set_texture_name_with_name_width(&mut self, name: &String, width: u32) -> bool { unsafe { tsControlRoot_setTextureName_cSuuf(self.this, name.this, width, 0, 0.0) != 0 } }
	pub fn set_texture_name_with_name_width_height(&mut self, name: &String, width: u32, height: u32) -> bool { unsafe { tsControlRoot_setTextureName_cSuuf(self.this, name.this, width, height, 0.0) != 0 } }
	pub fn set_texture_name_with_name_width_height_border(&mut self, name: &String, width: u32, height: u32, border: f32) -> bool { unsafe { tsControlRoot_setTextureName_cSuuf(self.this, name.this, width, height, border) != 0 } }
	pub fn set_texture_blob(&mut self, blob: *const *const u8) -> bool { unsafe { tsControlRoot_setTextureBlob(self.this, blob, ptr::null_mut(), 0, 0, 0.0) != 0 } }
	pub fn set_texture_blob_with_name(&mut self, blob: *const *const u8, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureBlob(self.this, blob, name_.as_ptr(), 0, 0, 0.0) != 0 }
	}
	pub fn set_texture_blob_with_name_width(&mut self, blob: *const *const u8, name: &str, width: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureBlob(self.this, blob, name_.as_ptr(), width, 0, 0.0) != 0 }
	}
	pub fn set_texture_blob_with_name_width_height(&mut self, blob: *const *const u8, name: &str, width: u32, height: u32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureBlob(self.this, blob, name_.as_ptr(), width, height, 0.0) != 0 }
	}
	pub fn set_texture_blob_with_name_width_height_border(&mut self, blob: *const *const u8, name: &str, width: u32, height: u32, border: f32) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRoot_setTextureBlob(self.this, blob, name_.as_ptr(), width, height, border) != 0 }
	}
	pub fn texture_width(&self) -> f32 { unsafe { tsControlRoot_getTextureWidth(self.this) } }
	pub fn texture_height(&self) -> f32 { unsafe { tsControlRoot_getTextureHeight(self.this) } }
	pub fn set_text_color(&mut self, type_: ControlType, state: ControlState, color: &Color) { unsafe { tsControlRoot_setTextColor(self.this, type_, state, color) } }
	pub fn set_text_offset(&mut self, type_: ControlType, state: ControlState, offset: &Vector3f) { unsafe { tsControlRoot_setTextOffset(self.this, type_, state, offset) } }
	pub fn text_color(&self, type_: ControlType, state: ControlState) -> Color { unsafe { tsControlRoot_getTextColor(self.this, type_, state) } }
	pub fn text_offset(&self, type_: ControlType, state: ControlState) -> Vector3f { unsafe { tsControlRoot_getTextOffset(self.this, type_, state) } }
	pub fn set_mesh_color(&mut self, mesh: ControlMesh, state: ControlState, color: &Color) { unsafe { tsControlRoot_setMeshColor(self.this, mesh, state, color) } }
	pub fn set_mesh_region(&mut self, mesh: ControlMesh, grid: &Rect, region: &Rect, border: &Vector2f) { unsafe { tsControlRoot_setMeshRegion(self.this, mesh, grid, region, border) } }
	pub fn set_mesh_regions(&mut self, mesh: ControlMesh, grid: &Rect, regions: &Rect, border: &Vector2f) { unsafe { tsControlRoot_setMeshRegions(self.this, mesh, grid, regions, border) } }
	pub fn mesh_color(&self, mesh: ControlMesh, state: ControlState) -> u32 { unsafe { tsControlRoot_getMeshColor(self.this, mesh, state) } }
	pub fn mesh_grid(&self, mesh: ControlMesh) -> Rect { unsafe { tsControlRoot_getMeshGrid(self.this, mesh) } }
	pub fn mesh_margin(&self, mesh: ControlMesh) -> Rect { unsafe { tsControlRoot_getMeshMargin(self.this, mesh) } }
	pub fn mesh_region(&self, mesh: ControlMesh, state: ControlState) -> Rect { unsafe { tsControlRoot_getMeshRegion(self.this, mesh, state) } }
	pub fn set_group_radius(&mut self, radius: f32) { unsafe { tsControlRoot_setGroupRadius(self.this, radius) } }
	pub fn set_group_color(&mut self, color: &Color) { unsafe { tsControlRoot_setGroupColor(self.this, color) } }
	pub fn group_radius(&self) -> f32 { unsafe { tsControlRoot_getGroupRadius(self.this) } }
	pub fn group_color(&self) -> Color { unsafe { tsControlRoot_getGroupColor(self.this) } }
	pub fn set_panel_radius(&mut self, radius: f32) { unsafe { tsControlRoot_setPanelRadius(self.this, radius) } }
	pub fn set_panel_color(&mut self, color: &Color) { unsafe { tsControlRoot_setPanelColor(self.this, color) } }
	pub fn panel_radius(&self) -> f32 { unsafe { tsControlRoot_getPanelRadius(self.this) } }
	pub fn panel_color(&self) -> Color { unsafe { tsControlRoot_getPanelColor(self.this) } }
	pub fn set_checked_color(&mut self, color: &Color) { unsafe { tsControlRoot_setCheckedColor(self.this, color) } }
	pub fn checked_color(&self) -> Color { unsafe { tsControlRoot_getCheckedColor(self.this) } }
	pub fn set_split_size(&mut self, size: f32) { unsafe { tsControlRoot_setSplitSize(self.this, size) } }
	pub fn split_size(&self) -> f32 { unsafe { tsControlRoot_getSplitSize(self.this) } }
	pub fn set_mouse(&mut self, x: i32, y: i32, buttons: ControlButtons) { unsafe { tsControlRoot_setMouse_iiCB(self.this, x, y, buttons) } }
	pub fn set_mousef32(&mut self, x: f32, y: f32, buttons: ControlButtons) { unsafe { tsControlRoot_setMouse_ffCB(self.this, x, y, buttons) } }
	pub fn mouse(&self) -> Vector2f { unsafe { tsControlRoot_getMouse(self.this) } }
	pub fn mouse_buttons(&self) -> ControlButtons { unsafe { tsControlRoot_getMouseButtons(self.this) } }
	pub fn mouse_x(&self) -> f32 { unsafe { tsControlRoot_getMouseX(self.this) } }
	pub fn mouse_y(&self) -> f32 { unsafe { tsControlRoot_getMouseY(self.this) } }
	pub fn set_mouse_offset(&mut self, offset: &Vector2f) { unsafe { tsControlRoot_setMouseOffset(self.this, offset) } }
	pub fn mouse_offset(&self) -> Vector2f { unsafe { tsControlRoot_getMouseOffset(self.this) } }
	pub fn set_mouse_axis(&mut self, axis: ControlAxis, delta: f32) { unsafe { tsControlRoot_setMouseAxis(self.this, axis, delta) } }
	pub fn set_mouse_align(&mut self, align: ControlAlign) { unsafe { tsControlRoot_setMouseAlign(self.this, align, 1) } }
	pub fn set_mouse_align_with_clear(&mut self, align: ControlAlign, clear: bool) { unsafe { tsControlRoot_setMouseAlign(self.this, align, if clear {1} else {0}) } }
	pub fn mouse_align(&self) -> ControlAlign { unsafe { tsControlRoot_getMouseAlign(self.this) } }
	pub fn has_mouse_align(&self, align: ControlAlign) -> bool { unsafe { tsControlRoot_hasMouseAlign(self.this, align) != 0 } }
	pub fn has_mouse_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlRoot_hasMouseAligns(self.this, aligns) != 0 } }
	pub fn set_keyboard_key(&mut self, key: u32, code: u32, value: bool) -> bool { unsafe { tsControlRoot_setKeyboardKey(self.this, key, code, if value {1} else {0}) != 0 } }
	pub fn keyboard_key(&mut self, key: u32) -> bool { unsafe { tsControlRoot_getKeyboardKey(self.this, key, 0) != 0 } }
	pub fn keyboard_key_with_clear(&mut self, key: u32, clear: bool) -> bool { unsafe { tsControlRoot_getKeyboardKey(self.this, key, if clear {1} else {0}) != 0 } }
	pub fn clear_current_control(&mut self) { unsafe { tsControlRoot_clearCurrentControl(self.this) } }
	pub fn set_current_control(&mut self, control: &mut Control) { unsafe { tsControlRoot_setCurrentControl(self.this, control.this, 0) } }
	pub fn set_current_control_with_grab(&mut self, control: &mut Control, grab: bool) { unsafe { tsControlRoot_setCurrentControl(self.this, control.this, if grab {1} else {0}) } }
	pub fn current_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRoot_getCurrentControl(self.this)) } }
	pub fn is_current_control(&self) -> bool { unsafe { tsControlRoot_isCurrentControl(self.this) != 0 } }
	pub fn control_grab(&self) -> bool { unsafe { tsControlRoot_getControlGrab(self.this) != 0 } }
	pub fn clear_focused_control(&mut self) { unsafe { tsControlRoot_clearFocusedControl(self.this) } }
	pub fn set_focused_control(&mut self, control: &mut Control) { unsafe { tsControlRoot_setFocusedControl(self.this, control.this) } }
	pub fn focused_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRoot_getFocusedControl(self.this)) } }
	pub fn is_focused_control(&self) -> bool { unsafe { tsControlRoot_isFocusedControl(self.this) != 0 } }
	pub fn clear_mouse_control(&mut self) { unsafe { tsControlRoot_clearMouseControl(self.this) } }
	pub fn set_mouse_control(&mut self, control: &mut Control) { unsafe { tsControlRoot_setMouseControl(self.this, control.this) } }
	pub fn mouse_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRoot_getMouseControl(self.this)) } }
	pub fn is_mouse_control(&self) -> bool { unsafe { tsControlRoot_isMouseControl(self.this) != 0 } }
	pub fn clear_input_control(&mut self) { unsafe { tsControlRoot_clearInputControl(self.this) } }
	pub fn set_input_control(&mut self, control: &mut Control) { unsafe { tsControlRoot_setInputControl(self.this, control.this) } }
	pub fn input_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRoot_getInputControl(self.this)) } }
	pub fn is_input_control(&self) -> bool { unsafe { tsControlRoot_isInputControl(self.this) != 0 } }
	pub fn clear_modal_control(&mut self) { unsafe { tsControlRoot_clearModalControl(self.this) } }
	pub fn set_modal_control(&mut self, control: &mut Control) { unsafe { tsControlRoot_setModalControl(self.this, control.this, 1) } }
	pub fn set_modal_control_with_disabled(&mut self, control: &mut Control, disabled: bool) { unsafe { tsControlRoot_setModalControl(self.this, control.this, if disabled {1} else {0}) } }
	pub fn modal_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRoot_getModalControl(self.this)) } }
	pub fn is_modal_disabled(&self) -> bool { unsafe { tsControlRoot_isModalDisabled(self.this) != 0 } }
	pub fn is_modal_control(&self) -> bool { unsafe { tsControlRoot_isModalControl(self.this) != 0 } }
	pub fn set_overlay_order(&mut self, order: i32) { unsafe { tsControlRoot_setOverlayOrder(self.this, order) } }
	pub fn overlay_order(&self) -> i32 { unsafe { tsControlRoot_getOverlayOrder(self.this) } }
	pub fn update(&mut self) -> bool { unsafe { tsControlRoot_update(self.this, 0, 0) != 0 } }
	pub fn update_with_scale(&mut self, scale: u32) -> bool { unsafe { tsControlRoot_update(self.this, scale, 0) != 0 } }
	pub fn update_with_scale_order(&mut self, scale: u32, order: i32) -> bool { unsafe { tsControlRoot_update(self.this, scale, order) != 0 } }
	pub fn set_copy_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlRoot_setCopyText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_copy_text_with_text(&mut self, text: &String) { unsafe { tsControlRoot_setCopyText_cS(self.this, text.this) } }
	pub fn paste_text(&mut self) -> string::String { unsafe { get_string(tsControlRoot_getPasteText(self.this)) } }
	pub fn set_copy_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRoot, &str) {
		let func = Box::leak(Box::new(func));
		let func_ = control_root_copy_callback_func::<Func>;
		unsafe { tsControlRoot_setCopyCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_paste_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRoot) -> string::String {
		let func = Box::leak(Box::new(func));
		let func_ = control_root_paste_callback_func::<Func>;
		unsafe { tsControlRoot_setPasteCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
}
impl ControlTrait for ControlRoot {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlRoot {
	fn drop(&mut self) { if self.owner { unsafe { tsControlRoot_delete(self.this) } } }
}
impl Clone for ControlRoot {
	fn clone(&self) -> ControlRoot { unsafe { ControlRoot { this: tsControlRoot_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlRoot { }
impl fmt::Display for ControlRoot {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlRoot ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlRoot_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlRoot_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlRoot_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlRoot_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlRoot_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlRoot_new() -> *mut c_void;
	fn tsControlRoot_new_Cb(canvas: *mut c_void, blob: i32) -> *mut c_void;
	fn tsControlRoot_delete(this: *mut c_void);
	fn tsControlRoot_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlRoot_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_clearPtr(this: *const c_void);
	fn tsControlRoot_destroyPtr(this: *const c_void);
	fn tsControlRoot_acquirePtr(this: *const c_void);
	fn tsControlRoot_unacquirePtr(this: *const c_void);
	fn tsControlRoot_isValidPtr(this: *const c_void) -> i32;
	fn tsControlRoot_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlRoot_isConstPtr(this: *const c_void) -> i32;
	fn tsControlRoot_getCountPtr(this: *const c_void) -> u32;
	fn tsControlRoot_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_equalControlPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlRoot_castControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_baseControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_setViewport_cV(this: *mut c_void, viewport: *const Viewport);
	fn tsControlRoot_setViewport_uu(this: *mut c_void, width: u32, height: u32);
	fn tsControlRoot_setViewport_ff(this: *mut c_void, width: f32, height: f32);
	fn tsControlRoot_getViewport(this: *const c_void) -> Viewport;
	fn tsControlRoot_getFontName(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_setFontName_s(this: *mut c_void, name: *const c_char);
	fn tsControlRoot_setFontName_cS(this: *mut c_void, name: *mut c_void);
	fn tsControlRoot_setFontBlob(this: *mut c_void, blob: *const *const u8, name: *const c_char) -> i32;
	fn tsControlRoot_setFontSize(this: *mut c_void, size: u32, update: i32) -> i32;
	fn tsControlRoot_getFontSize(this: *const c_void) -> u32;
	fn tsControlRoot_setFontScale(this: *mut c_void, scale: u32, update: i32) -> i32;
	fn tsControlRoot_getFontScale(this: *const c_void) -> u32;
	fn tsControlRoot_setFontStyle(this: *mut c_void, style: *const FontStyle, update: i32) -> i32;
	fn tsControlRoot_getFontStyle_c(this: *const c_void) -> FontStyle;
	fn tsControlRoot_getFontStyle(this: *mut c_void) -> FontStyle;
	fn tsControlRoot_getTextureName(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_setTextureName_suuf(this: *mut c_void, name: *const c_char, width: u32, height: u32, border: f32) -> i32;
	fn tsControlRoot_setTextureName_cSuuf(this: *mut c_void, name: *mut c_void, width: u32, height: u32, border: f32) -> i32;
	fn tsControlRoot_setTextureBlob(this: *mut c_void, blob: *const *const u8, name: *const c_char, width: u32, height: u32, border: f32) -> i32;
	fn tsControlRoot_getTextureWidth(this: *const c_void) -> f32;
	fn tsControlRoot_getTextureHeight(this: *const c_void) -> f32;
	fn tsControlRoot_setTextColor(this: *mut c_void, type_: ControlType, state: ControlState, color: *const Color);
	fn tsControlRoot_setTextOffset(this: *mut c_void, type_: ControlType, state: ControlState, offset: *const Vector3f);
	fn tsControlRoot_getTextColor(this: *const c_void, type_: ControlType, state: ControlState) -> Color;
	fn tsControlRoot_getTextOffset(this: *const c_void, type_: ControlType, state: ControlState) -> Vector3f;
	fn tsControlRoot_setMeshColor(this: *mut c_void, mesh: ControlMesh, state: ControlState, color: *const Color);
	fn tsControlRoot_setMeshRegion(this: *mut c_void, mesh: ControlMesh, grid: *const Rect, region: *const Rect, border: *const Vector2f);
	fn tsControlRoot_setMeshRegions(this: *mut c_void, mesh: ControlMesh, grid: *const Rect, regions: *const Rect, border: *const Vector2f);
	fn tsControlRoot_getMeshColor(this: *const c_void, mesh: ControlMesh, state: ControlState) -> u32;
	fn tsControlRoot_getMeshGrid(this: *const c_void, mesh: ControlMesh) -> Rect;
	fn tsControlRoot_getMeshMargin(this: *const c_void, mesh: ControlMesh) -> Rect;
	fn tsControlRoot_getMeshRegion(this: *const c_void, mesh: ControlMesh, state: ControlState) -> Rect;
	fn tsControlRoot_setGroupRadius(this: *mut c_void, radius: f32);
	fn tsControlRoot_setGroupColor(this: *mut c_void, color: *const Color);
	fn tsControlRoot_getGroupRadius(this: *const c_void) -> f32;
	fn tsControlRoot_getGroupColor(this: *const c_void) -> Color;
	fn tsControlRoot_setPanelRadius(this: *mut c_void, radius: f32);
	fn tsControlRoot_setPanelColor(this: *mut c_void, color: *const Color);
	fn tsControlRoot_getPanelRadius(this: *const c_void) -> f32;
	fn tsControlRoot_getPanelColor(this: *const c_void) -> Color;
	fn tsControlRoot_setCheckedColor(this: *mut c_void, color: *const Color);
	fn tsControlRoot_getCheckedColor(this: *const c_void) -> Color;
	fn tsControlRoot_setSplitSize(this: *mut c_void, size: f32);
	fn tsControlRoot_getSplitSize(this: *const c_void) -> f32;
	fn tsControlRoot_setMouse_iiCB(this: *mut c_void, x: i32, y: i32, buttons: ControlButtons);
	fn tsControlRoot_setMouse_ffCB(this: *mut c_void, x: f32, y: f32, buttons: ControlButtons);
	fn tsControlRoot_getMouse(this: *const c_void) -> Vector2f;
	fn tsControlRoot_getMouseButtons(this: *const c_void) -> ControlButtons;
	fn tsControlRoot_getMouseX(this: *const c_void) -> f32;
	fn tsControlRoot_getMouseY(this: *const c_void) -> f32;
	fn tsControlRoot_setMouseOffset(this: *mut c_void, offset: *const Vector2f);
	fn tsControlRoot_getMouseOffset(this: *const c_void) -> Vector2f;
	fn tsControlRoot_setMouseAxis(this: *mut c_void, axis: ControlAxis, delta: f32);
	fn tsControlRoot_setMouseAlign(this: *mut c_void, align: ControlAlign, clear: i32);
	fn tsControlRoot_getMouseAlign(this: *const c_void) -> ControlAlign;
	fn tsControlRoot_hasMouseAlign(this: *const c_void, align: ControlAlign) -> i32;
	fn tsControlRoot_hasMouseAligns(this: *const c_void, aligns: ControlAlign) -> i32;
	fn tsControlRoot_setKeyboardKey(this: *mut c_void, key: u32, code: u32, value: i32) -> i32;
	fn tsControlRoot_getKeyboardKey(this: *mut c_void, key: u32, clear: i32) -> i32;
	fn tsControlRoot_clearCurrentControl(this: *mut c_void);
	fn tsControlRoot_setCurrentControl(this: *mut c_void, control: *mut c_void, grab: i32);
	fn tsControlRoot_getCurrentControl(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_isCurrentControl(this: *const c_void) -> i32;
	fn tsControlRoot_getControlGrab(this: *const c_void) -> i32;
	fn tsControlRoot_clearFocusedControl(this: *mut c_void);
	fn tsControlRoot_setFocusedControl(this: *mut c_void, control: *mut c_void);
	fn tsControlRoot_getFocusedControl(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_isFocusedControl(this: *const c_void) -> i32;
	fn tsControlRoot_clearMouseControl(this: *mut c_void);
	fn tsControlRoot_setMouseControl(this: *mut c_void, control: *mut c_void);
	fn tsControlRoot_getMouseControl(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_isMouseControl(this: *const c_void) -> i32;
	fn tsControlRoot_clearInputControl(this: *mut c_void);
	fn tsControlRoot_setInputControl(this: *mut c_void, control: *mut c_void);
	fn tsControlRoot_getInputControl(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_isInputControl(this: *const c_void) -> i32;
	fn tsControlRoot_clearModalControl(this: *mut c_void);
	fn tsControlRoot_setModalControl(this: *mut c_void, control: *mut c_void, disabled: i32);
	fn tsControlRoot_getModalControl(this: *const c_void) -> *mut c_void;
	fn tsControlRoot_isModalDisabled(this: *const c_void) -> i32;
	fn tsControlRoot_isModalControl(this: *const c_void) -> i32;
	fn tsControlRoot_setOverlayOrder(this: *mut c_void, order: i32);
	fn tsControlRoot_getOverlayOrder(this: *const c_void) -> i32;
	fn tsControlRoot_update(this: *mut c_void, scale: u32, order: i32) -> i32;
	fn tsControlRoot_setCopyText_s(this: *mut c_void, text: *const c_char);
	fn tsControlRoot_setCopyText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlRoot_getPasteText(this: *mut c_void) -> *mut c_void;
	fn tsControlRoot_setCopyCallback(this: *mut c_void, func: ControlRootCopyCallback, data_: *mut c_void);
	fn tsControlRoot_setPasteCallback(this: *mut c_void, func: ControlRootPasteCallback, data_: *mut c_void);
}

// Tellusim::ControlText
pub struct ControlText {
	this: *mut c_void,
	owner: bool,
}
impl ControlText {
	pub fn null() -> ControlText { ControlText { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlText { unsafe { ControlText { this: tsControlText_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlText { unsafe { ControlText { this: tsControlText_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_text(parent: Option<&Control>, text: &str) -> ControlText {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlText { this: tsControlText_new_Cs(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_texts(parent: Option<&Control>, text: &String) -> ControlText { unsafe { ControlText { this: tsControlText_new_CcS(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlText { unsafe { ControlText { this: ptr, owner: tsControlText_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlText { unsafe { ControlText { this: tsControlText_copyPtr(self.this), owner: true } } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlText) -> bool { unsafe { tsControlText_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlText { unsafe { ControlText { this: tsControlText_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlText_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlText_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlText_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlText_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlText_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlText_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlText_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlText_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlText_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ControlTextTrait {
	fn set_mode(&mut self, mode: CanvasElementMode);
	fn mode(&self) -> CanvasElementMode;
	fn set_pipeline(&mut self, pipeline: &mut Pipeline);
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool;
	fn pipeline(&self) -> Pipeline;
	fn set_color(&mut self, color: &Color);
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32);
	fn color(&self) -> Color;
	fn set_filter(&mut self, filter: SamplerFilter);
	fn filter(&self) -> SamplerFilter;
	fn set_anisotropy(&mut self, anisotropy: u32);
	fn anisotropy(&self) -> u32;
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn blend_op(&self) -> PipelineBlendOp;
	fn blend_src_func(&self) -> PipelineBlendFunc;
	fn blend_dest_func(&self) -> PipelineBlendFunc;
	fn set_font_name(&mut self, name: &str);
	fn set_font_name_with_name(&mut self, name: &String);
	fn font_name(&self) -> string::String;
	fn set_font_color(&mut self, color: &Color);
	fn font_color(&self) -> Color;
	fn set_font_size(&mut self, size: u32) -> bool;
	fn font_size(&self) -> u32;
	fn set_font_style(&mut self, style: &FontStyle) -> bool;
	fn font_style_const(&self) -> FontStyle;
	fn font_style(&self) -> FontStyle;
	fn font_style_mut(&mut self) -> FontStyle;
	fn set_font_align(&mut self, align: ControlAlign);
	fn font_align(&self) -> ControlAlign;
	fn has_font_align(&self, align: ControlAlign) -> bool;
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool;
	fn set_text(&mut self, text: &str);
	fn set_text_with_text(&mut self, text: &String);
	fn text(&self) -> string::String;
	fn canvas_text(&mut self) -> CanvasText;
}
impl ControlTextTrait for ControlText {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlText {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlText {
	fn drop(&mut self) { if self.owner { unsafe { tsControlText_delete(self.this) } } }
}
impl Clone for ControlText {
	fn clone(&self) -> ControlText { unsafe { ControlText { this: tsControlText_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlText { }
impl fmt::Display for ControlText {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlText ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlText_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlText_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlText_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlText_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlText_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlText_new() -> *mut c_void;
	fn tsControlText_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlText_new_Cs(parent: *const *mut c_void, text: *const c_char) -> *mut c_void;
	fn tsControlText_new_CcS(parent: *const *mut c_void, text: *mut c_void) -> *mut c_void;
	fn tsControlText_delete(this: *mut c_void);
	fn tsControlText_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlText_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlText_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlText_clearPtr(this: *const c_void);
	fn tsControlText_destroyPtr(this: *const c_void);
	fn tsControlText_acquirePtr(this: *const c_void);
	fn tsControlText_unacquirePtr(this: *const c_void);
	fn tsControlText_isValidPtr(this: *const c_void) -> i32;
	fn tsControlText_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlText_isConstPtr(this: *const c_void) -> i32;
	fn tsControlText_getCountPtr(this: *const c_void) -> u32;
	fn tsControlText_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlText_equalControlPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlText_castControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlText_baseControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlText_setMode(this: *mut c_void, mode: CanvasElementMode);
	fn tsControlText_getMode(this: *const c_void) -> CanvasElementMode;
	fn tsControlText_setPipeline_P(this: *mut c_void, pipeline: *mut c_void);
	fn tsControlText_setPipeline_PcCEDC(this: *mut c_void, pipeline: *mut c_void, func: CanvasElementDrawCallback, data_: *mut c_void);
	fn tsControlText_getPipeline(this: *const c_void) -> *mut c_void;
	fn tsControlText_setColor_cC(this: *mut c_void, color: *const Color);
	fn tsControlText_setColor_ffff(this: *mut c_void, r: f32, g: f32, b: f32, a: f32);
	fn tsControlText_getColor(this: *const c_void) -> Color;
	fn tsControlText_setFilter(this: *mut c_void, filter: SamplerFilter);
	fn tsControlText_getFilter(this: *const c_void) -> SamplerFilter;
	fn tsControlText_setAnisotropy(this: *mut c_void, anisotropy: u32);
	fn tsControlText_getAnisotropy(this: *const c_void) -> u32;
	fn tsControlText_setBlend(this: *mut c_void, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsControlText_getBlendOp(this: *const c_void) -> PipelineBlendOp;
	fn tsControlText_getBlendSrcFunc(this: *const c_void) -> PipelineBlendFunc;
	fn tsControlText_getBlendDestFunc(this: *const c_void) -> PipelineBlendFunc;
	fn tsControlText_setFontName_s(this: *mut c_void, name: *const c_char);
	fn tsControlText_setFontName_cS(this: *mut c_void, name: *mut c_void);
	fn tsControlText_getFontName(this: *const c_void) -> *mut c_void;
	fn tsControlText_setFontColor(this: *mut c_void, color: *const Color);
	fn tsControlText_getFontColor(this: *const c_void) -> Color;
	fn tsControlText_setFontSize(this: *mut c_void, size: u32) -> i32;
	fn tsControlText_getFontSize(this: *const c_void) -> u32;
	fn tsControlText_setFontStyle(this: *mut c_void, style: *const FontStyle) -> i32;
	fn tsControlText_getFontStyleConst(this: *const c_void) -> FontStyle;
	fn tsControlText_getFontStyle_c(this: *const c_void) -> FontStyle;
	fn tsControlText_getFontStyle(this: *mut c_void) -> FontStyle;
	fn tsControlText_setFontAlign(this: *mut c_void, align: ControlAlign);
	fn tsControlText_getFontAlign(this: *const c_void) -> ControlAlign;
	fn tsControlText_hasFontAlign(this: *const c_void, align: ControlAlign) -> i32;
	fn tsControlText_hasFontAligns(this: *const c_void, aligns: ControlAlign) -> i32;
	fn tsControlText_setText_s(this: *mut c_void, text: *const c_char);
	fn tsControlText_setText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlText_getText(this: *const c_void) -> *mut c_void;
	fn tsControlText_getCanvasText(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlRect
pub struct ControlRect {
	this: *mut c_void,
	owner: bool,
}
type ControlRectInsideCallback = unsafe extern "C" fn(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void) -> i32;
unsafe extern "C" fn control_rect_inside_callback_func<Func>(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void) -> i32 where Func: FnMut(ControlRect, f32, f32) -> bool {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlRect::new_ptr(a0);
	if func(a0_, x, y) {1} else {0}
}
type ControlRectPressedCallback = unsafe extern "C" fn(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void);
unsafe extern "C" fn control_rect_pressed_callback_func<Func>(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void) where Func: FnMut(ControlRect, f32, f32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlRect::new_ptr(a0);
	func(a0_, x, y)
}
type ControlRectReleasedCallback = unsafe extern "C" fn(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void);
unsafe extern "C" fn control_rect_released_callback_func<Func>(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void) where Func: FnMut(ControlRect, f32, f32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlRect::new_ptr(a0);
	func(a0_, x, y)
}
type ControlRectClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_rect_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlRect) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlRect::new_ptr(a0);
	func(a0_)
}
impl ControlRect {
	pub fn null() -> ControlRect { ControlRect { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlRect { unsafe { ControlRect { this: tsControlRect_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlRect { unsafe { ControlRect { this: tsControlRect_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_texture(parent: Option<&Control>, texture: &mut Texture) -> ControlRect { unsafe { ControlRect { this: tsControlRect_new_CT(match parent { Some(parent) => &parent.this, None => ptr::null() }, texture.this), owner: true } } }
	pub fn new_with_parent_name(parent: Option<&Control>, name: &str) -> ControlRect {
		let name_ = CString::new(name).unwrap();
		unsafe { ControlRect { this: tsControlRect_new_Cs(match parent { Some(parent) => &parent.this, None => ptr::null() }, name_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_mode(parent: Option<&Control>, mode: CanvasElementMode) -> ControlRect { unsafe { ControlRect { this: tsControlRect_new_CCEM(match parent { Some(parent) => &parent.this, None => ptr::null() }, mode), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlRect { unsafe { ControlRect { this: ptr, owner: tsControlRect_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlRect { unsafe { ControlRect { this: tsControlRect_copyPtr(self.this), owner: true } } }
	pub fn from_control(ptr: &Control) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlRect_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRect_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlRect) -> bool { unsafe { tsControlRect_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlRect { unsafe { ControlRect { this: tsControlRect_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlRect_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlRect_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlRect_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlRect_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlRect_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlRect_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlRect_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlRect_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlRect_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ControlRectTrait {
	fn set_callback(&mut self, callback: bool);
	fn callback(&self) -> bool;
	fn set_fullscreen(&mut self, fullscreen: bool);
	fn is_fullscreen(&self) -> bool;
	fn set_mode(&mut self, mode: CanvasElementMode);
	fn mode(&self) -> CanvasElementMode;
	fn set_pipeline(&mut self, pipeline: &mut Pipeline);
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool;
	fn pipeline(&self) -> Pipeline;
	fn set_radius(&mut self, radius: f32);
	fn radius(&self) -> f32;
	fn set_color(&mut self, color: &Color);
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32);
	fn color(&self) -> Color;
	fn set_stroke_style(&mut self, style: &StrokeStyle);
	fn stroke_style_const(&self) -> StrokeStyle;
	fn stroke_style(&self) -> StrokeStyle;
	fn stroke_style_mut(&mut self) -> StrokeStyle;
	fn set_gradient_style(&mut self, style: &GradientStyle);
	fn gradient_style_const(&self) -> GradientStyle;
	fn gradient_style(&self) -> GradientStyle;
	fn gradient_style_mut(&mut self) -> GradientStyle;
	fn set_mipmap(&mut self, mipmap: f32);
	fn mipmap(&self) -> f32;
	fn set_filter(&mut self, filter: SamplerFilter);
	fn filter(&self) -> SamplerFilter;
	fn set_anisotropy(&mut self, anisotropy: u32);
	fn anisotropy(&self) -> u32;
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode);
	fn wrap_mode(&self) -> SamplerWrapMode;
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn blend_op(&self) -> PipelineBlendOp;
	fn blend_src_func(&self) -> PipelineBlendFunc;
	fn blend_dest_func(&self) -> PipelineBlendFunc;
	fn set_texture(&mut self, texture: &mut Texture);
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool);
	fn texture(&self) -> Texture;
	fn texture_linear(&self) -> bool;
	fn set_texture_name(&mut self, name: &str);
	fn set_texture_name_with_name(&mut self, name: &String);
	fn texture_name(&self) -> string::String;
	fn set_texture_scale(&mut self, scale_x: f32, scale_y: f32);
	fn texture_scale_x(&self) -> f32;
	fn texture_scale_y(&self) -> f32;
	fn set_texture_flip(&mut self, flip_x: bool, flip_y: bool);
	fn texture_flip_x(&self) -> bool;
	fn texture_flip_y(&self) -> bool;
	fn set_texture_proj(&mut self, projection: bool);
	fn texture_proj(&self) -> bool;
	fn set_tex_coord(&mut self, texcoord: &Rect);
	fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32);
	fn tex_coord(&self) -> Rect;
	fn set_inside_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) -> bool;
	fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32);
	fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32);
	fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect);
	fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect);
	fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect);
	fn canvas_rect(&mut self) -> CanvasRect;
	fn canvas_mesh(&mut self) -> CanvasMesh;
}
impl ControlRectTrait for ControlRect {
	fn set_callback(&mut self, callback: bool) { unsafe { tsControlRect_setCallback(self.this, if callback {1} else {0}) } }
	fn callback(&self) -> bool { unsafe { tsControlRect_getCallback(self.this) != 0 } }
	fn set_fullscreen(&mut self, fullscreen: bool) { unsafe { tsControlRect_setFullscreen(self.this, if fullscreen {1} else {0}) } }
	fn is_fullscreen(&self) -> bool { unsafe { tsControlRect_isFullscreen(self.this) != 0 } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlRect_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlRect_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlRect_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlRect_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlRect_getPipeline(self.this)) } }
	fn set_radius(&mut self, radius: f32) { unsafe { tsControlRect_setRadius(self.this, radius) } }
	fn radius(&self) -> f32 { unsafe { tsControlRect_getRadius(self.this) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlRect_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlRect_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlRect_getColor(self.this) } }
	fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsControlRect_setStrokeStyle(self.this, style) } }
	fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyleConst(self.this) } }
	fn stroke_style(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle_c(self.this) } }
	fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle(self.this) } }
	fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsControlRect_setGradientStyle(self.this, style) } }
	fn gradient_style_const(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyleConst(self.this) } }
	fn gradient_style(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle_c(self.this) } }
	fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsControlRect_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsControlRect_getMipmap(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlRect_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlRect_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlRect_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlRect_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsControlRect_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsControlRect_getWrapMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlRect_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlRect_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendDestFunc(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsControlRect_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsControlRect_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsControlRect_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsControlRect_getTextureLinear(self.this) != 0 } }
	fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRect_setTextureName_s(self.this, name_.as_ptr()) }
	}
	fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsControlRect_setTextureName_cS(self.this, name.this) } }
	fn texture_name(&self) -> string::String { unsafe { get_string(tsControlRect_getTextureName(self.this)) } }
	fn set_texture_scale(&mut self, scale_x: f32, scale_y: f32) { unsafe { tsControlRect_setTextureScale(self.this, scale_x, scale_y) } }
	fn texture_scale_x(&self) -> f32 { unsafe { tsControlRect_getTextureScaleX(self.this) } }
	fn texture_scale_y(&self) -> f32 { unsafe { tsControlRect_getTextureScaleY(self.this) } }
	fn set_texture_flip(&mut self, flip_x: bool, flip_y: bool) { unsafe { tsControlRect_setTextureFlip(self.this, if flip_x {1} else {0}, if flip_y {1} else {0}) } }
	fn texture_flip_x(&self) -> bool { unsafe { tsControlRect_getTextureFlipX(self.this) != 0 } }
	fn texture_flip_y(&self) -> bool { unsafe { tsControlRect_getTextureFlipY(self.this) != 0 } }
	fn set_texture_proj(&mut self, projection: bool) { unsafe { tsControlRect_setTextureProj(self.this, if projection {1} else {0}) } }
	fn texture_proj(&self) -> bool { unsafe { tsControlRect_getTextureProj(self.this) != 0 } }
	fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsControlRect_setTexCoord_cR(self.this, texcoord) } }
	fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControlRect_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	fn tex_coord(&self) -> Rect { unsafe { tsControlRect_getTexCoord(self.this) } }
	fn set_inside_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_inside_callback_func::<Func>;
		unsafe { tsControlRect_setInsideCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_pressed_callback_func::<Func>;
		unsafe { tsControlRect_setPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_released_callback_func::<Func>;
		unsafe { tsControlRect_setReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClicked2Callback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedRightCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn canvas_rect(&mut self) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsControlRect_getCanvasRect(self.this)) } }
	fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlRect_getCanvasMesh(self.this)) } }
}
impl ControlTrait for ControlRect {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlRect {
	fn drop(&mut self) { if self.owner { unsafe { tsControlRect_delete(self.this) } } }
}
impl Clone for ControlRect {
	fn clone(&self) -> ControlRect { unsafe { ControlRect { this: tsControlRect_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlRect { }
impl fmt::Display for ControlRect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlRect ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlRect_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlRect_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlRect_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlRect_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlRect_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlRect_new() -> *mut c_void;
	fn tsControlRect_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlRect_new_CT(parent: *const *mut c_void, texture: *mut c_void) -> *mut c_void;
	fn tsControlRect_new_Cs(parent: *const *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsControlRect_new_CCEM(parent: *const *mut c_void, mode: CanvasElementMode) -> *mut c_void;
	fn tsControlRect_delete(this: *mut c_void);
	fn tsControlRect_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlRect_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRect_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlRect_clearPtr(this: *const c_void);
	fn tsControlRect_destroyPtr(this: *const c_void);
	fn tsControlRect_acquirePtr(this: *const c_void);
	fn tsControlRect_unacquirePtr(this: *const c_void);
	fn tsControlRect_isValidPtr(this: *const c_void) -> i32;
	fn tsControlRect_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlRect_isConstPtr(this: *const c_void) -> i32;
	fn tsControlRect_getCountPtr(this: *const c_void) -> u32;
	fn tsControlRect_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRect_equalControlPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlRect_castControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRect_baseControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlRect_setCallback(this: *mut c_void, callback: i32);
	fn tsControlRect_getCallback(this: *const c_void) -> i32;
	fn tsControlRect_setFullscreen(this: *mut c_void, fullscreen: i32);
	fn tsControlRect_isFullscreen(this: *const c_void) -> i32;
	fn tsControlRect_setMode(this: *mut c_void, mode: CanvasElementMode);
	fn tsControlRect_getMode(this: *const c_void) -> CanvasElementMode;
	fn tsControlRect_setPipeline_P(this: *mut c_void, pipeline: *mut c_void);
	fn tsControlRect_setPipeline_PcCEDC(this: *mut c_void, pipeline: *mut c_void, func: CanvasElementDrawCallback, data_: *mut c_void);
	fn tsControlRect_getPipeline(this: *const c_void) -> *mut c_void;
	fn tsControlRect_setRadius(this: *mut c_void, radius: f32);
	fn tsControlRect_getRadius(this: *const c_void) -> f32;
	fn tsControlRect_setColor_cC(this: *mut c_void, color: *const Color);
	fn tsControlRect_setColor_ffff(this: *mut c_void, r: f32, g: f32, b: f32, a: f32);
	fn tsControlRect_getColor(this: *const c_void) -> Color;
	fn tsControlRect_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsControlRect_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsControlRect_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsControlRect_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsControlRect_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsControlRect_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsControlRect_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsControlRect_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsControlRect_setMipmap(this: *mut c_void, mipmap: f32);
	fn tsControlRect_getMipmap(this: *const c_void) -> f32;
	fn tsControlRect_setFilter(this: *mut c_void, filter: SamplerFilter);
	fn tsControlRect_getFilter(this: *const c_void) -> SamplerFilter;
	fn tsControlRect_setAnisotropy(this: *mut c_void, anisotropy: u32);
	fn tsControlRect_getAnisotropy(this: *const c_void) -> u32;
	fn tsControlRect_setWrapMode(this: *mut c_void, mode: SamplerWrapMode);
	fn tsControlRect_getWrapMode(this: *const c_void) -> SamplerWrapMode;
	fn tsControlRect_setBlend(this: *mut c_void, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc);
	fn tsControlRect_getBlendOp(this: *const c_void) -> PipelineBlendOp;
	fn tsControlRect_getBlendSrcFunc(this: *const c_void) -> PipelineBlendFunc;
	fn tsControlRect_getBlendDestFunc(this: *const c_void) -> PipelineBlendFunc;
	fn tsControlRect_setTexture(this: *mut c_void, texture: *mut c_void, linear: i32);
	fn tsControlRect_getTexture(this: *const c_void) -> *mut c_void;
	fn tsControlRect_getTextureLinear(this: *const c_void) -> i32;
	fn tsControlRect_setTextureName_s(this: *mut c_void, name: *const c_char);
	fn tsControlRect_setTextureName_cS(this: *mut c_void, name: *mut c_void);
	fn tsControlRect_getTextureName(this: *const c_void) -> *mut c_void;
	fn tsControlRect_setTextureScale(this: *mut c_void, scale_x: f32, scale_y: f32);
	fn tsControlRect_getTextureScaleX(this: *const c_void) -> f32;
	fn tsControlRect_getTextureScaleY(this: *const c_void) -> f32;
	fn tsControlRect_setTextureFlip(this: *mut c_void, flip_x: i32, flip_y: i32);
	fn tsControlRect_getTextureFlipX(this: *const c_void) -> i32;
	fn tsControlRect_getTextureFlipY(this: *const c_void) -> i32;
	fn tsControlRect_setTextureProj(this: *mut c_void, projection: i32);
	fn tsControlRect_getTextureProj(this: *const c_void) -> i32;
	fn tsControlRect_setTexCoord_cR(this: *mut c_void, texcoord: *const Rect);
	fn tsControlRect_setTexCoord_ffff(this: *mut c_void, left: f32, right: f32, bottom: f32, top: f32);
	fn tsControlRect_getTexCoord(this: *const c_void) -> Rect;
	fn tsControlRect_setInsideCallback(this: *mut c_void, func: ControlRectInsideCallback, data_: *mut c_void);
	fn tsControlRect_setPressedCallback(this: *mut c_void, func: ControlRectPressedCallback, data_: *mut c_void);
	fn tsControlRect_setReleasedCallback(this: *mut c_void, func: ControlRectReleasedCallback, data_: *mut c_void);
	fn tsControlRect_setClickedCallback(this: *mut c_void, func: ControlRectClickedCallback, data_: *mut c_void);
	fn tsControlRect_setClicked2Callback(this: *mut c_void, func: ControlRectClickedCallback, data_: *mut c_void);
	fn tsControlRect_setClickedRightCallback(this: *mut c_void, func: ControlRectClickedCallback, data_: *mut c_void);
	fn tsControlRect_getCanvasRect(this: *mut c_void) -> *mut c_void;
	fn tsControlRect_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlGrid
pub struct ControlGrid {
	this: *mut c_void,
	owner: bool,
}
impl ControlGrid {
	pub fn null() -> ControlGrid { ControlGrid { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_columns(parent: Option<&Control>, columns: u32) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_new_Cu(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns), owner: true } } }
	pub fn new_with_parent_columns_x(parent: Option<&Control>, columns: u32, x: f32) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_new_Cuff(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns, x, 0.0), owner: true } } }
	pub fn new_with_parent_columns_x_y(parent: Option<&Control>, columns: u32, x: f32, y: f32) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_new_Cuff(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns, x, y), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlGrid { unsafe { ControlGrid { this: ptr, owner: tsControlGrid_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_copyPtr(self.this), owner: true } } }
	pub fn from_control(ptr: &Control) -> ControlGrid { unsafe { ControlGrid::new_ptr(tsControlGrid_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlGrid_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlGrid) -> bool { unsafe { tsControlGrid_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlGrid_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlGrid_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlGrid_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlGrid_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlGrid_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlGrid_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlGrid_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlGrid_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlGrid_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_columns(&mut self, columns: u32) { unsafe { tsControlGrid_setColumns(self.this, columns) } }
	pub fn columns(&self) -> u32 { unsafe { tsControlGrid_getColumns(self.this) } }
	pub fn set_spacing(&mut self, spacing: &Vector2f) { unsafe { tsControlGrid_setSpacing_cV2(self.this, spacing) } }
	pub fn set_spacing_with_x(&mut self, x: f32, y: f32) { unsafe { tsControlGrid_setSpacing_ff(self.this, x, y) } }
	pub fn spacing(&self) -> Vector2f { unsafe { tsControlGrid_getSpacing(self.this) } }
	pub fn set_column_ratio(&mut self, index: u32, ratio: f32) { unsafe { tsControlGrid_setColumnRatio(self.this, index, ratio) } }
	pub fn column_ratio(&self, index: u32) -> f32 { unsafe { tsControlGrid_getColumnRatio(self.this, index) } }
	pub fn controls_size(&self) -> Vector2f { unsafe { tsControlGrid_getControlsSize(self.this) } }
}
impl ControlTrait for ControlGrid {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlGrid {
	fn drop(&mut self) { if self.owner { unsafe { tsControlGrid_delete(self.this) } } }
}
impl Clone for ControlGrid {
	fn clone(&self) -> ControlGrid { unsafe { ControlGrid { this: tsControlGrid_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlGrid { }
impl fmt::Display for ControlGrid {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlGrid ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlGrid_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlGrid_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlGrid_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlGrid_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlGrid_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlGrid_new() -> *mut c_void;
	fn tsControlGrid_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlGrid_new_Cu(parent: *const *mut c_void, columns: u32) -> *mut c_void;
	fn tsControlGrid_new_Cuff(parent: *const *mut c_void, columns: u32, x: f32, y: f32) -> *mut c_void;
	fn tsControlGrid_delete(this: *mut c_void);
	fn tsControlGrid_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlGrid_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGrid_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlGrid_clearPtr(this: *const c_void);
	fn tsControlGrid_destroyPtr(this: *const c_void);
	fn tsControlGrid_acquirePtr(this: *const c_void);
	fn tsControlGrid_unacquirePtr(this: *const c_void);
	fn tsControlGrid_isValidPtr(this: *const c_void) -> i32;
	fn tsControlGrid_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlGrid_isConstPtr(this: *const c_void) -> i32;
	fn tsControlGrid_getCountPtr(this: *const c_void) -> u32;
	fn tsControlGrid_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGrid_equalControlPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlGrid_castControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGrid_baseControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGrid_setColumns(this: *mut c_void, columns: u32);
	fn tsControlGrid_getColumns(this: *const c_void) -> u32;
	fn tsControlGrid_setSpacing_cV2(this: *mut c_void, spacing: *const Vector2f);
	fn tsControlGrid_setSpacing_ff(this: *mut c_void, x: f32, y: f32);
	fn tsControlGrid_getSpacing(this: *const c_void) -> Vector2f;
	fn tsControlGrid_setColumnRatio(this: *mut c_void, index: u32, ratio: f32);
	fn tsControlGrid_getColumnRatio(this: *const c_void, index: u32) -> f32;
	fn tsControlGrid_getControlsSize(this: *const c_void) -> Vector2f;
}

// Tellusim::ControlGroup
pub struct ControlGroup {
	this: *mut c_void,
	owner: bool,
}
type ControlGroupClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_group_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlGroup) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlGroup::new_ptr(a0);
	func(a0_)
}
impl ControlGroup {
	pub fn null() -> ControlGroup { ControlGroup { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_new(), owner: true } } }
	pub fn new_with_parent_above(parent: Option<&Control>, above: bool) -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_new_Cb(match parent { Some(parent) => &parent.this, None => ptr::null() }, if above {1} else {0}), owner: true } } }
	pub fn new_with_parent_text_above(parent: Option<&Control>, text: &str, above: bool) -> ControlGroup {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlGroup { this: tsControlGroup_new_Csb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), if above {1} else {0}), owner: true } }
	}
	pub fn new_with_parent_texts(parent: Option<&Control>, text: &String) -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_new_CcSb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this, 0), owner: true } } }
	pub fn new_with_parent_texts_above(parent: Option<&Control>, text: &String, above: bool) -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_new_CcSb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this, if above {1} else {0}), owner: true } } }
	pub fn new_with_parent_text_columns(parent: Option<&Control>, text: &str, columns: u32) -> ControlGroup {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlGroup { this: tsControlGroup_new_Csub(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), columns, 0), owner: true } }
	}
	pub fn new_with_parent_text_columns_above(parent: Option<&Control>, text: &str, columns: u32, above: bool) -> ControlGroup {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlGroup { this: tsControlGroup_new_Csub(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), columns, if above {1} else {0}), owner: true } }
	}
	pub fn new_with_parent_text_columns_x(parent: Option<&Control>, text: &str, columns: u32, x: f32, y: f32) -> ControlGroup {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlGroup { this: tsControlGroup_new_Csuffb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), columns, x, y, 0), owner: true } }
	}
	pub fn new_with_parent_text_columns_x_above(parent: Option<&Control>, text: &str, columns: u32, x: f32, y: f32, above: bool) -> ControlGroup {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlGroup { this: tsControlGroup_new_Csuffb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), columns, x, y, if above {1} else {0}), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> ControlGroup { unsafe { ControlGroup { this: ptr, owner: tsControlGroup_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlGroup { unsafe { ControlGroup::new_ptr(tsControlGroup_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlGroup_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlGroup) -> bool { unsafe { tsControlGroup_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlGroup_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlGroup_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlGroup_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlGroup_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlGroup_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlGroup_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlGroup_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlGroup_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlGroup_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_above(&mut self, above: bool) { unsafe { tsControlGroup_setAbove(self.this, if above {1} else {0}, 1) } }
	pub fn set_above_with_text(&mut self, above: bool, text: bool) { unsafe { tsControlGroup_setAbove(self.this, if above {1} else {0}, if text {1} else {0}) } }
	pub fn is_above(&self) -> bool { unsafe { tsControlGroup_isAbove(self.this) != 0 } }
	pub fn is_below(&self) -> bool { unsafe { tsControlGroup_isBelow(self.this) != 0 } }
	pub fn set_foldable(&mut self, foldable: bool) { unsafe { tsControlGroup_setFoldable(self.this, if foldable {1} else {0}) } }
	pub fn is_foldable(&self) -> bool { unsafe { tsControlGroup_isFoldable(self.this) != 0 } }
	pub fn set_expanded(&mut self, expanded: bool) { unsafe { tsControlGroup_setExpanded(self.this, if expanded {1} else {0}) } }
	pub fn is_expanded(&self) -> bool { unsafe { tsControlGroup_isExpanded(self.this) != 0 } }
	pub fn set_background(&mut self, background: bool) { unsafe { tsControlGroup_setBackground(self.this, if background {1} else {0}) } }
	pub fn background(&self) -> bool { unsafe { tsControlGroup_getBackground(self.this) != 0 } }
	pub fn set_group_radius(&mut self, radius: f32) { unsafe { tsControlGroup_setGroupRadius(self.this, radius) } }
	pub fn group_radius(&self) -> f32 { unsafe { tsControlGroup_getGroupRadius(self.this) } }
	pub fn set_group_color(&mut self, color: &Color) { unsafe { tsControlGroup_setGroupColor(self.this, color) } }
	pub fn group_color(&self) -> Color { unsafe { tsControlGroup_getGroupColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsControlGroup_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsControlGroup_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsControlGroup_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsControlGroup_getStrokeStyle(self.this) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsControlGroup_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsControlGroup_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsControlGroup_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsControlGroup_getGradientStyle(self.this) } }
	pub fn set_folded_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlGroup_setFoldedText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_folded_text_with_text(&mut self, text: &String) { unsafe { tsControlGroup_setFoldedText_cS(self.this, text.this) } }
	pub fn folded_text(&self) -> string::String { unsafe { get_string(tsControlGroup_getFoldedText(self.this)) } }
	pub fn set_expanded_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlGroup_setExpandedText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_expanded_text_with_text(&mut self, text: &String) { unsafe { tsControlGroup_setExpandedText_cS(self.this, text.this) } }
	pub fn expanded_text(&self) -> string::String { unsafe { get_string(tsControlGroup_getExpandedText(self.this)) } }
	pub fn set_columns(&mut self, columns: u32) { unsafe { tsControlGroup_setColumns(self.this, columns) } }
	pub fn columns(&self) -> u32 { unsafe { tsControlGroup_getColumns(self.this) } }
	pub fn set_spacing(&mut self, spacing: &Vector2f) { unsafe { tsControlGroup_setSpacing_cV2(self.this, spacing) } }
	pub fn set_spacing_with_x(&mut self, x: f32, y: f32) { unsafe { tsControlGroup_setSpacing_ff(self.this, x, y) } }
	pub fn spacing(&self) -> Vector2f { unsafe { tsControlGroup_getSpacing(self.this) } }
	pub fn set_column_ratio(&mut self, index: u32, ratio: f32) { unsafe { tsControlGroup_setColumnRatio(self.this, index, ratio) } }
	pub fn column_ratio(&self, index: u32) -> f32 { unsafe { tsControlGroup_getColumnRatio(self.this, index) } }
	pub fn controls_size(&self) -> Vector2f { unsafe { tsControlGroup_getControlsSize(self.this) } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlGroup) {
		let func = Box::leak(Box::new(func));
		let func_ = control_group_clicked_callback_func::<Func>;
		unsafe { tsControlGroup_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlGroup_isClicked(self.this) != 0 } }
	pub fn canvas_rect(&mut self) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsControlGroup_getCanvasRect(self.this)) } }
}
impl ControlTextTrait for ControlGroup {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlGroup {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlGroup {
	fn drop(&mut self) { if self.owner { unsafe { tsControlGroup_delete(self.this) } } }
}
impl Clone for ControlGroup {
	fn clone(&self) -> ControlGroup { unsafe { ControlGroup { this: tsControlGroup_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlGroup { }
impl fmt::Display for ControlGroup {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlGroup ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlGroup_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlGroup_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlGroup_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlGroup_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlGroup_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlGroup_new() -> *mut c_void;
	fn tsControlGroup_new_Cb(parent: *const *mut c_void, above: i32) -> *mut c_void;
	fn tsControlGroup_new_Csb(parent: *const *mut c_void, text: *const c_char, above: i32) -> *mut c_void;
	fn tsControlGroup_new_CcSb(parent: *const *mut c_void, text: *mut c_void, above: i32) -> *mut c_void;
	fn tsControlGroup_new_Csub(parent: *const *mut c_void, text: *const c_char, columns: u32, above: i32) -> *mut c_void;
	fn tsControlGroup_new_Csuffb(parent: *const *mut c_void, text: *const c_char, columns: u32, x: f32, y: f32, above: i32) -> *mut c_void;
	fn tsControlGroup_delete(this: *mut c_void);
	fn tsControlGroup_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlGroup_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_clearPtr(this: *const c_void);
	fn tsControlGroup_destroyPtr(this: *const c_void);
	fn tsControlGroup_acquirePtr(this: *const c_void);
	fn tsControlGroup_unacquirePtr(this: *const c_void);
	fn tsControlGroup_isValidPtr(this: *const c_void) -> i32;
	fn tsControlGroup_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlGroup_isConstPtr(this: *const c_void) -> i32;
	fn tsControlGroup_getCountPtr(this: *const c_void) -> u32;
	fn tsControlGroup_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlGroup_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_setAbove(this: *mut c_void, above: i32, text: i32);
	fn tsControlGroup_isAbove(this: *const c_void) -> i32;
	fn tsControlGroup_isBelow(this: *const c_void) -> i32;
	fn tsControlGroup_setFoldable(this: *mut c_void, foldable: i32);
	fn tsControlGroup_isFoldable(this: *const c_void) -> i32;
	fn tsControlGroup_setExpanded(this: *mut c_void, expanded: i32);
	fn tsControlGroup_isExpanded(this: *const c_void) -> i32;
	fn tsControlGroup_setBackground(this: *mut c_void, background: i32);
	fn tsControlGroup_getBackground(this: *const c_void) -> i32;
	fn tsControlGroup_setGroupRadius(this: *mut c_void, radius: f32);
	fn tsControlGroup_getGroupRadius(this: *const c_void) -> f32;
	fn tsControlGroup_setGroupColor(this: *mut c_void, color: *const Color);
	fn tsControlGroup_getGroupColor(this: *const c_void) -> Color;
	fn tsControlGroup_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsControlGroup_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsControlGroup_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsControlGroup_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsControlGroup_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsControlGroup_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsControlGroup_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsControlGroup_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsControlGroup_setFoldedText_s(this: *mut c_void, text: *const c_char);
	fn tsControlGroup_setFoldedText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlGroup_getFoldedText(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_setExpandedText_s(this: *mut c_void, text: *const c_char);
	fn tsControlGroup_setExpandedText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlGroup_getExpandedText(this: *const c_void) -> *mut c_void;
	fn tsControlGroup_setColumns(this: *mut c_void, columns: u32);
	fn tsControlGroup_getColumns(this: *const c_void) -> u32;
	fn tsControlGroup_setSpacing_cV2(this: *mut c_void, spacing: *const Vector2f);
	fn tsControlGroup_setSpacing_ff(this: *mut c_void, x: f32, y: f32);
	fn tsControlGroup_getSpacing(this: *const c_void) -> Vector2f;
	fn tsControlGroup_setColumnRatio(this: *mut c_void, index: u32, ratio: f32);
	fn tsControlGroup_getColumnRatio(this: *const c_void, index: u32) -> f32;
	fn tsControlGroup_getControlsSize(this: *const c_void) -> Vector2f;
	fn tsControlGroup_setClickedCallback(this: *mut c_void, func: ControlGroupClickedCallback, data_: *mut c_void);
	fn tsControlGroup_isClicked(this: *mut c_void) -> i32;
	fn tsControlGroup_getCanvasRect(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlPanel
pub struct ControlPanel {
	this: *mut c_void,
	owner: bool,
}
impl ControlPanel {
	pub fn null() -> ControlPanel { ControlPanel { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_columns(parent: Option<&Control>, columns: u32) -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_new_Cu(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns), owner: true } } }
	pub fn new_with_parent_columns_x(parent: Option<&Control>, columns: u32, x: f32, y: f32) -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_new_Cuff(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns, x, y), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlPanel { unsafe { ControlPanel { this: ptr, owner: tsControlPanel_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_copyPtr(self.this), owner: true } } }
	pub fn from_control_rect(ptr: &ControlRect) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControlPanel_castControlRectPtr(ptr.this)) } }
	pub fn to_control_rect(&self) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlPanel_baseControlRectPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlRect_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRect_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlPanel) -> bool { unsafe { tsControlPanel_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlPanel_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlPanel_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlPanel_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlPanel_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlPanel_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlPanel_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlPanel_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlPanel_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlPanel_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ControlPanelTrait {
	fn set_columns(&mut self, columns: u32);
	fn columns(&self) -> u32;
	fn set_spacing(&mut self, spacing: &Vector2f);
	fn set_spacing_with_x(&mut self, x: f32, y: f32);
	fn spacing(&self) -> Vector2f;
	fn set_column_ratio(&mut self, index: u32, ratio: f32);
	fn column_ratio(&self, index: u32) -> f32;
	fn controls_size(&self) -> Vector2f;
}
impl ControlPanelTrait for ControlPanel {
	fn set_columns(&mut self, columns: u32) { unsafe { tsControlPanel_setColumns(self.this, columns) } }
	fn columns(&self) -> u32 { unsafe { tsControlPanel_getColumns(self.this) } }
	fn set_spacing(&mut self, spacing: &Vector2f) { unsafe { tsControlPanel_setSpacing_cV2(self.this, spacing) } }
	fn set_spacing_with_x(&mut self, x: f32, y: f32) { unsafe { tsControlPanel_setSpacing_ff(self.this, x, y) } }
	fn spacing(&self) -> Vector2f { unsafe { tsControlPanel_getSpacing(self.this) } }
	fn set_column_ratio(&mut self, index: u32, ratio: f32) { unsafe { tsControlPanel_setColumnRatio(self.this, index, ratio) } }
	fn column_ratio(&self, index: u32) -> f32 { unsafe { tsControlPanel_getColumnRatio(self.this, index) } }
	fn controls_size(&self) -> Vector2f { unsafe { tsControlPanel_getControlsSize(self.this) } }
}
impl ControlRectTrait for ControlPanel {
	fn set_callback(&mut self, callback: bool) { unsafe { tsControlRect_setCallback(self.this, if callback {1} else {0}) } }
	fn callback(&self) -> bool { unsafe { tsControlRect_getCallback(self.this) != 0 } }
	fn set_fullscreen(&mut self, fullscreen: bool) { unsafe { tsControlRect_setFullscreen(self.this, if fullscreen {1} else {0}) } }
	fn is_fullscreen(&self) -> bool { unsafe { tsControlRect_isFullscreen(self.this) != 0 } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlRect_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlRect_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlRect_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlRect_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlRect_getPipeline(self.this)) } }
	fn set_radius(&mut self, radius: f32) { unsafe { tsControlRect_setRadius(self.this, radius) } }
	fn radius(&self) -> f32 { unsafe { tsControlRect_getRadius(self.this) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlRect_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlRect_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlRect_getColor(self.this) } }
	fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsControlRect_setStrokeStyle(self.this, style) } }
	fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyleConst(self.this) } }
	fn stroke_style(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle_c(self.this) } }
	fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle(self.this) } }
	fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsControlRect_setGradientStyle(self.this, style) } }
	fn gradient_style_const(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyleConst(self.this) } }
	fn gradient_style(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle_c(self.this) } }
	fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsControlRect_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsControlRect_getMipmap(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlRect_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlRect_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlRect_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlRect_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsControlRect_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsControlRect_getWrapMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlRect_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlRect_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendDestFunc(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsControlRect_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsControlRect_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsControlRect_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsControlRect_getTextureLinear(self.this) != 0 } }
	fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRect_setTextureName_s(self.this, name_.as_ptr()) }
	}
	fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsControlRect_setTextureName_cS(self.this, name.this) } }
	fn texture_name(&self) -> string::String { unsafe { get_string(tsControlRect_getTextureName(self.this)) } }
	fn set_texture_scale(&mut self, scale_x: f32, scale_y: f32) { unsafe { tsControlRect_setTextureScale(self.this, scale_x, scale_y) } }
	fn texture_scale_x(&self) -> f32 { unsafe { tsControlRect_getTextureScaleX(self.this) } }
	fn texture_scale_y(&self) -> f32 { unsafe { tsControlRect_getTextureScaleY(self.this) } }
	fn set_texture_flip(&mut self, flip_x: bool, flip_y: bool) { unsafe { tsControlRect_setTextureFlip(self.this, if flip_x {1} else {0}, if flip_y {1} else {0}) } }
	fn texture_flip_x(&self) -> bool { unsafe { tsControlRect_getTextureFlipX(self.this) != 0 } }
	fn texture_flip_y(&self) -> bool { unsafe { tsControlRect_getTextureFlipY(self.this) != 0 } }
	fn set_texture_proj(&mut self, projection: bool) { unsafe { tsControlRect_setTextureProj(self.this, if projection {1} else {0}) } }
	fn texture_proj(&self) -> bool { unsafe { tsControlRect_getTextureProj(self.this) != 0 } }
	fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsControlRect_setTexCoord_cR(self.this, texcoord) } }
	fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControlRect_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	fn tex_coord(&self) -> Rect { unsafe { tsControlRect_getTexCoord(self.this) } }
	fn set_inside_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_inside_callback_func::<Func>;
		unsafe { tsControlRect_setInsideCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_pressed_callback_func::<Func>;
		unsafe { tsControlRect_setPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_released_callback_func::<Func>;
		unsafe { tsControlRect_setReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClicked2Callback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedRightCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn canvas_rect(&mut self) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsControlRect_getCanvasRect(self.this)) } }
	fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlRect_getCanvasMesh(self.this)) } }
}
impl ControlTrait for ControlPanel {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlPanel {
	fn drop(&mut self) { if self.owner { unsafe { tsControlPanel_delete(self.this) } } }
}
impl Clone for ControlPanel {
	fn clone(&self) -> ControlPanel { unsafe { ControlPanel { this: tsControlPanel_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlPanel { }
impl fmt::Display for ControlPanel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlPanel ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlPanel_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlPanel_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlPanel_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlPanel_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlPanel_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlPanel_new() -> *mut c_void;
	fn tsControlPanel_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlPanel_new_Cu(parent: *const *mut c_void, columns: u32) -> *mut c_void;
	fn tsControlPanel_new_Cuff(parent: *const *mut c_void, columns: u32, x: f32, y: f32) -> *mut c_void;
	fn tsControlPanel_delete(this: *mut c_void);
	fn tsControlPanel_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlPanel_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlPanel_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlPanel_clearPtr(this: *const c_void);
	fn tsControlPanel_destroyPtr(this: *const c_void);
	fn tsControlPanel_acquirePtr(this: *const c_void);
	fn tsControlPanel_unacquirePtr(this: *const c_void);
	fn tsControlPanel_isValidPtr(this: *const c_void) -> i32;
	fn tsControlPanel_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlPanel_isConstPtr(this: *const c_void) -> i32;
	fn tsControlPanel_getCountPtr(this: *const c_void) -> u32;
	fn tsControlPanel_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlPanel_equalControlRectPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlPanel_castControlRectPtr(this: *const c_void) -> *mut c_void;
	fn tsControlPanel_baseControlRectPtr(this: *const c_void) -> *mut c_void;
	fn tsControlPanel_setColumns(this: *mut c_void, columns: u32);
	fn tsControlPanel_getColumns(this: *const c_void) -> u32;
	fn tsControlPanel_setSpacing_cV2(this: *mut c_void, spacing: *const Vector2f);
	fn tsControlPanel_setSpacing_ff(this: *mut c_void, x: f32, y: f32);
	fn tsControlPanel_getSpacing(this: *const c_void) -> Vector2f;
	fn tsControlPanel_setColumnRatio(this: *mut c_void, index: u32, ratio: f32);
	fn tsControlPanel_getColumnRatio(this: *const c_void, index: u32) -> f32;
	fn tsControlPanel_getControlsSize(this: *const c_void) -> Vector2f;
}

// Tellusim::ControlDialog
pub struct ControlDialog {
	this: *mut c_void,
	owner: bool,
}
type ControlDialogUpdatedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_dialog_updated_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlDialog) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlDialog::new_ptr(a0);
	func(a0_)
}
impl ControlDialog {
	pub fn null() -> ControlDialog { ControlDialog { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_columns(parent: Option<&Control>, columns: u32) -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_new_Cu(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns), owner: true } } }
	pub fn new_with_parent_columns_x(parent: Option<&Control>, columns: u32, x: f32, y: f32) -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_new_Cuff(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns, x, y), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlDialog { unsafe { ControlDialog { this: ptr, owner: tsControlDialog_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_copyPtr(self.this), owner: true } } }
	pub fn from_control_panel(ptr: &ControlPanel) -> ControlDialog { unsafe { ControlDialog::new_ptr(tsControlDialog_castControlPanelPtr(ptr.this)) } }
	pub fn to_control_panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControlDialog_baseControlPanelPtr(self.this)) } }
	pub fn from_control_rect(ptr: &ControlRect) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControlPanel_castControlRectPtr(ptr.this)) } }
	pub fn to_control_rect(&self) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlPanel_baseControlRectPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlRect_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRect_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlDialog) -> bool { unsafe { tsControlDialog_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlDialog_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlDialog_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlDialog_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlDialog_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlDialog_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlDialog_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlDialog_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlDialog_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlDialog_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
}
pub trait ControlDialogTrait {
	fn set_constrained(&mut self, constrained: bool);
	fn is_constrained(&self) -> bool;
	fn set_resizable(&mut self, resizable: bool);
	fn is_resizable(&self) -> bool;
	fn set_moveable(&mut self, moveable: bool);
	fn is_moveable(&self) -> bool;
	fn set_resize_area(&mut self, area: f32);
	fn resize_area(&self) -> f32;
	fn resize_align(&self) -> ControlAlign;
	fn has_resize_align(&self, align: ControlAlign) -> bool;
	fn has_resize_aligns(&self, aligns: ControlAlign) -> bool;
	fn set_mouse_position(&mut self, position: &Vector2f);
	fn mouse_position(&self) -> Vector2f;
	fn set_updated_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlDialog);
	fn is_updated(&mut self) -> bool;
}
impl ControlDialogTrait for ControlDialog {
	fn set_constrained(&mut self, constrained: bool) { unsafe { tsControlDialog_setConstrained(self.this, if constrained {1} else {0}) } }
	fn is_constrained(&self) -> bool { unsafe { tsControlDialog_isConstrained(self.this) != 0 } }
	fn set_resizable(&mut self, resizable: bool) { unsafe { tsControlDialog_setResizable(self.this, if resizable {1} else {0}) } }
	fn is_resizable(&self) -> bool { unsafe { tsControlDialog_isResizable(self.this) != 0 } }
	fn set_moveable(&mut self, moveable: bool) { unsafe { tsControlDialog_setMoveable(self.this, if moveable {1} else {0}) } }
	fn is_moveable(&self) -> bool { unsafe { tsControlDialog_isMoveable(self.this) != 0 } }
	fn set_resize_area(&mut self, area: f32) { unsafe { tsControlDialog_setResizeArea(self.this, area) } }
	fn resize_area(&self) -> f32 { unsafe { tsControlDialog_getResizeArea(self.this) } }
	fn resize_align(&self) -> ControlAlign { unsafe { tsControlDialog_getResizeAlign(self.this) } }
	fn has_resize_align(&self, align: ControlAlign) -> bool { unsafe { tsControlDialog_hasResizeAlign(self.this, align) != 0 } }
	fn has_resize_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlDialog_hasResizeAligns(self.this, aligns) != 0 } }
	fn set_mouse_position(&mut self, position: &Vector2f) { unsafe { tsControlDialog_setMousePosition(self.this, position) } }
	fn mouse_position(&self) -> Vector2f { unsafe { tsControlDialog_getMousePosition(self.this) } }
	fn set_updated_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlDialog) {
		let func = Box::leak(Box::new(func));
		let func_ = control_dialog_updated_callback_func::<Func>;
		unsafe { tsControlDialog_setUpdatedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn is_updated(&mut self) -> bool { unsafe { tsControlDialog_isUpdated(self.this) != 0 } }
}
impl ControlPanelTrait for ControlDialog {
	fn set_columns(&mut self, columns: u32) { unsafe { tsControlPanel_setColumns(self.this, columns) } }
	fn columns(&self) -> u32 { unsafe { tsControlPanel_getColumns(self.this) } }
	fn set_spacing(&mut self, spacing: &Vector2f) { unsafe { tsControlPanel_setSpacing_cV2(self.this, spacing) } }
	fn set_spacing_with_x(&mut self, x: f32, y: f32) { unsafe { tsControlPanel_setSpacing_ff(self.this, x, y) } }
	fn spacing(&self) -> Vector2f { unsafe { tsControlPanel_getSpacing(self.this) } }
	fn set_column_ratio(&mut self, index: u32, ratio: f32) { unsafe { tsControlPanel_setColumnRatio(self.this, index, ratio) } }
	fn column_ratio(&self, index: u32) -> f32 { unsafe { tsControlPanel_getColumnRatio(self.this, index) } }
	fn controls_size(&self) -> Vector2f { unsafe { tsControlPanel_getControlsSize(self.this) } }
}
impl ControlRectTrait for ControlDialog {
	fn set_callback(&mut self, callback: bool) { unsafe { tsControlRect_setCallback(self.this, if callback {1} else {0}) } }
	fn callback(&self) -> bool { unsafe { tsControlRect_getCallback(self.this) != 0 } }
	fn set_fullscreen(&mut self, fullscreen: bool) { unsafe { tsControlRect_setFullscreen(self.this, if fullscreen {1} else {0}) } }
	fn is_fullscreen(&self) -> bool { unsafe { tsControlRect_isFullscreen(self.this) != 0 } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlRect_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlRect_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlRect_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlRect_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlRect_getPipeline(self.this)) } }
	fn set_radius(&mut self, radius: f32) { unsafe { tsControlRect_setRadius(self.this, radius) } }
	fn radius(&self) -> f32 { unsafe { tsControlRect_getRadius(self.this) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlRect_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlRect_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlRect_getColor(self.this) } }
	fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsControlRect_setStrokeStyle(self.this, style) } }
	fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyleConst(self.this) } }
	fn stroke_style(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle_c(self.this) } }
	fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle(self.this) } }
	fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsControlRect_setGradientStyle(self.this, style) } }
	fn gradient_style_const(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyleConst(self.this) } }
	fn gradient_style(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle_c(self.this) } }
	fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsControlRect_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsControlRect_getMipmap(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlRect_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlRect_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlRect_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlRect_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsControlRect_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsControlRect_getWrapMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlRect_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlRect_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendDestFunc(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsControlRect_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsControlRect_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsControlRect_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsControlRect_getTextureLinear(self.this) != 0 } }
	fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRect_setTextureName_s(self.this, name_.as_ptr()) }
	}
	fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsControlRect_setTextureName_cS(self.this, name.this) } }
	fn texture_name(&self) -> string::String { unsafe { get_string(tsControlRect_getTextureName(self.this)) } }
	fn set_texture_scale(&mut self, scale_x: f32, scale_y: f32) { unsafe { tsControlRect_setTextureScale(self.this, scale_x, scale_y) } }
	fn texture_scale_x(&self) -> f32 { unsafe { tsControlRect_getTextureScaleX(self.this) } }
	fn texture_scale_y(&self) -> f32 { unsafe { tsControlRect_getTextureScaleY(self.this) } }
	fn set_texture_flip(&mut self, flip_x: bool, flip_y: bool) { unsafe { tsControlRect_setTextureFlip(self.this, if flip_x {1} else {0}, if flip_y {1} else {0}) } }
	fn texture_flip_x(&self) -> bool { unsafe { tsControlRect_getTextureFlipX(self.this) != 0 } }
	fn texture_flip_y(&self) -> bool { unsafe { tsControlRect_getTextureFlipY(self.this) != 0 } }
	fn set_texture_proj(&mut self, projection: bool) { unsafe { tsControlRect_setTextureProj(self.this, if projection {1} else {0}) } }
	fn texture_proj(&self) -> bool { unsafe { tsControlRect_getTextureProj(self.this) != 0 } }
	fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsControlRect_setTexCoord_cR(self.this, texcoord) } }
	fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControlRect_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	fn tex_coord(&self) -> Rect { unsafe { tsControlRect_getTexCoord(self.this) } }
	fn set_inside_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_inside_callback_func::<Func>;
		unsafe { tsControlRect_setInsideCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_pressed_callback_func::<Func>;
		unsafe { tsControlRect_setPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_released_callback_func::<Func>;
		unsafe { tsControlRect_setReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClicked2Callback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedRightCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn canvas_rect(&mut self) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsControlRect_getCanvasRect(self.this)) } }
	fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlRect_getCanvasMesh(self.this)) } }
}
impl ControlTrait for ControlDialog {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlDialog {
	fn drop(&mut self) { if self.owner { unsafe { tsControlDialog_delete(self.this) } } }
}
impl Clone for ControlDialog {
	fn clone(&self) -> ControlDialog { unsafe { ControlDialog { this: tsControlDialog_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlDialog { }
impl fmt::Display for ControlDialog {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlDialog ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlDialog_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlDialog_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlDialog_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlDialog_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlDialog_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlDialog_new() -> *mut c_void;
	fn tsControlDialog_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlDialog_new_Cu(parent: *const *mut c_void, columns: u32) -> *mut c_void;
	fn tsControlDialog_new_Cuff(parent: *const *mut c_void, columns: u32, x: f32, y: f32) -> *mut c_void;
	fn tsControlDialog_delete(this: *mut c_void);
	fn tsControlDialog_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlDialog_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlDialog_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlDialog_clearPtr(this: *const c_void);
	fn tsControlDialog_destroyPtr(this: *const c_void);
	fn tsControlDialog_acquirePtr(this: *const c_void);
	fn tsControlDialog_unacquirePtr(this: *const c_void);
	fn tsControlDialog_isValidPtr(this: *const c_void) -> i32;
	fn tsControlDialog_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlDialog_isConstPtr(this: *const c_void) -> i32;
	fn tsControlDialog_getCountPtr(this: *const c_void) -> u32;
	fn tsControlDialog_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlDialog_equalControlPanelPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlDialog_castControlPanelPtr(this: *const c_void) -> *mut c_void;
	fn tsControlDialog_baseControlPanelPtr(this: *const c_void) -> *mut c_void;
	fn tsControlDialog_setConstrained(this: *mut c_void, constrained: i32);
	fn tsControlDialog_isConstrained(this: *const c_void) -> i32;
	fn tsControlDialog_setResizable(this: *mut c_void, resizable: i32);
	fn tsControlDialog_isResizable(this: *const c_void) -> i32;
	fn tsControlDialog_setMoveable(this: *mut c_void, moveable: i32);
	fn tsControlDialog_isMoveable(this: *const c_void) -> i32;
	fn tsControlDialog_setResizeArea(this: *mut c_void, area: f32);
	fn tsControlDialog_getResizeArea(this: *const c_void) -> f32;
	fn tsControlDialog_getResizeAlign(this: *const c_void) -> ControlAlign;
	fn tsControlDialog_hasResizeAlign(this: *const c_void, align: ControlAlign) -> i32;
	fn tsControlDialog_hasResizeAligns(this: *const c_void, aligns: ControlAlign) -> i32;
	fn tsControlDialog_setMousePosition(this: *mut c_void, position: *const Vector2f);
	fn tsControlDialog_getMousePosition(this: *const c_void) -> Vector2f;
	fn tsControlDialog_setUpdatedCallback(this: *mut c_void, func: ControlDialogUpdatedCallback, data_: *mut c_void);
	fn tsControlDialog_isUpdated(this: *mut c_void) -> i32;
}

// Tellusim::ControlWindow
pub struct ControlWindow {
	this: *mut c_void,
	owner: bool,
}
impl ControlWindow {
	pub fn null() -> ControlWindow { ControlWindow { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_new(), owner: true } } }
	pub fn new_with_root(root: Option<&ControlRoot>, parent: &mut Window, window: &mut Window) -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_new_CRWW(match root { Some(root) => &root.this, None => ptr::null() }, parent.this, window.this), owner: true } } }
	pub fn new_with_root_columns(root: Option<&ControlRoot>, parent: &mut Window, window: &mut Window, columns: u32) -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_new_CRWWu(match root { Some(root) => &root.this, None => ptr::null() }, parent.this, window.this, columns), owner: true } } }
	pub fn new_with_root_columns_x(root: Option<&ControlRoot>, parent: &mut Window, window: &mut Window, columns: u32, x: f32, y: f32) -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_new_CRWWuff(match root { Some(root) => &root.this, None => ptr::null() }, parent.this, window.this, columns, x, y), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlWindow { unsafe { ControlWindow { this: ptr, owner: tsControlWindow_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_copyPtr(self.this), owner: true } } }
	pub fn from_control_dialog(ptr: &ControlDialog) -> ControlWindow { unsafe { ControlWindow::new_ptr(tsControlWindow_castControlDialogPtr(ptr.this)) } }
	pub fn to_control_dialog(&self) -> ControlDialog { unsafe { ControlDialog::new_ptr(tsControlWindow_baseControlDialogPtr(self.this)) } }
	pub fn from_control_panel(ptr: &ControlPanel) -> ControlDialog { unsafe { ControlDialog::new_ptr(tsControlDialog_castControlPanelPtr(ptr.this)) } }
	pub fn to_control_panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControlDialog_baseControlPanelPtr(self.this)) } }
	pub fn from_control_rect(ptr: &ControlRect) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControlPanel_castControlRectPtr(ptr.this)) } }
	pub fn to_control_rect(&self) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlPanel_baseControlRectPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlRect { unsafe { ControlRect::new_ptr(tsControlRect_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlRect_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlWindow) -> bool { unsafe { tsControlWindow_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlWindow_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlWindow_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlWindow_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlWindow_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlWindow_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlWindow_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlWindow_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlWindow_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlWindow_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn parent_window(&self) -> Window { unsafe { Window::new_ptr(tsControlWindow_getParentWindow(self.this)) } }
	pub fn dialog_window(&self) -> Window { unsafe { Window::new_ptr(tsControlWindow_getDialogWindow(self.this)) } }
}
impl ControlDialogTrait for ControlWindow {
	fn set_constrained(&mut self, constrained: bool) { unsafe { tsControlDialog_setConstrained(self.this, if constrained {1} else {0}) } }
	fn is_constrained(&self) -> bool { unsafe { tsControlDialog_isConstrained(self.this) != 0 } }
	fn set_resizable(&mut self, resizable: bool) { unsafe { tsControlDialog_setResizable(self.this, if resizable {1} else {0}) } }
	fn is_resizable(&self) -> bool { unsafe { tsControlDialog_isResizable(self.this) != 0 } }
	fn set_moveable(&mut self, moveable: bool) { unsafe { tsControlDialog_setMoveable(self.this, if moveable {1} else {0}) } }
	fn is_moveable(&self) -> bool { unsafe { tsControlDialog_isMoveable(self.this) != 0 } }
	fn set_resize_area(&mut self, area: f32) { unsafe { tsControlDialog_setResizeArea(self.this, area) } }
	fn resize_area(&self) -> f32 { unsafe { tsControlDialog_getResizeArea(self.this) } }
	fn resize_align(&self) -> ControlAlign { unsafe { tsControlDialog_getResizeAlign(self.this) } }
	fn has_resize_align(&self, align: ControlAlign) -> bool { unsafe { tsControlDialog_hasResizeAlign(self.this, align) != 0 } }
	fn has_resize_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlDialog_hasResizeAligns(self.this, aligns) != 0 } }
	fn set_mouse_position(&mut self, position: &Vector2f) { unsafe { tsControlDialog_setMousePosition(self.this, position) } }
	fn mouse_position(&self) -> Vector2f { unsafe { tsControlDialog_getMousePosition(self.this) } }
	fn set_updated_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlDialog) {
		let func = Box::leak(Box::new(func));
		let func_ = control_dialog_updated_callback_func::<Func>;
		unsafe { tsControlDialog_setUpdatedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn is_updated(&mut self) -> bool { unsafe { tsControlDialog_isUpdated(self.this) != 0 } }
}
impl ControlPanelTrait for ControlWindow {
	fn set_columns(&mut self, columns: u32) { unsafe { tsControlPanel_setColumns(self.this, columns) } }
	fn columns(&self) -> u32 { unsafe { tsControlPanel_getColumns(self.this) } }
	fn set_spacing(&mut self, spacing: &Vector2f) { unsafe { tsControlPanel_setSpacing_cV2(self.this, spacing) } }
	fn set_spacing_with_x(&mut self, x: f32, y: f32) { unsafe { tsControlPanel_setSpacing_ff(self.this, x, y) } }
	fn spacing(&self) -> Vector2f { unsafe { tsControlPanel_getSpacing(self.this) } }
	fn set_column_ratio(&mut self, index: u32, ratio: f32) { unsafe { tsControlPanel_setColumnRatio(self.this, index, ratio) } }
	fn column_ratio(&self, index: u32) -> f32 { unsafe { tsControlPanel_getColumnRatio(self.this, index) } }
	fn controls_size(&self) -> Vector2f { unsafe { tsControlPanel_getControlsSize(self.this) } }
}
impl ControlRectTrait for ControlWindow {
	fn set_callback(&mut self, callback: bool) { unsafe { tsControlRect_setCallback(self.this, if callback {1} else {0}) } }
	fn callback(&self) -> bool { unsafe { tsControlRect_getCallback(self.this) != 0 } }
	fn set_fullscreen(&mut self, fullscreen: bool) { unsafe { tsControlRect_setFullscreen(self.this, if fullscreen {1} else {0}) } }
	fn is_fullscreen(&self) -> bool { unsafe { tsControlRect_isFullscreen(self.this) != 0 } }
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlRect_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlRect_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlRect_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlRect_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlRect_getPipeline(self.this)) } }
	fn set_radius(&mut self, radius: f32) { unsafe { tsControlRect_setRadius(self.this, radius) } }
	fn radius(&self) -> f32 { unsafe { tsControlRect_getRadius(self.this) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlRect_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlRect_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlRect_getColor(self.this) } }
	fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsControlRect_setStrokeStyle(self.this, style) } }
	fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyleConst(self.this) } }
	fn stroke_style(&self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle_c(self.this) } }
	fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsControlRect_getStrokeStyle(self.this) } }
	fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsControlRect_setGradientStyle(self.this, style) } }
	fn gradient_style_const(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyleConst(self.this) } }
	fn gradient_style(&self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle_c(self.this) } }
	fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsControlRect_getGradientStyle(self.this) } }
	fn set_mipmap(&mut self, mipmap: f32) { unsafe { tsControlRect_setMipmap(self.this, mipmap) } }
	fn mipmap(&self) -> f32 { unsafe { tsControlRect_getMipmap(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlRect_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlRect_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlRect_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlRect_getAnisotropy(self.this) } }
	fn set_wrap_mode(&mut self, mode: SamplerWrapMode) { unsafe { tsControlRect_setWrapMode(self.this, mode) } }
	fn wrap_mode(&self) -> SamplerWrapMode { unsafe { tsControlRect_getWrapMode(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlRect_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlRect_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlRect_getBlendDestFunc(self.this) } }
	fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsControlRect_setTexture(self.this, texture.this, 0) } }
	fn set_texture_with_linear(&mut self, texture: &mut Texture, linear: bool) { unsafe { tsControlRect_setTexture(self.this, texture.this, if linear {1} else {0}) } }
	fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsControlRect_getTexture(self.this)) } }
	fn texture_linear(&self) -> bool { unsafe { tsControlRect_getTextureLinear(self.this) != 0 } }
	fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlRect_setTextureName_s(self.this, name_.as_ptr()) }
	}
	fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsControlRect_setTextureName_cS(self.this, name.this) } }
	fn texture_name(&self) -> string::String { unsafe { get_string(tsControlRect_getTextureName(self.this)) } }
	fn set_texture_scale(&mut self, scale_x: f32, scale_y: f32) { unsafe { tsControlRect_setTextureScale(self.this, scale_x, scale_y) } }
	fn texture_scale_x(&self) -> f32 { unsafe { tsControlRect_getTextureScaleX(self.this) } }
	fn texture_scale_y(&self) -> f32 { unsafe { tsControlRect_getTextureScaleY(self.this) } }
	fn set_texture_flip(&mut self, flip_x: bool, flip_y: bool) { unsafe { tsControlRect_setTextureFlip(self.this, if flip_x {1} else {0}, if flip_y {1} else {0}) } }
	fn texture_flip_x(&self) -> bool { unsafe { tsControlRect_getTextureFlipX(self.this) != 0 } }
	fn texture_flip_y(&self) -> bool { unsafe { tsControlRect_getTextureFlipY(self.this) != 0 } }
	fn set_texture_proj(&mut self, projection: bool) { unsafe { tsControlRect_setTextureProj(self.this, if projection {1} else {0}) } }
	fn texture_proj(&self) -> bool { unsafe { tsControlRect_getTextureProj(self.this) != 0 } }
	fn set_tex_coord(&mut self, texcoord: &Rect) { unsafe { tsControlRect_setTexCoord_cR(self.this, texcoord) } }
	fn set_tex_coord_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControlRect_setTexCoord_ffff(self.this, left, right, bottom, top) } }
	fn tex_coord(&self) -> Rect { unsafe { tsControlRect_getTexCoord(self.this) } }
	fn set_inside_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_inside_callback_func::<Func>;
		unsafe { tsControlRect_setInsideCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_pressed_callback_func::<Func>;
		unsafe { tsControlRect_setPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_released_callback_func::<Func>;
		unsafe { tsControlRect_setReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClicked2Callback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlRect) {
		let func = Box::leak(Box::new(func));
		let func_ = control_rect_clicked_callback_func::<Func>;
		unsafe { tsControlRect_setClickedRightCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	fn canvas_rect(&mut self) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsControlRect_getCanvasRect(self.this)) } }
	fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlRect_getCanvasMesh(self.this)) } }
}
impl ControlTrait for ControlWindow {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlWindow {
	fn drop(&mut self) { if self.owner { unsafe { tsControlWindow_delete(self.this) } } }
}
impl Clone for ControlWindow {
	fn clone(&self) -> ControlWindow { unsafe { ControlWindow { this: tsControlWindow_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlWindow { }
impl fmt::Display for ControlWindow {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlWindow ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlWindow_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlWindow_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlWindow_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlWindow_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlWindow_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlWindow_new() -> *mut c_void;
	fn tsControlWindow_new_CRWW(root: *const *mut c_void, parent: *mut c_void, window: *mut c_void) -> *mut c_void;
	fn tsControlWindow_new_CRWWu(root: *const *mut c_void, parent: *mut c_void, window: *mut c_void, columns: u32) -> *mut c_void;
	fn tsControlWindow_new_CRWWuff(root: *const *mut c_void, parent: *mut c_void, window: *mut c_void, columns: u32, x: f32, y: f32) -> *mut c_void;
	fn tsControlWindow_delete(this: *mut c_void);
	fn tsControlWindow_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlWindow_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlWindow_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlWindow_clearPtr(this: *const c_void);
	fn tsControlWindow_destroyPtr(this: *const c_void);
	fn tsControlWindow_acquirePtr(this: *const c_void);
	fn tsControlWindow_unacquirePtr(this: *const c_void);
	fn tsControlWindow_isValidPtr(this: *const c_void) -> i32;
	fn tsControlWindow_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlWindow_isConstPtr(this: *const c_void) -> i32;
	fn tsControlWindow_getCountPtr(this: *const c_void) -> u32;
	fn tsControlWindow_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlWindow_equalControlDialogPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlWindow_castControlDialogPtr(this: *const c_void) -> *mut c_void;
	fn tsControlWindow_baseControlDialogPtr(this: *const c_void) -> *mut c_void;
	fn tsControlWindow_getParentWindow(this: *const c_void) -> *mut c_void;
	fn tsControlWindow_getDialogWindow(this: *const c_void) -> *mut c_void;
}

// Tellusim::ControlCheck
pub struct ControlCheck {
	this: *mut c_void,
	owner: bool,
}
type ControlCheckClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_check_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlCheck) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlCheck::new_ptr(a0);
	func(a0_)
}
impl ControlCheck {
	pub fn null() -> ControlCheck { ControlCheck { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_text(parent: Option<&Control>, text: &str) -> ControlCheck {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlCheck { this: tsControlCheck_new_Cs(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_texts(parent: Option<&Control>, text: &String) -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_new_CcS(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this), owner: true } } }
	pub fn new_with_parent_text_checked(parent: Option<&Control>, text: &str, checked: bool) -> ControlCheck {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlCheck { this: tsControlCheck_new_Csb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), if checked {1} else {0}), owner: true } }
	}
	pub fn new_with_parent_texts_checked(parent: Option<&Control>, text: &String, checked: bool) -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_new_CcSb(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this, if checked {1} else {0}), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlCheck { unsafe { ControlCheck { this: ptr, owner: tsControlCheck_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlCheck { unsafe { ControlCheck::new_ptr(tsControlCheck_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlCheck_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlCheck) -> bool { unsafe { tsControlCheck_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlCheck_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlCheck_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlCheck_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlCheck_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlCheck_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlCheck_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlCheck_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlCheck_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlCheck_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_check_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCheck_setCheckText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_check_text_with_text(&mut self, text: &String) { unsafe { tsControlCheck_setCheckText_cS(self.this, text.this) } }
	pub fn check_text(&self) -> string::String { unsafe { get_string(tsControlCheck_getCheckText(self.this)) } }
	pub fn set_check_color(&mut self, color: &Color) { unsafe { tsControlCheck_setCheckColor(self.this, color) } }
	pub fn check_color(&self) -> Color { unsafe { tsControlCheck_getCheckColor(self.this) } }
	pub fn set_checked_color(&mut self, color: &Color) { unsafe { tsControlCheck_setCheckedColor(self.this, color) } }
	pub fn checked_color(&self) -> Color { unsafe { tsControlCheck_getCheckedColor(self.this) } }
	pub fn switch_checked(&mut self) -> bool { unsafe { tsControlCheck_switchChecked(self.this, 0) != 0 } }
	pub fn switch_checked_with_callback(&mut self, callback: bool) -> bool { unsafe { tsControlCheck_switchChecked(self.this, if callback {1} else {0}) != 0 } }
	pub fn set_checked(&mut self, checked: bool) { unsafe { tsControlCheck_setChecked(self.this, if checked {1} else {0}, 0) } }
	pub fn set_checked_with_callback(&mut self, checked: bool, callback: bool) { unsafe { tsControlCheck_setChecked(self.this, if checked {1} else {0}, if callback {1} else {0}) } }
	pub fn is_checked(&self) -> bool { unsafe { tsControlCheck_isChecked(self.this) != 0 } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlCheck) {
		let func = Box::leak(Box::new(func));
		let func_ = control_check_clicked_callback_func::<Func>;
		unsafe { tsControlCheck_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlCheck_isClicked(self.this) != 0 } }
	pub fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlCheck_getCanvasMesh(self.this)) } }
}
impl ControlTextTrait for ControlCheck {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlCheck {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlCheck {
	fn drop(&mut self) { if self.owner { unsafe { tsControlCheck_delete(self.this) } } }
}
impl Clone for ControlCheck {
	fn clone(&self) -> ControlCheck { unsafe { ControlCheck { this: tsControlCheck_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlCheck { }
impl fmt::Display for ControlCheck {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlCheck ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlCheck_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlCheck_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlCheck_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlCheck_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlCheck_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlCheck_new() -> *mut c_void;
	fn tsControlCheck_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlCheck_new_Cs(parent: *const *mut c_void, text: *const c_char) -> *mut c_void;
	fn tsControlCheck_new_CcS(parent: *const *mut c_void, text: *mut c_void) -> *mut c_void;
	fn tsControlCheck_new_Csb(parent: *const *mut c_void, text: *const c_char, checked: i32) -> *mut c_void;
	fn tsControlCheck_new_CcSb(parent: *const *mut c_void, text: *mut c_void, checked: i32) -> *mut c_void;
	fn tsControlCheck_delete(this: *mut c_void);
	fn tsControlCheck_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlCheck_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCheck_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlCheck_clearPtr(this: *const c_void);
	fn tsControlCheck_destroyPtr(this: *const c_void);
	fn tsControlCheck_acquirePtr(this: *const c_void);
	fn tsControlCheck_unacquirePtr(this: *const c_void);
	fn tsControlCheck_isValidPtr(this: *const c_void) -> i32;
	fn tsControlCheck_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlCheck_isConstPtr(this: *const c_void) -> i32;
	fn tsControlCheck_getCountPtr(this: *const c_void) -> u32;
	fn tsControlCheck_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCheck_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlCheck_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCheck_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCheck_setCheckText_s(this: *mut c_void, text: *const c_char);
	fn tsControlCheck_setCheckText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlCheck_getCheckText(this: *const c_void) -> *mut c_void;
	fn tsControlCheck_setCheckColor(this: *mut c_void, color: *const Color);
	fn tsControlCheck_getCheckColor(this: *const c_void) -> Color;
	fn tsControlCheck_setCheckedColor(this: *mut c_void, color: *const Color);
	fn tsControlCheck_getCheckedColor(this: *const c_void) -> Color;
	fn tsControlCheck_switchChecked(this: *mut c_void, callback: i32) -> i32;
	fn tsControlCheck_setChecked(this: *mut c_void, checked: i32, callback: i32);
	fn tsControlCheck_isChecked(this: *const c_void) -> i32;
	fn tsControlCheck_setClickedCallback(this: *mut c_void, func: ControlCheckClickedCallback, data_: *mut c_void);
	fn tsControlCheck_isClicked(this: *mut c_void) -> i32;
	fn tsControlCheck_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlCombo
pub struct ControlCombo {
	this: *mut c_void,
	owner: bool,
}
type ControlComboClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_combo_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlCombo) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlCombo::new_ptr(a0);
	func(a0_)
}
type ControlComboChangedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_combo_changed_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlCombo) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlCombo::new_ptr(a0);
	func(a0_)
}
impl ControlCombo {
	pub fn null() -> ControlCombo { ControlCombo { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlCombo { unsafe { ControlCombo { this: tsControlCombo_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlCombo { unsafe { ControlCombo { this: tsControlCombo_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlCombo { unsafe { ControlCombo { this: ptr, owner: tsControlCombo_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlCombo { unsafe { ControlCombo { this: tsControlCombo_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlCombo { unsafe { ControlCombo::new_ptr(tsControlCombo_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlCombo_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlCombo) -> bool { unsafe { tsControlCombo_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlCombo { unsafe { ControlCombo { this: tsControlCombo_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlCombo_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlCombo_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlCombo_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlCombo_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlCombo_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlCombo_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlCombo_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlCombo_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlCombo_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_text_enabled(&mut self, enabled: bool) { unsafe { tsControlCombo_setTextEnabled(self.this, if enabled {1} else {0}) } }
	pub fn is_text_enabled(&self) -> bool { unsafe { tsControlCombo_isTextEnabled(self.this) != 0 } }
	pub fn set_multi_selection(&mut self, multi_selection: bool) { unsafe { tsControlCombo_setMultiSelection(self.this, if multi_selection {1} else {0}) } }
	pub fn is_multi_selection(&self) -> bool { unsafe { tsControlCombo_isMultiSelection(self.this) != 0 } }
	pub fn set_combo_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_setComboText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_combo_text_with_text(&mut self, text: &String) { unsafe { tsControlCombo_setComboText_cS(self.this, text.this) } }
	pub fn combo_text(&self) -> string::String { unsafe { get_string(tsControlCombo_getComboText(self.this)) } }
	pub fn set_combo_color(&mut self, color: &Color) { unsafe { tsControlCombo_setComboColor(self.this, color) } }
	pub fn combo_color(&self) -> Color { unsafe { tsControlCombo_getComboColor(self.this) } }
	pub fn set_items_spacing(&mut self, spacing: f32) { unsafe { tsControlCombo_setItemsSpacing(self.this, spacing) } }
	pub fn items_spacing(&self) -> f32 { unsafe { tsControlCombo_getItemsSpacing(self.this) } }
	pub fn clear_items(&mut self) { unsafe { tsControlCombo_clearItems(self.this) } }
	pub fn add_item_with_text(&mut self, text: &str) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_addItem_s(self.this, text_.as_ptr()) }
	}
	pub fn add_item_with_texts(&mut self, text: &String) -> u32 { unsafe { tsControlCombo_addItem_cS(self.this, text.this) } }
	pub fn add_item_with_index(&mut self, index: u32, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_addItem_us(self.this, index, text_.as_ptr()) }
	}
	pub fn add_item_with_index_text(&mut self, index: u32, text: &String) { unsafe { tsControlCombo_addItem_ucS(self.this, index, text.this) } }
	pub fn remove_item(&mut self, index: u32) { unsafe { tsControlCombo_removeItem(self.this, index) } }
	pub fn num_items(&self) -> u32 { unsafe { tsControlCombo_getNumItems(self.this) } }
	pub fn switch_item_selected(&mut self, index: u32) -> bool { unsafe { tsControlCombo_switchItemSelected(self.this, index) != 0 } }
	pub fn set_item_selected(&mut self, index: u32, selected: bool) { unsafe { tsControlCombo_setItemSelected(self.this, index, if selected {1} else {0}) } }
	pub fn is_item_selected(&self, index: u32) -> bool { unsafe { tsControlCombo_isItemSelected(self.this, index) != 0 } }
	pub fn set_item_text(&mut self, index: u32, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_setItemText_us(self.this, index, text_.as_ptr()) }
	}
	pub fn set_item_text_with_text(&mut self, index: u32, text: &String) { unsafe { tsControlCombo_setItemText_ucS(self.this, index, text.this) } }
	pub fn item_text(&self, index: u32) -> string::String { unsafe { get_string(tsControlCombo_getItemText(self.this, index)) } }
	pub fn find_item_text(&self, text: &str) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_findItemText_cs(self.this, text_.as_ptr()) }
	}
	pub fn find_item_text_with_text(&self, text: &String) -> u32 { unsafe { tsControlCombo_findItemText_ccS(self.this, text.this) } }
	pub fn set_item_color(&mut self, index: u32, color: &Color) { unsafe { tsControlCombo_setItemColor(self.this, index, color) } }
	pub fn item_color(&self, index: u32) -> Color { unsafe { tsControlCombo_getItemColor(self.this, index) } }
	pub fn set_current_index(&mut self, index: u32) { unsafe { tsControlCombo_setCurrentIndex(self.this, index, 0) } }
	pub fn set_current_index_with_callback(&mut self, index: u32, callback: bool) { unsafe { tsControlCombo_setCurrentIndex(self.this, index, if callback {1} else {0}) } }
	pub fn set_current_text(&mut self, text: &str) -> bool {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_setCurrentText_sb(self.this, text_.as_ptr(), 0) != 0 }
	}
	pub fn set_current_text_with_callback(&mut self, text: &str, callback: bool) -> bool {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlCombo_setCurrentText_sb(self.this, text_.as_ptr(), if callback {1} else {0}) != 0 }
	}
	pub fn set_current_text_with_text(&mut self, text: &String) -> bool { unsafe { tsControlCombo_setCurrentText_cSb(self.this, text.this, 0) != 0 } }
	pub fn set_current_text_with_text_callback(&mut self, text: &String, callback: bool) -> bool { unsafe { tsControlCombo_setCurrentText_cSb(self.this, text.this, if callback {1} else {0}) != 0 } }
	pub fn current_index(&self) -> u32 { unsafe { tsControlCombo_getCurrentIndex(self.this) } }
	pub fn current_text(&self) -> string::String { unsafe { get_string(tsControlCombo_getCurrentText(self.this)) } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlCombo) {
		let func = Box::leak(Box::new(func));
		let func_ = control_combo_clicked_callback_func::<Func>;
		unsafe { tsControlCombo_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlCombo_isClicked(self.this) != 0 } }
	pub fn set_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlCombo) {
		let func = Box::leak(Box::new(func));
		let func_ = control_combo_changed_callback_func::<Func>;
		unsafe { tsControlCombo_setChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_changed(&mut self) -> bool { unsafe { tsControlCombo_isChanged(self.this) != 0 } }
	pub fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlCombo_getCanvasMesh(self.this)) } }
}
impl ControlTextTrait for ControlCombo {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlCombo {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlCombo {
	fn drop(&mut self) { if self.owner { unsafe { tsControlCombo_delete(self.this) } } }
}
impl Clone for ControlCombo {
	fn clone(&self) -> ControlCombo { unsafe { ControlCombo { this: tsControlCombo_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlCombo { }
impl fmt::Display for ControlCombo {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlCombo ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlCombo_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlCombo_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlCombo_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlCombo_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlCombo_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlCombo_new() -> *mut c_void;
	fn tsControlCombo_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlCombo_delete(this: *mut c_void);
	fn tsControlCombo_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlCombo_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_clearPtr(this: *const c_void);
	fn tsControlCombo_destroyPtr(this: *const c_void);
	fn tsControlCombo_acquirePtr(this: *const c_void);
	fn tsControlCombo_unacquirePtr(this: *const c_void);
	fn tsControlCombo_isValidPtr(this: *const c_void) -> i32;
	fn tsControlCombo_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlCombo_isConstPtr(this: *const c_void) -> i32;
	fn tsControlCombo_getCountPtr(this: *const c_void) -> u32;
	fn tsControlCombo_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlCombo_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_setTextEnabled(this: *mut c_void, enabled: i32);
	fn tsControlCombo_isTextEnabled(this: *const c_void) -> i32;
	fn tsControlCombo_setMultiSelection(this: *mut c_void, multi_selection: i32);
	fn tsControlCombo_isMultiSelection(this: *const c_void) -> i32;
	fn tsControlCombo_setComboText_s(this: *mut c_void, text: *const c_char);
	fn tsControlCombo_setComboText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlCombo_getComboText(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_setComboColor(this: *mut c_void, color: *const Color);
	fn tsControlCombo_getComboColor(this: *const c_void) -> Color;
	fn tsControlCombo_setItemsSpacing(this: *mut c_void, spacing: f32);
	fn tsControlCombo_getItemsSpacing(this: *const c_void) -> f32;
	fn tsControlCombo_clearItems(this: *mut c_void);
	fn tsControlCombo_addItem_s(this: *mut c_void, text: *const c_char) -> u32;
	fn tsControlCombo_addItem_cS(this: *mut c_void, text: *mut c_void) -> u32;
	fn tsControlCombo_addItem_us(this: *mut c_void, index: u32, text: *const c_char);
	fn tsControlCombo_addItem_ucS(this: *mut c_void, index: u32, text: *mut c_void);
	fn tsControlCombo_removeItem(this: *mut c_void, index: u32);
	fn tsControlCombo_getNumItems(this: *const c_void) -> u32;
	fn tsControlCombo_switchItemSelected(this: *mut c_void, index: u32) -> i32;
	fn tsControlCombo_setItemSelected(this: *mut c_void, index: u32, selected: i32);
	fn tsControlCombo_isItemSelected(this: *const c_void, index: u32) -> i32;
	fn tsControlCombo_setItemText_us(this: *mut c_void, index: u32, text: *const c_char);
	fn tsControlCombo_setItemText_ucS(this: *mut c_void, index: u32, text: *mut c_void);
	fn tsControlCombo_getItemText(this: *const c_void, index: u32) -> *mut c_void;
	fn tsControlCombo_findItemText_cs(this: *const c_void, text: *const c_char) -> u32;
	fn tsControlCombo_findItemText_ccS(this: *const c_void, text: *mut c_void) -> u32;
	fn tsControlCombo_setItemColor(this: *mut c_void, index: u32, color: *const Color);
	fn tsControlCombo_getItemColor(this: *const c_void, index: u32) -> Color;
	fn tsControlCombo_setCurrentIndex(this: *mut c_void, index: u32, callback: i32);
	fn tsControlCombo_setCurrentText_sb(this: *mut c_void, text: *const c_char, callback: i32) -> i32;
	fn tsControlCombo_setCurrentText_cSb(this: *mut c_void, text: *mut c_void, callback: i32) -> i32;
	fn tsControlCombo_getCurrentIndex(this: *const c_void) -> u32;
	fn tsControlCombo_getCurrentText(this: *const c_void) -> *mut c_void;
	fn tsControlCombo_setClickedCallback(this: *mut c_void, func: ControlComboClickedCallback, data_: *mut c_void);
	fn tsControlCombo_isClicked(this: *mut c_void) -> i32;
	fn tsControlCombo_setChangedCallback(this: *mut c_void, func: ControlComboChangedCallback, data_: *mut c_void);
	fn tsControlCombo_isChanged(this: *mut c_void) -> i32;
	fn tsControlCombo_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlButton
pub struct ControlButton {
	this: *mut c_void,
	owner: bool,
}
type ControlButtonPressedCallback = unsafe extern "C" fn(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void);
unsafe extern "C" fn control_button_pressed_callback_func<Func>(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void) where Func: FnMut(ControlButton, f32, f32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlButton::new_ptr(a0);
	func(a0_, x, y)
}
type ControlButtonReleasedCallback = unsafe extern "C" fn(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void);
unsafe extern "C" fn control_button_released_callback_func<Func>(a0: *mut c_void, x: f32, y: f32, data_: *mut c_void) where Func: FnMut(ControlButton, f32, f32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlButton::new_ptr(a0);
	func(a0_, x, y)
}
type ControlButtonClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_button_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlButton) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlButton::new_ptr(a0);
	func(a0_)
}
impl ControlButton {
	pub fn null() -> ControlButton { ControlButton { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlButton { unsafe { ControlButton { this: tsControlButton_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlButton { unsafe { ControlButton { this: tsControlButton_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_text(parent: Option<&Control>, text: &str) -> ControlButton {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlButton { this: tsControlButton_new_Cs(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_texts(parent: Option<&Control>, text: &String) -> ControlButton { unsafe { ControlButton { this: tsControlButton_new_CcS(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlButton { unsafe { ControlButton { this: ptr, owner: tsControlButton_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlButton { unsafe { ControlButton { this: tsControlButton_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlButton { unsafe { ControlButton::new_ptr(tsControlButton_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlButton_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlButton) -> bool { unsafe { tsControlButton_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlButton { unsafe { ControlButton { this: tsControlButton_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlButton_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlButton_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlButton_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlButton_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlButton_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlButton_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlButton_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlButton_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlButton_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_background(&mut self, background: bool) { unsafe { tsControlButton_setBackground(self.this, if background {1} else {0}) } }
	pub fn background(&self) -> bool { unsafe { tsControlButton_getBackground(self.this) != 0 } }
	pub fn set_button_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlButton_setButtonMode(self.this, mode) } }
	pub fn button_mode(&self) -> CanvasElementMode { unsafe { tsControlButton_getButtonMode(self.this) } }
	pub fn set_button_radius(&mut self, radius: f32) { unsafe { tsControlButton_setButtonRadius(self.this, radius) } }
	pub fn button_radius(&self) -> f32 { unsafe { tsControlButton_getButtonRadius(self.this) } }
	pub fn set_button_color(&mut self, color: &Color) { unsafe { tsControlButton_setButtonColor(self.this, color) } }
	pub fn button_color(&self) -> Color { unsafe { tsControlButton_getButtonColor(self.this) } }
	pub fn set_stroke_style(&mut self, style: &StrokeStyle) { unsafe { tsControlButton_setStrokeStyle(self.this, style) } }
	pub fn stroke_style_const(&self) -> StrokeStyle { unsafe { tsControlButton_getStrokeStyleConst(self.this) } }
	pub fn stroke_style(&self) -> StrokeStyle { unsafe { tsControlButton_getStrokeStyle_c(self.this) } }
	pub fn stroke_style_mut(&mut self) -> StrokeStyle { unsafe { tsControlButton_getStrokeStyle(self.this) } }
	pub fn set_gradient_style(&mut self, style: &GradientStyle) { unsafe { tsControlButton_setGradientStyle(self.this, style) } }
	pub fn gradient_style_const(&self) -> GradientStyle { unsafe { tsControlButton_getGradientStyleConst(self.this) } }
	pub fn gradient_style(&self) -> GradientStyle { unsafe { tsControlButton_getGradientStyle_c(self.this) } }
	pub fn gradient_style_mut(&mut self) -> GradientStyle { unsafe { tsControlButton_getGradientStyle(self.this) } }
	pub fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlButton, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_button_pressed_callback_func::<Func>;
		unsafe { tsControlButton_setPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_pressed(&mut self) -> bool { unsafe { tsControlButton_isPressed(self.this) != 0 } }
	pub fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlButton, f32, f32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_button_released_callback_func::<Func>;
		unsafe { tsControlButton_setReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_released(&mut self) -> bool { unsafe { tsControlButton_isReleased(self.this) != 0 } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlButton) {
		let func = Box::leak(Box::new(func));
		let func_ = control_button_clicked_callback_func::<Func>;
		unsafe { tsControlButton_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlButton_isClicked(self.this) != 0 } }
	pub fn canvas_rect(&mut self) -> CanvasRect { unsafe { CanvasRect::new_ptr(tsControlButton_getCanvasRect(self.this)) } }
	pub fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlButton_getCanvasMesh(self.this)) } }
}
impl ControlTextTrait for ControlButton {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlButton {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlButton {
	fn drop(&mut self) { if self.owner { unsafe { tsControlButton_delete(self.this) } } }
}
impl Clone for ControlButton {
	fn clone(&self) -> ControlButton { unsafe { ControlButton { this: tsControlButton_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlButton { }
impl fmt::Display for ControlButton {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlButton ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlButton_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlButton_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlButton_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlButton_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlButton_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlButton_new() -> *mut c_void;
	fn tsControlButton_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlButton_new_Cs(parent: *const *mut c_void, text: *const c_char) -> *mut c_void;
	fn tsControlButton_new_CcS(parent: *const *mut c_void, text: *mut c_void) -> *mut c_void;
	fn tsControlButton_delete(this: *mut c_void);
	fn tsControlButton_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlButton_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlButton_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlButton_clearPtr(this: *const c_void);
	fn tsControlButton_destroyPtr(this: *const c_void);
	fn tsControlButton_acquirePtr(this: *const c_void);
	fn tsControlButton_unacquirePtr(this: *const c_void);
	fn tsControlButton_isValidPtr(this: *const c_void) -> i32;
	fn tsControlButton_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlButton_isConstPtr(this: *const c_void) -> i32;
	fn tsControlButton_getCountPtr(this: *const c_void) -> u32;
	fn tsControlButton_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlButton_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlButton_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlButton_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlButton_setBackground(this: *mut c_void, background: i32);
	fn tsControlButton_getBackground(this: *const c_void) -> i32;
	fn tsControlButton_setButtonMode(this: *mut c_void, mode: CanvasElementMode);
	fn tsControlButton_getButtonMode(this: *const c_void) -> CanvasElementMode;
	fn tsControlButton_setButtonRadius(this: *mut c_void, radius: f32);
	fn tsControlButton_getButtonRadius(this: *const c_void) -> f32;
	fn tsControlButton_setButtonColor(this: *mut c_void, color: *const Color);
	fn tsControlButton_getButtonColor(this: *const c_void) -> Color;
	fn tsControlButton_setStrokeStyle(this: *mut c_void, style: *const StrokeStyle);
	fn tsControlButton_getStrokeStyleConst(this: *const c_void) -> StrokeStyle;
	fn tsControlButton_getStrokeStyle_c(this: *const c_void) -> StrokeStyle;
	fn tsControlButton_getStrokeStyle(this: *mut c_void) -> StrokeStyle;
	fn tsControlButton_setGradientStyle(this: *mut c_void, style: *const GradientStyle);
	fn tsControlButton_getGradientStyleConst(this: *const c_void) -> GradientStyle;
	fn tsControlButton_getGradientStyle_c(this: *const c_void) -> GradientStyle;
	fn tsControlButton_getGradientStyle(this: *mut c_void) -> GradientStyle;
	fn tsControlButton_setPressedCallback(this: *mut c_void, func: ControlButtonPressedCallback, data_: *mut c_void);
	fn tsControlButton_isPressed(this: *mut c_void) -> i32;
	fn tsControlButton_setReleasedCallback(this: *mut c_void, func: ControlButtonReleasedCallback, data_: *mut c_void);
	fn tsControlButton_isReleased(this: *mut c_void) -> i32;
	fn tsControlButton_setClickedCallback(this: *mut c_void, func: ControlButtonClickedCallback, data_: *mut c_void);
	fn tsControlButton_isClicked(this: *mut c_void) -> i32;
	fn tsControlButton_getCanvasRect(this: *mut c_void) -> *mut c_void;
	fn tsControlButton_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlSlider
pub struct ControlSlider {
	this: *mut c_void,
	owner: bool,
}
type ControlSliderFormatCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void) -> *mut c_void;
unsafe extern "C" fn control_slider_format_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) -> *mut c_void where Func: FnMut(ControlSlider) -> string::String {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlSlider::new_ptr(a0);
	let ret = CString::new(func(a0_)).unwrap();
	tsString_new_su(ret.as_ptr(), MAXU32)
}
type ControlSliderPressedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_slider_pressed_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlSlider) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlSlider::new_ptr(a0);
	func(a0_)
}
type ControlSliderReleasedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_slider_released_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlSlider) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlSlider::new_ptr(a0);
	func(a0_)
}
type ControlSliderClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_slider_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlSlider) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlSlider::new_ptr(a0);
	func(a0_)
}
type ControlSliderChangedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_slider_changed_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlSlider) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlSlider::new_ptr(a0);
	func(a0_)
}
impl ControlSlider {
	pub fn null() -> ControlSlider { ControlSlider { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlSlider { unsafe { ControlSlider { this: tsControlSlider_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlSlider { unsafe { ControlSlider { this: tsControlSlider_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_text(parent: Option<&Control>, text: &str) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Cs(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_texts(parent: Option<&Control>, text: &String) -> ControlSlider { unsafe { ControlSlider { this: tsControlSlider_new_CcS(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this), owner: true } } }
	pub fn new_with_parent_text_digits(parent: Option<&Control>, text: &str, digits: u32) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Csu(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), digits), owner: true } }
	}
	pub fn new_with_parent_text_digits_value(parent: Option<&Control>, text: &str, digits: u32, value: f64) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Csuf64(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), digits, value), owner: true } }
	}
	pub fn new_with_parent_text_digits_value_min(parent: Option<&Control>, text: &str, digits: u32, value: f64, min: f64, max: f64) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Csuf64f64f64(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), digits, value, min, max), owner: true } }
	}
	pub fn new_with_parent_text_valuef64(parent: Option<&Control>, text: &str, value: f64, min: f64, max: f64) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Csf64f64f64(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), value, min, max), owner: true } }
	}
	pub fn new_with_parent_text_valueu32(parent: Option<&Control>, text: &str, value: u32, min: u32, max: u32) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Csuuu(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), value, min, max), owner: true } }
	}
	pub fn new_with_parent_text_valuei32(parent: Option<&Control>, text: &str, value: i32, min: i32, max: i32) -> ControlSlider {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlSlider { this: tsControlSlider_new_Csiii(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr(), value, min, max), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> ControlSlider { unsafe { ControlSlider { this: ptr, owner: tsControlSlider_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlSlider { unsafe { ControlSlider { this: tsControlSlider_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlSlider { unsafe { ControlSlider::new_ptr(tsControlSlider_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlSlider_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlSlider) -> bool { unsafe { tsControlSlider_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlSlider { unsafe { ControlSlider { this: tsControlSlider_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlSlider_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlSlider_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlSlider_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlSlider_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlSlider_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlSlider_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlSlider_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlSlider_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlSlider_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_constrained(&mut self, constrained: bool) { unsafe { tsControlSlider_setConstrained(self.this, if constrained {1} else {0}) } }
	pub fn is_constrained(&self) -> bool { unsafe { tsControlSlider_isConstrained(self.this) != 0 } }
	pub fn set_text_enabled(&mut self, enabled: bool) { unsafe { tsControlSlider_setTextEnabled(self.this, if enabled {1} else {0}) } }
	pub fn is_text_enabled(&self) -> bool { unsafe { tsControlSlider_isTextEnabled(self.this) != 0 } }
	pub fn set_slider_color(&mut self, color: &Color) { unsafe { tsControlSlider_setSliderColor(self.this, color) } }
	pub fn slider_color(&self) -> Color { unsafe { tsControlSlider_getSliderColor(self.this) } }
	pub fn set_digits(&mut self, digits: u32) { unsafe { tsControlSlider_setDigits(self.this, digits) } }
	pub fn digits(&self) -> u32 { unsafe { tsControlSlider_getDigits(self.this) } }
	pub fn set_step(&mut self, step: f64) { unsafe { tsControlSlider_setStep(self.this, step) } }
	pub fn step(&self) -> f64 { unsafe { tsControlSlider_getStep(self.this) } }
	pub fn set_base(&mut self, base: f64) { unsafe { tsControlSlider_setBase(self.this, base) } }
	pub fn base(&self) -> f64 { unsafe { tsControlSlider_getBase(self.this) } }
	pub fn set_format(&mut self, format: &str) {
		let format_ = CString::new(format).unwrap();
		unsafe { tsControlSlider_setFormat_s(self.this, format_.as_ptr()) }
	}
	pub fn set_format_with_format(&mut self, format: &String) { unsafe { tsControlSlider_setFormat_cS(self.this, format.this) } }
	pub fn format(&self) -> string::String { unsafe { get_string(tsControlSlider_getFormat(self.this)) } }
	pub fn set_value(&mut self, value: f64) { unsafe { tsControlSlider_setValue(self.this, value, 0, 0) } }
	pub fn set_value_with_callback(&mut self, value: f64, callback: bool) { unsafe { tsControlSlider_setValue(self.this, value, if callback {1} else {0}, 0) } }
	pub fn set_value_with_callback_exponent(&mut self, value: f64, callback: bool, exponent: bool) { unsafe { tsControlSlider_setValue(self.this, value, if callback {1} else {0}, if exponent {1} else {0}) } }
	pub fn value(&self) -> f64 { unsafe { tsControlSlider_getValue(self.this, 0) } }
	pub fn value_with_exponent(&self, exponent: bool) -> f64 { unsafe { tsControlSlider_getValue(self.this, if exponent {1} else {0}) } }
	pub fn valuef32(&self) -> f32 { unsafe { tsControlSlider_getValuef32(self.this, 0) } }
	pub fn valuef32_with_exponent(&self, exponent: bool) -> f32 { unsafe { tsControlSlider_getValuef32(self.this, if exponent {1} else {0}) } }
	pub fn valueu32(&self) -> u32 { unsafe { tsControlSlider_getValueu32(self.this, 0) } }
	pub fn valueu32_with_exponent(&self, exponent: bool) -> u32 { unsafe { tsControlSlider_getValueu32(self.this, if exponent {1} else {0}) } }
	pub fn valuei32(&self) -> i32 { unsafe { tsControlSlider_getValuei32(self.this, 0) } }
	pub fn valuei32_with_exponent(&self, exponent: bool) -> i32 { unsafe { tsControlSlider_getValuei32(self.this, if exponent {1} else {0}) } }
	pub fn set_range(&mut self, min: f64, max: f64) { unsafe { tsControlSlider_setRange(self.this, min, max, 0) } }
	pub fn set_range_with_exponent(&mut self, min: f64, max: f64, exponent: bool) { unsafe { tsControlSlider_setRange(self.this, min, max, if exponent {1} else {0}) } }
	pub fn min_range(&self) -> f64 { unsafe { tsControlSlider_getMinRange(self.this, 0) } }
	pub fn min_range_with_exponent(&self, exponent: bool) -> f64 { unsafe { tsControlSlider_getMinRange(self.this, if exponent {1} else {0}) } }
	pub fn max_range(&self) -> f64 { unsafe { tsControlSlider_getMaxRange(self.this, 0) } }
	pub fn max_range_with_exponent(&self, exponent: bool) -> f64 { unsafe { tsControlSlider_getMaxRange(self.this, if exponent {1} else {0}) } }
	pub fn set_handle_size(&mut self, size: f32) { unsafe { tsControlSlider_setHandleSize(self.this, size) } }
	pub fn handle_size(&self) -> f32 { unsafe { tsControlSlider_getHandleSize(self.this) } }
	pub fn set_format_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) -> string::String {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_format_callback_func::<Func>;
		unsafe { tsControlSlider_setFormatCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_pressed_callback_func::<Func>;
		unsafe { tsControlSlider_setPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_pressed(&mut self) -> bool { unsafe { tsControlSlider_isPressed(self.this) != 0 } }
	pub fn set_released_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_released_callback_func::<Func>;
		unsafe { tsControlSlider_setReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_released(&mut self) -> bool { unsafe { tsControlSlider_isReleased(self.this) != 0 } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_clicked_callback_func::<Func>;
		unsafe { tsControlSlider_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_clicked_callback_func::<Func>;
		unsafe { tsControlSlider_setClicked2Callback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_clicked_callback_func::<Func>;
		unsafe { tsControlSlider_setClickedRightCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlSlider_isClicked(self.this) != 0 } }
	pub fn set_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlSlider) {
		let func = Box::leak(Box::new(func));
		let func_ = control_slider_changed_callback_func::<Func>;
		unsafe { tsControlSlider_setChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_changed(&mut self) -> bool { unsafe { tsControlSlider_isChanged(self.this, 1) != 0 } }
	pub fn is_changed_with_clear(&mut self, clear: bool) -> bool { unsafe { tsControlSlider_isChanged(self.this, if clear {1} else {0}) != 0 } }
	pub fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlSlider_getCanvasMesh(self.this)) } }
}
impl ControlTextTrait for ControlSlider {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlSlider {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlSlider {
	fn drop(&mut self) { if self.owner { unsafe { tsControlSlider_delete(self.this) } } }
}
impl Clone for ControlSlider {
	fn clone(&self) -> ControlSlider { unsafe { ControlSlider { this: tsControlSlider_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlSlider { }
impl fmt::Display for ControlSlider {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlSlider ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlSlider_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlSlider_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlSlider_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlSlider_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlSlider_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlSlider_new() -> *mut c_void;
	fn tsControlSlider_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlSlider_new_Cs(parent: *const *mut c_void, text: *const c_char) -> *mut c_void;
	fn tsControlSlider_new_CcS(parent: *const *mut c_void, text: *mut c_void) -> *mut c_void;
	fn tsControlSlider_new_Csu(parent: *const *mut c_void, text: *const c_char, digits: u32) -> *mut c_void;
	fn tsControlSlider_new_Csuf64(parent: *const *mut c_void, text: *const c_char, digits: u32, value: f64) -> *mut c_void;
	fn tsControlSlider_new_Csuf64f64f64(parent: *const *mut c_void, text: *const c_char, digits: u32, value: f64, min: f64, max: f64) -> *mut c_void;
	fn tsControlSlider_new_Csf64f64f64(parent: *const *mut c_void, text: *const c_char, value: f64, min: f64, max: f64) -> *mut c_void;
	fn tsControlSlider_new_Csuuu(parent: *const *mut c_void, text: *const c_char, value: u32, min: u32, max: u32) -> *mut c_void;
	fn tsControlSlider_new_Csiii(parent: *const *mut c_void, text: *const c_char, value: i32, min: i32, max: i32) -> *mut c_void;
	fn tsControlSlider_delete(this: *mut c_void);
	fn tsControlSlider_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlSlider_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSlider_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlSlider_clearPtr(this: *const c_void);
	fn tsControlSlider_destroyPtr(this: *const c_void);
	fn tsControlSlider_acquirePtr(this: *const c_void);
	fn tsControlSlider_unacquirePtr(this: *const c_void);
	fn tsControlSlider_isValidPtr(this: *const c_void) -> i32;
	fn tsControlSlider_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlSlider_isConstPtr(this: *const c_void) -> i32;
	fn tsControlSlider_getCountPtr(this: *const c_void) -> u32;
	fn tsControlSlider_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSlider_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlSlider_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSlider_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSlider_setConstrained(this: *mut c_void, constrained: i32);
	fn tsControlSlider_isConstrained(this: *const c_void) -> i32;
	fn tsControlSlider_setTextEnabled(this: *mut c_void, enabled: i32);
	fn tsControlSlider_isTextEnabled(this: *const c_void) -> i32;
	fn tsControlSlider_setSliderColor(this: *mut c_void, color: *const Color);
	fn tsControlSlider_getSliderColor(this: *const c_void) -> Color;
	fn tsControlSlider_setDigits(this: *mut c_void, digits: u32);
	fn tsControlSlider_getDigits(this: *const c_void) -> u32;
	fn tsControlSlider_setStep(this: *mut c_void, step: f64);
	fn tsControlSlider_getStep(this: *const c_void) -> f64;
	fn tsControlSlider_setBase(this: *mut c_void, base: f64);
	fn tsControlSlider_getBase(this: *const c_void) -> f64;
	fn tsControlSlider_setFormat_s(this: *mut c_void, format: *const c_char);
	fn tsControlSlider_setFormat_cS(this: *mut c_void, format: *mut c_void);
	fn tsControlSlider_getFormat(this: *const c_void) -> *mut c_void;
	fn tsControlSlider_setValue(this: *mut c_void, value: f64, callback: i32, exponent: i32);
	fn tsControlSlider_getValue(this: *const c_void, exponent: i32) -> f64;
	fn tsControlSlider_getValuef32(this: *const c_void, exponent: i32) -> f32;
	fn tsControlSlider_getValueu32(this: *const c_void, exponent: i32) -> u32;
	fn tsControlSlider_getValuei32(this: *const c_void, exponent: i32) -> i32;
	fn tsControlSlider_setRange(this: *mut c_void, min: f64, max: f64, exponent: i32);
	fn tsControlSlider_getMinRange(this: *const c_void, exponent: i32) -> f64;
	fn tsControlSlider_getMaxRange(this: *const c_void, exponent: i32) -> f64;
	fn tsControlSlider_setHandleSize(this: *mut c_void, size: f32);
	fn tsControlSlider_getHandleSize(this: *const c_void) -> f32;
	fn tsControlSlider_setFormatCallback(this: *mut c_void, func: ControlSliderFormatCallback, data_: *mut c_void);
	fn tsControlSlider_setPressedCallback(this: *mut c_void, func: ControlSliderPressedCallback, data_: *mut c_void);
	fn tsControlSlider_isPressed(this: *mut c_void) -> i32;
	fn tsControlSlider_setReleasedCallback(this: *mut c_void, func: ControlSliderReleasedCallback, data_: *mut c_void);
	fn tsControlSlider_isReleased(this: *mut c_void) -> i32;
	fn tsControlSlider_setClickedCallback(this: *mut c_void, func: ControlSliderClickedCallback, data_: *mut c_void);
	fn tsControlSlider_setClicked2Callback(this: *mut c_void, func: ControlSliderClickedCallback, data_: *mut c_void);
	fn tsControlSlider_setClickedRightCallback(this: *mut c_void, func: ControlSliderClickedCallback, data_: *mut c_void);
	fn tsControlSlider_isClicked(this: *mut c_void) -> i32;
	fn tsControlSlider_setChangedCallback(this: *mut c_void, func: ControlSliderChangedCallback, data_: *mut c_void);
	fn tsControlSlider_isChanged(this: *mut c_void, clear: i32) -> i32;
	fn tsControlSlider_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlScroll
pub struct ControlScroll {
	this: *mut c_void,
	owner: bool,
}
type ControlScrollClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_scroll_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlScroll) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlScroll::new_ptr(a0);
	func(a0_)
}
type ControlScrollChangedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_scroll_changed_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlScroll) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlScroll::new_ptr(a0);
	func(a0_)
}
impl ControlScroll {
	pub fn null() -> ControlScroll { ControlScroll { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new(), owner: true } } }
	pub fn new_with_parent_vertical(parent: Option<&Control>, vertical: bool) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cb(match parent { Some(parent) => &parent.this, None => ptr::null() }, if vertical {1} else {0}), owner: true } } }
	pub fn new_with_parent_valuef64(parent: Option<&Control>, value: f64) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cf64b(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, 0), owner: true } } }
	pub fn new_with_parent_valuef64_vertical(parent: Option<&Control>, value: f64, vertical: bool) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cf64b(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, if vertical {1} else {0}), owner: true } } }
	pub fn new_with_parent_valuef64_frame(parent: Option<&Control>, value: f64, frame: f64, range: f64) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cf64f64f64b(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, frame, range, 0), owner: true } } }
	pub fn new_with_parent_valuef64_frame_vertical(parent: Option<&Control>, value: f64, frame: f64, range: f64, vertical: bool) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cf64f64f64b(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, frame, range, if vertical {1} else {0}), owner: true } } }
	pub fn new_with_parent_valueu32(parent: Option<&Control>, value: u32, frame: u32, range: u32) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cuuub(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, frame, range, 0), owner: true } } }
	pub fn new_with_parent_valueu32_vertical(parent: Option<&Control>, value: u32, frame: u32, range: u32, vertical: bool) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Cuuub(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, frame, range, if vertical {1} else {0}), owner: true } } }
	pub fn new_with_parent_valuei32(parent: Option<&Control>, value: i32, frame: i32, range: i32) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Ciiib(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, frame, range, 0), owner: true } } }
	pub fn new_with_parent_valuei32_vertical(parent: Option<&Control>, value: i32, frame: i32, range: i32, vertical: bool) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_new_Ciiib(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, frame, range, if vertical {1} else {0}), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlScroll { unsafe { ControlScroll { this: ptr, owner: tsControlScroll_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlScroll { unsafe { ControlScroll::new_ptr(tsControlScroll_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlScroll_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlScroll) -> bool { unsafe { tsControlScroll_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlScroll_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlScroll_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlScroll_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlScroll_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlScroll_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlScroll_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlScroll_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlScroll_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlScroll_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_vertical(&mut self, vertical: bool) { unsafe { tsControlScroll_setVertical(self.this, if vertical {1} else {0}, 1) } }
	pub fn set_vertical_with_text(&mut self, vertical: bool, text: bool) { unsafe { tsControlScroll_setVertical(self.this, if vertical {1} else {0}, if text {1} else {0}) } }
	pub fn is_horizontal(&self) -> bool { unsafe { tsControlScroll_isHorizontal(self.this) != 0 } }
	pub fn is_vertical(&self) -> bool { unsafe { tsControlScroll_isVertical(self.this) != 0 } }
	pub fn set_prev_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlScroll_setPrevText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_prev_text_with_text(&mut self, text: &String) { unsafe { tsControlScroll_setPrevText_cS(self.this, text.this) } }
	pub fn prev_text(&self) -> string::String { unsafe { get_string(tsControlScroll_getPrevText(self.this)) } }
	pub fn set_next_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlScroll_setNextText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_next_text_with_text(&mut self, text: &String) { unsafe { tsControlScroll_setNextText_cS(self.this, text.this) } }
	pub fn next_text(&self) -> string::String { unsafe { get_string(tsControlScroll_getNextText(self.this)) } }
	pub fn set_scroll_color(&mut self, color: &Color) { unsafe { tsControlScroll_setScrollColor(self.this, color) } }
	pub fn scroll_color(&self) -> Color { unsafe { tsControlScroll_getScrollColor(self.this) } }
	pub fn set_step(&mut self, step: f64) { unsafe { tsControlScroll_setStep(self.this, step) } }
	pub fn step(&self) -> f64 { unsafe { tsControlScroll_getStep(self.this) } }
	pub fn set_value(&mut self, value: f64) { unsafe { tsControlScroll_setValue(self.this, value, 0) } }
	pub fn set_value_with_callback(&mut self, value: f64, callback: bool) { unsafe { tsControlScroll_setValue(self.this, value, if callback {1} else {0}) } }
	pub fn value(&self) -> f64 { unsafe { tsControlScroll_getValue(self.this) } }
	pub fn set_frame(&mut self, frame: f64) { unsafe { tsControlScroll_setFrame(self.this, frame) } }
	pub fn frame(&self) -> f64 { unsafe { tsControlScroll_getFrame(self.this) } }
	pub fn set_range(&mut self, range: f64) { unsafe { tsControlScroll_setRange(self.this, range) } }
	pub fn range(&self) -> f64 { unsafe { tsControlScroll_getRange(self.this) } }
	pub fn set_frame_align(&mut self, align: ControlAlign) { unsafe { tsControlScroll_setFrameAlign(self.this, align) } }
	pub fn frame_align(&self) -> ControlAlign { unsafe { tsControlScroll_getFrameAlign(self.this) } }
	pub fn has_frame_align(&self, align: ControlAlign) -> bool { unsafe { tsControlScroll_hasFrameAlign(self.this, align) != 0 } }
	pub fn has_frame_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlScroll_hasFrameAligns(self.this, aligns) != 0 } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlScroll) {
		let func = Box::leak(Box::new(func));
		let func_ = control_scroll_clicked_callback_func::<Func>;
		unsafe { tsControlScroll_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlScroll_isClicked(self.this) != 0 } }
	pub fn set_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlScroll) {
		let func = Box::leak(Box::new(func));
		let func_ = control_scroll_changed_callback_func::<Func>;
		unsafe { tsControlScroll_setChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_changed(&mut self) -> bool { unsafe { tsControlScroll_isChanged(self.this, 1) != 0 } }
	pub fn is_changed_with_clear(&mut self, clear: bool) -> bool { unsafe { tsControlScroll_isChanged(self.this, if clear {1} else {0}) != 0 } }
	pub fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlScroll_getCanvasMesh(self.this)) } }
}
impl ControlTextTrait for ControlScroll {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlScroll {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlScroll {
	fn drop(&mut self) { if self.owner { unsafe { tsControlScroll_delete(self.this) } } }
}
impl Clone for ControlScroll {
	fn clone(&self) -> ControlScroll { unsafe { ControlScroll { this: tsControlScroll_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlScroll { }
impl fmt::Display for ControlScroll {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlScroll ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlScroll_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlScroll_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlScroll_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlScroll_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlScroll_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlScroll_new() -> *mut c_void;
	fn tsControlScroll_new_Cb(parent: *const *mut c_void, vertical: i32) -> *mut c_void;
	fn tsControlScroll_new_Cf64b(parent: *const *mut c_void, value: f64, vertical: i32) -> *mut c_void;
	fn tsControlScroll_new_Cf64f64f64b(parent: *const *mut c_void, value: f64, frame: f64, range: f64, vertical: i32) -> *mut c_void;
	fn tsControlScroll_new_Cuuub(parent: *const *mut c_void, value: u32, frame: u32, range: u32, vertical: i32) -> *mut c_void;
	fn tsControlScroll_new_Ciiib(parent: *const *mut c_void, value: i32, frame: i32, range: i32, vertical: i32) -> *mut c_void;
	fn tsControlScroll_delete(this: *mut c_void);
	fn tsControlScroll_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlScroll_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_clearPtr(this: *const c_void);
	fn tsControlScroll_destroyPtr(this: *const c_void);
	fn tsControlScroll_acquirePtr(this: *const c_void);
	fn tsControlScroll_unacquirePtr(this: *const c_void);
	fn tsControlScroll_isValidPtr(this: *const c_void) -> i32;
	fn tsControlScroll_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlScroll_isConstPtr(this: *const c_void) -> i32;
	fn tsControlScroll_getCountPtr(this: *const c_void) -> u32;
	fn tsControlScroll_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlScroll_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_setVertical(this: *mut c_void, vertical: i32, text: i32);
	fn tsControlScroll_isHorizontal(this: *const c_void) -> i32;
	fn tsControlScroll_isVertical(this: *const c_void) -> i32;
	fn tsControlScroll_setPrevText_s(this: *mut c_void, text: *const c_char);
	fn tsControlScroll_setPrevText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlScroll_getPrevText(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_setNextText_s(this: *mut c_void, text: *const c_char);
	fn tsControlScroll_setNextText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlScroll_getNextText(this: *const c_void) -> *mut c_void;
	fn tsControlScroll_setScrollColor(this: *mut c_void, color: *const Color);
	fn tsControlScroll_getScrollColor(this: *const c_void) -> Color;
	fn tsControlScroll_setStep(this: *mut c_void, step: f64);
	fn tsControlScroll_getStep(this: *const c_void) -> f64;
	fn tsControlScroll_setValue(this: *mut c_void, value: f64, callback: i32);
	fn tsControlScroll_getValue(this: *const c_void) -> f64;
	fn tsControlScroll_setFrame(this: *mut c_void, frame: f64);
	fn tsControlScroll_getFrame(this: *const c_void) -> f64;
	fn tsControlScroll_setRange(this: *mut c_void, range: f64);
	fn tsControlScroll_getRange(this: *const c_void) -> f64;
	fn tsControlScroll_setFrameAlign(this: *mut c_void, align: ControlAlign);
	fn tsControlScroll_getFrameAlign(this: *const c_void) -> ControlAlign;
	fn tsControlScroll_hasFrameAlign(this: *const c_void, align: ControlAlign) -> i32;
	fn tsControlScroll_hasFrameAligns(this: *const c_void, aligns: ControlAlign) -> i32;
	fn tsControlScroll_setClickedCallback(this: *mut c_void, func: ControlScrollClickedCallback, data_: *mut c_void);
	fn tsControlScroll_isClicked(this: *mut c_void) -> i32;
	fn tsControlScroll_setChangedCallback(this: *mut c_void, func: ControlScrollChangedCallback, data_: *mut c_void);
	fn tsControlScroll_isChanged(this: *mut c_void, clear: i32) -> i32;
	fn tsControlScroll_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::ControlSplit
pub struct ControlSplit {
	this: *mut c_void,
	owner: bool,
}
impl ControlSplit {
	pub fn null() -> ControlSplit { ControlSplit { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_new_Cb(match parent { Some(parent) => &parent.this, None => ptr::null() }, 0), owner: true } } }
	pub fn new_with_parent_vertical(parent: Option<&Control>, vertical: bool) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_new_Cb(match parent { Some(parent) => &parent.this, None => ptr::null() }, if vertical {1} else {0}), owner: true } } }
	pub fn new_with_parent_value(parent: Option<&Control>, value: f32) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_new_Cfb(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, 0), owner: true } } }
	pub fn new_with_parent_value_vertical(parent: Option<&Control>, value: f32, vertical: bool) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_new_Cfb(match parent { Some(parent) => &parent.this, None => ptr::null() }, value, if vertical {1} else {0}), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlSplit { unsafe { ControlSplit { this: ptr, owner: tsControlSplit_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_copyPtr(self.this), owner: true } } }
	pub fn from_control(ptr: &Control) -> ControlSplit { unsafe { ControlSplit::new_ptr(tsControlSplit_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlSplit_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlSplit) -> bool { unsafe { tsControlSplit_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlSplit_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlSplit_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlSplit_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlSplit_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlSplit_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlSplit_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlSplit_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlSplit_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlSplit_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_absolute(&mut self, absolute: bool) { unsafe { tsControlSplit_setAbsolute(self.this, if absolute {1} else {0}) } }
	pub fn is_absolute(&self) -> bool { unsafe { tsControlSplit_isAbsolute(self.this) != 0 } }
	pub fn set_vertical(&mut self, vertical: bool) { unsafe { tsControlSplit_setVertical(self.this, if vertical {1} else {0}) } }
	pub fn is_horizontal(&self) -> bool { unsafe { tsControlSplit_isHorizontal(self.this) != 0 } }
	pub fn is_vertical(&self) -> bool { unsafe { tsControlSplit_isVertical(self.this) != 0 } }
	pub fn set_value(&mut self, value: f32) { unsafe { tsControlSplit_setValue(self.this, value) } }
	pub fn value(&self) -> f32 { unsafe { tsControlSplit_getValue(self.this) } }
	pub fn set_handle_size(&mut self, size: f32) { unsafe { tsControlSplit_setHandleSize(self.this, size) } }
	pub fn handle_size(&self) -> f32 { unsafe { tsControlSplit_getHandleSize(self.this) } }
	pub fn controls_size(&self) -> Vector2f { unsafe { tsControlSplit_getControlsSize(self.this) } }
}
impl ControlTrait for ControlSplit {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlSplit {
	fn drop(&mut self) { if self.owner { unsafe { tsControlSplit_delete(self.this) } } }
}
impl Clone for ControlSplit {
	fn clone(&self) -> ControlSplit { unsafe { ControlSplit { this: tsControlSplit_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlSplit { }
impl fmt::Display for ControlSplit {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlSplit ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlSplit_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlSplit_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlSplit_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlSplit_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlSplit_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlSplit_new() -> *mut c_void;
	fn tsControlSplit_new_Cb(parent: *const *mut c_void, vertical: i32) -> *mut c_void;
	fn tsControlSplit_new_Cfb(parent: *const *mut c_void, value: f32, vertical: i32) -> *mut c_void;
	fn tsControlSplit_delete(this: *mut c_void);
	fn tsControlSplit_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlSplit_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSplit_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlSplit_clearPtr(this: *const c_void);
	fn tsControlSplit_destroyPtr(this: *const c_void);
	fn tsControlSplit_acquirePtr(this: *const c_void);
	fn tsControlSplit_unacquirePtr(this: *const c_void);
	fn tsControlSplit_isValidPtr(this: *const c_void) -> i32;
	fn tsControlSplit_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlSplit_isConstPtr(this: *const c_void) -> i32;
	fn tsControlSplit_getCountPtr(this: *const c_void) -> u32;
	fn tsControlSplit_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSplit_equalControlPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlSplit_castControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSplit_baseControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlSplit_setAbsolute(this: *mut c_void, absolute: i32);
	fn tsControlSplit_isAbsolute(this: *const c_void) -> i32;
	fn tsControlSplit_setVertical(this: *mut c_void, vertical: i32);
	fn tsControlSplit_isHorizontal(this: *const c_void) -> i32;
	fn tsControlSplit_isVertical(this: *const c_void) -> i32;
	fn tsControlSplit_setValue(this: *mut c_void, value: f32);
	fn tsControlSplit_getValue(this: *const c_void) -> f32;
	fn tsControlSplit_setHandleSize(this: *mut c_void, size: f32);
	fn tsControlSplit_getHandleSize(this: *const c_void) -> f32;
	fn tsControlSplit_getControlsSize(this: *const c_void) -> Vector2f;
}

// Tellusim::ControlArea
pub struct ControlArea {
	this: *mut c_void,
	owner: bool,
}
impl ControlArea {
	pub fn null() -> ControlArea { ControlArea { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlArea { unsafe { ControlArea { this: tsControlArea_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlArea { unsafe { ControlArea { this: tsControlArea_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_columns(parent: Option<&Control>, columns: u32) -> ControlArea { unsafe { ControlArea { this: tsControlArea_new_Cu(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns), owner: true } } }
	pub fn new_with_parent_horizontal(parent: Option<&Control>, horizontal: bool, vertical: bool) -> ControlArea { unsafe { ControlArea { this: tsControlArea_new_Cbb(match parent { Some(parent) => &parent.this, None => ptr::null() }, if horizontal {1} else {0}, if vertical {1} else {0}), owner: true } } }
	pub fn new_with_parent_columns_x(parent: Option<&Control>, columns: u32, x: f32, y: f32) -> ControlArea { unsafe { ControlArea { this: tsControlArea_new_Cuff(match parent { Some(parent) => &parent.this, None => ptr::null() }, columns, x, y), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlArea { unsafe { ControlArea { this: ptr, owner: tsControlArea_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlArea { unsafe { ControlArea { this: tsControlArea_copyPtr(self.this), owner: true } } }
	pub fn from_control(ptr: &Control) -> ControlArea { unsafe { ControlArea::new_ptr(tsControlArea_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlArea_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlArea) -> bool { unsafe { tsControlArea_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlArea { unsafe { ControlArea { this: tsControlArea_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlArea_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlArea_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlArea_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlArea_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlArea_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlArea_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlArea_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlArea_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlArea_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_absolute(&mut self, absolute: bool) { unsafe { tsControlArea_setAbsolute(self.this, if absolute {1} else {0}) } }
	pub fn is_absolute(&self) -> bool { unsafe { tsControlArea_isAbsolute(self.this) != 0 } }
	pub fn set_scalable(&mut self, scalable: bool) { unsafe { tsControlArea_setScalable(self.this, if scalable {1} else {0}) } }
	pub fn is_scalable(&self) -> bool { unsafe { tsControlArea_isScalable(self.this) != 0 } }
	pub fn set_scrollable(&mut self, scrollable: bool) { unsafe { tsControlArea_setScrollable(self.this, if scrollable {1} else {0}) } }
	pub fn is_scrollable(&self) -> bool { unsafe { tsControlArea_isScrollable(self.this) != 0 } }
	pub fn set_scale(&mut self, scale: f32) { unsafe { tsControlArea_setScale(self.this, scale) } }
	pub fn scale(&self) -> f32 { unsafe { tsControlArea_getScale(self.this) } }
	pub fn set_scale_range(&mut self, min: f32, max: f32) { unsafe { tsControlArea_setScaleRange(self.this, min, max) } }
	pub fn min_scale(&self) -> f32 { unsafe { tsControlArea_getMinScale(self.this) } }
	pub fn max_scale(&self) -> f32 { unsafe { tsControlArea_getMaxScale(self.this) } }
	pub fn set_horizontal_step(&mut self, step: f64) { unsafe { tsControlArea_setHorizontalStep(self.this, step) } }
	pub fn set_vertical_step(&mut self, step: f64) { unsafe { tsControlArea_setVerticalStep(self.this, step) } }
	pub fn set_step(&mut self, horizontal: f64, vertical: f64) { unsafe { tsControlArea_setStep(self.this, horizontal, vertical) } }
	pub fn horizontal_step(&self) -> f64 { unsafe { tsControlArea_getHorizontalStep(self.this) } }
	pub fn vertical_step(&self) -> f64 { unsafe { tsControlArea_getVerticalStep(self.this) } }
	pub fn set_horizontal_value(&mut self, value: f64) { unsafe { tsControlArea_setHorizontalValue(self.this, value) } }
	pub fn set_vertical_value(&mut self, value: f64) { unsafe { tsControlArea_setVerticalValue(self.this, value) } }
	pub fn set_value(&mut self, horizontal: f64, vertical: f64) { unsafe { tsControlArea_setValue(self.this, horizontal, vertical) } }
	pub fn horizontal_value(&self) -> f64 { unsafe { tsControlArea_getHorizontalValue(self.this) } }
	pub fn vertical_value(&self) -> f64 { unsafe { tsControlArea_getVerticalValue(self.this) } }
	pub fn set_frame_align(&mut self, align: ControlAlign) { unsafe { tsControlArea_setFrameAlign(self.this, align) } }
	pub fn frame_align(&self) -> ControlAlign { unsafe { tsControlArea_getFrameAlign(self.this) } }
	pub fn horizontal_frame(&self) -> f64 { unsafe { tsControlArea_getHorizontalFrame(self.this) } }
	pub fn vertical_frame(&self) -> f64 { unsafe { tsControlArea_getVerticalFrame(self.this) } }
	pub fn horizontal_range(&self) -> f64 { unsafe { tsControlArea_getHorizontalRange(self.this) } }
	pub fn vertical_range(&self) -> f64 { unsafe { tsControlArea_getVerticalRange(self.this) } }
	pub fn set_horizontal_enabled(&mut self, enabled: bool) { unsafe { tsControlArea_setHorizontalEnabled(self.this, if enabled {1} else {0}, 0) } }
	pub fn set_horizontal_enabled_with_dynamic(&mut self, enabled: bool, dynamic: bool) { unsafe { tsControlArea_setHorizontalEnabled(self.this, if enabled {1} else {0}, if dynamic {1} else {0}) } }
	pub fn is_horizontal_enabled(&self) -> bool { unsafe { tsControlArea_isHorizontalEnabled(self.this) != 0 } }
	pub fn is_horizontal_dynamic(&self) -> bool { unsafe { tsControlArea_isHorizontalDynamic(self.this) != 0 } }
	pub fn is_horizontal_hidden(&self) -> bool { unsafe { tsControlArea_isHorizontalHidden(self.this) != 0 } }
	pub fn horizontal_scroll(&self) -> ControlScroll { unsafe { ControlScroll::new_ptr(tsControlArea_getHorizontalScroll_c(self.this)) } }
	pub fn horizontal_scroll_mut(&mut self) -> ControlScroll { unsafe { ControlScroll::new_ptr(tsControlArea_getHorizontalScroll(self.this)) } }
	pub fn set_vertical_enabled(&mut self, enabled: bool) { unsafe { tsControlArea_setVerticalEnabled(self.this, if enabled {1} else {0}, 0) } }
	pub fn set_vertical_enabled_with_dynamic(&mut self, enabled: bool, dynamic: bool) { unsafe { tsControlArea_setVerticalEnabled(self.this, if enabled {1} else {0}, if dynamic {1} else {0}) } }
	pub fn is_vertical_enabled(&self) -> bool { unsafe { tsControlArea_isVerticalEnabled(self.this) != 0 } }
	pub fn is_vertical_dynamic(&self) -> bool { unsafe { tsControlArea_isVerticalDynamic(self.this) != 0 } }
	pub fn is_vertical_hidden(&self) -> bool { unsafe { tsControlArea_isVerticalHidden(self.this) != 0 } }
	pub fn vertical_scroll(&self) -> ControlScroll { unsafe { ControlScroll::new_ptr(tsControlArea_getVerticalScroll_c(self.this)) } }
	pub fn vertical_scroll_mut(&mut self) -> ControlScroll { unsafe { ControlScroll::new_ptr(tsControlArea_getVerticalScroll(self.this)) } }
	pub fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlArea_setFontSize(self.this, size) != 0 } }
	pub fn font_size(&self) -> u32 { unsafe { tsControlArea_getFontSize(self.this) } }
	pub fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlArea_setFontStyle(self.this, style) != 0 } }
	pub fn font_style_const(&self) -> FontStyle { unsafe { tsControlArea_getFontStyleConst(self.this) } }
	pub fn font_style(&self) -> FontStyle { unsafe { tsControlArea_getFontStyle_c(self.this) } }
	pub fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlArea_getFontStyle(self.this) } }
	pub fn set_columns(&mut self, columns: u32) { unsafe { tsControlArea_setColumns(self.this, columns) } }
	pub fn columns(&self) -> u32 { unsafe { tsControlArea_getColumns(self.this) } }
	pub fn set_spacing(&mut self, spacing: &Vector2f) { unsafe { tsControlArea_setSpacing_cV2(self.this, spacing) } }
	pub fn set_spacing_with_x(&mut self, x: f32, y: f32) { unsafe { tsControlArea_setSpacing_ff(self.this, x, y) } }
	pub fn spacing(&self) -> Vector2f { unsafe { tsControlArea_getSpacing(self.this) } }
	pub fn set_column_ratio(&mut self, index: u32, ratio: f32) { unsafe { tsControlArea_setColumnRatio(self.this, index, ratio) } }
	pub fn column_ratio(&self, index: u32) -> f32 { unsafe { tsControlArea_getColumnRatio(self.this, index) } }
	pub fn controls_size(&self) -> Vector2f { unsafe { tsControlArea_getControlsSize(self.this) } }
	pub fn controls_offset(&self) -> Vector2f { unsafe { tsControlArea_getControlsOffset(self.this) } }
	pub fn view_rect(&self) -> Rect { unsafe { tsControlArea_getViewRect(self.this) } }
}
impl ControlTrait for ControlArea {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlArea {
	fn drop(&mut self) { if self.owner { unsafe { tsControlArea_delete(self.this) } } }
}
impl Clone for ControlArea {
	fn clone(&self) -> ControlArea { unsafe { ControlArea { this: tsControlArea_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlArea { }
impl fmt::Display for ControlArea {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlArea ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlArea_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlArea_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlArea_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlArea_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlArea_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlArea_new() -> *mut c_void;
	fn tsControlArea_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlArea_new_Cu(parent: *const *mut c_void, columns: u32) -> *mut c_void;
	fn tsControlArea_new_Cbb(parent: *const *mut c_void, horizontal: i32, vertical: i32) -> *mut c_void;
	fn tsControlArea_new_Cuff(parent: *const *mut c_void, columns: u32, x: f32, y: f32) -> *mut c_void;
	fn tsControlArea_delete(this: *mut c_void);
	fn tsControlArea_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlArea_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlArea_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlArea_clearPtr(this: *const c_void);
	fn tsControlArea_destroyPtr(this: *const c_void);
	fn tsControlArea_acquirePtr(this: *const c_void);
	fn tsControlArea_unacquirePtr(this: *const c_void);
	fn tsControlArea_isValidPtr(this: *const c_void) -> i32;
	fn tsControlArea_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlArea_isConstPtr(this: *const c_void) -> i32;
	fn tsControlArea_getCountPtr(this: *const c_void) -> u32;
	fn tsControlArea_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlArea_equalControlPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlArea_castControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlArea_baseControlPtr(this: *const c_void) -> *mut c_void;
	fn tsControlArea_setAbsolute(this: *mut c_void, absolute: i32);
	fn tsControlArea_isAbsolute(this: *const c_void) -> i32;
	fn tsControlArea_setScalable(this: *mut c_void, scalable: i32);
	fn tsControlArea_isScalable(this: *const c_void) -> i32;
	fn tsControlArea_setScrollable(this: *mut c_void, scrollable: i32);
	fn tsControlArea_isScrollable(this: *const c_void) -> i32;
	fn tsControlArea_setScale(this: *mut c_void, scale: f32);
	fn tsControlArea_getScale(this: *const c_void) -> f32;
	fn tsControlArea_setScaleRange(this: *mut c_void, min: f32, max: f32);
	fn tsControlArea_getMinScale(this: *const c_void) -> f32;
	fn tsControlArea_getMaxScale(this: *const c_void) -> f32;
	fn tsControlArea_setHorizontalStep(this: *mut c_void, step: f64);
	fn tsControlArea_setVerticalStep(this: *mut c_void, step: f64);
	fn tsControlArea_setStep(this: *mut c_void, horizontal: f64, vertical: f64);
	fn tsControlArea_getHorizontalStep(this: *const c_void) -> f64;
	fn tsControlArea_getVerticalStep(this: *const c_void) -> f64;
	fn tsControlArea_setHorizontalValue(this: *mut c_void, value: f64);
	fn tsControlArea_setVerticalValue(this: *mut c_void, value: f64);
	fn tsControlArea_setValue(this: *mut c_void, horizontal: f64, vertical: f64);
	fn tsControlArea_getHorizontalValue(this: *const c_void) -> f64;
	fn tsControlArea_getVerticalValue(this: *const c_void) -> f64;
	fn tsControlArea_setFrameAlign(this: *mut c_void, align: ControlAlign);
	fn tsControlArea_getFrameAlign(this: *const c_void) -> ControlAlign;
	fn tsControlArea_getHorizontalFrame(this: *const c_void) -> f64;
	fn tsControlArea_getVerticalFrame(this: *const c_void) -> f64;
	fn tsControlArea_getHorizontalRange(this: *const c_void) -> f64;
	fn tsControlArea_getVerticalRange(this: *const c_void) -> f64;
	fn tsControlArea_setHorizontalEnabled(this: *mut c_void, enabled: i32, dynamic: i32);
	fn tsControlArea_isHorizontalEnabled(this: *const c_void) -> i32;
	fn tsControlArea_isHorizontalDynamic(this: *const c_void) -> i32;
	fn tsControlArea_isHorizontalHidden(this: *const c_void) -> i32;
	fn tsControlArea_getHorizontalScroll_c(this: *const c_void) -> *mut c_void;
	fn tsControlArea_getHorizontalScroll(this: *mut c_void) -> *mut c_void;
	fn tsControlArea_setVerticalEnabled(this: *mut c_void, enabled: i32, dynamic: i32);
	fn tsControlArea_isVerticalEnabled(this: *const c_void) -> i32;
	fn tsControlArea_isVerticalDynamic(this: *const c_void) -> i32;
	fn tsControlArea_isVerticalHidden(this: *const c_void) -> i32;
	fn tsControlArea_getVerticalScroll_c(this: *const c_void) -> *mut c_void;
	fn tsControlArea_getVerticalScroll(this: *mut c_void) -> *mut c_void;
	fn tsControlArea_setFontSize(this: *mut c_void, size: u32) -> i32;
	fn tsControlArea_getFontSize(this: *const c_void) -> u32;
	fn tsControlArea_setFontStyle(this: *mut c_void, style: *const FontStyle) -> i32;
	fn tsControlArea_getFontStyleConst(this: *const c_void) -> FontStyle;
	fn tsControlArea_getFontStyle_c(this: *const c_void) -> FontStyle;
	fn tsControlArea_getFontStyle(this: *mut c_void) -> FontStyle;
	fn tsControlArea_setColumns(this: *mut c_void, columns: u32);
	fn tsControlArea_getColumns(this: *const c_void) -> u32;
	fn tsControlArea_setSpacing_cV2(this: *mut c_void, spacing: *const Vector2f);
	fn tsControlArea_setSpacing_ff(this: *mut c_void, x: f32, y: f32);
	fn tsControlArea_getSpacing(this: *const c_void) -> Vector2f;
	fn tsControlArea_setColumnRatio(this: *mut c_void, index: u32, ratio: f32);
	fn tsControlArea_getColumnRatio(this: *const c_void, index: u32) -> f32;
	fn tsControlArea_getControlsSize(this: *const c_void) -> Vector2f;
	fn tsControlArea_getControlsOffset(this: *const c_void) -> Vector2f;
	fn tsControlArea_getViewRect(this: *const c_void) -> Rect;
}

// Tellusim::ControlTree
pub struct ControlTree {
	this: *mut c_void,
	owner: bool,
}
type ControlTreeChangedCallback = unsafe extern "C" fn(a0: *mut c_void, item: u32, data_: *mut c_void);
unsafe extern "C" fn control_tree_changed_callback_func<Func>(a0: *mut c_void, item: u32, data_: *mut c_void) where Func: FnMut(ControlTree, u32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlTree::new_ptr(a0);
	func(a0_, item)
}
type ControlTreeDraggedCallback = unsafe extern "C" fn(a0: *mut c_void, item: u32, data_: *mut c_void) -> i32;
unsafe extern "C" fn control_tree_dragged_callback_func<Func>(a0: *mut c_void, item: u32, data_: *mut c_void) -> i32 where Func: FnMut(ControlTree, u32) -> bool {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlTree::new_ptr(a0);
	if func(a0_, item) {1} else {0}
}
type ControlTreeDroppedCallback = unsafe extern "C" fn(a0: *mut c_void, item: u32, data_: *mut c_void);
unsafe extern "C" fn control_tree_dropped_callback_func<Func>(a0: *mut c_void, item: u32, data_: *mut c_void) where Func: FnMut(ControlTree, u32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlTree::new_ptr(a0);
	func(a0_, item)
}
type ControlTreeClickedCallback = unsafe extern "C" fn(a0: *mut c_void, item: u32, data_: *mut c_void);
unsafe extern "C" fn control_tree_clicked_callback_func<Func>(a0: *mut c_void, item: u32, data_: *mut c_void) where Func: FnMut(ControlTree, u32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlTree::new_ptr(a0);
	func(a0_, item)
}
type ControlTreeExpandedCallback = unsafe extern "C" fn(a0: *mut c_void, item: u32, data_: *mut c_void);
unsafe extern "C" fn control_tree_expanded_callback_func<Func>(a0: *mut c_void, item: u32, data_: *mut c_void) where Func: FnMut(ControlTree, u32) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlTree::new_ptr(a0);
	func(a0_, item)
}
type ControlTreeSelectedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_tree_selected_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlTree) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlTree::new_ptr(a0);
	func(a0_)
}
impl ControlTree {
	pub fn null() -> ControlTree { ControlTree { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlTree { unsafe { ControlTree { this: tsControlTree_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlTree { unsafe { ControlTree { this: tsControlTree_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlTree { unsafe { ControlTree { this: ptr, owner: tsControlTree_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlTree { unsafe { ControlTree { this: tsControlTree_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlTree { unsafe { ControlTree::new_ptr(tsControlTree_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlTree_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlTree) -> bool { unsafe { tsControlTree_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlTree { unsafe { ControlTree { this: tsControlTree_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlTree_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlTree_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlTree_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlTree_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlTree_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlTree_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlTree_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlTree_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlTree_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_selectable(&mut self, selectable: bool) { unsafe { tsControlTree_setSelectable(self.this, if selectable {1} else {0}) } }
	pub fn is_selectable(&self) -> bool { unsafe { tsControlTree_isSelectable(self.this) != 0 } }
	pub fn set_multi_selection(&mut self, multi_selection: bool) { unsafe { tsControlTree_setMultiSelection(self.this, if multi_selection {1} else {0}) } }
	pub fn is_multi_selection(&self) -> bool { unsafe { tsControlTree_isMultiSelection(self.this) != 0 } }
	pub fn set_folded_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_setFoldedText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_folded_text_with_text(&mut self, text: &String) { unsafe { tsControlTree_setFoldedText_cS(self.this, text.this) } }
	pub fn folded_text(&self) -> string::String { unsafe { get_string(tsControlTree_getFoldedText(self.this)) } }
	pub fn set_expanded_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_setExpandedText_s(self.this, text_.as_ptr()) }
	}
	pub fn set_expanded_text_with_text(&mut self, text: &String) { unsafe { tsControlTree_setExpandedText_cS(self.this, text.this) } }
	pub fn expanded_text(&self) -> string::String { unsafe { get_string(tsControlTree_getExpandedText(self.this)) } }
	pub fn set_texture(&mut self, texture: &mut Texture) { unsafe { tsControlTree_setTexture(self.this, texture.this, 1, 1) } }
	pub fn set_texture_with_rows(&mut self, texture: &mut Texture, rows: u32) { unsafe { tsControlTree_setTexture(self.this, texture.this, rows, 1) } }
	pub fn set_texture_with_rows_columns(&mut self, texture: &mut Texture, rows: u32, columns: u32) { unsafe { tsControlTree_setTexture(self.this, texture.this, rows, columns) } }
	pub fn texture(&self) -> Texture { unsafe { Texture::new_ptr(tsControlTree_getTexture(self.this)) } }
	pub fn set_texture_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlTree_setTextureName_suu(self.this, name_.as_ptr(), 1, 1) }
	}
	pub fn set_texture_name_with_rows(&mut self, name: &str, rows: u32) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlTree_setTextureName_suu(self.this, name_.as_ptr(), rows, 1) }
	}
	pub fn set_texture_name_with_rows_columns(&mut self, name: &str, rows: u32, columns: u32) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlTree_setTextureName_suu(self.this, name_.as_ptr(), rows, columns) }
	}
	pub fn set_texture_name_with_name(&mut self, name: &String) { unsafe { tsControlTree_setTextureName_cSuu(self.this, name.this, 1, 1) } }
	pub fn set_texture_name_with_name_rows(&mut self, name: &String, rows: u32) { unsafe { tsControlTree_setTextureName_cSuu(self.this, name.this, rows, 1) } }
	pub fn set_texture_name_with_name_rows_columns(&mut self, name: &String, rows: u32, columns: u32) { unsafe { tsControlTree_setTextureName_cSuu(self.this, name.this, rows, columns) } }
	pub fn texture_name(&self) -> string::String { unsafe { get_string(tsControlTree_getTextureName(self.this)) } }
	pub fn set_texture_grid(&mut self, rows: u32, columns: u32) { unsafe { tsControlTree_setTextureGrid(self.this, rows, columns) } }
	pub fn texture_rows(&self) -> u32 { unsafe { tsControlTree_getTextureRows(self.this) } }
	pub fn texture_columns(&self) -> u32 { unsafe { tsControlTree_getTextureColumns(self.this) } }
	pub fn clear_items(&mut self) { unsafe { tsControlTree_clearItems(self.this) } }
	pub fn add_item(&mut self, text: &str) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_addItem_sub(self.this, text_.as_ptr(), MAXU32, 1) }
	}
	pub fn add_item_with_parent(&mut self, text: &str, parent: u32) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_addItem_sub(self.this, text_.as_ptr(), parent, 1) }
	}
	pub fn add_item_with_parent_expanded(&mut self, text: &str, parent: u32, expanded: bool) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_addItem_sub(self.this, text_.as_ptr(), parent, if expanded {1} else {0}) }
	}
	pub fn add_item_with_text(&mut self, text: &String) -> u32 { unsafe { tsControlTree_addItem_cSub(self.this, text.this, MAXU32, 1) } }
	pub fn add_item_with_text_parent(&mut self, text: &String, parent: u32) -> u32 { unsafe { tsControlTree_addItem_cSub(self.this, text.this, parent, 1) } }
	pub fn add_item_with_text_parent_expanded(&mut self, text: &String, parent: u32, expanded: bool) -> u32 { unsafe { tsControlTree_addItem_cSub(self.this, text.this, parent, if expanded {1} else {0}) } }
	pub fn remove_item(&mut self, item: u32) { unsafe { tsControlTree_removeItem(self.this, item, 0) } }
	pub fn remove_item_with_children(&mut self, item: u32, children: bool) { unsafe { tsControlTree_removeItem(self.this, item, if children {1} else {0}) } }
	pub fn view_item(&mut self, item: u32) { unsafe { tsControlTree_viewItem(self.this, item) } }
	pub fn num_items(&self) -> u32 { unsafe { tsControlTree_getNumItems(self.this) } }
	pub fn item(&self, index: u32) -> u32 { unsafe { tsControlTree_getItem(self.this, index) } }
	pub fn switch_item_hidden(&mut self, item: u32) -> bool { unsafe { tsControlTree_switchItemHidden(self.this, item, 0) != 0 } }
	pub fn switch_item_hidden_with_children(&mut self, item: u32, children: bool) -> bool { unsafe { tsControlTree_switchItemHidden(self.this, item, if children {1} else {0}) != 0 } }
	pub fn set_item_hidden(&mut self, item: u32, hidden: bool) { unsafe { tsControlTree_setItemHidden(self.this, item, if hidden {1} else {0}, 0) } }
	pub fn set_item_hidden_with_children(&mut self, item: u32, hidden: bool, children: bool) { unsafe { tsControlTree_setItemHidden(self.this, item, if hidden {1} else {0}, if children {1} else {0}) } }
	pub fn is_item_hidden(&self, item: u32) -> bool { unsafe { tsControlTree_isItemHidden(self.this, item) != 0 } }
	pub fn switch_item_expanded(&mut self, item: u32) -> bool { unsafe { tsControlTree_switchItemExpanded(self.this, item, 0) != 0 } }
	pub fn switch_item_expanded_with_children(&mut self, item: u32, children: bool) -> bool { unsafe { tsControlTree_switchItemExpanded(self.this, item, if children {1} else {0}) != 0 } }
	pub fn set_item_expanded(&mut self, item: u32, expanded: bool) { unsafe { tsControlTree_setItemExpanded(self.this, item, if expanded {1} else {0}, 0) } }
	pub fn set_item_expanded_with_children(&mut self, item: u32, expanded: bool, children: bool) { unsafe { tsControlTree_setItemExpanded(self.this, item, if expanded {1} else {0}, if children {1} else {0}) } }
	pub fn is_item_expanded(&self, item: u32) -> bool { unsafe { tsControlTree_isItemExpanded(self.this, item) != 0 } }
	pub fn switch_item_selected(&mut self, item: u32) -> bool { unsafe { tsControlTree_switchItemSelected(self.this, item, 0) != 0 } }
	pub fn switch_item_selected_with_children(&mut self, item: u32, children: bool) -> bool { unsafe { tsControlTree_switchItemSelected(self.this, item, if children {1} else {0}) != 0 } }
	pub fn set_item_selected(&mut self, item: u32, selected: bool) { unsafe { tsControlTree_setItemSelected(self.this, item, if selected {1} else {0}, 0) } }
	pub fn set_item_selected_with_children(&mut self, item: u32, selected: bool, children: bool) { unsafe { tsControlTree_setItemSelected(self.this, item, if selected {1} else {0}, if children {1} else {0}) } }
	pub fn is_item_selected(&self, item: u32) -> bool { unsafe { tsControlTree_isItemSelected(self.this, item) != 0 } }
	pub fn set_item_parent(&mut self, item: u32, parent: u32) { unsafe { tsControlTree_setItemParent(self.this, item, parent) } }
	pub fn item_parent(&self, item: u32) -> u32 { unsafe { tsControlTree_getItemParent(self.this, item) } }
	pub fn is_item_parent(&self, item: u32, parent: u32) -> bool { unsafe { tsControlTree_isItemParent(self.this, item, parent, 0) != 0 } }
	pub fn is_item_parent_with_hierarchy(&self, item: u32, parent: u32, hierarchy: bool) -> bool { unsafe { tsControlTree_isItemParent(self.this, item, parent, if hierarchy {1} else {0}) != 0 } }
	pub fn add_item_child(&mut self, item: u32, child: u32) { unsafe { tsControlTree_addItemChild(self.this, item, child) } }
	pub fn remove_item_child(&mut self, item: u32, child: u32) { unsafe { tsControlTree_removeItemChild(self.this, item, child) } }
	pub fn add_item_children(&mut self, item: u32, children: &[u32]) { unsafe { tsControlTree_addItemChildren(self.this, item, children.as_ptr(), children.len() as u32) } }
	pub fn remove_item_children(&mut self, item: u32, children: &[u32]) { unsafe { tsControlTree_removeItemChildren(self.this, item, children.as_ptr(), children.len() as u32) } }
	pub fn find_item_child(&self, item: u32, child: u32) -> u32 { unsafe { tsControlTree_findItemChild(self.this, item, child) } }
	pub fn is_item_child(&self, item: u32, child: u32) -> bool { unsafe { tsControlTree_isItemChild(self.this, item, child) != 0 } }
	pub fn num_item_children(&self, item: u32) -> u32 { unsafe { tsControlTree_getNumItemChildren(self.this, item) } }
	pub fn item_child(&self, item: u32, index: u32) -> u32 { unsafe { tsControlTree_getItemChild(self.this, item, index) } }
	pub fn set_item_text(&mut self, item: u32, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_setItemText_us(self.this, item, text_.as_ptr()) }
	}
	pub fn set_item_text_with_text(&mut self, item: u32, text: &String) { unsafe { tsControlTree_setItemText_ucS(self.this, item, text.this) } }
	pub fn item_text(&self, item: u32) -> string::String { unsafe { get_string(tsControlTree_getItemText(self.this, item)) } }
	pub fn find_item_text(&self, text: &str) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlTree_findItemText_cs(self.this, text_.as_ptr()) }
	}
	pub fn find_item_text_with_text(&self, text: &String) -> u32 { unsafe { tsControlTree_findItemText_ccS(self.this, text.this) } }
	pub fn set_item_color(&mut self, item: u32, color: &Color) { unsafe { tsControlTree_setItemColor(self.this, item, color) } }
	pub fn item_color(&self, item: u32) -> Color { unsafe { tsControlTree_getItemColor(self.this, item) } }
	pub fn set_item_texture(&mut self, item: u32, row: u32) { unsafe { tsControlTree_setItemTexture(self.this, item, row, 0) } }
	pub fn set_item_texture_with_column(&mut self, item: u32, row: u32, column: u32) { unsafe { tsControlTree_setItemTexture(self.this, item, row, column) } }
	pub fn item_texture_row(&self, item: u32) -> u32 { unsafe { tsControlTree_getItemTextureRow(self.this, item) } }
	pub fn item_texture_column(&self, item: u32) -> u32 { unsafe { tsControlTree_getItemTextureColumn(self.this, item) } }
	pub fn set_item_data(&mut self, item: u32, data: *mut c_void) { unsafe { tsControlTree_setItemData(self.this, item, data) } }
	pub fn item_data(&self, item: u32) -> *mut c_void { unsafe { tsControlTree_getItemData(self.this, item) } }
	pub fn focused_item(&self) -> u32 { unsafe { tsControlTree_getFocusedItem(self.this) } }
	pub fn set_current_item(&mut self, item: u32) { unsafe { tsControlTree_setCurrentItem(self.this, item, 0, 0, 0) } }
	pub fn set_current_item_with_select(&mut self, item: u32, select: bool) { unsafe { tsControlTree_setCurrentItem(self.this, item, if select {1} else {0}, 0, 0) } }
	pub fn set_current_item_with_select_view(&mut self, item: u32, select: bool, view: bool) { unsafe { tsControlTree_setCurrentItem(self.this, item, if select {1} else {0}, if view {1} else {0}, 0) } }
	pub fn set_current_item_with_select_view_callback(&mut self, item: u32, select: bool, view: bool, callback: bool) { unsafe { tsControlTree_setCurrentItem(self.this, item, if select {1} else {0}, if view {1} else {0}, if callback {1} else {0}) } }
	pub fn current_item(&self) -> u32 { unsafe { tsControlTree_getCurrentItem(self.this) } }
	pub fn current_text(&self) -> string::String { unsafe { get_string(tsControlTree_getCurrentText(self.this)) } }
	pub fn set_selection(&mut self) { unsafe { tsControlTree_setSelection(self.this) } }
	pub fn clear_selection(&mut self) { unsafe { tsControlTree_clearSelection(self.this) } }
	pub fn inverse_selection(&mut self) { unsafe { tsControlTree_inverseSelection(self.this) } }
	pub fn num_selected_items(&self) -> u32 { unsafe { tsControlTree_getNumSelectedItems(self.this) } }
	pub fn selected_item(&self, index: u32) -> u32 { unsafe { tsControlTree_getSelectedItem(self.this, index) } }
	pub fn set_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_changed_callback_func::<Func>;
		unsafe { tsControlTree_setChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_dragged_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_dragged_callback_func::<Func>;
		unsafe { tsControlTree_setDraggedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_dropped_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_dropped_callback_func::<Func>;
		unsafe { tsControlTree_setDroppedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_clicked_callback_func::<Func>;
		unsafe { tsControlTree_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_clicked2_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_clicked_callback_func::<Func>;
		unsafe { tsControlTree_setClicked2Callback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_clicked_right_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_clicked_callback_func::<Func>;
		unsafe { tsControlTree_setClickedRightCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_expanded_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree, u32) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_expanded_callback_func::<Func>;
		unsafe { tsControlTree_setExpandedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_selected_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlTree) {
		let func = Box::leak(Box::new(func));
		let func_ = control_tree_selected_callback_func::<Func>;
		unsafe { tsControlTree_setSelectedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
}
impl ControlTextTrait for ControlTree {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlTree {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlTree {
	fn drop(&mut self) { if self.owner { unsafe { tsControlTree_delete(self.this) } } }
}
impl Clone for ControlTree {
	fn clone(&self) -> ControlTree { unsafe { ControlTree { this: tsControlTree_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlTree { }
impl fmt::Display for ControlTree {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlTree ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlTree_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlTree_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlTree_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlTree_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlTree_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlTree_new() -> *mut c_void;
	fn tsControlTree_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlTree_delete(this: *mut c_void);
	fn tsControlTree_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlTree_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlTree_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlTree_clearPtr(this: *const c_void);
	fn tsControlTree_destroyPtr(this: *const c_void);
	fn tsControlTree_acquirePtr(this: *const c_void);
	fn tsControlTree_unacquirePtr(this: *const c_void);
	fn tsControlTree_isValidPtr(this: *const c_void) -> i32;
	fn tsControlTree_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlTree_isConstPtr(this: *const c_void) -> i32;
	fn tsControlTree_getCountPtr(this: *const c_void) -> u32;
	fn tsControlTree_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlTree_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlTree_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlTree_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlTree_setSelectable(this: *mut c_void, selectable: i32);
	fn tsControlTree_isSelectable(this: *const c_void) -> i32;
	fn tsControlTree_setMultiSelection(this: *mut c_void, multi_selection: i32);
	fn tsControlTree_isMultiSelection(this: *const c_void) -> i32;
	fn tsControlTree_setFoldedText_s(this: *mut c_void, text: *const c_char);
	fn tsControlTree_setFoldedText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlTree_getFoldedText(this: *const c_void) -> *mut c_void;
	fn tsControlTree_setExpandedText_s(this: *mut c_void, text: *const c_char);
	fn tsControlTree_setExpandedText_cS(this: *mut c_void, text: *mut c_void);
	fn tsControlTree_getExpandedText(this: *const c_void) -> *mut c_void;
	fn tsControlTree_setTexture(this: *mut c_void, texture: *mut c_void, rows: u32, columns: u32);
	fn tsControlTree_getTexture(this: *const c_void) -> *mut c_void;
	fn tsControlTree_setTextureName_suu(this: *mut c_void, name: *const c_char, rows: u32, columns: u32);
	fn tsControlTree_setTextureName_cSuu(this: *mut c_void, name: *mut c_void, rows: u32, columns: u32);
	fn tsControlTree_getTextureName(this: *const c_void) -> *mut c_void;
	fn tsControlTree_setTextureGrid(this: *mut c_void, rows: u32, columns: u32);
	fn tsControlTree_getTextureRows(this: *const c_void) -> u32;
	fn tsControlTree_getTextureColumns(this: *const c_void) -> u32;
	fn tsControlTree_clearItems(this: *mut c_void);
	fn tsControlTree_addItem_sub(this: *mut c_void, text: *const c_char, parent: u32, expanded: i32) -> u32;
	fn tsControlTree_addItem_cSub(this: *mut c_void, text: *mut c_void, parent: u32, expanded: i32) -> u32;
	fn tsControlTree_removeItem(this: *mut c_void, item: u32, children: i32);
	fn tsControlTree_viewItem(this: *mut c_void, item: u32);
	fn tsControlTree_getNumItems(this: *const c_void) -> u32;
	fn tsControlTree_getItem(this: *const c_void, index: u32) -> u32;
	fn tsControlTree_switchItemHidden(this: *mut c_void, item: u32, children: i32) -> i32;
	fn tsControlTree_setItemHidden(this: *mut c_void, item: u32, hidden: i32, children: i32);
	fn tsControlTree_isItemHidden(this: *const c_void, item: u32) -> i32;
	fn tsControlTree_switchItemExpanded(this: *mut c_void, item: u32, children: i32) -> i32;
	fn tsControlTree_setItemExpanded(this: *mut c_void, item: u32, expanded: i32, children: i32);
	fn tsControlTree_isItemExpanded(this: *const c_void, item: u32) -> i32;
	fn tsControlTree_switchItemSelected(this: *mut c_void, item: u32, children: i32) -> i32;
	fn tsControlTree_setItemSelected(this: *mut c_void, item: u32, selected: i32, children: i32);
	fn tsControlTree_isItemSelected(this: *const c_void, item: u32) -> i32;
	fn tsControlTree_setItemParent(this: *mut c_void, item: u32, parent: u32);
	fn tsControlTree_getItemParent(this: *const c_void, item: u32) -> u32;
	fn tsControlTree_isItemParent(this: *const c_void, item: u32, parent: u32, hierarchy: i32) -> i32;
	fn tsControlTree_addItemChild(this: *mut c_void, item: u32, child: u32);
	fn tsControlTree_removeItemChild(this: *mut c_void, item: u32, child: u32);
	fn tsControlTree_addItemChildren(this: *mut c_void, item: u32, children: *const u32, children_size: u32);
	fn tsControlTree_removeItemChildren(this: *mut c_void, item: u32, children: *const u32, children_size: u32);
	fn tsControlTree_findItemChild(this: *const c_void, item: u32, child: u32) -> u32;
	fn tsControlTree_isItemChild(this: *const c_void, item: u32, child: u32) -> i32;
	fn tsControlTree_getNumItemChildren(this: *const c_void, item: u32) -> u32;
	fn tsControlTree_getItemChild(this: *const c_void, item: u32, index: u32) -> u32;
	fn tsControlTree_setItemText_us(this: *mut c_void, item: u32, text: *const c_char);
	fn tsControlTree_setItemText_ucS(this: *mut c_void, item: u32, text: *mut c_void);
	fn tsControlTree_getItemText(this: *const c_void, item: u32) -> *mut c_void;
	fn tsControlTree_findItemText_cs(this: *const c_void, text: *const c_char) -> u32;
	fn tsControlTree_findItemText_ccS(this: *const c_void, text: *mut c_void) -> u32;
	fn tsControlTree_setItemColor(this: *mut c_void, item: u32, color: *const Color);
	fn tsControlTree_getItemColor(this: *const c_void, item: u32) -> Color;
	fn tsControlTree_setItemTexture(this: *mut c_void, item: u32, row: u32, column: u32);
	fn tsControlTree_getItemTextureRow(this: *const c_void, item: u32) -> u32;
	fn tsControlTree_getItemTextureColumn(this: *const c_void, item: u32) -> u32;
	fn tsControlTree_setItemData(this: *mut c_void, item: u32, data: *mut c_void);
	fn tsControlTree_getItemData(this: *const c_void, item: u32) -> *mut c_void;
	fn tsControlTree_getFocusedItem(this: *const c_void) -> u32;
	fn tsControlTree_setCurrentItem(this: *mut c_void, item: u32, select: i32, view: i32, callback: i32);
	fn tsControlTree_getCurrentItem(this: *const c_void) -> u32;
	fn tsControlTree_getCurrentText(this: *const c_void) -> *mut c_void;
	fn tsControlTree_setSelection(this: *mut c_void);
	fn tsControlTree_clearSelection(this: *mut c_void);
	fn tsControlTree_inverseSelection(this: *mut c_void);
	fn tsControlTree_getNumSelectedItems(this: *const c_void) -> u32;
	fn tsControlTree_getSelectedItem(this: *const c_void, index: u32) -> u32;
	fn tsControlTree_setChangedCallback(this: *mut c_void, func: ControlTreeChangedCallback, data_: *mut c_void);
	fn tsControlTree_setDraggedCallback(this: *mut c_void, func: ControlTreeDraggedCallback, data_: *mut c_void);
	fn tsControlTree_setDroppedCallback(this: *mut c_void, func: ControlTreeDroppedCallback, data_: *mut c_void);
	fn tsControlTree_setClickedCallback(this: *mut c_void, func: ControlTreeClickedCallback, data_: *mut c_void);
	fn tsControlTree_setClicked2Callback(this: *mut c_void, func: ControlTreeClickedCallback, data_: *mut c_void);
	fn tsControlTree_setClickedRightCallback(this: *mut c_void, func: ControlTreeClickedCallback, data_: *mut c_void);
	fn tsControlTree_setExpandedCallback(this: *mut c_void, func: ControlTreeExpandedCallback, data_: *mut c_void);
	fn tsControlTree_setSelectedCallback(this: *mut c_void, func: ControlTreeSelectedCallback, data_: *mut c_void);
}

// Tellusim::ControlEdit
pub struct ControlEdit {
	this: *mut c_void,
	owner: bool,
}
type ControlEditClickedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_edit_clicked_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlEdit) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlEdit::new_ptr(a0);
	func(a0_)
}
type ControlEditChangedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_edit_changed_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlEdit) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlEdit::new_ptr(a0);
	func(a0_)
}
type ControlEditReturnedCallback = unsafe extern "C" fn(a0: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn control_edit_returned_callback_func<Func>(a0: *mut c_void, data_: *mut c_void) where Func: FnMut(ControlEdit) {
	let func = &mut *(data_ as *mut Func);
	let a0_ = ControlEdit::new_ptr(a0);
	func(a0_)
}
impl ControlEdit {
	pub fn null() -> ControlEdit { ControlEdit { this: ptr::null_mut(), owner: false } }
	pub fn new() -> ControlEdit { unsafe { ControlEdit { this: tsControlEdit_new(), owner: true } } }
	pub fn new_with_parent(parent: Option<&Control>) -> ControlEdit { unsafe { ControlEdit { this: tsControlEdit_new_C(match parent { Some(parent) => &parent.this, None => ptr::null() }), owner: true } } }
	pub fn new_with_parent_text(parent: Option<&Control>, text: &str) -> ControlEdit {
		let text_ = CString::new(text).unwrap();
		unsafe { ControlEdit { this: tsControlEdit_new_Cs(match parent { Some(parent) => &parent.this, None => ptr::null() }, text_.as_ptr()), owner: true } }
	}
	pub fn new_with_parent_texts(parent: Option<&Control>, text: &String) -> ControlEdit { unsafe { ControlEdit { this: tsControlEdit_new_CcS(match parent { Some(parent) => &parent.this, None => ptr::null() }, text.this), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> ControlEdit { unsafe { ControlEdit { this: ptr, owner: tsControlEdit_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> ControlEdit { unsafe { ControlEdit { this: tsControlEdit_copyPtr(self.this), owner: true } } }
	pub fn from_control_text(ptr: &ControlText) -> ControlEdit { unsafe { ControlEdit::new_ptr(tsControlEdit_castControlTextPtr(ptr.this)) } }
	pub fn to_control_text(&self) -> ControlText { unsafe { ControlText::new_ptr(tsControlEdit_baseControlTextPtr(self.this)) } }
	pub fn from_control(ptr: &Control) -> ControlText { unsafe { ControlText::new_ptr(tsControlText_castControlPtr(ptr.this)) } }
	pub fn to_control(&self) -> Control { unsafe { Control::new_ptr(tsControlText_baseControlPtr(self.this)) } }
	pub fn equal_ptr(&self, ptr: ControlEdit) -> bool { unsafe { tsControlEdit_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> ControlEdit { unsafe { ControlEdit { this: tsControlEdit_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsControlEdit_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsControlEdit_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsControlEdit_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsControlEdit_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsControlEdit_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsControlEdit_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsControlEdit_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsControlEdit_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsControlEdit_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_frame(&mut self, frame: bool) { unsafe { tsControlEdit_setFrame(self.this, if frame {1} else {0}) } }
	pub fn frame(&self) -> bool { unsafe { tsControlEdit_getFrame(self.this) != 0 } }
	pub fn set_background(&mut self, background: bool) { unsafe { tsControlEdit_setBackground(self.this, if background {1} else {0}) } }
	pub fn background(&self) -> bool { unsafe { tsControlEdit_getBackground(self.this) != 0 } }
	pub fn set_edit_color(&mut self, color: &Color) { unsafe { tsControlEdit_setEditColor(self.this, color) } }
	pub fn edit_color(&self) -> Color { unsafe { tsControlEdit_getEditColor(self.this) } }
	pub fn set_edit_mode(&mut self, mode: ControlEditEditMode) { unsafe { tsControlEdit_setEditMode(self.this, mode) } }
	pub fn edit_mode(&self) -> ControlEditEditMode { unsafe { tsControlEdit_getEditMode(self.this) } }
	pub fn set_password_code(&mut self, code: u32) { unsafe { tsControlEdit_setPasswordCode(self.this, code) } }
	pub fn password_code(&self) -> u32 { unsafe { tsControlEdit_getPasswordCode(self.this) } }
	pub fn num_codes(&self) -> u32 { unsafe { tsControlEdit_getNumCodes(self.this) } }
	pub fn codes(&self) -> *const u32 { unsafe { tsControlEdit_getCodes(self.this) } }
	pub fn set_current_index(&mut self, index: u32) { unsafe { tsControlEdit_setCurrentIndex(self.this, index, MAXU32) } }
	pub fn set_current_index_with_selectionindex(&mut self, index: u32, selection_index: u32) { unsafe { tsControlEdit_setCurrentIndex(self.this, index, selection_index) } }
	pub fn current_index(&self) -> u32 { unsafe { tsControlEdit_getCurrentIndex(self.this) } }
	pub fn selection_index(&self) -> u32 { unsafe { tsControlEdit_getSelectionIndex(self.this) } }
	pub fn set_selection(&mut self) { unsafe { tsControlEdit_setSelection(self.this, 0, 0) } }
	pub fn set_selection_with_current(&mut self, current: bool) { unsafe { tsControlEdit_setSelection(self.this, if current {1} else {0}, 0) } }
	pub fn set_selection_with_current_changed(&mut self, current: bool, changed: bool) { unsafe { tsControlEdit_setSelection(self.this, if current {1} else {0}, if changed {1} else {0}) } }
	pub fn clear_selection(&mut self) { unsafe { tsControlEdit_clearSelection(self.this) } }
	pub fn selected_text(&self) -> string::String { unsafe { get_string(tsControlEdit_getSelectedText(self.this)) } }
	pub fn update_keyboard(&mut self, root: &mut ControlRoot, key: u32, code: u32) -> bool { unsafe { tsControlEdit_updateKeyboard(self.this, root.this, key, code) != 0 } }
	pub fn set_clicked_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlEdit) {
		let func = Box::leak(Box::new(func));
		let func_ = control_edit_clicked_callback_func::<Func>;
		unsafe { tsControlEdit_setClickedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_clicked(&mut self) -> bool { unsafe { tsControlEdit_isClicked(self.this) != 0 } }
	pub fn set_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlEdit) {
		let func = Box::leak(Box::new(func));
		let func_ = control_edit_changed_callback_func::<Func>;
		unsafe { tsControlEdit_setChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_changed(&mut self) -> bool { unsafe { tsControlEdit_isChanged(self.this) != 0 } }
	pub fn set_returned_callback<Func>(&mut self, func: Func) where Func: FnMut(ControlEdit) {
		let func = Box::leak(Box::new(func));
		let func_ = control_edit_returned_callback_func::<Func>;
		unsafe { tsControlEdit_setReturnedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn is_returned(&mut self) -> bool { unsafe { tsControlEdit_isReturned(self.this) != 0 } }
	pub fn canvas_mesh(&mut self) -> CanvasMesh { unsafe { CanvasMesh::new_ptr(tsControlEdit_getCanvasMesh(self.this)) } }
}
impl ControlTextTrait for ControlEdit {
	fn set_mode(&mut self, mode: CanvasElementMode) { unsafe { tsControlText_setMode(self.this, mode) } }
	fn mode(&self) -> CanvasElementMode { unsafe { tsControlText_getMode(self.this) } }
	fn set_pipeline(&mut self, pipeline: &mut Pipeline) { unsafe { tsControlText_setPipeline_P(self.this, pipeline.this) } }
	fn set_pipeline_with_func<Func>(&mut self, pipeline: &mut Pipeline, func: Func) where Func: FnMut(Command, CanvasElement) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = canvas_element_draw_callback_func::<Func>;
		unsafe { tsControlText_setPipeline_PcCEDC(self.this, pipeline.this, func_, func as *mut _ as *mut c_void) }
	}
	fn pipeline(&self) -> Pipeline { unsafe { Pipeline::new_ptr(tsControlText_getPipeline(self.this)) } }
	fn set_color(&mut self, color: &Color) { unsafe { tsControlText_setColor_cC(self.this, color) } }
	fn set_color_with_rgba(&mut self, r: f32, g: f32, b: f32, a: f32) { unsafe { tsControlText_setColor_ffff(self.this, r, g, b, a) } }
	fn color(&self) -> Color { unsafe { tsControlText_getColor(self.this) } }
	fn set_filter(&mut self, filter: SamplerFilter) { unsafe { tsControlText_setFilter(self.this, filter) } }
	fn filter(&self) -> SamplerFilter { unsafe { tsControlText_getFilter(self.this) } }
	fn set_anisotropy(&mut self, anisotropy: u32) { unsafe { tsControlText_setAnisotropy(self.this, anisotropy) } }
	fn anisotropy(&self) -> u32 { unsafe { tsControlText_getAnisotropy(self.this) } }
	fn set_blend(&mut self, op: PipelineBlendOp, src: PipelineBlendFunc, dest: PipelineBlendFunc) { unsafe { tsControlText_setBlend(self.this, op, src, dest) } }
	fn blend_op(&self) -> PipelineBlendOp { unsafe { tsControlText_getBlendOp(self.this) } }
	fn blend_src_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendSrcFunc(self.this) } }
	fn blend_dest_func(&self) -> PipelineBlendFunc { unsafe { tsControlText_getBlendDestFunc(self.this) } }
	fn set_font_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsControlText_setFontName_s(self.this, name_.as_ptr()) }
	}
	fn set_font_name_with_name(&mut self, name: &String) { unsafe { tsControlText_setFontName_cS(self.this, name.this) } }
	fn font_name(&self) -> string::String { unsafe { get_string(tsControlText_getFontName(self.this)) } }
	fn set_font_color(&mut self, color: &Color) { unsafe { tsControlText_setFontColor(self.this, color) } }
	fn font_color(&self) -> Color { unsafe { tsControlText_getFontColor(self.this) } }
	fn set_font_size(&mut self, size: u32) -> bool { unsafe { tsControlText_setFontSize(self.this, size) != 0 } }
	fn font_size(&self) -> u32 { unsafe { tsControlText_getFontSize(self.this) } }
	fn set_font_style(&mut self, style: &FontStyle) -> bool { unsafe { tsControlText_setFontStyle(self.this, style) != 0 } }
	fn font_style_const(&self) -> FontStyle { unsafe { tsControlText_getFontStyleConst(self.this) } }
	fn font_style(&self) -> FontStyle { unsafe { tsControlText_getFontStyle_c(self.this) } }
	fn font_style_mut(&mut self) -> FontStyle { unsafe { tsControlText_getFontStyle(self.this) } }
	fn set_font_align(&mut self, align: ControlAlign) { unsafe { tsControlText_setFontAlign(self.this, align) } }
	fn font_align(&self) -> ControlAlign { unsafe { tsControlText_getFontAlign(self.this) } }
	fn has_font_align(&self, align: ControlAlign) -> bool { unsafe { tsControlText_hasFontAlign(self.this, align) != 0 } }
	fn has_font_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControlText_hasFontAligns(self.this, aligns) != 0 } }
	fn set_text(&mut self, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsControlText_setText_s(self.this, text_.as_ptr()) }
	}
	fn set_text_with_text(&mut self, text: &String) { unsafe { tsControlText_setText_cS(self.this, text.this) } }
	fn text(&self) -> string::String { unsafe { get_string(tsControlText_getText(self.this)) } }
	fn canvas_text(&mut self) -> CanvasText { unsafe { CanvasText::new_ptr(tsControlText_getCanvasText(self.this)) } }
}
impl ControlTrait for ControlEdit {
	fn type_(&self) -> ControlType { unsafe { tsControl_getType(self.this) } }
	fn type_name_with_type(type_: ControlType) -> string::String { unsafe { get_cstring(tsControl_getTypeName_CT(type_)) } }
	fn type_name(&self) -> string::String { unsafe { get_cstring(tsControl_getTypeName_c(self.this)) } }
	fn is_unknown(&self) -> bool { unsafe { tsControl_isUnknown(self.this) != 0 } }
	fn is_root(&self) -> bool { unsafe { tsControl_isRoot(self.this) != 0 } }
	fn is_text(&self) -> bool { unsafe { tsControl_isText(self.this) != 0 } }
	fn is_rect(&self) -> bool { unsafe { tsControl_isRect(self.this) != 0 } }
	fn is_grid(&self) -> bool { unsafe { tsControl_isGrid(self.this) != 0 } }
	fn is_group(&self) -> bool { unsafe { tsControl_isGroup(self.this) != 0 } }
	fn is_panel(&self) -> bool { unsafe { tsControl_isPanel(self.this) != 0 } }
	fn is_dialog(&self) -> bool { unsafe { tsControl_isDialog(self.this) != 0 } }
	fn is_window(&self) -> bool { unsafe { tsControl_isWindow(self.this) != 0 } }
	fn is_check(&self) -> bool { unsafe { tsControl_isCheck(self.this) != 0 } }
	fn is_combo(&self) -> bool { unsafe { tsControl_isCombo(self.this) != 0 } }
	fn is_button(&self) -> bool { unsafe { tsControl_isButton(self.this) != 0 } }
	fn is_slider(&self) -> bool { unsafe { tsControl_isSlider(self.this) != 0 } }
	fn is_scroll(&self) -> bool { unsafe { tsControl_isScroll(self.this) != 0 } }
	fn is_split(&self) -> bool { unsafe { tsControl_isSplit(self.this) != 0 } }
	fn is_area(&self) -> bool { unsafe { tsControl_isArea(self.this) != 0 } }
	fn is_tree(&self) -> bool { unsafe { tsControl_isTree(self.this) != 0 } }
	fn is_edit(&self) -> bool { unsafe { tsControl_isEdit(self.this) != 0 } }
	fn set_align(&mut self, align: ControlAlign) { unsafe { tsControl_setAlign(self.this, align) } }
	fn align(&self) -> ControlAlign { unsafe { tsControl_getAlign(self.this) } }
	fn has_align(&self, align: ControlAlign) -> bool { unsafe { tsControl_hasAlign(self.this, align) != 0 } }
	fn has_aligns(&self, aligns: ControlAlign) -> bool { unsafe { tsControl_hasAligns(self.this, aligns) != 0 } }
	fn is_spacer(&self) -> bool { unsafe { tsControl_isSpacer(self.this) != 0 } }
	fn set_created(&mut self, created: bool) { unsafe { tsControl_setCreated(self.this, if created {1} else {0}) } }
	fn is_created(&self) -> bool { unsafe { tsControl_isCreated(self.this) != 0 } }
	fn set_enabled(&mut self, enabled: bool) { unsafe { tsControl_setEnabled(self.this, if enabled {1} else {0}) } }
	fn is_enabled(&self) -> bool { unsafe { tsControl_isEnabled(self.this) != 0 } }
	fn was_enabled(&self) -> bool { unsafe { tsControl_wasEnabled(self.this) != 0 } }
	fn was_updated(&self) -> bool { unsafe { tsControl_wasUpdated(self.this) != 0 } }
	fn set_disabled(&mut self, disabled: bool) { unsafe { tsControl_setDisabled(self.this, if disabled {1} else {0}) } }
	fn is_disabled(&self) -> bool { unsafe { tsControl_isDisabled(self.this) != 0 } }
	fn canvas(&self) -> Canvas { unsafe { Canvas::new_ptr(tsControl_getCanvas(self.this)) } }
	fn root(&self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot_c(self.this)) } }
	fn root_mut(&mut self) -> ControlRoot { unsafe { ControlRoot::new_ptr(tsControl_getRoot(self.this)) } }
	fn panel(&self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel_c(self.this)) } }
	fn panel_mut(&mut self) -> ControlPanel { unsafe { ControlPanel::new_ptr(tsControl_getPanel(self.this)) } }
	fn set_parent(&mut self, parent: &mut Control) -> u32 { unsafe { tsControl_setParent(self.this, parent.this) } }
	fn parent(&self) -> Control { unsafe { Control::new_ptr(tsControl_getParent_c(self.this)) } }
	fn parent_mut(&mut self) -> Control { unsafe { Control::new_ptr(tsControl_getParent(self.this)) } }
	fn is_parent_enabled(&self) -> bool { unsafe { tsControl_isParentEnabled(self.this) != 0 } }
	fn is_parent_disabled(&self) -> bool { unsafe { tsControl_isParentDisabled(self.this) != 0 } }
	fn add_child(&mut self, child: &mut Control) -> u32 { unsafe { tsControl_addChild(self.this, child.this) } }
	fn set_child(&mut self, index: u32, child: &mut Control) -> Control { unsafe { Control::new_ptr(tsControl_setChild(self.this, index, child.this)) } }
	fn raise_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_raiseChild(self.this, child.this) != 0 } }
	fn lower_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_lowerChild(self.this, child.this) != 0 } }
	fn remove_child(&mut self, child: &mut Control) -> bool { unsafe { tsControl_removeChild(self.this, child.this) != 0 } }
	fn release_children(&mut self) { unsafe { tsControl_releaseChildren(self.this) } }
	fn find_child(&self, child: &Control) -> u32 { unsafe { tsControl_findChild(self.this, child.this) } }
	fn is_child(&self, child: &Control) -> bool { unsafe { tsControl_isChild(self.this, child.this, 0) != 0 } }
	fn is_child_with_hierarchy(&self, child: &Control, hierarchy: bool) -> bool { unsafe { tsControl_isChild(self.this, child.this, if hierarchy {1} else {0}) != 0 } }
	fn num_children(&self) -> u32 { unsafe { tsControl_getNumChildren(self.this) } }
	fn child(&self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_cu(self.this, index)) } }
	fn child_mut(&mut self, index: u32) -> Control { unsafe { Control::new_ptr(tsControl_getChild_u(self.this, index)) } }
	fn set_size(&mut self, size: &Vector2f) { unsafe { tsControl_setSize_cV2(self.this, size) } }
	fn set_size_with_width(&mut self, width: f32, height: f32) { unsafe { tsControl_setSize_ff(self.this, width, height) } }
	fn size(&self) -> Vector2f { unsafe { tsControl_getSize(self.this) } }
	fn width(&self) -> f32 { unsafe { tsControl_getWidth(self.this) } }
	fn height(&self) -> f32 { unsafe { tsControl_getHeight(self.this) } }
	fn set_position(&mut self, position: &Vector3f) { unsafe { tsControl_setPosition_cV3(self.this, position) } }
	fn set_position_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, 0.0) } }
	fn set_position_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setPosition_fff(self.this, x, y, z) } }
	fn position(&self) -> Vector3f { unsafe { tsControl_getPosition(self.this) } }
	fn position_x(&self) -> f32 { unsafe { tsControl_getPositionX(self.this) } }
	fn position_y(&self) -> f32 { unsafe { tsControl_getPositionY(self.this) } }
	fn set_offset(&mut self, offset: &Vector3f) { unsafe { tsControl_setOffset_cV3(self.this, offset) } }
	fn set_offset_with_xy(&mut self, x: f32, y: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, 0.0) } }
	fn set_offset_with_xyz(&mut self, x: f32, y: f32, z: f32) { unsafe { tsControl_setOffset_fff(self.this, x, y, z) } }
	fn offset(&self) -> Vector3f { unsafe { tsControl_getOffset(self.this) } }
	fn offset_x(&self) -> f32 { unsafe { tsControl_getOffsetX(self.this) } }
	fn offset_y(&self) -> f32 { unsafe { tsControl_getOffsetY(self.this) } }
	fn set_margin(&mut self, value: f32) { unsafe { tsControl_setMargin_f(self.this, value) } }
	fn set_margin_with_horizontal(&mut self, horizontal: f32, vertical: f32) { unsafe { tsControl_setMargin_ff(self.this, horizontal, vertical) } }
	fn set_margin_with_left(&mut self, left: f32, right: f32, bottom: f32, top: f32) { unsafe { tsControl_setMargin_ffff(self.this, left, right, bottom, top) } }
	fn set_margin_with_margin(&mut self, margin: &Rect) { unsafe { tsControl_setMargin_cR(self.this, margin) } }
	fn margin(&self) -> Rect { unsafe { tsControl_getMargin(self.this) } }
	fn rect(&self) -> Rect { unsafe { tsControl_getRect(self.this) } }
	fn state(&self) -> ControlState { unsafe { tsControl_getState(self.this) } }
}
impl Drop for ControlEdit {
	fn drop(&mut self) { if self.owner { unsafe { tsControlEdit_delete(self.this) } } }
}
impl Clone for ControlEdit {
	fn clone(&self) -> ControlEdit { unsafe { ControlEdit { this: tsControlEdit_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for ControlEdit { }
impl fmt::Display for ControlEdit {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::ControlEdit ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsControlEdit_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsControlEdit_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsControlEdit_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsControlEdit_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsControlEdit_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsControlEdit_new() -> *mut c_void;
	fn tsControlEdit_new_C(parent: *const *mut c_void) -> *mut c_void;
	fn tsControlEdit_new_Cs(parent: *const *mut c_void, text: *const c_char) -> *mut c_void;
	fn tsControlEdit_new_CcS(parent: *const *mut c_void, text: *mut c_void) -> *mut c_void;
	fn tsControlEdit_delete(this: *mut c_void);
	fn tsControlEdit_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlEdit_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsControlEdit_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsControlEdit_clearPtr(this: *const c_void);
	fn tsControlEdit_destroyPtr(this: *const c_void);
	fn tsControlEdit_acquirePtr(this: *const c_void);
	fn tsControlEdit_unacquirePtr(this: *const c_void);
	fn tsControlEdit_isValidPtr(this: *const c_void) -> i32;
	fn tsControlEdit_isOwnerPtr(this: *const c_void) -> i32;
	fn tsControlEdit_isConstPtr(this: *const c_void) -> i32;
	fn tsControlEdit_getCountPtr(this: *const c_void) -> u32;
	fn tsControlEdit_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsControlEdit_equalControlTextPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsControlEdit_castControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlEdit_baseControlTextPtr(this: *const c_void) -> *mut c_void;
	fn tsControlEdit_setFrame(this: *mut c_void, frame: i32);
	fn tsControlEdit_getFrame(this: *const c_void) -> i32;
	fn tsControlEdit_setBackground(this: *mut c_void, background: i32);
	fn tsControlEdit_getBackground(this: *const c_void) -> i32;
	fn tsControlEdit_setEditColor(this: *mut c_void, color: *const Color);
	fn tsControlEdit_getEditColor(this: *const c_void) -> Color;
	fn tsControlEdit_setEditMode(this: *mut c_void, mode: ControlEditEditMode);
	fn tsControlEdit_getEditMode(this: *const c_void) -> ControlEditEditMode;
	fn tsControlEdit_setPasswordCode(this: *mut c_void, code: u32);
	fn tsControlEdit_getPasswordCode(this: *const c_void) -> u32;
	fn tsControlEdit_getNumCodes(this: *const c_void) -> u32;
	fn tsControlEdit_getCodes(this: *const c_void) -> *const u32;
	fn tsControlEdit_setCurrentIndex(this: *mut c_void, index: u32, selection_index: u32);
	fn tsControlEdit_getCurrentIndex(this: *const c_void) -> u32;
	fn tsControlEdit_getSelectionIndex(this: *const c_void) -> u32;
	fn tsControlEdit_setSelection(this: *mut c_void, current: i32, changed: i32);
	fn tsControlEdit_clearSelection(this: *mut c_void);
	fn tsControlEdit_getSelectedText(this: *const c_void) -> *mut c_void;
	fn tsControlEdit_updateKeyboard(this: *mut c_void, root: *mut c_void, key: u32, code: u32) -> i32;
	fn tsControlEdit_setClickedCallback(this: *mut c_void, func: ControlEditClickedCallback, data_: *mut c_void);
	fn tsControlEdit_isClicked(this: *mut c_void) -> i32;
	fn tsControlEdit_setChangedCallback(this: *mut c_void, func: ControlEditChangedCallback, data_: *mut c_void);
	fn tsControlEdit_isChanged(this: *mut c_void) -> i32;
	fn tsControlEdit_setReturnedCallback(this: *mut c_void, func: ControlEditReturnedCallback, data_: *mut c_void);
	fn tsControlEdit_isReturned(this: *mut c_void) -> i32;
	fn tsControlEdit_getCanvasMesh(this: *mut c_void) -> *mut c_void;
}

// Tellusim::DialogMessage
pub struct DialogMessage {
	this: *mut c_void,
	owner: bool,
}
type DialogMessageUpdateCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn dialog_message_update_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl DialogMessage {
	pub fn null() -> DialogMessage { DialogMessage { this: ptr::null_mut(), owner: false } }
	pub fn new_with_title(title: &str) -> DialogMessage {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogMessage { this: tsDialogMessage_new_ss(title_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_title_message(title: &str, message: &str) -> DialogMessage {
		let title_ = CString::new(title).unwrap();
		let message_ = CString::new(message).unwrap();
		unsafe { DialogMessage { this: tsDialogMessage_new_ss(title_.as_ptr(), message_.as_ptr()), owner: true } }
	}
	pub fn new_with_titles(title: &String) -> DialogMessage { unsafe { DialogMessage { this: tsDialogMessage_new_cSs(title.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_titles_message(title: &String, message: &str) -> DialogMessage {
		let message_ = CString::new(message).unwrap();
		unsafe { DialogMessage { this: tsDialogMessage_new_cSs(title.this, message_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> DialogMessage { unsafe { DialogMessage { this: ptr, owner: tsDialogMessage_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogMessage { unsafe { DialogMessage { this: tsDialogMessage_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogMessage) -> bool { unsafe { tsDialogMessage_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogMessage { unsafe { DialogMessage { this: tsDialogMessage_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogMessage_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogMessage_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogMessage_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogMessage_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogMessage_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogMessage_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogMessage_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogMessage_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogMessage_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogMessage_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogMessage_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogMessage_getPositionY(self.this) } }
	pub fn set_title(&mut self, title: &str) {
		let title_ = CString::new(title).unwrap();
		unsafe { tsDialogMessage_setTitle_s(self.this, title_.as_ptr()) }
	}
	pub fn set_title_with_title(&mut self, title: &String) { unsafe { tsDialogMessage_setTitle_cS(self.this, title.this) } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsDialogMessage_getTitle(self.this)) } }
	pub fn set_message(&mut self, message: &str) {
		let message_ = CString::new(message).unwrap();
		unsafe { tsDialogMessage_setMessage_s(self.this, message_.as_ptr()) }
	}
	pub fn set_message_with_message(&mut self, message: &String) { unsafe { tsDialogMessage_setMessage_cS(self.this, message.this) } }
	pub fn message(&self) -> string::String { unsafe { get_string(tsDialogMessage_getMessage(self.this)) } }
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_message_update_callback_func::<Func>;
		unsafe { tsDialogMessage_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run(&mut self) -> DialogMessageResult { unsafe { tsDialogMessage_run(self.this, DialogMessageFlags::Ok) } }
	pub fn run_with_flags(&mut self, flags: DialogMessageFlags) -> DialogMessageResult { unsafe { tsDialogMessage_run(self.this, flags) } }
}
impl Drop for DialogMessage {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogMessage_delete(self.this) } } }
}
impl Clone for DialogMessage {
	fn clone(&self) -> DialogMessage { unsafe { DialogMessage { this: tsDialogMessage_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogMessage { }
impl fmt::Display for DialogMessage {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogMessage ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogMessage_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogMessage_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogMessage_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogMessage_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogMessage_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogMessage_new_ss(title: *const c_char, message: *const c_char) -> *mut c_void;
	fn tsDialogMessage_new_cSs(title: *mut c_void, message: *const c_char) -> *mut c_void;
	fn tsDialogMessage_new_scS(title: *const c_char, message: *mut c_void) -> *mut c_void;
	fn tsDialogMessage_new_cScS(title: *mut c_void, message: *mut c_void) -> *mut c_void;
	fn tsDialogMessage_delete(this: *mut c_void);
	fn tsDialogMessage_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogMessage_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogMessage_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogMessage_clearPtr(this: *const c_void);
	fn tsDialogMessage_destroyPtr(this: *const c_void);
	fn tsDialogMessage_acquirePtr(this: *const c_void);
	fn tsDialogMessage_unacquirePtr(this: *const c_void);
	fn tsDialogMessage_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogMessage_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogMessage_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogMessage_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogMessage_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogMessage_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogMessage_getPositionX(this: *const c_void) -> i32;
	fn tsDialogMessage_getPositionY(this: *const c_void) -> i32;
	fn tsDialogMessage_setTitle_s(this: *mut c_void, title: *const c_char);
	fn tsDialogMessage_setTitle_cS(this: *mut c_void, title: *mut c_void);
	fn tsDialogMessage_getTitle(this: *const c_void) -> *mut c_void;
	fn tsDialogMessage_setMessage_s(this: *mut c_void, message: *const c_char);
	fn tsDialogMessage_setMessage_cS(this: *mut c_void, message: *mut c_void);
	fn tsDialogMessage_getMessage(this: *const c_void) -> *mut c_void;
	fn tsDialogMessage_setUpdateCallback(this: *mut c_void, func: DialogMessageUpdateCallback, data_: *mut c_void);
	fn tsDialogMessage_run(this: *mut c_void, flags: DialogMessageFlags) -> DialogMessageResult;
}

// Tellusim::DialogFileOpen
pub struct DialogFileOpen {
	this: *mut c_void,
	owner: bool,
}
type DialogFileOpenUpdateCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn dialog_file_open_update_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl DialogFileOpen {
	pub fn null() -> DialogFileOpen { DialogFileOpen { this: ptr::null_mut(), owner: false } }
	pub fn new_with_title(title: &str) -> DialogFileOpen {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogFileOpen { this: tsDialogFileOpen_new_ss(title_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_title_name(title: &str, name: &str) -> DialogFileOpen {
		let title_ = CString::new(title).unwrap();
		let name_ = CString::new(name).unwrap();
		unsafe { DialogFileOpen { this: tsDialogFileOpen_new_ss(title_.as_ptr(), name_.as_ptr()), owner: true } }
	}
	pub fn new_with_titles(title: &String) -> DialogFileOpen { unsafe { DialogFileOpen { this: tsDialogFileOpen_new_cSs(title.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_titles_name(title: &String, name: &str) -> DialogFileOpen {
		let name_ = CString::new(name).unwrap();
		unsafe { DialogFileOpen { this: tsDialogFileOpen_new_cSs(title.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> DialogFileOpen { unsafe { DialogFileOpen { this: ptr, owner: tsDialogFileOpen_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogFileOpen { unsafe { DialogFileOpen { this: tsDialogFileOpen_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogFileOpen) -> bool { unsafe { tsDialogFileOpen_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogFileOpen { unsafe { DialogFileOpen { this: tsDialogFileOpen_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogFileOpen_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogFileOpen_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogFileOpen_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogFileOpen_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogFileOpen_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogFileOpen_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogFileOpen_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogFileOpen_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogFileOpen_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogFileOpen_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogFileOpen_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogFileOpen_getPositionY(self.this) } }
	pub fn set_title(&mut self, title: &str) {
		let title_ = CString::new(title).unwrap();
		unsafe { tsDialogFileOpen_setTitle_s(self.this, title_.as_ptr()) }
	}
	pub fn set_title_with_title(&mut self, title: &String) { unsafe { tsDialogFileOpen_setTitle_cS(self.this, title.this) } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsDialogFileOpen_getTitle(self.this)) } }
	pub fn set_filter(&mut self, filter: &str) {
		let filter_ = CString::new(filter).unwrap();
		unsafe { tsDialogFileOpen_setFilter_s(self.this, filter_.as_ptr()) }
	}
	pub fn set_filter_with_filter(&mut self, filter: &String) { unsafe { tsDialogFileOpen_setFilter_cS(self.this, filter.this) } }
	pub fn filter(&self) -> string::String { unsafe { get_string(tsDialogFileOpen_getFilter(self.this)) } }
	pub fn set_file(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDialogFileOpen_setFile_s(self.this, name_.as_ptr()) }
	}
	pub fn set_file_with_name(&mut self, name: &String) { unsafe { tsDialogFileOpen_setFile_cS(self.this, name.this) } }
	pub fn file(&self) -> string::String { unsafe { get_string(tsDialogFileOpen_getFile(self.this)) } }
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_file_open_update_callback_func::<Func>;
		unsafe { tsDialogFileOpen_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run(&mut self) -> DialogFileOpenResult { unsafe { tsDialogFileOpen_run(self.this, DialogFileOpenFlags::None) } }
	pub fn run_with_flags(&mut self, flags: DialogFileOpenFlags) -> DialogFileOpenResult { unsafe { tsDialogFileOpen_run(self.this, flags) } }
}
impl Drop for DialogFileOpen {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogFileOpen_delete(self.this) } } }
}
impl Clone for DialogFileOpen {
	fn clone(&self) -> DialogFileOpen { unsafe { DialogFileOpen { this: tsDialogFileOpen_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogFileOpen { }
impl fmt::Display for DialogFileOpen {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogFileOpen ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogFileOpen_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogFileOpen_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogFileOpen_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogFileOpen_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogFileOpen_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogFileOpen_new_ss(title: *const c_char, name: *const c_char) -> *mut c_void;
	fn tsDialogFileOpen_new_cSs(title: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsDialogFileOpen_new_scS(title: *const c_char, name: *mut c_void) -> *mut c_void;
	fn tsDialogFileOpen_new_cScS(title: *mut c_void, name: *mut c_void) -> *mut c_void;
	fn tsDialogFileOpen_delete(this: *mut c_void);
	fn tsDialogFileOpen_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogFileOpen_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogFileOpen_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogFileOpen_clearPtr(this: *const c_void);
	fn tsDialogFileOpen_destroyPtr(this: *const c_void);
	fn tsDialogFileOpen_acquirePtr(this: *const c_void);
	fn tsDialogFileOpen_unacquirePtr(this: *const c_void);
	fn tsDialogFileOpen_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogFileOpen_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogFileOpen_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogFileOpen_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogFileOpen_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogFileOpen_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogFileOpen_getPositionX(this: *const c_void) -> i32;
	fn tsDialogFileOpen_getPositionY(this: *const c_void) -> i32;
	fn tsDialogFileOpen_setTitle_s(this: *mut c_void, title: *const c_char);
	fn tsDialogFileOpen_setTitle_cS(this: *mut c_void, title: *mut c_void);
	fn tsDialogFileOpen_getTitle(this: *const c_void) -> *mut c_void;
	fn tsDialogFileOpen_setFilter_s(this: *mut c_void, filter: *const c_char);
	fn tsDialogFileOpen_setFilter_cS(this: *mut c_void, filter: *mut c_void);
	fn tsDialogFileOpen_getFilter(this: *const c_void) -> *mut c_void;
	fn tsDialogFileOpen_setFile_s(this: *mut c_void, name: *const c_char);
	fn tsDialogFileOpen_setFile_cS(this: *mut c_void, name: *mut c_void);
	fn tsDialogFileOpen_getFile(this: *const c_void) -> *mut c_void;
	fn tsDialogFileOpen_setUpdateCallback(this: *mut c_void, func: DialogFileOpenUpdateCallback, data_: *mut c_void);
	fn tsDialogFileOpen_run(this: *mut c_void, flags: DialogFileOpenFlags) -> DialogFileOpenResult;
}

// Tellusim::DialogFileSave
pub struct DialogFileSave {
	this: *mut c_void,
	owner: bool,
}
type DialogFileSaveUpdateCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn dialog_file_save_update_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl DialogFileSave {
	pub fn null() -> DialogFileSave { DialogFileSave { this: ptr::null_mut(), owner: false } }
	pub fn new_with_title(title: &str) -> DialogFileSave {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogFileSave { this: tsDialogFileSave_new_ss(title_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_title_name(title: &str, name: &str) -> DialogFileSave {
		let title_ = CString::new(title).unwrap();
		let name_ = CString::new(name).unwrap();
		unsafe { DialogFileSave { this: tsDialogFileSave_new_ss(title_.as_ptr(), name_.as_ptr()), owner: true } }
	}
	pub fn new_with_titles(title: &String) -> DialogFileSave { unsafe { DialogFileSave { this: tsDialogFileSave_new_cSs(title.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_titles_name(title: &String, name: &str) -> DialogFileSave {
		let name_ = CString::new(name).unwrap();
		unsafe { DialogFileSave { this: tsDialogFileSave_new_cSs(title.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> DialogFileSave { unsafe { DialogFileSave { this: ptr, owner: tsDialogFileSave_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogFileSave { unsafe { DialogFileSave { this: tsDialogFileSave_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogFileSave) -> bool { unsafe { tsDialogFileSave_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogFileSave { unsafe { DialogFileSave { this: tsDialogFileSave_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogFileSave_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogFileSave_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogFileSave_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogFileSave_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogFileSave_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogFileSave_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogFileSave_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogFileSave_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogFileSave_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogFileSave_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogFileSave_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogFileSave_getPositionY(self.this) } }
	pub fn set_title(&mut self, title: &str) {
		let title_ = CString::new(title).unwrap();
		unsafe { tsDialogFileSave_setTitle_s(self.this, title_.as_ptr()) }
	}
	pub fn set_title_with_title(&mut self, title: &String) { unsafe { tsDialogFileSave_setTitle_cS(self.this, title.this) } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsDialogFileSave_getTitle(self.this)) } }
	pub fn set_filter(&mut self, filter: &str) {
		let filter_ = CString::new(filter).unwrap();
		unsafe { tsDialogFileSave_setFilter_s(self.this, filter_.as_ptr()) }
	}
	pub fn set_filter_with_filter(&mut self, filter: &String) { unsafe { tsDialogFileSave_setFilter_cS(self.this, filter.this) } }
	pub fn filter(&self) -> string::String { unsafe { get_string(tsDialogFileSave_getFilter(self.this)) } }
	pub fn set_file(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDialogFileSave_setFile_s(self.this, name_.as_ptr()) }
	}
	pub fn set_file_with_name(&mut self, name: &String) { unsafe { tsDialogFileSave_setFile_cS(self.this, name.this) } }
	pub fn file(&self) -> string::String { unsafe { get_string(tsDialogFileSave_getFile(self.this)) } }
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_file_save_update_callback_func::<Func>;
		unsafe { tsDialogFileSave_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run(&mut self) -> DialogFileSaveResult { unsafe { tsDialogFileSave_run(self.this, DialogFileSaveFlags::Overwrite) } }
	pub fn run_with_flags(&mut self, flags: DialogFileSaveFlags) -> DialogFileSaveResult { unsafe { tsDialogFileSave_run(self.this, flags) } }
}
impl Drop for DialogFileSave {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogFileSave_delete(self.this) } } }
}
impl Clone for DialogFileSave {
	fn clone(&self) -> DialogFileSave { unsafe { DialogFileSave { this: tsDialogFileSave_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogFileSave { }
impl fmt::Display for DialogFileSave {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogFileSave ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogFileSave_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogFileSave_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogFileSave_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogFileSave_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogFileSave_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogFileSave_new_ss(title: *const c_char, name: *const c_char) -> *mut c_void;
	fn tsDialogFileSave_new_cSs(title: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsDialogFileSave_new_scS(title: *const c_char, name: *mut c_void) -> *mut c_void;
	fn tsDialogFileSave_new_cScS(title: *mut c_void, name: *mut c_void) -> *mut c_void;
	fn tsDialogFileSave_delete(this: *mut c_void);
	fn tsDialogFileSave_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogFileSave_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogFileSave_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogFileSave_clearPtr(this: *const c_void);
	fn tsDialogFileSave_destroyPtr(this: *const c_void);
	fn tsDialogFileSave_acquirePtr(this: *const c_void);
	fn tsDialogFileSave_unacquirePtr(this: *const c_void);
	fn tsDialogFileSave_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogFileSave_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogFileSave_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogFileSave_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogFileSave_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogFileSave_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogFileSave_getPositionX(this: *const c_void) -> i32;
	fn tsDialogFileSave_getPositionY(this: *const c_void) -> i32;
	fn tsDialogFileSave_setTitle_s(this: *mut c_void, title: *const c_char);
	fn tsDialogFileSave_setTitle_cS(this: *mut c_void, title: *mut c_void);
	fn tsDialogFileSave_getTitle(this: *const c_void) -> *mut c_void;
	fn tsDialogFileSave_setFilter_s(this: *mut c_void, filter: *const c_char);
	fn tsDialogFileSave_setFilter_cS(this: *mut c_void, filter: *mut c_void);
	fn tsDialogFileSave_getFilter(this: *const c_void) -> *mut c_void;
	fn tsDialogFileSave_setFile_s(this: *mut c_void, name: *const c_char);
	fn tsDialogFileSave_setFile_cS(this: *mut c_void, name: *mut c_void);
	fn tsDialogFileSave_getFile(this: *const c_void) -> *mut c_void;
	fn tsDialogFileSave_setUpdateCallback(this: *mut c_void, func: DialogFileSaveUpdateCallback, data_: *mut c_void);
	fn tsDialogFileSave_run(this: *mut c_void, flags: DialogFileSaveFlags) -> DialogFileSaveResult;
}

// Tellusim::DialogDirectory
pub struct DialogDirectory {
	this: *mut c_void,
	owner: bool,
}
type DialogDirectoryUpdateCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn dialog_directory_update_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl DialogDirectory {
	pub fn null() -> DialogDirectory { DialogDirectory { this: ptr::null_mut(), owner: false } }
	pub fn new_with_title(title: &str) -> DialogDirectory {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogDirectory { this: tsDialogDirectory_new_ss(title_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_title_name(title: &str, name: &str) -> DialogDirectory {
		let title_ = CString::new(title).unwrap();
		let name_ = CString::new(name).unwrap();
		unsafe { DialogDirectory { this: tsDialogDirectory_new_ss(title_.as_ptr(), name_.as_ptr()), owner: true } }
	}
	pub fn new_with_titles(title: &String) -> DialogDirectory { unsafe { DialogDirectory { this: tsDialogDirectory_new_cSs(title.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_titles_name(title: &String, name: &str) -> DialogDirectory {
		let name_ = CString::new(name).unwrap();
		unsafe { DialogDirectory { this: tsDialogDirectory_new_cSs(title.this, name_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> DialogDirectory { unsafe { DialogDirectory { this: ptr, owner: tsDialogDirectory_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogDirectory { unsafe { DialogDirectory { this: tsDialogDirectory_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogDirectory) -> bool { unsafe { tsDialogDirectory_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogDirectory { unsafe { DialogDirectory { this: tsDialogDirectory_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogDirectory_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogDirectory_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogDirectory_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogDirectory_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogDirectory_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogDirectory_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogDirectory_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogDirectory_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogDirectory_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogDirectory_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogDirectory_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogDirectory_getPositionY(self.this) } }
	pub fn set_title(&mut self, title: &str) {
		let title_ = CString::new(title).unwrap();
		unsafe { tsDialogDirectory_setTitle_s(self.this, title_.as_ptr()) }
	}
	pub fn set_title_with_title(&mut self, title: &String) { unsafe { tsDialogDirectory_setTitle_cS(self.this, title.this) } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsDialogDirectory_getTitle(self.this)) } }
	pub fn set_directory(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDialogDirectory_setDirectory_s(self.this, name_.as_ptr()) }
	}
	pub fn set_directory_with_name(&mut self, name: &String) { unsafe { tsDialogDirectory_setDirectory_cS(self.this, name.this) } }
	pub fn directory(&self) -> string::String { unsafe { get_string(tsDialogDirectory_getDirectory(self.this)) } }
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_directory_update_callback_func::<Func>;
		unsafe { tsDialogDirectory_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run(&mut self) -> DialogDirectoryResult { unsafe { tsDialogDirectory_run(self.this, DialogDirectoryFlags::None) } }
	pub fn run_with_flags(&mut self, flags: DialogDirectoryFlags) -> DialogDirectoryResult { unsafe { tsDialogDirectory_run(self.this, flags) } }
}
impl Drop for DialogDirectory {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogDirectory_delete(self.this) } } }
}
impl Clone for DialogDirectory {
	fn clone(&self) -> DialogDirectory { unsafe { DialogDirectory { this: tsDialogDirectory_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogDirectory { }
impl fmt::Display for DialogDirectory {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogDirectory ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogDirectory_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogDirectory_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogDirectory_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogDirectory_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogDirectory_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogDirectory_new_ss(title: *const c_char, name: *const c_char) -> *mut c_void;
	fn tsDialogDirectory_new_cSs(title: *mut c_void, name: *const c_char) -> *mut c_void;
	fn tsDialogDirectory_new_scS(title: *const c_char, name: *mut c_void) -> *mut c_void;
	fn tsDialogDirectory_new_cScS(title: *mut c_void, name: *mut c_void) -> *mut c_void;
	fn tsDialogDirectory_delete(this: *mut c_void);
	fn tsDialogDirectory_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogDirectory_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogDirectory_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogDirectory_clearPtr(this: *const c_void);
	fn tsDialogDirectory_destroyPtr(this: *const c_void);
	fn tsDialogDirectory_acquirePtr(this: *const c_void);
	fn tsDialogDirectory_unacquirePtr(this: *const c_void);
	fn tsDialogDirectory_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogDirectory_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogDirectory_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogDirectory_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogDirectory_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogDirectory_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogDirectory_getPositionX(this: *const c_void) -> i32;
	fn tsDialogDirectory_getPositionY(this: *const c_void) -> i32;
	fn tsDialogDirectory_setTitle_s(this: *mut c_void, title: *const c_char);
	fn tsDialogDirectory_setTitle_cS(this: *mut c_void, title: *mut c_void);
	fn tsDialogDirectory_getTitle(this: *const c_void) -> *mut c_void;
	fn tsDialogDirectory_setDirectory_s(this: *mut c_void, name: *const c_char);
	fn tsDialogDirectory_setDirectory_cS(this: *mut c_void, name: *mut c_void);
	fn tsDialogDirectory_getDirectory(this: *const c_void) -> *mut c_void;
	fn tsDialogDirectory_setUpdateCallback(this: *mut c_void, func: DialogDirectoryUpdateCallback, data_: *mut c_void);
	fn tsDialogDirectory_run(this: *mut c_void, flags: DialogDirectoryFlags) -> DialogDirectoryResult;
}

// Tellusim::DialogProgress
pub struct DialogProgress {
	this: *mut c_void,
	owner: bool,
}
impl DialogProgress {
	pub fn null() -> DialogProgress { DialogProgress { this: ptr::null_mut(), owner: false } }
	pub fn new_with_title(title: &str) -> DialogProgress {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogProgress { this: tsDialogProgress_new_ss(title_.as_ptr(), ptr::null_mut()), owner: true } }
	}
	pub fn new_with_title_message(title: &str, message: &str) -> DialogProgress {
		let title_ = CString::new(title).unwrap();
		let message_ = CString::new(message).unwrap();
		unsafe { DialogProgress { this: tsDialogProgress_new_ss(title_.as_ptr(), message_.as_ptr()), owner: true } }
	}
	pub fn new_with_titles(title: &String) -> DialogProgress { unsafe { DialogProgress { this: tsDialogProgress_new_cSs(title.this, ptr::null_mut()), owner: true } } }
	pub fn new_with_titles_message(title: &String, message: &str) -> DialogProgress {
		let message_ = CString::new(message).unwrap();
		unsafe { DialogProgress { this: tsDialogProgress_new_cSs(title.this, message_.as_ptr()), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> DialogProgress { unsafe { DialogProgress { this: ptr, owner: tsDialogProgress_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogProgress { unsafe { DialogProgress { this: tsDialogProgress_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogProgress) -> bool { unsafe { tsDialogProgress_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogProgress { unsafe { DialogProgress { this: tsDialogProgress_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogProgress_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogProgress_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogProgress_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogProgress_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogProgress_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogProgress_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogProgress_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogProgress_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogProgress_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogProgress_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogProgress_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogProgress_getPositionY(self.this) } }
	pub fn set_title(&mut self, title: &str) {
		let title_ = CString::new(title).unwrap();
		unsafe { tsDialogProgress_setTitle_s(self.this, title_.as_ptr()) }
	}
	pub fn set_title_with_title(&mut self, title: &String) { unsafe { tsDialogProgress_setTitle_cS(self.this, title.this) } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsDialogProgress_getTitle(self.this)) } }
	pub fn set_message(&mut self, message: &str) {
		let message_ = CString::new(message).unwrap();
		unsafe { tsDialogProgress_setMessage_s(self.this, message_.as_ptr()) }
	}
	pub fn set_message_with_message(&mut self, message: &String) { unsafe { tsDialogProgress_setMessage_cS(self.this, message.this) } }
	pub fn message(&self) -> string::String { unsafe { get_string(tsDialogProgress_getMessage(self.this)) } }
	pub fn set_progress(&mut self, progress: u32) { unsafe { tsDialogProgress_setProgress(self.this, progress) } }
	pub fn progress(&self) -> u32 { unsafe { tsDialogProgress_getProgress(self.this) } }
	pub fn run(&mut self) -> DialogProgressResult { unsafe { tsDialogProgress_run(self.this, DialogProgressFlags::None) } }
	pub fn run_with_flags(&mut self, flags: DialogProgressFlags) -> DialogProgressResult { unsafe { tsDialogProgress_run(self.this, flags) } }
	pub fn close(&mut self) { unsafe { tsDialogProgress_close(self.this) } }
}
impl Drop for DialogProgress {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogProgress_delete(self.this) } } }
}
impl Clone for DialogProgress {
	fn clone(&self) -> DialogProgress { unsafe { DialogProgress { this: tsDialogProgress_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogProgress { }
impl fmt::Display for DialogProgress {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogProgress ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogProgress_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogProgress_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogProgress_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogProgress_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogProgress_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogProgress_new_ss(title: *const c_char, message: *const c_char) -> *mut c_void;
	fn tsDialogProgress_new_cSs(title: *mut c_void, message: *const c_char) -> *mut c_void;
	fn tsDialogProgress_new_scS(title: *const c_char, message: *mut c_void) -> *mut c_void;
	fn tsDialogProgress_new_cScS(title: *mut c_void, message: *mut c_void) -> *mut c_void;
	fn tsDialogProgress_delete(this: *mut c_void);
	fn tsDialogProgress_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogProgress_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogProgress_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogProgress_clearPtr(this: *const c_void);
	fn tsDialogProgress_destroyPtr(this: *const c_void);
	fn tsDialogProgress_acquirePtr(this: *const c_void);
	fn tsDialogProgress_unacquirePtr(this: *const c_void);
	fn tsDialogProgress_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogProgress_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogProgress_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogProgress_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogProgress_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogProgress_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogProgress_getPositionX(this: *const c_void) -> i32;
	fn tsDialogProgress_getPositionY(this: *const c_void) -> i32;
	fn tsDialogProgress_setTitle_s(this: *mut c_void, title: *const c_char);
	fn tsDialogProgress_setTitle_cS(this: *mut c_void, title: *mut c_void);
	fn tsDialogProgress_getTitle(this: *const c_void) -> *mut c_void;
	fn tsDialogProgress_setMessage_s(this: *mut c_void, message: *const c_char);
	fn tsDialogProgress_setMessage_cS(this: *mut c_void, message: *mut c_void);
	fn tsDialogProgress_getMessage(this: *const c_void) -> *mut c_void;
	fn tsDialogProgress_setProgress(this: *mut c_void, progress: u32);
	fn tsDialogProgress_getProgress(this: *const c_void) -> u32;
	fn tsDialogProgress_run(this: *mut c_void, flags: DialogProgressFlags) -> DialogProgressResult;
	fn tsDialogProgress_close(this: *mut c_void);
}

// Tellusim::DialogColor
pub struct DialogColor {
	this: *mut c_void,
	owner: bool,
}
type DialogColorChangedCallback = unsafe extern "C" fn(a0: Color, data_: *mut c_void);
unsafe extern "C" fn dialog_color_changed_callback_func<Func>(a0: Color, data_: *mut c_void) where Func: FnMut(Color) {
	let func = &mut *(data_ as *mut Func);
	func(a0)
}
type DialogColorUpdateCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn dialog_color_update_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl DialogColor {
	pub fn null() -> DialogColor { DialogColor { this: ptr::null_mut(), owner: false } }
	pub fn new() -> DialogColor { unsafe { DialogColor { this: tsDialogColor_new_scC(ptr::null_mut(), &Color::zero()), owner: true } } }
	pub fn new_with_title(title: &str) -> DialogColor {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogColor { this: tsDialogColor_new_scC(title_.as_ptr(), &Color::zero()), owner: true } }
	}
	pub fn new_with_title_color(title: &str, color: &Color) -> DialogColor {
		let title_ = CString::new(title).unwrap();
		unsafe { DialogColor { this: tsDialogColor_new_scC(title_.as_ptr(), color), owner: true } }
	}
	pub fn new_ptr(ptr: *mut c_void) -> DialogColor { unsafe { DialogColor { this: ptr, owner: tsDialogColor_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogColor { unsafe { DialogColor { this: tsDialogColor_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogColor) -> bool { unsafe { tsDialogColor_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogColor { unsafe { DialogColor { this: tsDialogColor_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogColor_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogColor_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogColor_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogColor_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogColor_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogColor_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogColor_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogColor_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogColor_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogColor_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogColor_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogColor_getPositionY(self.this) } }
	pub fn set_title(&mut self, title: &str) {
		let title_ = CString::new(title).unwrap();
		unsafe { tsDialogColor_setTitle_s(self.this, title_.as_ptr()) }
	}
	pub fn set_title_with_title(&mut self, title: &String) { unsafe { tsDialogColor_setTitle_cS(self.this, title.this) } }
	pub fn title(&self) -> string::String { unsafe { get_string(tsDialogColor_getTitle(self.this)) } }
	pub fn set_color(&mut self, color: &Color) { unsafe { tsDialogColor_setColor(self.this, color, 0) } }
	pub fn set_color_with_callback(&mut self, color: &Color, callback: bool) { unsafe { tsDialogColor_setColor(self.this, color, if callback {1} else {0}) } }
	pub fn color(&self) -> Color { unsafe { tsDialogColor_getColor(self.this) } }
	pub fn set_changed_callback<Func>(&mut self, func: Func) where Func: FnMut(Color) {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_color_changed_callback_func::<Func>;
		unsafe { tsDialogColor_setChangedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_color_update_callback_func::<Func>;
		unsafe { tsDialogColor_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run(&mut self) -> DialogColorResult { unsafe { tsDialogColor_run(self.this, DialogColorFlags::None) } }
	pub fn run_with_flags(&mut self, flags: DialogColorFlags) -> DialogColorResult { unsafe { tsDialogColor_run(self.this, flags) } }
}
impl Drop for DialogColor {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogColor_delete(self.this) } } }
}
impl Clone for DialogColor {
	fn clone(&self) -> DialogColor { unsafe { DialogColor { this: tsDialogColor_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogColor { }
impl fmt::Display for DialogColor {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogColor ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogColor_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogColor_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogColor_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogColor_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogColor_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogColor_new_scC(title: *const c_char, color: *const Color) -> *mut c_void;
	fn tsDialogColor_new_cScC(title: *mut c_void, color: *const Color) -> *mut c_void;
	fn tsDialogColor_delete(this: *mut c_void);
	fn tsDialogColor_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogColor_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogColor_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogColor_clearPtr(this: *const c_void);
	fn tsDialogColor_destroyPtr(this: *const c_void);
	fn tsDialogColor_acquirePtr(this: *const c_void);
	fn tsDialogColor_unacquirePtr(this: *const c_void);
	fn tsDialogColor_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogColor_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogColor_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogColor_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogColor_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogColor_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogColor_getPositionX(this: *const c_void) -> i32;
	fn tsDialogColor_getPositionY(this: *const c_void) -> i32;
	fn tsDialogColor_setTitle_s(this: *mut c_void, title: *const c_char);
	fn tsDialogColor_setTitle_cS(this: *mut c_void, title: *mut c_void);
	fn tsDialogColor_getTitle(this: *const c_void) -> *mut c_void;
	fn tsDialogColor_setColor(this: *mut c_void, color: *const Color, callback: i32);
	fn tsDialogColor_getColor(this: *const c_void) -> Color;
	fn tsDialogColor_setChangedCallback(this: *mut c_void, func: DialogColorChangedCallback, data_: *mut c_void);
	fn tsDialogColor_setUpdateCallback(this: *mut c_void, func: DialogColorUpdateCallback, data_: *mut c_void);
	fn tsDialogColor_run(this: *mut c_void, flags: DialogColorFlags) -> DialogColorResult;
}

// Tellusim::DialogMenu
pub struct DialogMenu {
	this: *mut c_void,
	owner: bool,
}
type DialogMenuClickedCallback = unsafe extern "C" fn(data_: *mut c_void);
unsafe extern "C" fn dialog_menu_clicked_callback_func<Func>(data_: *mut c_void) where Func: FnMut() {
	let func = &mut *(data_ as *mut Func);
	func()
}
type DialogMenuChangedCallback = unsafe extern "C" fn(a0: i32, data_: *mut c_void);
unsafe extern "C" fn dialog_menu_changed_callback_func<Func>(a0: i32, data_: *mut c_void) where Func: FnMut(bool) {
	let func = &mut *(data_ as *mut Func);
	func(a0 != 0)
}
type DialogMenuUpdateCallback = unsafe extern "C" fn(data_: *mut c_void) -> i32;
unsafe extern "C" fn dialog_menu_update_callback_func<Func>(data_: *mut c_void) -> i32 where Func: FnMut() -> bool {
	let func = &mut *(data_ as *mut Func);
	if func() {1} else {0}
}
impl DialogMenu {
	pub fn null() -> DialogMenu { DialogMenu { this: ptr::null_mut(), owner: false } }
	pub fn new() -> DialogMenu { unsafe { DialogMenu { this: tsDialogMenu_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> DialogMenu { unsafe { DialogMenu { this: ptr, owner: tsDialogMenu_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DialogMenu { unsafe { DialogMenu { this: tsDialogMenu_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DialogMenu) -> bool { unsafe { tsDialogMenu_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DialogMenu { unsafe { DialogMenu { this: tsDialogMenu_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDialogMenu_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDialogMenu_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDialogMenu_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDialogMenu_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDialogMenu_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDialogMenu_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDialogMenu_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDialogMenu_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDialogMenu_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn set_position(&mut self, x: i32, y: i32) { unsafe { tsDialogMenu_setPosition(self.this, x, y) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDialogMenu_getPositionX(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDialogMenu_getPositionY(self.this) } }
	pub fn num_items(&self) -> u32 { unsafe { tsDialogMenu_getNumItems(self.this) } }
	pub fn set_item_text(&mut self, index: u32, text: &str) {
		let text_ = CString::new(text).unwrap();
		unsafe { tsDialogMenu_setItemText_us(self.this, index, text_.as_ptr()) }
	}
	pub fn set_item_text_with_text(&mut self, index: u32, text: &String) { unsafe { tsDialogMenu_setItemText_ucS(self.this, index, text.this) } }
	pub fn item_text(&self, index: u32) -> string::String { unsafe { get_string(tsDialogMenu_getItemText(self.this, index)) } }
	pub fn set_item_key(&mut self, index: u32, key: &str) {
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_setItemKey(self.this, index, key_.as_ptr()) }
	}
	pub fn item_key(&self, index: u32) -> string::String { unsafe { get_string(tsDialogMenu_getItemKey(self.this, index)) } }
	pub fn set_item_image(&mut self, index: u32, image: &Image) { unsafe { tsDialogMenu_setItemImage(self.this, index, image.this) } }
	pub fn item_image(&self, index: u32) -> Image { unsafe { Image::new_ptr(tsDialogMenu_getItemImage(self.this, index)) } }
	pub fn set_item_checked(&mut self, index: u32, checked: bool) { unsafe { tsDialogMenu_setItemChecked(self.this, index, if checked {1} else {0}, 0) } }
	pub fn set_item_checked_with_callback(&mut self, index: u32, checked: bool, callback: bool) { unsafe { tsDialogMenu_setItemChecked(self.this, index, if checked {1} else {0}, if callback {1} else {0}) } }
	pub fn is_item_checked(&self, index: u32) -> bool { unsafe { tsDialogMenu_isItemChecked(self.this, index) != 0 } }
	pub fn set_item_enabled(&mut self, index: u32, enabled: bool) { unsafe { tsDialogMenu_setItemEnabled(self.this, index, if enabled {1} else {0}) } }
	pub fn is_item_enabled(&self, index: u32) -> bool { unsafe { tsDialogMenu_isItemEnabled(self.this, index) != 0 } }
	pub fn set_item_hidden(&mut self, index: u32, hidden: bool) { unsafe { tsDialogMenu_setItemHidden(self.this, index, if hidden {1} else {0}) } }
	pub fn is_item_hidden(&self, index: u32) -> bool { unsafe { tsDialogMenu_isItemHidden(self.this, index) != 0 } }
	pub fn set_items_group(&mut self, index: u32, size: u32) { unsafe { tsDialogMenu_setItemsGroup(self.this, index, size) } }
	pub fn item_group_index(&self, index: u32) -> u32 { unsafe { tsDialogMenu_getItemGroupIndex(self.this, index) } }
	pub fn item_group_size(&self, index: u32) -> u32 { unsafe { tsDialogMenu_getItemGroupSize(self.this, index) } }
	pub fn add_item_with_text_key(&mut self, text: &str, key: &str) -> u32 {
		let text_ = CString::new(text).unwrap();
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_ss(self.this, text_.as_ptr(), key_.as_ptr()) }
	}
	pub fn add_item_with_texts_key(&mut self, text: &String, key: &str) -> u32 {
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_cSs(self.this, text.this, key_.as_ptr()) }
	}
	pub fn add_item_with_text_image(&mut self, text: &str, image: &Image) -> u32 {
		let text_ = CString::new(text).unwrap();
		unsafe { tsDialogMenu_addItem_scIs(self.this, text_.as_ptr(), image.this, ptr::null_mut()) }
	}
	pub fn add_item_with_text_image_key(&mut self, text: &str, image: &Image, key: &str) -> u32 {
		let text_ = CString::new(text).unwrap();
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_scIs(self.this, text_.as_ptr(), image.this, key_.as_ptr()) }
	}
	pub fn add_item_with_texts_image(&mut self, text: &String, image: &Image) -> u32 { unsafe { tsDialogMenu_addItem_cScIs(self.this, text.this, image.this, ptr::null_mut()) } }
	pub fn add_item_with_texts_image_key(&mut self, text: &String, image: &Image, key: &str) -> u32 {
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_cScIs(self.this, text.this, image.this, key_.as_ptr()) }
	}
	pub fn add_item_with_text_func<Func>(&mut self, text: &str, func: Func) -> u32 where Func: FnMut() {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_scDMCCs(self.this, text_.as_ptr(), func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_func_key<Func>(&mut self, text: &str, func: Func, key: &str) -> u32 where Func: FnMut() {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_scDMCCs(self.this, text_.as_ptr(), func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_func<Func>(&mut self, text: &String, func: Func) -> u32 where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_cScDMCCs(self.this, text.this, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_func_key<Func>(&mut self, text: &String, func: Func, key: &str) -> u32 where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_cScDMCCs(self.this, text.this, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_image_func<Func>(&mut self, text: &str, image: &Image, func: Func) -> u32 where Func: FnMut() {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_scIcDMCCs(self.this, text_.as_ptr(), image.this, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_image_func_key<Func>(&mut self, text: &str, image: &Image, func: Func, key: &str) -> u32 where Func: FnMut() {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_scIcDMCCs(self.this, text_.as_ptr(), image.this, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_image_func<Func>(&mut self, text: &String, image: &Image, func: Func) -> u32 where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_cScIcDMCCs(self.this, text.this, image.this, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_image_func_key<Func>(&mut self, text: &String, image: &Image, func: Func, key: &str) -> u32 where Func: FnMut() {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_clicked_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_cScIcDMCCs(self.this, text.this, image.this, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_checked<Func>(&mut self, text: &str, checked: bool, func: Func) -> u32 where Func: FnMut(bool) {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_sbcDMCCs(self.this, text_.as_ptr(), if checked {1} else {0}, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_checked_key<Func>(&mut self, text: &str, checked: bool, func: Func, key: &str) -> u32 where Func: FnMut(bool) {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_sbcDMCCs(self.this, text_.as_ptr(), if checked {1} else {0}, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_checked<Func>(&mut self, text: &String, checked: bool, func: Func) -> u32 where Func: FnMut(bool) {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_cSbcDMCCs(self.this, text.this, if checked {1} else {0}, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_checked_key<Func>(&mut self, text: &String, checked: bool, func: Func, key: &str) -> u32 where Func: FnMut(bool) {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_cSbcDMCCs(self.this, text.this, if checked {1} else {0}, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_image_checked<Func>(&mut self, text: &str, image: &Image, checked: bool, func: Func) -> u32 where Func: FnMut(bool) {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_scIbcDMCCs(self.this, text_.as_ptr(), image.this, if checked {1} else {0}, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_text_image_checked_key<Func>(&mut self, text: &str, image: &Image, checked: bool, func: Func, key: &str) -> u32 where Func: FnMut(bool) {
		let text_ = CString::new(text).unwrap();
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_scIbcDMCCs(self.this, text_.as_ptr(), image.this, if checked {1} else {0}, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_image_checked<Func>(&mut self, text: &String, image: &Image, checked: bool, func: Func) -> u32 where Func: FnMut(bool) {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		unsafe { tsDialogMenu_addItem_cScIbcDMCCs(self.this, text.this, image.this, if checked {1} else {0}, func_, ptr::null_mut(), func as *mut _ as *mut c_void) }
	}
	pub fn add_item_with_texts_image_checked_key<Func>(&mut self, text: &String, image: &Image, checked: bool, func: Func, key: &str) -> u32 where Func: FnMut(bool) {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_changed_callback_func::<Func>;
		let key_ = CString::new(key).unwrap();
		unsafe { tsDialogMenu_addItem_cScIbcDMCCs(self.this, text.this, image.this, if checked {1} else {0}, func_, key_.as_ptr(), func as *mut _ as *mut c_void) }
	}
	pub fn set_update_callback<Func>(&mut self, func: Func) where Func: FnMut() -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = dialog_menu_update_callback_func::<Func>;
		unsafe { tsDialogMenu_setUpdateCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn run(&mut self) -> DialogMenuResult { unsafe { tsDialogMenu_run(self.this, DialogMenuFlags::None) } }
	pub fn run_with_flags(&mut self, flags: DialogMenuFlags) -> DialogMenuResult { unsafe { tsDialogMenu_run(self.this, flags) } }
}
impl Drop for DialogMenu {
	fn drop(&mut self) { if self.owner { unsafe { tsDialogMenu_delete(self.this) } } }
}
impl Clone for DialogMenu {
	fn clone(&self) -> DialogMenu { unsafe { DialogMenu { this: tsDialogMenu_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DialogMenu { }
impl fmt::Display for DialogMenu {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DialogMenu ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDialogMenu_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDialogMenu_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDialogMenu_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDialogMenu_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDialogMenu_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDialogMenu_new() -> *mut c_void;
	fn tsDialogMenu_delete(this: *mut c_void);
	fn tsDialogMenu_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDialogMenu_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogMenu_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDialogMenu_clearPtr(this: *const c_void);
	fn tsDialogMenu_destroyPtr(this: *const c_void);
	fn tsDialogMenu_acquirePtr(this: *const c_void);
	fn tsDialogMenu_unacquirePtr(this: *const c_void);
	fn tsDialogMenu_isValidPtr(this: *const c_void) -> i32;
	fn tsDialogMenu_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDialogMenu_isConstPtr(this: *const c_void) -> i32;
	fn tsDialogMenu_getCountPtr(this: *const c_void) -> u32;
	fn tsDialogMenu_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDialogMenu_setPosition(this: *mut c_void, x: i32, y: i32);
	fn tsDialogMenu_getPositionX(this: *const c_void) -> i32;
	fn tsDialogMenu_getPositionY(this: *const c_void) -> i32;
	fn tsDialogMenu_getNumItems(this: *const c_void) -> u32;
	fn tsDialogMenu_setItemText_us(this: *mut c_void, index: u32, text: *const c_char);
	fn tsDialogMenu_setItemText_ucS(this: *mut c_void, index: u32, text: *mut c_void);
	fn tsDialogMenu_getItemText(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDialogMenu_setItemKey(this: *mut c_void, index: u32, key: *const c_char);
	fn tsDialogMenu_getItemKey(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDialogMenu_setItemImage(this: *mut c_void, index: u32, image: *mut c_void);
	fn tsDialogMenu_getItemImage(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDialogMenu_setItemChecked(this: *mut c_void, index: u32, checked: i32, callback: i32);
	fn tsDialogMenu_isItemChecked(this: *const c_void, index: u32) -> i32;
	fn tsDialogMenu_setItemEnabled(this: *mut c_void, index: u32, enabled: i32);
	fn tsDialogMenu_isItemEnabled(this: *const c_void, index: u32) -> i32;
	fn tsDialogMenu_setItemHidden(this: *mut c_void, index: u32, hidden: i32);
	fn tsDialogMenu_isItemHidden(this: *const c_void, index: u32) -> i32;
	fn tsDialogMenu_setItemsGroup(this: *mut c_void, index: u32, size: u32);
	fn tsDialogMenu_getItemGroupIndex(this: *const c_void, index: u32) -> u32;
	fn tsDialogMenu_getItemGroupSize(this: *const c_void, index: u32) -> u32;
	fn tsDialogMenu_addItem_ss(this: *mut c_void, text: *const c_char, key: *const c_char) -> u32;
	fn tsDialogMenu_addItem_cSs(this: *mut c_void, text: *mut c_void, key: *const c_char) -> u32;
	fn tsDialogMenu_addItem_scIs(this: *mut c_void, text: *const c_char, image: *mut c_void, key: *const c_char) -> u32;
	fn tsDialogMenu_addItem_cScIs(this: *mut c_void, text: *mut c_void, image: *mut c_void, key: *const c_char) -> u32;
	fn tsDialogMenu_addItem_scDMCCs(this: *mut c_void, text: *const c_char, func: DialogMenuClickedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_cScDMCCs(this: *mut c_void, text: *mut c_void, func: DialogMenuClickedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_scIcDMCCs(this: *mut c_void, text: *const c_char, image: *mut c_void, func: DialogMenuClickedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_cScIcDMCCs(this: *mut c_void, text: *mut c_void, image: *mut c_void, func: DialogMenuClickedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_sbcDMCCs(this: *mut c_void, text: *const c_char, checked: i32, func: DialogMenuChangedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_cSbcDMCCs(this: *mut c_void, text: *mut c_void, checked: i32, func: DialogMenuChangedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_scIbcDMCCs(this: *mut c_void, text: *const c_char, image: *mut c_void, checked: i32, func: DialogMenuChangedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_addItem_cScIbcDMCCs(this: *mut c_void, text: *mut c_void, image: *mut c_void, checked: i32, func: DialogMenuChangedCallback, key: *const c_char, data_: *mut c_void) -> u32;
	fn tsDialogMenu_setUpdateCallback(this: *mut c_void, func: DialogMenuUpdateCallback, data_: *mut c_void);
	fn tsDialogMenu_run(this: *mut c_void, flags: DialogMenuFlags) -> DialogMenuResult;
}

// Tellusim::CubeFilter
pub struct CubeFilter {
	this: *mut c_void,
	owner: bool,
}
impl CubeFilter {
	pub fn null() -> CubeFilter { CubeFilter { this: ptr::null_mut(), owner: false } }
	pub fn new() -> CubeFilter { unsafe { CubeFilter { this: tsCubeFilter_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> CubeFilter { unsafe { CubeFilter { this: ptr, owner: tsCubeFilter_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> CubeFilter { unsafe { CubeFilter { this: tsCubeFilter_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: CubeFilter) -> bool { unsafe { tsCubeFilter_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> CubeFilter { unsafe { CubeFilter { this: tsCubeFilter_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsCubeFilter_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsCubeFilter_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsCubeFilter_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsCubeFilter_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsCubeFilter_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsCubeFilter_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsCubeFilter_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsCubeFilter_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsCubeFilter_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsCubeFilter_clear(self.this) } }
	pub fn is_created(&self, mode: CubeFilterMode) -> bool { unsafe { tsCubeFilter_isCreated(self.this, mode) != 0 } }
	pub fn group_size(&self) -> u32 { unsafe { tsCubeFilter_getGroupSize(self.this) } }
	pub fn max_order(&self) -> u32 { unsafe { tsCubeFilter_getMaxOrder(self.this) } }
	pub fn max_size(&self) -> u32 { unsafe { tsCubeFilter_getMaxSize(self.this) } }
	pub fn harmonics(&self) -> u32 { unsafe { tsCubeFilter_getHarmonics(self.this) } }
	pub fn create(&mut self, device: &Device, mode: CubeFilterMode) -> bool { unsafe { tsCubeFilter_create_cDCFMuuu(self.this, device.this, mode, 3, 1024, 256) != 0 } }
	pub fn create_with_order(&mut self, device: &Device, mode: CubeFilterMode, order: u32) -> bool { unsafe { tsCubeFilter_create_cDCFMuuu(self.this, device.this, mode, order, 1024, 256) != 0 } }
	pub fn create_with_order_size(&mut self, device: &Device, mode: CubeFilterMode, order: u32, size: u32) -> bool { unsafe { tsCubeFilter_create_cDCFMuuu(self.this, device.this, mode, order, size, 256) != 0 } }
	pub fn create_with_order_size_groups(&mut self, device: &Device, mode: CubeFilterMode, order: u32, size: u32, groups: u32) -> bool { unsafe { tsCubeFilter_create_cDCFMuuu(self.this, device.this, mode, order, size, groups) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: CubeFilterFlags) -> bool { unsafe { tsCubeFilter_create_cDCFFuuu(self.this, device.this, flags, 3, 1024, 256) != 0 } }
	pub fn create_with_flags_order(&mut self, device: &Device, flags: CubeFilterFlags, order: u32) -> bool { unsafe { tsCubeFilter_create_cDCFFuuu(self.this, device.this, flags, order, 1024, 256) != 0 } }
	pub fn create_with_flags_order_size(&mut self, device: &Device, flags: CubeFilterFlags, order: u32, size: u32) -> bool { unsafe { tsCubeFilter_create_cDCFFuuu(self.this, device.this, flags, order, size, 256) != 0 } }
	pub fn create_with_flags_order_size_groups(&mut self, device: &Device, flags: CubeFilterFlags, order: u32, size: u32, groups: u32) -> bool { unsafe { tsCubeFilter_create_cDCFFuuu(self.this, device.this, flags, order, size, groups) != 0 } }
	pub fn dispatch_with_buffer_slice(&self, compute: &mut Compute, buffer: &mut Buffer, offset: u32, texture: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCubeFilter_dispatch_cCBuTcS(self.this, compute.this, buffer.this, offset, texture.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn dispatch_with_buffer(&self, compute: &mut Compute, buffer: &mut Buffer, offset: u32, texture: &mut Texture) -> bool { unsafe { tsCubeFilter_dispatch_cCBuT(self.this, compute.this, buffer.this, offset, texture.this) != 0 } }
	pub fn dispatch_with_texture_slice(&self, compute: &mut Compute, texture: &mut Texture, slice: Option<&Slice>, buffer: &mut Buffer, offset: u32) -> bool {
		let slice_ = Slice::default();
		unsafe { tsCubeFilter_dispatch_cCTcSBu(self.this, compute.this, texture.this, match slice { Some(slice) => slice, None => &slice_ }, buffer.this, offset) != 0 }
	}
	pub fn dispatch_with_texture(&self, compute: &mut Compute, texture: &mut Texture, buffer: &mut Buffer, offset: u32) -> bool { unsafe { tsCubeFilter_dispatch_cCTBu(self.this, compute.this, texture.this, buffer.this, offset) != 0 } }
}
impl Drop for CubeFilter {
	fn drop(&mut self) { if self.owner { unsafe { tsCubeFilter_delete(self.this) } } }
}
impl Clone for CubeFilter {
	fn clone(&self) -> CubeFilter { unsafe { CubeFilter { this: tsCubeFilter_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for CubeFilter { }
impl fmt::Display for CubeFilter {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::CubeFilter ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsCubeFilter_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsCubeFilter_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsCubeFilter_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsCubeFilter_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsCubeFilter_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsCubeFilter_new() -> *mut c_void;
	fn tsCubeFilter_delete(this: *mut c_void);
	fn tsCubeFilter_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsCubeFilter_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsCubeFilter_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsCubeFilter_clearPtr(this: *const c_void);
	fn tsCubeFilter_destroyPtr(this: *const c_void);
	fn tsCubeFilter_acquirePtr(this: *const c_void);
	fn tsCubeFilter_unacquirePtr(this: *const c_void);
	fn tsCubeFilter_isValidPtr(this: *const c_void) -> i32;
	fn tsCubeFilter_isOwnerPtr(this: *const c_void) -> i32;
	fn tsCubeFilter_isConstPtr(this: *const c_void) -> i32;
	fn tsCubeFilter_getCountPtr(this: *const c_void) -> u32;
	fn tsCubeFilter_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsCubeFilter_clear(this: *mut c_void);
	fn tsCubeFilter_isCreated(this: *const c_void, mode: CubeFilterMode) -> i32;
	fn tsCubeFilter_getGroupSize(this: *const c_void) -> u32;
	fn tsCubeFilter_getMaxOrder(this: *const c_void) -> u32;
	fn tsCubeFilter_getMaxSize(this: *const c_void) -> u32;
	fn tsCubeFilter_getHarmonics(this: *const c_void) -> u32;
	fn tsCubeFilter_create_cDCFMuuu(this: *mut c_void, device: *mut c_void, mode: CubeFilterMode, order: u32, size: u32, groups: u32) -> i32;
	fn tsCubeFilter_create_cDCFFuuu(this: *mut c_void, device: *mut c_void, flags: CubeFilterFlags, order: u32, size: u32, groups: u32) -> i32;
	fn tsCubeFilter_dispatch_cCBuTcS(this: *const c_void, compute: *mut c_void, buffer: *mut c_void, offset: u32, texture: *mut c_void, slice: *const Slice) -> i32;
	fn tsCubeFilter_dispatch_cCBuT(this: *const c_void, compute: *mut c_void, buffer: *mut c_void, offset: u32, texture: *mut c_void) -> i32;
	fn tsCubeFilter_dispatch_cCTcSBu(this: *const c_void, compute: *mut c_void, texture: *mut c_void, slice: *const Slice, buffer: *mut c_void, offset: u32) -> i32;
	fn tsCubeFilter_dispatch_cCTBu(this: *const c_void, compute: *mut c_void, texture: *mut c_void, buffer: *mut c_void, offset: u32) -> i32;
}

// Tellusim::DecoderJPEG
pub struct DecoderJPEG {
	this: *mut c_void,
	owner: bool,
}
impl DecoderJPEG {
	pub fn null() -> DecoderJPEG { DecoderJPEG { this: ptr::null_mut(), owner: false } }
	pub fn new() -> DecoderJPEG { unsafe { DecoderJPEG { this: tsDecoderJPEG_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> DecoderJPEG { unsafe { DecoderJPEG { this: ptr, owner: tsDecoderJPEG_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> DecoderJPEG { unsafe { DecoderJPEG { this: tsDecoderJPEG_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: DecoderJPEG) -> bool { unsafe { tsDecoderJPEG_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> DecoderJPEG { unsafe { DecoderJPEG { this: tsDecoderJPEG_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDecoderJPEG_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDecoderJPEG_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDecoderJPEG_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDecoderJPEG_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDecoderJPEG_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDecoderJPEG_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDecoderJPEG_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDecoderJPEG_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDecoderJPEG_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsDecoderJPEG_clear(self.this) } }
	pub fn is_created(&self, mode: DecoderJPEGMode) -> bool { unsafe { tsDecoderJPEG_isCreated(self.this, mode) != 0 } }
	pub fn is_yuv(mode: DecoderJPEGMode) -> bool { unsafe { tsDecoderJPEG_isYUV(mode) != 0 } }
	pub fn create(&mut self, device: &Device, mode: DecoderJPEGMode) -> bool { unsafe { tsDecoderJPEG_create_cDDJM(self.this, device.this, mode) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: DecoderJPEGFlags) -> bool { unsafe { tsDecoderJPEG_create_cDDJF(self.this, device.this, flags) != 0 } }
	pub fn load(name: &str, image: &mut Image, mode: &mut DecoderJPEGMode, size: &mut Size) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsDecoderJPEG_load_sIDJMS(name_.as_ptr(), image.this, mode, size) != 0 }
	}
	pub fn load_with_stream(stream: &mut Stream, image: &mut Image, mode: &mut DecoderJPEGMode, size: &mut Size) -> bool { unsafe { tsDecoderJPEG_load_StIDJMS(stream.this, image.this, mode, size) != 0 } }
	pub fn load_texture(&self, device: &Device, name: &str) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDecoderJPEG_loadTexture_ccDsTF(self.this, device.this, name_.as_ptr(), TextureFlags::None)) }
	}
	pub fn load_texture_with_flags(&self, device: &Device, name: &str, flags: TextureFlags) -> Texture {
		let name_ = CString::new(name).unwrap();
		unsafe { Texture::new_ptr(tsDecoderJPEG_loadTexture_ccDsTF(self.this, device.this, name_.as_ptr(), flags)) }
	}
	pub fn load_texture_with_stream(&self, device: &Device, stream: &mut Stream) -> Texture { unsafe { Texture::new_ptr(tsDecoderJPEG_loadTexture_ccDStTF(self.this, device.this, stream.this, TextureFlags::None)) } }
	pub fn load_texture_with_stream_flags(&self, device: &Device, stream: &mut Stream, flags: TextureFlags) -> Texture { unsafe { Texture::new_ptr(tsDecoderJPEG_loadTexture_ccDStTF(self.this, device.this, stream.this, flags)) } }
	pub fn dispatch_with_destslice(&self, compute: &mut Compute, mode: DecoderJPEGMode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDecoderJPEG_dispatch_cCDJMTTcScS(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch_with_srcslice(&self, compute: &mut Compute, mode: DecoderJPEGMode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsDecoderJPEG_dispatch_cCDJMTTcS(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch(&self, compute: &mut Compute, mode: DecoderJPEGMode, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDecoderJPEG_dispatch_cCDJMTT(self.this, compute.this, mode, dest.this, src.this) != 0 } }
	pub fn dispatch_yuv_with_destslice(&self, compute: &mut Compute, mode: DecoderJPEGMode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsDecoderJPEG_dispatchYUV_cCDJMTTcScS(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch_yuv_with_srcslice(&self, compute: &mut Compute, mode: DecoderJPEGMode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsDecoderJPEG_dispatchYUV_cCDJMTTcS(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch_yuv(&self, compute: &mut Compute, mode: DecoderJPEGMode, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsDecoderJPEG_dispatchYUV_cCDJMTT(self.this, compute.this, mode, dest.this, src.this) != 0 } }
}
impl Drop for DecoderJPEG {
	fn drop(&mut self) { if self.owner { unsafe { tsDecoderJPEG_delete(self.this) } } }
}
impl Clone for DecoderJPEG {
	fn clone(&self) -> DecoderJPEG { unsafe { DecoderJPEG { this: tsDecoderJPEG_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for DecoderJPEG { }
impl fmt::Display for DecoderJPEG {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::DecoderJPEG ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDecoderJPEG_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDecoderJPEG_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDecoderJPEG_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDecoderJPEG_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDecoderJPEG_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDecoderJPEG_new() -> *mut c_void;
	fn tsDecoderJPEG_delete(this: *mut c_void);
	fn tsDecoderJPEG_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDecoderJPEG_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDecoderJPEG_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDecoderJPEG_clearPtr(this: *const c_void);
	fn tsDecoderJPEG_destroyPtr(this: *const c_void);
	fn tsDecoderJPEG_acquirePtr(this: *const c_void);
	fn tsDecoderJPEG_unacquirePtr(this: *const c_void);
	fn tsDecoderJPEG_isValidPtr(this: *const c_void) -> i32;
	fn tsDecoderJPEG_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDecoderJPEG_isConstPtr(this: *const c_void) -> i32;
	fn tsDecoderJPEG_getCountPtr(this: *const c_void) -> u32;
	fn tsDecoderJPEG_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDecoderJPEG_clear(this: *mut c_void);
	fn tsDecoderJPEG_isCreated(this: *const c_void, mode: DecoderJPEGMode) -> i32;
	fn tsDecoderJPEG_isYUV(mode: DecoderJPEGMode) -> i32;
	fn tsDecoderJPEG_create_cDDJM(this: *mut c_void, device: *mut c_void, mode: DecoderJPEGMode) -> i32;
	fn tsDecoderJPEG_create_cDDJF(this: *mut c_void, device: *mut c_void, flags: DecoderJPEGFlags) -> i32;
	fn tsDecoderJPEG_load_sIDJMS(name: *const c_char, image: *mut c_void, mode: &mut DecoderJPEGMode, size: *mut Size) -> i32;
	fn tsDecoderJPEG_load_StIDJMS(stream: *mut c_void, image: *mut c_void, mode: &mut DecoderJPEGMode, size: *mut Size) -> i32;
	fn tsDecoderJPEG_loadTexture_ccDsTF(this: *const c_void, device: *mut c_void, name: *const c_char, flags: TextureFlags) -> *mut c_void;
	fn tsDecoderJPEG_loadTexture_ccDStTF(this: *const c_void, device: *mut c_void, stream: *mut c_void, flags: TextureFlags) -> *mut c_void;
	fn tsDecoderJPEG_dispatch_cCDJMTTcScS(this: *const c_void, compute: *mut c_void, mode: DecoderJPEGMode, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice) -> i32;
	fn tsDecoderJPEG_dispatch_cCDJMTTcS(this: *const c_void, compute: *mut c_void, mode: DecoderJPEGMode, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsDecoderJPEG_dispatch_cCDJMTT(this: *const c_void, compute: *mut c_void, mode: DecoderJPEGMode, dest: *mut c_void, src: *mut c_void) -> i32;
	fn tsDecoderJPEG_dispatchYUV_cCDJMTTcScS(this: *const c_void, compute: *mut c_void, mode: DecoderJPEGMode, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice) -> i32;
	fn tsDecoderJPEG_dispatchYUV_cCDJMTTcS(this: *const c_void, compute: *mut c_void, mode: DecoderJPEGMode, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsDecoderJPEG_dispatchYUV_cCDJMTT(this: *const c_void, compute: *mut c_void, mode: DecoderJPEGMode, dest: *mut c_void, src: *mut c_void) -> i32;
}

// Tellusim::EncoderBC15
pub struct EncoderBC15 {
	this: *mut c_void,
	owner: bool,
}
impl EncoderBC15 {
	pub fn null() -> EncoderBC15 { EncoderBC15 { this: ptr::null_mut(), owner: false } }
	pub fn new() -> EncoderBC15 { unsafe { EncoderBC15 { this: tsEncoderBC15_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> EncoderBC15 { unsafe { EncoderBC15 { this: ptr, owner: tsEncoderBC15_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> EncoderBC15 { unsafe { EncoderBC15 { this: tsEncoderBC15_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: EncoderBC15) -> bool { unsafe { tsEncoderBC15_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> EncoderBC15 { unsafe { EncoderBC15 { this: tsEncoderBC15_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsEncoderBC15_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsEncoderBC15_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsEncoderBC15_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsEncoderBC15_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsEncoderBC15_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsEncoderBC15_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsEncoderBC15_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsEncoderBC15_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsEncoderBC15_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsEncoderBC15_clear(self.this) } }
	pub fn is_created(&self, mode: EncoderBC15Mode) -> bool { unsafe { tsEncoderBC15_isCreated(self.this, mode) != 0 } }
	pub fn create(&mut self, device: &Device, mode: EncoderBC15Mode) -> bool { unsafe { tsEncoderBC15_create_cDEB15M(self.this, device.this, mode) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: EncoderBC15Flags) -> bool { unsafe { tsEncoderBC15_create_cDEB15F(self.this, device.this, flags) != 0 } }
	pub fn dispatch_with_destslice(&self, compute: &mut Compute, mode: EncoderBC15Mode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsEncoderBC15_dispatch_cCEB15MTTcScS(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch_with_srcslice(&self, compute: &mut Compute, mode: EncoderBC15Mode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsEncoderBC15_dispatch_cCEB15MTTcS(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch(&self, compute: &mut Compute, mode: EncoderBC15Mode, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsEncoderBC15_dispatch_cCEB15MTT(self.this, compute.this, mode, dest.this, src.this) != 0 } }
}
impl Drop for EncoderBC15 {
	fn drop(&mut self) { if self.owner { unsafe { tsEncoderBC15_delete(self.this) } } }
}
impl Clone for EncoderBC15 {
	fn clone(&self) -> EncoderBC15 { unsafe { EncoderBC15 { this: tsEncoderBC15_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for EncoderBC15 { }
impl fmt::Display for EncoderBC15 {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::EncoderBC15 ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsEncoderBC15_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsEncoderBC15_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsEncoderBC15_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsEncoderBC15_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsEncoderBC15_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsEncoderBC15_new() -> *mut c_void;
	fn tsEncoderBC15_delete(this: *mut c_void);
	fn tsEncoderBC15_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsEncoderBC15_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderBC15_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderBC15_clearPtr(this: *const c_void);
	fn tsEncoderBC15_destroyPtr(this: *const c_void);
	fn tsEncoderBC15_acquirePtr(this: *const c_void);
	fn tsEncoderBC15_unacquirePtr(this: *const c_void);
	fn tsEncoderBC15_isValidPtr(this: *const c_void) -> i32;
	fn tsEncoderBC15_isOwnerPtr(this: *const c_void) -> i32;
	fn tsEncoderBC15_isConstPtr(this: *const c_void) -> i32;
	fn tsEncoderBC15_getCountPtr(this: *const c_void) -> u32;
	fn tsEncoderBC15_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderBC15_clear(this: *mut c_void);
	fn tsEncoderBC15_isCreated(this: *const c_void, mode: EncoderBC15Mode) -> i32;
	fn tsEncoderBC15_create_cDEB15M(this: *mut c_void, device: *mut c_void, mode: EncoderBC15Mode) -> i32;
	fn tsEncoderBC15_create_cDEB15F(this: *mut c_void, device: *mut c_void, flags: EncoderBC15Flags) -> i32;
	fn tsEncoderBC15_dispatch_cCEB15MTTcScS(this: *const c_void, compute: *mut c_void, mode: EncoderBC15Mode, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice) -> i32;
	fn tsEncoderBC15_dispatch_cCEB15MTTcS(this: *const c_void, compute: *mut c_void, mode: EncoderBC15Mode, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsEncoderBC15_dispatch_cCEB15MTT(this: *const c_void, compute: *mut c_void, mode: EncoderBC15Mode, dest: *mut c_void, src: *mut c_void) -> i32;
}

// Tellusim::EncoderBC67
pub struct EncoderBC67 {
	this: *mut c_void,
	owner: bool,
}
impl EncoderBC67 {
	pub fn null() -> EncoderBC67 { EncoderBC67 { this: ptr::null_mut(), owner: false } }
	pub fn new() -> EncoderBC67 { unsafe { EncoderBC67 { this: tsEncoderBC67_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> EncoderBC67 { unsafe { EncoderBC67 { this: ptr, owner: tsEncoderBC67_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> EncoderBC67 { unsafe { EncoderBC67 { this: tsEncoderBC67_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: EncoderBC67) -> bool { unsafe { tsEncoderBC67_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> EncoderBC67 { unsafe { EncoderBC67 { this: tsEncoderBC67_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsEncoderBC67_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsEncoderBC67_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsEncoderBC67_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsEncoderBC67_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsEncoderBC67_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsEncoderBC67_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsEncoderBC67_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsEncoderBC67_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsEncoderBC67_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsEncoderBC67_clear(self.this) } }
	pub fn is_created(&self, mode: EncoderBC67Mode) -> bool { unsafe { tsEncoderBC67_isCreated(self.this, mode) != 0 } }
	pub fn create(&mut self, device: &Device, mode: EncoderBC67Mode) -> bool { unsafe { tsEncoderBC67_create_cDEB67M(self.this, device.this, mode) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: EncoderBC67Flags) -> bool { unsafe { tsEncoderBC67_create_cDEB67F(self.this, device.this, flags) != 0 } }
	pub fn dispatch_with_destslice(&self, compute: &mut Compute, mode: EncoderBC67Mode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsEncoderBC67_dispatch_cCEB67MTTcScSu(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, 4) != 0 }
	}
	pub fn dispatch_with_destslice_components(&self, compute: &mut Compute, mode: EncoderBC67Mode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>, components: u32) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsEncoderBC67_dispatch_cCEB67MTTcScSu(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, components) != 0 }
	}
	pub fn dispatch_with_srcslice(&self, compute: &mut Compute, mode: EncoderBC67Mode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsEncoderBC67_dispatch_cCEB67MTTcSu(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, 4) != 0 }
	}
	pub fn dispatch_with_srcslice_components(&self, compute: &mut Compute, mode: EncoderBC67Mode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>, components: u32) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsEncoderBC67_dispatch_cCEB67MTTcSu(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, components) != 0 }
	}
	pub fn dispatch(&self, compute: &mut Compute, mode: EncoderBC67Mode, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsEncoderBC67_dispatch_cCEB67MTTu(self.this, compute.this, mode, dest.this, src.this, 4) != 0 } }
	pub fn dispatch_with_components(&self, compute: &mut Compute, mode: EncoderBC67Mode, dest: &mut Texture, src: &mut Texture, components: u32) -> bool { unsafe { tsEncoderBC67_dispatch_cCEB67MTTu(self.this, compute.this, mode, dest.this, src.this, components) != 0 } }
}
impl Drop for EncoderBC67 {
	fn drop(&mut self) { if self.owner { unsafe { tsEncoderBC67_delete(self.this) } } }
}
impl Clone for EncoderBC67 {
	fn clone(&self) -> EncoderBC67 { unsafe { EncoderBC67 { this: tsEncoderBC67_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for EncoderBC67 { }
impl fmt::Display for EncoderBC67 {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::EncoderBC67 ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsEncoderBC67_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsEncoderBC67_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsEncoderBC67_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsEncoderBC67_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsEncoderBC67_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsEncoderBC67_new() -> *mut c_void;
	fn tsEncoderBC67_delete(this: *mut c_void);
	fn tsEncoderBC67_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsEncoderBC67_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderBC67_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderBC67_clearPtr(this: *const c_void);
	fn tsEncoderBC67_destroyPtr(this: *const c_void);
	fn tsEncoderBC67_acquirePtr(this: *const c_void);
	fn tsEncoderBC67_unacquirePtr(this: *const c_void);
	fn tsEncoderBC67_isValidPtr(this: *const c_void) -> i32;
	fn tsEncoderBC67_isOwnerPtr(this: *const c_void) -> i32;
	fn tsEncoderBC67_isConstPtr(this: *const c_void) -> i32;
	fn tsEncoderBC67_getCountPtr(this: *const c_void) -> u32;
	fn tsEncoderBC67_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderBC67_clear(this: *mut c_void);
	fn tsEncoderBC67_isCreated(this: *const c_void, mode: EncoderBC67Mode) -> i32;
	fn tsEncoderBC67_create_cDEB67M(this: *mut c_void, device: *mut c_void, mode: EncoderBC67Mode) -> i32;
	fn tsEncoderBC67_create_cDEB67F(this: *mut c_void, device: *mut c_void, flags: EncoderBC67Flags) -> i32;
	fn tsEncoderBC67_dispatch_cCEB67MTTcScSu(this: *const c_void, compute: *mut c_void, mode: EncoderBC67Mode, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice, components: u32) -> i32;
	fn tsEncoderBC67_dispatch_cCEB67MTTcSu(this: *const c_void, compute: *mut c_void, mode: EncoderBC67Mode, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice, components: u32) -> i32;
	fn tsEncoderBC67_dispatch_cCEB67MTTu(this: *const c_void, compute: *mut c_void, mode: EncoderBC67Mode, dest: *mut c_void, src: *mut c_void, components: u32) -> i32;
}

// Tellusim::EncoderASTC
pub struct EncoderASTC {
	this: *mut c_void,
	owner: bool,
}
impl EncoderASTC {
	pub fn null() -> EncoderASTC { EncoderASTC { this: ptr::null_mut(), owner: false } }
	pub fn new() -> EncoderASTC { unsafe { EncoderASTC { this: tsEncoderASTC_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> EncoderASTC { unsafe { EncoderASTC { this: ptr, owner: tsEncoderASTC_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> EncoderASTC { unsafe { EncoderASTC { this: tsEncoderASTC_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: EncoderASTC) -> bool { unsafe { tsEncoderASTC_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> EncoderASTC { unsafe { EncoderASTC { this: tsEncoderASTC_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsEncoderASTC_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsEncoderASTC_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsEncoderASTC_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsEncoderASTC_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsEncoderASTC_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsEncoderASTC_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsEncoderASTC_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsEncoderASTC_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsEncoderASTC_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsEncoderASTC_clear(self.this) } }
	pub fn is_created(&self, mode: EncoderASTCMode) -> bool { unsafe { tsEncoderASTC_isCreated(self.this, mode) != 0 } }
	pub fn create(&mut self, device: &Device, mode: EncoderASTCMode) -> bool { unsafe { tsEncoderASTC_create_cDEAM(self.this, device.this, mode) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: EncoderASTCFlags) -> bool { unsafe { tsEncoderASTC_create_cDEAF(self.this, device.this, flags) != 0 } }
	pub fn dispatch_with_destslice(&self, compute: &mut Compute, mode: EncoderASTCMode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsEncoderASTC_dispatch_cCEAMTTcScSu(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, 4) != 0 }
	}
	pub fn dispatch_with_destslice_components(&self, compute: &mut Compute, mode: EncoderASTCMode, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>, components: u32) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsEncoderASTC_dispatch_cCEAMTTcScSu(self.this, compute.this, mode, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, components) != 0 }
	}
	pub fn dispatch_with_srcslice(&self, compute: &mut Compute, mode: EncoderASTCMode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsEncoderASTC_dispatch_cCEAMTTcSu(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, 4) != 0 }
	}
	pub fn dispatch_with_srcslice_components(&self, compute: &mut Compute, mode: EncoderASTCMode, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>, components: u32) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsEncoderASTC_dispatch_cCEAMTTcSu(self.this, compute.this, mode, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, components) != 0 }
	}
	pub fn dispatch(&self, compute: &mut Compute, mode: EncoderASTCMode, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsEncoderASTC_dispatch_cCEAMTTu(self.this, compute.this, mode, dest.this, src.this, 4) != 0 } }
	pub fn dispatch_with_components(&self, compute: &mut Compute, mode: EncoderASTCMode, dest: &mut Texture, src: &mut Texture, components: u32) -> bool { unsafe { tsEncoderASTC_dispatch_cCEAMTTu(self.this, compute.this, mode, dest.this, src.this, components) != 0 } }
}
impl Drop for EncoderASTC {
	fn drop(&mut self) { if self.owner { unsafe { tsEncoderASTC_delete(self.this) } } }
}
impl Clone for EncoderASTC {
	fn clone(&self) -> EncoderASTC { unsafe { EncoderASTC { this: tsEncoderASTC_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for EncoderASTC { }
impl fmt::Display for EncoderASTC {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::EncoderASTC ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsEncoderASTC_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsEncoderASTC_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsEncoderASTC_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsEncoderASTC_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsEncoderASTC_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsEncoderASTC_new() -> *mut c_void;
	fn tsEncoderASTC_delete(this: *mut c_void);
	fn tsEncoderASTC_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsEncoderASTC_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderASTC_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderASTC_clearPtr(this: *const c_void);
	fn tsEncoderASTC_destroyPtr(this: *const c_void);
	fn tsEncoderASTC_acquirePtr(this: *const c_void);
	fn tsEncoderASTC_unacquirePtr(this: *const c_void);
	fn tsEncoderASTC_isValidPtr(this: *const c_void) -> i32;
	fn tsEncoderASTC_isOwnerPtr(this: *const c_void) -> i32;
	fn tsEncoderASTC_isConstPtr(this: *const c_void) -> i32;
	fn tsEncoderASTC_getCountPtr(this: *const c_void) -> u32;
	fn tsEncoderASTC_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsEncoderASTC_clear(this: *mut c_void);
	fn tsEncoderASTC_isCreated(this: *const c_void, mode: EncoderASTCMode) -> i32;
	fn tsEncoderASTC_create_cDEAM(this: *mut c_void, device: *mut c_void, mode: EncoderASTCMode) -> i32;
	fn tsEncoderASTC_create_cDEAF(this: *mut c_void, device: *mut c_void, flags: EncoderASTCFlags) -> i32;
	fn tsEncoderASTC_dispatch_cCEAMTTcScSu(this: *const c_void, compute: *mut c_void, mode: EncoderASTCMode, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice, components: u32) -> i32;
	fn tsEncoderASTC_dispatch_cCEAMTTcSu(this: *const c_void, compute: *mut c_void, mode: EncoderASTCMode, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice, components: u32) -> i32;
	fn tsEncoderASTC_dispatch_cCEAMTTu(this: *const c_void, compute: *mut c_void, mode: EncoderASTCMode, dest: *mut c_void, src: *mut c_void, components: u32) -> i32;
}

// Tellusim::MeshModel
pub struct MeshModel {
	this: *mut c_void,
	owner: bool,
}
type MeshModelCreateCallback = unsafe extern "C" fn(src: *const c_void, size: usize, owner: i32, data_: *mut c_void) -> i32;
unsafe extern "C" fn mesh_model_create_callback_func<Func>(src: *const c_void, size: usize, owner: i32, data_: *mut c_void) -> i32 where Func: FnMut(*const c_void, usize, bool) -> bool {
	let func = &mut *(data_ as *mut Func);
	if func(src, size, owner != 0) {1} else {0}
}
impl MeshModel {
	pub fn null() -> MeshModel { MeshModel { this: ptr::null_mut(), owner: false } }
	pub fn new() -> MeshModel { unsafe { MeshModel { this: tsMeshModel_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> MeshModel { MeshModel { this: ptr, owner: true } }
	pub fn copy_ptr(&self) -> MeshModel { MeshModel { this: self.this, owner: false } }
	pub fn clear(&mut self) { unsafe { tsMeshModel_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsMeshModel_isCreated(self.this) != 0 } }
	pub fn flags(&self) -> MeshModelFlags { unsafe { tsMeshModel_getFlags(self.this) } }
	pub fn has_flag(&self, flags: MeshModelFlags) -> bool { unsafe { tsMeshModel_hasFlag(self.this, flags) != 0 } }
	pub fn has_flags(&self, flags: MeshModelFlags) -> bool { unsafe { tsMeshModel_hasFlags(self.this, flags) != 0 } }
	pub fn load(&mut self, device: &Device, pipeline: &Pipeline, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshModel_load_cDcPsMMFA(self.this, device.this, pipeline.this, name_.as_ptr(), MeshModelFlags::Default, ptr::null_mut()) != 0 }
	}
	pub fn load_with_flags(&mut self, device: &Device, pipeline: &Pipeline, name: &str, flags: MeshModelFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshModel_load_cDcPsMMFA(self.this, device.this, pipeline.this, name_.as_ptr(), flags, ptr::null_mut()) != 0 }
	}
	pub fn load_with_flags_async(&mut self, device: &Device, pipeline: &Pipeline, name: &str, flags: MeshModelFlags, async_: Option<&Async>) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshModel_load_cDcPsMMFA(self.this, device.this, pipeline.this, name_.as_ptr(), flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 }
	}
	pub fn load_with_stream(&mut self, device: &Device, pipeline: &Pipeline, stream: &mut Stream) -> bool { unsafe { tsMeshModel_load_cDcPStMMFA(self.this, device.this, pipeline.this, stream.this, MeshModelFlags::Default, ptr::null_mut()) != 0 } }
	pub fn load_with_stream_flags(&mut self, device: &Device, pipeline: &Pipeline, stream: &mut Stream, flags: MeshModelFlags) -> bool { unsafe { tsMeshModel_load_cDcPStMMFA(self.this, device.this, pipeline.this, stream.this, flags, ptr::null_mut()) != 0 } }
	pub fn load_with_stream_flags_async(&mut self, device: &Device, pipeline: &Pipeline, stream: &mut Stream, flags: MeshModelFlags, async_: Option<&Async>) -> bool { unsafe { tsMeshModel_load_cDcPStMMFA(self.this, device.this, pipeline.this, stream.this, flags, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create(&mut self, device: &Device, pipeline: &Pipeline, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshModel_create_cDcPsMMF(self.this, device.this, pipeline.this, name_.as_ptr(), MeshModelFlags::Default) != 0 }
	}
	pub fn create_with_flags(&mut self, device: &Device, pipeline: &Pipeline, name: &str, flags: MeshModelFlags) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsMeshModel_create_cDcPsMMF(self.this, device.this, pipeline.this, name_.as_ptr(), flags) != 0 }
	}
	pub fn create_with_mesh(&mut self, device: &Device, pipeline: &Pipeline, mesh: &Mesh) -> bool { unsafe { tsMeshModel_create_cDcPcMMMF(self.this, device.this, pipeline.this, mesh.this, MeshModelFlags::Default) != 0 } }
	pub fn create_with_mesh_flags(&mut self, device: &Device, pipeline: &Pipeline, mesh: &Mesh, flags: MeshModelFlags) -> bool { unsafe { tsMeshModel_create_cDcPcMMMF(self.this, device.this, pipeline.this, mesh.this, flags) != 0 } }
	pub fn create_with_geometry(&mut self, device: &Device, pipeline: &Pipeline, geometry: &MeshGeometry) -> bool { unsafe { tsMeshModel_create_cDcPcMGMMF(self.this, device.this, pipeline.this, geometry.this, MeshModelFlags::Default) != 0 } }
	pub fn create_with_geometry_flags(&mut self, device: &Device, pipeline: &Pipeline, geometry: &MeshGeometry, flags: MeshModelFlags) -> bool { unsafe { tsMeshModel_create_cDcPcMGMMF(self.this, device.this, pipeline.this, geometry.this, flags) != 0 } }
	pub fn create_with_geometries(&mut self, device: &Device, pipeline: &Pipeline, geometries: &[&mut MeshGeometry]) -> bool {
		let mut geometries_ = Vec::new();
		for ptr in geometries { geometries_.push(ptr.this); }
		unsafe { tsMeshModel_create_cDcPcAMGMMF(self.this, device.this, pipeline.this, geometries_.as_ptr(), geometries.len() as u32, MeshModelFlags::Default) != 0 }
	}
	pub fn create_with_geometries_flags(&mut self, device: &Device, pipeline: &Pipeline, geometries: &[&mut MeshGeometry], flags: MeshModelFlags) -> bool {
		let mut geometries_ = Vec::new();
		for ptr in geometries { geometries_.push(ptr.this); }
		unsafe { tsMeshModel_create_cDcPcAMGMMF(self.this, device.this, pipeline.this, geometries_.as_ptr(), geometries.len() as u32, flags) != 0 }
	}
	pub fn set_vertex_buffer_callback<Func>(&mut self, func: Func) where Func: FnMut(*const c_void, usize, bool) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = mesh_model_create_callback_func::<Func>;
		unsafe { tsMeshModel_setVertexBufferCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_index_buffer_callback<Func>(&mut self, func: Func) where Func: FnMut(*const c_void, usize, bool) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = mesh_model_create_callback_func::<Func>;
		unsafe { tsMeshModel_setIndexBufferCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_mesh_buffer_callback<Func>(&mut self, func: Func) where Func: FnMut(*const c_void, usize, bool) -> bool {
		let func = Box::leak(Box::new(func));
		let func_ = mesh_model_create_callback_func::<Func>;
		unsafe { tsMeshModel_setMeshBufferCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_buffers(&self, command: &mut Command) { unsafe { tsMeshModel_setBuffers(self.this, command.this, 0, ptr::null_mut()) } }
	pub fn set_buffers_with_index(&self, command: &mut Command, index: u32) { unsafe { tsMeshModel_setBuffers(self.this, command.this, index, ptr::null_mut()) } }
	pub fn set_buffers_with_index_pipeline(&self, command: &mut Command, index: u32, pipeline: Option<&Pipeline>) { unsafe { tsMeshModel_setBuffers(self.this, command.this, index, match pipeline { Some(pipeline) => &pipeline.this, None => ptr::null() }) } }
	pub fn draw(&self, command: &mut Command) { unsafe { tsMeshModel_draw_cC(self.this, command.this) } }
	pub fn draw_with_geometry(&self, command: &mut Command, geometry: u32) { unsafe { tsMeshModel_draw_cCu(self.this, command.this, geometry) } }
	pub fn draw_with_geometry_material(&self, command: &mut Command, geometry: u32, material: u32) { unsafe { tsMeshModel_draw_cCuu(self.this, command.this, geometry, material) } }
	pub fn draw_instanced(&self, command: &mut Command, geometry: u32, num_instances: u32) { unsafe { tsMeshModel_drawInstanced_cCuuu(self.this, command.this, geometry, num_instances, 0) } }
	pub fn draw_instanced_with_baseinstance(&self, command: &mut Command, geometry: u32, num_instances: u32, base_instance: u32) { unsafe { tsMeshModel_drawInstanced_cCuuu(self.this, command.this, geometry, num_instances, base_instance) } }
	pub fn draw_instanced_with_material(&self, command: &mut Command, geometry: u32, material: u32, num_instances: u32, base_instance: u32) { unsafe { tsMeshModel_drawInstanced_cCuuuu(self.this, command.this, geometry, material, num_instances, base_instance) } }
	pub fn num_vertices(&self) -> u32 { unsafe { tsMeshModel_getNumVertices(self.this) } }
	pub fn num_vertex_buffers(&self) -> u32 { unsafe { tsMeshModel_getNumVertexBuffers(self.this) } }
	pub fn vertex_buffer_stride(&self, index: u32) -> u32 { unsafe { tsMeshModel_getVertexBufferStride(self.this, index) } }
	pub fn vertex_buffer_offset(&self, index: u32) -> usize { unsafe { tsMeshModel_getVertexBufferOffset(self.this, index) } }
	pub fn vertex_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsMeshModel_getVertexBuffer(self.this)) } }
	pub fn num_indices(&self) -> u32 { unsafe { tsMeshModel_getNumIndices(self.this) } }
	pub fn index_format(&self) -> Format { unsafe { tsMeshModel_getIndexFormat(self.this) } }
	pub fn index_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsMeshModel_getIndexBuffer(self.this)) } }
	pub fn num_meshlets(&self) -> u32 { unsafe { tsMeshModel_getNumMeshlets(self.this) } }
	pub fn meshlet_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsMeshModel_getMeshletBuffer(self.this)) } }
	pub fn num_geometries(&self) -> u32 { unsafe { tsMeshModel_getNumGeometries(self.this) } }
	pub fn num_geometry_indices(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getNumGeometryIndices(self.this, geometry) } }
	pub fn num_geometry_vertices(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getNumGeometryVertices(self.this, geometry) } }
	pub fn num_geometry_meshlets(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getNumGeometryMeshlets(self.this, geometry) } }
	pub fn geometry_base_index(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getGeometryBaseIndex(self.this, geometry) } }
	pub fn geometry_base_vertex(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getGeometryBaseVertex(self.this, geometry) } }
	pub fn geometry_base_meshlet(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getGeometryBaseMeshlet(self.this, geometry) } }
	pub fn num_materials(&self, geometry: u32) -> u32 { unsafe { tsMeshModel_getNumMaterials(self.this, geometry) } }
	pub fn num_material_indices(&self, geometry: u32, material: u32) -> u32 { unsafe { tsMeshModel_getNumMaterialIndices(self.this, geometry, material) } }
	pub fn num_material_vertices(&self, geometry: u32, material: u32) -> u32 { unsafe { tsMeshModel_getNumMaterialVertices(self.this, geometry, material) } }
	pub fn num_material_meshlets(&self, geometry: u32, material: u32) -> u32 { unsafe { tsMeshModel_getNumMaterialMeshlets(self.this, geometry, material) } }
	pub fn material_base_index(&self, geometry: u32, material: u32) -> u32 { unsafe { tsMeshModel_getMaterialBaseIndex(self.this, geometry, material) } }
	pub fn material_base_vertex(&self, geometry: u32, material: u32) -> u32 { unsafe { tsMeshModel_getMaterialBaseVertex(self.this, geometry, material) } }
	pub fn material_base_meshlet(&self, geometry: u32, material: u32) -> u32 { unsafe { tsMeshModel_getMaterialBaseMeshlet(self.this, geometry, material) } }
	pub fn memory(&self) -> usize { unsafe { tsMeshModel_getMemory(self.this) } }
}
impl Drop for MeshModel {
	fn drop(&mut self) { if self.owner { unsafe { tsMeshModel_delete(self.this) } } }
}
impl fmt::Display for MeshModel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::MeshModel ".to_string();
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsMeshModel_new() -> *mut c_void;
	fn tsMeshModel_delete(this: *mut c_void);
	fn tsMeshModel_clear(this: *mut c_void);
	fn tsMeshModel_isCreated(this: *const c_void) -> i32;
	fn tsMeshModel_getFlags(this: *const c_void) -> MeshModelFlags;
	fn tsMeshModel_hasFlag(this: *const c_void, flags: MeshModelFlags) -> i32;
	fn tsMeshModel_hasFlags(this: *const c_void, flags: MeshModelFlags) -> i32;
	fn tsMeshModel_load_cDcPsMMFA(this: *mut c_void, device: *mut c_void, pipeline: *mut c_void, name: *const c_char, flags: MeshModelFlags, async_: *const *mut c_void) -> i32;
	fn tsMeshModel_load_cDcPStMMFA(this: *mut c_void, device: *mut c_void, pipeline: *mut c_void, stream: *mut c_void, flags: MeshModelFlags, async_: *const *mut c_void) -> i32;
	fn tsMeshModel_create_cDcPsMMF(this: *mut c_void, device: *mut c_void, pipeline: *mut c_void, name: *const c_char, flags: MeshModelFlags) -> i32;
	fn tsMeshModel_create_cDcPcMMMF(this: *mut c_void, device: *mut c_void, pipeline: *mut c_void, mesh: *mut c_void, flags: MeshModelFlags) -> i32;
	fn tsMeshModel_create_cDcPcMGMMF(this: *mut c_void, device: *mut c_void, pipeline: *mut c_void, geometry: *mut c_void, flags: MeshModelFlags) -> i32;
	fn tsMeshModel_create_cDcPcAMGMMF(this: *mut c_void, device: *mut c_void, pipeline: *mut c_void, geometries: *const *mut c_void, geometries_size: u32, flags: MeshModelFlags) -> i32;
	fn tsMeshModel_setVertexBufferCallback(this: *mut c_void, func: MeshModelCreateCallback, data_: *mut c_void);
	fn tsMeshModel_setIndexBufferCallback(this: *mut c_void, func: MeshModelCreateCallback, data_: *mut c_void);
	fn tsMeshModel_setMeshBufferCallback(this: *mut c_void, func: MeshModelCreateCallback, data_: *mut c_void);
	fn tsMeshModel_setBuffers(this: *const c_void, command: *mut c_void, index: u32, pipeline: *const *mut c_void);
	fn tsMeshModel_draw_cC(this: *const c_void, command: *mut c_void);
	fn tsMeshModel_draw_cCu(this: *const c_void, command: *mut c_void, geometry: u32);
	fn tsMeshModel_draw_cCuu(this: *const c_void, command: *mut c_void, geometry: u32, material: u32);
	fn tsMeshModel_drawInstanced_cCuuu(this: *const c_void, command: *mut c_void, geometry: u32, num_instances: u32, base_instance: u32);
	fn tsMeshModel_drawInstanced_cCuuuu(this: *const c_void, command: *mut c_void, geometry: u32, material: u32, num_instances: u32, base_instance: u32);
	fn tsMeshModel_getNumVertices(this: *const c_void) -> u32;
	fn tsMeshModel_getNumVertexBuffers(this: *const c_void) -> u32;
	fn tsMeshModel_getVertexBufferStride(this: *const c_void, index: u32) -> u32;
	fn tsMeshModel_getVertexBufferOffset(this: *const c_void, index: u32) -> usize;
	fn tsMeshModel_getVertexBuffer(this: *const c_void) -> *mut c_void;
	fn tsMeshModel_getNumIndices(this: *const c_void) -> u32;
	fn tsMeshModel_getIndexFormat(this: *const c_void) -> Format;
	fn tsMeshModel_getIndexBuffer(this: *const c_void) -> *mut c_void;
	fn tsMeshModel_getNumMeshlets(this: *const c_void) -> u32;
	fn tsMeshModel_getMeshletBuffer(this: *const c_void) -> *mut c_void;
	fn tsMeshModel_getNumGeometries(this: *const c_void) -> u32;
	fn tsMeshModel_getNumGeometryIndices(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getNumGeometryVertices(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getNumGeometryMeshlets(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getGeometryBaseIndex(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getGeometryBaseVertex(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getGeometryBaseMeshlet(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getNumMaterials(this: *const c_void, geometry: u32) -> u32;
	fn tsMeshModel_getNumMaterialIndices(this: *const c_void, geometry: u32, material: u32) -> u32;
	fn tsMeshModel_getNumMaterialVertices(this: *const c_void, geometry: u32, material: u32) -> u32;
	fn tsMeshModel_getNumMaterialMeshlets(this: *const c_void, geometry: u32, material: u32) -> u32;
	fn tsMeshModel_getMaterialBaseIndex(this: *const c_void, geometry: u32, material: u32) -> u32;
	fn tsMeshModel_getMaterialBaseVertex(this: *const c_void, geometry: u32, material: u32) -> u32;
	fn tsMeshModel_getMaterialBaseMeshlet(this: *const c_void, geometry: u32, material: u32) -> u32;
	fn tsMeshModel_getMemory(this: *const c_void) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MeshModelMeshlet {
	pub num_primitives: u32,
	pub num_vertices: u32,
	pub base_index: u32,
	pub base_vertex: u32,
	pub bound_sphere: Vector4f,
	pub normal_angle: Vector4f,
}
impl fmt::Display for MeshModelMeshlet {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("num_primitives: {0}\n", self.num_primitives);
		ret += &format!("num_vertices: {0}\n", self.num_vertices);
		ret += &format!("base_index: {0}\n", self.base_index);
		ret += &format!("base_vertex: {0}\n", self.base_vertex);
		ret += &format!("bound_sphere: {0}\n", self.bound_sphere);
		ret += &format!("normal_angle: {0}", self.normal_angle);
		write!(f, "{0}", ret)
	}
}

// Tellusim::SeparableFilter
pub struct SeparableFilter {
	this: *mut c_void,
	owner: bool,
}
impl SeparableFilter {
	pub fn null() -> SeparableFilter { SeparableFilter { this: ptr::null_mut(), owner: false } }
	pub fn new() -> SeparableFilter { unsafe { SeparableFilter { this: tsSeparableFilter_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> SeparableFilter { unsafe { SeparableFilter { this: ptr, owner: tsSeparableFilter_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> SeparableFilter { unsafe { SeparableFilter { this: tsSeparableFilter_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: SeparableFilter) -> bool { unsafe { tsSeparableFilter_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> SeparableFilter { unsafe { SeparableFilter { this: tsSeparableFilter_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSeparableFilter_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSeparableFilter_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSeparableFilter_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSeparableFilter_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSeparableFilter_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSeparableFilter_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSeparableFilter_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSeparableFilter_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSeparableFilter_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsSeparableFilter_clear(self.this) } }
	pub fn is_created(&self, format: Format, size: u32) -> bool { unsafe { tsSeparableFilter_isCreated(self.this, format, size) != 0 } }
	pub fn set_input_source(&mut self, mode: SeparableFilterMode, src: &str) {
		let src_ = CString::new(src).unwrap();
		unsafe { tsSeparableFilter_setInputSource(self.this, mode, src_.as_ptr()) }
	}
	pub fn input_source(&self, mode: SeparableFilterMode) -> string::String { unsafe { get_string(tsSeparableFilter_getInputSource(self.this, mode)) } }
	pub fn set_output_source(&mut self, mode: SeparableFilterMode, src: &str) {
		let src_ = CString::new(src).unwrap();
		unsafe { tsSeparableFilter_setOutputSource(self.this, mode, src_.as_ptr()) }
	}
	pub fn output_source(&self, mode: SeparableFilterMode) -> string::String { unsafe { get_string(tsSeparableFilter_getOutputSource(self.this, mode)) } }
	pub fn create(&mut self, device: &Device, format: Format, size: u32) -> bool { unsafe { tsSeparableFilter_create(self.this, device.this, format, size, SeparableFilterFlags::None) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, format: Format, size: u32, flags: SeparableFilterFlags) -> bool { unsafe { tsSeparableFilter_create(self.this, device.this, format, size, flags) != 0 } }
	pub fn set_weights(&mut self, mode: SeparableFilterMode, weights: &[Vector4f]) { unsafe { tsSeparableFilter_setWeights_SFMcAV4b(self.this, mode, weights.as_ptr(), weights.len() as u32, 0) } }
	pub fn set_weights_with_normalize(&mut self, mode: SeparableFilterMode, weights: &[Vector4f], normalize: bool) { unsafe { tsSeparableFilter_setWeights_SFMcAV4b(self.this, mode, weights.as_ptr(), weights.len() as u32, if normalize {1} else {0}) } }
	pub fn set_weights_with_weights(&mut self, mode: SeparableFilterMode, weights: &[f32]) { unsafe { tsSeparableFilter_setWeights_SFMcA32b(self.this, mode, weights.as_ptr(), weights.len() as u32, 0) } }
	pub fn set_weights_with_weights_normalize(&mut self, mode: SeparableFilterMode, weights: &[f32], normalize: bool) { unsafe { tsSeparableFilter_setWeights_SFMcA32b(self.this, mode, weights.as_ptr(), weights.len() as u32, if normalize {1} else {0}) } }
	pub fn set_gaussian_weights(&mut self, size: u32, sigma: &Vector4f) { unsafe { tsSeparableFilter_setGaussianWeights_ucV4(self.this, size, sigma) } }
	pub fn set_gaussian_weights_with_sigma(&mut self, size: u32, sigma: f32) { unsafe { tsSeparableFilter_setGaussianWeights_uf(self.this, size, sigma) } }
	pub fn set_sobel_xweights(&mut self, size: u32) { unsafe { tsSeparableFilter_setSobelXWeights(self.this, size) } }
	pub fn set_sobel_yweights(&mut self, size: u32) { unsafe { tsSeparableFilter_setSobelYWeights(self.this, size) } }
	pub fn set_box_weights(&mut self, size: u32) { unsafe { tsSeparableFilter_setBoxWeights(self.this, size) } }
	pub fn dispatch_with_destslice(&self, compute: &mut Compute, mode: SeparableFilterMode, size: u32, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsSeparableFilter_dispatch_cCSFMuTTcScScV4(self.this, compute.this, mode, size, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, &Vector4f::zero()) != 0 }
	}
	pub fn dispatch_with_destslice_parameters(&self, compute: &mut Compute, mode: SeparableFilterMode, size: u32, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>, parameters: &Vector4f) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsSeparableFilter_dispatch_cCSFMuTTcScScV4(self.this, compute.this, mode, size, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, parameters) != 0 }
	}
	pub fn dispatch_with_srcslice(&self, compute: &mut Compute, mode: SeparableFilterMode, size: u32, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsSeparableFilter_dispatch_cCSFMuTTcScV4(self.this, compute.this, mode, size, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, &Vector4f::zero()) != 0 }
	}
	pub fn dispatch_with_srcslice_parameters(&self, compute: &mut Compute, mode: SeparableFilterMode, size: u32, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>, parameters: &Vector4f) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsSeparableFilter_dispatch_cCSFMuTTcScV4(self.this, compute.this, mode, size, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }, parameters) != 0 }
	}
	pub fn dispatch(&self, compute: &mut Compute, mode: SeparableFilterMode, size: u32, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsSeparableFilter_dispatch_cCSFMuTTcV4(self.this, compute.this, mode, size, dest.this, src.this, &Vector4f::zero()) != 0 } }
	pub fn dispatch_with_parameters(&self, compute: &mut Compute, mode: SeparableFilterMode, size: u32, dest: &mut Texture, src: &mut Texture, parameters: &Vector4f) -> bool { unsafe { tsSeparableFilter_dispatch_cCSFMuTTcV4(self.this, compute.this, mode, size, dest.this, src.this, parameters) != 0 } }
}
impl Drop for SeparableFilter {
	fn drop(&mut self) { if self.owner { unsafe { tsSeparableFilter_delete(self.this) } } }
}
impl Clone for SeparableFilter {
	fn clone(&self) -> SeparableFilter { unsafe { SeparableFilter { this: tsSeparableFilter_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for SeparableFilter { }
impl fmt::Display for SeparableFilter {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::SeparableFilter ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSeparableFilter_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSeparableFilter_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSeparableFilter_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSeparableFilter_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSeparableFilter_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSeparableFilter_new() -> *mut c_void;
	fn tsSeparableFilter_delete(this: *mut c_void);
	fn tsSeparableFilter_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSeparableFilter_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSeparableFilter_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSeparableFilter_clearPtr(this: *const c_void);
	fn tsSeparableFilter_destroyPtr(this: *const c_void);
	fn tsSeparableFilter_acquirePtr(this: *const c_void);
	fn tsSeparableFilter_unacquirePtr(this: *const c_void);
	fn tsSeparableFilter_isValidPtr(this: *const c_void) -> i32;
	fn tsSeparableFilter_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSeparableFilter_isConstPtr(this: *const c_void) -> i32;
	fn tsSeparableFilter_getCountPtr(this: *const c_void) -> u32;
	fn tsSeparableFilter_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSeparableFilter_clear(this: *mut c_void);
	fn tsSeparableFilter_isCreated(this: *const c_void, format: Format, size: u32) -> i32;
	fn tsSeparableFilter_setInputSource(this: *mut c_void, mode: SeparableFilterMode, src: *const c_char);
	fn tsSeparableFilter_getInputSource(this: *const c_void, mode: SeparableFilterMode) -> *mut c_void;
	fn tsSeparableFilter_setOutputSource(this: *mut c_void, mode: SeparableFilterMode, src: *const c_char);
	fn tsSeparableFilter_getOutputSource(this: *const c_void, mode: SeparableFilterMode) -> *mut c_void;
	fn tsSeparableFilter_create(this: *mut c_void, device: *mut c_void, format: Format, size: u32, flags: SeparableFilterFlags) -> i32;
	fn tsSeparableFilter_setWeights_SFMcAV4b(this: *mut c_void, mode: SeparableFilterMode, weights: *const Vector4f, weights_size: u32, normalize: i32);
	fn tsSeparableFilter_setWeights_SFMcA32b(this: *mut c_void, mode: SeparableFilterMode, weights: *const f32, weights_size: u32, normalize: i32);
	fn tsSeparableFilter_setGaussianWeights_ucV4(this: *mut c_void, size: u32, sigma: *const Vector4f);
	fn tsSeparableFilter_setGaussianWeights_uf(this: *mut c_void, size: u32, sigma: f32);
	fn tsSeparableFilter_setSobelXWeights(this: *mut c_void, size: u32);
	fn tsSeparableFilter_setSobelYWeights(this: *mut c_void, size: u32);
	fn tsSeparableFilter_setBoxWeights(this: *mut c_void, size: u32);
	fn tsSeparableFilter_dispatch_cCSFMuTTcScScV4(this: *const c_void, compute: *mut c_void, mode: SeparableFilterMode, size: u32, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice, parameters: *const Vector4f) -> i32;
	fn tsSeparableFilter_dispatch_cCSFMuTTcScV4(this: *const c_void, compute: *mut c_void, mode: SeparableFilterMode, size: u32, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice, parameters: *const Vector4f) -> i32;
	fn tsSeparableFilter_dispatch_cCSFMuTTcV4(this: *const c_void, compute: *mut c_void, mode: SeparableFilterMode, size: u32, dest: *mut c_void, src: *mut c_void, parameters: *const Vector4f) -> i32;
}

// Tellusim::PrefixScan
pub struct PrefixScan {
	this: *mut c_void,
	owner: bool,
}
impl PrefixScan {
	pub fn null() -> PrefixScan { PrefixScan { this: ptr::null_mut(), owner: false } }
	pub fn new() -> PrefixScan { unsafe { PrefixScan { this: tsPrefixScan_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> PrefixScan { unsafe { PrefixScan { this: ptr, owner: tsPrefixScan_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> PrefixScan { unsafe { PrefixScan { this: tsPrefixScan_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: PrefixScan) -> bool { unsafe { tsPrefixScan_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> PrefixScan { unsafe { PrefixScan { this: tsPrefixScan_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsPrefixScan_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsPrefixScan_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsPrefixScan_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsPrefixScan_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsPrefixScan_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsPrefixScan_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsPrefixScan_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsPrefixScan_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsPrefixScan_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsPrefixScan_clear(self.this) } }
	pub fn is_created(&self, flags: PrefixScanFlags) -> bool { unsafe { tsPrefixScan_isCreated(self.this, flags) != 0 } }
	pub fn group_size(&self) -> u32 { unsafe { tsPrefixScan_getGroupSize(self.this) } }
	pub fn scan_elements(&self) -> u32 { unsafe { tsPrefixScan_getScanElements(self.this) } }
	pub fn max_elements(&self) -> u32 { unsafe { tsPrefixScan_getMaxElements(self.this) } }
	pub fn max_regions(&self) -> u32 { unsafe { tsPrefixScan_getMaxRegions(self.this) } }
	pub fn create(&mut self, device: &Device, mode: PrefixScanMode) -> bool { unsafe { tsPrefixScan_create_cDPSMuuA(self.this, device.this, mode, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups(&mut self, device: &Device, mode: PrefixScanMode, groups: u32) -> bool { unsafe { tsPrefixScan_create_cDPSMuuA(self.this, device.this, mode, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions(&mut self, device: &Device, mode: PrefixScanMode, groups: u32, regions: u32) -> bool { unsafe { tsPrefixScan_create_cDPSMuuA(self.this, device.this, mode, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions_async(&mut self, device: &Device, mode: PrefixScanMode, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsPrefixScan_create_cDPSMuuA(self.this, device.this, mode, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: PrefixScanFlags) -> bool { unsafe { tsPrefixScan_create_cDPSFuuA(self.this, device.this, flags, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups(&mut self, device: &Device, flags: PrefixScanFlags, groups: u32) -> bool { unsafe { tsPrefixScan_create_cDPSFuuA(self.this, device.this, flags, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions(&mut self, device: &Device, flags: PrefixScanFlags, groups: u32, regions: u32) -> bool { unsafe { tsPrefixScan_create_cDPSFuuA(self.this, device.this, flags, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions_async(&mut self, device: &Device, flags: PrefixScanFlags, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsPrefixScan_create_cDPSFuuA(self.this, device.this, flags, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, offset: u32, size: u32) -> bool { unsafe { tsPrefixScan_dispatch_CBuu(self.this, compute.this, data.this, offset, size) != 0 } }
	pub fn dispatch_with_count(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, offsets: *const u32, sizes: *const u32) -> bool { unsafe { tsPrefixScan_dispatch_CBuupupPSF(self.this, compute.this, data.this, count, offsets, sizes, PrefixScanFlags::None) != 0 } }
	pub fn dispatch_with_count_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, offsets: *const u32, sizes: *const u32, flags: PrefixScanFlags) -> bool { unsafe { tsPrefixScan_dispatch_CBuupupPSF(self.this, compute.this, data.this, count, offsets, sizes, flags) != 0 } }
	pub fn dispatch_indirect_with_dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBBuPSFu(self.this, compute.this, data.this, dispatch.this, offset, PrefixScanFlags::None, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_dispatch_flags(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, flags: PrefixScanFlags) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBBuPSFu(self.this, compute.this, data.this, dispatch.this, offset, flags, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_dispatch_flags_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, flags: PrefixScanFlags, max_size: u32) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBBuPSFu(self.this, compute.this, data.this, dispatch.this, offset, flags, max_size) != 0 } }
	pub fn dispatch_indirect_with_countu32(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBuBuPSFu(self.this, compute.this, data.this, count, dispatch.this, offset, PrefixScanFlags::None, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countu32_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, flags: PrefixScanFlags) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBuBuPSFu(self.this, compute.this, data.this, count, dispatch.this, offset, flags, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countu32_flags_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, flags: PrefixScanFlags, max_size: u32) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBuBuPSFu(self.this, compute.this, data.this, count, dispatch.this, offset, flags, max_size) != 0 } }
	pub fn dispatch_indirect_with_countb(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBBBuuPSFu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, PrefixScanFlags::None, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countb_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32, flags: PrefixScanFlags) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBBBuuPSFu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, flags, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countb_flags_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32, flags: PrefixScanFlags, max_size: u32) -> bool { unsafe { tsPrefixScan_dispatchIndirect_CBBBuuPSFu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, flags, max_size) != 0 } }
}
impl Drop for PrefixScan {
	fn drop(&mut self) { if self.owner { unsafe { tsPrefixScan_delete(self.this) } } }
}
impl Clone for PrefixScan {
	fn clone(&self) -> PrefixScan { unsafe { PrefixScan { this: tsPrefixScan_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for PrefixScan { }
impl fmt::Display for PrefixScan {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::PrefixScan ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsPrefixScan_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsPrefixScan_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsPrefixScan_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsPrefixScan_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsPrefixScan_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsPrefixScan_new() -> *mut c_void;
	fn tsPrefixScan_delete(this: *mut c_void);
	fn tsPrefixScan_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsPrefixScan_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsPrefixScan_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsPrefixScan_clearPtr(this: *const c_void);
	fn tsPrefixScan_destroyPtr(this: *const c_void);
	fn tsPrefixScan_acquirePtr(this: *const c_void);
	fn tsPrefixScan_unacquirePtr(this: *const c_void);
	fn tsPrefixScan_isValidPtr(this: *const c_void) -> i32;
	fn tsPrefixScan_isOwnerPtr(this: *const c_void) -> i32;
	fn tsPrefixScan_isConstPtr(this: *const c_void) -> i32;
	fn tsPrefixScan_getCountPtr(this: *const c_void) -> u32;
	fn tsPrefixScan_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsPrefixScan_clear(this: *mut c_void);
	fn tsPrefixScan_isCreated(this: *const c_void, flags: PrefixScanFlags) -> i32;
	fn tsPrefixScan_getGroupSize(this: *const c_void) -> u32;
	fn tsPrefixScan_getScanElements(this: *const c_void) -> u32;
	fn tsPrefixScan_getMaxElements(this: *const c_void) -> u32;
	fn tsPrefixScan_getMaxRegions(this: *const c_void) -> u32;
	fn tsPrefixScan_create_cDPSMuuA(this: *mut c_void, device: *mut c_void, mode: PrefixScanMode, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsPrefixScan_create_cDPSFuuA(this: *mut c_void, device: *mut c_void, flags: PrefixScanFlags, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsPrefixScan_dispatch_CBuu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, offset: u32, size: u32) -> i32;
	fn tsPrefixScan_dispatch_CBuupupPSF(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: u32, offsets: *const u32, sizes: *const u32, flags: PrefixScanFlags) -> i32;
	fn tsPrefixScan_dispatchIndirect_CBBuPSFu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, dispatch: *mut c_void, offset: u32, flags: PrefixScanFlags, max_size: u32) -> i32;
	fn tsPrefixScan_dispatchIndirect_CBuBuPSFu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: u32, dispatch: *mut c_void, offset: u32, flags: PrefixScanFlags, max_size: u32) -> i32;
	fn tsPrefixScan_dispatchIndirect_CBBBuuPSFu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: *mut c_void, dispatch: *mut c_void, count_offset: u32, dispatch_offset: u32, flags: PrefixScanFlags, max_size: u32) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrefixScanDispatchParameters {
	pub offset: u32,
	pub size: u32,
	pub padding_0: u32,
	pub padding_1: u32,
}
impl fmt::Display for PrefixScanDispatchParameters {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("offset: {0}\n", self.offset);
		ret += &format!("size: {0}\n", self.size);
		write!(f, "{0}", ret)
	}
}

// Tellusim::RadixSort
pub struct RadixSort {
	this: *mut c_void,
	owner: bool,
}
impl RadixSort {
	pub fn null() -> RadixSort { RadixSort { this: ptr::null_mut(), owner: false } }
	pub fn new() -> RadixSort { unsafe { RadixSort { this: tsRadixSort_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> RadixSort { unsafe { RadixSort { this: ptr, owner: tsRadixSort_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> RadixSort { unsafe { RadixSort { this: tsRadixSort_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: RadixSort) -> bool { unsafe { tsRadixSort_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> RadixSort { unsafe { RadixSort { this: tsRadixSort_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsRadixSort_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsRadixSort_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsRadixSort_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsRadixSort_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsRadixSort_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsRadixSort_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsRadixSort_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsRadixSort_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsRadixSort_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsRadixSort_clear(self.this) } }
	pub fn is_created(&self, flags: RadixSortFlags) -> bool { unsafe { tsRadixSort_isCreated(self.this, flags) != 0 } }
	pub fn data_size(&self) -> u32 { unsafe { tsRadixSort_getDataSize(self.this) } }
	pub fn group_size(&self) -> u32 { unsafe { tsRadixSort_getGroupSize(self.this) } }
	pub fn sort_elements(&self) -> u32 { unsafe { tsRadixSort_getSortElements(self.this) } }
	pub fn update_elements(&self) -> u32 { unsafe { tsRadixSort_getUpdateElements(self.this) } }
	pub fn max_elements(&self) -> u32 { unsafe { tsRadixSort_getMaxElements(self.this) } }
	pub fn max_regions(&self) -> u32 { unsafe { tsRadixSort_getMaxRegions(self.this) } }
	pub fn prefix_scan(&self) -> PrefixScan { unsafe { PrefixScan::new_ptr(tsRadixSort_getPrefixScan(self.this)) } }
	pub fn data_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsRadixSort_getDataBuffer(self.this)) } }
	pub fn create(&mut self, device: &Device, mode: RadixSortMode, scan: &mut PrefixScan, size: u32) -> bool { unsafe { tsRadixSort_create_cDRSMPSuuuA(self.this, device.this, mode, scan.this, size, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups(&mut self, device: &Device, mode: RadixSortMode, scan: &mut PrefixScan, size: u32, groups: u32) -> bool { unsafe { tsRadixSort_create_cDRSMPSuuuA(self.this, device.this, mode, scan.this, size, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions(&mut self, device: &Device, mode: RadixSortMode, scan: &mut PrefixScan, size: u32, groups: u32, regions: u32) -> bool { unsafe { tsRadixSort_create_cDRSMPSuuuA(self.this, device.this, mode, scan.this, size, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions_async(&mut self, device: &Device, mode: RadixSortMode, scan: &mut PrefixScan, size: u32, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsRadixSort_create_cDRSMPSuuuA(self.this, device.this, mode, scan.this, size, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: RadixSortFlags, scan: &mut PrefixScan, size: u32) -> bool { unsafe { tsRadixSort_create_cDRSFPSuuuA(self.this, device.this, flags, scan.this, size, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups(&mut self, device: &Device, flags: RadixSortFlags, scan: &mut PrefixScan, size: u32, groups: u32) -> bool { unsafe { tsRadixSort_create_cDRSFPSuuuA(self.this, device.this, flags, scan.this, size, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions(&mut self, device: &Device, flags: RadixSortFlags, scan: &mut PrefixScan, size: u32, groups: u32, regions: u32) -> bool { unsafe { tsRadixSort_create_cDRSFPSuuuA(self.this, device.this, flags, scan.this, size, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions_async(&mut self, device: &Device, flags: RadixSortFlags, scan: &mut PrefixScan, size: u32, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsRadixSort_create_cDRSFPSuuuA(self.this, device.this, flags, scan.this, size, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, keys_offset: u32, data_offset: u32, size: u32) -> bool { unsafe { tsRadixSort_dispatch_CBuuuRSFu(self.this, compute.this, data.this, keys_offset, data_offset, size, RadixSortFlags::None, 32) != 0 } }
	pub fn dispatch_with_flags(&mut self, compute: &mut Compute, data: &mut Buffer, keys_offset: u32, data_offset: u32, size: u32, flags: RadixSortFlags) -> bool { unsafe { tsRadixSort_dispatch_CBuuuRSFu(self.this, compute.this, data.this, keys_offset, data_offset, size, flags, 32) != 0 } }
	pub fn dispatch_with_flags_bits(&mut self, compute: &mut Compute, data: &mut Buffer, keys_offset: u32, data_offset: u32, size: u32, flags: RadixSortFlags, bits: u32) -> bool { unsafe { tsRadixSort_dispatch_CBuuuRSFu(self.this, compute.this, data.this, keys_offset, data_offset, size, flags, bits) != 0 } }
	pub fn dispatch_with_count(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32) -> bool { unsafe { tsRadixSort_dispatch_CBuupupupRSFu(self.this, compute.this, data.this, count, keys_offsets, data_offsets, sizes, RadixSortFlags::None, 32) != 0 } }
	pub fn dispatch_with_count_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32, flags: RadixSortFlags) -> bool { unsafe { tsRadixSort_dispatch_CBuupupupRSFu(self.this, compute.this, data.this, count, keys_offsets, data_offsets, sizes, flags, 32) != 0 } }
	pub fn dispatch_with_count_flags_bits(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32, flags: RadixSortFlags, bits: u32) -> bool { unsafe { tsRadixSort_dispatch_CBuupupupRSFu(self.this, compute.this, data.this, count, keys_offsets, data_offsets, sizes, flags, bits) != 0 } }
	pub fn dispatch_indirect_with_dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBuRSFuu(self.this, compute.this, data.this, dispatch.this, offset, RadixSortFlags::None, 32, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_dispatch_flags(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, flags: RadixSortFlags) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBuRSFuu(self.this, compute.this, data.this, dispatch.this, offset, flags, 32, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_dispatch_flags_bits(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, flags: RadixSortFlags, bits: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBuRSFuu(self.this, compute.this, data.this, dispatch.this, offset, flags, bits, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_dispatch_flags_bits_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, flags: RadixSortFlags, bits: u32, max_size: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBuRSFuu(self.this, compute.this, data.this, dispatch.this, offset, flags, bits, max_size) != 0 } }
	pub fn dispatch_indirect_with_countu32(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBuBuRSFuu(self.this, compute.this, data.this, count, dispatch.this, offset, RadixSortFlags::None, 32, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countu32_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, flags: RadixSortFlags) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBuBuRSFuu(self.this, compute.this, data.this, count, dispatch.this, offset, flags, 32, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countu32_flags_bits(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, flags: RadixSortFlags, bits: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBuBuRSFuu(self.this, compute.this, data.this, count, dispatch.this, offset, flags, bits, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countu32_flags_bits_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, flags: RadixSortFlags, bits: u32, max_size: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBuBuRSFuu(self.this, compute.this, data.this, count, dispatch.this, offset, flags, bits, max_size) != 0 } }
	pub fn dispatch_indirect_with_countb(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBBuuRSFuu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, RadixSortFlags::None, 32, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countb_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32, flags: RadixSortFlags) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBBuuRSFuu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, flags, 32, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countb_flags_bits(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32, flags: RadixSortFlags, bits: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBBuuRSFuu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, flags, bits, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_countb_flags_bits_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32, flags: RadixSortFlags, bits: u32, max_size: u32) -> bool { unsafe { tsRadixSort_dispatchIndirect_CBBBuuRSFuu(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, flags, bits, max_size) != 0 } }
}
impl Drop for RadixSort {
	fn drop(&mut self) { if self.owner { unsafe { tsRadixSort_delete(self.this) } } }
}
impl Clone for RadixSort {
	fn clone(&self) -> RadixSort { unsafe { RadixSort { this: tsRadixSort_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for RadixSort { }
impl fmt::Display for RadixSort {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::RadixSort ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsRadixSort_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsRadixSort_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsRadixSort_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsRadixSort_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsRadixSort_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsRadixSort_new() -> *mut c_void;
	fn tsRadixSort_delete(this: *mut c_void);
	fn tsRadixSort_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsRadixSort_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsRadixSort_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsRadixSort_clearPtr(this: *const c_void);
	fn tsRadixSort_destroyPtr(this: *const c_void);
	fn tsRadixSort_acquirePtr(this: *const c_void);
	fn tsRadixSort_unacquirePtr(this: *const c_void);
	fn tsRadixSort_isValidPtr(this: *const c_void) -> i32;
	fn tsRadixSort_isOwnerPtr(this: *const c_void) -> i32;
	fn tsRadixSort_isConstPtr(this: *const c_void) -> i32;
	fn tsRadixSort_getCountPtr(this: *const c_void) -> u32;
	fn tsRadixSort_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsRadixSort_clear(this: *mut c_void);
	fn tsRadixSort_isCreated(this: *const c_void, flags: RadixSortFlags) -> i32;
	fn tsRadixSort_getDataSize(this: *const c_void) -> u32;
	fn tsRadixSort_getGroupSize(this: *const c_void) -> u32;
	fn tsRadixSort_getSortElements(this: *const c_void) -> u32;
	fn tsRadixSort_getUpdateElements(this: *const c_void) -> u32;
	fn tsRadixSort_getMaxElements(this: *const c_void) -> u32;
	fn tsRadixSort_getMaxRegions(this: *const c_void) -> u32;
	fn tsRadixSort_getPrefixScan(this: *const c_void) -> *mut c_void;
	fn tsRadixSort_getDataBuffer(this: *const c_void) -> *mut c_void;
	fn tsRadixSort_create_cDRSMPSuuuA(this: *mut c_void, device: *mut c_void, mode: RadixSortMode, scan: *mut c_void, size: u32, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsRadixSort_create_cDRSFPSuuuA(this: *mut c_void, device: *mut c_void, flags: RadixSortFlags, scan: *mut c_void, size: u32, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsRadixSort_dispatch_CBuuuRSFu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, keys_offset: u32, data_offset: u32, size: u32, flags: RadixSortFlags, bits: u32) -> i32;
	fn tsRadixSort_dispatch_CBuupupupRSFu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32, flags: RadixSortFlags, bits: u32) -> i32;
	fn tsRadixSort_dispatchIndirect_CBBuRSFuu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, dispatch: *mut c_void, offset: u32, flags: RadixSortFlags, bits: u32, max_size: u32) -> i32;
	fn tsRadixSort_dispatchIndirect_CBuBuRSFuu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: u32, dispatch: *mut c_void, offset: u32, flags: RadixSortFlags, bits: u32, max_size: u32) -> i32;
	fn tsRadixSort_dispatchIndirect_CBBBuuRSFuu(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: *mut c_void, dispatch: *mut c_void, count_offset: u32, dispatch_offset: u32, flags: RadixSortFlags, bits: u32, max_size: u32) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RadixSortDispatchParameters {
	pub keys_offset: u32,
	pub data_offset: u32,
	pub size: u32,
	pub padding: u32,
}
impl fmt::Display for RadixSortDispatchParameters {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("keys_offset: {0}\n", self.keys_offset);
		ret += &format!("data_offset: {0}\n", self.data_offset);
		ret += &format!("size: {0}\n", self.size);
		write!(f, "{0}", ret)
	}
}

// Tellusim::BitonicSort
pub struct BitonicSort {
	this: *mut c_void,
	owner: bool,
}
impl BitonicSort {
	pub fn null() -> BitonicSort { BitonicSort { this: ptr::null_mut(), owner: false } }
	pub fn new() -> BitonicSort { unsafe { BitonicSort { this: tsBitonicSort_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> BitonicSort { unsafe { BitonicSort { this: ptr, owner: tsBitonicSort_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> BitonicSort { unsafe { BitonicSort { this: tsBitonicSort_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: BitonicSort) -> bool { unsafe { tsBitonicSort_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> BitonicSort { unsafe { BitonicSort { this: tsBitonicSort_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsBitonicSort_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsBitonicSort_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsBitonicSort_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsBitonicSort_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsBitonicSort_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsBitonicSort_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsBitonicSort_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsBitonicSort_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsBitonicSort_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsBitonicSort_clear(self.this) } }
	pub fn is_created(&self, flags: BitonicSortFlags) -> bool { unsafe { tsBitonicSort_isCreated(self.this, flags) != 0 } }
	pub fn data_size(&self) -> u32 { unsafe { tsBitonicSort_getDataSize(self.this) } }
	pub fn group_size(&self) -> u32 { unsafe { tsBitonicSort_getGroupSize(self.this) } }
	pub fn sort_elements(&self) -> u32 { unsafe { tsBitonicSort_getSortElements(self.this) } }
	pub fn max_regions(&self) -> u32 { unsafe { tsBitonicSort_getMaxRegions(self.this) } }
	pub fn create(&mut self, device: &Device, mode: BitonicSortMode, size: u32) -> bool { unsafe { tsBitonicSort_create_cDBSMuuuA(self.this, device.this, mode, size, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups(&mut self, device: &Device, mode: BitonicSortMode, size: u32, groups: u32) -> bool { unsafe { tsBitonicSort_create_cDBSMuuuA(self.this, device.this, mode, size, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions(&mut self, device: &Device, mode: BitonicSortMode, size: u32, groups: u32, regions: u32) -> bool { unsafe { tsBitonicSort_create_cDBSMuuuA(self.this, device.this, mode, size, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions_async(&mut self, device: &Device, mode: BitonicSortMode, size: u32, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsBitonicSort_create_cDBSMuuuA(self.this, device.this, mode, size, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: BitonicSortFlags, size: u32) -> bool { unsafe { tsBitonicSort_create_cDBSFuuuA(self.this, device.this, flags, size, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups(&mut self, device: &Device, flags: BitonicSortFlags, size: u32, groups: u32) -> bool { unsafe { tsBitonicSort_create_cDBSFuuuA(self.this, device.this, flags, size, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions(&mut self, device: &Device, flags: BitonicSortFlags, size: u32, groups: u32, regions: u32) -> bool { unsafe { tsBitonicSort_create_cDBSFuuuA(self.this, device.this, flags, size, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions_async(&mut self, device: &Device, flags: BitonicSortFlags, size: u32, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsBitonicSort_create_cDBSFuuuA(self.this, device.this, flags, size, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, keys_offset: u32, data_offset: u32, size: u32) -> bool { unsafe { tsBitonicSort_dispatch_CBuuuBSF(self.this, compute.this, data.this, keys_offset, data_offset, size, BitonicSortFlags::None) != 0 } }
	pub fn dispatch_with_flags(&mut self, compute: &mut Compute, data: &mut Buffer, keys_offset: u32, data_offset: u32, size: u32, flags: BitonicSortFlags) -> bool { unsafe { tsBitonicSort_dispatch_CBuuuBSF(self.this, compute.this, data.this, keys_offset, data_offset, size, flags) != 0 } }
	pub fn dispatch_with_count(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32) -> bool { unsafe { tsBitonicSort_dispatch_CBuupupupBSF(self.this, compute.this, data.this, count, keys_offsets, data_offsets, sizes, BitonicSortFlags::None) != 0 } }
	pub fn dispatch_with_count_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32, flags: BitonicSortFlags) -> bool { unsafe { tsBitonicSort_dispatch_CBuupupupBSF(self.this, compute.this, data.this, count, keys_offsets, data_offsets, sizes, flags) != 0 } }
	pub fn dispatch_indirect_with_dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsBitonicSort_dispatchIndirect_CBBuBSF(self.this, compute.this, data.this, dispatch.this, offset, BitonicSortFlags::None) != 0 } }
	pub fn dispatch_indirect_with_dispatch_flags(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, flags: BitonicSortFlags) -> bool { unsafe { tsBitonicSort_dispatchIndirect_CBBuBSF(self.this, compute.this, data.this, dispatch.this, offset, flags) != 0 } }
	pub fn dispatch_indirect_with_countu32(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsBitonicSort_dispatchIndirect_CBuBuBSF(self.this, compute.this, data.this, count, dispatch.this, offset, BitonicSortFlags::None) != 0 } }
	pub fn dispatch_indirect_with_countu32_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, flags: BitonicSortFlags) -> bool { unsafe { tsBitonicSort_dispatchIndirect_CBuBuBSF(self.this, compute.this, data.this, count, dispatch.this, offset, flags) != 0 } }
	pub fn dispatch_indirect_with_countb(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32) -> bool { unsafe { tsBitonicSort_dispatchIndirect_CBBBuuBSF(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, BitonicSortFlags::None) != 0 } }
	pub fn dispatch_indirect_with_countb_flags(&mut self, compute: &mut Compute, data: &mut Buffer, count: &mut Buffer, dispatch: &mut Buffer, count_offset: u32, dispatch_offset: u32, flags: BitonicSortFlags) -> bool { unsafe { tsBitonicSort_dispatchIndirect_CBBBuuBSF(self.this, compute.this, data.this, count.this, dispatch.this, count_offset, dispatch_offset, flags) != 0 } }
}
impl Drop for BitonicSort {
	fn drop(&mut self) { if self.owner { unsafe { tsBitonicSort_delete(self.this) } } }
}
impl Clone for BitonicSort {
	fn clone(&self) -> BitonicSort { unsafe { BitonicSort { this: tsBitonicSort_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for BitonicSort { }
impl fmt::Display for BitonicSort {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::BitonicSort ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsBitonicSort_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsBitonicSort_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsBitonicSort_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsBitonicSort_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsBitonicSort_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsBitonicSort_new() -> *mut c_void;
	fn tsBitonicSort_delete(this: *mut c_void);
	fn tsBitonicSort_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsBitonicSort_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsBitonicSort_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsBitonicSort_clearPtr(this: *const c_void);
	fn tsBitonicSort_destroyPtr(this: *const c_void);
	fn tsBitonicSort_acquirePtr(this: *const c_void);
	fn tsBitonicSort_unacquirePtr(this: *const c_void);
	fn tsBitonicSort_isValidPtr(this: *const c_void) -> i32;
	fn tsBitonicSort_isOwnerPtr(this: *const c_void) -> i32;
	fn tsBitonicSort_isConstPtr(this: *const c_void) -> i32;
	fn tsBitonicSort_getCountPtr(this: *const c_void) -> u32;
	fn tsBitonicSort_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsBitonicSort_clear(this: *mut c_void);
	fn tsBitonicSort_isCreated(this: *const c_void, flags: BitonicSortFlags) -> i32;
	fn tsBitonicSort_getDataSize(this: *const c_void) -> u32;
	fn tsBitonicSort_getGroupSize(this: *const c_void) -> u32;
	fn tsBitonicSort_getSortElements(this: *const c_void) -> u32;
	fn tsBitonicSort_getMaxRegions(this: *const c_void) -> u32;
	fn tsBitonicSort_create_cDBSMuuuA(this: *mut c_void, device: *mut c_void, mode: BitonicSortMode, size: u32, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsBitonicSort_create_cDBSFuuuA(this: *mut c_void, device: *mut c_void, flags: BitonicSortFlags, size: u32, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsBitonicSort_dispatch_CBuuuBSF(this: *mut c_void, compute: *mut c_void, data: *mut c_void, keys_offset: u32, data_offset: u32, size: u32, flags: BitonicSortFlags) -> i32;
	fn tsBitonicSort_dispatch_CBuupupupBSF(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: u32, keys_offsets: *const u32, data_offsets: *const u32, sizes: *const u32, flags: BitonicSortFlags) -> i32;
	fn tsBitonicSort_dispatchIndirect_CBBuBSF(this: *mut c_void, compute: *mut c_void, data: *mut c_void, dispatch: *mut c_void, offset: u32, flags: BitonicSortFlags) -> i32;
	fn tsBitonicSort_dispatchIndirect_CBuBuBSF(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: u32, dispatch: *mut c_void, offset: u32, flags: BitonicSortFlags) -> i32;
	fn tsBitonicSort_dispatchIndirect_CBBBuuBSF(this: *mut c_void, compute: *mut c_void, data: *mut c_void, count: *mut c_void, dispatch: *mut c_void, count_offset: u32, dispatch_offset: u32, flags: BitonicSortFlags) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitonicSortDispatchParameters {
	pub keys_offset: u32,
	pub data_offset: u32,
	pub size: u32,
	pub padding: u32,
}
impl fmt::Display for BitonicSortDispatchParameters {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("keys_offset: {0}\n", self.keys_offset);
		ret += &format!("data_offset: {0}\n", self.data_offset);
		ret += &format!("size: {0}\n", self.size);
		write!(f, "{0}", ret)
	}
}

// Tellusim::SpatialGrid
pub struct SpatialGrid {
	this: *mut c_void,
	owner: bool,
}
impl SpatialGrid {
	pub fn null() -> SpatialGrid { SpatialGrid { this: ptr::null_mut(), owner: false } }
	pub fn new() -> SpatialGrid { unsafe { SpatialGrid { this: tsSpatialGrid_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> SpatialGrid { unsafe { SpatialGrid { this: ptr, owner: tsSpatialGrid_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> SpatialGrid { unsafe { SpatialGrid { this: tsSpatialGrid_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: SpatialGrid) -> bool { unsafe { tsSpatialGrid_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> SpatialGrid { unsafe { SpatialGrid { this: tsSpatialGrid_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSpatialGrid_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSpatialGrid_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSpatialGrid_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSpatialGrid_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSpatialGrid_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSpatialGrid_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSpatialGrid_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSpatialGrid_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSpatialGrid_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsSpatialGrid_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsSpatialGrid_isCreated(self.this) != 0 } }
	pub fn group_size(&self) -> u32 { unsafe { tsSpatialGrid_getGroupSize(self.this) } }
	pub fn radix_sort(&self) -> RadixSort { unsafe { RadixSort::new_ptr(tsSpatialGrid_getRadixSort(self.this)) } }
	pub fn create(&mut self, device: &Device, sort: &mut RadixSort) -> bool { unsafe { tsSpatialGrid_create(self.this, device.this, sort.this, 256) != 0 } }
	pub fn create_with_groups(&mut self, device: &Device, sort: &mut RadixSort, groups: u32) -> bool { unsafe { tsSpatialGrid_create(self.this, device.this, sort.this, groups) != 0 } }
	pub fn dispatch(&mut self, compute: &mut Compute, data: &mut Buffer, offset: u32, size: u32) -> bool { unsafe { tsSpatialGrid_dispatch(self.this, compute.this, data.this, offset, size, 32) != 0 } }
	pub fn dispatch_with_bits(&mut self, compute: &mut Compute, data: &mut Buffer, offset: u32, size: u32, bits: u32) -> bool { unsafe { tsSpatialGrid_dispatch(self.this, compute.this, data.this, offset, size, bits) != 0 } }
	pub fn dispatch_indirect(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsSpatialGrid_dispatchIndirect(self.this, compute.this, data.this, dispatch.this, offset, MAXU32) != 0 } }
	pub fn dispatch_indirect_with_maxsize(&mut self, compute: &mut Compute, data: &mut Buffer, dispatch: &mut Buffer, offset: u32, max_size: u32) -> bool { unsafe { tsSpatialGrid_dispatchIndirect(self.this, compute.this, data.this, dispatch.this, offset, max_size) != 0 } }
}
impl Drop for SpatialGrid {
	fn drop(&mut self) { if self.owner { unsafe { tsSpatialGrid_delete(self.this) } } }
}
impl Clone for SpatialGrid {
	fn clone(&self) -> SpatialGrid { unsafe { SpatialGrid { this: tsSpatialGrid_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for SpatialGrid { }
impl fmt::Display for SpatialGrid {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::SpatialGrid ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSpatialGrid_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSpatialGrid_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSpatialGrid_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSpatialGrid_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSpatialGrid_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSpatialGrid_new() -> *mut c_void;
	fn tsSpatialGrid_delete(this: *mut c_void);
	fn tsSpatialGrid_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSpatialGrid_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSpatialGrid_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSpatialGrid_clearPtr(this: *const c_void);
	fn tsSpatialGrid_destroyPtr(this: *const c_void);
	fn tsSpatialGrid_acquirePtr(this: *const c_void);
	fn tsSpatialGrid_unacquirePtr(this: *const c_void);
	fn tsSpatialGrid_isValidPtr(this: *const c_void) -> i32;
	fn tsSpatialGrid_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSpatialGrid_isConstPtr(this: *const c_void) -> i32;
	fn tsSpatialGrid_getCountPtr(this: *const c_void) -> u32;
	fn tsSpatialGrid_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSpatialGrid_clear(this: *mut c_void);
	fn tsSpatialGrid_isCreated(this: *const c_void) -> i32;
	fn tsSpatialGrid_getGroupSize(this: *const c_void) -> u32;
	fn tsSpatialGrid_getRadixSort(this: *const c_void) -> *mut c_void;
	fn tsSpatialGrid_create(this: *mut c_void, device: *mut c_void, sort: *mut c_void, groups: u32) -> i32;
	fn tsSpatialGrid_dispatch(this: *mut c_void, compute: *mut c_void, data: *mut c_void, offset: u32, size: u32, bits: u32) -> i32;
	fn tsSpatialGrid_dispatchIndirect(this: *mut c_void, compute: *mut c_void, data: *mut c_void, dispatch: *mut c_void, offset: u32, max_size: u32) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpatialGridDispatchParameters {
	pub offset: u32,
	pub size: u32,
	pub padding_0: u32,
	pub padding_1: u32,
}
impl fmt::Display for SpatialGridDispatchParameters {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("offset: {0}\n", self.offset);
		ret += &format!("size: {0}\n", self.size);
		write!(f, "{0}", ret)
	}
}

// Tellusim::SpatialTree
pub struct SpatialTree {
	this: *mut c_void,
	owner: bool,
}
impl SpatialTree {
	pub fn null() -> SpatialTree { SpatialTree { this: ptr::null_mut(), owner: false } }
	pub fn new() -> SpatialTree { unsafe { SpatialTree { this: tsSpatialTree_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> SpatialTree { unsafe { SpatialTree { this: ptr, owner: tsSpatialTree_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> SpatialTree { unsafe { SpatialTree { this: tsSpatialTree_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: SpatialTree) -> bool { unsafe { tsSpatialTree_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> SpatialTree { unsafe { SpatialTree { this: tsSpatialTree_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsSpatialTree_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsSpatialTree_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsSpatialTree_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsSpatialTree_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsSpatialTree_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsSpatialTree_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsSpatialTree_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsSpatialTree_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsSpatialTree_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsSpatialTree_clear(self.this) } }
	pub fn is_created(&self, flags: SpatialTreeFlags) -> bool { unsafe { tsSpatialTree_isCreated(self.this, flags) != 0 } }
	pub fn group_size(&self) -> u32 { unsafe { tsSpatialTree_getGroupSize(self.this) } }
	pub fn bounds_nodes(&self) -> u32 { unsafe { tsSpatialTree_getBoundsNodes(self.this) } }
	pub fn max_nodes(&self) -> u32 { unsafe { tsSpatialTree_getMaxNodes(self.this) } }
	pub fn max_regions(&self) -> u32 { unsafe { tsSpatialTree_getMaxRegions(self.this) } }
	pub fn radix_sort(&self) -> RadixSort { unsafe { RadixSort::new_ptr(tsSpatialTree_getRadixSort(self.this)) } }
	pub fn hash_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsSpatialTree_getHashBuffer(self.this)) } }
	pub fn parents_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsSpatialTree_getParentsBuffer(self.this)) } }
	pub fn counter_buffer(&self) -> Buffer { unsafe { Buffer::new_ptr(tsSpatialTree_getCounterBuffer(self.this)) } }
	pub fn create(&mut self, device: &Device, mode: SpatialTreeMode, sort: &mut RadixSort, size: u32) -> bool { unsafe { tsSpatialTree_create_cDSTMRSuuuA(self.this, device.this, mode, sort.this, size, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups(&mut self, device: &Device, mode: SpatialTreeMode, sort: &mut RadixSort, size: u32, groups: u32) -> bool { unsafe { tsSpatialTree_create_cDSTMRSuuuA(self.this, device.this, mode, sort.this, size, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions(&mut self, device: &Device, mode: SpatialTreeMode, sort: &mut RadixSort, size: u32, groups: u32, regions: u32) -> bool { unsafe { tsSpatialTree_create_cDSTMRSuuuA(self.this, device.this, mode, sort.this, size, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_groups_regions_async(&mut self, device: &Device, mode: SpatialTreeMode, sort: &mut RadixSort, size: u32, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsSpatialTree_create_cDSTMRSuuuA(self.this, device.this, mode, sort.this, size, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: SpatialTreeFlags, sort: &mut RadixSort, size: u32) -> bool { unsafe { tsSpatialTree_create_cDSTFRSuuuA(self.this, device.this, flags, sort.this, size, 256, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups(&mut self, device: &Device, flags: SpatialTreeFlags, sort: &mut RadixSort, size: u32, groups: u32) -> bool { unsafe { tsSpatialTree_create_cDSTFRSuuuA(self.this, device.this, flags, sort.this, size, groups, 1, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions(&mut self, device: &Device, flags: SpatialTreeFlags, sort: &mut RadixSort, size: u32, groups: u32, regions: u32) -> bool { unsafe { tsSpatialTree_create_cDSTFRSuuuA(self.this, device.this, flags, sort.this, size, groups, regions, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_groups_regions_async(&mut self, device: &Device, flags: SpatialTreeFlags, sort: &mut RadixSort, size: u32, groups: u32, regions: u32, async_: Option<&Async>) -> bool { unsafe { tsSpatialTree_create_cDSTFRSuuuA(self.this, device.this, flags, sort.this, size, groups, regions, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn dispatch(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, offset: u32, size: u32) -> bool { unsafe { tsSpatialTree_dispatch_CSTHBuuSTF(self.this, compute.this, hash, nodes.this, offset, size, SpatialTreeFlags::None) != 0 } }
	pub fn dispatch_with_flags(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, offset: u32, size: u32, flags: SpatialTreeFlags) -> bool { unsafe { tsSpatialTree_dispatch_CSTHBuuSTF(self.this, compute.this, hash, nodes.this, offset, size, flags) != 0 } }
	pub fn dispatch_with_count(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, count: u32, offsets: *const u32, sizes: *const u32) -> bool { unsafe { tsSpatialTree_dispatch_CSTHBuupupSTF(self.this, compute.this, hash, nodes.this, count, offsets, sizes, SpatialTreeFlags::None) != 0 } }
	pub fn dispatch_with_count_flags(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, count: u32, offsets: *const u32, sizes: *const u32, flags: SpatialTreeFlags) -> bool { unsafe { tsSpatialTree_dispatch_CSTHBuupupSTF(self.this, compute.this, hash, nodes.this, count, offsets, sizes, flags) != 0 } }
	pub fn dispatch_indirect(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(self.this, compute.this, hash, nodes.this, dispatch.this, offset, MAXU32, SpatialTreeFlags::None) != 0 } }
	pub fn dispatch_indirect_with_maxsize(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, dispatch: &mut Buffer, offset: u32, max_size: u32) -> bool { unsafe { tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(self.this, compute.this, hash, nodes.this, dispatch.this, offset, max_size, SpatialTreeFlags::None) != 0 } }
	pub fn dispatch_indirect_with_maxsize_flags(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, dispatch: &mut Buffer, offset: u32, max_size: u32, flags: SpatialTreeFlags) -> bool { unsafe { tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(self.this, compute.this, hash, nodes.this, dispatch.this, offset, max_size, flags) != 0 } }
	pub fn dispatch_indirect_with_count(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32) -> bool { unsafe { tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(self.this, compute.this, hash, nodes.this, count, dispatch.this, offset, MAXU32, SpatialTreeFlags::None) != 0 } }
	pub fn dispatch_indirect_with_count_maxsize(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, max_size: u32) -> bool { unsafe { tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(self.this, compute.this, hash, nodes.this, count, dispatch.this, offset, max_size, SpatialTreeFlags::None) != 0 } }
	pub fn dispatch_indirect_with_count_maxsize_flags(&mut self, compute: &mut Compute, hash: SpatialTreeHash, nodes: &mut Buffer, count: u32, dispatch: &mut Buffer, offset: u32, max_size: u32, flags: SpatialTreeFlags) -> bool { unsafe { tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(self.this, compute.this, hash, nodes.this, count, dispatch.this, offset, max_size, flags) != 0 } }
}
impl Drop for SpatialTree {
	fn drop(&mut self) { if self.owner { unsafe { tsSpatialTree_delete(self.this) } } }
}
impl Clone for SpatialTree {
	fn clone(&self) -> SpatialTree { unsafe { SpatialTree { this: tsSpatialTree_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for SpatialTree { }
impl fmt::Display for SpatialTree {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::SpatialTree ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsSpatialTree_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsSpatialTree_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsSpatialTree_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsSpatialTree_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsSpatialTree_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsSpatialTree_new() -> *mut c_void;
	fn tsSpatialTree_delete(this: *mut c_void);
	fn tsSpatialTree_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsSpatialTree_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_clearPtr(this: *const c_void);
	fn tsSpatialTree_destroyPtr(this: *const c_void);
	fn tsSpatialTree_acquirePtr(this: *const c_void);
	fn tsSpatialTree_unacquirePtr(this: *const c_void);
	fn tsSpatialTree_isValidPtr(this: *const c_void) -> i32;
	fn tsSpatialTree_isOwnerPtr(this: *const c_void) -> i32;
	fn tsSpatialTree_isConstPtr(this: *const c_void) -> i32;
	fn tsSpatialTree_getCountPtr(this: *const c_void) -> u32;
	fn tsSpatialTree_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_clear(this: *mut c_void);
	fn tsSpatialTree_isCreated(this: *const c_void, flags: SpatialTreeFlags) -> i32;
	fn tsSpatialTree_getGroupSize(this: *const c_void) -> u32;
	fn tsSpatialTree_getBoundsNodes(this: *const c_void) -> u32;
	fn tsSpatialTree_getMaxNodes(this: *const c_void) -> u32;
	fn tsSpatialTree_getMaxRegions(this: *const c_void) -> u32;
	fn tsSpatialTree_getRadixSort(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_getHashBuffer(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_getParentsBuffer(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_getCounterBuffer(this: *const c_void) -> *mut c_void;
	fn tsSpatialTree_create_cDSTMRSuuuA(this: *mut c_void, device: *mut c_void, mode: SpatialTreeMode, sort: *mut c_void, size: u32, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsSpatialTree_create_cDSTFRSuuuA(this: *mut c_void, device: *mut c_void, flags: SpatialTreeFlags, sort: *mut c_void, size: u32, groups: u32, regions: u32, async_: *const *mut c_void) -> i32;
	fn tsSpatialTree_dispatch_CSTHBuuSTF(this: *mut c_void, compute: *mut c_void, hash: SpatialTreeHash, nodes: *mut c_void, offset: u32, size: u32, flags: SpatialTreeFlags) -> i32;
	fn tsSpatialTree_dispatch_CSTHBuupupSTF(this: *mut c_void, compute: *mut c_void, hash: SpatialTreeHash, nodes: *mut c_void, count: u32, offsets: *const u32, sizes: *const u32, flags: SpatialTreeFlags) -> i32;
	fn tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(this: *mut c_void, compute: *mut c_void, hash: SpatialTreeHash, nodes: *mut c_void, dispatch: *mut c_void, offset: u32, max_size: u32, flags: SpatialTreeFlags) -> i32;
	fn tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(this: *mut c_void, compute: *mut c_void, hash: SpatialTreeHash, nodes: *mut c_void, count: u32, dispatch: *mut c_void, offset: u32, max_size: u32, flags: SpatialTreeFlags) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpatialTreeNode {
	pub bound_min: Vector3f,
	pub is_enabled: u32,
	pub bound_max: Vector3f,
	pub data: u32,
	pub left: u32,
	pub right: u32,
	pub parent: u32,
	pub spatial: u32,
}
impl fmt::Display for SpatialTreeNode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("bound_min: {0}\n", self.bound_min);
		ret += &format!("is_enabled: {0}\n", self.is_enabled);
		ret += &format!("bound_max: {0}\n", self.bound_max);
		ret += &format!("data: {0}\n", self.data);
		ret += &format!("left: {0}\n", self.left);
		ret += &format!("right: {0}\n", self.right);
		ret += &format!("parent: {0}\n", self.parent);
		ret += &format!("spatial: {0}", self.spatial);
		write!(f, "{0}", ret)
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpatialTreeDispatchParameters {
	pub offset: u32,
	pub size: u32,
	pub padding_0: u32,
	pub padding_1: u32,
}
impl fmt::Display for SpatialTreeDispatchParameters {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = string::String::new();
		ret += &format!("offset: {0}\n", self.offset);
		ret += &format!("size: {0}\n", self.size);
		write!(f, "{0}", ret)
	}
}

// Tellusim::FourierTransform
pub struct FourierTransform {
	this: *mut c_void,
	owner: bool,
}
impl FourierTransform {
	pub fn null() -> FourierTransform { FourierTransform { this: ptr::null_mut(), owner: false } }
	pub fn new() -> FourierTransform { unsafe { FourierTransform { this: tsFourierTransform_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> FourierTransform { unsafe { FourierTransform { this: ptr, owner: tsFourierTransform_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> FourierTransform { unsafe { FourierTransform { this: tsFourierTransform_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: FourierTransform) -> bool { unsafe { tsFourierTransform_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> FourierTransform { unsafe { FourierTransform { this: tsFourierTransform_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsFourierTransform_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsFourierTransform_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsFourierTransform_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsFourierTransform_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsFourierTransform_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsFourierTransform_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsFourierTransform_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsFourierTransform_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsFourierTransform_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsFourierTransform_clear(self.this) } }
	pub fn is_created(&self, mode: FourierTransformMode) -> bool { unsafe { tsFourierTransform_isCreated_cFTM(self.this, mode) != 0 } }
	pub fn is_created_with_flags(&self, flags: FourierTransformFlags) -> bool { unsafe { tsFourierTransform_isCreated_cFTF(self.this, flags) != 0 } }
	pub fn max_width(&self) -> u32 { unsafe { tsFourierTransform_getMaxWidth(self.this) } }
	pub fn max_height(&self) -> u32 { unsafe { tsFourierTransform_getMaxHeight(self.this) } }
	pub fn aligned_size(&self, size: u32) -> u32 { unsafe { tsFourierTransform_getAlignedSize(self.this, size) } }
	pub fn create(&mut self, device: &Device, mode: FourierTransformMode, width: u32, height: u32) -> bool { unsafe { tsFourierTransform_create_cDFTMuuA(self.this, device.this, mode, width, height, ptr::null_mut()) != 0 } }
	pub fn create_with_async(&mut self, device: &Device, mode: FourierTransformMode, width: u32, height: u32, async_: Option<&Async>) -> bool { unsafe { tsFourierTransform_create_cDFTMuuA(self.this, device.this, mode, width, height, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: FourierTransformFlags, width: u32, height: u32) -> bool { unsafe { tsFourierTransform_create_cDFTFuuA(self.this, device.this, flags, width, height, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_async(&mut self, device: &Device, flags: FourierTransformFlags, width: u32, height: u32, async_: Option<&Async>) -> bool { unsafe { tsFourierTransform_create_cDFTFuuA(self.this, device.this, flags, width, height, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn dispatch_with_destslice(&self, compute: &mut Compute, mode: FourierTransformMode, op: FourierTransformOperation, dest: &mut Texture, src: &mut Texture, dest_slice: Option<&Slice>, src_slice: Option<&Slice>) -> bool {
		let dest_slice_ = Slice::default();
		let src_slice_ = Slice::default();
		unsafe { tsFourierTransform_dispatch_cCFTMFTOTTcScS(self.this, compute.this, mode, op, dest.this, src.this, match dest_slice { Some(dest_slice) => dest_slice, None => &dest_slice_ }, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch_with_srcslice(&self, compute: &mut Compute, mode: FourierTransformMode, op: FourierTransformOperation, dest: &mut Texture, src: &mut Texture, src_slice: Option<&Slice>) -> bool {
		let src_slice_ = Slice::default();
		unsafe { tsFourierTransform_dispatch_cCFTMFTOTTcS(self.this, compute.this, mode, op, dest.this, src.this, match src_slice { Some(src_slice) => src_slice, None => &src_slice_ }) != 0 }
	}
	pub fn dispatch(&self, compute: &mut Compute, mode: FourierTransformMode, op: FourierTransformOperation, dest: &mut Texture, src: &mut Texture) -> bool { unsafe { tsFourierTransform_dispatch_cCFTMFTOTT(self.this, compute.this, mode, op, dest.this, src.this) != 0 } }
}
impl Drop for FourierTransform {
	fn drop(&mut self) { if self.owner { unsafe { tsFourierTransform_delete(self.this) } } }
}
impl Clone for FourierTransform {
	fn clone(&self) -> FourierTransform { unsafe { FourierTransform { this: tsFourierTransform_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for FourierTransform { }
impl fmt::Display for FourierTransform {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::FourierTransform ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsFourierTransform_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsFourierTransform_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsFourierTransform_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsFourierTransform_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsFourierTransform_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsFourierTransform_new() -> *mut c_void;
	fn tsFourierTransform_delete(this: *mut c_void);
	fn tsFourierTransform_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsFourierTransform_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsFourierTransform_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsFourierTransform_clearPtr(this: *const c_void);
	fn tsFourierTransform_destroyPtr(this: *const c_void);
	fn tsFourierTransform_acquirePtr(this: *const c_void);
	fn tsFourierTransform_unacquirePtr(this: *const c_void);
	fn tsFourierTransform_isValidPtr(this: *const c_void) -> i32;
	fn tsFourierTransform_isOwnerPtr(this: *const c_void) -> i32;
	fn tsFourierTransform_isConstPtr(this: *const c_void) -> i32;
	fn tsFourierTransform_getCountPtr(this: *const c_void) -> u32;
	fn tsFourierTransform_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsFourierTransform_clear(this: *mut c_void);
	fn tsFourierTransform_isCreated_cFTM(this: *const c_void, mode: FourierTransformMode) -> i32;
	fn tsFourierTransform_isCreated_cFTF(this: *const c_void, flags: FourierTransformFlags) -> i32;
	fn tsFourierTransform_getMaxWidth(this: *const c_void) -> u32;
	fn tsFourierTransform_getMaxHeight(this: *const c_void) -> u32;
	fn tsFourierTransform_getAlignedSize(this: *const c_void, size: u32) -> u32;
	fn tsFourierTransform_create_cDFTMuuA(this: *mut c_void, device: *mut c_void, mode: FourierTransformMode, width: u32, height: u32, async_: *const *mut c_void) -> i32;
	fn tsFourierTransform_create_cDFTFuuA(this: *mut c_void, device: *mut c_void, flags: FourierTransformFlags, width: u32, height: u32, async_: *const *mut c_void) -> i32;
	fn tsFourierTransform_dispatch_cCFTMFTOTTcScS(this: *const c_void, compute: *mut c_void, mode: FourierTransformMode, op: FourierTransformOperation, dest: *mut c_void, src: *mut c_void, dest_slice: *const Slice, src_slice: *const Slice) -> i32;
	fn tsFourierTransform_dispatch_cCFTMFTOTTcS(this: *const c_void, compute: *mut c_void, mode: FourierTransformMode, op: FourierTransformOperation, dest: *mut c_void, src: *mut c_void, src_slice: *const Slice) -> i32;
	fn tsFourierTransform_dispatch_cCFTMFTOTT(this: *const c_void, compute: *mut c_void, mode: FourierTransformMode, op: FourierTransformOperation, dest: *mut c_void, src: *mut c_void) -> i32;
}

// Tellusim::TensorGraph
pub struct TensorGraph {
	this: *mut c_void,
	owner: bool,
}
impl TensorGraph {
	pub fn null() -> TensorGraph { TensorGraph { this: ptr::null_mut(), owner: false } }
	pub fn new() -> TensorGraph { unsafe { TensorGraph { this: tsTensorGraph_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> TensorGraph { unsafe { TensorGraph { this: ptr, owner: tsTensorGraph_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> TensorGraph { unsafe { TensorGraph { this: tsTensorGraph_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: TensorGraph) -> bool { unsafe { tsTensorGraph_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> TensorGraph { unsafe { TensorGraph { this: tsTensorGraph_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsTensorGraph_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsTensorGraph_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsTensorGraph_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsTensorGraph_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsTensorGraph_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsTensorGraph_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsTensorGraph_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsTensorGraph_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsTensorGraph_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn clear(&mut self) { unsafe { tsTensorGraph_clear(self.this) } }
	pub fn is_created(&self) -> bool { unsafe { tsTensorGraph_isCreated(self.this) != 0 } }
	pub fn create(&mut self, device: &Device) -> bool { unsafe { tsTensorGraph_create(self.this, device.this, TensorGraphFlags::All, TensorGraphMasks::All, ptr::null_mut()) != 0 } }
	pub fn create_with_flags(&mut self, device: &Device, flags: TensorGraphFlags) -> bool { unsafe { tsTensorGraph_create(self.this, device.this, flags, TensorGraphMasks::All, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_masks(&mut self, device: &Device, flags: TensorGraphFlags, masks: TensorGraphMasks) -> bool { unsafe { tsTensorGraph_create(self.this, device.this, flags, masks, ptr::null_mut()) != 0 } }
	pub fn create_with_flags_masks_async(&mut self, device: &Device, flags: TensorGraphFlags, masks: TensorGraphMasks, async_: Option<&Async>) -> bool { unsafe { tsTensorGraph_create(self.this, device.this, flags, masks, match async_ { Some(async_) => &async_.this, None => ptr::null() }) != 0 } }
	pub fn dispatch_with_op_dest(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &Tensor) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOcTTGF(self.this, compute.this, op, dest, TensorGraphFlags::None) != 0 } }
	pub fn dispatch_with_op_dest_flags(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &Tensor, flags: TensorGraphFlags) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOcTTGF(self.this, compute.this, op, dest, flags) != 0 } }
	pub fn dispatch_with_op_dest_mut_flags(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &mut Tensor, src_0: &Tensor, flags: TensorGraphFlags) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOTcTTGF(self.this, compute.this, op, dest, src_0, flags) != 0 } }
	pub fn dispatch_with_op_dest_mut_src1(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &mut Tensor, src_0: &Tensor, src_1: &Tensor) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOTcTcTTGF(self.this, compute.this, op, dest, src_0, src_1, TensorGraphFlags::None) != 0 } }
	pub fn dispatch_with_op_dest_mut_src1_flags(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &mut Tensor, src_0: &Tensor, src_1: &Tensor, flags: TensorGraphFlags) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOTcTcTTGF(self.this, compute.this, op, dest, src_0, src_1, flags) != 0 } }
	pub fn dispatch_with_op_dest_mut_src1_src2(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &mut Tensor, src_0: &Tensor, src_1: &Tensor, src_2: &Tensor) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOTcTcTcTTGF(self.this, compute.this, op, dest, src_0, src_1, src_2, TensorGraphFlags::None) != 0 } }
	pub fn dispatch_with_op_dest_mut_src1_src2_flags(&self, compute: &mut Compute, op: TensorGraphOperation, dest: &mut Tensor, src_0: &Tensor, src_1: &Tensor, src_2: &Tensor, flags: TensorGraphFlags) -> bool { unsafe { tsTensorGraph_dispatch_cCTGOTcTcTcTTGF(self.this, compute.this, op, dest, src_0, src_1, src_2, flags) != 0 } }
	pub fn dispatch_with_destct_region(&self, compute: &mut Compute, dest: &Tensor, src: &mut Texture, region: &Region) -> bool { unsafe { tsTensorGraph_dispatch_cCcTTcRcS(self.this, compute.this, dest, src.this, region, &Slice::default()) != 0 } }
	pub fn dispatch_with_destct_region_slice(&self, compute: &mut Compute, dest: &Tensor, src: &mut Texture, region: &Region, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsTensorGraph_dispatch_cCcTTcRcS(self.this, compute.this, dest, src.this, region, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn dispatch_with_destct(&self, compute: &mut Compute, dest: &Tensor, src: &mut Texture) -> bool { unsafe { tsTensorGraph_dispatch_cCcTTcS(self.this, compute.this, dest, src.this, &Slice::default()) != 0 } }
	pub fn dispatch_with_destct_slice(&self, compute: &mut Compute, dest: &Tensor, src: &mut Texture, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsTensorGraph_dispatch_cCcTTcS(self.this, compute.this, dest, src.this, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn dispatch_with_destt_region(&self, compute: &mut Compute, dest: &mut Texture, src: &Tensor, region: &Region) -> bool { unsafe { tsTensorGraph_dispatch_cCTcTcRcS(self.this, compute.this, dest.this, src, region, &Slice::default()) != 0 } }
	pub fn dispatch_with_destt_region_slice(&self, compute: &mut Compute, dest: &mut Texture, src: &Tensor, region: &Region, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsTensorGraph_dispatch_cCTcTcRcS(self.this, compute.this, dest.this, src, region, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
	pub fn dispatch_with_destt(&self, compute: &mut Compute, dest: &mut Texture, src: &Tensor) -> bool { unsafe { tsTensorGraph_dispatch_cCTcTcS(self.this, compute.this, dest.this, src, &Slice::default()) != 0 } }
	pub fn dispatch_with_destt_slice(&self, compute: &mut Compute, dest: &mut Texture, src: &Tensor, slice: Option<&Slice>) -> bool {
		let slice_ = Slice::default();
		unsafe { tsTensorGraph_dispatch_cCTcTcS(self.this, compute.this, dest.this, src, match slice { Some(slice) => slice, None => &slice_ }) != 0 }
	}
}
impl Drop for TensorGraph {
	fn drop(&mut self) { if self.owner { unsafe { tsTensorGraph_delete(self.this) } } }
}
impl Clone for TensorGraph {
	fn clone(&self) -> TensorGraph { unsafe { TensorGraph { this: tsTensorGraph_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for TensorGraph { }
impl fmt::Display for TensorGraph {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::TensorGraph ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsTensorGraph_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsTensorGraph_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsTensorGraph_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsTensorGraph_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsTensorGraph_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsTensorGraph_new() -> *mut c_void;
	fn tsTensorGraph_delete(this: *mut c_void);
	fn tsTensorGraph_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsTensorGraph_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsTensorGraph_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsTensorGraph_clearPtr(this: *const c_void);
	fn tsTensorGraph_destroyPtr(this: *const c_void);
	fn tsTensorGraph_acquirePtr(this: *const c_void);
	fn tsTensorGraph_unacquirePtr(this: *const c_void);
	fn tsTensorGraph_isValidPtr(this: *const c_void) -> i32;
	fn tsTensorGraph_isOwnerPtr(this: *const c_void) -> i32;
	fn tsTensorGraph_isConstPtr(this: *const c_void) -> i32;
	fn tsTensorGraph_getCountPtr(this: *const c_void) -> u32;
	fn tsTensorGraph_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsTensorGraph_clear(this: *mut c_void);
	fn tsTensorGraph_isCreated(this: *const c_void) -> i32;
	fn tsTensorGraph_create(this: *mut c_void, device: *mut c_void, flags: TensorGraphFlags, masks: TensorGraphMasks, async_: *const *mut c_void) -> i32;
	fn tsTensorGraph_dispatch_cCTGOcTTGF(this: *const c_void, compute: *mut c_void, op: TensorGraphOperation, dest: *const Tensor, flags: TensorGraphFlags) -> i32;
	fn tsTensorGraph_dispatch_cCTGOTcTTGF(this: *const c_void, compute: *mut c_void, op: TensorGraphOperation, dest: *mut Tensor, src_0: *const Tensor, flags: TensorGraphFlags) -> i32;
	fn tsTensorGraph_dispatch_cCTGOTcTcTTGF(this: *const c_void, compute: *mut c_void, op: TensorGraphOperation, dest: *mut Tensor, src_0: *const Tensor, src_1: *const Tensor, flags: TensorGraphFlags) -> i32;
	fn tsTensorGraph_dispatch_cCTGOTcTcTcTTGF(this: *const c_void, compute: *mut c_void, op: TensorGraphOperation, dest: *mut Tensor, src_0: *const Tensor, src_1: *const Tensor, src_2: *const Tensor, flags: TensorGraphFlags) -> i32;
	fn tsTensorGraph_dispatch_cCcTTcRcS(this: *const c_void, compute: *mut c_void, dest: *const Tensor, src: *mut c_void, region: *const Region, slice: *const Slice) -> i32;
	fn tsTensorGraph_dispatch_cCcTTcS(this: *const c_void, compute: *mut c_void, dest: *const Tensor, src: *mut c_void, slice: *const Slice) -> i32;
	fn tsTensorGraph_dispatch_cCTcTcRcS(this: *const c_void, compute: *mut c_void, dest: *mut c_void, src: *const Tensor, region: *const Region, slice: *const Slice) -> i32;
	fn tsTensorGraph_dispatch_cCTcTcS(this: *const c_void, compute: *mut c_void, dest: *mut c_void, src: *const Tensor, slice: *const Slice) -> i32;
}

// Tellusim::Controller
pub struct Controller {
	this: *mut c_void,
	owner: bool,
}
type ControllerButtonPressedCallback = unsafe extern "C" fn(controller: *mut c_void, button: ControllerButton, data_: *mut c_void);
unsafe extern "C" fn controller_button_pressed_callback_func<Func>(controller: *mut c_void, button: ControllerButton, data_: *mut c_void) where Func: FnMut(Controller, ControllerButton) {
	let func = &mut *(data_ as *mut Func);
	let controller_ = Controller::new_ptr(controller);
	func(controller_, button)
}
type ControllerButtonReleasedCallback = unsafe extern "C" fn(controller: *mut c_void, button: ControllerButton, data_: *mut c_void);
unsafe extern "C" fn controller_button_released_callback_func<Func>(controller: *mut c_void, button: ControllerButton, data_: *mut c_void) where Func: FnMut(Controller, ControllerButton) {
	let func = &mut *(data_ as *mut Func);
	let controller_ = Controller::new_ptr(controller);
	func(controller_, button)
}
type ControllerConnectedCallback = unsafe extern "C" fn(controller: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn controller_connected_callback_func<Func>(controller: *mut c_void, data_: *mut c_void) where Func: FnMut(Controller) {
	let func = &mut *(data_ as *mut Func);
	let controller_ = Controller::new_ptr(controller);
	func(controller_)
}
type ControllerDisconnectedCallback = unsafe extern "C" fn(controller: *mut c_void, data_: *mut c_void);
unsafe extern "C" fn controller_disconnected_callback_func<Func>(controller: *mut c_void, data_: *mut c_void) where Func: FnMut(Controller) {
	let func = &mut *(data_ as *mut Func);
	let controller_ = Controller::new_ptr(controller);
	func(controller_)
}
impl Controller {
	pub fn null() -> Controller { Controller { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Controller { unsafe { Controller { this: tsController_new(), owner: true } } }
	pub fn new_with_index(index: u32) -> Controller { unsafe { Controller { this: tsController_new_u(index), owner: true } } }
	pub fn new_with_type(type_: ControllerType) -> Controller { unsafe { Controller { this: tsController_new_CTu(type_, MAXU32), owner: true } } }
	pub fn new_with_type_index(type_: ControllerType, index: u32) -> Controller { unsafe { Controller { this: tsController_new_CTu(type_, index), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Controller { unsafe { Controller { this: ptr, owner: tsController_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Controller { unsafe { Controller { this: tsController_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Controller) -> bool { unsafe { tsController_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Controller { unsafe { Controller { this: tsController_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsController_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsController_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsController_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsController_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsController_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsController_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsController_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsController_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsController_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn num_controllers() -> u32 { unsafe { tsController_getNumControllers() } }
	pub fn find_controller(name: &str) -> u32 {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_findController(name_.as_ptr()) }
	}
	pub fn controller(index: u32) -> Controller { unsafe { Controller::new_ptr(tsController_getController(index)) } }
	pub fn update() { unsafe { tsController_update() } }
	pub fn set_type(&mut self, type_: ControllerType) { unsafe { tsController_setType(self.this, type_) } }
	pub fn type_(&self) -> ControllerType { unsafe { tsController_getType(self.this) } }
	pub fn type_name_with_type(type_: ControllerType) -> string::String { unsafe { get_cstring(tsController_getTypeName_CT(type_)) } }
	pub fn type_name(&self) -> string::String { unsafe { get_cstring(tsController_getTypeName_c(self.this)) } }
	pub fn is_unknown(&self) -> bool { unsafe { tsController_isUnknown(self.this) != 0 } }
	pub fn is_joystick(&self) -> bool { unsafe { tsController_isJoystick(self.this) != 0 } }
	pub fn is_game_pad(&self) -> bool { unsafe { tsController_isGamePad(self.this) != 0 } }
	pub fn is_wheel(&self) -> bool { unsafe { tsController_isWheel(self.this) != 0 } }
	pub fn set_index(&mut self, index: u32) { unsafe { tsController_setIndex(self.this, index) } }
	pub fn index(&self) -> u32 { unsafe { tsController_getIndex(self.this) } }
	pub fn set_name(&mut self, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_setName(self.this, name_.as_ptr()) }
	}
	pub fn name(&self) -> string::String { unsafe { get_string(tsController_getName(self.this)) } }
	pub fn set_model(&mut self, model: &str) {
		let model_ = CString::new(model).unwrap();
		unsafe { tsController_setModel(self.this, model_.as_ptr()) }
	}
	pub fn model(&self) -> string::String { unsafe { get_string(tsController_getModel(self.this)) } }
	pub fn is_connected(&self) -> bool { unsafe { tsController_isConnected(self.this) != 0 } }
	pub fn was_connected(&self) -> bool { unsafe { tsController_wasConnected(self.this) != 0 } }
	pub fn connect(&mut self) -> bool { unsafe { tsController_connect(self.this, ptr::null_mut()) != 0 } }
	pub fn connect_with_name(&mut self, name: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_connect(self.this, name_.as_ptr()) != 0 }
	}
	pub fn release(&mut self) { unsafe { tsController_release(self.this) } }
	pub fn set_stick_name(&mut self, stick: ControllerStick, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_setStickName(self.this, stick, name_.as_ptr()) }
	}
	pub fn stick_name(&self, stick: ControllerStick) -> string::String { unsafe { get_string(tsController_getStickName(self.this, stick)) } }
	pub fn find_stick(&self, name: &str) -> ControllerStick {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_findStick(self.this, name_.as_ptr()) }
	}
	pub fn set_stick(&mut self, stick: ControllerStick, x: f32, y: f32) { unsafe { tsController_setStick(self.this, stick, x, y) } }
	pub fn stick_x(&self, stick: ControllerStick) -> f32 { unsafe { tsController_getStickX(self.this, stick) } }
	pub fn stick_y(&self, stick: ControllerStick) -> f32 { unsafe { tsController_getStickY(self.this, stick) } }
	pub fn set_axis_name(&mut self, axis: ControllerAxis, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_setAxisName(self.this, axis, name_.as_ptr()) }
	}
	pub fn axis_name(&self, axis: ControllerAxis) -> string::String { unsafe { get_string(tsController_getAxisName(self.this, axis)) } }
	pub fn find_axis(&self, name: &str) -> ControllerAxis {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_findAxis(self.this, name_.as_ptr()) }
	}
	pub fn set_axis(&mut self, axis: ControllerAxis, value: f32) { unsafe { tsController_setAxis(self.this, axis, value) } }
	pub fn axis(&self, axis: ControllerAxis) -> f32 { unsafe { tsController_getAxis(self.this, axis) } }
	pub fn set_button_name(&mut self, button: ControllerButton, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_setButtonName(self.this, button, name_.as_ptr()) }
	}
	pub fn button_name(&self, button: ControllerButton) -> string::String { unsafe { get_string(tsController_getButtonName(self.this, button)) } }
	pub fn find_button(&self, name: &str) -> ControllerButton {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_findButton(self.this, name_.as_ptr()) }
	}
	pub fn set_button(&mut self, button: ControllerButton, value: bool) { unsafe { tsController_setButton(self.this, button, if value {1} else {0}) } }
	pub fn button(&self, button: ControllerButton) -> bool { unsafe { tsController_getButton(self.this, button, 0) != 0 } }
	pub fn button_with_clear(&self, button: ControllerButton, clear: bool) -> bool { unsafe { tsController_getButton(self.this, button, if clear {1} else {0}) != 0 } }
	pub fn set_button_value(&mut self, button: ControllerButton, value: f32) { unsafe { tsController_setButtonValue(self.this, button, value) } }
	pub fn button_value(&self, button: ControllerButton) -> f32 { unsafe { tsController_getButtonValue(self.this, button) } }
	pub fn set_motor_name(&mut self, motor: ControllerMotor, name: &str) {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_setMotorName(self.this, motor, name_.as_ptr()) }
	}
	pub fn motor_name(&self, motor: ControllerMotor) -> string::String { unsafe { get_string(tsController_getMotorName(self.this, motor)) } }
	pub fn find_motor(&self, name: &str) -> ControllerMotor {
		let name_ = CString::new(name).unwrap();
		unsafe { tsController_findMotor(self.this, name_.as_ptr()) }
	}
	pub fn set_motor(&mut self, motor: ControllerMotor, value: f32) { unsafe { tsController_setMotor(self.this, motor, value) } }
	pub fn motor(&self, motor: ControllerMotor) -> f32 { unsafe { tsController_getMotor(self.this, motor) } }
	pub fn set_button_pressed_callback<Func>(&mut self, func: Func) where Func: FnMut(Controller, ControllerButton) {
		let func = Box::leak(Box::new(func));
		let func_ = controller_button_pressed_callback_func::<Func>;
		unsafe { tsController_setButtonPressedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_button_released_callback<Func>(&mut self, func: Func) where Func: FnMut(Controller, ControllerButton) {
		let func = Box::leak(Box::new(func));
		let func_ = controller_button_released_callback_func::<Func>;
		unsafe { tsController_setButtonReleasedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_connected_callback<Func>(&mut self, func: Func) where Func: FnMut(Controller) {
		let func = Box::leak(Box::new(func));
		let func_ = controller_connected_callback_func::<Func>;
		unsafe { tsController_setConnectedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
	pub fn set_disconnected_callback<Func>(&mut self, func: Func) where Func: FnMut(Controller) {
		let func = Box::leak(Box::new(func));
		let func_ = controller_disconnected_callback_func::<Func>;
		unsafe { tsController_setDisconnectedCallback(self.this, func_, func as *mut _ as *mut c_void) }
	}
}
impl Drop for Controller {
	fn drop(&mut self) { if self.owner { unsafe { tsController_delete(self.this) } } }
}
impl Clone for Controller {
	fn clone(&self) -> Controller { unsafe { Controller { this: tsController_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Controller { }
impl fmt::Display for Controller {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Controller ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsController_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsController_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsController_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsController_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsController_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsController_new() -> *mut c_void;
	fn tsController_new_u(index: u32) -> *mut c_void;
	fn tsController_new_CTu(type_: ControllerType, index: u32) -> *mut c_void;
	fn tsController_delete(this: *mut c_void);
	fn tsController_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsController_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsController_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsController_clearPtr(this: *const c_void);
	fn tsController_destroyPtr(this: *const c_void);
	fn tsController_acquirePtr(this: *const c_void);
	fn tsController_unacquirePtr(this: *const c_void);
	fn tsController_isValidPtr(this: *const c_void) -> i32;
	fn tsController_isOwnerPtr(this: *const c_void) -> i32;
	fn tsController_isConstPtr(this: *const c_void) -> i32;
	fn tsController_getCountPtr(this: *const c_void) -> u32;
	fn tsController_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsController_getNumControllers() -> u32;
	fn tsController_findController(name: *const c_char) -> u32;
	fn tsController_getController(index: u32) -> *mut c_void;
	fn tsController_update();
	fn tsController_setType(this: *mut c_void, type_: ControllerType);
	fn tsController_getType(this: *const c_void) -> ControllerType;
	fn tsController_getTypeName_CT(type_: ControllerType) -> *const c_char;
	fn tsController_getTypeName_c(this: *const c_void) -> *const c_char;
	fn tsController_isUnknown(this: *const c_void) -> i32;
	fn tsController_isJoystick(this: *const c_void) -> i32;
	fn tsController_isGamePad(this: *const c_void) -> i32;
	fn tsController_isWheel(this: *const c_void) -> i32;
	fn tsController_setIndex(this: *mut c_void, index: u32);
	fn tsController_getIndex(this: *const c_void) -> u32;
	fn tsController_setName(this: *mut c_void, name: *const c_char);
	fn tsController_getName(this: *const c_void) -> *mut c_void;
	fn tsController_setModel(this: *mut c_void, model: *const c_char);
	fn tsController_getModel(this: *const c_void) -> *mut c_void;
	fn tsController_isConnected(this: *const c_void) -> i32;
	fn tsController_wasConnected(this: *const c_void) -> i32;
	fn tsController_connect(this: *mut c_void, name: *const c_char) -> i32;
	fn tsController_release(this: *mut c_void);
	fn tsController_setStickName(this: *mut c_void, stick: ControllerStick, name: *const c_char);
	fn tsController_getStickName(this: *const c_void, stick: ControllerStick) -> *mut c_void;
	fn tsController_findStick(this: *const c_void, name: *const c_char) -> ControllerStick;
	fn tsController_setStick(this: *mut c_void, stick: ControllerStick, x: f32, y: f32);
	fn tsController_getStickX(this: *const c_void, stick: ControllerStick) -> f32;
	fn tsController_getStickY(this: *const c_void, stick: ControllerStick) -> f32;
	fn tsController_setAxisName(this: *mut c_void, axis: ControllerAxis, name: *const c_char);
	fn tsController_getAxisName(this: *const c_void, axis: ControllerAxis) -> *mut c_void;
	fn tsController_findAxis(this: *const c_void, name: *const c_char) -> ControllerAxis;
	fn tsController_setAxis(this: *mut c_void, axis: ControllerAxis, value: f32);
	fn tsController_getAxis(this: *const c_void, axis: ControllerAxis) -> f32;
	fn tsController_setButtonName(this: *mut c_void, button: ControllerButton, name: *const c_char);
	fn tsController_getButtonName(this: *const c_void, button: ControllerButton) -> *mut c_void;
	fn tsController_findButton(this: *const c_void, name: *const c_char) -> ControllerButton;
	fn tsController_setButton(this: *mut c_void, button: ControllerButton, value: i32);
	fn tsController_getButton(this: *const c_void, button: ControllerButton, clear: i32) -> i32;
	fn tsController_setButtonValue(this: *mut c_void, button: ControllerButton, value: f32);
	fn tsController_getButtonValue(this: *const c_void, button: ControllerButton) -> f32;
	fn tsController_setMotorName(this: *mut c_void, motor: ControllerMotor, name: *const c_char);
	fn tsController_getMotorName(this: *const c_void, motor: ControllerMotor) -> *mut c_void;
	fn tsController_findMotor(this: *const c_void, name: *const c_char) -> ControllerMotor;
	fn tsController_setMotor(this: *mut c_void, motor: ControllerMotor, value: f32);
	fn tsController_getMotor(this: *const c_void, motor: ControllerMotor) -> f32;
	fn tsController_setButtonPressedCallback(this: *mut c_void, func: ControllerButtonPressedCallback, data_: *mut c_void);
	fn tsController_setButtonReleasedCallback(this: *mut c_void, func: ControllerButtonReleasedCallback, data_: *mut c_void);
	fn tsController_setConnectedCallback(this: *mut c_void, func: ControllerConnectedCallback, data_: *mut c_void);
	fn tsController_setDisconnectedCallback(this: *mut c_void, func: ControllerDisconnectedCallback, data_: *mut c_void);
}

// Tellusim::Desktop
pub struct Desktop {
	this: *mut c_void,
	owner: bool,
}
impl Desktop {
	pub fn null() -> Desktop { Desktop { this: ptr::null_mut(), owner: false } }
	pub fn new() -> Desktop { unsafe { Desktop { this: tsDesktop_new(), owner: true } } }
	pub fn new_ptr(ptr: *mut c_void) -> Desktop { unsafe { Desktop { this: ptr, owner: tsDesktop_isOwnerPtr(ptr) != 0 } } }
	pub fn copy_ptr(&self) -> Desktop { unsafe { Desktop { this: tsDesktop_copyPtr(self.this), owner: true } } }
	pub fn equal_ptr(&self, ptr: Desktop) -> bool { unsafe { tsDesktop_equalPtr(self.this, ptr.this) != 0 } }
	pub fn clone_ptr(&self) -> Desktop { unsafe { Desktop { this: tsDesktop_clonePtr(self.this), owner: true } } }
	pub fn clear_ptr(&mut self) { unsafe { tsDesktop_clearPtr(self.this) } }
	pub fn destroy_ptr(&mut self) { unsafe { tsDesktop_destroyPtr(self.this) } }
	pub fn acquire_ptr(&mut self) { unsafe { tsDesktop_acquirePtr(self.this) } }
	pub fn unacquire_ptr(&mut self) { unsafe { tsDesktop_unacquirePtr(self.this) } }
	pub fn is_valid_ptr(&self) -> bool { unsafe { tsDesktop_isValidPtr(self.this) != 0 } }
	pub fn is_owner_ptr(&self) -> bool { unsafe { tsDesktop_isOwnerPtr(self.this) != 0 } }
	pub fn is_const_ptr(&self) -> bool { unsafe { tsDesktop_isConstPtr(self.this) != 0 } }
	pub fn count_ptr(&self) -> u32 { unsafe { tsDesktop_getCountPtr(self.this) } }
	pub fn internal_ptr(&self) -> *const c_void { unsafe { tsDesktop_getInternalPtr(self.this) } }
	pub fn this_ptr(&self) -> *mut c_void { self.this }
	pub fn update(&mut self) -> bool { unsafe { tsDesktop_update(self.this) != 0 } }
	pub fn width(&self) -> u32 { unsafe { tsDesktop_getWidth_c(self.this) } }
	pub fn height(&self) -> u32 { unsafe { tsDesktop_getHeight_c(self.this) } }
	pub fn position_x(&self) -> i32 { unsafe { tsDesktop_getPositionX_c(self.this) } }
	pub fn position_y(&self) -> i32 { unsafe { tsDesktop_getPositionY_c(self.this) } }
	pub fn scale(&self) -> f32 { unsafe { tsDesktop_getScale(self.this) } }
	pub fn num_screens(&self) -> u32 { unsafe { tsDesktop_getNumScreens(self.this) } }
	pub fn screen_name(&self, index: u32) -> string::String { unsafe { get_string(tsDesktop_getScreenName(self.this, index)) } }
	pub fn screen_device(&self, index: u32) -> string::String { unsafe { get_string(tsDesktop_getScreenDevice(self.this, index)) } }
	pub fn screen_width(&self, index: u32) -> u32 { unsafe { tsDesktop_getScreenWidth(self.this, index) } }
	pub fn screen_height(&self, index: u32) -> u32 { unsafe { tsDesktop_getScreenHeight(self.this, index) } }
	pub fn screen_position_x(&self, index: u32) -> i32 { unsafe { tsDesktop_getScreenPositionX(self.this, index) } }
	pub fn screen_position_y(&self, index: u32) -> i32 { unsafe { tsDesktop_getScreenPositionY(self.this, index) } }
	pub fn screen_frequency(&self, index: u32) -> u32 { unsafe { tsDesktop_getScreenFrequency(self.this, index) } }
	pub fn num_modes(&self, index: u32) -> u32 { unsafe { tsDesktop_getNumModes(self.this, index) } }
	pub fn mode_width(&self, index: u32, mode: u32) -> u32 { unsafe { tsDesktop_getModeWidth(self.this, index, mode) } }
	pub fn mode_height(&self, index: u32, mode: u32) -> u32 { unsafe { tsDesktop_getModeHeight(self.this, index, mode) } }
	pub fn mode_index(&self, index: u32, width: u32, height: u32) -> u32 { unsafe { tsDesktop_getModeIndex(self.this, index, width, height) } }
	pub fn set_mode(&mut self, index: u32, width: u32, height: u32) -> bool { unsafe { tsDesktop_setMode(self.this, index, width, height) != 0 } }
	pub fn restore_mode(&mut self, index: u32) -> bool { unsafe { tsDesktop_restoreMode(self.this, index) != 0 } }
	pub fn width_with_index(&self, index: u32) -> u32 { unsafe { tsDesktop_getWidth_cu(self.this, index) } }
	pub fn height_with_index(&self, index: u32) -> u32 { unsafe { tsDesktop_getHeight_cu(self.this, index) } }
	pub fn position_x_with_index(&self, index: u32) -> i32 { unsafe { tsDesktop_getPositionX_cu(self.this, index) } }
	pub fn position_y_with_index(&self, index: u32) -> i32 { unsafe { tsDesktop_getPositionY_cu(self.this, index) } }
	pub fn screen_index(&self, x: i32, y: i32) -> u32 { unsafe { tsDesktop_getScreenIndex(self.this, x, y) } }
	pub fn set_mouse(&self, x: i32, y: i32) -> bool { unsafe { tsDesktop_setMouse(self.this, x, y) != 0 } }
	pub fn mouse(&self, x: &mut i32, y: &mut i32) -> bool { unsafe { tsDesktop_getMouse(self.this, x, y) != 0 } }
}
impl Drop for Desktop {
	fn drop(&mut self) { if self.owner { unsafe { tsDesktop_delete(self.this) } } }
}
impl Clone for Desktop {
	fn clone(&self) -> Desktop { unsafe { Desktop { this: tsDesktop_clonePtr(self.this), owner: true } } }
}
unsafe impl Send for Desktop { }
impl fmt::Display for Desktop {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let mut ret = "tellusim::Desktop ".to_string();
		unsafe {
			ret += &format!("valid: {0}", tsDesktop_isValidPtr(self.this) != 0);
			ret += &format!("; owner: {0}", tsDesktop_isOwnerPtr(self.this) != 0);
			ret += &format!("; const: {0}", tsDesktop_isConstPtr(self.this) != 0);
			ret += &format!("; count: {0}", tsDesktop_getCountPtr(self.this));
			ret += &format!("; internal: 0x{0:8x}; ", tsDesktop_getInternalPtr(self.this) as u64);
		}
		ret += &format!("this: 0x{0:8x}", self.this as u64);
		ret += &format!("; owner: {0}", self.owner);
		write!(f, "{0}", ret)
	}
}
extern "C" {
	fn tsDesktop_new() -> *mut c_void;
	fn tsDesktop_delete(this: *mut c_void);
	fn tsDesktop_equalPtr(this: *const c_void, ptr: *const c_void) -> i32;
	fn tsDesktop_copyPtr(this: *const c_void) -> *mut c_void;
	fn tsDesktop_clonePtr(this: *const c_void) -> *mut c_void;
	fn tsDesktop_clearPtr(this: *const c_void);
	fn tsDesktop_destroyPtr(this: *const c_void);
	fn tsDesktop_acquirePtr(this: *const c_void);
	fn tsDesktop_unacquirePtr(this: *const c_void);
	fn tsDesktop_isValidPtr(this: *const c_void) -> i32;
	fn tsDesktop_isOwnerPtr(this: *const c_void) -> i32;
	fn tsDesktop_isConstPtr(this: *const c_void) -> i32;
	fn tsDesktop_getCountPtr(this: *const c_void) -> u32;
	fn tsDesktop_getInternalPtr(this: *const c_void) -> *mut c_void;
	fn tsDesktop_update(this: *mut c_void) -> i32;
	fn tsDesktop_getWidth_c(this: *const c_void) -> u32;
	fn tsDesktop_getHeight_c(this: *const c_void) -> u32;
	fn tsDesktop_getPositionX_c(this: *const c_void) -> i32;
	fn tsDesktop_getPositionY_c(this: *const c_void) -> i32;
	fn tsDesktop_getScale(this: *const c_void) -> f32;
	fn tsDesktop_getNumScreens(this: *const c_void) -> u32;
	fn tsDesktop_getScreenName(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDesktop_getScreenDevice(this: *const c_void, index: u32) -> *mut c_void;
	fn tsDesktop_getScreenWidth(this: *const c_void, index: u32) -> u32;
	fn tsDesktop_getScreenHeight(this: *const c_void, index: u32) -> u32;
	fn tsDesktop_getScreenPositionX(this: *const c_void, index: u32) -> i32;
	fn tsDesktop_getScreenPositionY(this: *const c_void, index: u32) -> i32;
	fn tsDesktop_getScreenFrequency(this: *const c_void, index: u32) -> u32;
	fn tsDesktop_getNumModes(this: *const c_void, index: u32) -> u32;
	fn tsDesktop_getModeWidth(this: *const c_void, index: u32, mode: u32) -> u32;
	fn tsDesktop_getModeHeight(this: *const c_void, index: u32, mode: u32) -> u32;
	fn tsDesktop_getModeIndex(this: *const c_void, index: u32, width: u32, height: u32) -> u32;
	fn tsDesktop_setMode(this: *mut c_void, index: u32, width: u32, height: u32) -> i32;
	fn tsDesktop_restoreMode(this: *mut c_void, index: u32) -> i32;
	fn tsDesktop_getWidth_cu(this: *const c_void, index: u32) -> u32;
	fn tsDesktop_getHeight_cu(this: *const c_void, index: u32) -> u32;
	fn tsDesktop_getPositionX_cu(this: *const c_void, index: u32) -> i32;
	fn tsDesktop_getPositionY_cu(this: *const c_void, index: u32) -> i32;
	fn tsDesktop_getScreenIndex(this: *const c_void, x: i32, y: i32) -> u32;
	fn tsDesktop_setMouse(this: *const c_void, x: i32, y: i32) -> i32;
	fn tsDesktop_getMouse(this: *const c_void, x: &mut i32, y: &mut i32) -> i32;
}

// Tellusim
pub fn platform_name(platform: Platform) -> string::String { unsafe { get_cstring(ts_getPlatformName(platform)) } }
pub fn find_platform_name(name: &str) -> Platform {
	let name_ = CString::new(name).unwrap();
	unsafe { ts_findPlatformName(name_.as_ptr()) }
}
pub fn is_platform_available(platform: Platform) -> bool { unsafe { ts_isPlatformAvailable(platform) != 0 } }
pub fn format_name(format: Format) -> string::String { unsafe { get_cstring(ts_getFormatName(format)) } }
pub fn find_format_name(name: &str) -> Format {
	let name_ = CString::new(name).unwrap();
	unsafe { ts_findFormatName(name_.as_ptr()) }
}
pub fn glsl_format_name(format: Format) -> string::String { unsafe { get_cstring(ts_getGLSLFormatName(format)) } }
pub fn find_glsl_format_name(name: &str) -> Format {
	let name_ = CString::new(name).unwrap();
	unsafe { ts_findGLSLFormatName(name_.as_ptr()) }
}
pub fn is_color_format(format: Format) -> bool { unsafe { ts_isColorFormat(format) != 0 } }
pub fn is_depth_format(format: Format) -> bool { unsafe { ts_isDepthFormat(format) != 0 } }
pub fn is_pixel_format(format: Format) -> bool { unsafe { ts_isPixelFormat(format) != 0 } }
pub fn is_plain_format(format: Format) -> bool { unsafe { ts_isPlainFormat(format) != 0 } }
pub fn is_mixed_format(format: Format) -> bool { unsafe { ts_isMixedFormat(format) != 0 } }
pub fn is_block_format(format: Format) -> bool { unsafe { ts_isBlockFormat(format) != 0 } }
pub fn is_stencil_format(format: Format) -> bool { unsafe { ts_isStencilFormat(format) != 0 } }
pub fn to_pixel_format(format: Format) -> Format { unsafe { ts_toPixelFormat(format) } }
pub fn is_norm_format(format: Format) -> bool { unsafe { ts_isNormFormat(format) != 0 } }
pub fn is_srgb_format(format: Format) -> bool { unsafe { ts_isSRGBFormat(format) != 0 } }
pub fn is_signed_format(format: Format) -> bool { unsafe { ts_isSignedFormat(format) != 0 } }
pub fn is_unsigned_format(format: Format) -> bool { unsafe { ts_isUnsignedFormat(format) != 0 } }
pub fn is_integer_format(format: Format) -> bool { unsafe { ts_isIntegerFormat(format) != 0 } }
pub fn is_float_format(format: Format) -> bool { unsafe { ts_isFloatFormat(format) != 0 } }
pub fn to_norm_format(format: Format) -> Format { unsafe { ts_toNormFormat(format) } }
pub fn to_srgb_format(format: Format) -> Format { unsafe { ts_toSRGBFormat(format) } }
pub fn to_signed_format(format: Format) -> Format { unsafe { ts_toSignedFormat(format) } }
pub fn to_unsigned_format(format: Format) -> Format { unsafe { ts_toUnsignedFormat(format) } }
pub fn to_float_format(format: Format) -> Format { unsafe { ts_toFloatFormat(format) } }
pub fn isi8_format(format: Format) -> bool { unsafe { ts_isi8Format(format) != 0 } }
pub fn isu8_format(format: Format) -> bool { unsafe { ts_isu8Format(format) != 0 } }
pub fn is8_bit_format(format: Format) -> bool { unsafe { ts_is8BitFormat(format) != 0 } }
pub fn to8_bit_format(format: Format) -> Format { unsafe { ts_to8BitFormat(format) } }
pub fn isi16_format(format: Format) -> bool { unsafe { ts_isi16Format(format) != 0 } }
pub fn isu16_format(format: Format) -> bool { unsafe { ts_isu16Format(format) != 0 } }
pub fn isf16_format(format: Format) -> bool { unsafe { ts_isf16Format(format) != 0 } }
pub fn is16_bit_format(format: Format) -> bool { unsafe { ts_is16BitFormat(format) != 0 } }
pub fn to16_bit_format(format: Format) -> Format { unsafe { ts_to16BitFormat(format) } }
pub fn isi32_format(format: Format) -> bool { unsafe { ts_isi32Format(format) != 0 } }
pub fn isu32_format(format: Format) -> bool { unsafe { ts_isu32Format(format) != 0 } }
pub fn isf32_format(format: Format) -> bool { unsafe { ts_isf32Format(format) != 0 } }
pub fn is32_bit_format(format: Format) -> bool { unsafe { ts_is32BitFormat(format) != 0 } }
pub fn to32_bit_format(format: Format) -> Format { unsafe { ts_to32BitFormat(format) } }
pub fn isi64_format(format: Format) -> bool { unsafe { ts_isi64Format(format) != 0 } }
pub fn isu64_format(format: Format) -> bool { unsafe { ts_isu64Format(format) != 0 } }
pub fn isf64_format(format: Format) -> bool { unsafe { ts_isf64Format(format) != 0 } }
pub fn is64_bit_format(format: Format) -> bool { unsafe { ts_is64BitFormat(format) != 0 } }
pub fn is_bc15_format(format: Format) -> bool { unsafe { ts_isBC15Format(format) != 0 } }
pub fn is_bc67_format(format: Format) -> bool { unsafe { ts_isBC67Format(format) != 0 } }
pub fn is_etc2_format(format: Format) -> bool { unsafe { ts_isETC2Format(format) != 0 } }
pub fn is_astc_format(format: Format) -> bool { unsafe { ts_isASTCFormat(format) != 0 } }
pub fn format_components(format: Format) -> u32 { unsafe { ts_getFormatComponents(format) } }
pub fn to_format_components(format: Format, components: u32) -> Format { unsafe { ts_toFormatComponents(format, components) } }
pub fn format_pixel_size(format: Format) -> u32 { unsafe { ts_getFormatPixelSize(format) } }
pub fn format_block_size(format: Format) -> u32 { unsafe { ts_getFormatBlockSize(format) } }
pub fn format_block_width(format: Format) -> u32 { unsafe { ts_getFormatBlockWidth(format) } }
pub fn format_block_height(format: Format) -> u32 { unsafe { ts_getFormatBlockHeight(format) } }
pub fn pixel_format_value(format: Format, value: *mut f32, src: *const c_void) -> u32 { unsafe { ts_getPixelFormatValue(format, value, src, 0) } }
pub fn pixel_format_value_with_stride(format: Format, value: *mut f32, src: *const c_void, stride: u32) -> u32 { unsafe { ts_getPixelFormatValue(format, value, src, stride) } }
pub fn set_pixel_format_value(format: Format, dest: *mut c_void, value: *const f32) -> u32 { unsafe { ts_setPixelFormatValue(format, dest, value, 0) } }
pub fn set_pixel_format_value_with_stride(format: Format, dest: *mut c_void, value: *const f32, stride: u32) -> u32 { unsafe { ts_setPixelFormatValue(format, dest, value, stride) } }
extern "C" {
	fn ts_getPlatformName(platform: Platform) -> *const c_char;
	fn ts_findPlatformName(name: *const c_char) -> Platform;
	fn ts_isPlatformAvailable(platform: Platform) -> i32;
	fn ts_getFormatName(format: Format) -> *const c_char;
	fn ts_findFormatName(name: *const c_char) -> Format;
	fn ts_getGLSLFormatName(format: Format) -> *const c_char;
	fn ts_findGLSLFormatName(name: *const c_char) -> Format;
	fn ts_isColorFormat(format: Format) -> i32;
	fn ts_isDepthFormat(format: Format) -> i32;
	fn ts_isPixelFormat(format: Format) -> i32;
	fn ts_isPlainFormat(format: Format) -> i32;
	fn ts_isMixedFormat(format: Format) -> i32;
	fn ts_isBlockFormat(format: Format) -> i32;
	fn ts_isStencilFormat(format: Format) -> i32;
	fn ts_toPixelFormat(format: Format) -> Format;
	fn ts_isNormFormat(format: Format) -> i32;
	fn ts_isSRGBFormat(format: Format) -> i32;
	fn ts_isSignedFormat(format: Format) -> i32;
	fn ts_isUnsignedFormat(format: Format) -> i32;
	fn ts_isIntegerFormat(format: Format) -> i32;
	fn ts_isFloatFormat(format: Format) -> i32;
	fn ts_toNormFormat(format: Format) -> Format;
	fn ts_toSRGBFormat(format: Format) -> Format;
	fn ts_toSignedFormat(format: Format) -> Format;
	fn ts_toUnsignedFormat(format: Format) -> Format;
	fn ts_toFloatFormat(format: Format) -> Format;
	fn ts_isi8Format(format: Format) -> i32;
	fn ts_isu8Format(format: Format) -> i32;
	fn ts_is8BitFormat(format: Format) -> i32;
	fn ts_to8BitFormat(format: Format) -> Format;
	fn ts_isi16Format(format: Format) -> i32;
	fn ts_isu16Format(format: Format) -> i32;
	fn ts_isf16Format(format: Format) -> i32;
	fn ts_is16BitFormat(format: Format) -> i32;
	fn ts_to16BitFormat(format: Format) -> Format;
	fn ts_isi32Format(format: Format) -> i32;
	fn ts_isu32Format(format: Format) -> i32;
	fn ts_isf32Format(format: Format) -> i32;
	fn ts_is32BitFormat(format: Format) -> i32;
	fn ts_to32BitFormat(format: Format) -> Format;
	fn ts_isi64Format(format: Format) -> i32;
	fn ts_isu64Format(format: Format) -> i32;
	fn ts_isf64Format(format: Format) -> i32;
	fn ts_is64BitFormat(format: Format) -> i32;
	fn ts_isBC15Format(format: Format) -> i32;
	fn ts_isBC67Format(format: Format) -> i32;
	fn ts_isETC2Format(format: Format) -> i32;
	fn ts_isASTCFormat(format: Format) -> i32;
	fn ts_getFormatComponents(format: Format) -> u32;
	fn ts_toFormatComponents(format: Format, components: u32) -> Format;
	fn ts_getFormatPixelSize(format: Format) -> u32;
	fn ts_getFormatBlockSize(format: Format) -> u32;
	fn ts_getFormatBlockWidth(format: Format) -> u32;
	fn ts_getFormatBlockHeight(format: Format) -> u32;
	fn ts_getPixelFormatValue(format: Format, value: *mut f32, src: *const c_void, stride: u32) -> u32;
	fn ts_setPixelFormatValue(format: Format, dest: *mut c_void, value: *const f32, stride: u32) -> u32;
}

// Tellusim::Allocator
pub mod allocator {
	#![allow(unused_imports)] use super::*;
	pub fn allocate(size: usize) -> *mut c_void { unsafe { tsAllocator_allocate_z(size) } }
	pub fn reallocate(ptr: *mut c_void, old_size: usize, new_size: usize) -> *mut c_void { unsafe { tsAllocator_reallocate(ptr, old_size, new_size) } }
	pub fn free(ptr: *const c_void, size: usize) { unsafe { tsAllocator_free(ptr, size) } }
	pub fn memory() -> usize { unsafe { tsAllocator_getMemory() } }
	pub fn allocations() -> usize { unsafe { tsAllocator_getAllocations() } }
	extern "C" {
		fn tsAllocator_allocate_z(size: usize) -> *mut c_void;
		fn tsAllocator_reallocate(ptr: *mut c_void, old_size: usize, new_size: usize) -> *mut c_void;
		fn tsAllocator_free(ptr: *const c_void, size: usize);
		fn tsAllocator_getMemory() -> usize;
		fn tsAllocator_getAllocations() -> usize;
	}
}

// Tellusim::Log
pub mod log {
	#![allow(unused_imports)] use super::*;
	type LogCallback = unsafe extern "C" fn(a0: LogLevel, time: u64, str: *const c_char, data: *mut c_void) -> i32;
	pub fn set_level(level: LogLevel) { unsafe { tsLog_setLevel(level) } }
	pub fn level() -> LogLevel { unsafe { tsLog_getLevel() } }
	pub fn unlock_callback() { unsafe { tsLog_unlockCallback() } }
	pub fn lock_callback() { unsafe { tsLog_lockCallback() } }
	pub fn print(str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsLog_print_s(str_.as_ptr()) }
	}
	pub fn print_with_level(level: LogLevel, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsLog_print_LLs(level, str_.as_ptr()) }
	}
	pub fn printe(level: LogLevel, str: &str) {
		let str_ = CString::new(str).unwrap();
		unsafe { tsLog_printe(level, str_.as_ptr()) }
	}
	extern "C" {
		fn tsLog_setLevel(level: LogLevel);
		fn tsLog_getLevel() -> LogLevel;
		fn tsLog_setCallback(callback: LogCallback, data: *mut c_void);
		fn tsLog_getCallbackData() -> *mut c_void;
		fn tsLog_unlockCallback();
		fn tsLog_lockCallback();
		fn tsLog_print_s(str: *const c_char);
		fn tsLog_print_LLs(level: LogLevel, str: *const c_char);
		fn tsLog_printe(level: LogLevel, str: *const c_char);
	}
}

// Tellusim::Time
pub mod time {
	#![allow(unused_imports)] use super::*;
	pub fn current() -> u64 { unsafe { tsTime_current() } }
	pub fn seconds() -> f64 { unsafe { tsTime_seconds() } }
	pub fn sleep(usec: u32) { unsafe { tsTime_sleep(usec) } }
	extern "C" {
		fn tsTime_current() -> u64;
		fn tsTime_seconds() -> f64;
		fn tsTime_sleep(usec: u32);
	}
}

// Tellusim::System
pub mod system {
	#![allow(unused_imports)] use super::*;
	pub fn thread_id() -> u32 { unsafe { tsSystem_getThreadID() } }
	pub fn set_environment(name: &str, value: &str) -> bool {
		let name_ = CString::new(name).unwrap();
		let value_ = CString::new(value).unwrap();
		unsafe { tsSystem_setEnvironment_ss(name_.as_ptr(), value_.as_ptr()) != 0 }
	}
	pub fn set_environment_with_name(name: &String, value: &str) -> bool {
		let value_ = CString::new(value).unwrap();
		unsafe { tsSystem_setEnvironment_cSs(name.this, value_.as_ptr()) != 0 }
	}
	pub fn environment(name: &str) -> string::String {
		let name_ = CString::new(name).unwrap();
		unsafe { get_string(tsSystem_getEnvironment_s(name_.as_ptr())) }
	}
	pub fn environment_with_name(name: &String) -> string::String { unsafe { get_string(tsSystem_getEnvironment_cS(name.this)) } }
	pub fn load_library(name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSystem_loadLibrary_s(name_.as_ptr()) }
	}
	pub fn load_library_with_name(name: &String) -> *mut c_void { unsafe { tsSystem_loadLibrary_cS(name.this) } }
	pub fn function(handle: *mut c_void, name: &str) -> *mut c_void {
		let name_ = CString::new(name).unwrap();
		unsafe { tsSystem_getFunction_prs(handle, name_.as_ptr()) }
	}
	pub fn function_with_name(handle: *mut c_void, name: &String) -> *mut c_void { unsafe { tsSystem_getFunction_prcS(handle, name.this) } }
	pub fn close_library(handle: *mut c_void) { unsafe { tsSystem_closeLibrary(handle) } }
	pub fn exec(command: &str) -> bool {
		let command_ = CString::new(command).unwrap();
		unsafe { tsSystem_exec_sbb(command_.as_ptr(), 0, 1) != 0 }
	}
	pub fn exec_with_wait(command: &str, wait: bool) -> bool {
		let command_ = CString::new(command).unwrap();
		unsafe { tsSystem_exec_sbb(command_.as_ptr(), if wait {1} else {0}, 1) != 0 }
	}
	pub fn exec_with_wait_console(command: &str, wait: bool, console: bool) -> bool {
		let command_ = CString::new(command).unwrap();
		unsafe { tsSystem_exec_sbb(command_.as_ptr(), if wait {1} else {0}, if console {1} else {0}) != 0 }
	}
	pub fn exec_with_command(command: &String) -> bool { unsafe { tsSystem_exec_cSbb(command.this, 0, 1) != 0 } }
	pub fn exec_with_command_wait(command: &String, wait: bool) -> bool { unsafe { tsSystem_exec_cSbb(command.this, if wait {1} else {0}, 1) != 0 } }
	pub fn exec_with_command_wait_console(command: &String, wait: bool, console: bool) -> bool { unsafe { tsSystem_exec_cSbb(command.this, if wait {1} else {0}, if console {1} else {0}) != 0 } }
	pub fn open(command: &str) -> bool {
		let command_ = CString::new(command).unwrap();
		unsafe { tsSystem_open_s(command_.as_ptr()) != 0 }
	}
	pub fn open_with_command(command: &String) -> bool { unsafe { tsSystem_open_cS(command.this) != 0 } }
	extern "C" {
		fn tsSystem_getThreadID() -> u32;
		fn tsSystem_setEnvironment_ss(name: *const c_char, value: *const c_char) -> i32;
		fn tsSystem_setEnvironment_cSs(name: *mut c_void, value: *const c_char) -> i32;
		fn tsSystem_getEnvironment_s(name: *const c_char) -> *mut c_void;
		fn tsSystem_getEnvironment_cS(name: *mut c_void) -> *mut c_void;
		fn tsSystem_loadLibrary_s(name: *const c_char) -> *mut c_void;
		fn tsSystem_loadLibrary_cS(name: *mut c_void) -> *mut c_void;
		fn tsSystem_getFunction_prs(handle: *mut c_void, name: *const c_char) -> *mut c_void;
		fn tsSystem_getFunction_prcS(handle: *mut c_void, name: *mut c_void) -> *mut c_void;
		fn tsSystem_closeLibrary(handle: *mut c_void);
		fn tsSystem_exec_sbb(command: *const c_char, wait: i32, console: i32) -> i32;
		fn tsSystem_exec_cSbb(command: *mut c_void, wait: i32, console: i32) -> i32;
		fn tsSystem_open_s(command: *const c_char) -> i32;
		fn tsSystem_open_cS(command: *mut c_void) -> i32;
	}
}

// Tellusim::MeshGraph
pub mod mesh_graph {
	#![allow(unused_imports)] use super::*;
	type MeshGraphProgressCallback = unsafe extern "C" fn(progress: u32, data_: *mut c_void) -> i32;
	unsafe extern "C" fn mesh_graph_progress_callback_null(_progress: u32, _data_: *mut c_void) -> i32 { 1 }
	unsafe extern "C" fn mesh_graph_progress_callback_func<Func>(progress: u32, data_: *mut c_void) -> i32 where Func: FnMut(u32) -> bool {
		let func = &mut *(data_ as *mut Func);
		if func(progress) {1} else {0}
	}
	pub fn create(dest: &mut Mesh, src: &mut Mesh, max_attributes: u32, max_primitives: u32) -> bool { unsafe { tsMeshGraph_create_MMuucMGPCA(dest.this, src.this, max_attributes, max_primitives, mesh_graph_progress_callback_null, ptr::null_mut(), ptr::null_mut()) != 0 } }
	pub fn create_with_func<Func>(dest: &mut Mesh, src: &mut Mesh, max_attributes: u32, max_primitives: u32, func: Func) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_graph_progress_callback_func::<Func>;
		unsafe { tsMeshGraph_create_MMuucMGPCA(dest.this, src.this, max_attributes, max_primitives, func_, ptr::null_mut(), func as *mut _ as *mut c_void) != 0 }
	}
	pub fn create_with_func_async<Func>(dest: &mut Mesh, src: &mut Mesh, max_attributes: u32, max_primitives: u32, func: Func, async_: Option<&Async>) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_graph_progress_callback_func::<Func>;
		unsafe { tsMeshGraph_create_MMuucMGPCA(dest.this, src.this, max_attributes, max_primitives, func_, match async_ { Some(async_) => &async_.this, None => ptr::null() }, func as *mut _ as *mut c_void) != 0 }
	}
	extern "C" {
		fn tsMeshGraph_create_MMuucMGPCA(dest: *mut c_void, src: *mut c_void, max_attributes: u32, max_primitives: u32, func: MeshGraphProgressCallback, async_: *const *mut c_void, data_: *mut c_void) -> i32;
	}
}

// Tellusim::MeshReduce
pub mod mesh_reduce {
	#![allow(unused_imports)] use super::*;
	type MeshReduceProgressCallback = unsafe extern "C" fn(progress: u32, data_: *mut c_void) -> i32;
	unsafe extern "C" fn mesh_reduce_progress_callback_null(_progress: u32, _data_: *mut c_void) -> i32 { 1 }
	unsafe extern "C" fn mesh_reduce_progress_callback_func<Func>(progress: u32, data_: *mut c_void) -> i32 where Func: FnMut(u32) -> bool {
		let func = &mut *(data_ as *mut Func);
		if func(progress) {1} else {0}
	}
	pub fn collapse(dest: &mut Mesh, src: &Mesh, ratio: f32) -> bool { unsafe { tsMeshReduce_collapse_McMffcMRPC(dest.this, src.this, ratio, 0.0, mesh_reduce_progress_callback_null, ptr::null_mut()) != 0 } }
	pub fn collapse_with_threshold(dest: &mut Mesh, src: &Mesh, ratio: f32, threshold: f32) -> bool { unsafe { tsMeshReduce_collapse_McMffcMRPC(dest.this, src.this, ratio, threshold, mesh_reduce_progress_callback_null, ptr::null_mut()) != 0 } }
	pub fn collapse_with_threshold_func<Func>(dest: &mut Mesh, src: &Mesh, ratio: f32, threshold: f32, func: Func) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_reduce_progress_callback_func::<Func>;
		unsafe { tsMeshReduce_collapse_McMffcMRPC(dest.this, src.this, ratio, threshold, func_, func as *mut _ as *mut c_void) != 0 }
	}
	pub fn collapse_with_dest(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32) -> bool { unsafe { tsMeshReduce_collapse_MGcMGffcMRPCu(dest.this, src.this, ratio, 0.0, mesh_reduce_progress_callback_null, MAXU32, ptr::null_mut()) != 0 } }
	pub fn collapse_with_dest_threshold(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32, threshold: f32) -> bool { unsafe { tsMeshReduce_collapse_MGcMGffcMRPCu(dest.this, src.this, ratio, threshold, mesh_reduce_progress_callback_null, MAXU32, ptr::null_mut()) != 0 } }
	pub fn collapse_with_dest_threshold_func<Func>(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32, threshold: f32, func: Func) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_reduce_progress_callback_func::<Func>;
		unsafe { tsMeshReduce_collapse_MGcMGffcMRPCu(dest.this, src.this, ratio, threshold, func_, MAXU32, func as *mut _ as *mut c_void) != 0 }
	}
	pub fn collapse_with_dest_threshold_func_position<Func>(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32, threshold: f32, func: Func, position: u32) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_reduce_progress_callback_func::<Func>;
		unsafe { tsMeshReduce_collapse_MGcMGffcMRPCu(dest.this, src.this, ratio, threshold, func_, position, func as *mut _ as *mut c_void) != 0 }
	}
	extern "C" {
		fn tsMeshReduce_collapse_McMffcMRPC(dest: *mut c_void, src: *mut c_void, ratio: f32, threshold: f32, func: MeshReduceProgressCallback, data_: *mut c_void) -> i32;
		fn tsMeshReduce_collapse_MGcMGffcMRPCu(dest: *mut c_void, src: *mut c_void, ratio: f32, threshold: f32, func: MeshReduceProgressCallback, position: u32, data_: *mut c_void) -> i32;
	}
}

// Tellusim::MeshRefine
pub mod mesh_refine {
	#![allow(unused_imports)] use super::*;
	pub fn subdiv(dest: &mut Mesh, src: &Mesh, steps: u32) -> bool { unsafe { tsMeshRefine_subdiv_McMuf(dest.this, src.this, steps, 1.0) != 0 } }
	pub fn subdiv_with_weight(dest: &mut Mesh, src: &Mesh, steps: u32, weight: f32) -> bool { unsafe { tsMeshRefine_subdiv_McMuf(dest.this, src.this, steps, weight) != 0 } }
	pub fn subdiv_with_dest(dest: &mut MeshGeometry, src: &MeshGeometry, steps: u32) -> bool { unsafe { tsMeshRefine_subdiv_MGcMGufu(dest.this, src.this, steps, 1.0, MAXU32) != 0 } }
	pub fn subdiv_with_dest_weight(dest: &mut MeshGeometry, src: &MeshGeometry, steps: u32, weight: f32) -> bool { unsafe { tsMeshRefine_subdiv_MGcMGufu(dest.this, src.this, steps, weight, MAXU32) != 0 } }
	pub fn subdiv_with_dest_weight_position(dest: &mut MeshGeometry, src: &MeshGeometry, steps: u32, weight: f32, position: u32) -> bool { unsafe { tsMeshRefine_subdiv_MGcMGufu(dest.this, src.this, steps, weight, position) != 0 } }
	extern "C" {
		fn tsMeshRefine_subdiv_McMuf(dest: *mut c_void, src: *mut c_void, steps: u32, weight: f32) -> i32;
		fn tsMeshRefine_subdiv_MGcMGufu(dest: *mut c_void, src: *mut c_void, steps: u32, weight: f32, position: u32) -> i32;
	}
}

// Tellusim::MeshSolid
pub mod mesh_solid {
	#![allow(unused_imports)] use super::*;
	type MeshSolidProgressCallback = unsafe extern "C" fn(progress: u32, data_: *mut c_void) -> i32;
	unsafe extern "C" fn mesh_solid_progress_callback_null(_progress: u32, _data_: *mut c_void) -> i32 { 1 }
	unsafe extern "C" fn mesh_solid_progress_callback_func<Func>(progress: u32, data_: *mut c_void) -> i32 where Func: FnMut(u32) -> bool {
		let func = &mut *(data_ as *mut Func);
		if func(progress) {1} else {0}
	}
	pub fn create(dest: &mut Mesh, src: &Mesh) -> bool { unsafe { tsMeshSolid_create_McMffcMSPC(dest.this, src.this, 1.0, 0.9, mesh_solid_progress_callback_null, ptr::null_mut()) != 0 } }
	pub fn create_with_ratio(dest: &mut Mesh, src: &Mesh, ratio: f32) -> bool { unsafe { tsMeshSolid_create_McMffcMSPC(dest.this, src.this, ratio, 0.9, mesh_solid_progress_callback_null, ptr::null_mut()) != 0 } }
	pub fn create_with_ratio_threshold(dest: &mut Mesh, src: &Mesh, ratio: f32, threshold: f32) -> bool { unsafe { tsMeshSolid_create_McMffcMSPC(dest.this, src.this, ratio, threshold, mesh_solid_progress_callback_null, ptr::null_mut()) != 0 } }
	pub fn create_with_ratio_threshold_func<Func>(dest: &mut Mesh, src: &Mesh, ratio: f32, threshold: f32, func: Func) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_solid_progress_callback_func::<Func>;
		unsafe { tsMeshSolid_create_McMffcMSPC(dest.this, src.this, ratio, threshold, func_, func as *mut _ as *mut c_void) != 0 }
	}
	pub fn create_with_dest(dest: &mut MeshGeometry, src: &MeshGeometry) -> bool { unsafe { tsMeshSolid_create_MGcMGffcMSPCu(dest.this, src.this, 1.0, 0.9, mesh_solid_progress_callback_null, MAXU32, ptr::null_mut()) != 0 } }
	pub fn create_with_dest_ratio(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32) -> bool { unsafe { tsMeshSolid_create_MGcMGffcMSPCu(dest.this, src.this, ratio, 0.9, mesh_solid_progress_callback_null, MAXU32, ptr::null_mut()) != 0 } }
	pub fn create_with_dest_ratio_threshold(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32, threshold: f32) -> bool { unsafe { tsMeshSolid_create_MGcMGffcMSPCu(dest.this, src.this, ratio, threshold, mesh_solid_progress_callback_null, MAXU32, ptr::null_mut()) != 0 } }
	pub fn create_with_dest_ratio_threshold_func<Func>(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32, threshold: f32, func: Func) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_solid_progress_callback_func::<Func>;
		unsafe { tsMeshSolid_create_MGcMGffcMSPCu(dest.this, src.this, ratio, threshold, func_, MAXU32, func as *mut _ as *mut c_void) != 0 }
	}
	pub fn create_with_dest_ratio_threshold_func_position<Func>(dest: &mut MeshGeometry, src: &MeshGeometry, ratio: f32, threshold: f32, func: Func, position: u32) -> bool where Func: FnMut(u32) -> bool {
		let mut func = func;
		let func = &mut func;
		let func_ = mesh_solid_progress_callback_func::<Func>;
		unsafe { tsMeshSolid_create_MGcMGffcMSPCu(dest.this, src.this, ratio, threshold, func_, position, func as *mut _ as *mut c_void) != 0 }
	}
	extern "C" {
		fn tsMeshSolid_create_McMffcMSPC(dest: *mut c_void, src: *mut c_void, ratio: f32, threshold: f32, func: MeshSolidProgressCallback, data_: *mut c_void) -> i32;
		fn tsMeshSolid_create_MGcMGffcMSPCu(dest: *mut c_void, src: *mut c_void, ratio: f32, threshold: f32, func: MeshSolidProgressCallback, position: u32, data_: *mut c_void) -> i32;
	}
}
