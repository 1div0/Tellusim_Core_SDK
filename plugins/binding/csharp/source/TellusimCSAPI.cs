// Copyright (C) 2018-2025, Tellusim Technologies Inc. All rights reserved
// https://tellusim.com/

using System;
using System.Runtime.InteropServices;

/*
 */
namespace Tellusim {
	
	// Tellusim::Vendor
	public enum Vendor : uint {
		ARM = 0x13b5,
		AMD = 0x1002,
		Apple = 0x106b,
		Intel = 0x8086,
		Nvidia = 0x10de,
		Qualcomm = 0x5143,
	}
	
	// Tellusim::Platform
	public enum Platform : uint {
		Unknown = 0,
		Fusion,
		D3D12,
		D3D11,
		MTL,
		VK,
		GL,
		GLES,
		WG,
		CU,
		HIP,
		Any,
		NumPlatforms,
	}
	
	// Tellusim::BindFlags
	public enum BindFlags : uint {
		BindFlagNone = 0,
		BindFlagFixed = 1,
		BindFlagRead = 2,
	}
	
	// Tellusim::TableType
	public enum TableType : uint {
		Texture = 0,
		Storage,
		NumTableTypes,
	}
	
	// Tellusim::Format
	public enum Format : uint {
		Unknown = 0,
		Ri8,
		Ru8,
		Ri8n,
		Ru8n,
		RGi8,
		RGu8,
		RGi8n,
		RGu8n,
		RGBi8,
		RGBu8,
		RGBi8n,
		RGBu8n,
		RGBu8ns,
		RGBAi8,
		RGBAu8,
		RGBAi8n,
		RGBAu8n,
		RGBAu8ns,
		BGRAu8n,
		BGRAu8ns,
		Ri16,
		Ru16,
		Ri16n,
		Ru16n,
		Rf16,
		RGi16,
		RGu16,
		RGi16n,
		RGu16n,
		RGf16,
		RGBi16,
		RGBu16,
		RGBi16n,
		RGBu16n,
		RGBf16,
		RGBAi16,
		RGBAu16,
		RGBAi16n,
		RGBAu16n,
		RGBAf16,
		Ri32,
		Ru32,
		Rf32,
		RGi32,
		RGu32,
		RGf32,
		RGBi32,
		RGBu32,
		RGBf32,
		RGBAi32,
		RGBAu32,
		RGBAf32,
		Ri64,
		Ru64,
		Rf64,
		RGi64,
		RGu64,
		RGf64,
		RGBi64,
		RGBu64,
		RGBf64,
		RGBAi64,
		RGBAu64,
		RGBAf64,
		RGBAu4n,
		RGBu5Au1n,
		Ru5Gu6Bu5n,
		RGBu10Au2,
		RGBu10Au2n,
		RGf11Bf10,
		RGBf9Eu5,
		RGBf21,
		BC1RGBu8n,
		BC1RGBu8ns,
		BC1RGBAu8n,
		BC1RGBAu8ns,
		BC2RGBAu8n,
		BC2RGBAu8ns,
		BC3RGBAu8n,
		BC3RGBAu8ns,
		BC4Ri8n,
		BC4Ru8n,
		BC5RGi8n,
		BC5RGu8n,
		BC6RGBf16s,
		BC6RGBf16u,
		BC7RGBAu8n,
		BC7RGBAu8ns,
		EACRi8n,
		EACRu8n,
		EACRGi8n,
		EACRGu8n,
		ETC2RGBu8n,
		ETC2RGBu8ns,
		ETC2RGBAu8n,
		ETC2RGBAu8ns,
		ETC2RGBu8Au1n,
		ETC2RGBu8Au1ns,
		ASTC44RGBAu8n,
		ASTC44RGBAu8ns,
		ASTC44RGBAf16,
		ASTC54RGBAu8n,
		ASTC54RGBAu8ns,
		ASTC54RGBAf16,
		ASTC55RGBAu8n,
		ASTC55RGBAu8ns,
		ASTC55RGBAf16,
		ASTC65RGBAu8n,
		ASTC65RGBAu8ns,
		ASTC65RGBAf16,
		ASTC66RGBAu8n,
		ASTC66RGBAu8ns,
		ASTC66RGBAf16,
		ASTC85RGBAu8n,
		ASTC85RGBAu8ns,
		ASTC85RGBAf16,
		ASTC86RGBAu8n,
		ASTC86RGBAu8ns,
		ASTC86RGBAf16,
		ASTC88RGBAu8n,
		ASTC88RGBAu8ns,
		ASTC88RGBAf16,
		Du16,
		Du16Su8,
		Du24,
		Du24Su8,
		Df32,
		Df32Su8,
		NumFormats,
	}
	
	// Tellusim::String
	public sealed class String {
		public String() { self = new HandleRef(this, tsString_new()); owner = true; }
		public String(uint size, char c = (char)0) { self = new HandleRef(this, tsString_new_uc(size, c)); owner = true; }
		public String(string str, uint length = Base.Maxu32) { self = new HandleRef(this, tsString_new_su(str, length)); owner = true; }
		public String(ushort[] str, uint length = Base.Maxu32) { self = new HandleRef(this, tsString_new_wu(str, length)); owner = true; }
		public String(uint[] str, uint length = Base.Maxu32) { self = new HandleRef(this, tsString_new_upu(str, length)); owner = true; }
		public String(String ptr) { self = new HandleRef(this, ptr.getSelfPtr()); }
		public String(IntPtr ptr) { self = new HandleRef(this, ptr); owner = true; }
		public static String Null() { return new String(IntPtr.Zero); }
		~String() { if(owner) tsString_delete(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void reserve(uint size, bool discard = false) { tsString_reserve(self, size, discard); }
		public void resize(uint size, char c = (char)0, bool reserve = false) { tsString_resize(self, size, c, reserve); }
		public void release() { tsString_release(self); }
		public void clear() { tsString_clear(self); }
		public void copy(string str, uint length = Base.Maxu32) { tsString_copy_su(self, str, length); }
		public void copy(ushort[] str, uint length = Base.Maxu32) { tsString_copy_wu(self, str, length); }
		public void copy(uint[] str, uint length = Base.Maxu32) { tsString_copy_upu(self, str, length); }
		public void copy(String string_, uint length = Base.Maxu32) { tsString_copy_cSu(self, string_.getSelf(), length); }
		public void append(char c) { tsString_append_c(self, c); }
		public void append(string str, uint length = Base.Maxu32) { tsString_append_su(self, str, length); }
		public void append(String string_, uint length = Base.Maxu32) { tsString_append_cSu(self, string_.getSelf(), length); }
		public void insert(uint pos, string str, uint length = Base.Maxu32) { tsString_insert_usu(self, pos, str, length); }
		public void insert(uint pos, String string_, uint length = Base.Maxu32) { tsString_insert_ucSu(self, pos, string_.getSelf(), length); }
		public void removeBack(uint length = 1) { tsString_removeBack(self, length); }
		public void remove(uint pos, uint length = 1) { tsString_remove(self, pos, length); }
		public void reverse(uint pos = 0, uint length = Base.Maxu32) { tsString_reverse(self, pos, length); }
		public uint size() { return tsString_size(self); }
		public bool empty() { return tsString_empty(self); }
		public string get() { return Base.getCString(tsString_get(self)); }
		public char get(uint index) { return tsString_get_u(self, index); }
		public uint find(char c, uint pos = 0) { return tsString_find_ccu(self, c, pos); }
		public uint rfind(char c, uint pos = Base.Maxu32) { return tsString_rfind_ccu(self, c, pos); }
		public uint count(char c, uint pos = 0) { return tsString_count_ccu(self, c, pos); }
		public uint find(string str, uint pos = 0) { return tsString_find_csu(self, str, pos); }
		public uint rfind(string str, uint pos = Base.Maxu32) { return tsString_rfind_csu(self, str, pos); }
		public uint count(string str, uint pos = 0) { return tsString_count_csu(self, str, pos); }
		public bool begins(string str, uint length = Base.Maxu32, uint pos = 0) { return tsString_begins(self, str, length, pos); }
		public bool contains(string str, uint length = Base.Maxu32, uint pos = 0) { return tsString_contains(self, str, length, pos); }
		public bool match(string str, uint length = Base.Maxu32, uint pos = 0) { return tsString_match(self, str, length, pos); }
		public int compare(string str, uint pos = 0) { return tsString_compare(self, str, pos); }
		public uint distance(string str, bool scan = false, uint pos = 0) { return tsString_distance(self, str, scan, pos); }
		public string begin() { return Base.getCString(tsString_begin(self)); }
		public string end() { return Base.getCString(tsString_end(self)); }
		public char front(uint index = 0) { return tsString_front_cu(self, index); }
		public char back(uint index = 0) { return tsString_back_cu(self, index); }
		public string substring(uint pos, uint length = Base.Maxu32) { return Base.getString(tsString_substring(self, pos, length)); }
		public string replace(char before, char after, uint pos = 0) { return Base.getString(tsString_replace_cccu(self, before, after, pos)); }
		public string replace(string before, string after, uint pos = 0) { return Base.getString(tsString_replace_cssu(self, before, after, pos)); }
		public string replace(String before, String after, uint pos = 0) { return Base.getString(tsString_replace_ccScSu(self, before.getSelf(), after.getSelf(), pos)); }
		public string extension(string extension) { return Base.getString(tsString_extension_cs(self, extension)); }
		public string extension() { return Base.getString(tsString_extension_c(self)); }
		public string pathname() { return Base.getString(tsString_pathname(self)); }
		public string basename() { return Base.getString(tsString_basename(self)); }
		public string dirname() { return Base.getString(tsString_dirname(self)); }
		public static string relname(string path, string str) { return Base.getString(tsString_relname_ss(path, str)); }
		public static string relname(String path, String str) { return Base.getString(tsString_relname_cScS(path.getSelf(), str.getSelf())); }
		public string capitalize(string delimiters = "", string spaces = "") { return Base.getString(tsString_capitalize(self, delimiters, spaces)); }
		public string lower() { return Base.getString(tsString_lower(self)); }
		public string upper() { return Base.getString(tsString_upper(self)); }
		public static uint toUtf32(string str, ref uint code) { return tsString_toUtf32_sur(str, ref code); }
		public uint toUtf16(ushort[] d, uint length) { return tsString_toUtf16(self, d, length); }
		public uint toUtf32(uint[] d, uint length) { return tsString_toUtf32_curu(self, d, length); }
		public static uint fromUtf32(String d, uint code) { return tsString_fromUtf32_Su(d.getSelf(), code); }
		public static string fromUtf16(ushort[] str, uint length = Base.Maxu32) { return Base.getString(tsString_fromUtf16(str, length)); }
		public static string fromUtf32(uint[] str, uint length = Base.Maxu32) { return Base.getString(tsString_fromUtf32_upu(str, length)); }
		public static string fromUrl(string str, uint length = Base.Maxu32) { return Base.getString(tsString_fromUrl_su(str, length)); }
		public static string fromUrl(String string_, uint length = Base.Maxu32) { return Base.getString(tsString_fromUrl_cSu(string_.getSelf(), length)); }
		public static string fromi32(String d, int value, uint radix = 10) { return Base.getString(tsString_fromi32_Siu(d.getSelf(), value, radix)); }
		public static string fromi64(String d, long value, uint radix = 10) { return Base.getString(tsString_fromi64_Si64u(d.getSelf(), value, radix)); }
		public static string fromu32(String d, uint value, uint radix = 10) { return Base.getString(tsString_fromu32_Suu(d.getSelf(), value, radix)); }
		public static string fromu64(String d, ulong value, uint radix = 10) { return Base.getString(tsString_fromu64_Su64u(d.getSelf(), value, radix)); }
		public static string fromf32(String d, float value, uint digits = 6, bool compact = false, bool exponent = false) { return Base.getString(tsString_fromf32_Sfubb(d.getSelf(), value, digits, compact, exponent)); }
		public static string fromf64(String d, double value, uint digits = 12, bool compact = false, bool exponent = false) { return Base.getString(tsString_fromf64_Sf64ubb(d.getSelf(), value, digits, compact, exponent)); }
		public static string fromi32(int value, uint radix = 10) { return Base.getString(tsString_fromi32_iu(value, radix)); }
		public static string fromi64(long value, uint radix = 10) { return Base.getString(tsString_fromi64_i64u(value, radix)); }
		public static string fromu32(uint value, uint radix = 10) { return Base.getString(tsString_fromu32_uu(value, radix)); }
		public static string fromu64(ulong value, uint radix = 10) { return Base.getString(tsString_fromu64_u64u(value, radix)); }
		public static string fromf32(float value, uint digits = 6, bool compact = false, bool exponent = false) { return Base.getString(tsString_fromf32_fubb(value, digits, compact, exponent)); }
		public static string fromf64(double value, uint digits = 12, bool compact = false, bool exponent = false) { return Base.getString(tsString_fromf64_f64ubb(value, digits, compact, exponent)); }
		public static int toi32(string str, uint radix = 10, uint[] size = null) { return tsString_toi32_suur(str, radix, size); }
		public static long toi64(string str, uint radix = 10, uint[] size = null) { return tsString_toi64_suur(str, radix, size); }
		public static uint tou32(string str, uint radix = 10, uint[] size = null) { return tsString_tou32_suur(str, radix, size); }
		public static ulong tou64(string str, uint radix = 10, uint[] size = null) { return tsString_tou64_suur(str, radix, size); }
		public static int toi32(string str, uint[] size) { return tsString_toi32_sur(str, size); }
		public static long toi64(string str, uint[] size) { return tsString_toi64_sur(str, size); }
		public static uint tou32(string str, uint[] size) { return tsString_tou32_sur(str, size); }
		public static ulong tou64(string str, uint[] size) { return tsString_tou64_sur(str, size); }
		public static float tof32(string str, uint[] size = null) { return tsString_tof32_sur(str, size); }
		public static double tof64(string str, uint[] size = null) { return tsString_tof64_sur(str, size); }
		public int toi32(uint radix = 10, uint pos = 0) { return tsString_toi32_cuu(self, radix, pos); }
		public long toi64(uint radix = 10, uint pos = 0) { return tsString_toi64_cuu(self, radix, pos); }
		public uint tou32(uint radix = 10, uint pos = 0) { return tsString_tou32_cuu(self, radix, pos); }
		public ulong tou64(uint radix = 10, uint pos = 0) { return tsString_tou64_cuu(self, radix, pos); }
		public float tof32(uint pos = 0) { return tsString_tof32_cu(self, pos); }
		public double tof64(uint pos = 0) { return tsString_tof64_cu(self, pos); }
		public uint toHashu32(uint pos = 0) { return tsString_toHashu32(self, pos); }
		public ulong toHashu64(uint pos = 0) { return tsString_toHashu64(self, pos); }
		public uint toRGBAu8(uint pos = 0) { return tsString_toRGBAu8(self, pos); }
		public static string fromTime(ulong usec, uint digits = 2) { return Base.getString(tsString_fromTime(usec, digits)); }
		public static string fromBytes(ulong bytes, uint digits = 2) { return Base.getString(tsString_fromBytes(bytes, digits)); }
		public static string fromNumber(ulong value, uint digits = 2) { return Base.getString(tsString_fromNumber(value, digits)); }
		public static string fromFrequency(ulong hz, uint digits = 2) { return Base.getString(tsString_fromFrequency(hz, digits)); }
		public static string fromLength(double distance, uint digits = 2) { return Base.getString(tsString_fromLength(distance, digits)); }
		public static string fromAngle(double angle, uint digits = 2) { return Base.getString(tsString_fromAngle(angle, digits)); }
		public static ulong toBytes(string str, uint[] size = null) { return tsString_toBytes_sur(str, size); }
		public static ulong toNumber(string str, uint[] size = null) { return tsString_toNumber_sur(str, size); }
		public static ulong toFrequency(string str, uint[] size = null) { return tsString_toFrequency_sur(str, size); }
		public static double toLength(string str, uint[] size = null) { return tsString_toLength_sur(str, size); }
		public ulong toBytes(uint pos = 0, uint[] size = null) { return tsString_toBytes_cuur(self, pos, size); }
		public ulong toNumber(uint pos = 0, uint[] size = null) { return tsString_toNumber_cuur(self, pos, size); }
		public ulong toFrequency(uint pos = 0, uint[] size = null) { return tsString_toFrequency_cuur(self, pos, size); }
		public double toLength(uint pos = 0, uint[] size = null) { return tsString_toLength_cuur(self, pos, size); }
		public override string ToString() { return "Tellusim.String: Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(String ptr) { return (ptr != null && ptr.getSelfPtr() != IntPtr.Zero); }
		[DllImport(Base.Import)] private static extern IntPtr tsString_new();
		[DllImport(Base.Import)] private static extern IntPtr tsString_new_uc(uint size, char c);
		[DllImport(Base.Import)] private static extern IntPtr tsString_new_su(string str, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_new_wu(ushort[] str, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_new_upu(uint[] str, uint length);
		[DllImport(Base.Import)] private static extern void tsString_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsString_reserve(HandleRef self, uint size, bool discard);
		[DllImport(Base.Import)] private static extern void tsString_resize(HandleRef self, uint size, char c, bool reserve);
		[DllImport(Base.Import)] private static extern void tsString_release(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsString_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsString_copy_su(HandleRef self, string str, uint length);
		[DllImport(Base.Import)] private static extern void tsString_copy_wu(HandleRef self, ushort[] str, uint length);
		[DllImport(Base.Import)] private static extern void tsString_copy_upu(HandleRef self, uint[] str, uint length);
		[DllImport(Base.Import)] private static extern void tsString_copy_cSu(HandleRef self, HandleRef string_, uint length);
		[DllImport(Base.Import)] private static extern void tsString_append_c(HandleRef self, char c);
		[DllImport(Base.Import)] private static extern void tsString_append_su(HandleRef self, string str, uint length);
		[DllImport(Base.Import)] private static extern void tsString_append_cSu(HandleRef self, HandleRef string_, uint length);
		[DllImport(Base.Import)] private static extern void tsString_insert_usu(HandleRef self, uint pos, string str, uint length);
		[DllImport(Base.Import)] private static extern void tsString_insert_ucSu(HandleRef self, uint pos, HandleRef string_, uint length);
		[DllImport(Base.Import)] private static extern void tsString_removeBack(HandleRef self, uint length);
		[DllImport(Base.Import)] private static extern void tsString_remove(HandleRef self, uint pos, uint length);
		[DllImport(Base.Import)] private static extern void tsString_reverse(HandleRef self, uint pos, uint length);
		[DllImport(Base.Import)] private static extern uint tsString_size(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsString_empty(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_get(HandleRef self);
		[DllImport(Base.Import)] private static extern char tsString_get_u(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsString_find_ccu(HandleRef self, char c, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_rfind_ccu(HandleRef self, char c, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_count_ccu(HandleRef self, char c, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_find_csu(HandleRef self, string str, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_rfind_csu(HandleRef self, string str, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_count_csu(HandleRef self, string str, uint pos);
		[DllImport(Base.Import)] private static extern bool tsString_begins(HandleRef self, string str, uint length, uint pos);
		[DllImport(Base.Import)] private static extern bool tsString_contains(HandleRef self, string str, uint length, uint pos);
		[DllImport(Base.Import)] private static extern bool tsString_match(HandleRef self, string str, uint length, uint pos);
		[DllImport(Base.Import)] private static extern int tsString_compare(HandleRef self, string str, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_distance(HandleRef self, string str, bool scan, uint pos);
		[DllImport(Base.Import)] private static extern IntPtr tsString_begin(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_end(HandleRef self);
		[DllImport(Base.Import)] private static extern char tsString_front_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern char tsString_back_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsString_substring(HandleRef self, uint pos, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_replace_cccu(HandleRef self, char before, char after, uint pos);
		[DllImport(Base.Import)] private static extern IntPtr tsString_replace_cssu(HandleRef self, string before, string after, uint pos);
		[DllImport(Base.Import)] private static extern IntPtr tsString_replace_ccScSu(HandleRef self, HandleRef before, HandleRef after, uint pos);
		[DllImport(Base.Import)] private static extern IntPtr tsString_extension_cs(HandleRef self, string extension);
		[DllImport(Base.Import)] private static extern IntPtr tsString_extension_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_pathname(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_basename(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_dirname(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_relname_ss(string path, string str);
		[DllImport(Base.Import)] private static extern IntPtr tsString_relname_cScS(HandleRef path, HandleRef str);
		[DllImport(Base.Import)] private static extern IntPtr tsString_capitalize(HandleRef self, string delimiters, string spaces);
		[DllImport(Base.Import)] private static extern IntPtr tsString_lower(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsString_upper(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsString_toUtf32_sur(string str, ref uint code);
		[DllImport(Base.Import)] private static extern uint tsString_toUtf16(HandleRef self, ushort[] d, uint length);
		[DllImport(Base.Import)] private static extern uint tsString_toUtf32_curu(HandleRef self, uint[] d, uint length);
		[DllImport(Base.Import)] private static extern uint tsString_fromUtf32_Su(HandleRef d, uint code);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromUtf16(ushort[] str, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromUtf32_upu(uint[] str, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromUrl_su(string str, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromUrl_cSu(HandleRef string_, uint length);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromi32_Siu(HandleRef d, int value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromi64_Si64u(HandleRef d, long value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromu32_Suu(HandleRef d, uint value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromu64_Su64u(HandleRef d, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromf32_Sfubb(HandleRef d, float value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromf64_Sf64ubb(HandleRef d, double value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromi32_iu(int value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromi64_i64u(long value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromu32_uu(uint value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromu64_u64u(ulong value, uint radix);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromf32_fubb(float value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromf64_f64ubb(double value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern int tsString_toi32_suur(string str, uint radix, uint[] size);
		[DllImport(Base.Import)] private static extern long tsString_toi64_suur(string str, uint radix, uint[] size);
		[DllImport(Base.Import)] private static extern uint tsString_tou32_suur(string str, uint radix, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_tou64_suur(string str, uint radix, uint[] size);
		[DllImport(Base.Import)] private static extern int tsString_toi32_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern long tsString_toi64_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern uint tsString_tou32_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_tou64_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern float tsString_tof32_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern double tsString_tof64_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern int tsString_toi32_cuu(HandleRef self, uint radix, uint pos);
		[DllImport(Base.Import)] private static extern long tsString_toi64_cuu(HandleRef self, uint radix, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_tou32_cuu(HandleRef self, uint radix, uint pos);
		[DllImport(Base.Import)] private static extern ulong tsString_tou64_cuu(HandleRef self, uint radix, uint pos);
		[DllImport(Base.Import)] private static extern float tsString_tof32_cu(HandleRef self, uint pos);
		[DllImport(Base.Import)] private static extern double tsString_tof64_cu(HandleRef self, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_toHashu32(HandleRef self, uint pos);
		[DllImport(Base.Import)] private static extern ulong tsString_toHashu64(HandleRef self, uint pos);
		[DllImport(Base.Import)] private static extern uint tsString_toRGBAu8(HandleRef self, uint pos);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromTime(ulong usec, uint digits);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromBytes(ulong bytes, uint digits);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromNumber(ulong value, uint digits);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromFrequency(ulong hz, uint digits);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromLength(double distance, uint digits);
		[DllImport(Base.Import)] private static extern IntPtr tsString_fromAngle(double angle, uint digits);
		[DllImport(Base.Import)] private static extern ulong tsString_toBytes_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_toNumber_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_toFrequency_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern double tsString_toLength_sur(string str, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_toBytes_cuur(HandleRef self, uint pos, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_toNumber_cuur(HandleRef self, uint pos, uint[] size);
		[DllImport(Base.Import)] private static extern ulong tsString_toFrequency_cuur(HandleRef self, uint pos, uint[] size);
		[DllImport(Base.Import)] private static extern double tsString_toLength_cuur(HandleRef self, uint pos, uint[] size);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::App
	public sealed class App {
		public const uint Version_19 = 20221010;
		public const uint Version_20 = 20221109;
		public const uint Version_21 = 20221122;
		public const uint Version_22 = 20221222;
		public const uint Version_23 = 20230117;
		public const uint Version_24 = 20230217;
		public const uint Version_25 = 20230402;
		public const uint Version_26 = 20230509;
		public const uint Version_27 = 20230612;
		public const uint Version_28 = 20230718;
		public const uint Version_29 = 20230824;
		public const uint Version_30 = 20231029;
		public const uint Version_31 = 20231113;
		public const uint Version_32 = 20231212;
		public const uint Version_33 = 20240116;
		public const uint Version_34 = 20240216;
		public const uint Version_35 = 20240320;
		public const uint Version_36 = 20240427;
		public const uint Version_37 = 20240515;
		public const uint Version_38 = 20250215;
		public const uint Version_39 = 20250322;
		public const uint Version_40 = 20250429;
		public const uint Version_41 = 20250816;
		public const uint Version = 20250816;
		public App(string[] args) { self = new HandleRef(this, tsApp_new(args.Length + 1, Base.getArgs(args))); owner = true; }
		public App(App ptr) { self = new HandleRef(this, ptr.getSelfPtr()); }
		public App(IntPtr ptr) { self = new HandleRef(this, ptr); owner = true; }
		public static App Null() { return new App(IntPtr.Zero); }
		~App() { if(owner) tsApp_delete(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsApp_clear(self); }
		public Platform getPlatform() { return tsApp_getPlatform(self); }
		public uint getDevice() { return tsApp_getDevice(self); }
		public uint getWidth() { return tsApp_getWidth(self); }
		public uint getHeight() { return tsApp_getHeight(self); }
		public uint getMultisample() { return tsApp_getMultisample(self); }
		public uint getNumArguments() { return tsApp_getNumArguments(self); }
		public string getArgument(uint num) { return Base.getString(tsApp_getArgument_cu(self, num)); }
		public bool isArgument(string name) { return tsApp_isArgument(self, name); }
		public string getArgument(string name) { return Base.getString(tsApp_getArgument_cs(self, name)); }
		public bool create(Platform platform = Platform.Unknown, uint version = Version) { return tsApp_create(self, platform, version); }
		public static void setPlatform(Platform platform, uint device = Base.Maxu32) { tsApp_setPlatform(platform, device); }
		public static void setSize(uint width, uint height, uint multisample = 0) { tsApp_setSize(width, height, multisample); }
		public static bool isBuildCore() { return tsApp_isBuildCore(); }
		public static bool isBuildDebug() { return tsApp_isBuildDebug(); }
		public static bool isBuildFloat64() { return tsApp_isBuildFloat64(); }
		public static string getBuildDate() { return Base.getString(tsApp_getBuildDate()); }
		public static string getBuildInfo() { return Base.getString(tsApp_getBuildInfo()); }
		public static uint getVersion() { return tsApp_getVersion(); }
		public static ulong getAPIHash() { return tsApp_getAPIHash(); }
		public override string ToString() { return "Tellusim.App: Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(App ptr) { return (ptr != null && ptr.getSelfPtr() != IntPtr.Zero); }
		[DllImport(Base.Import)] private static extern IntPtr tsApp_new(int argc, string[] argv);
		[DllImport(Base.Import)] private static extern void tsApp_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsApp_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsApp_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsApp_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsApp_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsApp_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsApp_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsApp_getNumArguments(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsApp_getArgument_cu(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern bool tsApp_isArgument(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsApp_getArgument_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsApp_create(HandleRef self, Platform platform, uint version);
		[DllImport(Base.Import)] private static extern void tsApp_setPlatform(Platform platform, uint device);
		[DllImport(Base.Import)] private static extern void tsApp_setSize(uint width, uint height, uint multisample);
		[DllImport(Base.Import)] private static extern bool tsApp_isBuildCore();
		[DllImport(Base.Import)] private static extern bool tsApp_isBuildDebug();
		[DllImport(Base.Import)] private static extern bool tsApp_isBuildFloat64();
		[DllImport(Base.Import)] private static extern IntPtr tsApp_getBuildDate();
		[DllImport(Base.Import)] private static extern IntPtr tsApp_getBuildInfo();
		[DllImport(Base.Import)] private static extern uint tsApp_getVersion();
		[DllImport(Base.Import)] private static extern ulong tsApp_getAPIHash();
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Async
	public sealed class Async {
		public Async() { self = new HandleRef(this, tsAsync_new()); owner = true; }
		public Async(Async ptr) { self = new HandleRef(this, tsAsync_copyPtr(ptr.getSelf())); owner = true; }
		public Async(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsAsync_isOwnerPtr(self); }
		public static Async Null() { return new Async(IntPtr.Zero); }
		~Async() { if(owner) tsAsync_delete(self); }
		public bool equalPtr(Async ptr) { return tsAsync_equalPtr(self, ptr.getSelf()); }
		public Async clonePtr() { return new Async(tsAsync_clonePtr(self)); }
		public void clearPtr() { tsAsync_clearPtr(self); }
		public void destroyPtr() { tsAsync_destroyPtr(self); }
		public void acquirePtr() { tsAsync_acquirePtr(self); }
		public void unacquirePtr() { tsAsync_unacquirePtr(self); }
		public bool isValidPtr() { return tsAsync_isValidPtr(self); }
		public bool isOwnerPtr() { return tsAsync_isOwnerPtr(self); }
		public bool isConstPtr() { return tsAsync_isConstPtr(self); }
		public uint getCountPtr() { return tsAsync_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsAsync_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public bool init(uint num = 0) { return tsAsync_init(self, num); }
		public bool shutdown() { return tsAsync_shutdown(self); }
		public bool isInitialized() { return tsAsync_isInitialized(self); }
		public static uint getNumCores() { return tsAsync_getNumCores(); }
		public uint getNumThreads() { return tsAsync_getNumThreads(self); }
		public void clear() { tsAsync_clear(self); }
		public uint getNumTasks(bool check = false) { return tsAsync_getNumTasks(self, check); }
		public bool check() { return tsAsync_check_c(self); }
		public bool wait() { return tsAsync_wait_c(self); }
		public override string ToString() { return "Tellusim.Async: Valid: " + tsAsync_isValidPtr(self) + "; Owner: " + tsAsync_isOwnerPtr(self) + "; Const: " + tsAsync_isConstPtr(self) + "; Count: " + tsAsync_getCountPtr(self) + "; Internal: 0x" + tsAsync_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Async ptr) { return (ptr != null && tsAsync_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsAsync_new();
		[DllImport(Base.Import)] private static extern void tsAsync_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsAsync_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsAsync_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsAsync_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsAsync_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsAsync_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsAsync_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsAsync_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsAsync_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_init(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern bool tsAsync_shutdown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_isInitialized(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsAsync_getNumCores();
		[DllImport(Base.Import)] private static extern uint tsAsync_getNumThreads(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsAsync_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsAsync_getNumTasks(HandleRef self, bool check);
		[DllImport(Base.Import)] private static extern bool tsAsync_check_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsAsync_wait_c(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Stream
	public class Stream {
		public Stream() { self = new HandleRef(this, tsStream_new()); owner = true; }
		public Stream(Stream ptr) { self = new HandleRef(this, tsStream_copyPtr(ptr.getSelf())); owner = true; }
		public Stream(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsStream_isOwnerPtr(self); }
		public static Stream Null() { return new Stream(IntPtr.Zero); }
		~Stream() { if(owner) tsStream_delete(self); }
		public bool equalPtr(Stream ptr) { return tsStream_equalPtr(self, ptr.getSelf()); }
		public Stream clonePtr() { return new Stream(tsStream_clonePtr(self)); }
		public void clearPtr() { tsStream_clearPtr(self); }
		public void destroyPtr() { tsStream_destroyPtr(self); }
		public void acquirePtr() { tsStream_acquirePtr(self); }
		public void unacquirePtr() { tsStream_unacquirePtr(self); }
		public bool isValidPtr() { return tsStream_isValidPtr(self); }
		public bool isOwnerPtr() { return tsStream_isOwnerPtr(self); }
		public bool isConstPtr() { return tsStream_isConstPtr(self); }
		public uint getCountPtr() { return tsStream_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsStream_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Stream move() { return new Stream(tsStream_move(self)); }
		public bool isOpened() { return tsStream_isOpened(self); }
		public bool isMapped() { return tsStream_isMapped(self); }
		public bool isAvailable() { return tsStream_isAvailable(self); }
		public ulong getSize() { return tsStream_getSize(self); }
		public string getName() { return Base.getString(tsStream_getName(self)); }
		public ulong tell() { return tsStream_tell(self); }
		public bool seek(ulong offset) { return tsStream_seek(self, offset); }
		public bool seekBack(ulong offset) { return tsStream_seekBack(self, offset); }
		public bool seekCur(long offset) { return tsStream_seekCur(self, offset); }
		public byte[] getData() { return tsStream_getData(self); }
		public ulong read(IntPtr dest, ulong size) { return tsStream_read(self, dest, size); }
		public ulong read<Type>(ref Type[] dest) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			ulong ret_ = read(ptr_, (ulong)size_);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong write(IntPtr src, ulong size) { return tsStream_write(self, src, size); }
		public ulong write<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = write(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool flush() { return tsStream_flush(self); }
		public bool puts(string str) { return tsStream_puts_s(self, str); }
		public bool puts(String str) { return tsStream_puts_cS(self, str.getSelf()); }
		public bool printf(string format) { return tsStream_printf(self, format); }
		public string gets(ref byte status) { return Base.getString(tsStream_gets(self, ref status)); }
		public string gets() { byte status = 1; return Base.getString(tsStream_gets(self, ref status)); }
		public sbyte readi8(ref byte status) { return tsStream_readi8(self, ref status); }
		public sbyte readi8() { byte status = 1; return tsStream_readi8(self, ref status); }
		public bool writei8(sbyte value) { return tsStream_writei8(self, value); }
		public byte readu8(ref byte status) { return tsStream_readu8(self, ref status); }
		public byte readu8() { byte status = 1; return tsStream_readu8(self, ref status); }
		public bool writeu8(byte value) { return tsStream_writeu8(self, value); }
		public short readi16(ref byte status) { return tsStream_readi16(self, ref status); }
		public short readi16() { byte status = 1; return tsStream_readi16(self, ref status); }
		public bool writei16(short value) { return tsStream_writei16(self, value); }
		public ushort readu16(ref byte status) { return tsStream_readu16(self, ref status); }
		public ushort readu16() { byte status = 1; return tsStream_readu16(self, ref status); }
		public bool writeu16(ushort value) { return tsStream_writeu16(self, value); }
		public int readi32(ref byte status) { return tsStream_readi32(self, ref status); }
		public int readi32() { byte status = 1; return tsStream_readi32(self, ref status); }
		public bool writei32(int value) { return tsStream_writei32(self, value); }
		public uint readu32(ref byte status) { return tsStream_readu32(self, ref status); }
		public uint readu32() { byte status = 1; return tsStream_readu32(self, ref status); }
		public bool writeu32(uint value) { return tsStream_writeu32(self, value); }
		public long readi64(ref byte status) { return tsStream_readi64(self, ref status); }
		public long readi64() { byte status = 1; return tsStream_readi64(self, ref status); }
		public bool writei64(long value) { return tsStream_writei64(self, value); }
		public ulong readu64(ref byte status) { return tsStream_readu64(self, ref status); }
		public ulong readu64() { byte status = 1; return tsStream_readu64(self, ref status); }
		public bool writeu64(ulong value) { return tsStream_writeu64(self, value); }
		public float readf32(ref byte status) { return tsStream_readf32(self, ref status); }
		public float readf32() { byte status = 1; return tsStream_readf32(self, ref status); }
		public bool writef32(float value) { return tsStream_writef32(self, value); }
		public double readf64(ref byte status) { return tsStream_readf64(self, ref status); }
		public double readf64() { byte status = 1; return tsStream_readf64(self, ref status); }
		public bool writef64(double value) { return tsStream_writef64(self, value); }
		public int readi32e(ref byte status) { return tsStream_readi32e(self, ref status); }
		public int readi32e() { byte status = 1; return tsStream_readi32e(self, ref status); }
		public bool writei32e(int value) { return tsStream_writei32e(self, value); }
		public uint readu32e(ref byte status) { return tsStream_readu32e(self, ref status); }
		public uint readu32e() { byte status = 1; return tsStream_readu32e(self, ref status); }
		public bool writeu32e(uint value) { return tsStream_writeu32e(self, value); }
		public long readi64e(ref byte status) { return tsStream_readi64e(self, ref status); }
		public long readi64e() { byte status = 1; return tsStream_readi64e(self, ref status); }
		public bool writei64e(long value) { return tsStream_writei64e(self, value); }
		public ulong readu64e(ref byte status) { return tsStream_readu64e(self, ref status); }
		public ulong readu64e() { byte status = 1; return tsStream_readu64e(self, ref status); }
		public bool writeu64e(ulong value) { return tsStream_writeu64e(self, value); }
		public string readString(ref byte status) { return Base.getString(tsStream_readString_br(self, ref status)); }
		public string readString() { byte status = 1; return Base.getString(tsStream_readString_br(self, ref status)); }
		public bool writeString(String str) { return tsStream_writeString_cS(self, str.getSelf()); }
		public bool writeString(string str) { return tsStream_writeString_s(self, str); }
		public string readString(char term, ref byte status, uint size = Base.Maxu32) { return Base.getString(tsStream_readString_cbru(self, term, ref status, size)); }
		public string readString(char term, uint size = Base.Maxu32) { byte status = 1; return Base.getString(tsStream_readString_cbru(self, term, ref status, size)); }
		public bool writeString(String str, char term) { return tsStream_writeString_cSc(self, str.getSelf(), term); }
		public bool writeString(string str, char term) { return tsStream_writeString_sc(self, str, term); }
		public string readToken(ref byte status) { return Base.getString(tsStream_readToken_br(self, ref status)); }
		public string readToken() { byte status = 1; return Base.getString(tsStream_readToken_br(self, ref status)); }
		public bool readToken(String dest, bool clear = true) { return tsStream_readToken_Sb(self, dest.getSelf(), clear); }
		public string readLine(ref byte status) { return Base.getString(tsStream_readLine_br(self, ref status)); }
		public string readLine() { byte status = 1; return Base.getString(tsStream_readLine_br(self, ref status)); }
		public bool readLine(String dest, bool empty = false, bool clear = true) { return tsStream_readLine_Sbb(self, dest.getSelf(), empty, clear); }
		public ulong readStream(Stream dest, ulong size, ref byte status) { return tsStream_readStream(self, dest.getSelf(), size, ref status); }
		public ulong readStream(Stream dest, ulong size) { byte status = 1; return tsStream_readStream(self, dest.getSelf(), size, ref status); }
		public ulong writeStream(Stream src, ulong size, ref byte status) { return tsStream_writeStream(self, src.getSelf(), size, ref status); }
		public ulong writeStream(Stream src, ulong size) { byte status = 1; return tsStream_writeStream(self, src.getSelf(), size, ref status); }
		public ulong readZip(IntPtr dest, ulong size) { return tsStream_readZip(self, dest, size); }
		public ulong readZip<Type>(ref Type[] dest) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			ulong ret_ = readZip(ptr_, (ulong)size_);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong writeZip(IntPtr src, ulong size, int level = -1) { return tsStream_writeZip(self, src, size, level); }
		public ulong writeZip<Type>(Type[] src, int level = -1) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = writeZip(ptr_, (ulong)size_, level);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong writeZipFast(IntPtr src, ulong size) { return tsStream_writeZipFast(self, src, size); }
		public ulong writeZipFast<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = writeZipFast(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong writeZipBest(IntPtr src, ulong size) { return tsStream_writeZipBest(self, src, size); }
		public ulong writeZipBest<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = writeZipBest(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong readLz4(IntPtr dest, ulong size) { return tsStream_readLz4(self, dest, size); }
		public ulong readLz4<Type>(ref Type[] dest) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			ulong ret_ = readLz4(ptr_, (ulong)size_);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong writeLz4(IntPtr src, ulong size, int level = -1) { return tsStream_writeLz4(self, src, size, level); }
		public ulong writeLz4<Type>(Type[] src, int level = -1) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = writeLz4(ptr_, (ulong)size_, level);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong writeLz4Fast(IntPtr src, ulong size) { return tsStream_writeLz4Fast(self, src, size); }
		public ulong writeLz4Fast<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = writeLz4Fast(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong writeLz4Best(IntPtr src, ulong size) { return tsStream_writeLz4Best(self, src, size); }
		public ulong writeLz4Best<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			ulong ret_ = writeLz4Best(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong decodeZip(Stream src, ulong size, ref byte status, int window = 15) { return tsStream_decodeZip(self, src.getSelf(), size, ref status, window); }
		public ulong decodeZip(Stream src, ulong size, int window = 15) { byte status = 1; return tsStream_decodeZip(self, src.getSelf(), size, ref status, window); }
		public ulong encodeZip(Stream dest, ulong size, ref byte status, int level = -1) { return tsStream_encodeZip(self, dest.getSelf(), size, ref status, level); }
		public ulong encodeZip(Stream dest, ulong size, int level = -1) { byte status = 1; return tsStream_encodeZip(self, dest.getSelf(), size, ref status, level); }
		public ulong encodeZipFast(Stream dest, ulong size, ref byte status) { return tsStream_encodeZipFast(self, dest.getSelf(), size, ref status); }
		public ulong encodeZipFast(Stream dest, ulong size) { byte status = 1; return tsStream_encodeZipFast(self, dest.getSelf(), size, ref status); }
		public ulong encodeZipBest(Stream dest, ulong size, ref byte status) { return tsStream_encodeZipBest(self, dest.getSelf(), size, ref status); }
		public ulong encodeZipBest(Stream dest, ulong size) { byte status = 1; return tsStream_encodeZipBest(self, dest.getSelf(), size, ref status); }
		public ulong decodeLz4(Stream src, ulong size, ref byte status) { return tsStream_decodeLz4(self, src.getSelf(), size, ref status); }
		public ulong decodeLz4(Stream src, ulong size) { byte status = 1; return tsStream_decodeLz4(self, src.getSelf(), size, ref status); }
		public ulong encodeLz4(Stream dest, ulong size, ref byte status, int level = -1) { return tsStream_encodeLz4(self, dest.getSelf(), size, ref status, level); }
		public ulong encodeLz4(Stream dest, ulong size, int level = -1) { byte status = 1; return tsStream_encodeLz4(self, dest.getSelf(), size, ref status, level); }
		public ulong encodeLz4Fast(Stream dest, ulong size, ref byte status) { return tsStream_encodeLz4Fast(self, dest.getSelf(), size, ref status); }
		public ulong encodeLz4Fast(Stream dest, ulong size) { byte status = 1; return tsStream_encodeLz4Fast(self, dest.getSelf(), size, ref status); }
		public ulong encodeLz4Best(Stream dest, ulong size, ref byte status) { return tsStream_encodeLz4Best(self, dest.getSelf(), size, ref status); }
		public ulong encodeLz4Best(Stream dest, ulong size) { byte status = 1; return tsStream_encodeLz4Best(self, dest.getSelf(), size, ref status); }
		public override string ToString() { return "Tellusim.Stream: Valid: " + tsStream_isValidPtr(self) + "; Owner: " + tsStream_isOwnerPtr(self) + "; Const: " + tsStream_isConstPtr(self) + "; Count: " + tsStream_getCountPtr(self) + "; Internal: 0x" + tsStream_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Stream ptr) { return (ptr != null && tsStream_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsStream_new();
		[DllImport(Base.Import)] private static extern void tsStream_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsStream_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsStream_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsStream_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsStream_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsStream_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_move(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_isOpened(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_isMapped(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_isAvailable(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsStream_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsStream_tell(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_seek(HandleRef self, ulong offset);
		[DllImport(Base.Import)] private static extern bool tsStream_seekBack(HandleRef self, ulong offset);
		[DllImport(Base.Import)] private static extern bool tsStream_seekCur(HandleRef self, long offset);
		[DllImport(Base.Import)] private static extern byte[] tsStream_getData(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsStream_read(HandleRef self, IntPtr dest, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_write(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsStream_flush(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsStream_puts_s(HandleRef self, string str);
		[DllImport(Base.Import)] private static extern bool tsStream_puts_cS(HandleRef self, HandleRef str);
		[DllImport(Base.Import)] private static extern bool tsStream_printf(HandleRef self, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_gets(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern sbyte tsStream_readi8(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writei8(HandleRef self, sbyte value);
		[DllImport(Base.Import)] private static extern byte tsStream_readu8(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeu8(HandleRef self, byte value);
		[DllImport(Base.Import)] private static extern short tsStream_readi16(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writei16(HandleRef self, short value);
		[DllImport(Base.Import)] private static extern ushort tsStream_readu16(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeu16(HandleRef self, ushort value);
		[DllImport(Base.Import)] private static extern int tsStream_readi32(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writei32(HandleRef self, int value);
		[DllImport(Base.Import)] private static extern uint tsStream_readu32(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeu32(HandleRef self, uint value);
		[DllImport(Base.Import)] private static extern long tsStream_readi64(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writei64(HandleRef self, long value);
		[DllImport(Base.Import)] private static extern ulong tsStream_readu64(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeu64(HandleRef self, ulong value);
		[DllImport(Base.Import)] private static extern float tsStream_readf32(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writef32(HandleRef self, float value);
		[DllImport(Base.Import)] private static extern double tsStream_readf64(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writef64(HandleRef self, double value);
		[DllImport(Base.Import)] private static extern int tsStream_readi32e(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writei32e(HandleRef self, int value);
		[DllImport(Base.Import)] private static extern uint tsStream_readu32e(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeu32e(HandleRef self, uint value);
		[DllImport(Base.Import)] private static extern long tsStream_readi64e(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writei64e(HandleRef self, long value);
		[DllImport(Base.Import)] private static extern ulong tsStream_readu64e(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeu64e(HandleRef self, ulong value);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_readString_br(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_writeString_cS(HandleRef self, HandleRef str);
		[DllImport(Base.Import)] private static extern bool tsStream_writeString_s(HandleRef self, string str);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_readString_cbru(HandleRef self, char term, ref byte status, uint size);
		[DllImport(Base.Import)] private static extern bool tsStream_writeString_cSc(HandleRef self, HandleRef str, char term);
		[DllImport(Base.Import)] private static extern bool tsStream_writeString_sc(HandleRef self, string str, char term);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_readToken_br(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_readToken_Sb(HandleRef self, HandleRef dest, bool clear);
		[DllImport(Base.Import)] private static extern IntPtr tsStream_readLine_br(HandleRef self, ref byte status);
		[DllImport(Base.Import)] private static extern bool tsStream_readLine_Sbb(HandleRef self, HandleRef dest, bool empty, bool clear);
		[DllImport(Base.Import)] private static extern ulong tsStream_readStream(HandleRef self, HandleRef dest, ulong size, ref byte status);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeStream(HandleRef self, HandleRef src, ulong size, ref byte status);
		[DllImport(Base.Import)] private static extern ulong tsStream_readZip(HandleRef self, IntPtr dest, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeZip(HandleRef self, IntPtr src, ulong size, int level);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeZipFast(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeZipBest(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_readLz4(HandleRef self, IntPtr dest, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeLz4(HandleRef self, IntPtr src, ulong size, int level);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeLz4Fast(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_writeLz4Best(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsStream_decodeZip(HandleRef self, HandleRef src, ulong size, ref byte status, int window);
		[DllImport(Base.Import)] private static extern ulong tsStream_encodeZip(HandleRef self, HandleRef dest, ulong size, ref byte status, int level);
		[DllImport(Base.Import)] private static extern ulong tsStream_encodeZipFast(HandleRef self, HandleRef dest, ulong size, ref byte status);
		[DllImport(Base.Import)] private static extern ulong tsStream_encodeZipBest(HandleRef self, HandleRef dest, ulong size, ref byte status);
		[DllImport(Base.Import)] private static extern ulong tsStream_decodeLz4(HandleRef self, HandleRef src, ulong size, ref byte status);
		[DllImport(Base.Import)] private static extern ulong tsStream_encodeLz4(HandleRef self, HandleRef dest, ulong size, ref byte status, int level);
		[DllImport(Base.Import)] private static extern ulong tsStream_encodeLz4Fast(HandleRef self, HandleRef dest, ulong size, ref byte status);
		[DllImport(Base.Import)] private static extern ulong tsStream_encodeLz4Best(HandleRef self, HandleRef dest, ulong size, ref byte status);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::Blob
	public sealed class Blob : Stream {
		public Blob(string name = "") { self = new HandleRef(this, tsBlob_new_s(name)); owner = true; }
		public Blob(String name) { self = new HandleRef(this, tsBlob_new_cS(name.getSelf())); owner = true; }
		public Blob(ulong size, string name = "") { self = new HandleRef(this, tsBlob_new_zs(size, name)); owner = true; }
		public Blob(byte[] data, ulong size, string name = "") { self = new HandleRef(this, tsBlob_new_u8pzs(data, size, name)); owner = true; }
		public Blob(byte[] blob, string name = "") { self = new HandleRef(this, tsBlob_new_bls(blob, name)); owner = true; }
		public Blob(Blob blob, bool move) { self = new HandleRef(this, tsBlob_new_cBb(blob.getSelf(), move)); owner = true; }
		public Blob(Blob ptr) { self = new HandleRef(this, tsBlob_copyPtr(ptr.getSelf())); owner = true; }
		public Blob(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsBlob_isOwnerPtr(self); }
		public static new Blob Null() { return new Blob(IntPtr.Zero); }
		public void release() { tsBlob_release(self); }
		public void clear() { tsBlob_clear(self); }
		public void setName(string name) { tsBlob_setName_s(self, name); }
		public void setName(String name) { tsBlob_setName_cS(self, name.getSelf()); }
		public void setSize(ulong size) { tsBlob_setSize(self, size); }
		public void setCapacity(ulong size) { tsBlob_setCapacity(self, size); }
		public ulong getCapacity() { return tsBlob_getCapacity(self); }
		public bool setData(byte[] data, ulong size) { return tsBlob_setData_u8pz(self, data, size); }
		public bool setData(byte[] blob) { return tsBlob_setData_bl(self, blob); }
		public bool setData(Blob blob) { return tsBlob_setData_cB(self, blob.getSelf()); }
		public new byte[] getData() { return tsBlob_getData_c(self); }
		public string encodeBase64(ulong size = 0) { return Base.getString(tsBlob_encodeBase64(self, size)); }
		public bool decodeBase64(string src) { return tsBlob_decodeBase64(self, src); }
		public void getMD5(uint[] hash, ulong size = 0) { tsBlob_getMD5_urz(self, hash, size); }
		public string getMD5(ulong size = 0) { return Base.getString(tsBlob_getMD5_z(self, size)); }
		public static string getMD5(String str) { return Base.getString(tsBlob_getMD5_cS(str.getSelf())); }
		public static string getMD5(IntPtr src, ulong size) { return Base.getString(tsBlob_getMD5_pz(src, size)); }
		public static string getMD5<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			string ret_ = getMD5(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public static string getMD5(Stream src, ulong size = 0) { return Base.getString(tsBlob_getMD5_Stz(src.getSelf(), size)); }
		public void getSHA1(uint[] hash, ulong size = 0) { tsBlob_getSHA1_urz(self, hash, size); }
		public string getSHA1(ulong size = 0) { return Base.getString(tsBlob_getSHA1_z(self, size)); }
		public static string getSHA1(String str) { return Base.getString(tsBlob_getSHA1_cS(str.getSelf())); }
		public static string getSHA1(IntPtr src, ulong size) { return Base.getString(tsBlob_getSHA1_pz(src, size)); }
		public static string getSHA1<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			string ret_ = getSHA1(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public static string getSHA1(Stream src, ulong size = 0) { return Base.getString(tsBlob_getSHA1_Stz(src.getSelf(), size)); }
		public override string ToString() { return "Tellusim.Blob: Valid: " + tsBlob_isValidPtr(self) + "; Owner: " + tsBlob_isOwnerPtr(self) + "; Const: " + tsBlob_isConstPtr(self) + "; Count: " + tsBlob_getCountPtr(self) + "; Internal: 0x" + tsBlob_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Blob ptr) { return (ptr != null && tsBlob_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_new_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_new_zs(ulong size, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_new_u8pzs(byte[] data, ulong size, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_new_bls(byte[] blob, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_new_cBb(HandleRef blob, bool move);
		[DllImport(Base.Import)] private static extern void tsBlob_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBlob_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBlob_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBlob_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBlob_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBlob_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_release(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBlob_setName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsBlob_setName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern void tsBlob_setSize(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern void tsBlob_setCapacity(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsBlob_getCapacity(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBlob_setData_u8pz(HandleRef self, byte[] data, ulong size);
		[DllImport(Base.Import)] private static extern bool tsBlob_setData_bl(HandleRef self, byte[] blob);
		[DllImport(Base.Import)] private static extern bool tsBlob_setData_cB(HandleRef self, HandleRef blob);
		[DllImport(Base.Import)] private static extern byte[] tsBlob_getData_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_encodeBase64(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern bool tsBlob_decodeBase64(HandleRef self, string src);
		[DllImport(Base.Import)] private static extern void tsBlob_getMD5_urz(HandleRef self, uint[] hash, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getMD5_z(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getMD5_cS(HandleRef str);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getMD5_pz(IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getMD5_Stz(HandleRef src, ulong size);
		[DllImport(Base.Import)] private static extern void tsBlob_getSHA1_urz(HandleRef self, uint[] hash, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getSHA1_z(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getSHA1_cS(HandleRef str);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getSHA1_pz(IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsBlob_getSHA1_Stz(HandleRef src, ulong size);
	}
	
	// Tellusim::File
	public sealed class File : Stream {
		public File() { self = new HandleRef(this, tsFile_new()); owner = true; }
		public File(File ptr) { self = new HandleRef(this, tsFile_copyPtr(ptr.getSelf())); owner = true; }
		public File(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFile_isOwnerPtr(self); }
		public static new File Null() { return new File(IntPtr.Zero); }
		public bool open(string name, string mode) { return tsFile_open_ss(self, name, mode); }
		public bool open(String name, string mode) { return tsFile_open_cSs(self, name.getSelf(), mode); }
		public bool open(int fd, string name, string mode) { return tsFile_open_iss(self, fd, name, mode); }
		public bool popen(string command, string mode) { return tsFile_popen_ss(self, command, mode); }
		public bool popen(String command, string mode) { return tsFile_popen_cSs(self, command.getSelf(), mode); }
		public void close() { tsFile_close(self); }
		public static bool isFile(string name) { return tsFile_isFile_s(name); }
		public static bool isFile(String name) { return tsFile_isFile_cS(name.getSelf()); }
		public static ulong getMTime(string name) { return tsFile_getMTime(name); }
		public static ulong getSize(string name) { return tsFile_getSize(name); }
		public static bool remove(string name) { return tsFile_remove(name); }
		public override string ToString() { return "Tellusim.File: Valid: " + tsFile_isValidPtr(self) + "; Owner: " + tsFile_isOwnerPtr(self) + "; Const: " + tsFile_isConstPtr(self) + "; Count: " + tsFile_getCountPtr(self) + "; Internal: 0x" + tsFile_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(File ptr) { return (ptr != null && tsFile_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFile_new();
		[DllImport(Base.Import)] private static extern void tsFile_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFile_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFile_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFile_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFile_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFile_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFile_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFile_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFile_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFile_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFile_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFile_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFile_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFile_open_ss(HandleRef self, string name, string mode);
		[DllImport(Base.Import)] private static extern bool tsFile_open_cSs(HandleRef self, HandleRef name, string mode);
		[DllImport(Base.Import)] private static extern bool tsFile_open_iss(HandleRef self, int fd, string name, string mode);
		[DllImport(Base.Import)] private static extern bool tsFile_popen_ss(HandleRef self, string command, string mode);
		[DllImport(Base.Import)] private static extern bool tsFile_popen_cSs(HandleRef self, HandleRef command, string mode);
		[DllImport(Base.Import)] private static extern void tsFile_close(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFile_isFile_s(string name);
		[DllImport(Base.Import)] private static extern bool tsFile_isFile_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern ulong tsFile_getMTime(string name);
		[DllImport(Base.Import)] private static extern ulong tsFile_getSize(string name);
		[DllImport(Base.Import)] private static extern bool tsFile_remove(string name);
	}
	
	// Tellusim::Socket
	public class Socket : Stream {
		public enum Type : uint {
			Stream = 0,
			Datagram,
			NumTypes,
		}
		public Socket(Type type = Type.Stream) { self = new HandleRef(this, tsSocket_new(type)); owner = true; }
		public Socket(Socket ptr) { self = new HandleRef(this, tsSocket_copyPtr(ptr.getSelf())); owner = true; }
		public Socket(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSocket_isOwnerPtr(self); }
		public static new Socket Null() { return new Socket(IntPtr.Zero); }
		public bool open(ushort port, ushort num = 32) { return tsSocket_open_u16u16(self, port, num); }
		public bool open(string name, ushort port) { return tsSocket_open_su16(self, name, port); }
		public bool open(String name, ushort port) { return tsSocket_open_cSu16(self, name.getSelf(), port); }
		public void close() { tsSocket_close(self); }
		public bool connect(uint sec, uint usec = 0) { return tsSocket_connect(self, sec, usec); }
		public bool accept(Socket socket) { return tsSocket_accept(self, socket.getSelf()); }
		public bool select(uint sec, uint usec = 0) { return tsSocket_select(self, sec, usec); }
		public bool setTimeout(uint sec) { return tsSocket_setTimeout(self, sec); }
		public uint getTimeout() { return tsSocket_getTimeout(self); }
		public bool setBlock(bool block) { return tsSocket_setBlock(self, block); }
		public bool getBlock() { return tsSocket_getBlock(self); }
		public bool setDelay(bool delay) { return tsSocket_setDelay(self, delay); }
		public bool getDelay() { return tsSocket_getDelay(self); }
		public void setName(string name) { tsSocket_setName_s(self, name); }
		public void setName(String name) { tsSocket_setName_cS(self, name.getSelf()); }
		public ushort getPort() { return tsSocket_getPort(self); }
		public int getFD() { return tsSocket_getFD(self); }
		public Type getType() { return tsSocket_getType(self); }
		public static string getAddress(string delimiter = "") { return Base.getString(tsSocket_getAddress(delimiter)); }
		public override string ToString() { return "Tellusim.Socket: Valid: " + tsSocket_isValidPtr(self) + "; Owner: " + tsSocket_isOwnerPtr(self) + "; Const: " + tsSocket_isConstPtr(self) + "; Count: " + tsSocket_getCountPtr(self) + "; Internal: 0x" + tsSocket_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Socket ptr) { return (ptr != null && tsSocket_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSocket_new(Type type);
		[DllImport(Base.Import)] private static extern void tsSocket_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSocket_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSocket_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocket_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocket_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocket_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocket_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSocket_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSocket_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_open_u16u16(HandleRef self, ushort port, ushort num);
		[DllImport(Base.Import)] private static extern bool tsSocket_open_su16(HandleRef self, string name, ushort port);
		[DllImport(Base.Import)] private static extern bool tsSocket_open_cSu16(HandleRef self, HandleRef name, ushort port);
		[DllImport(Base.Import)] private static extern void tsSocket_close(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_connect(HandleRef self, uint sec, uint usec);
		[DllImport(Base.Import)] private static extern bool tsSocket_accept(HandleRef self, HandleRef socket);
		[DllImport(Base.Import)] private static extern bool tsSocket_select(HandleRef self, uint sec, uint usec);
		[DllImport(Base.Import)] private static extern bool tsSocket_setTimeout(HandleRef self, uint sec);
		[DllImport(Base.Import)] private static extern uint tsSocket_getTimeout(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_setBlock(HandleRef self, bool block);
		[DllImport(Base.Import)] private static extern bool tsSocket_getBlock(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocket_setDelay(HandleRef self, bool delay);
		[DllImport(Base.Import)] private static extern bool tsSocket_getDelay(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocket_setName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsSocket_setName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern ushort tsSocket_getPort(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsSocket_getFD(HandleRef self);
		[DllImport(Base.Import)] private static extern Type tsSocket_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSocket_getAddress(string delimiter);
	}
	
	// Tellusim::SocketSSL
	public sealed class SocketSSL : Socket {
		public SocketSSL() { self = new HandleRef(this, tsSocketSSL_new()); owner = true; }
		public SocketSSL(SocketSSL ptr) { self = new HandleRef(this, tsSocketSSL_copyPtr(ptr.getSelf())); owner = true; }
		public SocketSSL(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSocketSSL_isOwnerPtr(self); }
		public SocketSSL(Socket ptr) { self = new HandleRef(this, tsSocketSSL_castSocketPtr(ptr.getSelf())); }
		public Socket toSocket() { return new Socket(tsSocketSSL_baseSocketPtr(self)); }
		public static new SocketSSL Null() { return new SocketSSL(IntPtr.Zero); }
		public bool handshake(string name = "") { return tsSocketSSL_handshake(self, name); }
		public bool accept(SocketSSL socket) { return tsSocketSSL_accept_SS(self, socket.getSelf()); }
		public new bool accept(Socket socket) { return tsSocketSSL_accept_S(self, socket.getSelf()); }
		public bool load(Stream stream) { return tsSocketSSL_load_St(self, stream.getSelf()); }
		public bool load(string name) { return tsSocketSSL_load_s(self, name); }
		public bool load(String name) { return tsSocketSSL_load_cS(self, name.getSelf()); }
		public bool isConnected() { return tsSocketSSL_isConnected(self); }
		public override string ToString() { return "Tellusim.SocketSSL: Valid: " + tsSocketSSL_isValidPtr(self) + "; Owner: " + tsSocketSSL_isOwnerPtr(self) + "; Const: " + tsSocketSSL_isConstPtr(self) + "; Count: " + tsSocketSSL_getCountPtr(self) + "; Internal: 0x" + tsSocketSSL_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(SocketSSL ptr) { return (ptr != null && tsSocketSSL_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSocketSSL_new();
		[DllImport(Base.Import)] private static extern void tsSocketSSL_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSocketSSL_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSocketSSL_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocketSSL_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocketSSL_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocketSSL_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSocketSSL_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSocketSSL_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSocketSSL_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_equalSocketPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSocketSSL_castSocketPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSocketSSL_baseSocketPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_handshake(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_accept_SS(HandleRef self, HandleRef socket);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_accept_S(HandleRef self, HandleRef socket);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_load_St(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_load_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_load_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsSocketSSL_isConnected(HandleRef self);
	}
	
	// Tellusim::Source
	public sealed class Source : Stream {
		public delegate bool IsCallback(string name, IntPtr data);
		public delegate Stream OpenCallback(string name, IntPtr data);
		public Source() { self = new HandleRef(this, tsSource_new()); owner = true; }
		public Source(byte[] data, ulong size, string name = "") { self = new HandleRef(this, tsSource_new_u8pzs(data, size, name)); owner = true; }
		public Source(Source ptr) { self = new HandleRef(this, tsSource_copyPtr(ptr.getSelf())); owner = true; }
		public Source(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSource_isOwnerPtr(self); }
		public static new Source Null() { return new Source(IntPtr.Zero); }
		public bool open(string name, bool callback = true, bool write = false) { return tsSource_open_sbb(self, name, callback, write); }
		public bool open(String name, bool callback = true, bool write = false) { return tsSource_open_cSbb(self, name.getSelf(), callback, write); }
		public void close() { tsSource_close(self); }
		public void setName(string name, ulong offset, ulong size) { tsSource_setName_szz(self, name, offset, size); }
		public void setName(String name, ulong offset, ulong size) { tsSource_setName_cSzz(self, name.getSelf(), offset, size); }
		public void setData(byte[] data, ulong size, string name = "") { tsSource_setData(self, data, size, name); }
		public static bool isSource(string name) { return tsSource_isSource_s(name); }
		public static bool isSource(String name) { return tsSource_isSource_cS(name.getSelf()); }
		public static ulong getMTime(string name) { return tsSource_getMTime(name); }
		public static ulong getSize(string name) { return tsSource_getSize(name); }
		public static void setCallback(OpenCallback open_func, IntPtr data = new IntPtr()) {
			if(open_func != null) OpenCallback_12 = GCHandle.Alloc(open_func);
			tsSource_setCallback_SOCpr(Base.getFunc(open_func), data);
		}
		public static void setCallback(OpenCallback open_func, IsCallback is_func, IntPtr data = new IntPtr()) {
			if(open_func != null) OpenCallback_13 = GCHandle.Alloc(open_func);
			if(is_func != null) IsCallback_13 = GCHandle.Alloc(is_func);
			tsSource_setCallback_SOCSICpr(Base.getFunc(open_func), Base.getFunc(is_func), data);
		}
		public static IntPtr getCallbackData() { return tsSource_getCallbackData(); }
		private static GCHandle OpenCallback_12;
		private static GCHandle IsCallback_13;
		private static GCHandle OpenCallback_13;
		public override string ToString() { return "Tellusim.Source: Valid: " + tsSource_isValidPtr(self) + "; Owner: " + tsSource_isOwnerPtr(self) + "; Const: " + tsSource_isConstPtr(self) + "; Count: " + tsSource_getCountPtr(self) + "; Internal: 0x" + tsSource_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Source ptr) { return (ptr != null && tsSource_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSource_new();
		[DllImport(Base.Import)] private static extern IntPtr tsSource_new_u8pzs(byte[] data, ulong size, string name);
		[DllImport(Base.Import)] private static extern void tsSource_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSource_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSource_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSource_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSource_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSource_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSource_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSource_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSource_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSource_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSource_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSource_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSource_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSource_open_sbb(HandleRef self, string name, bool callback, bool write);
		[DllImport(Base.Import)] private static extern bool tsSource_open_cSbb(HandleRef self, HandleRef name, bool callback, bool write);
		[DllImport(Base.Import)] private static extern void tsSource_close(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSource_setName_szz(HandleRef self, string name, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern void tsSource_setName_cSzz(HandleRef self, HandleRef name, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern void tsSource_setData(HandleRef self, byte[] data, ulong size, string name);
		[DllImport(Base.Import)] private static extern bool tsSource_isSource_s(string name);
		[DllImport(Base.Import)] private static extern bool tsSource_isSource_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern ulong tsSource_getMTime(string name);
		[DllImport(Base.Import)] private static extern ulong tsSource_getSize(string name);
		[DllImport(Base.Import)] private static extern void tsSource_setCallback_SOCpr(IntPtr open_func, IntPtr data);
		[DllImport(Base.Import)] private static extern void tsSource_setCallback_SOCSICpr(IntPtr open_func, IntPtr is_func, IntPtr data);
		[DllImport(Base.Import)] private static extern IntPtr tsSource_getCallbackData();
	}
	
	// Tellusim::Date
	public sealed class Date {
		public Date() { self = new HandleRef(this, tsDate_new()); owner = true; }
		public Date(long time, bool local = true) { self = new HandleRef(this, tsDate_new_i64b(time, local)); owner = true; }
		public Date(string str, string format = "") { self = new HandleRef(this, tsDate_new_ss(str, format)); owner = true; }
		public Date(Date ptr) { self = new HandleRef(this, tsDate_copyPtr(ptr.getSelf())); owner = true; }
		public Date(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDate_isOwnerPtr(self); }
		public static Date Null() { return new Date(IntPtr.Zero); }
		~Date() { if(owner) tsDate_delete(self); }
		public bool equalPtr(Date ptr) { return tsDate_equalPtr(self, ptr.getSelf()); }
		public Date clonePtr() { return new Date(tsDate_clonePtr(self)); }
		public void clearPtr() { tsDate_clearPtr(self); }
		public void destroyPtr() { tsDate_destroyPtr(self); }
		public void acquirePtr() { tsDate_acquirePtr(self); }
		public void unacquirePtr() { tsDate_unacquirePtr(self); }
		public bool isValidPtr() { return tsDate_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDate_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDate_isConstPtr(self); }
		public uint getCountPtr() { return tsDate_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDate_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsDate_clear(self); }
		public void setTime(long time, bool local = true) { tsDate_setTime(self, time, local); }
		public long getTime(bool local = true) { return tsDate_getTime(self, local); }
		public bool setString(string str, string format = "") { return tsDate_setString(self, str, format); }
		public string getString(string format = "") { return Base.getString(tsDate_getString(self, format)); }
		public void setYear(uint year) { tsDate_setYear(self, year); }
		public void setMonth(uint month) { tsDate_setMonth(self, month); }
		public void setDate(uint date) { tsDate_setDate(self, date); }
		public void setDay(uint day) { tsDate_setDay(self, day); }
		public void setHours(uint hours) { tsDate_setHours(self, hours); }
		public void setMinutes(uint minutes) { tsDate_setMinutes(self, minutes); }
		public void setSeconds(uint seconds) { tsDate_setSeconds(self, seconds); }
		public uint getYear() { return tsDate_getYear(self); }
		public uint getMonth() { return tsDate_getMonth(self); }
		public uint getDate() { return tsDate_getDate(self); }
		public uint getDay() { return tsDate_getDay(self); }
		public uint getHours() { return tsDate_getHours(self); }
		public uint getMinutes() { return tsDate_getMinutes(self); }
		public uint getSeconds() { return tsDate_getSeconds(self); }
		public static int getTimeZone() { return tsDate_getTimeZone(); }
		public override string ToString() { return "Tellusim.Date: Valid: " + tsDate_isValidPtr(self) + "; Owner: " + tsDate_isOwnerPtr(self) + "; Const: " + tsDate_isConstPtr(self) + "; Count: " + tsDate_getCountPtr(self) + "; Internal: 0x" + tsDate_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Date ptr) { return (ptr != null && tsDate_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDate_new();
		[DllImport(Base.Import)] private static extern IntPtr tsDate_new_i64b(long time, bool local);
		[DllImport(Base.Import)] private static extern IntPtr tsDate_new_ss(string str, string format);
		[DllImport(Base.Import)] private static extern void tsDate_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDate_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDate_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDate_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDate_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDate_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDate_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDate_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDate_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDate_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDate_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDate_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDate_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDate_setTime(HandleRef self, long time, bool local);
		[DllImport(Base.Import)] private static extern long tsDate_getTime(HandleRef self, bool local);
		[DllImport(Base.Import)] private static extern bool tsDate_setString(HandleRef self, string str, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsDate_getString(HandleRef self, string format);
		[DllImport(Base.Import)] private static extern void tsDate_setYear(HandleRef self, uint year);
		[DllImport(Base.Import)] private static extern void tsDate_setMonth(HandleRef self, uint month);
		[DllImport(Base.Import)] private static extern void tsDate_setDate(HandleRef self, uint date);
		[DllImport(Base.Import)] private static extern void tsDate_setDay(HandleRef self, uint day);
		[DllImport(Base.Import)] private static extern void tsDate_setHours(HandleRef self, uint hours);
		[DllImport(Base.Import)] private static extern void tsDate_setMinutes(HandleRef self, uint minutes);
		[DllImport(Base.Import)] private static extern void tsDate_setSeconds(HandleRef self, uint seconds);
		[DllImport(Base.Import)] private static extern uint tsDate_getYear(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getMonth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getDate(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getDay(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getHours(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getMinutes(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDate_getSeconds(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDate_getTimeZone();
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Info
	public sealed class Info {
		public Info() { self = new HandleRef(this, tsInfo_new()); owner = true; }
		public Info(Info ptr) { self = new HandleRef(this, tsInfo_copyPtr(ptr.getSelf())); owner = true; }
		public Info(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsInfo_isOwnerPtr(self); }
		public static Info Null() { return new Info(IntPtr.Zero); }
		~Info() { if(owner) tsInfo_delete(self); }
		public bool equalPtr(Info ptr) { return tsInfo_equalPtr(self, ptr.getSelf()); }
		public Info clonePtr() { return new Info(tsInfo_clonePtr(self)); }
		public void clearPtr() { tsInfo_clearPtr(self); }
		public void destroyPtr() { tsInfo_destroyPtr(self); }
		public void acquirePtr() { tsInfo_acquirePtr(self); }
		public void unacquirePtr() { tsInfo_unacquirePtr(self); }
		public bool isValidPtr() { return tsInfo_isValidPtr(self); }
		public bool isOwnerPtr() { return tsInfo_isOwnerPtr(self); }
		public bool isConstPtr() { return tsInfo_isConstPtr(self); }
		public uint getCountPtr() { return tsInfo_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsInfo_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public ulong getSystemMemory() { return tsInfo_getSystemMemory(self); }
		public ulong getSystemUptime() { return tsInfo_getSystemUptime(self); }
		public string getSystemName() { return Base.getString(tsInfo_getSystemName(self)); }
		public string getSystemVersion() { return Base.getString(tsInfo_getSystemVersion(self)); }
		public string getKernelVersion() { return Base.getString(tsInfo_getKernelVersion(self)); }
		public uint getCPUCount() { return tsInfo_getCPUCount(self); }
		public string getCPUName(uint index) { return Base.getString(tsInfo_getCPUName(self, index)); }
		public string getCPUVendor(uint index) { return Base.getString(tsInfo_getCPUVendor(self, index)); }
		public uint getCPUCores(uint index) { return tsInfo_getCPUCores(self, index); }
		public uint getCPUThreads(uint index) { return tsInfo_getCPUThreads(self, index); }
		public ulong getCPUFrequency(uint index) { return tsInfo_getCPUFrequency(self, index); }
		public uint getCPUTemperature(uint index) { return tsInfo_getCPUTemperature(self, index); }
		public uint getCPUUtilization(uint index) { return tsInfo_getCPUUtilization(self, index); }
		public uint getCPUFanSpeed(uint index) { return tsInfo_getCPUFanSpeed(self, index); }
		public uint getCPUPower(uint index) { return tsInfo_getCPUPower(self, index); }
		public uint getGPUCount() { return tsInfo_getGPUCount(self); }
		public string getGPUName(uint index) { return Base.getString(tsInfo_getGPUName(self, index)); }
		public string getGPUVendor(uint index) { return Base.getString(tsInfo_getGPUVendor(self, index)); }
		public string getGPUSerial(uint index) { return Base.getString(tsInfo_getGPUSerial(self, index)); }
		public string getGPUDevice(uint index) { return Base.getString(tsInfo_getGPUDevice(self, index)); }
		public string getGPUVersion(uint index) { return Base.getString(tsInfo_getGPUVersion(self, index)); }
		public ulong getGPUMemory(uint index) { return tsInfo_getGPUMemory(self, index); }
		public uint getGPUScreens(uint index) { return tsInfo_getGPUScreens(self, index); }
		public ulong getGPUFrequency(uint index) { return tsInfo_getGPUFrequency(self, index); }
		public uint getGPUTemperature(uint index) { return tsInfo_getGPUTemperature(self, index); }
		public uint getGPUUtilization(uint index) { return tsInfo_getGPUUtilization(self, index); }
		public uint getGPUFanSpeed(uint index) { return tsInfo_getGPUFanSpeed(self, index); }
		public uint getGPUPower(uint index) { return tsInfo_getGPUPower(self, index); }
		public bool isGPUThrottling(uint index) { return tsInfo_isGPUThrottling(self, index); }
		public override string ToString() { return "Tellusim.Info: Valid: " + tsInfo_isValidPtr(self) + "; Owner: " + tsInfo_isOwnerPtr(self) + "; Const: " + tsInfo_isConstPtr(self) + "; Count: " + tsInfo_getCountPtr(self) + "; Internal: 0x" + tsInfo_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Info ptr) { return (ptr != null && tsInfo_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_new();
		[DllImport(Base.Import)] private static extern void tsInfo_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsInfo_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsInfo_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsInfo_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsInfo_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsInfo_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsInfo_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsInfo_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsInfo_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsInfo_getSystemMemory(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsInfo_getSystemUptime(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getSystemName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getSystemVersion(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getKernelVersion(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUCount(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getCPUName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getCPUVendor(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUCores(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUThreads(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsInfo_getCPUFrequency(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUTemperature(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUUtilization(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUFanSpeed(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getCPUPower(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getGPUCount(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getGPUName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getGPUVendor(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getGPUSerial(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getGPUDevice(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsInfo_getGPUVersion(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsInfo_getGPUMemory(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getGPUScreens(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsInfo_getGPUFrequency(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getGPUTemperature(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getGPUUtilization(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getGPUFanSpeed(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsInfo_getGPUPower(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsInfo_isGPUThrottling(HandleRef self, uint index);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Directory
	public sealed class Directory {
		public enum Attributes : uint {
			None = 0,
			Read = 1,
			Write = 2,
			Hidden = 4,
			Execute = 8,
			Temporary = 16,
			NumAttributes = 5,
		}
		public Directory() { self = new HandleRef(this, tsDirectory_new()); owner = true; }
		public Directory(Directory ptr) { self = new HandleRef(this, tsDirectory_copyPtr(ptr.getSelf())); owner = true; }
		public Directory(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDirectory_isOwnerPtr(self); }
		public static Directory Null() { return new Directory(IntPtr.Zero); }
		~Directory() { if(owner) tsDirectory_delete(self); }
		public bool equalPtr(Directory ptr) { return tsDirectory_equalPtr(self, ptr.getSelf()); }
		public Directory clonePtr() { return new Directory(tsDirectory_clonePtr(self)); }
		public void clearPtr() { tsDirectory_clearPtr(self); }
		public void destroyPtr() { tsDirectory_destroyPtr(self); }
		public void acquirePtr() { tsDirectory_acquirePtr(self); }
		public void unacquirePtr() { tsDirectory_unacquirePtr(self); }
		public bool isValidPtr() { return tsDirectory_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDirectory_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDirectory_isConstPtr(self); }
		public uint getCountPtr() { return tsDirectory_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDirectory_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public bool open(string name, bool children = false) { return tsDirectory_open_sb(self, name, children); }
		public bool open(String name, bool children = false) { return tsDirectory_open_cSb(self, name.getSelf(), children); }
		public void close() { tsDirectory_close(self); }
		public bool isOpened() { return tsDirectory_isOpened(self); }
		public string getName() { return Base.getString(tsDirectory_getName(self)); }
		public uint getNumFiles() { return tsDirectory_getNumFiles(self); }
		public string getFileName(uint index) { return Base.getString(tsDirectory_getFileName(self, index)); }
		public Attributes getFileAttributes(uint index) { return tsDirectory_getFileAttributes_cu(self, index); }
		public ulong getFileMTime(uint index) { return tsDirectory_getFileMTime_cu(self, index); }
		public ulong getFileATime(uint index) { return tsDirectory_getFileATime_cu(self, index); }
		public ulong getFileCTime(uint index) { return tsDirectory_getFileCTime_cu(self, index); }
		public ulong getFileSize(uint index) { return tsDirectory_getFileSize_cu(self, index); }
		public uint getNumDirectories() { return tsDirectory_getNumDirectories(self); }
		public string getDirectoryName(uint index) { return Base.getString(tsDirectory_getDirectoryName(self, index)); }
		public Attributes getDirectoryAttributes(uint index) { return tsDirectory_getDirectoryAttributes(self, index); }
		public ulong getDirectoryCTime(uint index) { return tsDirectory_getDirectoryCTime(self, index); }
		public uint getDirectorySize(uint index) { return tsDirectory_getDirectorySize(self, index); }
		public static bool isFile(string name) { return tsDirectory_isFile_s(name); }
		public static bool isFile(String name) { return tsDirectory_isFile_cS(name.getSelf()); }
		public static bool setFileAttributes(string name, Attributes attributes) { return tsDirectory_setFileAttributes(name, attributes); }
		public static Attributes getFileAttributes(string name) { return tsDirectory_getFileAttributes_s(name); }
		public static bool setFileMTime(string name, ulong time) { return tsDirectory_setFileMTime(name, time); }
		public static ulong getFileMTime(string name) { return tsDirectory_getFileMTime_s(name); }
		public static ulong getFileATime(string name) { return tsDirectory_getFileATime_s(name); }
		public static ulong getFileCTime(string name) { return tsDirectory_getFileCTime_s(name); }
		public static ulong getFileSize(string name) { return tsDirectory_getFileSize_s(name); }
		public static ulong getFileSize(String name) { return tsDirectory_getFileSize_cS(name.getSelf()); }
		public static bool removeFile(string name) { return tsDirectory_removeFile_s(name); }
		public static bool removeFile(String name) { return tsDirectory_removeFile_cS(name.getSelf()); }
		public static bool copyFile(string name, string new_name, bool attributes = false) { return tsDirectory_copyFile_ssb(name, new_name, attributes); }
		public static bool copyFile(String name, String new_name, bool attributes = false) { return tsDirectory_copyFile_cScSb(name.getSelf(), new_name.getSelf(), attributes); }
		public static bool isDirectory(string name) { return tsDirectory_isDirectory_s(name); }
		public static bool isDirectory(String name) { return tsDirectory_isDirectory_cS(name.getSelf()); }
		public static bool changeDirectory(string name) { return tsDirectory_changeDirectory_s(name); }
		public static bool changeDirectory(String name) { return tsDirectory_changeDirectory_cS(name.getSelf()); }
		public static bool createDirectory(string name, bool children = false) { return tsDirectory_createDirectory_sb(name, children); }
		public static bool createDirectory(String name, bool children = false) { return tsDirectory_createDirectory_cSb(name.getSelf(), children); }
		public static bool removeDirectory(string name, bool children = false) { return tsDirectory_removeDirectory_sb(name, children); }
		public static bool removeDirectory(String name, bool children = false) { return tsDirectory_removeDirectory_cSb(name.getSelf(), children); }
		public static bool copyDirectory(string name, string new_name, bool attributes = false) { return tsDirectory_copyDirectory_ssb(name, new_name, attributes); }
		public static bool copyDirectory(String name, String new_name, bool attributes = false) { return tsDirectory_copyDirectory_cScSb(name.getSelf(), new_name.getSelf(), attributes); }
		public static bool rename(string name, string new_name) { return tsDirectory_rename_ss(name, new_name); }
		public static bool rename(String name, String new_name) { return tsDirectory_rename_cScS(name.getSelf(), new_name.getSelf()); }
		public static string getCurrentDirectory() { return Base.getString(tsDirectory_getCurrentDirectory()); }
		public static string getBinaryDirectory() { return Base.getString(tsDirectory_getBinaryDirectory()); }
		public static string getHomeDirectory() { return Base.getString(tsDirectory_getHomeDirectory()); }
		public static string getTempDirectory() { return Base.getString(tsDirectory_getTempDirectory()); }
		public static string getConfigDirectory() { return Base.getString(tsDirectory_getConfigDirectory()); }
		public static string getDocumentsDirectory() { return Base.getString(tsDirectory_getDocumentsDirectory()); }
		public override string ToString() { return "Tellusim.Directory: Valid: " + tsDirectory_isValidPtr(self) + "; Owner: " + tsDirectory_isOwnerPtr(self) + "; Const: " + tsDirectory_isConstPtr(self) + "; Count: " + tsDirectory_getCountPtr(self) + "; Internal: 0x" + tsDirectory_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Directory ptr) { return (ptr != null && tsDirectory_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_new();
		[DllImport(Base.Import)] private static extern void tsDirectory_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDirectory_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDirectory_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDirectory_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDirectory_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDirectory_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDirectory_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDirectory_open_sb(HandleRef self, string name, bool children);
		[DllImport(Base.Import)] private static extern bool tsDirectory_open_cSb(HandleRef self, HandleRef name, bool children);
		[DllImport(Base.Import)] private static extern void tsDirectory_close(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isOpened(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDirectory_getNumFiles(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getFileName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Attributes tsDirectory_getFileAttributes_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileMTime_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileATime_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileCTime_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileSize_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDirectory_getNumDirectories(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getDirectoryName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Attributes tsDirectory_getDirectoryAttributes(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getDirectoryCTime(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDirectory_getDirectorySize(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isFile_s(string name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isFile_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_setFileAttributes(string name, Attributes attributes);
		[DllImport(Base.Import)] private static extern Attributes tsDirectory_getFileAttributes_s(string name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_setFileMTime(string name, ulong time);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileMTime_s(string name);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileATime_s(string name);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileCTime_s(string name);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileSize_s(string name);
		[DllImport(Base.Import)] private static extern ulong tsDirectory_getFileSize_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_removeFile_s(string name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_removeFile_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_copyFile_ssb(string name, string new_name, bool attributes);
		[DllImport(Base.Import)] private static extern bool tsDirectory_copyFile_cScSb(HandleRef name, HandleRef new_name, bool attributes);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isDirectory_s(string name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_isDirectory_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_changeDirectory_s(string name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_changeDirectory_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_createDirectory_sb(string name, bool children);
		[DllImport(Base.Import)] private static extern bool tsDirectory_createDirectory_cSb(HandleRef name, bool children);
		[DllImport(Base.Import)] private static extern bool tsDirectory_removeDirectory_sb(string name, bool children);
		[DllImport(Base.Import)] private static extern bool tsDirectory_removeDirectory_cSb(HandleRef name, bool children);
		[DllImport(Base.Import)] private static extern bool tsDirectory_copyDirectory_ssb(string name, string new_name, bool attributes);
		[DllImport(Base.Import)] private static extern bool tsDirectory_copyDirectory_cScSb(HandleRef name, HandleRef new_name, bool attributes);
		[DllImport(Base.Import)] private static extern bool tsDirectory_rename_ss(string name, string new_name);
		[DllImport(Base.Import)] private static extern bool tsDirectory_rename_cScS(HandleRef name, HandleRef new_name);
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getCurrentDirectory();
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getBinaryDirectory();
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getHomeDirectory();
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getTempDirectory();
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getConfigDirectory();
		[DllImport(Base.Import)] private static extern IntPtr tsDirectory_getDocumentsDirectory();
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Archive
	public sealed class Archive {
		public Archive() { self = new HandleRef(this, tsArchive_new()); owner = true; }
		public Archive(Archive ptr) { self = new HandleRef(this, ptr.getSelfPtr()); }
		public Archive(IntPtr ptr) { self = new HandleRef(this, ptr); owner = true; }
		public static Archive Null() { return new Archive(IntPtr.Zero); }
		~Archive() { if(owner) tsArchive_delete(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public bool open(string name, string type = "") { return tsArchive_open_ss(self, name, type); }
		public bool open(String name, string type = "") { return tsArchive_open_cSs(self, name.getSelf(), type); }
		public bool open(Stream stream, string type = "") { return tsArchive_open_Sts(self, stream.getSelf(), type); }
		public void close() { tsArchive_close(self); }
		public bool isOpened() { return tsArchive_isOpened(self); }
		public string getName() { return Base.getString(tsArchive_getName(self)); }
		public uint getNumFiles() { return tsArchive_getNumFiles(self); }
		public string getFileName(uint index) { return Base.getString(tsArchive_getFileName(self, index)); }
		public ulong getFileMTime(uint index) { return tsArchive_getFileMTime(self, index); }
		public ulong getFileSize(uint index) { return tsArchive_getFileSize(self, index); }
		public uint findFile(string name) { return tsArchive_findFile_cs(self, name); }
		public uint findFile(String name) { return tsArchive_findFile_ccS(self, name.getSelf()); }
		public bool isFile(string name) { return tsArchive_isFile_cs(self, name); }
		public bool isFile(String name) { return tsArchive_isFile_ccS(self, name.getSelf()); }
		public Stream openFile(string name) { return new Stream(tsArchive_openFile_cs(self, name)); }
		public Stream openFile(String name) { return new Stream(tsArchive_openFile_ccS(self, name.getSelf())); }
		public Stream openFile(uint index) { return new Stream(tsArchive_openFile_cu(self, index)); }
		public override string ToString() { return "Tellusim.Archive: Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Archive ptr) { return (ptr != null && ptr.getSelfPtr() != IntPtr.Zero); }
		[DllImport(Base.Import)] private static extern IntPtr tsArchive_new();
		[DllImport(Base.Import)] private static extern void tsArchive_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsArchive_open_ss(HandleRef self, string name, string type);
		[DllImport(Base.Import)] private static extern bool tsArchive_open_cSs(HandleRef self, HandleRef name, string type);
		[DllImport(Base.Import)] private static extern bool tsArchive_open_Sts(HandleRef self, HandleRef stream, string type);
		[DllImport(Base.Import)] private static extern void tsArchive_close(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsArchive_isOpened(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsArchive_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsArchive_getNumFiles(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsArchive_getFileName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsArchive_getFileMTime(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsArchive_getFileSize(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsArchive_findFile_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsArchive_findFile_ccS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsArchive_isFile_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsArchive_isFile_ccS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsArchive_openFile_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsArchive_openFile_ccS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsArchive_openFile_cu(HandleRef self, uint index);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Image
	public sealed class Image {
		public enum Type : uint {
			Unknown = 0,
			_2D,
			_3D,
			Cube,
			NumTypes,
		}
		public enum Flags : uint {
			None = 0,
			Mipmaps = 1,
			NoClear = 2,
			NoAllocate = 4,
			Fast = 8,
			Best = 16,
			Perceptual = 32,
			Panorama = 64,
			Normalize = 128,
			Gamma = 256,
			SRGB = 512,
			Num = 10,
		}
		public enum Filter : uint {
			Unknown = 0,
			Point,
			Linear,
			Cubic,
			Sinc,
			Box,
			Max,
			Min,
			Mip,
			CR,
			NumFilters,
		}
		public Image() { self = new HandleRef(this, tsImage_new()); owner = true; }
		public Image(string name, Flags flags = Flags.None, uint offset = 0) { self = new HandleRef(this, tsImage_new_sIFu(name, flags, offset)); owner = true; }
		public Image(Stream stream, Flags flags = Flags.None, uint offset = 0) { self = new HandleRef(this, tsImage_new_StIFu(stream.getSelf(), flags, offset)); owner = true; }
		public Image(Type type, Format format, in Size size, Flags flags = Flags.None) { self = new HandleRef(this, tsImage_new_ITFcSIF(type, format, in size, flags)); owner = true; }
		public Image(Type type, Format format, in Size size, uint layers, Flags flags = Flags.None) { self = new HandleRef(this, tsImage_new_ITFcSuIF(type, format, in size, layers, flags)); owner = true; }
		public Image(Image ptr) { self = new HandleRef(this, tsImage_copyPtr(ptr.getSelf())); owner = true; }
		public Image(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsImage_isOwnerPtr(self); }
		public static Image Null() { return new Image(IntPtr.Zero); }
		~Image() { if(owner) tsImage_delete(self); }
		public bool equalPtr(Image ptr) { return tsImage_equalPtr(self, ptr.getSelf()); }
		public Image clonePtr() { return new Image(tsImage_clonePtr(self)); }
		public void clearPtr() { tsImage_clearPtr(self); }
		public void destroyPtr() { tsImage_destroyPtr(self); }
		public void acquirePtr() { tsImage_acquirePtr(self); }
		public void unacquirePtr() { tsImage_unacquirePtr(self); }
		public bool isValidPtr() { return tsImage_isValidPtr(self); }
		public bool isOwnerPtr() { return tsImage_isOwnerPtr(self); }
		public bool isConstPtr() { return tsImage_isConstPtr(self); }
		public uint getCountPtr() { return tsImage_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsImage_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsImage_clear(self); }
		public bool isLoaded() { return tsImage_isLoaded(self); }
		public bool isAllocated() { return tsImage_isAllocated(self); }
		public Type getType() { return tsImage_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsImage_getTypeName_IT(type)); }
		public string getTypeName() { return Base.getCString(tsImage_getTypeName_c(self)); }
		public bool is2DType() { return tsImage_is2DType(self); }
		public bool is3DType() { return tsImage_is3DType(self); }
		public bool isCubeType() { return tsImage_isCubeType(self); }
		public Format getFormat() { return tsImage_getFormat(self); }
		public string getFormatName() { return Base.getCString(tsImage_getFormatName(self)); }
		public bool isColorFormat() { return tsImage_isColorFormat(self); }
		public bool isDepthFormat() { return tsImage_isDepthFormat(self); }
		public bool isPixelFormat() { return tsImage_isPixelFormat(self); }
		public bool isPlainFormat() { return tsImage_isPlainFormat(self); }
		public bool isMixedFormat() { return tsImage_isMixedFormat(self); }
		public bool isBlockFormat() { return tsImage_isBlockFormat(self); }
		public bool isStencilFormat() { return tsImage_isStencilFormat(self); }
		public bool isNormFormat() { return tsImage_isNormFormat(self); }
		public bool isSRGBFormat() { return tsImage_isSRGBFormat(self); }
		public bool isFloatFormat() { return tsImage_isFloatFormat(self); }
		public bool isSignedFormat() { return tsImage_isSignedFormat(self); }
		public bool isUnsignedFormat() { return tsImage_isUnsignedFormat(self); }
		public bool isIntegerFormat() { return tsImage_isIntegerFormat(self); }
		public bool isi8Format() { return tsImage_isi8Format(self); }
		public bool isu8Format() { return tsImage_isu8Format(self); }
		public bool is8BitFormat() { return tsImage_is8BitFormat(self); }
		public bool isi16Format() { return tsImage_isi16Format(self); }
		public bool isu16Format() { return tsImage_isu16Format(self); }
		public bool isf16Format() { return tsImage_isf16Format(self); }
		public bool is16BitFormat() { return tsImage_is16BitFormat(self); }
		public bool isi32Format() { return tsImage_isi32Format(self); }
		public bool isu32Format() { return tsImage_isu32Format(self); }
		public bool isf32Format() { return tsImage_isf32Format(self); }
		public bool is32BitFormat() { return tsImage_is32BitFormat(self); }
		public bool isi64Format() { return tsImage_isi64Format(self); }
		public bool isu64Format() { return tsImage_isu64Format(self); }
		public bool isf64Format() { return tsImage_isf64Format(self); }
		public bool is64BitFormat() { return tsImage_is64BitFormat(self); }
		public bool isBC15Format() { return tsImage_isBC15Format(self); }
		public bool isBC67Format() { return tsImage_isBC67Format(self); }
		public bool isETC2Format() { return tsImage_isETC2Format(self); }
		public bool isASTCFormat() { return tsImage_isASTCFormat(self); }
		public uint getComponents() { return tsImage_getComponents(self); }
		public uint getPixelSize() { return tsImage_getPixelSize(self); }
		public uint getBlockSize() { return tsImage_getBlockSize(self); }
		public uint getBlockWidth() { return tsImage_getBlockWidth(self); }
		public uint getBlockHeight() { return tsImage_getBlockHeight(self); }
		public uint getWidth() { return tsImage_getWidth_c(self); }
		public uint getHeight() { return tsImage_getHeight_c(self); }
		public uint getDepth() { return tsImage_getDepth_c(self); }
		public uint getFaces() { return tsImage_getFaces(self); }
		public uint getLayers() { return tsImage_getLayers(self); }
		public uint getMipmaps() { return tsImage_getMipmaps(self); }
		public uint findMipmap(in Size size) { return tsImage_findMipmap(self, in size); }
		public uint getWidth(uint mipmap) { return tsImage_getWidth_cu(self, mipmap); }
		public uint getHeight(uint mipmap) { return tsImage_getHeight_cu(self, mipmap); }
		public uint getDepth(uint mipmap) { return tsImage_getDepth_cu(self, mipmap); }
		public bool hasLayers() { return tsImage_hasLayers(self); }
		public bool hasMipmaps() { return tsImage_hasMipmaps(self); }
		public Size getSize() { return tsImage_getSize_c(self); }
		public Region getRegion() { return tsImage_getRegion_c(self); }
		public Slice getSlice() { return tsImage_getSlice_c(self); }
		public Size getSize(uint mipmap) { return tsImage_getSize_cu(self, mipmap); }
		public Region getRegion(uint mipmap) { return tsImage_getRegion_cu(self, mipmap); }
		public Slice getSlice(uint mipmap) { return tsImage_getSlice_cu(self, mipmap); }
		public void setMetaInfo(String str) { tsImage_setMetaInfo(self, str.getSelf()); }
		public string getMetaInfo() { return Base.getString(tsImage_getMetaInfo(self)); }
		public string getDescription() { return Base.getString(tsImage_getDescription(self)); }
		public ulong getOffset(in Slice slice, uint alignment = 1) { return tsImage_getOffset(self, in slice, alignment); }
		public ulong getStride(uint mipmap = 0, uint alignment = 1) { return tsImage_getStride(self, mipmap, alignment); }
		public ulong getMipmapSize(uint mipmap, uint alignment = 1) { return tsImage_getMipmapSize(self, mipmap, alignment); }
		public ulong getLayerSize(uint alignment = 1) { return tsImage_getLayerSize(self, alignment); }
		public ulong getDataSize(uint alignment = 1) { return tsImage_getDataSize(self, alignment); }
		public bool create(Type type, Format format, in Size size, Flags flags = Flags.None) { return tsImage_create_ITFcSIF(self, type, format, in size, flags); }
		public bool create(Type type, Format format, in Size size, uint layers, Flags flags = Flags.None) { return tsImage_create_ITFcSuIF(self, type, format, in size, layers, flags); }
		public bool create2D(Format format, uint size, Flags flags = Flags.None) { return tsImage_create2D_FuIF(self, format, size, flags); }
		public bool create3D(Format format, uint size, Flags flags = Flags.None) { return tsImage_create3D_FuIF(self, format, size, flags); }
		public bool createCube(Format format, uint size, Flags flags = Flags.None) { return tsImage_createCube_FuIF(self, format, size, flags); }
		public bool create2D(Format format, uint width, uint height, Flags flags = Flags.None) { return tsImage_create2D_FuuIF(self, format, width, height, flags); }
		public bool create3D(Format format, uint width, uint height, uint depth, Flags flags = Flags.None) { return tsImage_create3D_FuuuIF(self, format, width, height, depth, flags); }
		public bool create2D(Format format, uint width, uint height, uint layers, Flags flags = Flags.None) { return tsImage_create2D_FuuuIF(self, format, width, height, layers, flags); }
		public bool createCube(Format format, uint size, uint layers, Flags flags = Flags.None) { return tsImage_createCube_FuuIF(self, format, size, layers, flags); }
		public bool info(string name, Flags flags = Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_info_sIFuA(self, name, flags, offset, ref async_);
		}
		public bool info(String name, Flags flags = Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_info_cSIFuA(self, name.getSelf(), flags, offset, ref async_);
		}
		public bool info(Stream stream, Flags flags = Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_info_StIFuA(self, stream.getSelf(), flags, offset, ref async_);
		}
		public bool info(string name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_info_sA(self, name, ref async_);
		}
		public bool info(String name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_info_cSA(self, name.getSelf(), ref async_);
		}
		public bool info(Stream stream, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_info_StA(self, stream.getSelf(), ref async_);
		}
		public bool load(string name, Flags flags = Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_load_sIFuA(self, name, flags, offset, ref async_);
		}
		public bool load(String name, Flags flags = Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_load_cSIFuA(self, name.getSelf(), flags, offset, ref async_);
		}
		public bool load(Stream stream, Flags flags = Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_load_StIFuA(self, stream.getSelf(), flags, offset, ref async_);
		}
		public bool load(string name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_load_sA(self, name, ref async_);
		}
		public bool load(String name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_load_cSA(self, name.getSelf(), ref async_);
		}
		public bool load(Stream stream, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsImage_load_StA(self, stream.getSelf(), ref async_);
		}
		public bool save(string name, Flags flags = Flags.None, uint quality = 95) { return tsImage_save_csIFu(self, name, flags, quality); }
		public bool save(String name, Flags flags = Flags.None, uint quality = 95) { return tsImage_save_ccSIFu(self, name.getSelf(), flags, quality); }
		public bool save(Stream stream, Flags flags = Flags.None, uint quality = 95) { return tsImage_save_cStIFu(self, stream.getSelf(), flags, quality); }
		public bool swap(uint component_0, uint component_1) { return tsImage_swap(self, component_0, component_1); }
		public bool copy(Image src, uint dest_component, uint src_component) { return tsImage_copy_cIuu(self, src.getSelf(), dest_component, src_component); }
		public bool flipX(in Region region, in Slice slice) { return tsImage_flipX_cRcS(self, in region, in slice); }
		public bool flipX(in Region region) { return tsImage_flipX_cR(self, in region); }
		public bool flipX() { return tsImage_flipX(self); }
		public bool flipY(in Region region, in Slice slice) { return tsImage_flipY_cRcS(self, in region, in slice); }
		public bool flipY(in Region region) { return tsImage_flipY_cR(self, in region); }
		public bool flipY() { return tsImage_flipY(self); }
		public bool copy(Image src, in Origin dest_origin, in Region src_region, in Slice dest_slice, in Slice src_slice) { return tsImage_copy_cIcOcRcScS(self, src.getSelf(), in dest_origin, in src_region, in dest_slice, in src_slice); }
		public bool copy(Image src, in Origin dest_origin, in Region src_region) { return tsImage_copy_cIcOcR(self, src.getSelf(), in dest_origin, in src_region); }
		public bool copy(Image src, in Origin dest_origin, in Slice dest_slice) { return tsImage_copy_cIcOcS(self, src.getSelf(), in dest_origin, in dest_slice); }
		public bool copy(Image src, in Slice dest_slice, in Slice src_slice) { return tsImage_copy_cIcScS(self, src.getSelf(), in dest_slice, in src_slice); }
		public bool copy(Image src, in Origin dest_origin) { return tsImage_copy_cIcO(self, src.getSelf(), in dest_origin); }
		public bool copy(Image src, in Slice dest_slice) { return tsImage_copy_cIcS(self, src.getSelf(), in dest_slice); }
		public Image toType(Type type, Flags flags, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_toType_cITIFA(self, type, flags, ref async_));
		}
		public Image toType(Type type, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_toType_cITA(self, type, ref async_));
		}
		public Image toFormat(Format format, Flags flags, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_toFormat_cFIFA(self, format, flags, ref async_));
		}
		public Image toFormat(Format format, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_toFormat_cFA(self, format, ref async_));
		}
		public Image getSlice(in Slice slice) { return new Image(tsImage_getSlice_ccS(self, in slice)); }
		public Image getComponent(uint component) { return new Image(tsImage_getComponent(self, component)); }
		public Image getRegion(in Region region, in Slice slice) { return new Image(tsImage_getRegion_ccRcS(self, in region, in slice)); }
		public Image getRegion(in Region region) { return new Image(tsImage_getRegion_ccR(self, in region)); }
		public Image getRotated(int angle, in Slice slice) { return new Image(tsImage_getRotated_cicS(self, angle, in slice)); }
		public Image getRotated(int angle) { return new Image(tsImage_getRotated_ci(self, angle)); }
		public Image getResized(in Size size, Filter min, Filter mag, Flags flags, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_getResized_ccSIFIFIFA(self, in size, min, mag, flags, ref async_));
		}
		public Image getResized(in Size size, Filter min, Filter mag = Filter.Cubic, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_getResized_ccSIFIFA(self, in size, min, mag, ref async_));
		}
		public Image getResized(in Size size, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_getResized_ccSA(self, in size, ref async_));
		}
		public Image getMipmapped(Filter filter, Flags flags, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_getMipmapped_cIFIFA(self, filter, flags, ref async_));
		}
		public Image getMipmapped(Filter filter, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_getMipmapped_cIFA(self, filter, ref async_));
		}
		public Image getMipmapped(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Image(tsImage_getMipmapped_cA(self, ref async_));
		}
		public int compare(Image image) { return tsImage_compare(self, image.getSelf()); }
		public byte[] getData(in Slice slice) { return tsImage_getData_ccS(self, in slice); }
		public byte[] getData(in Origin origin, in Slice slice) { return tsImage_getData_ccOcS(self, in origin, in slice); }
		public bool setData(IntPtr src, in Slice slice, uint alignment = 1, ulong stride = 0) { return tsImage_setData(self, src, in slice, alignment, stride); }
		public bool getData(IntPtr dest, in Slice slice, uint alignment = 1, ulong stride = 0) { return tsImage_getData_cprcSuz(self, dest, in slice, alignment, stride); }
		public ulong getMemory() { return tsImage_getMemory(self); }
		public override string ToString() { return "Tellusim.Image: Valid: " + tsImage_isValidPtr(self) + "; Owner: " + tsImage_isOwnerPtr(self) + "; Const: " + tsImage_isConstPtr(self) + "; Count: " + tsImage_getCountPtr(self) + "; Internal: 0x" + tsImage_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Image ptr) { return (ptr != null && tsImage_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsImage_new();
		[DllImport(Base.Import)] private static extern IntPtr tsImage_new_sIFu(string name, Flags flags, uint offset);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_new_StIFu(HandleRef stream, Flags flags, uint offset);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_new_ITFcSIF(Type type, Format format, in Size size, Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_new_ITFcSuIF(Type type, Format format, in Size size, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern void tsImage_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsImage_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsImage_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsImage_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsImage_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsImage_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isLoaded(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isAllocated(HandleRef self);
		[DllImport(Base.Import)] private static extern Type tsImage_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getTypeName_IT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_is2DType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_is3DType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isCubeType(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsImage_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getFormatName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isColorFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isDepthFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isPixelFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isPlainFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isMixedFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isBlockFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isStencilFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isNormFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isSRGBFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isFloatFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isSignedFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isUnsignedFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isIntegerFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isi8Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isu8Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_is8BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isi16Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isu16Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isf16Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_is16BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isi32Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isu32Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isf32Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_is32BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isi64Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isu64Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isf64Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_is64BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isBC15Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isBC67Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isETC2Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_isASTCFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getComponents(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getPixelSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getBlockSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getBlockWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getBlockHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getWidth_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getHeight_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getDepth_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getFaces(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_getMipmaps(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImage_findMipmap(HandleRef self, in Size size);
		[DllImport(Base.Import)] private static extern uint tsImage_getWidth_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern uint tsImage_getHeight_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern uint tsImage_getDepth_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern bool tsImage_hasLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_hasMipmaps(HandleRef self);
		[DllImport(Base.Import)] private static extern Size tsImage_getSize_c(HandleRef self);
		[DllImport(Base.Import)] private static extern Region tsImage_getRegion_c(HandleRef self);
		[DllImport(Base.Import)] private static extern Slice tsImage_getSlice_c(HandleRef self);
		[DllImport(Base.Import)] private static extern Size tsImage_getSize_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern Region tsImage_getRegion_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern Slice tsImage_getSlice_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern void tsImage_setMetaInfo(HandleRef self, HandleRef str);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getMetaInfo(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getDescription(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsImage_getOffset(HandleRef self, in Slice slice, uint alignment);
		[DllImport(Base.Import)] private static extern ulong tsImage_getStride(HandleRef self, uint mipmap, uint alignment);
		[DllImport(Base.Import)] private static extern ulong tsImage_getMipmapSize(HandleRef self, uint mipmap, uint alignment);
		[DllImport(Base.Import)] private static extern ulong tsImage_getLayerSize(HandleRef self, uint alignment);
		[DllImport(Base.Import)] private static extern ulong tsImage_getDataSize(HandleRef self, uint alignment);
		[DllImport(Base.Import)] private static extern bool tsImage_create_ITFcSIF(HandleRef self, Type type, Format format, in Size size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_create_ITFcSuIF(HandleRef self, Type type, Format format, in Size size, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_create2D_FuIF(HandleRef self, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_create3D_FuIF(HandleRef self, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_createCube_FuIF(HandleRef self, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_create2D_FuuIF(HandleRef self, Format format, uint width, uint height, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_create3D_FuuuIF(HandleRef self, Format format, uint width, uint height, uint depth, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_create2D_FuuuIF(HandleRef self, Format format, uint width, uint height, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_createCube_FuuIF(HandleRef self, Format format, uint size, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsImage_info_sIFuA(HandleRef self, string name, Flags flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_info_cSIFuA(HandleRef self, HandleRef name, Flags flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_info_StIFuA(HandleRef self, HandleRef stream, Flags flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_info_sA(HandleRef self, string name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_info_cSA(HandleRef self, HandleRef name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_info_StA(HandleRef self, HandleRef stream, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_load_sIFuA(HandleRef self, string name, Flags flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_load_cSIFuA(HandleRef self, HandleRef name, Flags flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_load_StIFuA(HandleRef self, HandleRef stream, Flags flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_load_sA(HandleRef self, string name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_load_cSA(HandleRef self, HandleRef name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_load_StA(HandleRef self, HandleRef stream, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsImage_save_csIFu(HandleRef self, string name, Flags flags, uint quality);
		[DllImport(Base.Import)] private static extern bool tsImage_save_ccSIFu(HandleRef self, HandleRef name, Flags flags, uint quality);
		[DllImport(Base.Import)] private static extern bool tsImage_save_cStIFu(HandleRef self, HandleRef stream, Flags flags, uint quality);
		[DllImport(Base.Import)] private static extern bool tsImage_swap(HandleRef self, uint component_0, uint component_1);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIuu(HandleRef self, HandleRef src, uint dest_component, uint src_component);
		[DllImport(Base.Import)] private static extern bool tsImage_flipX_cRcS(HandleRef self, in Region region, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsImage_flipX_cR(HandleRef self, in Region region);
		[DllImport(Base.Import)] private static extern bool tsImage_flipX(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_flipY_cRcS(HandleRef self, in Region region, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsImage_flipY_cR(HandleRef self, in Region region);
		[DllImport(Base.Import)] private static extern bool tsImage_flipY(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIcOcRcScS(HandleRef self, HandleRef src, in Origin dest_origin, in Region src_region, in Slice dest_slice, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIcOcR(HandleRef self, HandleRef src, in Origin dest_origin, in Region src_region);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIcOcS(HandleRef self, HandleRef src, in Origin dest_origin, in Slice dest_slice);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIcScS(HandleRef self, HandleRef src, in Slice dest_slice, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIcO(HandleRef self, HandleRef src, in Origin dest_origin);
		[DllImport(Base.Import)] private static extern bool tsImage_copy_cIcS(HandleRef self, HandleRef src, in Slice dest_slice);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_toType_cITIFA(HandleRef self, Type type, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_toType_cITA(HandleRef self, Type type, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_toFormat_cFIFA(HandleRef self, Format format, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_toFormat_cFA(HandleRef self, Format format, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getSlice_ccS(HandleRef self, in Slice slice);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getComponent(HandleRef self, uint component);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getRegion_ccRcS(HandleRef self, in Region region, in Slice slice);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getRegion_ccR(HandleRef self, in Region region);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getRotated_cicS(HandleRef self, int angle, in Slice slice);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getRotated_ci(HandleRef self, int angle);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getResized_ccSIFIFIFA(HandleRef self, in Size size, Filter min, Filter mag, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getResized_ccSIFIFA(HandleRef self, in Size size, Filter min, Filter mag, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getResized_ccSA(HandleRef self, in Size size, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getMipmapped_cIFIFA(HandleRef self, Filter filter, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getMipmapped_cIFA(HandleRef self, Filter filter, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsImage_getMipmapped_cA(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern int tsImage_compare(HandleRef self, HandleRef image);
		[DllImport(Base.Import)] private static extern byte[] tsImage_getData_ccS(HandleRef self, in Slice slice);
		[DllImport(Base.Import)] private static extern byte[] tsImage_getData_ccOcS(HandleRef self, in Origin origin, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsImage_setData(HandleRef self, IntPtr src, in Slice slice, uint alignment, ulong stride);
		[DllImport(Base.Import)] private static extern bool tsImage_getData_cprcSuz(HandleRef self, IntPtr dest, in Slice slice, uint alignment, ulong stride);
		[DllImport(Base.Import)] private static extern ulong tsImage_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::ImageSampler
	public sealed class ImageSampler {
		public ImageSampler() { self = new HandleRef(this, tsImageSampler_new()); owner = true; }
		public ImageSampler(Image image, in Slice slice) { self = new HandleRef(this, tsImageSampler_new_IcS(image.getSelf(), in slice)); owner = true; }
		public ImageSampler(ImageSampler ptr) { self = new HandleRef(this, ptr.getSelfPtr()); }
		public ImageSampler(IntPtr ptr) { self = new HandleRef(this, ptr); owner = true; }
		public static ImageSampler Null() { return new ImageSampler(IntPtr.Zero); }
		~ImageSampler() { if(owner) tsImageSampler_delete(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsImageSampler_clear(self); }
		public bool isCreated() { return tsImageSampler_isCreated(self); }
		public Image.Type getType() { return tsImageSampler_getType(self); }
		public bool is2DType() { return tsImageSampler_is2DType(self); }
		public bool is3DType() { return tsImageSampler_is3DType(self); }
		public bool isCubeType() { return tsImageSampler_isCubeType(self); }
		public Format getFormat() { return tsImageSampler_getFormat(self); }
		public string getFormatName() { return Base.getCString(tsImageSampler_getFormatName(self)); }
		public uint getWidth() { return tsImageSampler_getWidth(self); }
		public uint getHeight() { return tsImageSampler_getHeight(self); }
		public uint getDepth() { return tsImageSampler_getDepth(self); }
		public uint getFaces() { return tsImageSampler_getFaces(self); }
		public ulong getTexels() { return tsImageSampler_getTexels(self); }
		public Size getSize() { return tsImageSampler_getSize(self); }
		public Region getRegion() { return tsImageSampler_getRegion(self); }
		public ulong getStride() { return tsImageSampler_getStride(self); }
		public ulong getLayerSize() { return tsImageSampler_getLayerSize(self); }
		public uint getPixelSize() { return tsImageSampler_getPixelSize(self); }
		public uint getComponents() { return tsImageSampler_getComponents(self); }
		public byte[] getData() { return tsImageSampler_getData_c(self); }
		public bool create(Image image, in Slice slice) { return tsImageSampler_create_IcS(self, image.getSelf(), in slice); }
		public bool create(Image.Type type, Format format, in Size size, ulong stride, IntPtr data) { return tsImageSampler_create_ITFcSzpr(self, type, format, in size, stride, data); }
		public bool create(Image.Type type, Format format, in Size size, ulong stride, ulong layer_size, IntPtr data) { return tsImageSampler_create_ITFcSzzpr(self, type, format, in size, stride, layer_size, data); }
		public bool clear(in Color color) { return tsImageSampler_clear_cC(self, in color); }
		public bool clear(in ImageColor color) { return tsImageSampler_clear_cIC(self, in color); }
		public bool mad(in Color m, in Color a) { return tsImageSampler_mad(self, in m, in a); }
		public void set2D(uint x, uint y, in ImageColor color) { tsImageSampler_set2D(self, x, y, in color); }
		public ImageColor get2D(uint x, uint y, bool repeat = false) { return tsImageSampler_get2D_cuub(self, x, y, repeat); }
		public ImageColor get2D(double x, double y, bool repeat = false, Image.Filter filter = Image.Filter.Linear) { return tsImageSampler_get2D_cf64f64bIF(self, x, y, repeat, filter); }
		public void set3D(uint x, uint y, uint z, in ImageColor color) { tsImageSampler_set3D(self, x, y, z, in color); }
		public ImageColor get3D(uint x, uint y, uint z, bool repeat = false) { return tsImageSampler_get3D_cuuub(self, x, y, z, repeat); }
		public ImageColor get3D(float x, float y, float z, bool repeat = false, Image.Filter filter = Image.Filter.Linear) { return tsImageSampler_get3D_cfffbIF(self, x, y, z, repeat, filter); }
		public void setCube(float x, float y, float z, in ImageColor color) { tsImageSampler_setCube(self, x, y, z, in color); }
		public ImageColor getCube(float x, float y, float z, Image.Filter filter = Image.Filter.Linear) { return tsImageSampler_getCube(self, x, y, z, filter); }
		public uint getCubeFace(float x, float y, float z, ref float tx, ref float ty) { return tsImageSampler_getCubeFace(self, x, y, z, ref tx, ref ty); }
		public void setTexel(ulong t, in ImageColor color) { tsImageSampler_setTexel(self, t, in color); }
		public ImageColor getTexel(ulong t) { return tsImageSampler_getTexel(self, t); }
		public override string ToString() { return "Tellusim.ImageSampler: Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ImageSampler ptr) { return (ptr != null && ptr.getSelfPtr() != IntPtr.Zero); }
		[DllImport(Base.Import)] private static extern IntPtr tsImageSampler_new();
		[DllImport(Base.Import)] private static extern IntPtr tsImageSampler_new_IcS(HandleRef image, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsImageSampler_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsImageSampler_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern Image.Type tsImageSampler_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_is2DType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_is3DType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_isCubeType(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsImageSampler_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsImageSampler_getFormatName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getDepth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getFaces(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsImageSampler_getTexels(HandleRef self);
		[DllImport(Base.Import)] private static extern Size tsImageSampler_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern Region tsImageSampler_getRegion(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsImageSampler_getStride(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsImageSampler_getLayerSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getPixelSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getComponents(HandleRef self);
		[DllImport(Base.Import)] private static extern byte[] tsImageSampler_getData_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_create_IcS(HandleRef self, HandleRef image, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_create_ITFcSzpr(HandleRef self, Image.Type type, Format format, in Size size, ulong stride, IntPtr data);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_create_ITFcSzzpr(HandleRef self, Image.Type type, Format format, in Size size, ulong stride, ulong layer_size, IntPtr data);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_clear_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_clear_cIC(HandleRef self, in ImageColor color);
		[DllImport(Base.Import)] private static extern bool tsImageSampler_mad(HandleRef self, in Color m, in Color a);
		[DllImport(Base.Import)] private static extern void tsImageSampler_set2D(HandleRef self, uint x, uint y, in ImageColor color);
		[DllImport(Base.Import)] private static extern ImageColor tsImageSampler_get2D_cuub(HandleRef self, uint x, uint y, bool repeat);
		[DllImport(Base.Import)] private static extern ImageColor tsImageSampler_get2D_cf64f64bIF(HandleRef self, double x, double y, bool repeat, Image.Filter filter);
		[DllImport(Base.Import)] private static extern void tsImageSampler_set3D(HandleRef self, uint x, uint y, uint z, in ImageColor color);
		[DllImport(Base.Import)] private static extern ImageColor tsImageSampler_get3D_cuuub(HandleRef self, uint x, uint y, uint z, bool repeat);
		[DllImport(Base.Import)] private static extern ImageColor tsImageSampler_get3D_cfffbIF(HandleRef self, float x, float y, float z, bool repeat, Image.Filter filter);
		[DllImport(Base.Import)] private static extern void tsImageSampler_setCube(HandleRef self, float x, float y, float z, in ImageColor color);
		[DllImport(Base.Import)] private static extern ImageColor tsImageSampler_getCube(HandleRef self, float x, float y, float z, Image.Filter filter);
		[DllImport(Base.Import)] private static extern uint tsImageSampler_getCubeFace(HandleRef self, float x, float y, float z, ref float tx, ref float ty);
		[DllImport(Base.Import)] private static extern void tsImageSampler_setTexel(HandleRef self, ulong t, in ImageColor color);
		[DllImport(Base.Import)] private static extern ImageColor tsImageSampler_getTexel(HandleRef self, ulong t);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshNode
	public sealed class MeshNode {
		public MeshNode(string name = "") { self = new HandleRef(this, tsMeshNode_new_s(name)); owner = true; }
		public MeshNode(Mesh mesh, string name = "") { self = new HandleRef(this, tsMeshNode_new_Ms(mesh.getSelf(), name)); owner = true; }
		public MeshNode(in MeshNode parent, string name = "") {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsMeshNode_new_MNs(ref parent_, name)); owner = true;
		}
		public MeshNode(Mesh mesh, in MeshNode parent, string name = "") {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsMeshNode_new_MMNs(mesh.getSelf(), ref parent_, name)); owner = true;
		}
		public MeshNode(MeshNode ptr) { self = new HandleRef(this, tsMeshNode_copyPtr(ptr.getSelf())); owner = true; }
		public MeshNode(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshNode_isOwnerPtr(self); }
		public static MeshNode Null() { return new MeshNode(IntPtr.Zero); }
		~MeshNode() { if(owner) tsMeshNode_delete(self); }
		public bool equalPtr(MeshNode ptr) { return tsMeshNode_equalPtr(self, ptr.getSelf()); }
		public MeshNode clonePtr() { return new MeshNode(tsMeshNode_clonePtr(self)); }
		public void clearPtr() { tsMeshNode_clearPtr(self); }
		public void destroyPtr() { tsMeshNode_destroyPtr(self); }
		public void acquirePtr() { tsMeshNode_acquirePtr(self); }
		public void unacquirePtr() { tsMeshNode_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshNode_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshNode_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshNode_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshNode_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshNode_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshNode_clear(self); }
		public MeshNode clone(Mesh mesh) { return new MeshNode(tsMeshNode_clone(self, mesh.getSelf())); }
		public void setName(string name) { tsMeshNode_setName(self, name); }
		public string getName() { return Base.getString(tsMeshNode_getName(self)); }
		public uint getIndex() { return tsMeshNode_getIndex(self); }
		public void setMesh(Mesh mesh, bool check = true) { tsMeshNode_setMesh(self, mesh.getSelf(), check); }
		public Mesh getMesh() { return new Mesh(tsMeshNode_getMesh_c(self)); }
		public uint setParent(MeshNode parent, bool check = true) { return tsMeshNode_setParent(self, parent.getSelf(), check); }
		public MeshNode getParent() { return new MeshNode(tsMeshNode_getParent_c(self)); }
		public bool isRoot() { return tsMeshNode_isRoot(self); }
		public void reserveChildren(uint num_children) { tsMeshNode_reserveChildren(self, num_children); }
		public uint addChild(MeshNode child, bool check = true) { return tsMeshNode_addChild(self, child.getSelf(), check); }
		public bool removeChild(MeshNode child) { return tsMeshNode_removeChild(self, child.getSelf()); }
		public void releaseChildren() { tsMeshNode_releaseChildren(self); }
		public uint findChild(MeshNode child) { return tsMeshNode_findChild_ccMN(self, child.getSelf()); }
		public uint findChild(string name) { return tsMeshNode_findChild_cs(self, name); }
		public uint getNumChildren() { return tsMeshNode_getNumChildren(self); }
		public MeshNode getChild(uint index) { return new MeshNode(tsMeshNode_getChild_cu(self, index)); }
		public MeshNode getChild(string name) { return new MeshNode(tsMeshNode_getChild_cs(self, name)); }
		public void clearGeometries() { tsMeshNode_clearGeometries(self); }
		public void reserveGeometries(uint num_geometries) { tsMeshNode_reserveGeometries(self, num_geometries); }
		public uint addGeometry(MeshGeometry geometry, bool check = true) { return tsMeshNode_addGeometry(self, geometry.getSelf(), check); }
		public bool removeGeometry(MeshGeometry geometry) { return tsMeshNode_removeGeometry(self, geometry.getSelf()); }
		public bool replaceGeometry(MeshGeometry old_geometry, MeshGeometry geometry) { return tsMeshNode_replaceGeometry(self, old_geometry.getSelf(), geometry.getSelf()); }
		public uint findGeometry(MeshGeometry geometry) { return tsMeshNode_findGeometry(self, geometry.getSelf()); }
		public uint getNumGeometries() { return tsMeshNode_getNumGeometries(self); }
		public MeshGeometry getGeometry(uint index) { return new MeshGeometry(tsMeshNode_getGeometry_cu(self, index)); }
		public void clearAttachments() { tsMeshNode_clearAttachments(self); }
		public void reserveAttachments(uint num_attachments) { tsMeshNode_reserveAttachments(self, num_attachments); }
		public uint addAttachment(MeshAttachment attachment, bool check = true) { return tsMeshNode_addAttachment(self, attachment.getSelf(), check); }
		public bool removeAttachment(MeshAttachment attachment) { return tsMeshNode_removeAttachment(self, attachment.getSelf()); }
		public bool replaceAttachment(MeshAttachment old_attachment, MeshAttachment attachment) { return tsMeshNode_replaceAttachment(self, old_attachment.getSelf(), attachment.getSelf()); }
		public uint findAttachment(MeshAttachment attachment) { return tsMeshNode_findAttachment_ccMA(self, attachment.getSelf()); }
		public uint findAttachment(string name) { return tsMeshNode_findAttachment_cs(self, name); }
		public uint getNumAttachments() { return tsMeshNode_getNumAttachments(self); }
		public MeshAttachment getAttachment(uint index) { return new MeshAttachment(tsMeshNode_getAttachment_cu(self, index)); }
		public void setLocalTransform(in Matrix4x3d transform) { tsMeshNode_setLocalTransform(self, in transform); }
		public Matrix4x3d getLocalTransform() { return tsMeshNode_getLocalTransform(self); }
		public void setGlobalTransform(in Matrix4x3d transform) { tsMeshNode_setGlobalTransform(self, in transform); }
		public Matrix4x3d getGlobalTransform() { return tsMeshNode_getGlobalTransform(self); }
		public void setPivotTransform(in Matrix4x3d transform) { tsMeshNode_setPivotTransform(self, in transform); }
		public Matrix4x3d getPivotTransform() { return tsMeshNode_getPivotTransform(self); }
		public void setMorphTransform(in Vector4f transform) { tsMeshNode_setMorphTransform(self, in transform); }
		public Vector4f getMorphTransform() { return tsMeshNode_getMorphTransform(self); }
		public void createLocalTransforms(in Matrix4x3d itransform) { tsMeshNode_createLocalTransforms(self, in itransform); }
		public void createGlobalTransforms(in Matrix4x3d transform) { tsMeshNode_createGlobalTransforms(self, in transform); }
		public void setTransform(in Vector3d scale) { tsMeshNode_setTransform(self, in scale); }
		public ulong getMemory() { return tsMeshNode_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshNode: Valid: " + tsMeshNode_isValidPtr(self) + "; Owner: " + tsMeshNode_isOwnerPtr(self) + "; Const: " + tsMeshNode_isConstPtr(self) + "; Count: " + tsMeshNode_getCountPtr(self) + "; Internal: 0x" + tsMeshNode_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshNode ptr) { return (ptr != null && tsMeshNode_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_new_Ms(HandleRef mesh, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_new_MNs(ref IntPtr parent, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_new_MMNs(HandleRef mesh, ref IntPtr parent, string name);
		[DllImport(Base.Import)] private static extern void tsMeshNode_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_clone(HandleRef self, HandleRef mesh);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setMesh(HandleRef self, HandleRef mesh, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getMesh_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_setParent(HandleRef self, HandleRef parent, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getParent_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_isRoot(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_reserveChildren(HandleRef self, uint num_children);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_addChild(HandleRef self, HandleRef child, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_removeChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern void tsMeshNode_releaseChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_findChild_ccMN(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_findChild_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_getNumChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getChild_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getChild_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsMeshNode_clearGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_reserveGeometries(HandleRef self, uint num_geometries);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_addGeometry(HandleRef self, HandleRef geometry, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_removeGeometry(HandleRef self, HandleRef geometry);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_replaceGeometry(HandleRef self, HandleRef old_geometry, HandleRef geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_findGeometry(HandleRef self, HandleRef geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_getNumGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getGeometry_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshNode_clearAttachments(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_reserveAttachments(HandleRef self, uint num_attachments);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_addAttachment(HandleRef self, HandleRef attachment, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_removeAttachment(HandleRef self, HandleRef attachment);
		[DllImport(Base.Import)] private static extern bool tsMeshNode_replaceAttachment(HandleRef self, HandleRef old_attachment, HandleRef attachment);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_findAttachment_ccMA(HandleRef self, HandleRef attachment);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_findAttachment_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMeshNode_getNumAttachments(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshNode_getAttachment_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setLocalTransform(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshNode_getLocalTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setGlobalTransform(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshNode_getGlobalTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setPivotTransform(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshNode_getPivotTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setMorphTransform(HandleRef self, in Vector4f transform);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshNode_getMorphTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshNode_createLocalTransforms(HandleRef self, in Matrix4x3d itransform);
		[DllImport(Base.Import)] private static extern void tsMeshNode_createGlobalTransforms(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern void tsMeshNode_setTransform(HandleRef self, in Vector3d scale);
		[DllImport(Base.Import)] private static extern ulong tsMeshNode_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshIndices
	public sealed class MeshIndices {
		public enum Type : uint {
			Unknown = 0,
			Point,
			Line,
			Triangle,
			Quadrilateral,
			Tetrahedron,
			Material,
			Island,
			Group,
			Joint,
			Edge,
			NumTypes,
		}
		public MeshIndices(string name = "") { self = new HandleRef(this, tsMeshIndices_new_s(name)); owner = true; }
		public MeshIndices(Type type, Format format, string name = "") { self = new HandleRef(this, tsMeshIndices_new_MITFs(type, format, name)); owner = true; }
		public MeshIndices(Type type, Format format, uint size, string name = "") { self = new HandleRef(this, tsMeshIndices_new_MITFus(type, format, size, name)); owner = true; }
		public MeshIndices(MeshIndices ptr) { self = new HandleRef(this, tsMeshIndices_copyPtr(ptr.getSelf())); owner = true; }
		public MeshIndices(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshIndices_isOwnerPtr(self); }
		public static MeshIndices Null() { return new MeshIndices(IntPtr.Zero); }
		~MeshIndices() { if(owner) tsMeshIndices_delete(self); }
		public bool equalPtr(MeshIndices ptr) { return tsMeshIndices_equalPtr(self, ptr.getSelf()); }
		public MeshIndices clonePtr() { return new MeshIndices(tsMeshIndices_clonePtr(self)); }
		public void clearPtr() { tsMeshIndices_clearPtr(self); }
		public void destroyPtr() { tsMeshIndices_destroyPtr(self); }
		public void acquirePtr() { tsMeshIndices_acquirePtr(self); }
		public void unacquirePtr() { tsMeshIndices_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshIndices_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshIndices_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshIndices_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshIndices_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshIndices_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshIndices_clear(self); }
		public void setName(string name) { tsMeshIndices_setName(self, name); }
		public string getName() { return Base.getString(tsMeshIndices_getName(self)); }
		public void create(Type type, Format format, uint size = 0) { tsMeshIndices_create(self, type, format, size); }
		public Type getType() { return tsMeshIndices_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsMeshIndices_getTypeName_MIT(type)); }
		public string getTypeName() { return Base.getCString(tsMeshIndices_getTypeName_c(self)); }
		public bool isUnknown() { return tsMeshIndices_isUnknown(self); }
		public bool isPoint() { return tsMeshIndices_isPoint(self); }
		public bool isLine() { return tsMeshIndices_isLine(self); }
		public bool isTriangle() { return tsMeshIndices_isTriangle(self); }
		public bool isQuadrilateral() { return tsMeshIndices_isQuadrilateral(self); }
		public bool isTetrahedron() { return tsMeshIndices_isTetrahedron(self); }
		public bool isPrimitive() { return tsMeshIndices_isPrimitive(self); }
		public bool isSolid() { return tsMeshIndices_isSolid(self); }
		public bool isVolume() { return tsMeshIndices_isVolume(self); }
		public bool isMaterial() { return tsMeshIndices_isMaterial(self); }
		public bool isGroup() { return tsMeshIndices_isGroup(self); }
		public bool isJoint() { return tsMeshIndices_isJoint(self); }
		public bool isEdge() { return tsMeshIndices_isEdge(self); }
		public uint getPrimitiveSize() { return tsMeshIndices_getPrimitiveSize(self); }
		public Format getFormat() { return tsMeshIndices_getFormat(self); }
		public string getFormatName() { return Base.getCString(tsMeshIndices_getFormatName(self)); }
		public void setGeometry(MeshGeometry geometry, bool check = true) { tsMeshIndices_setGeometry(self, geometry.getSelf(), check); }
		public MeshGeometry getGeometry() { return new MeshGeometry(tsMeshIndices_getGeometry_c(self)); }
		public void setSize(uint size, bool discard = true, bool clear = false) { tsMeshIndices_setSize(self, size, discard, clear); }
		public uint getSize() { return tsMeshIndices_getSize(self); }
		public uint getStride() { return tsMeshIndices_getStride(self); }
		public ulong getBytes() { return tsMeshIndices_getBytes(self); }
		public void setData(uint value, uint size = 0, uint offset = 0) { tsMeshIndices_setData_uuu(self, value, size, offset); }
		public void setData(IntPtr src, Format format = Format.Unknown, uint size = 0, uint repeat = 1) { tsMeshIndices_setData_pFuu(self, src, format, size, repeat); }
		public void getData(IntPtr dest, Format format = Format.Unknown, uint size = 0, uint repeat = 1) { tsMeshIndices_getData_cprFuu(self, dest, format, size, repeat); }
		public IntPtr getData() { return tsMeshIndices_getData_c(self); }
		public void set(uint index, uint value) { tsMeshIndices_set_uu(self, index, value); }
		public void set(uint index, uint value_0, uint value_1) { tsMeshIndices_set_uuu(self, index, value_0, value_1); }
		public void set(uint index, uint value_0, uint value_1, uint value_2) { tsMeshIndices_set_uuuu(self, index, value_0, value_1, value_2); }
		public void set(uint index, uint value_0, uint value_1, uint value_2, uint value_3) { tsMeshIndices_set_uuuuu(self, index, value_0, value_1, value_2, value_3); }
		public uint get(uint index) { return tsMeshIndices_get_cu(self, index); }
		public void get(uint index, ref uint value_0, ref uint value_1) { tsMeshIndices_get_cuurur(self, index, ref value_0, ref value_1); }
		public void get(uint index, ref uint value_0, ref uint value_1, ref uint value_2) { tsMeshIndices_get_cuururur(self, index, ref value_0, ref value_1, ref value_2); }
		public void get(uint index, ref uint value_0, ref uint value_1, ref uint value_2, ref uint value_3) { tsMeshIndices_get_cuurururur(self, index, ref value_0, ref value_1, ref value_2, ref value_3); }
		public IntPtr getPtr(uint index) { return tsMeshIndices_getPtr_cu(self, index); }
		public bool isDirect() { return tsMeshIndices_isDirect(self); }
		public bool isUniform() { return tsMeshIndices_isUniform(self); }
		public uint getMinIndex() { return tsMeshIndices_getMinIndex(self); }
		public uint getMaxIndex() { return tsMeshIndices_getMaxIndex(self); }
		public int compare(MeshIndices indices) { return tsMeshIndices_compare(self, indices.getSelf()); }
		public void addIndices(MeshIndices indices, uint offset, bool expand = false) { tsMeshIndices_addIndices(self, indices.getSelf(), offset, expand); }
		public MeshIndices toFormat(Format format) { return new MeshIndices(tsMeshIndices_toFormat(self, format)); }
		public MeshIndices toType(Type type) { return new MeshIndices(tsMeshIndices_toType_cMIT(self, type)); }
		public MeshIndices toType(Type type, MeshAttribute position_attribute) { return new MeshIndices(tsMeshIndices_toType_cMITcMA(self, type, position_attribute.getSelf())); }
		public ulong getMemory() { return tsMeshIndices_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshIndices: Valid: " + tsMeshIndices_isValidPtr(self) + "; Owner: " + tsMeshIndices_isOwnerPtr(self) + "; Const: " + tsMeshIndices_isConstPtr(self) + "; Count: " + tsMeshIndices_getCountPtr(self) + "; Internal: 0x" + tsMeshIndices_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshIndices ptr) { return (ptr != null && tsMeshIndices_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_new_MITFs(Type type, Format format, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_new_MITFus(Type type, Format format, uint size, string name);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_create(HandleRef self, Type type, Format format, uint size);
		[DllImport(Base.Import)] private static extern Type tsMeshIndices_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getTypeName_MIT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isUnknown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isPoint(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isLine(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isTriangle(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isQuadrilateral(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isTetrahedron(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isPrimitive(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isSolid(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isVolume(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isMaterial(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isGroup(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isJoint(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isEdge(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_getPrimitiveSize(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsMeshIndices_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getFormatName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_setGeometry(HandleRef self, HandleRef geometry, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getGeometry_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_setSize(HandleRef self, uint size, bool discard, bool clear);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_getStride(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsMeshIndices_getBytes(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_setData_uuu(HandleRef self, uint value, uint size, uint offset);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_setData_pFuu(HandleRef self, IntPtr src, Format format, uint size, uint repeat);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_getData_cprFuu(HandleRef self, IntPtr dest, Format format, uint size, uint repeat);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getData_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_set_uu(HandleRef self, uint index, uint value);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_set_uuu(HandleRef self, uint index, uint value_0, uint value_1);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_set_uuuu(HandleRef self, uint index, uint value_0, uint value_1, uint value_2);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_set_uuuuu(HandleRef self, uint index, uint value_0, uint value_1, uint value_2, uint value_3);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_get_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_get_cuurur(HandleRef self, uint index, ref uint value_0, ref uint value_1);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_get_cuururur(HandleRef self, uint index, ref uint value_0, ref uint value_1, ref uint value_2);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_get_cuurururur(HandleRef self, uint index, ref uint value_0, ref uint value_1, ref uint value_2, ref uint value_3);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_getPtr_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isDirect(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshIndices_isUniform(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_getMinIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshIndices_getMaxIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsMeshIndices_compare(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern void tsMeshIndices_addIndices(HandleRef self, HandleRef indices, uint offset, bool expand);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_toFormat(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_toType_cMIT(HandleRef self, Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshIndices_toType_cMITcMA(HandleRef self, Type type, HandleRef position_attribute);
		[DllImport(Base.Import)] private static extern ulong tsMeshIndices_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshAttribute
	public sealed class MeshAttribute {
		public enum Type : uint {
			Unknown = 0,
			Position,
			Basis,
			Normal,
			Tangent,
			Binormal,
			TexCoord,
			Weights,
			Joints,
			Color,
			Crease,
			Index,
			NumTypes,
		}
		public MeshAttribute(string name = "", uint index = 0) { self = new HandleRef(this, tsMeshAttribute_new_su(name, index)); owner = true; }
		public MeshAttribute(Type type, Format format, string name = "", uint index = 0) { self = new HandleRef(this, tsMeshAttribute_new_MATFsu(type, format, name, index)); owner = true; }
		public MeshAttribute(Type type, Format format, uint size, string name = "", uint index = 0) { self = new HandleRef(this, tsMeshAttribute_new_MATFusu(type, format, size, name, index)); owner = true; }
		public MeshAttribute(Type type, Format format, uint size, uint index) { self = new HandleRef(this, tsMeshAttribute_new_MATFuu(type, format, size, index)); owner = true; }
		public MeshAttribute(MeshAttribute ptr) { self = new HandleRef(this, tsMeshAttribute_copyPtr(ptr.getSelf())); owner = true; }
		public MeshAttribute(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshAttribute_isOwnerPtr(self); }
		public static MeshAttribute Null() { return new MeshAttribute(IntPtr.Zero); }
		~MeshAttribute() { if(owner) tsMeshAttribute_delete(self); }
		public bool equalPtr(MeshAttribute ptr) { return tsMeshAttribute_equalPtr(self, ptr.getSelf()); }
		public MeshAttribute clonePtr() { return new MeshAttribute(tsMeshAttribute_clonePtr(self)); }
		public void clearPtr() { tsMeshAttribute_clearPtr(self); }
		public void destroyPtr() { tsMeshAttribute_destroyPtr(self); }
		public void acquirePtr() { tsMeshAttribute_acquirePtr(self); }
		public void unacquirePtr() { tsMeshAttribute_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshAttribute_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshAttribute_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshAttribute_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshAttribute_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshAttribute_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshAttribute_clear(self); }
		public void setName(string name) { tsMeshAttribute_setName(self, name); }
		public string getName() { return Base.getString(tsMeshAttribute_getName(self)); }
		public void create(Type type, Format format, uint size = 0) { tsMeshAttribute_create(self, type, format, size); }
		public Type getType() { return tsMeshAttribute_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsMeshAttribute_getTypeName_MAT(type)); }
		public string getTypeName() { return Base.getCString(tsMeshAttribute_getTypeName_c(self)); }
		public bool isUnknown() { return tsMeshAttribute_isUnknown(self); }
		public bool isPosition() { return tsMeshAttribute_isPosition(self); }
		public bool isBasis() { return tsMeshAttribute_isBasis(self); }
		public bool isNormal() { return tsMeshAttribute_isNormal(self); }
		public bool isTangent() { return tsMeshAttribute_isTangent(self); }
		public bool isBinormal() { return tsMeshAttribute_isBinormal(self); }
		public bool isSpatial() { return tsMeshAttribute_isSpatial(self); }
		public bool isNormalized() { return tsMeshAttribute_isNormalized(self); }
		public bool isTexCoord() { return tsMeshAttribute_isTexCoord(self); }
		public bool isWeights() { return tsMeshAttribute_isWeights(self); }
		public bool isJoints() { return tsMeshAttribute_isJoints(self); }
		public bool isColor() { return tsMeshAttribute_isColor(self); }
		public bool isVertex() { return tsMeshAttribute_isVertex(self); }
		public bool isCrease() { return tsMeshAttribute_isCrease(self); }
		public Format getFormat() { return tsMeshAttribute_getFormat(self); }
		public string getFormatName() { return Base.getCString(tsMeshAttribute_getFormatName(self)); }
		public uint getComponents() { return tsMeshAttribute_getComponents(self); }
		public bool isPacked() { return tsMeshAttribute_isPacked(self); }
		public void setIndex(uint index) { tsMeshAttribute_setIndex(self, index); }
		public uint getIndex() { return tsMeshAttribute_getIndex(self); }
		public void setIndices(MeshIndices indices) { tsMeshAttribute_setIndices(self, indices.getSelf()); }
		public MeshIndices getIndices() { return new MeshIndices(tsMeshAttribute_getIndices_c(self)); }
		public void setGeometry(MeshGeometry geometry, bool check = true) { tsMeshAttribute_setGeometry(self, geometry.getSelf(), check); }
		public MeshGeometry getGeometry() { return new MeshGeometry(tsMeshAttribute_getGeometry_c(self)); }
		public void setSize(uint size, bool discard = true, bool clear = false) { tsMeshAttribute_setSize(self, size, discard, clear); }
		public uint getSize() { return tsMeshAttribute_getSize(self); }
		public uint getStride() { return tsMeshAttribute_getStride(self); }
		public ulong getBytes() { return tsMeshAttribute_getBytes(self); }
		public void setData(IntPtr src, uint size = 0, uint stride = 0) { tsMeshAttribute_setData_puu(self, src, size, stride); }
		public void setData(IntPtr src, uint[] indices, uint stride = 0) { tsMeshAttribute_setData_pcA32u(self, src, indices, (uint)indices.Length, stride); }
		public void getData(IntPtr dest, uint size = 0, uint stride = 0) { tsMeshAttribute_getData_cpruu(self, dest, size, stride); }
		public void getData(IntPtr dest, MeshIndices indices, uint stride = 0) { tsMeshAttribute_getData_cprcMIu(self, dest, indices.getSelf(), stride); }
		public void getData(IntPtr dest, uint[] indices, uint stride = 0) { tsMeshAttribute_getData_cprcA32u(self, dest, indices, (uint)indices.Length, stride); }
		public IntPtr getData() { return tsMeshAttribute_getData_c(self); }
		public void setValue(uint index, IntPtr src, ulong size) { tsMeshAttribute_setValue(self, index, src, size); }
		public void setValue<Type>(uint index, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setValue(index, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void getValue(uint index, IntPtr dest, ulong size) { tsMeshAttribute_getValue(self, index, dest, size); }
		public void getValue<Type>(uint index, ref Type[] dest) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			getValue(index, ptr_, (ulong)size_);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
		}
		public IntPtr getPtr(uint index) { return tsMeshAttribute_getPtr_cu(self, index); }
		public int compare(MeshAttribute attribute, in Matrix4x3f transform, float threshold = 1e-6f, bool spatial = true) { return tsMeshAttribute_compare(self, attribute.getSelf(), in transform, threshold, spatial); }
		public void addAttribute(MeshAttribute attribute) { tsMeshAttribute_addAttribute(self, attribute.getSelf()); }
		public bool setTransform(in Matrix4x3f transform) { return tsMeshAttribute_setTransform(self, in transform); }
		public bool morphAttribute(MeshAttribute attribute, float k) { return tsMeshAttribute_morphAttribute(self, attribute.getSelf(), k); }
		public bool packAttributes(MeshAttribute attribute_0, MeshAttribute attribute_1, Format format) { return tsMeshAttribute_packAttributes(self, attribute_0.getSelf(), attribute_1.getSelf(), format); }
		public bool unpackAttributes(MeshAttribute attribute_0, MeshAttribute attribute_1) { return tsMeshAttribute_unpackAttributes(self, attribute_0.getSelf(), attribute_1.getSelf()); }
		public MeshAttribute optimizeAttribute(MeshIndices indices) { return new MeshAttribute(tsMeshAttribute_optimizeAttribute(self, indices.getSelf())); }
		public MeshAttribute toDirect(MeshIndices indices) { return new MeshAttribute(tsMeshAttribute_toDirect(self, indices.getSelf())); }
		public MeshAttribute toFormat(Format format) { return new MeshAttribute(tsMeshAttribute_toFormat(self, format)); }
		public MeshAttribute toType(Type type) { return new MeshAttribute(tsMeshAttribute_toType(self, type)); }
		public Matrix4x3f getCovarianceMatrix() { return tsMeshAttribute_getCovarianceMatrix(self); }
		public Matrix4x3f getMinTransform() { return tsMeshAttribute_getMinTransform(self); }
		public BoundBoxf getBoundBox() { return tsMeshAttribute_getBoundBox(self); }
		public BoundSpheref getBoundSphere() { return tsMeshAttribute_getBoundSphere(self); }
		public ulong getMemory() { return tsMeshAttribute_getMemory(self); }
		public void set<Type>(uint index, in Type value) { Marshal.StructureToPtr(value, tsMeshAttribute_getPtr_cu(self, index), false); }
		public Type get<Type>(uint index, ref Type value) { value = Marshal.PtrToStructure<Type>(tsMeshAttribute_getPtr_cu(self, index)); return value; }
		public override string ToString() { return "Tellusim.MeshAttribute: Valid: " + tsMeshAttribute_isValidPtr(self) + "; Owner: " + tsMeshAttribute_isOwnerPtr(self) + "; Const: " + tsMeshAttribute_isConstPtr(self) + "; Count: " + tsMeshAttribute_getCountPtr(self) + "; Internal: 0x" + tsMeshAttribute_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshAttribute ptr) { return (ptr != null && tsMeshAttribute_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_new_su(string name, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_new_MATFsu(Type type, Format format, string name, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_new_MATFusu(Type type, Format format, uint size, string name, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_new_MATFuu(Type type, Format format, uint size, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshAttribute_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_create(HandleRef self, Type type, Format format, uint size);
		[DllImport(Base.Import)] private static extern Type tsMeshAttribute_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getTypeName_MAT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isUnknown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isPosition(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isBasis(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isNormal(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isTangent(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isBinormal(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isSpatial(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isNormalized(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isTexCoord(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isWeights(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isJoints(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isColor(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isVertex(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isCrease(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsMeshAttribute_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getFormatName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshAttribute_getComponents(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_isPacked(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setIndex(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsMeshAttribute_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setIndices(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getIndices_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setGeometry(HandleRef self, HandleRef geometry, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getGeometry_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setSize(HandleRef self, uint size, bool discard, bool clear);
		[DllImport(Base.Import)] private static extern uint tsMeshAttribute_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshAttribute_getStride(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsMeshAttribute_getBytes(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setData_puu(HandleRef self, IntPtr src, uint size, uint stride);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setData_pcA32u(HandleRef self, IntPtr src, uint[] indices, uint indices_size, uint stride);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_getData_cpruu(HandleRef self, IntPtr dest, uint size, uint stride);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_getData_cprcMIu(HandleRef self, IntPtr dest, HandleRef indices, uint stride);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_getData_cprcA32u(HandleRef self, IntPtr dest, uint[] indices, uint indices_size, uint stride);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getData_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_setValue(HandleRef self, uint index, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_getValue(HandleRef self, uint index, IntPtr dest, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_getPtr_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern int tsMeshAttribute_compare(HandleRef self, HandleRef attribute, in Matrix4x3f transform, float threshold, bool spatial);
		[DllImport(Base.Import)] private static extern void tsMeshAttribute_addAttribute(HandleRef self, HandleRef attribute);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_setTransform(HandleRef self, in Matrix4x3f transform);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_morphAttribute(HandleRef self, HandleRef attribute, float k);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_packAttributes(HandleRef self, HandleRef attribute_0, HandleRef attribute_1, Format format);
		[DllImport(Base.Import)] private static extern bool tsMeshAttribute_unpackAttributes(HandleRef self, HandleRef attribute_0, HandleRef attribute_1);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_optimizeAttribute(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_toDirect(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_toFormat(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttribute_toType(HandleRef self, Type type);
		[DllImport(Base.Import)] private static extern Matrix4x3f tsMeshAttribute_getCovarianceMatrix(HandleRef self);
		[DllImport(Base.Import)] private static extern Matrix4x3f tsMeshAttribute_getMinTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern BoundBoxf tsMeshAttribute_getBoundBox(HandleRef self);
		[DllImport(Base.Import)] private static extern BoundSpheref tsMeshAttribute_getBoundSphere(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsMeshAttribute_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshJoint
	public sealed class MeshJoint {
		public MeshJoint(string name = "") { self = new HandleRef(this, tsMeshJoint_new_s(name)); owner = true; }
		public MeshJoint(MeshGeometry geometry, string name = "") { self = new HandleRef(this, tsMeshJoint_new_MGs(geometry.getSelf(), name)); owner = true; }
		public MeshJoint(MeshJoint ptr) { self = new HandleRef(this, tsMeshJoint_copyPtr(ptr.getSelf())); owner = true; }
		public MeshJoint(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshJoint_isOwnerPtr(self); }
		public static MeshJoint Null() { return new MeshJoint(IntPtr.Zero); }
		~MeshJoint() { if(owner) tsMeshJoint_delete(self); }
		public bool equalPtr(MeshJoint ptr) { return tsMeshJoint_equalPtr(self, ptr.getSelf()); }
		public MeshJoint clonePtr() { return new MeshJoint(tsMeshJoint_clonePtr(self)); }
		public void clearPtr() { tsMeshJoint_clearPtr(self); }
		public void destroyPtr() { tsMeshJoint_destroyPtr(self); }
		public void acquirePtr() { tsMeshJoint_acquirePtr(self); }
		public void unacquirePtr() { tsMeshJoint_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshJoint_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshJoint_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshJoint_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshJoint_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshJoint_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshJoint_clear(self); }
		public void setName(string name) { tsMeshJoint_setName(self, name); }
		public string getName() { return Base.getString(tsMeshJoint_getName(self)); }
		public void setNode(MeshNode node) { tsMeshJoint_setNode(self, node.getSelf()); }
		public MeshNode getNode() { return new MeshNode(tsMeshJoint_getNode_c(self)); }
		public uint getNodeIndex() { return tsMeshJoint_getNodeIndex(self); }
		public Matrix4x3d getLocalTransform() { return tsMeshJoint_getLocalTransform(self); }
		public Matrix4x3d getGlobalTransform() { return tsMeshJoint_getGlobalTransform(self); }
		public void setIndices(MeshIndices indices) { tsMeshJoint_setIndices(self, indices.getSelf()); }
		public MeshIndices getIndices() { return new MeshIndices(tsMeshJoint_getIndices_c(self)); }
		public void setGeometry(MeshGeometry geometry, bool check = true) { tsMeshJoint_setGeometry(self, geometry.getSelf(), check); }
		public MeshGeometry getGeometry() { return new MeshGeometry(tsMeshJoint_getGeometry_c(self)); }
		public void setBoundBox(in BoundBoxf box) { tsMeshJoint_setBoundBox(self, in box); }
		public BoundBoxf getBoundBox() { return tsMeshJoint_getBoundBox(self); }
		public void setBoundSphere(in BoundSpheref sphere) { tsMeshJoint_setBoundSphere(self, in sphere); }
		public BoundSpheref getBoundSphere() { return tsMeshJoint_getBoundSphere(self); }
		public void setITransform(in Matrix4x3f itransform) { tsMeshJoint_setITransform(self, in itransform); }
		public Matrix4x3f getITransform() { return tsMeshJoint_getITransform(self); }
		public int compare(MeshJoint joint) { return tsMeshJoint_compare(self, joint.getSelf()); }
		public ulong getMemory() { return tsMeshJoint_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshJoint: Valid: " + tsMeshJoint_isValidPtr(self) + "; Owner: " + tsMeshJoint_isOwnerPtr(self) + "; Const: " + tsMeshJoint_isConstPtr(self) + "; Count: " + tsMeshJoint_getCountPtr(self) + "; Internal: 0x" + tsMeshJoint_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshJoint ptr) { return (ptr != null && tsMeshJoint_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_new_MGs(HandleRef geometry, string name);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshJoint_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshJoint_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshJoint_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshJoint_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshJoint_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setNode(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_getNode_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshJoint_getNodeIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshJoint_getLocalTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshJoint_getGlobalTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setIndices(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_getIndices_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setGeometry(HandleRef self, HandleRef geometry, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshJoint_getGeometry_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setBoundBox(HandleRef self, in BoundBoxf box);
		[DllImport(Base.Import)] private static extern BoundBoxf tsMeshJoint_getBoundBox(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setBoundSphere(HandleRef self, in BoundSpheref sphere);
		[DllImport(Base.Import)] private static extern BoundSpheref tsMeshJoint_getBoundSphere(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshJoint_setITransform(HandleRef self, in Matrix4x3f itransform);
		[DllImport(Base.Import)] private static extern Matrix4x3f tsMeshJoint_getITransform(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsMeshJoint_compare(HandleRef self, HandleRef joint);
		[DllImport(Base.Import)] private static extern ulong tsMeshJoint_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshMaterial
	public sealed class MeshMaterial {
		public enum Flags : uint {
			None = 0,
			Bool = 1,
			Scalarf32 = 2,
			Vector4f = 4,
			Matrix3x2f = 8,
			Color = 16,
			Name = 32,
			Layout = 64,
			Blob = 128,
			Image = 256,
			Texture = 416,
		}
		public MeshMaterial(string name = "") { self = new HandleRef(this, tsMeshMaterial_new_s(name)); owner = true; }
		public MeshMaterial(MeshGeometry geometry, string name = "") { self = new HandleRef(this, tsMeshMaterial_new_MGs(geometry.getSelf(), name)); owner = true; }
		public MeshMaterial(MeshMaterial ptr) { self = new HandleRef(this, tsMeshMaterial_copyPtr(ptr.getSelf())); owner = true; }
		public MeshMaterial(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshMaterial_isOwnerPtr(self); }
		public static MeshMaterial Null() { return new MeshMaterial(IntPtr.Zero); }
		~MeshMaterial() { if(owner) tsMeshMaterial_delete(self); }
		public bool equalPtr(MeshMaterial ptr) { return tsMeshMaterial_equalPtr(self, ptr.getSelf()); }
		public MeshMaterial clonePtr() { return new MeshMaterial(tsMeshMaterial_clonePtr(self)); }
		public void clearPtr() { tsMeshMaterial_clearPtr(self); }
		public void destroyPtr() { tsMeshMaterial_destroyPtr(self); }
		public void acquirePtr() { tsMeshMaterial_acquirePtr(self); }
		public void unacquirePtr() { tsMeshMaterial_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshMaterial_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshMaterial_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshMaterial_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshMaterial_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshMaterial_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshMaterial_clear(self); }
		public void setName(string name) { tsMeshMaterial_setName(self, name); }
		public string getName() { return Base.getString(tsMeshMaterial_getName(self)); }
		public uint getIndex() { return tsMeshMaterial_getIndex(self); }
		public void setIndices(MeshIndices indices) { tsMeshMaterial_setIndices(self, indices.getSelf()); }
		public MeshIndices getIndices() { return new MeshIndices(tsMeshMaterial_getIndices_c(self)); }
		public void setGeometry(MeshGeometry geometry, bool check = true) { tsMeshMaterial_setGeometry(self, geometry.getSelf(), check); }
		public MeshGeometry getGeometry() { return new MeshGeometry(tsMeshMaterial_getGeometry_c(self)); }
		public void setData(string data) { tsMeshMaterial_setData_s(self, data); }
		public void setData(String data) { tsMeshMaterial_setData_cS(self, data.getSelf()); }
		public string getData() { return Base.getString(tsMeshMaterial_getData(self)); }
		public void clearParameters() { tsMeshMaterial_clearParameters(self); }
		public bool removeParameter(string type) { return tsMeshMaterial_removeParameter(self, type); }
		public void copyParameters(MeshMaterial material) { tsMeshMaterial_copyParameters(self, material.getSelf()); }
		public uint findParameter(string type) { return tsMeshMaterial_findParameter(self, type); }
		public bool hasParameter(string type) { return tsMeshMaterial_hasParameter(self, type); }
		public uint getNumParameters() { return tsMeshMaterial_getNumParameters(self); }
		public string getParameterType(uint index) { return Base.getString(tsMeshMaterial_getParameterType(self, index)); }
		public void addParameter(string type, bool value) { tsMeshMaterial_addParameter_sb(self, type, value); }
		public void addParameter(string type, float value) { tsMeshMaterial_addParameter_sf(self, type, value); }
		public void addParameter(string type, in Vector4f value) { tsMeshMaterial_addParameter_scV4(self, type, in value); }
		public void addParameter(string type, in Matrix3x2f value) { tsMeshMaterial_addParameter_scM32(self, type, in value); }
		public void addParameter(string type, in Color color) { tsMeshMaterial_addParameter_scC(self, type, in color); }
		public void addParameter(string type, string name, string layout = "") { tsMeshMaterial_addParameter_sss(self, type, name, layout); }
		public void addParameter(string type, String name, string layout = "") { tsMeshMaterial_addParameter_scSs(self, type, name.getSelf(), layout); }
		public void addParameter(string type, Image image, string layout = "") { tsMeshMaterial_addParameter_scIs(self, type, image.getSelf(), layout); }
		public void addParameter(string type, Blob blob, string layout = "") { tsMeshMaterial_addParameter_sBs(self, type, blob.getSelf(), layout); }
		public Flags getParameterFlags(uint index) { return tsMeshMaterial_getParameterFlags_cu(self, index); }
		public bool hasParameterFlag(uint index, Flags flags) { return tsMeshMaterial_hasParameterFlag_cuMMF(self, index, flags); }
		public bool hasParameterFlags(uint index, Flags flags) { return tsMeshMaterial_hasParameterFlags_cuMMF(self, index, flags); }
		public bool getParameterBool(uint index, bool value = false) { return tsMeshMaterial_getParameterBool_cub(self, index, value); }
		public float getParameterScalarf32(uint index, float value = 0.0f) { return tsMeshMaterial_getParameterScalarf32_cuf(self, index, value); }
		public Vector4f getParameterVector4f(uint index, in Vector4f vector) { return tsMeshMaterial_getParameterVector4f_cucV4(self, index, in vector); }
		public Matrix3x2f getParameterMatrix3x2f(uint index, in Matrix3x2f matrix) { return tsMeshMaterial_getParameterMatrix3x2f_cucM32(self, index, in matrix); }
		public Color getParameterColor(uint index, in Color color) { return tsMeshMaterial_getParameterColor_cucC(self, index, in color); }
		public string getParameterName(uint index, String name = null) { return Base.getString(tsMeshMaterial_getParameterName_cucS(self, index, (name != null) ? name.getSelf() : Base.Null)); }
		public string getParameterLayout(uint index, String layout = null) { return Base.getString(tsMeshMaterial_getParameterLayout_cucS(self, index, (layout != null) ? layout.getSelf() : Base.Null)); }
		public Image getParameterImage(uint index) { return new Image(tsMeshMaterial_getParameterImage_cu(self, index)); }
		public Blob getParameterBlob(uint index) { return new Blob(tsMeshMaterial_getParameterBlob_cu(self, index)); }
		public Flags getParameterFlags(string type) { return tsMeshMaterial_getParameterFlags_cs(self, type); }
		public bool hasParameterFlag(string type, Flags flags) { return tsMeshMaterial_hasParameterFlag_csMMF(self, type, flags); }
		public bool hasParameterFlags(string type, Flags flags) { return tsMeshMaterial_hasParameterFlags_csMMF(self, type, flags); }
		public bool getParameterBool(string type, bool value = false) { return tsMeshMaterial_getParameterBool_csb(self, type, value); }
		public float getParameterScalarf32(string type, float value = 0.0f) { return tsMeshMaterial_getParameterScalarf32_csf(self, type, value); }
		public Vector4f getParameterVector4f(string type, in Vector4f vector) { return tsMeshMaterial_getParameterVector4f_cscV4(self, type, in vector); }
		public Matrix3x2f getParameterMatrix3x2f(string type, in Matrix3x2f matrix) { return tsMeshMaterial_getParameterMatrix3x2f_cscM32(self, type, in matrix); }
		public Color getParameterColor(string type, in Color color) { return tsMeshMaterial_getParameterColor_cscC(self, type, in color); }
		public string getParameterName(string type, String name = null) { return Base.getString(tsMeshMaterial_getParameterName_cscS(self, type, (name != null) ? name.getSelf() : Base.Null)); }
		public string getParameterLayout(string type, String layout = null) { return Base.getString(tsMeshMaterial_getParameterLayout_cscS(self, type, (layout != null) ? layout.getSelf() : Base.Null)); }
		public int compare(MeshMaterial material) { return tsMeshMaterial_compare(self, material.getSelf()); }
		public ulong getMemory() { return tsMeshMaterial_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshMaterial: Valid: " + tsMeshMaterial_isValidPtr(self) + "; Owner: " + tsMeshMaterial_isOwnerPtr(self) + "; Const: " + tsMeshMaterial_isConstPtr(self) + "; Count: " + tsMeshMaterial_getCountPtr(self) + "; Internal: 0x" + tsMeshMaterial_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshMaterial ptr) { return (ptr != null && tsMeshMaterial_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_new_MGs(HandleRef geometry, string name);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshMaterial_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshMaterial_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_setIndices(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getIndices_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_setGeometry(HandleRef self, HandleRef geometry, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getGeometry_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_setData_s(HandleRef self, string data);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_setData_cS(HandleRef self, HandleRef data);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getData(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_clearParameters(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_removeParameter(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_copyParameters(HandleRef self, HandleRef material);
		[DllImport(Base.Import)] private static extern uint tsMeshMaterial_findParameter(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_hasParameter(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern uint tsMeshMaterial_getNumParameters(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterType(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_sb(HandleRef self, string type, bool value);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_sf(HandleRef self, string type, float value);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_scV4(HandleRef self, string type, in Vector4f value);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_scM32(HandleRef self, string type, in Matrix3x2f value);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_scC(HandleRef self, string type, in Color color);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_sss(HandleRef self, string type, string name, string layout);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_scSs(HandleRef self, string type, HandleRef name, string layout);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_scIs(HandleRef self, string type, HandleRef image, string layout);
		[DllImport(Base.Import)] private static extern void tsMeshMaterial_addParameter_sBs(HandleRef self, string type, HandleRef blob, string layout);
		[DllImport(Base.Import)] private static extern Flags tsMeshMaterial_getParameterFlags_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_hasParameterFlag_cuMMF(HandleRef self, uint index, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_hasParameterFlags_cuMMF(HandleRef self, uint index, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_getParameterBool_cub(HandleRef self, uint index, bool value);
		[DllImport(Base.Import)] private static extern float tsMeshMaterial_getParameterScalarf32_cuf(HandleRef self, uint index, float value);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshMaterial_getParameterVector4f_cucV4(HandleRef self, uint index, in Vector4f vector);
		[DllImport(Base.Import)] private static extern Matrix3x2f tsMeshMaterial_getParameterMatrix3x2f_cucM32(HandleRef self, uint index, in Matrix3x2f matrix);
		[DllImport(Base.Import)] private static extern Color tsMeshMaterial_getParameterColor_cucC(HandleRef self, uint index, in Color color);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterName_cucS(HandleRef self, uint index, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterLayout_cucS(HandleRef self, uint index, HandleRef layout);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterImage_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterBlob_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Flags tsMeshMaterial_getParameterFlags_cs(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_hasParameterFlag_csMMF(HandleRef self, string type, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_hasParameterFlags_csMMF(HandleRef self, string type, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshMaterial_getParameterBool_csb(HandleRef self, string type, bool value);
		[DllImport(Base.Import)] private static extern float tsMeshMaterial_getParameterScalarf32_csf(HandleRef self, string type, float value);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshMaterial_getParameterVector4f_cscV4(HandleRef self, string type, in Vector4f vector);
		[DllImport(Base.Import)] private static extern Matrix3x2f tsMeshMaterial_getParameterMatrix3x2f_cscM32(HandleRef self, string type, in Matrix3x2f matrix);
		[DllImport(Base.Import)] private static extern Color tsMeshMaterial_getParameterColor_cscC(HandleRef self, string type, in Color color);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterName_cscS(HandleRef self, string type, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshMaterial_getParameterLayout_cscS(HandleRef self, string type, HandleRef layout);
		[DllImport(Base.Import)] private static extern int tsMeshMaterial_compare(HandleRef self, HandleRef material);
		[DllImport(Base.Import)] private static extern ulong tsMeshMaterial_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshGeometry
	public sealed class MeshGeometry {
		public MeshGeometry(string name = "") { self = new HandleRef(this, tsMeshGeometry_new_s(name)); owner = true; }
		public MeshGeometry(Mesh mesh, string name = "") { self = new HandleRef(this, tsMeshGeometry_new_Ms(mesh.getSelf(), name)); owner = true; }
		public MeshGeometry(MeshGeometry ptr) { self = new HandleRef(this, tsMeshGeometry_copyPtr(ptr.getSelf())); owner = true; }
		public MeshGeometry(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshGeometry_isOwnerPtr(self); }
		public static MeshGeometry Null() { return new MeshGeometry(IntPtr.Zero); }
		~MeshGeometry() { if(owner) tsMeshGeometry_delete(self); }
		public bool equalPtr(MeshGeometry ptr) { return tsMeshGeometry_equalPtr(self, ptr.getSelf()); }
		public MeshGeometry clonePtr() { return new MeshGeometry(tsMeshGeometry_clonePtr(self)); }
		public void clearPtr() { tsMeshGeometry_clearPtr(self); }
		public void destroyPtr() { tsMeshGeometry_destroyPtr(self); }
		public void acquirePtr() { tsMeshGeometry_acquirePtr(self); }
		public void unacquirePtr() { tsMeshGeometry_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshGeometry_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshGeometry_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshGeometry_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshGeometry_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshGeometry_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshGeometry_clear(self); }
		public void setName(string name) { tsMeshGeometry_setName(self, name); }
		public string getName() { return Base.getString(tsMeshGeometry_getName(self)); }
		public uint getIndex() { return tsMeshGeometry_getIndex(self); }
		public void setMesh(Mesh mesh, bool check = true) { tsMeshGeometry_setMesh(self, mesh.getSelf(), check); }
		public Mesh getMesh() { return new Mesh(tsMeshGeometry_getMesh_c(self)); }
		public uint setParent0(MeshGeometry parent, bool check = true) { return tsMeshGeometry_setParent0(self, parent.getSelf(), check); }
		public uint setParent1(MeshGeometry parent, bool check = true) { return tsMeshGeometry_setParent1(self, parent.getSelf(), check); }
		public MeshGeometry getParent0() { return new MeshGeometry(tsMeshGeometry_getParent0_c(self)); }
		public MeshGeometry getParent1() { return new MeshGeometry(tsMeshGeometry_getParent1_c(self)); }
		public bool isRoot() { return tsMeshGeometry_isRoot(self); }
		public void reserveChildren(uint num_children) { tsMeshGeometry_reserveChildren(self, num_children); }
		public uint addChild0(MeshGeometry child, bool check = true) { return tsMeshGeometry_addChild0(self, child.getSelf(), check); }
		public uint addChild1(MeshGeometry child, bool check = true) { return tsMeshGeometry_addChild1(self, child.getSelf(), check); }
		public bool removeChild(MeshGeometry child) { return tsMeshGeometry_removeChild(self, child.getSelf()); }
		public void releaseChildren() { tsMeshGeometry_releaseChildren(self); }
		public uint findChild(MeshGeometry child) { return tsMeshGeometry_findChild(self, child.getSelf()); }
		public uint getNumChildren() { return tsMeshGeometry_getNumChildren(self); }
		public MeshGeometry getChild(uint index) { return new MeshGeometry(tsMeshGeometry_getChild_cu(self, index)); }
		public void clearIndices() { tsMeshGeometry_clearIndices(self); }
		public void reserveIndices(uint num_indices) { tsMeshGeometry_reserveIndices(self, num_indices); }
		public uint addIndices(MeshIndices indices, bool check = true) { return tsMeshGeometry_addIndices(self, indices.getSelf(), check); }
		public bool removeIndices(MeshIndices indices) { return tsMeshGeometry_removeIndices(self, indices.getSelf()); }
		public bool replaceIndices(MeshIndices old_indices, MeshIndices indices) { return tsMeshGeometry_replaceIndices(self, old_indices.getSelf(), indices.getSelf()); }
		public uint findIndices(MeshIndices indices) { return tsMeshGeometry_findIndices_ccMI(self, indices.getSelf()); }
		public uint findIndices(MeshIndices.Type type) { return tsMeshGeometry_findIndices_cMIT(self, type); }
		public bool hasIndices(MeshIndices.Type type) { return tsMeshGeometry_hasIndices(self, type); }
		public bool hasSolidIndices() { return tsMeshGeometry_hasSolidIndices(self); }
		public uint getNumIndices(MeshIndices.Type type) { return tsMeshGeometry_getNumIndices_cMIT(self, type); }
		public MeshIndices getIndices(MeshIndices.Type type) { return new MeshIndices(tsMeshGeometry_getIndices_cMIT(self, type)); }
		public uint getNumIndices() { return tsMeshGeometry_getNumIndices_c(self); }
		public MeshIndices getIndices(uint index) { return new MeshIndices(tsMeshGeometry_getIndices_cu(self, index)); }
		public void clearAttributes() { tsMeshGeometry_clearAttributes(self); }
		public void reserveAttributes(uint num_attributes) { tsMeshGeometry_reserveAttributes(self, num_attributes); }
		public uint addAttribute(MeshAttribute attribute, bool check = true) { return tsMeshGeometry_addAttribute_MAb(self, attribute.getSelf(), check); }
		public uint addAttribute(MeshAttribute attribute, MeshIndices indices, bool check = true) { return tsMeshGeometry_addAttribute_MAMIb(self, attribute.getSelf(), indices.getSelf(), check); }
		public bool removeAttribute(MeshAttribute attribute) { return tsMeshGeometry_removeAttribute(self, attribute.getSelf()); }
		public bool replaceAttribute(MeshAttribute old_attribute, MeshAttribute attribute) { return tsMeshGeometry_replaceAttribute(self, old_attribute.getSelf(), attribute.getSelf()); }
		public bool replaceAttributeIndices(MeshIndices old_indices, MeshIndices indices) { return tsMeshGeometry_replaceAttributeIndices(self, old_indices.getSelf(), indices.getSelf()); }
		public uint findAttribute(MeshAttribute.Type type, Format format, uint index = 0) { return tsMeshGeometry_findAttribute_cMATFu(self, type, format, index); }
		public uint findAttribute(MeshAttribute.Type type, uint index = 0) { return tsMeshGeometry_findAttribute_cMATu(self, type, index); }
		public uint findAttribute(string name, uint index = 0) { return tsMeshGeometry_findAttribute_csu(self, name, index); }
		public uint findAttribute(MeshAttribute attribute) { return tsMeshGeometry_findAttribute_ccMA(self, attribute.getSelf()); }
		public bool hasAttribute(MeshAttribute.Type type, Format format, uint index = 0) { return tsMeshGeometry_hasAttribute_cMATFu(self, type, format, index); }
		public bool hasAttribute(MeshAttribute.Type type, uint index = 0) { return tsMeshGeometry_hasAttribute_cMATu(self, type, index); }
		public bool hasAttribute(string name, uint index = 0) { return tsMeshGeometry_hasAttribute_csu(self, name, index); }
		public bool hasAttribute(MeshAttribute attribute) { return tsMeshGeometry_hasAttribute_ccMA(self, attribute.getSelf()); }
		public uint getNumAttributes(MeshAttribute.Type type) { return tsMeshGeometry_getNumAttributes_cMAT(self, type); }
		public uint getNumAttributes(MeshIndices indices) { return tsMeshGeometry_getNumAttributes_ccMI(self, indices.getSelf()); }
		public MeshAttribute getAttribute(MeshAttribute.Type type, uint index = 0) { return new MeshAttribute(tsMeshGeometry_getAttribute_cMATu(self, type, index)); }
		public uint getNumAttributes() { return tsMeshGeometry_getNumAttributes_c(self); }
		public MeshAttribute getAttribute(uint index) { return new MeshAttribute(tsMeshGeometry_getAttribute_cu(self, index)); }
		public void clearJoints() { tsMeshGeometry_clearJoints(self); }
		public void reserveJoints(uint num_joints) { tsMeshGeometry_reserveJoints(self, num_joints); }
		public uint addJoint(MeshJoint joint, bool check = true) { return tsMeshGeometry_addJoint_MJb(self, joint.getSelf(), check); }
		public uint addJoint(MeshJoint joint, MeshNode node, bool check = true) { return tsMeshGeometry_addJoint_MJMNb(self, joint.getSelf(), node.getSelf(), check); }
		public bool removeJoint(MeshJoint joint) { return tsMeshGeometry_removeJoint(self, joint.getSelf()); }
		public bool replaceJoint(MeshJoint old_joint, MeshJoint joint) { return tsMeshGeometry_replaceJoint(self, old_joint.getSelf(), joint.getSelf()); }
		public uint findJoint(MeshJoint joint) { return tsMeshGeometry_findJoint_ccMJ(self, joint.getSelf()); }
		public uint findJoint(MeshNode node) { return tsMeshGeometry_findJoint_ccMN(self, node.getSelf()); }
		public uint findJoint(string name) { return tsMeshGeometry_findJoint_cs(self, name); }
		public uint getNumJoints() { return tsMeshGeometry_getNumJoints(self); }
		public MeshJoint getJoint(uint index) { return new MeshJoint(tsMeshGeometry_getJoint_cu(self, index)); }
		public void clearMaterials() { tsMeshGeometry_clearMaterials(self); }
		public void reserveMaterials(uint num_materials) { tsMeshGeometry_reserveMaterials(self, num_materials); }
		public uint addMaterial(MeshMaterial material, bool check = true) { return tsMeshGeometry_addMaterial_MMb(self, material.getSelf(), check); }
		public uint addMaterial(MeshMaterial material, MeshIndices indices, bool check = true) { return tsMeshGeometry_addMaterial_MMMIb(self, material.getSelf(), indices.getSelf(), check); }
		public bool removeMaterial(MeshMaterial material) { return tsMeshGeometry_removeMaterial(self, material.getSelf()); }
		public bool replaceMaterial(MeshMaterial old_material, MeshMaterial material) { return tsMeshGeometry_replaceMaterial(self, old_material.getSelf(), material.getSelf()); }
		public uint findMaterial(MeshMaterial material) { return tsMeshGeometry_findMaterial_ccMM(self, material.getSelf()); }
		public uint findMaterial(string name) { return tsMeshGeometry_findMaterial_cs(self, name); }
		public uint getNumMaterials() { return tsMeshGeometry_getNumMaterials(self); }
		public MeshMaterial getMaterial(uint index) { return new MeshMaterial(tsMeshGeometry_getMaterial_cu(self, index)); }
		public void setBoundBox(in BoundBoxf box) { tsMeshGeometry_setBoundBox(self, in box); }
		public BoundBoxf getBoundBox() { return tsMeshGeometry_getBoundBox(self); }
		public void setBoundSphere(in BoundSpheref sphere) { tsMeshGeometry_setBoundSphere(self, in sphere); }
		public BoundSpheref getBoundSphere() { return tsMeshGeometry_getBoundSphere(self); }
		public bool setTransform(in Vector3f scale) { return tsMeshGeometry_setTransform_cV3(self, in scale); }
		public bool setTransform(in Matrix4x3f transform, bool apply = false) { return tsMeshGeometry_setTransform_cM43b(self, in transform, apply); }
		public Matrix4x3f getTransform() { return tsMeshGeometry_getTransform(self); }
		public void setJointITransform(in Matrix4x3f itransform) { tsMeshGeometry_setJointITransform(self, in itransform); }
		public Matrix4x3f getJointITransform() { return tsMeshGeometry_getJointITransform(self); }
		public void setMinVisibility(float distance) { tsMeshGeometry_setMinVisibility(self, distance); }
		public void setMaxVisibility(float distance) { tsMeshGeometry_setMaxVisibility(self, distance); }
		public void setVisibilityRange(float min, float max) { tsMeshGeometry_setVisibilityRange(self, min, max); }
		public float getMinVisibility() { return tsMeshGeometry_getMinVisibility(self); }
		public float getMaxVisibility() { return tsMeshGeometry_getMaxVisibility(self); }
		public bool hasVisibilityRange() { return tsMeshGeometry_hasVisibilityRange(self); }
		public void setVisibilityError(float error) { tsMeshGeometry_setVisibilityError(self, error); }
		public float getVisibilityError() { return tsMeshGeometry_getVisibilityError(self); }
		public bool createBounds(bool force = false, uint position = Base.Maxu32) { return tsMeshGeometry_createBounds(self, force, position); }
		public uint createBasis(bool force = false, uint position = Base.Maxu32, uint normal = Base.Maxu32, uint tangent = Base.Maxu32, bool append = false) { return tsMeshGeometry_createBasis_buuub(self, force, position, normal, tangent, append); }
		public uint createBasis(float angle, bool force = false, uint position = Base.Maxu32, uint normal = Base.Maxu32, uint tangent = Base.Maxu32, bool append = false) { return tsMeshGeometry_createBasis_fbuuub(self, angle, force, position, normal, tangent, append); }
		public uint createNormals(bool force = false, uint position = Base.Maxu32, bool append = false) { return tsMeshGeometry_createNormals_bub(self, force, position, append); }
		public uint createNormals(float angle, bool force = false, uint position = Base.Maxu32, bool append = false) { return tsMeshGeometry_createNormals_fbub(self, angle, force, position, append); }
		public uint createTangents(bool force = false, uint position = Base.Maxu32, uint normal = Base.Maxu32, uint texcoord = Base.Maxu32, bool append = false) { return tsMeshGeometry_createTangents(self, force, position, normal, texcoord, append); }
		public uint createIslands(uint max_attributes, uint max_primitives, bool force = false, uint index = Base.Maxu32, uint position = Base.Maxu32, bool append = false) { return tsMeshGeometry_createIslands(self, max_attributes, max_primitives, force, index, position, append); }
		public bool optimizeIndices(uint cache = 32, bool transparent = false, uint index = Base.Maxu32, uint position = Base.Maxu32) { return tsMeshGeometry_optimizeIndices(self, cache, transparent, index, position); }
		public bool optimizeAttributes(uint material = Base.Maxu32) { return tsMeshGeometry_optimizeAttributes(self, material); }
		public void optimizeMaterials() { tsMeshGeometry_optimizeMaterials(self); }
		public bool packAttributes(bool remove = true) { return tsMeshGeometry_packAttributes(self, remove); }
		public bool unpackAttributes(bool remove = true) { return tsMeshGeometry_unpackAttributes(self, remove); }
		public int compare(MeshGeometry geometry, in Matrix4x3f transform, float threshold = 1e-6f, bool spatial = true) { return tsMeshGeometry_compare(self, geometry.getSelf(), in transform, threshold, spatial); }
		public bool isOptimized() { return tsMeshGeometry_isOptimized(self); }
		public bool validate() { return tsMeshGeometry_validate(self); }
		public ulong getMemory() { return tsMeshGeometry_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshGeometry: Valid: " + tsMeshGeometry_isValidPtr(self) + "; Owner: " + tsMeshGeometry_isOwnerPtr(self) + "; Const: " + tsMeshGeometry_isConstPtr(self) + "; Count: " + tsMeshGeometry_getCountPtr(self) + "; Internal: 0x" + tsMeshGeometry_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshGeometry ptr) { return (ptr != null && tsMeshGeometry_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_new_Ms(HandleRef mesh, string name);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setMesh(HandleRef self, HandleRef mesh, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getMesh_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_setParent0(HandleRef self, HandleRef parent, bool check);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_setParent1(HandleRef self, HandleRef parent, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getParent0_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getParent1_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_isRoot(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_reserveChildren(HandleRef self, uint num_children);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addChild0(HandleRef self, HandleRef child, bool check);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addChild1(HandleRef self, HandleRef child, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_removeChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_releaseChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getChild_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_clearIndices(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_reserveIndices(HandleRef self, uint num_indices);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addIndices(HandleRef self, HandleRef indices, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_removeIndices(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_replaceIndices(HandleRef self, HandleRef old_indices, HandleRef indices);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findIndices_ccMI(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findIndices_cMIT(HandleRef self, MeshIndices.Type type);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasIndices(HandleRef self, MeshIndices.Type type);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasSolidIndices(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumIndices_cMIT(HandleRef self, MeshIndices.Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getIndices_cMIT(HandleRef self, MeshIndices.Type type);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumIndices_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getIndices_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_clearAttributes(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_reserveAttributes(HandleRef self, uint num_attributes);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addAttribute_MAb(HandleRef self, HandleRef attribute, bool check);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addAttribute_MAMIb(HandleRef self, HandleRef attribute, HandleRef indices, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_removeAttribute(HandleRef self, HandleRef attribute);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_replaceAttribute(HandleRef self, HandleRef old_attribute, HandleRef attribute);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_replaceAttributeIndices(HandleRef self, HandleRef old_indices, HandleRef indices);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findAttribute_cMATFu(HandleRef self, MeshAttribute.Type type, Format format, uint index);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findAttribute_cMATu(HandleRef self, MeshAttribute.Type type, uint index);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findAttribute_csu(HandleRef self, string name, uint index);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findAttribute_ccMA(HandleRef self, HandleRef attribute);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasAttribute_cMATFu(HandleRef self, MeshAttribute.Type type, Format format, uint index);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasAttribute_cMATu(HandleRef self, MeshAttribute.Type type, uint index);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasAttribute_csu(HandleRef self, string name, uint index);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasAttribute_ccMA(HandleRef self, HandleRef attribute);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumAttributes_cMAT(HandleRef self, MeshAttribute.Type type);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumAttributes_ccMI(HandleRef self, HandleRef indices);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getAttribute_cMATu(HandleRef self, MeshAttribute.Type type, uint index);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumAttributes_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getAttribute_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_clearJoints(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_reserveJoints(HandleRef self, uint num_joints);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addJoint_MJb(HandleRef self, HandleRef joint, bool check);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addJoint_MJMNb(HandleRef self, HandleRef joint, HandleRef node, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_removeJoint(HandleRef self, HandleRef joint);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_replaceJoint(HandleRef self, HandleRef old_joint, HandleRef joint);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findJoint_ccMJ(HandleRef self, HandleRef joint);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findJoint_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findJoint_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumJoints(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getJoint_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_clearMaterials(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_reserveMaterials(HandleRef self, uint num_materials);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addMaterial_MMb(HandleRef self, HandleRef material, bool check);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_addMaterial_MMMIb(HandleRef self, HandleRef material, HandleRef indices, bool check);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_removeMaterial(HandleRef self, HandleRef material);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_replaceMaterial(HandleRef self, HandleRef old_material, HandleRef material);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findMaterial_ccMM(HandleRef self, HandleRef material);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_findMaterial_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_getNumMaterials(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshGeometry_getMaterial_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setBoundBox(HandleRef self, in BoundBoxf box);
		[DllImport(Base.Import)] private static extern BoundBoxf tsMeshGeometry_getBoundBox(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setBoundSphere(HandleRef self, in BoundSpheref sphere);
		[DllImport(Base.Import)] private static extern BoundSpheref tsMeshGeometry_getBoundSphere(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_setTransform_cV3(HandleRef self, in Vector3f scale);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_setTransform_cM43b(HandleRef self, in Matrix4x3f transform, bool apply);
		[DllImport(Base.Import)] private static extern Matrix4x3f tsMeshGeometry_getTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setJointITransform(HandleRef self, in Matrix4x3f itransform);
		[DllImport(Base.Import)] private static extern Matrix4x3f tsMeshGeometry_getJointITransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setMinVisibility(HandleRef self, float distance);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setMaxVisibility(HandleRef self, float distance);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setVisibilityRange(HandleRef self, float min, float max);
		[DllImport(Base.Import)] private static extern float tsMeshGeometry_getMinVisibility(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsMeshGeometry_getMaxVisibility(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_hasVisibilityRange(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_setVisibilityError(HandleRef self, float error);
		[DllImport(Base.Import)] private static extern float tsMeshGeometry_getVisibilityError(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_createBounds(HandleRef self, bool force, uint position);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_createBasis_buuub(HandleRef self, bool force, uint position, uint normal, uint tangent, bool append);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_createBasis_fbuuub(HandleRef self, float angle, bool force, uint position, uint normal, uint tangent, bool append);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_createNormals_bub(HandleRef self, bool force, uint position, bool append);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_createNormals_fbub(HandleRef self, float angle, bool force, uint position, bool append);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_createTangents(HandleRef self, bool force, uint position, uint normal, uint texcoord, bool append);
		[DllImport(Base.Import)] private static extern uint tsMeshGeometry_createIslands(HandleRef self, uint max_attributes, uint max_primitives, bool force, uint index, uint position, bool append);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_optimizeIndices(HandleRef self, uint cache, bool transparent, uint index, uint position);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_optimizeAttributes(HandleRef self, uint material);
		[DllImport(Base.Import)] private static extern void tsMeshGeometry_optimizeMaterials(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_packAttributes(HandleRef self, bool remove);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_unpackAttributes(HandleRef self, bool remove);
		[DllImport(Base.Import)] private static extern int tsMeshGeometry_compare(HandleRef self, HandleRef geometry, in Matrix4x3f transform, float threshold, bool spatial);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_isOptimized(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshGeometry_validate(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsMeshGeometry_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshTransform
	public sealed class MeshTransform {
		public MeshTransform() { self = new HandleRef(this, tsMeshTransform_new()); owner = true; }
		public MeshTransform(MeshTransform ptr) { self = new HandleRef(this, tsMeshTransform_copyPtr(ptr.getSelf())); owner = true; }
		public MeshTransform(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshTransform_isOwnerPtr(self); }
		public static MeshTransform Null() { return new MeshTransform(IntPtr.Zero); }
		~MeshTransform() { if(owner) tsMeshTransform_delete(self); }
		public bool equalPtr(MeshTransform ptr) { return tsMeshTransform_equalPtr(self, ptr.getSelf()); }
		public MeshTransform clonePtr() { return new MeshTransform(tsMeshTransform_clonePtr(self)); }
		public void clearPtr() { tsMeshTransform_clearPtr(self); }
		public void destroyPtr() { tsMeshTransform_destroyPtr(self); }
		public void acquirePtr() { tsMeshTransform_acquirePtr(self); }
		public void unacquirePtr() { tsMeshTransform_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshTransform_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshTransform_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshTransform_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshTransform_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshTransform_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshTransform_clear(self); }
		public double getMinTime() { return tsMeshTransform_getMinTime(self); }
		public double getMaxTime() { return tsMeshTransform_getMaxTime(self); }
		public void setTransform(double time, in Matrix4x3d transform, float threshold = 1e-6f) { tsMeshTransform_setTransform_f64cM43f(self, time, in transform, threshold); }
		public void setTranslate(double time, in Vector3d translate, float threshold = 1e-6f) { tsMeshTransform_setTranslate(self, time, in translate, threshold); }
		public void setRotate(double time, in Quaternionf rotate, float threshold = 1e-6f) { tsMeshTransform_setRotate(self, time, in rotate, threshold); }
		public void setScale(double time, in Vector3f scale, float threshold = 1e-6f) { tsMeshTransform_setScale(self, time, in scale, threshold); }
		public void setMorph(double time, in Vector4f morph, float threshold = 1e-6f) { tsMeshTransform_setMorph(self, time, in morph, threshold); }
		public Matrix4x3d getTransform(double time) { return tsMeshTransform_getTransform(self, time); }
		public Vector3d getTranslate(double time) { return tsMeshTransform_getTranslate(self, time); }
		public Quaternionf getRotate(double time) { return tsMeshTransform_getRotate(self, time); }
		public Vector3f getScale(double time) { return tsMeshTransform_getScale(self, time); }
		public Vector4f getMorph(double time) { return tsMeshTransform_getMorph(self, time); }
		public bool hasTransformKeys() { return tsMeshTransform_hasTransformKeys(self); }
		public bool hasTranslateKeys() { return tsMeshTransform_hasTranslateKeys(self); }
		public bool hasRotateKeys() { return tsMeshTransform_hasRotateKeys(self); }
		public bool hasScaleKeys() { return tsMeshTransform_hasScaleKeys(self); }
		public bool hasMorphKeys() { return tsMeshTransform_hasMorphKeys(self); }
		public void setTransform(in Vector3d scale) { tsMeshTransform_setTransform_cV3(self, in scale); }
		public void setTransform(in Matrix4x3d transform) { tsMeshTransform_setTransform_cM43(self, in transform); }
		public ulong getMemory() { return tsMeshTransform_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshTransform: Valid: " + tsMeshTransform_isValidPtr(self) + "; Owner: " + tsMeshTransform_isOwnerPtr(self) + "; Const: " + tsMeshTransform_isConstPtr(self) + "; Count: " + tsMeshTransform_getCountPtr(self) + "; Internal: 0x" + tsMeshTransform_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshTransform ptr) { return (ptr != null && tsMeshTransform_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshTransform_new();
		[DllImport(Base.Import)] private static extern void tsMeshTransform_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshTransform_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshTransform_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshTransform_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshTransform_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsMeshTransform_getMinTime(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsMeshTransform_getMaxTime(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setTransform_f64cM43f(HandleRef self, double time, in Matrix4x3d transform, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setTranslate(HandleRef self, double time, in Vector3d translate, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setRotate(HandleRef self, double time, in Quaternionf rotate, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setScale(HandleRef self, double time, in Vector3f scale, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setMorph(HandleRef self, double time, in Vector4f morph, float threshold);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshTransform_getTransform(HandleRef self, double time);
		[DllImport(Base.Import)] private static extern Vector3d tsMeshTransform_getTranslate(HandleRef self, double time);
		[DllImport(Base.Import)] private static extern Quaternionf tsMeshTransform_getRotate(HandleRef self, double time);
		[DllImport(Base.Import)] private static extern Vector3f tsMeshTransform_getScale(HandleRef self, double time);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshTransform_getMorph(HandleRef self, double time);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_hasTransformKeys(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_hasTranslateKeys(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_hasRotateKeys(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_hasScaleKeys(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshTransform_hasMorphKeys(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setTransform_cV3(HandleRef self, in Vector3d scale);
		[DllImport(Base.Import)] private static extern void tsMeshTransform_setTransform_cM43(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern ulong tsMeshTransform_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshAnimation
	public sealed class MeshAnimation {
		public MeshAnimation(string name = "") { self = new HandleRef(this, tsMeshAnimation_new_s(name)); owner = true; }
		public MeshAnimation(Mesh mesh, string name = "") { self = new HandleRef(this, tsMeshAnimation_new_Ms(mesh.getSelf(), name)); owner = true; }
		public MeshAnimation(MeshAnimation ptr) { self = new HandleRef(this, tsMeshAnimation_copyPtr(ptr.getSelf())); owner = true; }
		public MeshAnimation(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshAnimation_isOwnerPtr(self); }
		public static MeshAnimation Null() { return new MeshAnimation(IntPtr.Zero); }
		~MeshAnimation() { if(owner) tsMeshAnimation_delete(self); }
		public bool equalPtr(MeshAnimation ptr) { return tsMeshAnimation_equalPtr(self, ptr.getSelf()); }
		public MeshAnimation clonePtr() { return new MeshAnimation(tsMeshAnimation_clonePtr(self)); }
		public void clearPtr() { tsMeshAnimation_clearPtr(self); }
		public void destroyPtr() { tsMeshAnimation_destroyPtr(self); }
		public void acquirePtr() { tsMeshAnimation_acquirePtr(self); }
		public void unacquirePtr() { tsMeshAnimation_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshAnimation_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshAnimation_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshAnimation_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshAnimation_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshAnimation_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshAnimation_clear(self); }
		public uint getIndex() { return tsMeshAnimation_getIndex(self); }
		public void setName(string name) { tsMeshAnimation_setName(self, name); }
		public string getName() { return Base.getString(tsMeshAnimation_getName(self)); }
		public void setMesh(Mesh mesh, bool check = true) { tsMeshAnimation_setMesh(self, mesh.getSelf(), check); }
		public Mesh getMesh() { return new Mesh(tsMeshAnimation_getMesh_c(self)); }
		public double getMinTime() { return tsMeshAnimation_getMinTime(self); }
		public double getMaxTime() { return tsMeshAnimation_getMaxTime(self); }
		public void setNumTransforms(uint num_transforms) { tsMeshAnimation_setNumTransforms(self, num_transforms); }
		public uint getNumTransforms() { return tsMeshAnimation_getNumTransforms(self); }
		public MeshTransform getTransform(uint node) { return new MeshTransform(tsMeshAnimation_getTransform_cu(self, node)); }
		public void setTransform(double time, uint node, in Matrix4x3d transform, float threshold = 1e-6f) { tsMeshAnimation_setTransform_f64ucM43f(self, time, node, in transform, threshold); }
		public void setTranslate(double time, uint node, in Vector3d translate, float threshold = 1e-6f) { tsMeshAnimation_setTranslate(self, time, node, in translate, threshold); }
		public void setRotate(double time, uint node, in Quaternionf rotate, float threshold = 1e-6f) { tsMeshAnimation_setRotate(self, time, node, in rotate, threshold); }
		public void setScale(double time, uint node, in Vector3f scale, float threshold = 1e-6f) { tsMeshAnimation_setScale(self, time, node, in scale, threshold); }
		public void setMorph(double time, uint node, in Vector4f morph, float threshold = 1e-6f) { tsMeshAnimation_setMorph(self, time, node, in morph, threshold); }
		public void setTime(double time, in Matrix4x3d transform, bool loop = true, double from = -Base.Maxf32, double to = Base.Maxf32) { tsMeshAnimation_setTime_f64cM43bf64f64(self, time, in transform, loop, from, to); }
		public void setTime(double time, bool loop, double from = -Base.Maxf32, double to = Base.Maxf32) { tsMeshAnimation_setTime_f64bf64f64(self, time, loop, from, to); }
		public Matrix4x3d getLocalTransform(uint node) { return tsMeshAnimation_getLocalTransform_cu(self, node); }
		public Matrix4x3d getLocalTransform(MeshNode node) { return tsMeshAnimation_getLocalTransform_ccMN(self, node.getSelf()); }
		public Matrix4x3d getLocalTransform(MeshJoint joint) { return tsMeshAnimation_getLocalTransform_ccMJ(self, joint.getSelf()); }
		public Matrix4x3d getGlobalTransform(uint node) { return tsMeshAnimation_getGlobalTransform_cu(self, node); }
		public Matrix4x3d getGlobalTransform(MeshNode node) { return tsMeshAnimation_getGlobalTransform_ccMN(self, node.getSelf()); }
		public Matrix4x3d getGlobalTransform(MeshJoint joint) { return tsMeshAnimation_getGlobalTransform_ccMJ(self, joint.getSelf()); }
		public Vector4f getMorphTransform(uint node) { return tsMeshAnimation_getMorphTransform_cu(self, node); }
		public Vector4f getMorphTransform(MeshNode node) { return tsMeshAnimation_getMorphTransform_ccMN(self, node.getSelf()); }
		public BoundBoxd getBoundBox() { return tsMeshAnimation_getBoundBox_c(self); }
		public BoundBoxd getBoundBox(MeshNode node) { return tsMeshAnimation_getBoundBox_ccMN(self, node.getSelf()); }
		public BoundBoxd getBoundBox(MeshGeometry geometry) { return tsMeshAnimation_getBoundBox_ccMG(self, geometry.getSelf()); }
		public BoundBoxd getBoundBox(MeshGeometry geometry, in Vector4f morph) { return tsMeshAnimation_getBoundBox_ccMGcV4(self, geometry.getSelf(), in morph); }
		public void setTransform(in Vector3d scale) { tsMeshAnimation_setTransform_cV3(self, in scale); }
		public void setTransform(in Matrix4x3d transform) { tsMeshAnimation_setTransform_cM43(self, in transform); }
		public void optimizeTransforms(float threshold = 1e-6f) { tsMeshAnimation_optimizeTransforms(self, threshold); }
		public ulong getMemory() { return tsMeshAnimation_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshAnimation: Valid: " + tsMeshAnimation_isValidPtr(self) + "; Owner: " + tsMeshAnimation_isOwnerPtr(self) + "; Const: " + tsMeshAnimation_isConstPtr(self) + "; Count: " + tsMeshAnimation_getCountPtr(self) + "; Internal: 0x" + tsMeshAnimation_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshAnimation ptr) { return (ptr != null && tsMeshAnimation_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_new_Ms(HandleRef mesh, string name);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAnimation_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAnimation_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAnimation_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAnimation_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshAnimation_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshAnimation_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setMesh(HandleRef self, HandleRef mesh, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_getMesh_c(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsMeshAnimation_getMinTime(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsMeshAnimation_getMaxTime(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setNumTransforms(HandleRef self, uint num_transforms);
		[DllImport(Base.Import)] private static extern uint tsMeshAnimation_getNumTransforms(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAnimation_getTransform_cu(HandleRef self, uint node);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setTransform_f64ucM43f(HandleRef self, double time, uint node, in Matrix4x3d transform, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setTranslate(HandleRef self, double time, uint node, in Vector3d translate, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setRotate(HandleRef self, double time, uint node, in Quaternionf rotate, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setScale(HandleRef self, double time, uint node, in Vector3f scale, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setMorph(HandleRef self, double time, uint node, in Vector4f morph, float threshold);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setTime_f64cM43bf64f64(HandleRef self, double time, in Matrix4x3d transform, bool loop, double from, double to);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setTime_f64bf64f64(HandleRef self, double time, bool loop, double from, double to);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshAnimation_getLocalTransform_cu(HandleRef self, uint node);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshAnimation_getLocalTransform_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshAnimation_getLocalTransform_ccMJ(HandleRef self, HandleRef joint);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshAnimation_getGlobalTransform_cu(HandleRef self, uint node);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshAnimation_getGlobalTransform_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern Matrix4x3d tsMeshAnimation_getGlobalTransform_ccMJ(HandleRef self, HandleRef joint);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshAnimation_getMorphTransform_cu(HandleRef self, uint node);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshAnimation_getMorphTransform_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMeshAnimation_getBoundBox_c(HandleRef self);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMeshAnimation_getBoundBox_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMeshAnimation_getBoundBox_ccMG(HandleRef self, HandleRef geometry);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMeshAnimation_getBoundBox_ccMGcV4(HandleRef self, HandleRef geometry, in Vector4f morph);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setTransform_cV3(HandleRef self, in Vector3d scale);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_setTransform_cM43(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern void tsMeshAnimation_optimizeTransforms(HandleRef self, float threshold);
		[DllImport(Base.Import)] private static extern ulong tsMeshAnimation_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshAttachment
	public sealed class MeshAttachment {
		public enum Type : uint {
			Unknown = 0,
			LightGlobal,
			LightPoint,
			LightSpot,
			LightImage,
			CameraPerspective,
			CameraOrthographic,
			NumTypes,
		}
		public enum Flags : uint {
			None = 0,
			Bool = 1,
			Scalarf32 = 2,
			Vector4f = 4,
			Color = 8,
			Name = 16,
		}
		public MeshAttachment(string name = "") { self = new HandleRef(this, tsMeshAttachment_new_s(name)); owner = true; }
		public MeshAttachment(Type type, string name = "") { self = new HandleRef(this, tsMeshAttachment_new_MATs(type, name)); owner = true; }
		public MeshAttachment(MeshNode node, string name = "") { self = new HandleRef(this, tsMeshAttachment_new_MNs(node.getSelf(), name)); owner = true; }
		public MeshAttachment(MeshAttachment ptr) { self = new HandleRef(this, tsMeshAttachment_copyPtr(ptr.getSelf())); owner = true; }
		public MeshAttachment(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMeshAttachment_isOwnerPtr(self); }
		public static MeshAttachment Null() { return new MeshAttachment(IntPtr.Zero); }
		~MeshAttachment() { if(owner) tsMeshAttachment_delete(self); }
		public bool equalPtr(MeshAttachment ptr) { return tsMeshAttachment_equalPtr(self, ptr.getSelf()); }
		public MeshAttachment clonePtr() { return new MeshAttachment(tsMeshAttachment_clonePtr(self)); }
		public void clearPtr() { tsMeshAttachment_clearPtr(self); }
		public void destroyPtr() { tsMeshAttachment_destroyPtr(self); }
		public void acquirePtr() { tsMeshAttachment_acquirePtr(self); }
		public void unacquirePtr() { tsMeshAttachment_unacquirePtr(self); }
		public bool isValidPtr() { return tsMeshAttachment_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMeshAttachment_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMeshAttachment_isConstPtr(self); }
		public uint getCountPtr() { return tsMeshAttachment_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMeshAttachment_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshAttachment_clear(self); }
		public void setType(Type type) { tsMeshAttachment_setType(self, type); }
		public Type getType() { return tsMeshAttachment_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsMeshAttachment_getTypeName_MAT(type)); }
		public string getTypeName() { return Base.getCString(tsMeshAttachment_getTypeName_c(self)); }
		public bool isUnknown() { return tsMeshAttachment_isUnknown(self); }
		public bool isLight() { return tsMeshAttachment_isLight(self); }
		public bool isCamera() { return tsMeshAttachment_isCamera(self); }
		public void setName(string name) { tsMeshAttachment_setName(self, name); }
		public string getName() { return Base.getString(tsMeshAttachment_getName(self)); }
		public void setNode(MeshNode node, bool check = true) { tsMeshAttachment_setNode(self, node.getSelf(), check); }
		public MeshNode getNode() { return new MeshNode(tsMeshAttachment_getNode_c(self)); }
		public void setData(string data) { tsMeshAttachment_setData_s(self, data); }
		public void setData(String data) { tsMeshAttachment_setData_cS(self, data.getSelf()); }
		public string getData() { return Base.getString(tsMeshAttachment_getData(self)); }
		public void clearParameters() { tsMeshAttachment_clearParameters(self); }
		public bool removeParameter(string type) { return tsMeshAttachment_removeParameter(self, type); }
		public void copyParameters(MeshAttachment attachment) { tsMeshAttachment_copyParameters(self, attachment.getSelf()); }
		public uint findParameter(string type) { return tsMeshAttachment_findParameter(self, type); }
		public bool hasParameter(string type) { return tsMeshAttachment_hasParameter(self, type); }
		public uint getNumParameters() { return tsMeshAttachment_getNumParameters(self); }
		public string getParameterType(uint index) { return Base.getString(tsMeshAttachment_getParameterType(self, index)); }
		public void addParameter(string type, bool value) { tsMeshAttachment_addParameter_sb(self, type, value); }
		public void addParameter(string type, float value) { tsMeshAttachment_addParameter_sf(self, type, value); }
		public void addParameter(string type, in Vector4f vector) { tsMeshAttachment_addParameter_scV4(self, type, in vector); }
		public void addParameter(string type, in Color color) { tsMeshAttachment_addParameter_scC(self, type, in color); }
		public void addParameter(string type, string name) { tsMeshAttachment_addParameter_ss(self, type, name); }
		public void addParameter(string type, String name) { tsMeshAttachment_addParameter_scS(self, type, name.getSelf()); }
		public Flags getParameterFlags(uint index) { return tsMeshAttachment_getParameterFlags_cu(self, index); }
		public bool hasParameterFlag(uint index, Flags flags) { return tsMeshAttachment_hasParameterFlag_cuMAF(self, index, flags); }
		public bool hasParameterFlags(uint index, Flags flags) { return tsMeshAttachment_hasParameterFlags_cuMAF(self, index, flags); }
		public bool getParameterBool(uint index, bool value = false) { return tsMeshAttachment_getParameterBool_cub(self, index, value); }
		public float getParameterScalarf32(uint index, float value = 0.0f) { return tsMeshAttachment_getParameterScalarf32_cuf(self, index, value); }
		public Vector4f getParameterVector4f(uint index, in Vector4f vector) { return tsMeshAttachment_getParameterVector4f_cucV4(self, index, in vector); }
		public Color getParameterColor(uint index, in Color color) { return tsMeshAttachment_getParameterColor_cucC(self, index, in color); }
		public string getParameterName(uint index, String name = null) { return Base.getString(tsMeshAttachment_getParameterName_cucS(self, index, (name != null) ? name.getSelf() : Base.Null)); }
		public Flags getParameterFlags(string type) { return tsMeshAttachment_getParameterFlags_cs(self, type); }
		public bool hasParameterFlag(string type, Flags flags) { return tsMeshAttachment_hasParameterFlag_csMAF(self, type, flags); }
		public bool hasParameterFlags(string type, Flags flags) { return tsMeshAttachment_hasParameterFlags_csMAF(self, type, flags); }
		public bool getParameterBool(string type, bool value = false) { return tsMeshAttachment_getParameterBool_csb(self, type, value); }
		public float getParameterScalarf32(string type, float value = 0.0f) { return tsMeshAttachment_getParameterScalarf32_csf(self, type, value); }
		public Vector4f getParameterVector4f(string type, in Vector4f vector) { return tsMeshAttachment_getParameterVector4f_cscV4(self, type, in vector); }
		public Color getParameterColor(string type, in Color color) { return tsMeshAttachment_getParameterColor_cscC(self, type, in color); }
		public string getParameterName(string type, String name = null) { return Base.getString(tsMeshAttachment_getParameterName_cscS(self, type, (name != null) ? name.getSelf() : Base.Null)); }
		public void setTransform(in Vector3f scale) { tsMeshAttachment_setTransform_cV3(self, in scale); }
		public void setTransform(in Matrix4x3f transform) { tsMeshAttachment_setTransform_cM43(self, in transform); }
		public Matrix4x3f getTransform() { return tsMeshAttachment_getTransform(self); }
		public int compare(MeshAttachment attachment) { return tsMeshAttachment_compare(self, attachment.getSelf()); }
		public ulong getMemory() { return tsMeshAttachment_getMemory(self); }
		public override string ToString() { return "Tellusim.MeshAttachment: Valid: " + tsMeshAttachment_isValidPtr(self) + "; Owner: " + tsMeshAttachment_isOwnerPtr(self) + "; Const: " + tsMeshAttachment_isConstPtr(self) + "; Count: " + tsMeshAttachment_getCountPtr(self) + "; Internal: 0x" + tsMeshAttachment_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshAttachment ptr) { return (ptr != null && tsMeshAttachment_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_new_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_new_MATs(Type type, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_new_MNs(HandleRef node, string name);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshAttachment_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setType(HandleRef self, Type type);
		[DllImport(Base.Import)] private static extern Type tsMeshAttachment_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getTypeName_MAT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_isUnknown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_isLight(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_isCamera(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setNode(HandleRef self, HandleRef node, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getNode_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setData_s(HandleRef self, string data);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setData_cS(HandleRef self, HandleRef data);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getData(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_clearParameters(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_removeParameter(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_copyParameters(HandleRef self, HandleRef attachment);
		[DllImport(Base.Import)] private static extern uint tsMeshAttachment_findParameter(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_hasParameter(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern uint tsMeshAttachment_getNumParameters(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getParameterType(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_addParameter_sb(HandleRef self, string type, bool value);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_addParameter_sf(HandleRef self, string type, float value);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_addParameter_scV4(HandleRef self, string type, in Vector4f vector);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_addParameter_scC(HandleRef self, string type, in Color color);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_addParameter_ss(HandleRef self, string type, string name);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_addParameter_scS(HandleRef self, string type, HandleRef name);
		[DllImport(Base.Import)] private static extern Flags tsMeshAttachment_getParameterFlags_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_hasParameterFlag_cuMAF(HandleRef self, uint index, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_hasParameterFlags_cuMAF(HandleRef self, uint index, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_getParameterBool_cub(HandleRef self, uint index, bool value);
		[DllImport(Base.Import)] private static extern float tsMeshAttachment_getParameterScalarf32_cuf(HandleRef self, uint index, float value);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshAttachment_getParameterVector4f_cucV4(HandleRef self, uint index, in Vector4f vector);
		[DllImport(Base.Import)] private static extern Color tsMeshAttachment_getParameterColor_cucC(HandleRef self, uint index, in Color color);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getParameterName_cucS(HandleRef self, uint index, HandleRef name);
		[DllImport(Base.Import)] private static extern Flags tsMeshAttachment_getParameterFlags_cs(HandleRef self, string type);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_hasParameterFlag_csMAF(HandleRef self, string type, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_hasParameterFlags_csMAF(HandleRef self, string type, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshAttachment_getParameterBool_csb(HandleRef self, string type, bool value);
		[DllImport(Base.Import)] private static extern float tsMeshAttachment_getParameterScalarf32_csf(HandleRef self, string type, float value);
		[DllImport(Base.Import)] private static extern Vector4f tsMeshAttachment_getParameterVector4f_cscV4(HandleRef self, string type, in Vector4f vector);
		[DllImport(Base.Import)] private static extern Color tsMeshAttachment_getParameterColor_cscC(HandleRef self, string type, in Color color);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshAttachment_getParameterName_cscS(HandleRef self, string type, HandleRef name);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setTransform_cV3(HandleRef self, in Vector3f scale);
		[DllImport(Base.Import)] private static extern void tsMeshAttachment_setTransform_cM43(HandleRef self, in Matrix4x3f transform);
		[DllImport(Base.Import)] private static extern Matrix4x3f tsMeshAttachment_getTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsMeshAttachment_compare(HandleRef self, HandleRef attachment);
		[DllImport(Base.Import)] private static extern ulong tsMeshAttachment_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Mesh
	public sealed class Mesh {
		public enum Flags : uint {
			None = 0,
			Embed = 1,
			_32Bit = 2,
		}
		public enum Basis : uint {
			Unknown = 0,
			XUpRight,
			YUpRight,
			ZUpRight,
			XUpLeft,
			YUpLeft,
			ZUpLeft,
			ZUpMaya,
			NumBases,
		}
		public enum Axis : uint {
			Unknown = 0,
			PX,
			PY,
			PZ,
			NX,
			NY,
			NZ,
			NumAxes,
		}
		public Mesh() { self = new HandleRef(this, tsMesh_new()); owner = true; }
		public Mesh(Mesh ptr) { self = new HandleRef(this, tsMesh_copyPtr(ptr.getSelf())); owner = true; }
		public Mesh(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMesh_isOwnerPtr(self); }
		public static Mesh Null() { return new Mesh(IntPtr.Zero); }
		~Mesh() { if(owner) tsMesh_delete(self); }
		public bool equalPtr(Mesh ptr) { return tsMesh_equalPtr(self, ptr.getSelf()); }
		public Mesh clonePtr() { return new Mesh(tsMesh_clonePtr(self)); }
		public void clearPtr() { tsMesh_clearPtr(self); }
		public void destroyPtr() { tsMesh_destroyPtr(self); }
		public void acquirePtr() { tsMesh_acquirePtr(self); }
		public void unacquirePtr() { tsMesh_unacquirePtr(self); }
		public bool isValidPtr() { return tsMesh_isValidPtr(self); }
		public bool isOwnerPtr() { return tsMesh_isOwnerPtr(self); }
		public bool isConstPtr() { return tsMesh_isConstPtr(self); }
		public uint getCountPtr() { return tsMesh_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsMesh_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMesh_clear(self); }
		public bool isLoaded() { return tsMesh_isLoaded(self); }
		public bool info(string name, Flags flags = Flags.None, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_info_sMFA(self, name, flags, ref async_);
		}
		public bool info(String name, Flags flags = Flags.None, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_info_cSMFA(self, name.getSelf(), flags, ref async_);
		}
		public bool info(Stream stream, Flags flags = Flags.None, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_info_StMFA(self, stream.getSelf(), flags, ref async_);
		}
		public bool info(string name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_info_sA(self, name, ref async_);
		}
		public bool info(String name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_info_cSA(self, name.getSelf(), ref async_);
		}
		public bool info(Stream stream, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_info_StA(self, stream.getSelf(), ref async_);
		}
		public bool load(string name, Flags flags = Flags.None, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_load_sMFA(self, name, flags, ref async_);
		}
		public bool load(String name, Flags flags = Flags.None, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_load_cSMFA(self, name.getSelf(), flags, ref async_);
		}
		public bool load(Stream stream, Flags flags = Flags.None, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_load_StMFA(self, stream.getSelf(), flags, ref async_);
		}
		public bool load(string name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_load_sA(self, name, ref async_);
		}
		public bool load(String name, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_load_cSA(self, name.getSelf(), ref async_);
		}
		public bool load(Stream stream, in Async async) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_load_StA(self, stream.getSelf(), ref async_);
		}
		public bool save(string name, Flags flags = Flags.None) { return tsMesh_save_csMF(self, name, flags); }
		public bool save(String name, Flags flags = Flags.None) { return tsMesh_save_ccSMF(self, name.getSelf(), flags); }
		public bool save(Stream stream, Flags flags = Flags.None) { return tsMesh_save_cStMF(self, stream.getSelf(), flags); }
		public void setName(string name) { tsMesh_setName(self, name); }
		public string getName() { return Base.getString(tsMesh_getName(self)); }
		public bool setBasis(Axis front, Axis right, Axis up) { return tsMesh_setBasis_MAMAMA(self, front, right, up); }
		public bool setBasis(Basis basis) { return tsMesh_setBasis_MB(self, basis); }
		public Axis getFrontAxis() { return tsMesh_getFrontAxis(self); }
		public Axis getRightAxis() { return tsMesh_getRightAxis(self); }
		public Axis getUpAxis() { return tsMesh_getUpAxis(self); }
		public Basis getBasis() { return tsMesh_getBasis(self); }
		public string getFrontAxisName() { return Base.getCString(tsMesh_getFrontAxisName(self)); }
		public string getRightAxisName() { return Base.getCString(tsMesh_getRightAxisName(self)); }
		public string getUpAxisName() { return Base.getCString(tsMesh_getUpAxisName(self)); }
		public string getBasisName() { return Base.getString(tsMesh_getBasisName(self)); }
		public void clearNodes() { tsMesh_clearNodes(self); }
		public void reserveNodes(uint num_nodes) { tsMesh_reserveNodes(self, num_nodes); }
		public uint addNode(MeshNode node, bool check = true) { return tsMesh_addNode(self, node.getSelf(), check); }
		public bool removeNode(MeshNode node) { return tsMesh_removeNode(self, node.getSelf()); }
		public uint findNode(MeshNode node) { return tsMesh_findNode_ccMN(self, node.getSelf()); }
		public uint findNode(string name) { return tsMesh_findNode_cs(self, name); }
		public uint getNumNodes() { return tsMesh_getNumNodes(self); }
		public MeshNode getNode(uint index) { return new MeshNode(tsMesh_getNode_cu(self, index)); }
		public void createLocalTransforms(in Matrix4x3d itransform) { tsMesh_createLocalTransforms(self, in itransform); }
		public void createGlobalTransforms(in Matrix4x3d transform) { tsMesh_createGlobalTransforms(self, in transform); }
		public void clearGeometries() { tsMesh_clearGeometries(self); }
		public void reserveGeometries(uint num_geometries) { tsMesh_reserveGeometries(self, num_geometries); }
		public uint addGeometry(MeshGeometry geometry, bool check = true) { return tsMesh_addGeometry_MGb(self, geometry.getSelf(), check); }
		public uint addGeometry(MeshGeometry geometry, MeshNode node, bool check = true) { return tsMesh_addGeometry_MGMNb(self, geometry.getSelf(), node.getSelf(), check); }
		public bool removeGeometry(MeshGeometry geometry) { return tsMesh_removeGeometry(self, geometry.getSelf()); }
		public bool replaceGeometry(MeshGeometry old_geometry, MeshGeometry geometry) { return tsMesh_replaceGeometry(self, old_geometry.getSelf(), geometry.getSelf()); }
		public uint findGeometry(MeshGeometry geometry) { return tsMesh_findGeometry_ccMG(self, geometry.getSelf()); }
		public uint findGeometry(string name) { return tsMesh_findGeometry_cs(self, name); }
		public uint getNumGeometries() { return tsMesh_getNumGeometries(self); }
		public MeshGeometry getGeometry(uint index) { return new MeshGeometry(tsMesh_getGeometry_cu(self, index)); }
		public bool hasGeometryIndices(MeshIndices.Type type) { return tsMesh_hasGeometryIndices(self, type); }
		public bool hasGeometryAttribute(MeshAttribute.Type type) { return tsMesh_hasGeometryAttribute(self, type); }
		public ulong getNumGeometryPositions() { return tsMesh_getNumGeometryPositions(self); }
		public ulong getNumGeometryPrimitives() { return tsMesh_getNumGeometryPrimitives(self); }
		public void clearAnimations() { tsMesh_clearAnimations(self); }
		public void reserveAnimations(uint num_animations) { tsMesh_reserveAnimations(self, num_animations); }
		public uint addAnimation(MeshAnimation animation, bool check = true) { return tsMesh_addAnimation(self, animation.getSelf(), check); }
		public bool removeAnimation(MeshAnimation animation) { return tsMesh_removeAnimation(self, animation.getSelf()); }
		public bool replaceAnimation(MeshAnimation old_animation, MeshAnimation animation) { return tsMesh_replaceAnimation(self, old_animation.getSelf(), animation.getSelf()); }
		public uint findAnimation(MeshAnimation animation) { return tsMesh_findAnimation_ccMA(self, animation.getSelf()); }
		public uint findAnimation(string name) { return tsMesh_findAnimation_cs(self, name); }
		public uint getNumAnimations() { return tsMesh_getNumAnimations(self); }
		public MeshAnimation getAnimation(uint index) { return new MeshAnimation(tsMesh_getAnimation_cu(self, index)); }
		public BoundBoxd getBoundBox() { return tsMesh_getBoundBox_c(self); }
		public BoundBoxd getBoundBox(MeshNode node) { return tsMesh_getBoundBox_ccMN(self, node.getSelf()); }
		public BoundBoxd getBoundBox(MeshGeometry geometry) { return tsMesh_getBoundBox_ccMG(self, geometry.getSelf()); }
		public bool createBounds(bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createBounds_bA(self, force, ref async_);
		}
		public bool createBounds(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createBounds_A(self, ref async_);
		}
		public bool createBasis(bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createBasis_bA(self, force, ref async_);
		}
		public bool createBasis(float angle, bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createBasis_fbA(self, angle, force, ref async_);
		}
		public bool createBasis(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createBasis_A(self, ref async_);
		}
		public bool createBasis(float angle, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createBasis_fA(self, angle, ref async_);
		}
		public bool createNormals(bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createNormals_bA(self, force, ref async_);
		}
		public bool createNormals(float angle, bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createNormals_fbA(self, angle, force, ref async_);
		}
		public bool createNormals(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createNormals_A(self, ref async_);
		}
		public bool createNormals(float angle, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createNormals_fA(self, angle, ref async_);
		}
		public bool createTangents(bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createTangents_bA(self, force, ref async_);
		}
		public bool createTangents(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createTangents_A(self, ref async_);
		}
		public bool createIslands(uint max_attributes, uint max_primitives, bool force, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createIslands_uubA(self, max_attributes, max_primitives, force, ref async_);
		}
		public bool createIslands(uint max_attributes, uint max_primitives, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_createIslands_uuA(self, max_attributes, max_primitives, ref async_);
		}
		public bool optimizeIndices(uint cache, bool transparent, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_optimizeIndices_ubA(self, cache, transparent, ref async_);
		}
		public bool optimizeIndices(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_optimizeIndices_A(self, ref async_);
		}
		public bool optimizeIndices(uint cache, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_optimizeIndices_uA(self, cache, ref async_);
		}
		public bool optimizeAttributes(in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMesh_optimizeAttributes(self, ref async_);
		}
		public void optimizeMaterials() { tsMesh_optimizeMaterials(self); }
		public bool optimizeWinding(bool clockwise = false) { return tsMesh_optimizeWinding(self, clockwise); }
		public void optimizeGeometries(float threshold = 1e-3f, uint depth = 16) { tsMesh_optimizeGeometries(self, threshold, depth); }
		public void optimizeAnimations(float threshold = 1e-6f) { tsMesh_optimizeAnimations(self, threshold); }
		public bool optimizeOrder() { return tsMesh_optimizeOrder(self); }
		public void mergeGeometries() { tsMesh_mergeGeometries(self); }
		public bool packAttributes(bool remove = true) { return tsMesh_packAttributes(self, remove); }
		public bool unpackAttributes(bool remove = true) { return tsMesh_unpackAttributes(self, remove); }
		public bool setTransform(in Vector3d scale) { return tsMesh_setTransform(self, in scale); }
		public ulong getMemory() { return tsMesh_getMemory(self); }
		public override string ToString() { return "Tellusim.Mesh: Valid: " + tsMesh_isValidPtr(self) + "; Owner: " + tsMesh_isOwnerPtr(self) + "; Const: " + tsMesh_isConstPtr(self) + "; Count: " + tsMesh_getCountPtr(self) + "; Internal: 0x" + tsMesh_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Mesh ptr) { return (ptr != null && tsMesh_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_new();
		[DllImport(Base.Import)] private static extern void tsMesh_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMesh_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_isLoaded(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_info_sMFA(HandleRef self, string name, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_info_cSMFA(HandleRef self, HandleRef name, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_info_StMFA(HandleRef self, HandleRef stream, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_info_sA(HandleRef self, string name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_info_cSA(HandleRef self, HandleRef name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_info_StA(HandleRef self, HandleRef stream, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_load_sMFA(HandleRef self, string name, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_load_cSMFA(HandleRef self, HandleRef name, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_load_StMFA(HandleRef self, HandleRef stream, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_load_sA(HandleRef self, string name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_load_cSA(HandleRef self, HandleRef name, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_load_StA(HandleRef self, HandleRef stream, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_save_csMF(HandleRef self, string name, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMesh_save_ccSMF(HandleRef self, HandleRef name, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMesh_save_cStMF(HandleRef self, HandleRef stream, Flags flags);
		[DllImport(Base.Import)] private static extern void tsMesh_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_setBasis_MAMAMA(HandleRef self, Axis front, Axis right, Axis up);
		[DllImport(Base.Import)] private static extern bool tsMesh_setBasis_MB(HandleRef self, Basis basis);
		[DllImport(Base.Import)] private static extern Axis tsMesh_getFrontAxis(HandleRef self);
		[DllImport(Base.Import)] private static extern Axis tsMesh_getRightAxis(HandleRef self);
		[DllImport(Base.Import)] private static extern Axis tsMesh_getUpAxis(HandleRef self);
		[DllImport(Base.Import)] private static extern Basis tsMesh_getBasis(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getFrontAxisName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getRightAxisName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getUpAxisName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getBasisName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_clearNodes(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_reserveNodes(HandleRef self, uint num_nodes);
		[DllImport(Base.Import)] private static extern uint tsMesh_addNode(HandleRef self, HandleRef node, bool check);
		[DllImport(Base.Import)] private static extern bool tsMesh_removeNode(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern uint tsMesh_findNode_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern uint tsMesh_findNode_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMesh_getNumNodes(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getNode_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsMesh_createLocalTransforms(HandleRef self, in Matrix4x3d itransform);
		[DllImport(Base.Import)] private static extern void tsMesh_createGlobalTransforms(HandleRef self, in Matrix4x3d transform);
		[DllImport(Base.Import)] private static extern void tsMesh_clearGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_reserveGeometries(HandleRef self, uint num_geometries);
		[DllImport(Base.Import)] private static extern uint tsMesh_addGeometry_MGb(HandleRef self, HandleRef geometry, bool check);
		[DllImport(Base.Import)] private static extern uint tsMesh_addGeometry_MGMNb(HandleRef self, HandleRef geometry, HandleRef node, bool check);
		[DllImport(Base.Import)] private static extern bool tsMesh_removeGeometry(HandleRef self, HandleRef geometry);
		[DllImport(Base.Import)] private static extern bool tsMesh_replaceGeometry(HandleRef self, HandleRef old_geometry, HandleRef geometry);
		[DllImport(Base.Import)] private static extern uint tsMesh_findGeometry_ccMG(HandleRef self, HandleRef geometry);
		[DllImport(Base.Import)] private static extern uint tsMesh_findGeometry_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMesh_getNumGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getGeometry_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsMesh_hasGeometryIndices(HandleRef self, MeshIndices.Type type);
		[DllImport(Base.Import)] private static extern bool tsMesh_hasGeometryAttribute(HandleRef self, MeshAttribute.Type type);
		[DllImport(Base.Import)] private static extern ulong tsMesh_getNumGeometryPositions(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsMesh_getNumGeometryPrimitives(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_clearAnimations(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_reserveAnimations(HandleRef self, uint num_animations);
		[DllImport(Base.Import)] private static extern uint tsMesh_addAnimation(HandleRef self, HandleRef animation, bool check);
		[DllImport(Base.Import)] private static extern bool tsMesh_removeAnimation(HandleRef self, HandleRef animation);
		[DllImport(Base.Import)] private static extern bool tsMesh_replaceAnimation(HandleRef self, HandleRef old_animation, HandleRef animation);
		[DllImport(Base.Import)] private static extern uint tsMesh_findAnimation_ccMA(HandleRef self, HandleRef animation);
		[DllImport(Base.Import)] private static extern uint tsMesh_findAnimation_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsMesh_getNumAnimations(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMesh_getAnimation_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMesh_getBoundBox_c(HandleRef self);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMesh_getBoundBox_ccMN(HandleRef self, HandleRef node);
		[DllImport(Base.Import)] private static extern BoundBoxd tsMesh_getBoundBox_ccMG(HandleRef self, HandleRef geometry);
		[DllImport(Base.Import)] private static extern bool tsMesh_createBounds_bA(HandleRef self, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createBounds_A(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createBasis_bA(HandleRef self, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createBasis_fbA(HandleRef self, float angle, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createBasis_A(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createBasis_fA(HandleRef self, float angle, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createNormals_bA(HandleRef self, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createNormals_fbA(HandleRef self, float angle, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createNormals_A(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createNormals_fA(HandleRef self, float angle, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createTangents_bA(HandleRef self, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createTangents_A(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createIslands_uubA(HandleRef self, uint max_attributes, uint max_primitives, bool force, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_createIslands_uuA(HandleRef self, uint max_attributes, uint max_primitives, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_optimizeIndices_ubA(HandleRef self, uint cache, bool transparent, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_optimizeIndices_A(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_optimizeIndices_uA(HandleRef self, uint cache, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMesh_optimizeAttributes(HandleRef self, ref IntPtr async);
		[DllImport(Base.Import)] private static extern void tsMesh_optimizeMaterials(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_optimizeWinding(HandleRef self, bool clockwise);
		[DllImport(Base.Import)] private static extern void tsMesh_optimizeGeometries(HandleRef self, float threshold, uint depth);
		[DllImport(Base.Import)] private static extern void tsMesh_optimizeAnimations(HandleRef self, float threshold);
		[DllImport(Base.Import)] private static extern bool tsMesh_optimizeOrder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMesh_mergeGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMesh_packAttributes(HandleRef self, bool remove);
		[DllImport(Base.Import)] private static extern bool tsMesh_unpackAttributes(HandleRef self, bool remove);
		[DllImport(Base.Import)] private static extern bool tsMesh_setTransform(HandleRef self, in Vector3d scale);
		[DllImport(Base.Import)] private static extern ulong tsMesh_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Json
	public sealed class Json {
		public enum Type : uint {
			Unknown = 0,
			Null,
			Bool,
			Number,
			String,
			Object,
			Array,
			NumTypes,
		}
		public Json() { self = new HandleRef(this, tsJson_new()); owner = true; }
		public Json(Type type) { self = new HandleRef(this, tsJson_new_JT(type)); owner = true; }
		public Json(string name, Type type = Type.Unknown) { self = new HandleRef(this, tsJson_new_sJT(name, type)); owner = true; }
		public Json(String name, Type type = Type.Unknown) { self = new HandleRef(this, tsJson_new_cSJT(name.getSelf(), type)); owner = true; }
		public Json(in Json parent, string name, Type type = Type.Unknown) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsJson_new_JsJT(ref parent_, name, type)); owner = true;
		}
		public Json(in Json parent, String name, Type type = Type.Unknown) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsJson_new_JcSJT(ref parent_, name.getSelf(), type)); owner = true;
		}
		public Json(Json ptr) { self = new HandleRef(this, tsJson_copyPtr(ptr.getSelf())); owner = true; }
		public Json(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsJson_isOwnerPtr(self); }
		public static Json Null() { return new Json(IntPtr.Zero); }
		~Json() { if(owner) tsJson_delete(self); }
		public bool equalPtr(Json ptr) { return tsJson_equalPtr(self, ptr.getSelf()); }
		public Json clonePtr() { return new Json(tsJson_clonePtr(self)); }
		public void clearPtr() { tsJson_clearPtr(self); }
		public void destroyPtr() { tsJson_destroyPtr(self); }
		public void acquirePtr() { tsJson_acquirePtr(self); }
		public void unacquirePtr() { tsJson_unacquirePtr(self); }
		public bool isValidPtr() { return tsJson_isValidPtr(self); }
		public bool isOwnerPtr() { return tsJson_isOwnerPtr(self); }
		public bool isConstPtr() { return tsJson_isConstPtr(self); }
		public uint getCountPtr() { return tsJson_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsJson_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsJson_clear(self); }
		public bool create(string str, ulong size = 0, bool owner = false) { return tsJson_create_szb(self, str, size, owner); }
		public bool create(String str, ulong size = 0, bool owner = false) { return tsJson_create_cSzb(self, str.getSelf(), size, owner); }
		public bool load(string name) { return tsJson_load_s(self, name); }
		public bool load(String name) { return tsJson_load_cS(self, name.getSelf()); }
		public bool load(Stream stream) { return tsJson_load_St(self, stream.getSelf()); }
		public bool save(string name, bool compact = false) { return tsJson_save_csb(self, name, compact); }
		public bool save(String name, bool compact = false) { return tsJson_save_ccSb(self, name.getSelf(), compact); }
		public bool save(Stream stream, bool compact = false) { return tsJson_save_cStb(self, stream.getSelf(), compact); }
		public Json getRoot() { return new Json(tsJson_getRoot_c(self)); }
		public uint setParent(Json parent, bool check = true) { return tsJson_setParent(self, parent.getSelf(), check); }
		public Json getParent() { return new Json(tsJson_getParent_c(self)); }
		public Json addChild(string name, Type type = Type.Unknown, bool check = true) { return new Json(tsJson_addChild_sJTb(self, name, type, check)); }
		public uint addChild(Json child, bool check = true) { return tsJson_addChild_Jb(self, child.getSelf(), check); }
		public bool removeChild(Json child) { return tsJson_removeChild(self, child.getSelf()); }
		public void releaseChildren() { tsJson_releaseChildren(self); }
		public uint findChild(string name) { return tsJson_findChild(self, name); }
		public bool isChild(string name) { return tsJson_isChild(self, name); }
		public Json getChild(string name) { return new Json(tsJson_getChild_cs(self, name)); }
		public uint getNumChildren() { return tsJson_getNumChildren(self); }
		public Json getChild(uint index) { return new Json(tsJson_getChild_cu(self, index)); }
		public string getPathName() { return Base.getString(tsJson_getPathName(self)); }
		public void setName(string name) { tsJson_setName_s(self, name); }
		public void setName(String name) { tsJson_setName_cS(self, name.getSelf()); }
		public string getName() { return Base.getString(tsJson_getName(self)); }
		public void setType(Type type) { tsJson_setType(self, type); }
		public Type getType() { return tsJson_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsJson_getTypeName_JT(type)); }
		public string getTypeName() { return Base.getCString(tsJson_getTypeName_c(self)); }
		public bool isUnknown() { return tsJson_isUnknown(self); }
		public bool isNull() { return tsJson_isNull(self); }
		public bool isBool() { return tsJson_isBool(self); }
		public bool isNumber() { return tsJson_isNumber(self); }
		public bool isString() { return tsJson_isString(self); }
		public bool isObject() { return tsJson_isObject(self); }
		public bool isArray() { return tsJson_isArray(self); }
		public void setData(bool value) { tsJson_setData_b(self, value); }
		public void setData(int value, uint radix = 10) { tsJson_setData_iu(self, value, radix); }
		public void setData(uint value, uint radix = 10) { tsJson_setData_uu(self, value, radix); }
		public void setData(ulong value, uint radix = 10) { tsJson_setData_u64u(self, value, radix); }
		public void setData(float value, uint digits = 6, bool compact = true, bool exponent = true) { tsJson_setData_fubb(self, value, digits, compact, exponent); }
		public void setData(double value, uint digits = 12, bool compact = true, bool exponent = true) { tsJson_setData_f64ubb(self, value, digits, compact, exponent); }
		public void setData(string value) { tsJson_setData_s(self, value); }
		public void setData(String value) { tsJson_setData_cS(self, value.getSelf()); }
		public string getData() { return Base.getString(tsJson_getData_c(self)); }
		public bool getDataBool() { return tsJson_getDataBool(self); }
		public int getDatai32(uint radix = 10) { return tsJson_getDatai32(self, radix); }
		public uint getDatau32(uint radix = 10) { return tsJson_getDatau32(self, radix); }
		public ulong getDatau64(uint radix = 10) { return tsJson_getDatau64(self, radix); }
		public float getDataf32() { return tsJson_getDataf32(self); }
		public double getDataf64() { return tsJson_getDataf64(self); }
		public string getNumber() { return Base.getString(tsJson_getNumber(self)); }
		public string getString() { return Base.getString(tsJson_getString(self)); }
		public bool getData(string name, bool value) { return tsJson_getData_csb(self, name, value); }
		public int getData(string name, int value, uint radix = 10) { return tsJson_getData_csiu(self, name, value, radix); }
		public uint getData(string name, uint value, uint radix = 10) { return tsJson_getData_csuu(self, name, value, radix); }
		public ulong getData(string name, ulong value, uint radix = 10) { return tsJson_getData_csu64u(self, name, value, radix); }
		public float getData(string name, float value) { return tsJson_getData_csf(self, name, value); }
		public double getData(string name, double value) { return tsJson_getData_csf64(self, name, value); }
		public string getData(string name, String value = null) { return Base.getString(tsJson_getData_cscS(self, name, (value != null) ? value.getSelf() : Base.Null)); }
		public void setData(string[] values, uint size) { tsJson_setData_spu(self, values, size); }
		public void setData(in String values, uint size) {
			IntPtr values_ = (values != null) ? values.getSelfPtr() : IntPtr.Zero;
			tsJson_setData_cSu(self, ref values_, size);
		}
		public void setData(int[] values, uint size, uint radix = 10) { tsJson_setData_ipuu(self, values, size, radix); }
		public void setData(uint[] values, uint size, uint radix = 10) { tsJson_setData_upuu(self, values, size, radix); }
		public void setData(float[] values, uint size, uint digits = 6, bool compact = true, bool exponent = true) { tsJson_setData_fpuubb(self, values, size, digits, compact, exponent); }
		public void setData(double[] values, uint size, uint digits = 12, bool compact = true, bool exponent = true) { tsJson_setData_f64puubb(self, values, size, digits, compact, exponent); }
		public uint getData(in String values, uint size) {
			IntPtr values_ = (values != null) ? values.getSelfPtr() : IntPtr.Zero;
			return tsJson_getData_cSu(self, ref values_, size);
		}
		public uint getData(int[] values, uint size, uint radix = 10) { return tsJson_getData_ciruu(self, values, size, radix); }
		public uint getData(uint[] values, uint size, uint radix = 10) { return tsJson_getData_curuu(self, values, size, radix); }
		public uint getData(float[] values, uint size) { return tsJson_getData_cfru(self, values, size); }
		public uint getData(double[] values, uint size) { return tsJson_getData_cf64ru(self, values, size); }
		public override string ToString() { return "Tellusim.Json: Valid: " + tsJson_isValidPtr(self) + "; Owner: " + tsJson_isOwnerPtr(self) + "; Const: " + tsJson_isConstPtr(self) + "; Count: " + tsJson_getCountPtr(self) + "; Internal: 0x" + tsJson_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Json ptr) { return (ptr != null && tsJson_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsJson_new();
		[DllImport(Base.Import)] private static extern IntPtr tsJson_new_JT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_new_sJT(string name, Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_new_cSJT(HandleRef name, Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_new_JsJT(ref IntPtr parent, string name, Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_new_JcSJT(ref IntPtr parent, HandleRef name, Type type);
		[DllImport(Base.Import)] private static extern void tsJson_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsJson_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_create_szb(HandleRef self, string str, ulong size, bool owner);
		[DllImport(Base.Import)] private static extern bool tsJson_create_cSzb(HandleRef self, HandleRef str, ulong size, bool owner);
		[DllImport(Base.Import)] private static extern bool tsJson_load_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsJson_load_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsJson_load_St(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern bool tsJson_save_csb(HandleRef self, string name, bool compact);
		[DllImport(Base.Import)] private static extern bool tsJson_save_ccSb(HandleRef self, HandleRef name, bool compact);
		[DllImport(Base.Import)] private static extern bool tsJson_save_cStb(HandleRef self, HandleRef stream, bool compact);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getRoot_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsJson_setParent(HandleRef self, HandleRef parent, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getParent_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_addChild_sJTb(HandleRef self, string name, Type type, bool check);
		[DllImport(Base.Import)] private static extern uint tsJson_addChild_Jb(HandleRef self, HandleRef child, bool check);
		[DllImport(Base.Import)] private static extern bool tsJson_removeChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern void tsJson_releaseChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsJson_findChild(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsJson_isChild(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getChild_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsJson_getNumChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getChild_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getPathName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_setName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsJson_setName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_setType(HandleRef self, Type type);
		[DllImport(Base.Import)] private static extern Type tsJson_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getTypeName_JT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isUnknown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isNull(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isBool(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isNumber(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isString(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isObject(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_isArray(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsJson_setData_b(HandleRef self, bool value);
		[DllImport(Base.Import)] private static extern void tsJson_setData_iu(HandleRef self, int value, uint radix);
		[DllImport(Base.Import)] private static extern void tsJson_setData_uu(HandleRef self, uint value, uint radix);
		[DllImport(Base.Import)] private static extern void tsJson_setData_u64u(HandleRef self, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern void tsJson_setData_fubb(HandleRef self, float value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern void tsJson_setData_f64ubb(HandleRef self, double value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern void tsJson_setData_s(HandleRef self, string value);
		[DllImport(Base.Import)] private static extern void tsJson_setData_cS(HandleRef self, HandleRef value);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getData_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_getDataBool(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsJson_getDatai32(HandleRef self, uint radix);
		[DllImport(Base.Import)] private static extern uint tsJson_getDatau32(HandleRef self, uint radix);
		[DllImport(Base.Import)] private static extern ulong tsJson_getDatau64(HandleRef self, uint radix);
		[DllImport(Base.Import)] private static extern float tsJson_getDataf32(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsJson_getDataf64(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getNumber(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getString(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsJson_getData_csb(HandleRef self, string name, bool value);
		[DllImport(Base.Import)] private static extern int tsJson_getData_csiu(HandleRef self, string name, int value, uint radix);
		[DllImport(Base.Import)] private static extern uint tsJson_getData_csuu(HandleRef self, string name, uint value, uint radix);
		[DllImport(Base.Import)] private static extern ulong tsJson_getData_csu64u(HandleRef self, string name, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern float tsJson_getData_csf(HandleRef self, string name, float value);
		[DllImport(Base.Import)] private static extern double tsJson_getData_csf64(HandleRef self, string name, double value);
		[DllImport(Base.Import)] private static extern IntPtr tsJson_getData_cscS(HandleRef self, string name, HandleRef value);
		[DllImport(Base.Import)] private static extern void tsJson_setData_spu(HandleRef self, string[] values, uint size);
		[DllImport(Base.Import)] private static extern void tsJson_setData_cSu(HandleRef self, ref IntPtr values, uint size);
		[DllImport(Base.Import)] private static extern void tsJson_setData_ipuu(HandleRef self, int[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern void tsJson_setData_upuu(HandleRef self, uint[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern void tsJson_setData_fpuubb(HandleRef self, float[] values, uint size, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern void tsJson_setData_f64puubb(HandleRef self, double[] values, uint size, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern uint tsJson_getData_cSu(HandleRef self, ref IntPtr values, uint size);
		[DllImport(Base.Import)] private static extern uint tsJson_getData_ciruu(HandleRef self, int[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern uint tsJson_getData_curuu(HandleRef self, uint[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern uint tsJson_getData_cfru(HandleRef self, float[] values, uint size);
		[DllImport(Base.Import)] private static extern uint tsJson_getData_cf64ru(HandleRef self, double[] values, uint size);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Xml
	public sealed class Xml {
		public Xml() { self = new HandleRef(this, tsXml_new()); owner = true; }
		public Xml(string name, string attributes = "") { self = new HandleRef(this, tsXml_new_ss(name, attributes)); owner = true; }
		public Xml(String name, string attributes = "") { self = new HandleRef(this, tsXml_new_cSs(name.getSelf(), attributes)); owner = true; }
		public Xml(in Xml parent, string name, string attributes = "") {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsXml_new_Xss(ref parent_, name, attributes)); owner = true;
		}
		public Xml(in Xml parent, String name, string attributes = "") {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsXml_new_XcSs(ref parent_, name.getSelf(), attributes)); owner = true;
		}
		public Xml(Xml ptr) { self = new HandleRef(this, tsXml_copyPtr(ptr.getSelf())); owner = true; }
		public Xml(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsXml_isOwnerPtr(self); }
		public static Xml Null() { return new Xml(IntPtr.Zero); }
		~Xml() { if(owner) tsXml_delete(self); }
		public bool equalPtr(Xml ptr) { return tsXml_equalPtr(self, ptr.getSelf()); }
		public Xml clonePtr() { return new Xml(tsXml_clonePtr(self)); }
		public void clearPtr() { tsXml_clearPtr(self); }
		public void destroyPtr() { tsXml_destroyPtr(self); }
		public void acquirePtr() { tsXml_acquirePtr(self); }
		public void unacquirePtr() { tsXml_unacquirePtr(self); }
		public bool isValidPtr() { return tsXml_isValidPtr(self); }
		public bool isOwnerPtr() { return tsXml_isOwnerPtr(self); }
		public bool isConstPtr() { return tsXml_isConstPtr(self); }
		public uint getCountPtr() { return tsXml_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsXml_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsXml_clear(self); }
		public bool create(string str, ulong size = 0, bool owner = false) { return tsXml_create_szb(self, str, size, owner); }
		public bool create(String str, ulong size = 0, bool owner = false) { return tsXml_create_cSzb(self, str.getSelf(), size, owner); }
		public bool load(string name) { return tsXml_load_s(self, name); }
		public bool load(String name) { return tsXml_load_cS(self, name.getSelf()); }
		public bool load(Stream stream) { return tsXml_load_St(self, stream.getSelf()); }
		public bool save(string name, bool compact = false) { return tsXml_save_csb(self, name, compact); }
		public bool save(String name, bool compact = false) { return tsXml_save_ccSb(self, name.getSelf(), compact); }
		public bool save(Stream stream, bool compact = false) { return tsXml_save_cStb(self, stream.getSelf(), compact); }
		public Xml getRoot() { return new Xml(tsXml_getRoot_c(self)); }
		public uint setParent(Xml parent, bool check = true) { return tsXml_setParent(self, parent.getSelf(), check); }
		public Xml getParent() { return new Xml(tsXml_getParent_c(self)); }
		public Xml addChild(string name, bool check = true) { return new Xml(tsXml_addChild_sb(self, name, check)); }
		public uint addChild(Xml child, bool check = true) { return tsXml_addChild_Xb(self, child.getSelf(), check); }
		public bool removeChild(Xml child) { return tsXml_removeChild(self, child.getSelf()); }
		public void releaseChildren() { tsXml_releaseChildren(self); }
		public uint findChild(string name) { return tsXml_findChild(self, name); }
		public bool isChild(string name) { return tsXml_isChild(self, name); }
		public Xml getChild(string name) { return new Xml(tsXml_getChild_cs(self, name)); }
		public uint getNumChildren() { return tsXml_getNumChildren(self); }
		public Xml getChild(uint index) { return new Xml(tsXml_getChild_cu(self, index)); }
		public string getPathName() { return Base.getString(tsXml_getPathName(self)); }
		public void setName(string name) { tsXml_setName_s(self, name); }
		public void setName(String name) { tsXml_setName_cS(self, name.getSelf()); }
		public string getName() { return Base.getString(tsXml_getName(self)); }
		public void setData(bool value) { tsXml_setData_b(self, value); }
		public void setData(string value) { tsXml_setData_s(self, value); }
		public void setData(String value) { tsXml_setData_cS(self, value.getSelf()); }
		public void setData(int value, uint radix = 10) { tsXml_setData_iu(self, value, radix); }
		public void setData(uint value, uint radix = 10) { tsXml_setData_uu(self, value, radix); }
		public void setData(ulong value, uint radix = 10) { tsXml_setData_u64u(self, value, radix); }
		public void setData(float value, uint digits = 6, bool compact = true, bool exponent = true) { tsXml_setData_fubb(self, value, digits, compact, exponent); }
		public void setData(double value, uint digits = 12, bool compact = true, bool exponent = true) { tsXml_setData_f64ubb(self, value, digits, compact, exponent); }
		public string getData() { return Base.getString(tsXml_getData_c(self)); }
		public bool getDataBool() { return tsXml_getDataBool(self); }
		public int getDatai32(uint radix = 10) { return tsXml_getDatai32(self, radix); }
		public uint getDatau32(uint radix = 10) { return tsXml_getDatau32(self, radix); }
		public ulong getDatau64(uint radix = 10) { return tsXml_getDatau64(self, radix); }
		public float getDataf32() { return tsXml_getDataf32(self); }
		public double getDataf64() { return tsXml_getDataf64(self); }
		public string getData(string name, String value = null) { return Base.getString(tsXml_getData_cscS(self, name, (value != null) ? value.getSelf() : Base.Null)); }
		public bool getData(string name, bool value) { return tsXml_getData_csb(self, name, value); }
		public int getData(string name, int value, uint radix = 10) { return tsXml_getData_csiu(self, name, value, radix); }
		public uint getData(string name, uint value, uint radix = 10) { return tsXml_getData_csuu(self, name, value, radix); }
		public ulong getData(string name, ulong value, uint radix = 10) { return tsXml_getData_csu64u(self, name, value, radix); }
		public float getData(string name, float value) { return tsXml_getData_csf(self, name, value); }
		public double getData(string name, double value) { return tsXml_getData_csf64(self, name, value); }
		public void setData(string[] values, uint size, uint wrap = Base.Maxu32) { tsXml_setData_spuu(self, values, size, wrap); }
		public void setData(in String values, uint size, uint wrap = Base.Maxu32) {
			IntPtr values_ = (values != null) ? values.getSelfPtr() : IntPtr.Zero;
			tsXml_setData_cSuu(self, ref values_, size, wrap);
		}
		public void setData(int[] values, uint size, uint radix = 10, uint wrap = Base.Maxu32) { tsXml_setData_ipuuu(self, values, size, radix, wrap); }
		public void setData(uint[] values, uint size, uint radix = 10, uint wrap = Base.Maxu32) { tsXml_setData_upuuu(self, values, size, radix, wrap); }
		public void setData(float[] values, uint size, uint digits = 6, bool compact = true, bool exponent = true, uint wrap = Base.Maxu32) { tsXml_setData_fpuubbu(self, values, size, digits, compact, exponent, wrap); }
		public void setData(double[] values, uint size, uint digits = 12, bool compact = true, bool exponent = true, uint wrap = Base.Maxu32) { tsXml_setData_f64puubbu(self, values, size, digits, compact, exponent, wrap); }
		public uint getData(in String values, uint size) {
			IntPtr values_ = (values != null) ? values.getSelfPtr() : IntPtr.Zero;
			return tsXml_getData_cSu(self, ref values_, size);
		}
		public uint getData(int[] values, uint size, uint radix = 10) { return tsXml_getData_ciruu(self, values, size, radix); }
		public uint getData(uint[] values, uint size, uint radix = 10) { return tsXml_getData_curuu(self, values, size, radix); }
		public uint getData(float[] values, uint size) { return tsXml_getData_cfru(self, values, size); }
		public uint getData(double[] values, uint size) { return tsXml_getData_cf64ru(self, values, size); }
		public uint addAttribute(string name) { return tsXml_addAttribute(self, name); }
		public bool removeAttribute(string name) { return tsXml_removeAttribute(self, name); }
		public uint findAttribute(string name) { return tsXml_findAttribute(self, name); }
		public bool isAttribute(string name) { return tsXml_isAttribute(self, name); }
		public void removeAttributes() { tsXml_removeAttributes(self); }
		public uint getNumAttributes() { return tsXml_getNumAttributes(self); }
		public string getAttributeName(uint index) { return Base.getString(tsXml_getAttributeName(self, index)); }
		public bool setAttributes(string str) { return tsXml_setAttributes(self, str); }
		public void setAttribute(uint index, bool value) { tsXml_setAttribute_ub(self, index, value); }
		public void setAttribute(uint index, string value) { tsXml_setAttribute_us(self, index, value); }
		public void setAttribute(uint index, String value) { tsXml_setAttribute_ucS(self, index, value.getSelf()); }
		public void setAttribute(uint index, int value, uint radix = 10) { tsXml_setAttribute_uiu(self, index, value, radix); }
		public void setAttribute(uint index, uint value, uint radix = 10) { tsXml_setAttribute_uuu(self, index, value, radix); }
		public void setAttribute(uint index, ulong value, uint radix = 10) { tsXml_setAttribute_uu64u(self, index, value, radix); }
		public void setAttribute(uint index, float value, uint digits = 6, bool compact = true, bool exponent = true) { tsXml_setAttribute_ufubb(self, index, value, digits, compact, exponent); }
		public void setAttribute(uint index, double value, uint digits = 12, bool compact = true, bool exponent = true) { tsXml_setAttribute_uf64ubb(self, index, value, digits, compact, exponent); }
		public string getAttribute(uint index) { return Base.getString(tsXml_getAttribute_cu(self, index)); }
		public int getAttributei32(uint index, uint radix = 10) { return tsXml_getAttributei32(self, index, radix); }
		public uint getAttributeu32(uint index, uint radix = 10) { return tsXml_getAttributeu32(self, index, radix); }
		public ulong getAttributeu64(uint index, uint radix = 10) { return tsXml_getAttributeu64(self, index, radix); }
		public float getAttributef32(uint index) { return tsXml_getAttributef32(self, index); }
		public double getAttributef64(uint index) { return tsXml_getAttributef64(self, index); }
		public string getAttribute(string name, String value = null) { return Base.getString(tsXml_getAttribute_cscS(self, name, (value != null) ? value.getSelf() : Base.Null)); }
		public bool getAttribute(string name, bool value) { return tsXml_getAttribute_csb(self, name, value); }
		public int getAttribute(string name, int value, uint radix = 10) { return tsXml_getAttribute_csiu(self, name, value, radix); }
		public uint getAttribute(string name, uint value, uint radix = 10) { return tsXml_getAttribute_csuu(self, name, value, radix); }
		public ulong getAttribute(string name, ulong value, uint radix = 10) { return tsXml_getAttribute_csu64u(self, name, value, radix); }
		public float getAttribute(string name, float value) { return tsXml_getAttribute_csf(self, name, value); }
		public double getAttribute(string name, double value) { return tsXml_getAttribute_csf64(self, name, value); }
		public void setAttribute(uint index, string[] values, uint size, string delimiter = "") { tsXml_setAttribute_uspus(self, index, values, size, delimiter); }
		public void setAttribute(uint index, in String values, uint size, string delimiter = "") {
			IntPtr values_ = (values != null) ? values.getSelfPtr() : IntPtr.Zero;
			tsXml_setAttribute_ucSus(self, index, ref values_, size, delimiter);
		}
		public void setAttribute(uint index, int[] values, uint size, uint radix = 10) { tsXml_setAttribute_uipuu(self, index, values, size, radix); }
		public void setAttribute(uint index, uint[] values, uint size, uint radix = 10) { tsXml_setAttribute_uupuu(self, index, values, size, radix); }
		public void setAttribute(uint index, float[] values, uint size, uint digits = 6, bool compact = true, bool exponent = true) { tsXml_setAttribute_ufpuubb(self, index, values, size, digits, compact, exponent); }
		public void setAttribute(uint index, double[] values, uint size, uint digits = 12, bool compact = true, bool exponent = true) { tsXml_setAttribute_uf64puubb(self, index, values, size, digits, compact, exponent); }
		public uint getAttribute(uint index, in String values, uint size, string delimiter = "") {
			IntPtr values_ = (values != null) ? values.getSelfPtr() : IntPtr.Zero;
			return tsXml_getAttribute_cuSus(self, index, ref values_, size, delimiter);
		}
		public uint getAttribute(uint index, int[] values, uint size, uint radix = 10) { return tsXml_getAttribute_cuiruu(self, index, values, size, radix); }
		public uint getAttribute(uint index, uint[] values, uint size, uint radix = 10) { return tsXml_getAttribute_cuuruu(self, index, values, size, radix); }
		public uint getAttribute(uint index, float[] values, uint size) { return tsXml_getAttribute_cufru(self, index, values, size); }
		public uint getAttribute(uint index, double[] values, uint size) { return tsXml_getAttribute_cuf64ru(self, index, values, size); }
		public override string ToString() { return "Tellusim.Xml: Valid: " + tsXml_isValidPtr(self) + "; Owner: " + tsXml_isOwnerPtr(self) + "; Const: " + tsXml_isConstPtr(self) + "; Count: " + tsXml_getCountPtr(self) + "; Internal: 0x" + tsXml_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Xml ptr) { return (ptr != null && tsXml_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsXml_new();
		[DllImport(Base.Import)] private static extern IntPtr tsXml_new_ss(string name, string attributes);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_new_cSs(HandleRef name, string attributes);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_new_Xss(ref IntPtr parent, string name, string attributes);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_new_XcSs(ref IntPtr parent, HandleRef name, string attributes);
		[DllImport(Base.Import)] private static extern void tsXml_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsXml_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsXml_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsXml_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsXml_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsXml_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsXml_create_szb(HandleRef self, string str, ulong size, bool owner);
		[DllImport(Base.Import)] private static extern bool tsXml_create_cSzb(HandleRef self, HandleRef str, ulong size, bool owner);
		[DllImport(Base.Import)] private static extern bool tsXml_load_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsXml_load_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsXml_load_St(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern bool tsXml_save_csb(HandleRef self, string name, bool compact);
		[DllImport(Base.Import)] private static extern bool tsXml_save_ccSb(HandleRef self, HandleRef name, bool compact);
		[DllImport(Base.Import)] private static extern bool tsXml_save_cStb(HandleRef self, HandleRef stream, bool compact);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getRoot_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsXml_setParent(HandleRef self, HandleRef parent, bool check);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getParent_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_addChild_sb(HandleRef self, string name, bool check);
		[DllImport(Base.Import)] private static extern uint tsXml_addChild_Xb(HandleRef self, HandleRef child, bool check);
		[DllImport(Base.Import)] private static extern bool tsXml_removeChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern void tsXml_releaseChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsXml_findChild(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsXml_isChild(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getChild_cs(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsXml_getNumChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getChild_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getPathName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_setName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsXml_setName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsXml_setData_b(HandleRef self, bool value);
		[DllImport(Base.Import)] private static extern void tsXml_setData_s(HandleRef self, string value);
		[DllImport(Base.Import)] private static extern void tsXml_setData_cS(HandleRef self, HandleRef value);
		[DllImport(Base.Import)] private static extern void tsXml_setData_iu(HandleRef self, int value, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setData_uu(HandleRef self, uint value, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setData_u64u(HandleRef self, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setData_fubb(HandleRef self, float value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern void tsXml_setData_f64ubb(HandleRef self, double value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getData_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsXml_getDataBool(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsXml_getDatai32(HandleRef self, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getDatau32(HandleRef self, uint radix);
		[DllImport(Base.Import)] private static extern ulong tsXml_getDatau64(HandleRef self, uint radix);
		[DllImport(Base.Import)] private static extern float tsXml_getDataf32(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsXml_getDataf64(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getData_cscS(HandleRef self, string name, HandleRef value);
		[DllImport(Base.Import)] private static extern bool tsXml_getData_csb(HandleRef self, string name, bool value);
		[DllImport(Base.Import)] private static extern int tsXml_getData_csiu(HandleRef self, string name, int value, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getData_csuu(HandleRef self, string name, uint value, uint radix);
		[DllImport(Base.Import)] private static extern ulong tsXml_getData_csu64u(HandleRef self, string name, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern float tsXml_getData_csf(HandleRef self, string name, float value);
		[DllImport(Base.Import)] private static extern double tsXml_getData_csf64(HandleRef self, string name, double value);
		[DllImport(Base.Import)] private static extern void tsXml_setData_spuu(HandleRef self, string[] values, uint size, uint wrap);
		[DllImport(Base.Import)] private static extern void tsXml_setData_cSuu(HandleRef self, ref IntPtr values, uint size, uint wrap);
		[DllImport(Base.Import)] private static extern void tsXml_setData_ipuuu(HandleRef self, int[] values, uint size, uint radix, uint wrap);
		[DllImport(Base.Import)] private static extern void tsXml_setData_upuuu(HandleRef self, uint[] values, uint size, uint radix, uint wrap);
		[DllImport(Base.Import)] private static extern void tsXml_setData_fpuubbu(HandleRef self, float[] values, uint size, uint digits, bool compact, bool exponent, uint wrap);
		[DllImport(Base.Import)] private static extern void tsXml_setData_f64puubbu(HandleRef self, double[] values, uint size, uint digits, bool compact, bool exponent, uint wrap);
		[DllImport(Base.Import)] private static extern uint tsXml_getData_cSu(HandleRef self, ref IntPtr values, uint size);
		[DllImport(Base.Import)] private static extern uint tsXml_getData_ciruu(HandleRef self, int[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getData_curuu(HandleRef self, uint[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getData_cfru(HandleRef self, float[] values, uint size);
		[DllImport(Base.Import)] private static extern uint tsXml_getData_cf64ru(HandleRef self, double[] values, uint size);
		[DllImport(Base.Import)] private static extern uint tsXml_addAttribute(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsXml_removeAttribute(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern uint tsXml_findAttribute(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsXml_isAttribute(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsXml_removeAttributes(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsXml_getNumAttributes(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getAttributeName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsXml_setAttributes(HandleRef self, string str);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_ub(HandleRef self, uint index, bool value);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_us(HandleRef self, uint index, string value);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_ucS(HandleRef self, uint index, HandleRef value);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uiu(HandleRef self, uint index, int value, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uuu(HandleRef self, uint index, uint value, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uu64u(HandleRef self, uint index, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_ufubb(HandleRef self, uint index, float value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uf64ubb(HandleRef self, uint index, double value, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getAttribute_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern int tsXml_getAttributei32(HandleRef self, uint index, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttributeu32(HandleRef self, uint index, uint radix);
		[DllImport(Base.Import)] private static extern ulong tsXml_getAttributeu64(HandleRef self, uint index, uint radix);
		[DllImport(Base.Import)] private static extern float tsXml_getAttributef32(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern double tsXml_getAttributef64(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsXml_getAttribute_cscS(HandleRef self, string name, HandleRef value);
		[DllImport(Base.Import)] private static extern bool tsXml_getAttribute_csb(HandleRef self, string name, bool value);
		[DllImport(Base.Import)] private static extern int tsXml_getAttribute_csiu(HandleRef self, string name, int value, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttribute_csuu(HandleRef self, string name, uint value, uint radix);
		[DllImport(Base.Import)] private static extern ulong tsXml_getAttribute_csu64u(HandleRef self, string name, ulong value, uint radix);
		[DllImport(Base.Import)] private static extern float tsXml_getAttribute_csf(HandleRef self, string name, float value);
		[DllImport(Base.Import)] private static extern double tsXml_getAttribute_csf64(HandleRef self, string name, double value);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uspus(HandleRef self, uint index, string[] values, uint size, string delimiter);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_ucSus(HandleRef self, uint index, ref IntPtr values, uint size, string delimiter);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uipuu(HandleRef self, uint index, int[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uupuu(HandleRef self, uint index, uint[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_ufpuubb(HandleRef self, uint index, float[] values, uint size, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern void tsXml_setAttribute_uf64puubb(HandleRef self, uint index, double[] values, uint size, uint digits, bool compact, bool exponent);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttribute_cuSus(HandleRef self, uint index, ref IntPtr values, uint size, string delimiter);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttribute_cuiruu(HandleRef self, uint index, int[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttribute_cuuruu(HandleRef self, uint index, uint[] values, uint size, uint radix);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttribute_cufru(HandleRef self, uint index, float[] values, uint size);
		[DllImport(Base.Import)] private static extern uint tsXml_getAttribute_cuf64ru(HandleRef self, uint index, double[] values, uint size);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Buffer
	public class Buffer {
		public enum Flags : uint {
			None = 0,
			Read = 1,
			Write = 2,
			Source = 4,
			Sparse = 8,
			Shared = 16,
			Mapped = 32,
			Extern = 64,
			Interop = 128,
			Dynamic = 256,
			Uniform = 512,
			Storage = 1024,
			Address = 2048,
			Tracing = 4096,
			Scratch = 8192,
			Binding = 16384,
			Indirect = 32768,
			Conditional = 65536,
			Vertex = 131072,
			Index = 262144,
			Texel = 524288,
			Accel = 1048576,
			Default = 0,
			Num = 21,
		}
		public Buffer() { self = new HandleRef(this, tsBuffer_new()); owner = true; }
		public Buffer(Buffer ptr) { self = new HandleRef(this, tsBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public Buffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsBuffer_isOwnerPtr(self); }
		public static Buffer Null() { return new Buffer(IntPtr.Zero); }
		~Buffer() { if(owner) tsBuffer_delete(self); }
		public bool equalPtr(Buffer ptr) { return tsBuffer_equalPtr(self, ptr.getSelf()); }
		public Buffer clonePtr() { return new Buffer(tsBuffer_clonePtr(self)); }
		public void clearPtr() { tsBuffer_clearPtr(self); }
		public void destroyPtr() { tsBuffer_destroyPtr(self); }
		public void acquirePtr() { tsBuffer_acquirePtr(self); }
		public void unacquirePtr() { tsBuffer_unacquirePtr(self); }
		public bool isValidPtr() { return tsBuffer_isValidPtr(self); }
		public bool isOwnerPtr() { return tsBuffer_isOwnerPtr(self); }
		public bool isConstPtr() { return tsBuffer_isConstPtr(self); }
		public uint getCountPtr() { return tsBuffer_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsBuffer_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsBuffer_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsBuffer_getPlatformName(self)); }
		public uint getIndex() { return tsBuffer_getIndex(self); }
		public void clear() { tsBuffer_clear(self); }
		public bool isCreated() { return tsBuffer_isCreated(self); }
		public void setName(string name) { tsBuffer_setName(self, name); }
		public string getName() { return Base.getString(tsBuffer_getName(self)); }
		public bool create(Flags flags, ulong size, Format format = Format.Unknown) { return tsBuffer_create(self, flags, size, format); }
		public bool isMapped() { return tsBuffer_isMapped(self); }
		public Flags getFlags() { return tsBuffer_getFlags(self); }
		public bool hasFlag(Flags flags) { return tsBuffer_hasFlag(self, flags); }
		public bool hasFlags(Flags flags) { return tsBuffer_hasFlags(self, flags); }
		public string getFlagsName() { return Base.getString(tsBuffer_getFlagsName(self)); }
		public Format getFormat() { return tsBuffer_getFormat(self); }
		public string getFormatName() { return Base.getCString(tsBuffer_getFormatName(self)); }
		public uint getComponents() { return tsBuffer_getComponents(self); }
		public uint getPixelSize() { return tsBuffer_getPixelSize(self); }
		public ulong getSize() { return tsBuffer_getSize(self); }
		public ulong getPageSize() { return tsBuffer_getPageSize(self); }
		public string getDescription() { return Base.getString(tsBuffer_getDescription(self)); }
		public override string ToString() { return "Tellusim.Buffer: Valid: " + tsBuffer_isValidPtr(self) + "; Owner: " + tsBuffer_isOwnerPtr(self) + "; Const: " + tsBuffer_isConstPtr(self) + "; Count: " + tsBuffer_getCountPtr(self) + "; Internal: 0x" + tsBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Buffer ptr) { return (ptr != null && tsBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_new();
		[DllImport(Base.Import)] private static extern void tsBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsBuffer_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBuffer_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBuffer_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBuffer_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_create(HandleRef self, Flags flags, ulong size, Format format);
		[DllImport(Base.Import)] private static extern bool tsBuffer_isMapped(HandleRef self);
		[DllImport(Base.Import)] private static extern Flags tsBuffer_getFlags(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBuffer_hasFlag(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsBuffer_hasFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_getFlagsName(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsBuffer_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_getFormatName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBuffer_getComponents(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBuffer_getPixelSize(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsBuffer_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsBuffer_getPageSize(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBuffer_getDescription(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::BufferTable
	public sealed class BufferTable {
		public BufferTable() { self = new HandleRef(this, tsBufferTable_new()); owner = true; }
		public BufferTable(BufferTable ptr) { self = new HandleRef(this, tsBufferTable_copyPtr(ptr.getSelf())); owner = true; }
		public BufferTable(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsBufferTable_isOwnerPtr(self); }
		public static BufferTable Null() { return new BufferTable(IntPtr.Zero); }
		~BufferTable() { if(owner) tsBufferTable_delete(self); }
		public bool equalPtr(BufferTable ptr) { return tsBufferTable_equalPtr(self, ptr.getSelf()); }
		public BufferTable clonePtr() { return new BufferTable(tsBufferTable_clonePtr(self)); }
		public void clearPtr() { tsBufferTable_clearPtr(self); }
		public void destroyPtr() { tsBufferTable_destroyPtr(self); }
		public void acquirePtr() { tsBufferTable_acquirePtr(self); }
		public void unacquirePtr() { tsBufferTable_unacquirePtr(self); }
		public bool isValidPtr() { return tsBufferTable_isValidPtr(self); }
		public bool isOwnerPtr() { return tsBufferTable_isOwnerPtr(self); }
		public bool isConstPtr() { return tsBufferTable_isConstPtr(self); }
		public uint getCountPtr() { return tsBufferTable_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsBufferTable_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsBufferTable_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsBufferTable_getPlatformName(self)); }
		public uint getIndex() { return tsBufferTable_getIndex(self); }
		public void clear() { tsBufferTable_clear(self); }
		public bool isCreated() { return tsBufferTable_isCreated(self); }
		public void setName(string name) { tsBufferTable_setName(self, name); }
		public string getName() { return Base.getString(tsBufferTable_getName(self)); }
		public bool create(uint size) { return tsBufferTable_create(self, size); }
		public uint getSize() { return tsBufferTable_getSize(self); }
		public Buffer get(uint index) { return new Buffer(tsBufferTable_get(self, index)); }
		public bool isOwner(uint index) { return tsBufferTable_isOwner(self, index); }
		public ulong getMemory() { return tsBufferTable_getMemory(self); }
		public override string ToString() { return "Tellusim.BufferTable: Valid: " + tsBufferTable_isValidPtr(self) + "; Owner: " + tsBufferTable_isOwnerPtr(self) + "; Const: " + tsBufferTable_isConstPtr(self) + "; Count: " + tsBufferTable_getCountPtr(self) + "; Internal: 0x" + tsBufferTable_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(BufferTable ptr) { return (ptr != null && tsBufferTable_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_new();
		[DllImport(Base.Import)] private static extern void tsBufferTable_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBufferTable_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBufferTable_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBufferTable_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBufferTable_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBufferTable_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsBufferTable_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBufferTable_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBufferTable_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBufferTable_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_create(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern uint tsBufferTable_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBufferTable_get(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsBufferTable_isOwner(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsBufferTable_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::D3D12Buffer
	public sealed class D3D12Buffer : Buffer {
		public D3D12Buffer() { self = new HandleRef(this, tsD3D12Buffer_new()); owner = true; }
		public D3D12Buffer(D3D12Buffer ptr) { self = new HandleRef(this, tsD3D12Buffer_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Buffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Buffer_isOwnerPtr(self); }
		public D3D12Buffer(Buffer ptr) { self = new HandleRef(this, tsD3D12Buffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsD3D12Buffer_baseBufferPtr(self)); }
		public static new D3D12Buffer Null() { return new D3D12Buffer(IntPtr.Zero); }
		public bool create(Flags flags, IntPtr buffer, uint state) { return tsD3D12Buffer_create(self, flags, buffer, state); }
		public IntPtr getD3D12Buffer() { return tsD3D12Buffer_getD3D12Buffer(self); }
		public ulong getUnorderedAccessView() { return tsD3D12Buffer_getUnorderedAccessView(self); }
		public ulong getShaderResourceView() { return tsD3D12Buffer_getShaderResourceView(self); }
		public ulong getBufferAddress() { return tsD3D12Buffer_getBufferAddress(self); }
		public void setBufferState(uint state) { tsD3D12Buffer_setBufferState(self, state); }
		public uint getBufferState() { return tsD3D12Buffer_getBufferState(self); }
		public IntPtr getSharedHandle() { return tsD3D12Buffer_getSharedHandle(self); }
		public IntPtr getInteropHandle() { return tsD3D12Buffer_getInteropHandle(self); }
		public override string ToString() { return "Tellusim.D3D12Buffer: Valid: " + tsD3D12Buffer_isValidPtr(self) + "; Owner: " + tsD3D12Buffer_isOwnerPtr(self) + "; Const: " + tsD3D12Buffer_isConstPtr(self) + "; Count: " + tsD3D12Buffer_getCountPtr(self) + "; Internal: 0x" + tsD3D12Buffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Buffer ptr) { return (ptr != null && tsD3D12Buffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Buffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Buffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Buffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Buffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Buffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Buffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Buffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Buffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Buffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Buffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Buffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Buffer_create(HandleRef self, Flags flags, IntPtr buffer, uint state);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_getD3D12Buffer(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Buffer_getUnorderedAccessView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Buffer_getShaderResourceView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Buffer_getBufferAddress(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Buffer_setBufferState(HandleRef self, uint state);
		[DllImport(Base.Import)] private static extern uint tsD3D12Buffer_getBufferState(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_getSharedHandle(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Buffer_getInteropHandle(HandleRef self);
	}
	
	// Tellusim::D3D11Buffer
	public sealed class D3D11Buffer : Buffer {
		public D3D11Buffer() { self = new HandleRef(this, tsD3D11Buffer_new()); owner = true; }
		public D3D11Buffer(D3D11Buffer ptr) { self = new HandleRef(this, tsD3D11Buffer_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Buffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Buffer_isOwnerPtr(self); }
		public D3D11Buffer(Buffer ptr) { self = new HandleRef(this, tsD3D11Buffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsD3D11Buffer_baseBufferPtr(self)); }
		public static new D3D11Buffer Null() { return new D3D11Buffer(IntPtr.Zero); }
		public bool create(Flags flags, IntPtr buffer) { return tsD3D11Buffer_create(self, flags, buffer); }
		public IntPtr getD3D11Buffer() { return tsD3D11Buffer_getD3D11Buffer(self); }
		public IntPtr getUnorderedAccessView() { return tsD3D11Buffer_getUnorderedAccessView(self); }
		public IntPtr getShaderResourceView() { return tsD3D11Buffer_getShaderResourceView(self); }
		public IntPtr getInteropHandle() { return tsD3D11Buffer_getInteropHandle(self); }
		public override string ToString() { return "Tellusim.D3D11Buffer: Valid: " + tsD3D11Buffer_isValidPtr(self) + "; Owner: " + tsD3D11Buffer_isOwnerPtr(self) + "; Const: " + tsD3D11Buffer_isConstPtr(self) + "; Count: " + tsD3D11Buffer_getCountPtr(self) + "; Internal: 0x" + tsD3D11Buffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Buffer ptr) { return (ptr != null && tsD3D11Buffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_new();
		[DllImport(Base.Import)] private static extern void tsD3D11Buffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Buffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Buffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Buffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Buffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Buffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Buffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Buffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Buffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Buffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Buffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Buffer_create(HandleRef self, Flags flags, IntPtr buffer);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_getD3D11Buffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_getUnorderedAccessView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_getShaderResourceView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Buffer_getInteropHandle(HandleRef self);
	}
	
	// Tellusim::MTLBuffer
	public sealed class MTLBuffer : Buffer {
		public MTLBuffer() { self = new HandleRef(this, tsMTLBuffer_new()); owner = true; }
		public MTLBuffer(MTLBuffer ptr) { self = new HandleRef(this, tsMTLBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public MTLBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLBuffer_isOwnerPtr(self); }
		public MTLBuffer(Buffer ptr) { self = new HandleRef(this, tsMTLBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsMTLBuffer_baseBufferPtr(self)); }
		public static new MTLBuffer Null() { return new MTLBuffer(IntPtr.Zero); }
		public bool create(Flags flags, IntPtr buffer) { return tsMTLBuffer_create(self, flags, buffer); }
		public IntPtr getMTLBuffer() { return tsMTLBuffer_getMTLBuffer(self); }
		public IntPtr getSharedPtr() { return tsMTLBuffer_getSharedPtr(self); }
		public override string ToString() { return "Tellusim.MTLBuffer: Valid: " + tsMTLBuffer_isValidPtr(self) + "; Owner: " + tsMTLBuffer_isOwnerPtr(self) + "; Const: " + tsMTLBuffer_isConstPtr(self) + "; Count: " + tsMTLBuffer_getCountPtr(self) + "; Internal: 0x" + tsMTLBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLBuffer ptr) { return (ptr != null && tsMTLBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_new();
		[DllImport(Base.Import)] private static extern void tsMTLBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLBuffer_create(HandleRef self, Flags flags, IntPtr buffer);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_getMTLBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLBuffer_getSharedPtr(HandleRef self);
	}
	
	// Tellusim::VKBuffer
	public sealed class VKBuffer : Buffer {
		public VKBuffer() { self = new HandleRef(this, tsVKBuffer_new()); owner = true; }
		public VKBuffer(VKBuffer ptr) { self = new HandleRef(this, tsVKBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public VKBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKBuffer_isOwnerPtr(self); }
		public VKBuffer(Buffer ptr) { self = new HandleRef(this, tsVKBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsVKBuffer_baseBufferPtr(self)); }
		public static new VKBuffer Null() { return new VKBuffer(IntPtr.Zero); }
		public bool create(Flags flags, ulong size, IntPtr buffer, uint access) { return tsVKBuffer_create(self, flags, size, buffer, access); }
		public IntPtr getVKBuffer() { return tsVKBuffer_getVKBuffer(self); }
		public IntPtr getBufferView() { return tsVKBuffer_getBufferView(self); }
		public ulong getBufferAddress() { return tsVKBuffer_getBufferAddress(self); }
		public void setBufferAccess(uint access) { tsVKBuffer_setBufferAccess(self, access); }
		public uint getBufferAccess() { return tsVKBuffer_getBufferAccess(self); }
		public IntPtr getSharedPtr() { return tsVKBuffer_getSharedPtr(self); }
		public IntPtr getInteropHandle() { return tsVKBuffer_getInteropHandle(self); }
		public override string ToString() { return "Tellusim.VKBuffer: Valid: " + tsVKBuffer_isValidPtr(self) + "; Owner: " + tsVKBuffer_isOwnerPtr(self) + "; Const: " + tsVKBuffer_isConstPtr(self) + "; Count: " + tsVKBuffer_getCountPtr(self) + "; Internal: 0x" + tsVKBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKBuffer ptr) { return (ptr != null && tsVKBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_new();
		[DllImport(Base.Import)] private static extern void tsVKBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKBuffer_create(HandleRef self, Flags flags, ulong size, IntPtr buffer, uint access);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_getVKBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_getBufferView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsVKBuffer_getBufferAddress(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKBuffer_setBufferAccess(HandleRef self, uint access);
		[DllImport(Base.Import)] private static extern uint tsVKBuffer_getBufferAccess(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_getSharedPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKBuffer_getInteropHandle(HandleRef self);
	}
	
	// Tellusim::GLBuffer
	public sealed class GLBuffer : Buffer {
		public GLBuffer() { self = new HandleRef(this, tsGLBuffer_new()); owner = true; }
		public GLBuffer(GLBuffer ptr) { self = new HandleRef(this, tsGLBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public GLBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLBuffer_isOwnerPtr(self); }
		public GLBuffer(Buffer ptr) { self = new HandleRef(this, tsGLBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsGLBuffer_baseBufferPtr(self)); }
		public static new GLBuffer Null() { return new GLBuffer(IntPtr.Zero); }
		public bool create(Flags flags, uint target, uint buffer_id) { return tsGLBuffer_create(self, flags, target, buffer_id); }
		public uint getTarget() { return tsGLBuffer_getTarget(self); }
		public uint getBufferID() { return tsGLBuffer_getBufferID(self); }
		public override string ToString() { return "Tellusim.GLBuffer: Valid: " + tsGLBuffer_isValidPtr(self) + "; Owner: " + tsGLBuffer_isOwnerPtr(self) + "; Const: " + tsGLBuffer_isConstPtr(self) + "; Count: " + tsGLBuffer_getCountPtr(self) + "; Internal: 0x" + tsGLBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLBuffer ptr) { return (ptr != null && tsGLBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLBuffer_new();
		[DllImport(Base.Import)] private static extern void tsGLBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLBuffer_create(HandleRef self, Flags flags, uint target, uint buffer_id);
		[DllImport(Base.Import)] private static extern uint tsGLBuffer_getTarget(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLBuffer_getBufferID(HandleRef self);
	}
	
	// Tellusim::GLESBuffer
	public sealed class GLESBuffer : Buffer {
		public GLESBuffer() { self = new HandleRef(this, tsGLESBuffer_new()); owner = true; }
		public GLESBuffer(GLESBuffer ptr) { self = new HandleRef(this, tsGLESBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public GLESBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLESBuffer_isOwnerPtr(self); }
		public GLESBuffer(Buffer ptr) { self = new HandleRef(this, tsGLESBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsGLESBuffer_baseBufferPtr(self)); }
		public static new GLESBuffer Null() { return new GLESBuffer(IntPtr.Zero); }
		public bool create(Flags flags, uint target, uint buffer_id) { return tsGLESBuffer_create(self, flags, target, buffer_id); }
		public uint getTarget() { return tsGLESBuffer_getTarget(self); }
		public uint getBufferID() { return tsGLESBuffer_getBufferID(self); }
		public override string ToString() { return "Tellusim.GLESBuffer: Valid: " + tsGLESBuffer_isValidPtr(self) + "; Owner: " + tsGLESBuffer_isOwnerPtr(self) + "; Const: " + tsGLESBuffer_isConstPtr(self) + "; Count: " + tsGLESBuffer_getCountPtr(self) + "; Internal: 0x" + tsGLESBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLESBuffer ptr) { return (ptr != null && tsGLESBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLESBuffer_new();
		[DllImport(Base.Import)] private static extern void tsGLESBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESBuffer_create(HandleRef self, Flags flags, uint target, uint buffer_id);
		[DllImport(Base.Import)] private static extern uint tsGLESBuffer_getTarget(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESBuffer_getBufferID(HandleRef self);
	}
	
	// Tellusim::CUBuffer
	public sealed class CUBuffer : Buffer {
		public CUBuffer() { self = new HandleRef(this, tsCUBuffer_new()); owner = true; }
		public CUBuffer(CUBuffer ptr) { self = new HandleRef(this, tsCUBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public CUBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCUBuffer_isOwnerPtr(self); }
		public CUBuffer(Buffer ptr) { self = new HandleRef(this, tsCUBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsCUBuffer_baseBufferPtr(self)); }
		public static new CUBuffer Null() { return new CUBuffer(IntPtr.Zero); }
		public ulong getBufferPtr() { return tsCUBuffer_getBufferPtr(self); }
		public byte[] getBufferData() { return tsCUBuffer_getBufferData(self); }
		public IntPtr getBufferEvent() { return tsCUBuffer_getBufferEvent(self); }
		public uint getArrayFormat() { return tsCUBuffer_getArrayFormat(self); }
		public uint getArrayChannels() { return tsCUBuffer_getArrayChannels(self); }
		public IntPtr getSharedMemory() { return tsCUBuffer_getSharedMemory(self); }
		public override string ToString() { return "Tellusim.CUBuffer: Valid: " + tsCUBuffer_isValidPtr(self) + "; Owner: " + tsCUBuffer_isOwnerPtr(self) + "; Const: " + tsCUBuffer_isConstPtr(self) + "; Count: " + tsCUBuffer_getCountPtr(self) + "; Internal: 0x" + tsCUBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CUBuffer ptr) { return (ptr != null && tsCUBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_new();
		[DllImport(Base.Import)] private static extern void tsCUBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsCUBuffer_getBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern byte[] tsCUBuffer_getBufferData(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_getBufferEvent(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUBuffer_getArrayFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUBuffer_getArrayChannels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUBuffer_getSharedMemory(HandleRef self);
	}
	
	// Tellusim::HIPBuffer
	public sealed class HIPBuffer : Buffer {
		public HIPBuffer() { self = new HandleRef(this, tsHIPBuffer_new()); owner = true; }
		public HIPBuffer(HIPBuffer ptr) { self = new HandleRef(this, tsHIPBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public HIPBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsHIPBuffer_isOwnerPtr(self); }
		public HIPBuffer(Buffer ptr) { self = new HandleRef(this, tsHIPBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsHIPBuffer_baseBufferPtr(self)); }
		public static new HIPBuffer Null() { return new HIPBuffer(IntPtr.Zero); }
		public IntPtr getBufferPtr() { return tsHIPBuffer_getBufferPtr(self); }
		public byte[] getBufferData() { return tsHIPBuffer_getBufferData(self); }
		public IntPtr getBufferEvent() { return tsHIPBuffer_getBufferEvent(self); }
		public uint getArrayFormat() { return tsHIPBuffer_getArrayFormat(self); }
		public uint getArrayChannels() { return tsHIPBuffer_getArrayChannels(self); }
		public IntPtr getSharedMemory() { return tsHIPBuffer_getSharedMemory(self); }
		public override string ToString() { return "Tellusim.HIPBuffer: Valid: " + tsHIPBuffer_isValidPtr(self) + "; Owner: " + tsHIPBuffer_isOwnerPtr(self) + "; Const: " + tsHIPBuffer_isConstPtr(self) + "; Count: " + tsHIPBuffer_getCountPtr(self) + "; Internal: 0x" + tsHIPBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(HIPBuffer ptr) { return (ptr != null && tsHIPBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_new();
		[DllImport(Base.Import)] private static extern void tsHIPBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_getBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern byte[] tsHIPBuffer_getBufferData(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_getBufferEvent(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPBuffer_getArrayFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPBuffer_getArrayChannels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPBuffer_getSharedMemory(HandleRef self);
	}
	
	// Tellusim::FUBuffer
	public sealed class FUBuffer : Buffer {
		public FUBuffer() { self = new HandleRef(this, tsFUBuffer_new()); owner = true; }
		public FUBuffer(Buffer[] buffers, bool owner = false) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			self = new HandleRef(this, tsFUBuffer_new_cABb(buffers_, (uint)buffers.Length, owner)); owner = true;
		}
		public FUBuffer(FUBuffer ptr) { self = new HandleRef(this, tsFUBuffer_copyPtr(ptr.getSelf())); owner = true; }
		public FUBuffer(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUBuffer_isOwnerPtr(self); }
		public FUBuffer(Buffer ptr) { self = new HandleRef(this, tsFUBuffer_castBufferPtr(ptr.getSelf())); }
		public Buffer toBuffer() { return new Buffer(tsFUBuffer_baseBufferPtr(self)); }
		public static new FUBuffer Null() { return new FUBuffer(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUBuffer_setMask(self, mask); }
		public uint getMask() { return tsFUBuffer_getMask(self); }
		public uint getNumBuffers() { return tsFUBuffer_getNumBuffers(self); }
		public Buffer getBuffer(uint index) { return new Buffer(tsFUBuffer_getBuffer_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUBuffer: Valid: " + tsFUBuffer_isValidPtr(self) + "; Owner: " + tsFUBuffer_isOwnerPtr(self) + "; Const: " + tsFUBuffer_isConstPtr(self) + "; Count: " + tsFUBuffer_getCountPtr(self) + "; Internal: 0x" + tsFUBuffer_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUBuffer ptr) { return (ptr != null && tsFUBuffer_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_new_cABb(IntPtr[] buffers, uint buffers_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUBuffer_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUBuffer_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUBuffer_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUBuffer_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUBuffer_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUBuffer_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUBuffer_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUBuffer_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUBuffer_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUBuffer_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUBuffer_equalBufferPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_castBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_baseBufferPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUBuffer_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUBuffer_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUBuffer_getNumBuffers(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUBuffer_getBuffer_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Command
	public partial class Command {
		public Command() { self = new HandleRef(this, tsCommand_new()); owner = true; }
		public Command(Command ptr) { self = new HandleRef(this, tsCommand_copyPtr(ptr.getSelf())); owner = true; }
		public Command(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCommand_isOwnerPtr(self); }
		public static Command Null() { return new Command(IntPtr.Zero); }
		~Command() { if(owner) tsCommand_delete(self); }
		public bool equalPtr(Command ptr) { return tsCommand_equalPtr(self, ptr.getSelf()); }
		public Command clonePtr() { return new Command(tsCommand_clonePtr(self)); }
		public void clearPtr() { tsCommand_clearPtr(self); }
		public void destroyPtr() { tsCommand_destroyPtr(self); }
		public void acquirePtr() { tsCommand_acquirePtr(self); }
		public void unacquirePtr() { tsCommand_unacquirePtr(self); }
		public bool isValidPtr() { return tsCommand_isValidPtr(self); }
		public bool isOwnerPtr() { return tsCommand_isOwnerPtr(self); }
		public bool isConstPtr() { return tsCommand_isConstPtr(self); }
		public uint getCountPtr() { return tsCommand_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsCommand_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsCommand_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsCommand_getPlatformName(self)); }
		public uint getIndex() { return tsCommand_getIndex(self); }
		public void setPipeline(Pipeline pipeline) { tsCommand_setPipeline(self, pipeline.getSelf()); }
		public Pipeline getPipeline() { return new Pipeline(tsCommand_getPipeline(self)); }
		public void setViewport(uint index, in Viewport viewport) { tsCommand_setViewport(self, index, in viewport); }
		public void setViewports(Viewport[] viewports) { tsCommand_setViewports(self, viewports, (uint)viewports.Length); }
		public void setScissor(uint index, in Scissor scissor) { tsCommand_setScissor(self, index, in scissor); }
		public void setScissors(Scissor[] scissors) { tsCommand_setScissors(self, scissors, (uint)scissors.Length); }
		public void setSampler(uint index, Sampler sampler) { tsCommand_setSampler(self, index, sampler.getSelf()); }
		public void setSamplers(uint index, Sampler[] samplers) {
			IntPtr[] samplers_ = new IntPtr[samplers.Length];
			for(int i = 0; i < samplers.Length; i++) samplers_[i] = samplers[i].getSelfPtr();
			tsCommand_setSamplers_ucAS(self, index, samplers_, (uint)samplers.Length);
		}
		public void setTexture(uint index, Texture texture) { tsCommand_setTexture_uT(self, index, texture.getSelf()); }
		public void setTexture(uint index, Texture texture, in Slice slice) { tsCommand_setTexture_uTcS(self, index, texture.getSelf(), in slice); }
		public void setTextures(uint index, Texture[] textures) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			tsCommand_setTextures_ucAT(self, index, textures_, (uint)textures.Length);
		}
		public void setSurfaceTexture(uint index, Texture texture) { tsCommand_setSurfaceTexture_uT(self, index, texture.getSelf()); }
		public void setSurfaceTexture(uint index, Texture texture, in Slice slice, Format format = Format.Unknown) { tsCommand_setSurfaceTexture_uTcSF(self, index, texture.getSelf(), in slice, format); }
		public void setSurfaceTextures(uint index, Texture[] textures) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			tsCommand_setSurfaceTextures_ucAT(self, index, textures_, (uint)textures.Length);
		}
		public IntPtr getUniformData(uint index, ulong size) { return tsCommand_getUniformData(self, index, size); }
		public void setUniformData(uint index, IntPtr src, ulong size) { tsCommand_setUniformData(self, index, src, size); }
		public void setUniformData<Type>(uint index, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setUniformData(index, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setUniformBuffer(uint index, Buffer buffer, ulong offset = 0, ulong size = 0) { tsCommand_setUniformBuffer(self, index, buffer.getSelf(), offset, size); }
		public void setUniformOffset(uint index, ulong offset, bool relative = false) { tsCommand_setUniformOffset(self, index, offset, relative); }
		public void setUniformBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setUniformBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setUniformBuffers(uint index, Buffer[] buffers, ulong[] offsets) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setUniformBuffers_ucABcA(self, index, buffers_, (uint)buffers.Length, offsets, (uint)offsets.Length);
		}
		public IntPtr getStorageData(uint index, ulong size) { return tsCommand_getStorageData(self, index, size); }
		public void setStorageData(uint index, IntPtr src, ulong size) { tsCommand_setStorageData(self, index, src, size); }
		public void setStorageData<Type>(uint index, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setStorageData(index, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setStorageBuffer(uint index, Buffer buffer, ulong offset = 0, ulong size = 0) { tsCommand_setStorageBuffer(self, index, buffer.getSelf(), offset, size); }
		public void setStorageOffset(uint index, ulong offset, bool relative = false) { tsCommand_setStorageOffset(self, index, offset, relative); }
		public void setStorageBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setStorageBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setStorageBuffers(uint index, Buffer[] buffers, ulong[] offsets) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setStorageBuffers_ucABcA(self, index, buffers_, (uint)buffers.Length, offsets, (uint)offsets.Length);
		}
		public void setTracing(uint index, Tracing tracing) { tsCommand_setTracing(self, index, tracing.getSelf()); }
		public void setTracings(uint index, Tracing[] tracings) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			tsCommand_setTracings_ucAT(self, index, tracings_, (uint)tracings.Length);
		}
		public void setTexelBuffer(uint index, Buffer buffer) { tsCommand_setTexelBuffer(self, index, buffer.getSelf()); }
		public void setTexelBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setTexelBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setTextureTable(uint index, TextureTable table) { tsCommand_setTextureTable(self, index, table.getSelf()); }
		public void setTextureTables(uint index, TextureTable[] tables) {
			IntPtr[] tables_ = new IntPtr[tables.Length];
			for(int i = 0; i < tables.Length; i++) tables_[i] = tables[i].getSelfPtr();
			tsCommand_setTextureTables_ucATT(self, index, tables_, (uint)tables.Length);
		}
		public void setStorageTable(uint index, BufferTable table) { tsCommand_setStorageTable(self, index, table.getSelf()); }
		public void setStorageTables(uint index, BufferTable[] tables) {
			IntPtr[] tables_ = new IntPtr[tables.Length];
			for(int i = 0; i < tables.Length; i++) tables_[i] = tables[i].getSelfPtr();
			tsCommand_setStorageTables_ucABT(self, index, tables_, (uint)tables.Length);
		}
		public IntPtr getVertexData(uint index, ulong size) { return tsCommand_getVertexData(self, index, size); }
		public void setVertexData(uint index, IntPtr src, ulong size) { tsCommand_setVertexData(self, index, src, size); }
		public void setVertexData<Type>(uint index, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setVertexData(index, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setVertexBuffer(uint index, Buffer buffer, ulong offset = 0) { tsCommand_setVertexBuffer(self, index, buffer.getSelf(), offset); }
		public void setVertexOffset(uint index, ulong offset, bool relative = false) { tsCommand_setVertexOffset(self, index, offset, relative); }
		public void setVertexBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setVertexBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setVertexBuffers(uint index, Buffer[] buffers, ulong[] offsets) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCommand_setVertexBuffers_ucABcA(self, index, buffers_, (uint)buffers.Length, offsets, (uint)offsets.Length);
		}
		public IntPtr getIndexData(Format format, ulong size) { return tsCommand_getIndexData(self, format, size); }
		public void setIndexData(Format format, IntPtr src, ulong size) { tsCommand_setIndexData(self, format, src, size); }
		public void setIndexData<Type>(Format format, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setIndexData(format, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setIndexBuffer(Format format, Buffer buffer, ulong offset = 0) { tsCommand_setIndexBuffer(self, format, buffer.getSelf(), offset); }
		public void setIndexOffset(ulong offset, bool relative = false) { tsCommand_setIndexOffset(self, offset, relative); }
		public IntPtr getIndirectData(ulong size) { return tsCommand_getIndirectData(self, size); }
		public void setIndirectData(IntPtr src, ulong size) { tsCommand_setIndirectData(self, src, size); }
		public void setIndirectData<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setIndirectData(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setIndirectBuffer(Buffer buffer, ulong offset = 0) { tsCommand_setIndirectBuffer(self, buffer.getSelf(), offset); }
		public void setIndirectOffset(ulong offset, bool relative = false) { tsCommand_setIndirectOffset(self, offset, relative); }
		public void setBlendColor(in Color color) { tsCommand_setBlendColor_cC(self, in color); }
		public void setBlendColor(float r, float g, float b, float a) { tsCommand_setBlendColor_ffff(self, r, g, b, a); }
		public void setStencilRef(uint ref_) { tsCommand_setStencilRef(self, ref_); }
		public void drawArrays(uint num_vertices, uint base_vertex = 0) { tsCommand_drawArrays(self, num_vertices, base_vertex); }
		public void drawArraysInstanced(uint num_vertices, uint base_vertex, uint num_instances, uint base_instance = 0) { tsCommand_drawArraysInstanced(self, num_vertices, base_vertex, num_instances, base_instance); }
		public void drawArraysIndirect(uint num_draws, ulong stride = 16) { tsCommand_drawArraysIndirect_uz(self, num_draws, stride); }
		public void drawArraysIndirect(Buffer buffer, ulong offset, uint num_draws, ulong stride = 16) { tsCommand_drawArraysIndirect_Bzuz(self, buffer.getSelf(), offset, num_draws, stride); }
		public void drawElements(uint num_indices, uint base_index = 0, int base_vertex = 0) { tsCommand_drawElements(self, num_indices, base_index, base_vertex); }
		public void drawElementsInstanced(uint num_indices, uint base_index, uint num_instances) { tsCommand_drawElementsInstanced_uuu(self, num_indices, base_index, num_instances); }
		public void drawElementsInstanced(uint num_indices, uint base_index, int base_vertex, uint num_instances, uint base_instance = 0) { tsCommand_drawElementsInstanced_uuiuu(self, num_indices, base_index, base_vertex, num_instances, base_instance); }
		public void drawElementsIndirect(uint num_draws, ulong stride = 20) { tsCommand_drawElementsIndirect_uz(self, num_draws, stride); }
		public void drawElementsIndirect(Buffer buffer, ulong offset, uint num_draws, ulong stride = 20) { tsCommand_drawElementsIndirect_Bzuz(self, buffer.getSelf(), offset, num_draws, stride); }
		public void drawMesh(uint width, uint height = 1, uint depth = 1) { tsCommand_drawMesh(self, width, height, depth); }
		public void drawMeshIndirect(uint num_draws, ulong stride = 16) { tsCommand_drawMeshIndirect_uz(self, num_draws, stride); }
		public void drawMeshIndirect(Buffer buffer, ulong offset, uint num_draws, ulong stride = 16) { tsCommand_drawMeshIndirect_Bzuz(self, buffer.getSelf(), offset, num_draws, stride); }
		public void beginConditional(Buffer buffer, ulong offset) { tsCommand_beginConditional(self, buffer.getSelf(), offset); }
		public void endConditional() { tsCommand_endConditional(self); }
		public bool beginQuery(Query query) { return tsCommand_beginQuery(self, query.getSelf()); }
		public void endQuery(Query query) { tsCommand_endQuery(self, query.getSelf()); }
		public override string ToString() { return "Tellusim.Command: Valid: " + tsCommand_isValidPtr(self) + "; Owner: " + tsCommand_isOwnerPtr(self) + "; Const: " + tsCommand_isConstPtr(self) + "; Count: " + tsCommand_getCountPtr(self) + "; Internal: 0x" + tsCommand_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Command ptr) { return (ptr != null && tsCommand_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_new();
		[DllImport(Base.Import)] private static extern void tsCommand_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCommand_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCommand_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCommand_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCommand_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCommand_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCommand_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCommand_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCommand_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCommand_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsCommand_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCommand_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCommand_setPipeline(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getPipeline(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCommand_setViewport(HandleRef self, uint index, in Viewport viewport);
		[DllImport(Base.Import)] private static extern void tsCommand_setViewports(HandleRef self, Viewport[] viewports, uint num_viewports);
		[DllImport(Base.Import)] private static extern void tsCommand_setScissor(HandleRef self, uint index, in Scissor scissor);
		[DllImport(Base.Import)] private static extern void tsCommand_setScissors(HandleRef self, Scissor[] scissors, uint num_scissors);
		[DllImport(Base.Import)] private static extern void tsCommand_setSampler(HandleRef self, uint index, HandleRef sampler);
		[DllImport(Base.Import)] private static extern void tsCommand_setSamplers_ucAS(HandleRef self, uint index, IntPtr[] samplers, uint samplers_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setTexture_uT(HandleRef self, uint index, HandleRef texture);
		[DllImport(Base.Import)] private static extern void tsCommand_setTexture_uTcS(HandleRef self, uint index, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsCommand_setTextures_ucAT(HandleRef self, uint index, IntPtr[] textures, uint textures_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setSurfaceTexture_uT(HandleRef self, uint index, HandleRef texture);
		[DllImport(Base.Import)] private static extern void tsCommand_setSurfaceTexture_uTcSF(HandleRef self, uint index, HandleRef texture, in Slice slice, Format format);
		[DllImport(Base.Import)] private static extern void tsCommand_setSurfaceTextures_ucAT(HandleRef self, uint index, IntPtr[] textures, uint textures_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getUniformData(HandleRef self, uint index, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setUniformData(HandleRef self, uint index, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setUniformBuffer(HandleRef self, uint index, HandleRef buffer, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setUniformOffset(HandleRef self, uint index, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCommand_setUniformBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setUniformBuffers_ucABcA(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size, ulong[] offsets, uint offsets_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getStorageData(HandleRef self, uint index, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageData(HandleRef self, uint index, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageBuffer(HandleRef self, uint index, HandleRef buffer, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageOffset(HandleRef self, uint index, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageBuffers_ucABcA(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size, ulong[] offsets, uint offsets_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setTracing(HandleRef self, uint index, HandleRef tracing);
		[DllImport(Base.Import)] private static extern void tsCommand_setTracings_ucAT(HandleRef self, uint index, IntPtr[] tracings, uint tracings_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setTexelBuffer(HandleRef self, uint index, HandleRef buffer);
		[DllImport(Base.Import)] private static extern void tsCommand_setTexelBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setTextureTable(HandleRef self, uint index, HandleRef table);
		[DllImport(Base.Import)] private static extern void tsCommand_setTextureTables_ucATT(HandleRef self, uint index, IntPtr[] tables, uint tables_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageTable(HandleRef self, uint index, HandleRef table);
		[DllImport(Base.Import)] private static extern void tsCommand_setStorageTables_ucABT(HandleRef self, uint index, IntPtr[] tables, uint tables_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getVertexData(HandleRef self, uint index, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setVertexData(HandleRef self, uint index, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setVertexBuffer(HandleRef self, uint index, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsCommand_setVertexOffset(HandleRef self, uint index, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCommand_setVertexBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCommand_setVertexBuffers_ucABcA(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size, ulong[] offsets, uint offsets_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getIndexData(HandleRef self, Format format, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setIndexData(HandleRef self, Format format, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setIndexBuffer(HandleRef self, Format format, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsCommand_setIndexOffset(HandleRef self, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern IntPtr tsCommand_getIndirectData(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setIndirectData(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCommand_setIndirectBuffer(HandleRef self, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsCommand_setIndirectOffset(HandleRef self, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCommand_setBlendColor_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern void tsCommand_setBlendColor_ffff(HandleRef self, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern void tsCommand_setStencilRef(HandleRef self, uint ref_);
		[DllImport(Base.Import)] private static extern void tsCommand_drawArrays(HandleRef self, uint num_vertices, uint base_vertex);
		[DllImport(Base.Import)] private static extern void tsCommand_drawArraysInstanced(HandleRef self, uint num_vertices, uint base_vertex, uint num_instances, uint base_instance);
		[DllImport(Base.Import)] private static extern void tsCommand_drawArraysIndirect_uz(HandleRef self, uint num_draws, ulong stride);
		[DllImport(Base.Import)] private static extern void tsCommand_drawArraysIndirect_Bzuz(HandleRef self, HandleRef buffer, ulong offset, uint num_draws, ulong stride);
		[DllImport(Base.Import)] private static extern void tsCommand_drawElements(HandleRef self, uint num_indices, uint base_index, int base_vertex);
		[DllImport(Base.Import)] private static extern void tsCommand_drawElementsInstanced_uuu(HandleRef self, uint num_indices, uint base_index, uint num_instances);
		[DllImport(Base.Import)] private static extern void tsCommand_drawElementsInstanced_uuiuu(HandleRef self, uint num_indices, uint base_index, int base_vertex, uint num_instances, uint base_instance);
		[DllImport(Base.Import)] private static extern void tsCommand_drawElementsIndirect_uz(HandleRef self, uint num_draws, ulong stride);
		[DllImport(Base.Import)] private static extern void tsCommand_drawElementsIndirect_Bzuz(HandleRef self, HandleRef buffer, ulong offset, uint num_draws, ulong stride);
		[DllImport(Base.Import)] private static extern void tsCommand_drawMesh(HandleRef self, uint width, uint height, uint depth);
		[DllImport(Base.Import)] private static extern void tsCommand_drawMeshIndirect_uz(HandleRef self, uint num_draws, ulong stride);
		[DllImport(Base.Import)] private static extern void tsCommand_drawMeshIndirect_Bzuz(HandleRef self, HandleRef buffer, ulong offset, uint num_draws, ulong stride);
		[DllImport(Base.Import)] private static extern void tsCommand_beginConditional(HandleRef self, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsCommand_endConditional(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCommand_beginQuery(HandleRef self, HandleRef query);
		[DllImport(Base.Import)] private static extern void tsCommand_endQuery(HandleRef self, HandleRef query);
		[StructLayout(LayoutKind.Sequential)] public struct DrawArraysIndirect {
			public uint num_vertices;
			public uint num_instances;
			public uint base_vertex;
			public uint base_instance;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("num_vertices: {0}\n", num_vertices);
				ret += System.String.Format("num_instances: {0}\n", num_instances);
				ret += System.String.Format("base_vertex: {0}\n", base_vertex);
				ret += System.String.Format("base_instance: {0}", base_instance);
				return ret;
			}
		}
		[StructLayout(LayoutKind.Sequential)] public struct DrawElementsIndirect {
			public uint num_indices;
			public uint num_instances;
			public uint base_index;
			public int base_vertex;
			public uint base_instance;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("num_indices: {0}\n", num_indices);
				ret += System.String.Format("num_instances: {0}\n", num_instances);
				ret += System.String.Format("base_index: {0}\n", base_index);
				ret += System.String.Format("base_vertex: {0}\n", base_vertex);
				ret += System.String.Format("base_instance: {0}", base_instance);
				return ret;
			}
		}
		[StructLayout(LayoutKind.Sequential)] public struct DrawMeshIndirect {
			public uint group_width;
			public uint group_height;
			public uint group_depth;
			public uint padding;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("group_width: {0}\n", group_width);
				ret += System.String.Format("group_height: {0}\n", group_height);
				ret += System.String.Format("group_depth: {0}\n", group_depth);
				return ret;
			}
		}
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Command
	public sealed class D3D12Command : Command {
		public D3D12Command() { self = new HandleRef(this, tsD3D12Command_new()); owner = true; }
		public D3D12Command(D3D12Command ptr) { self = new HandleRef(this, tsD3D12Command_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Command(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Command_isOwnerPtr(self); }
		public D3D12Command(Command ptr) { self = new HandleRef(this, tsD3D12Command_castCommandPtr(ptr.getSelf())); }
		public Command toCommand() { return new Command(tsD3D12Command_baseCommandPtr(self)); }
		public static new D3D12Command Null() { return new D3D12Command(IntPtr.Zero); }
		public IntPtr getD3D12Command() { return tsD3D12Command_getD3D12Command(self); }
		public void update() { tsD3D12Command_update(self); }
		public override string ToString() { return "Tellusim.D3D12Command: Valid: " + tsD3D12Command_isValidPtr(self) + "; Owner: " + tsD3D12Command_isOwnerPtr(self) + "; Const: " + tsD3D12Command_isConstPtr(self) + "; Count: " + tsD3D12Command_getCountPtr(self) + "; Internal: 0x" + tsD3D12Command_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Command ptr) { return (ptr != null && tsD3D12Command_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Command_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Command_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Command_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Command_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Command_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Command_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Command_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Command_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Command_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Command_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Command_equalCommandPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_castCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_baseCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Command_getD3D12Command(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Command_update(HandleRef self);
	}
	
	// Tellusim::MTLCommand
	public sealed class MTLCommand : Command {
		public MTLCommand() { self = new HandleRef(this, tsMTLCommand_new()); owner = true; }
		public MTLCommand(MTLCommand ptr) { self = new HandleRef(this, tsMTLCommand_copyPtr(ptr.getSelf())); owner = true; }
		public MTLCommand(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLCommand_isOwnerPtr(self); }
		public MTLCommand(Command ptr) { self = new HandleRef(this, tsMTLCommand_castCommandPtr(ptr.getSelf())); }
		public Command toCommand() { return new Command(tsMTLCommand_baseCommandPtr(self)); }
		public static new MTLCommand Null() { return new MTLCommand(IntPtr.Zero); }
		public IntPtr getEncoder() { return tsMTLCommand_getEncoder(self); }
		public void flush(IntPtr encoder, bool enqueue = false) { tsMTLCommand_flush_prb(self, encoder, enqueue); }
		public void flush(bool create = false, bool enqueue = false) { tsMTLCommand_flush_bb(self, create, enqueue); }
		public void update() { tsMTLCommand_update(self); }
		public override string ToString() { return "Tellusim.MTLCommand: Valid: " + tsMTLCommand_isValidPtr(self) + "; Owner: " + tsMTLCommand_isOwnerPtr(self) + "; Const: " + tsMTLCommand_isConstPtr(self) + "; Count: " + tsMTLCommand_getCountPtr(self) + "; Internal: 0x" + tsMTLCommand_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLCommand ptr) { return (ptr != null && tsMTLCommand_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_new();
		[DllImport(Base.Import)] private static extern void tsMTLCommand_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCommand_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCommand_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCommand_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCommand_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLCommand_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCommand_equalCommandPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_castCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_baseCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCommand_getEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_flush_prb(HandleRef self, IntPtr encoder, bool enqueue);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_flush_bb(HandleRef self, bool create, bool enqueue);
		[DllImport(Base.Import)] private static extern void tsMTLCommand_update(HandleRef self);
	}
	
	// Tellusim::VKCommand
	public sealed class VKCommand : Command {
		public VKCommand() { self = new HandleRef(this, tsVKCommand_new()); owner = true; }
		public VKCommand(VKCommand ptr) { self = new HandleRef(this, tsVKCommand_copyPtr(ptr.getSelf())); owner = true; }
		public VKCommand(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKCommand_isOwnerPtr(self); }
		public VKCommand(Command ptr) { self = new HandleRef(this, tsVKCommand_castCommandPtr(ptr.getSelf())); }
		public Command toCommand() { return new Command(tsVKCommand_baseCommandPtr(self)); }
		public static new VKCommand Null() { return new VKCommand(IntPtr.Zero); }
		public IntPtr getVKCommand() { return tsVKCommand_getVKCommand(self); }
		public IntPtr getSamplerDescriptor() { return tsVKCommand_getSamplerDescriptor(self); }
		public IntPtr getImageDescriptor() { return tsVKCommand_getImageDescriptor(self); }
		public IntPtr getBufferDescriptor() { return tsVKCommand_getBufferDescriptor(self); }
		public IntPtr getTracingDescriptor() { return tsVKCommand_getTracingDescriptor(self); }
		public IntPtr getTexelDescriptor() { return tsVKCommand_getTexelDescriptor(self); }
		public void update() { tsVKCommand_update(self); }
		public override string ToString() { return "Tellusim.VKCommand: Valid: " + tsVKCommand_isValidPtr(self) + "; Owner: " + tsVKCommand_isOwnerPtr(self) + "; Const: " + tsVKCommand_isConstPtr(self) + "; Count: " + tsVKCommand_getCountPtr(self) + "; Internal: 0x" + tsVKCommand_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKCommand ptr) { return (ptr != null && tsVKCommand_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_new();
		[DllImport(Base.Import)] private static extern void tsVKCommand_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCommand_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCommand_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCommand_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCommand_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCommand_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCommand_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCommand_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCommand_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKCommand_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCommand_equalCommandPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_castCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_baseCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getVKCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getSamplerDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getImageDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getBufferDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getTracingDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCommand_getTexelDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCommand_update(HandleRef self);
	}
	
	// Tellusim::FUCommand
	public sealed class FUCommand : Command {
		public FUCommand() { self = new HandleRef(this, tsFUCommand_new()); owner = true; }
		public FUCommand(Command[] commands, bool owner = false) {
			IntPtr[] commands_ = new IntPtr[commands.Length];
			for(int i = 0; i < commands.Length; i++) commands_[i] = commands[i].getSelfPtr();
			self = new HandleRef(this, tsFUCommand_new_cACb(commands_, (uint)commands.Length, owner)); owner = true;
		}
		public FUCommand(FUCommand ptr) { self = new HandleRef(this, tsFUCommand_copyPtr(ptr.getSelf())); owner = true; }
		public FUCommand(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUCommand_isOwnerPtr(self); }
		public FUCommand(Command ptr) { self = new HandleRef(this, tsFUCommand_castCommandPtr(ptr.getSelf())); }
		public Command toCommand() { return new Command(tsFUCommand_baseCommandPtr(self)); }
		public static new FUCommand Null() { return new FUCommand(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUCommand_setMask(self, mask); }
		public uint getMask() { return tsFUCommand_getMask(self); }
		public uint getNumCommands() { return tsFUCommand_getNumCommands(self); }
		public Command getCommand(uint index) { return new Command(tsFUCommand_getCommand_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUCommand: Valid: " + tsFUCommand_isValidPtr(self) + "; Owner: " + tsFUCommand_isOwnerPtr(self) + "; Const: " + tsFUCommand_isConstPtr(self) + "; Count: " + tsFUCommand_getCountPtr(self) + "; Internal: 0x" + tsFUCommand_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUCommand ptr) { return (ptr != null && tsFUCommand_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_new_cACb(IntPtr[] commands, uint commands_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUCommand_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCommand_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCommand_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCommand_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCommand_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCommand_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCommand_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCommand_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCommand_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUCommand_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCommand_equalCommandPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_castCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_baseCommandPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCommand_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUCommand_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUCommand_getNumCommands(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCommand_getCommand_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Compute
	public partial class Compute {
		public Compute() { self = new HandleRef(this, tsCompute_new()); owner = true; }
		public Compute(Compute ptr) { self = new HandleRef(this, tsCompute_copyPtr(ptr.getSelf())); owner = true; }
		public Compute(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCompute_isOwnerPtr(self); }
		public static Compute Null() { return new Compute(IntPtr.Zero); }
		~Compute() { if(owner) tsCompute_delete(self); }
		public bool equalPtr(Compute ptr) { return tsCompute_equalPtr(self, ptr.getSelf()); }
		public Compute clonePtr() { return new Compute(tsCompute_clonePtr(self)); }
		public void clearPtr() { tsCompute_clearPtr(self); }
		public void destroyPtr() { tsCompute_destroyPtr(self); }
		public void acquirePtr() { tsCompute_acquirePtr(self); }
		public void unacquirePtr() { tsCompute_unacquirePtr(self); }
		public bool isValidPtr() { return tsCompute_isValidPtr(self); }
		public bool isOwnerPtr() { return tsCompute_isOwnerPtr(self); }
		public bool isConstPtr() { return tsCompute_isConstPtr(self); }
		public uint getCountPtr() { return tsCompute_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsCompute_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsCompute_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsCompute_getPlatformName(self)); }
		public uint getIndex() { return tsCompute_getIndex(self); }
		public void setKernel(Kernel kernel) { tsCompute_setKernel(self, kernel.getSelf()); }
		public Kernel getKernel() { return new Kernel(tsCompute_getKernel(self)); }
		public void setTraversal(Traversal traversal) { tsCompute_setTraversal(self, traversal.getSelf()); }
		public Traversal getTraversal() { return new Traversal(tsCompute_getTraversal(self)); }
		public void setSampler(uint index, Sampler sampler) { tsCompute_setSampler(self, index, sampler.getSelf()); }
		public void setSamplers(uint index, Sampler[] samplers) {
			IntPtr[] samplers_ = new IntPtr[samplers.Length];
			for(int i = 0; i < samplers.Length; i++) samplers_[i] = samplers[i].getSelfPtr();
			tsCompute_setSamplers_ucAS(self, index, samplers_, (uint)samplers.Length);
		}
		public void setTexture(uint index, Texture texture) { tsCompute_setTexture_uT(self, index, texture.getSelf()); }
		public void setTexture(uint index, Texture texture, in Slice slice) { tsCompute_setTexture_uTcS(self, index, texture.getSelf(), in slice); }
		public void setTextures(uint index, Texture[] textures) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			tsCompute_setTextures_ucAT(self, index, textures_, (uint)textures.Length);
		}
		public void setSurfaceTexture(uint index, Texture texture) { tsCompute_setSurfaceTexture_uT(self, index, texture.getSelf()); }
		public void setSurfaceTexture(uint index, Texture texture, in Slice slice, Format format = Format.Unknown) { tsCompute_setSurfaceTexture_uTcSF(self, index, texture.getSelf(), in slice, format); }
		public void setSurfaceTextures(uint index, Texture[] textures) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			tsCompute_setSurfaceTextures_ucAT(self, index, textures_, (uint)textures.Length);
		}
		public IntPtr getUniformData(uint index, ulong size) { return tsCompute_getUniformData(self, index, size); }
		public void setUniformData(uint index, IntPtr src, ulong size) { tsCompute_setUniformData(self, index, src, size); }
		public void setUniformData<Type>(uint index, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setUniformData(index, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setUniformBuffer(uint index, Buffer buffer, ulong offset = 0, ulong size = 0) { tsCompute_setUniformBuffer(self, index, buffer.getSelf(), offset, size); }
		public void setUniformOffset(uint index, ulong offset, bool relative = false) { tsCompute_setUniformOffset(self, index, offset, relative); }
		public void setUniformBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCompute_setUniformBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setUniformBuffers(uint index, Buffer[] buffers, ulong[] offsets) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCompute_setUniformBuffers_ucABcA(self, index, buffers_, (uint)buffers.Length, offsets, (uint)offsets.Length);
		}
		public IntPtr getStorageData(uint index, ulong size) { return tsCompute_getStorageData(self, index, size); }
		public void setStorageData(uint index, IntPtr src, ulong size) { tsCompute_setStorageData(self, index, src, size); }
		public void setStorageData<Type>(uint index, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setStorageData(index, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setStorageBuffer(uint index, Buffer buffer, ulong offset = 0, ulong size = 0) { tsCompute_setStorageBuffer(self, index, buffer.getSelf(), offset, size); }
		public void setStorageOffset(uint index, ulong offset, bool relative = false) { tsCompute_setStorageOffset(self, index, offset, relative); }
		public void setStorageBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCompute_setStorageBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setStorageBuffers(uint index, Buffer[] buffers, ulong[] offsets) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCompute_setStorageBuffers_ucABcA(self, index, buffers_, (uint)buffers.Length, offsets, (uint)offsets.Length);
		}
		public void setTracing(uint index, Tracing tracing) { tsCompute_setTracing(self, index, tracing.getSelf()); }
		public void setTracings(uint index, Tracing[] tracings) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			tsCompute_setTracings_ucAT(self, index, tracings_, (uint)tracings.Length);
		}
		public void setTexelBuffer(uint index, Buffer buffer) { tsCompute_setTexelBuffer(self, index, buffer.getSelf()); }
		public void setTexelBuffers(uint index, Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCompute_setTexelBuffers_ucAB(self, index, buffers_, (uint)buffers.Length);
		}
		public void setTextureTable(uint index, TextureTable table) { tsCompute_setTextureTable(self, index, table.getSelf()); }
		public void setTextureTables(uint index, TextureTable[] tables) {
			IntPtr[] tables_ = new IntPtr[tables.Length];
			for(int i = 0; i < tables.Length; i++) tables_[i] = tables[i].getSelfPtr();
			tsCompute_setTextureTables_ucATT(self, index, tables_, (uint)tables.Length);
		}
		public void setStorageTable(uint index, BufferTable table) { tsCompute_setStorageTable(self, index, table.getSelf()); }
		public void setStorageTables(uint index, BufferTable[] tables) {
			IntPtr[] tables_ = new IntPtr[tables.Length];
			for(int i = 0; i < tables.Length; i++) tables_[i] = tables[i].getSelfPtr();
			tsCompute_setStorageTables_ucABT(self, index, tables_, (uint)tables.Length);
		}
		public IntPtr getIndirectData(ulong size) { return tsCompute_getIndirectData(self, size); }
		public void setIndirectData(IntPtr src, ulong size) { tsCompute_setIndirectData(self, src, size); }
		public void setIndirectData<Type>(Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			setIndirectData(ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
		}
		public void setIndirectBuffer(Buffer buffer, ulong offset = 0) { tsCompute_setIndirectBuffer(self, buffer.getSelf(), offset); }
		public void setIndirectOffset(ulong offset, bool relative = false) { tsCompute_setIndirectOffset(self, offset, relative); }
		public void dispatch(uint width, uint height = 1, uint depth = 1) { tsCompute_dispatch_uuu(self, width, height, depth); }
		public void dispatch(Texture texture) { tsCompute_dispatch_cT(self, texture.getSelf()); }
		public void dispatch(in Size size) { tsCompute_dispatch_cS(self, in size); }
		public void dispatchIndirect() { tsCompute_dispatchIndirect(self); }
		public bool setBuffer(Buffer buffer, ulong offset, IntPtr src, ulong size) { return tsCompute_setBuffer_Bzpz(self, buffer.getSelf(), offset, src, size); }
		public bool setBuffer<Type>(Buffer buffer, ulong offset, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = setBuffer(buffer, offset, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool setBuffer(Buffer buffer, IntPtr src, ulong size) { return tsCompute_setBuffer_Bpz(self, buffer.getSelf(), src, size); }
		public bool setBuffer<Type>(Buffer buffer, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = setBuffer(buffer, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool setBuffer(Buffer buffer, IntPtr src) { return tsCompute_setBuffer_Bp(self, buffer.getSelf(), src); }
		public bool copyBuffer(Buffer buffer, ulong dest_offset, Buffer src, ulong src_offset, ulong size) { return tsCompute_copyBuffer_BzBzz(self, buffer.getSelf(), dest_offset, src.getSelf(), src_offset, size); }
		public bool copyBuffer(Buffer buffer, ulong dest_offset, Buffer src, ulong size) { return tsCompute_copyBuffer_BzBz(self, buffer.getSelf(), dest_offset, src.getSelf(), size); }
		public bool copyBuffer(Buffer buffer, Buffer src, ulong size) { return tsCompute_copyBuffer_BBz(self, buffer.getSelf(), src.getSelf(), size); }
		public bool copyBuffer(Buffer buffer, Buffer src) { return tsCompute_copyBuffer_BB(self, buffer.getSelf(), src.getSelf()); }
		public bool clearBuffer(Buffer buffer, Format format, ulong offset, IntPtr src, ulong size) { return tsCompute_clearBuffer_BFzpz(self, buffer.getSelf(), format, offset, src, size); }
		public bool clearBuffer<Type>(Buffer buffer, Format format, ulong offset, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = clearBuffer(buffer, format, offset, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool clearBuffer(Buffer buffer, Format format, IntPtr src, ulong size) { return tsCompute_clearBuffer_BFpz(self, buffer.getSelf(), format, src, size); }
		public bool clearBuffer<Type>(Buffer buffer, Format format, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = clearBuffer(buffer, format, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool clearBuffer(Buffer buffer, Format format, IntPtr src) { return tsCompute_clearBuffer_BFp(self, buffer.getSelf(), format, src); }
		public bool clearBuffer(Buffer buffer) { return tsCompute_clearBuffer_B(self, buffer.getSelf()); }
		public bool setTexture(Texture texture, in Origin dest_origin, in Slice dest_slice, Image image, in Slice src_slice) { return tsCompute_setTexture_TcOcScIcS(self, texture.getSelf(), in dest_origin, in dest_slice, image.getSelf(), in src_slice); }
		public bool setTexture(Texture texture, in Origin dest_origin, Image image) { return tsCompute_setTexture_TcOcI(self, texture.getSelf(), in dest_origin, image.getSelf()); }
		public bool setTexture(Texture texture, in Slice dest_slice, Image image) { return tsCompute_setTexture_TcScI(self, texture.getSelf(), in dest_slice, image.getSelf()); }
		public bool setTexture(Texture texture, Image image) { return tsCompute_setTexture_TcI(self, texture.getSelf(), image.getSelf()); }
		public bool copyTexture(Texture texture, in Origin dest_origin, in Slice dest_slice, Texture src, in Region src_region, in Slice src_slice) { return tsCompute_copyTexture_TcOcSTcRcS(self, texture.getSelf(), in dest_origin, in dest_slice, src.getSelf(), in src_region, in src_slice); }
		public bool copyTexture(Texture texture, in Origin dest_origin, Texture src, in Region src_region) { return tsCompute_copyTexture_TcOTcR(self, texture.getSelf(), in dest_origin, src.getSelf(), in src_region); }
		public bool copyTexture(Texture texture, in Slice dest_slice, Texture src, in Slice src_slice) { return tsCompute_copyTexture_TcSTcS(self, texture.getSelf(), in dest_slice, src.getSelf(), in src_slice); }
		public bool copyTexture(Texture texture, Texture src) { return tsCompute_copyTexture_TT(self, texture.getSelf(), src.getSelf()); }
		public bool clearTexture(Texture texture, in Region region, in Slice slice, IntPtr src) { return tsCompute_clearTexture_TcRcSp(self, texture.getSelf(), in region, in slice, src); }
		public bool clearTexture(Texture texture, in Region region, IntPtr src) { return tsCompute_clearTexture_TcRp(self, texture.getSelf(), in region, src); }
		public bool clearTexture(Texture texture, in Slice slice, IntPtr src) { return tsCompute_clearTexture_TcSp(self, texture.getSelf(), in slice, src); }
		public bool clearTexture(Texture texture, IntPtr src) { return tsCompute_clearTexture_Tp(self, texture.getSelf(), src); }
		public void barrier(Texture texture) { tsCompute_barrier_T(self, texture.getSelf()); }
		public void barrier(Buffer buffer) { tsCompute_barrier_B(self, buffer.getSelf()); }
		public void barrier(Texture[] textures) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			tsCompute_barrier_cAT(self, textures_, (uint)textures.Length);
		}
		public void barrier(Buffer[] buffers) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			tsCompute_barrier_cAB(self, buffers_, (uint)buffers.Length);
		}
		public void beginConditional(Buffer buffer, ulong offset) { tsCompute_beginConditional(self, buffer.getSelf(), offset); }
		public void endConditional() { tsCompute_endConditional(self); }
		public bool beginQuery(Query query) { return tsCompute_beginQuery(self, query.getSelf()); }
		public void endQuery(Query query) { tsCompute_endQuery(self, query.getSelf()); }
		public override string ToString() { return "Tellusim.Compute: Valid: " + tsCompute_isValidPtr(self) + "; Owner: " + tsCompute_isOwnerPtr(self) + "; Const: " + tsCompute_isConstPtr(self) + "; Count: " + tsCompute_getCountPtr(self) + "; Internal: 0x" + tsCompute_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Compute ptr) { return (ptr != null && tsCompute_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_new();
		[DllImport(Base.Import)] private static extern void tsCompute_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCompute_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCompute_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCompute_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCompute_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCompute_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsCompute_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCompute_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_setKernel(HandleRef self, HandleRef kernel);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getKernel(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_setTraversal(HandleRef self, HandleRef traversal);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getTraversal(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCompute_setSampler(HandleRef self, uint index, HandleRef sampler);
		[DllImport(Base.Import)] private static extern void tsCompute_setSamplers_ucAS(HandleRef self, uint index, IntPtr[] samplers, uint samplers_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setTexture_uT(HandleRef self, uint index, HandleRef texture);
		[DllImport(Base.Import)] private static extern void tsCompute_setTexture_uTcS(HandleRef self, uint index, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsCompute_setTextures_ucAT(HandleRef self, uint index, IntPtr[] textures, uint textures_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setSurfaceTexture_uT(HandleRef self, uint index, HandleRef texture);
		[DllImport(Base.Import)] private static extern void tsCompute_setSurfaceTexture_uTcSF(HandleRef self, uint index, HandleRef texture, in Slice slice, Format format);
		[DllImport(Base.Import)] private static extern void tsCompute_setSurfaceTextures_ucAT(HandleRef self, uint index, IntPtr[] textures, uint textures_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getUniformData(HandleRef self, uint index, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setUniformData(HandleRef self, uint index, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setUniformBuffer(HandleRef self, uint index, HandleRef buffer, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setUniformOffset(HandleRef self, uint index, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCompute_setUniformBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setUniformBuffers_ucABcA(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size, ulong[] offsets, uint offsets_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getStorageData(HandleRef self, uint index, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageData(HandleRef self, uint index, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageBuffer(HandleRef self, uint index, HandleRef buffer, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageOffset(HandleRef self, uint index, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageBuffers_ucABcA(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size, ulong[] offsets, uint offsets_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setTracing(HandleRef self, uint index, HandleRef tracing);
		[DllImport(Base.Import)] private static extern void tsCompute_setTracings_ucAT(HandleRef self, uint index, IntPtr[] tracings, uint tracings_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setTexelBuffer(HandleRef self, uint index, HandleRef buffer);
		[DllImport(Base.Import)] private static extern void tsCompute_setTexelBuffers_ucAB(HandleRef self, uint index, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setTextureTable(HandleRef self, uint index, HandleRef table);
		[DllImport(Base.Import)] private static extern void tsCompute_setTextureTables_ucATT(HandleRef self, uint index, IntPtr[] tables, uint tables_size);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageTable(HandleRef self, uint index, HandleRef table);
		[DllImport(Base.Import)] private static extern void tsCompute_setStorageTables_ucABT(HandleRef self, uint index, IntPtr[] tables, uint tables_size);
		[DllImport(Base.Import)] private static extern IntPtr tsCompute_getIndirectData(HandleRef self, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setIndirectData(HandleRef self, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern void tsCompute_setIndirectBuffer(HandleRef self, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsCompute_setIndirectOffset(HandleRef self, ulong offset, bool relative);
		[DllImport(Base.Import)] private static extern void tsCompute_dispatch_uuu(HandleRef self, uint width, uint height, uint depth);
		[DllImport(Base.Import)] private static extern void tsCompute_dispatch_cT(HandleRef self, HandleRef texture);
		[DllImport(Base.Import)] private static extern void tsCompute_dispatch_cS(HandleRef self, in Size size);
		[DllImport(Base.Import)] private static extern void tsCompute_dispatchIndirect(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCompute_setBuffer_Bzpz(HandleRef self, HandleRef buffer, ulong offset, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_setBuffer_Bpz(HandleRef self, HandleRef buffer, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_setBuffer_Bp(HandleRef self, HandleRef buffer, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyBuffer_BzBzz(HandleRef self, HandleRef buffer, ulong dest_offset, HandleRef src, ulong src_offset, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyBuffer_BzBz(HandleRef self, HandleRef buffer, ulong dest_offset, HandleRef src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyBuffer_BBz(HandleRef self, HandleRef buffer, HandleRef src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyBuffer_BB(HandleRef self, HandleRef buffer, HandleRef src);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearBuffer_BFzpz(HandleRef self, HandleRef buffer, Format format, ulong offset, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearBuffer_BFpz(HandleRef self, HandleRef buffer, Format format, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearBuffer_BFp(HandleRef self, HandleRef buffer, Format format, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearBuffer_B(HandleRef self, HandleRef buffer);
		[DllImport(Base.Import)] private static extern bool tsCompute_setTexture_TcOcScIcS(HandleRef self, HandleRef texture, in Origin dest_origin, in Slice dest_slice, HandleRef image, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsCompute_setTexture_TcOcI(HandleRef self, HandleRef texture, in Origin dest_origin, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsCompute_setTexture_TcScI(HandleRef self, HandleRef texture, in Slice dest_slice, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsCompute_setTexture_TcI(HandleRef self, HandleRef texture, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyTexture_TcOcSTcRcS(HandleRef self, HandleRef texture, in Origin dest_origin, in Slice dest_slice, HandleRef src, in Region src_region, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyTexture_TcOTcR(HandleRef self, HandleRef texture, in Origin dest_origin, HandleRef src, in Region src_region);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyTexture_TcSTcS(HandleRef self, HandleRef texture, in Slice dest_slice, HandleRef src, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsCompute_copyTexture_TT(HandleRef self, HandleRef texture, HandleRef src);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearTexture_TcRcSp(HandleRef self, HandleRef texture, in Region region, in Slice slice, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearTexture_TcRp(HandleRef self, HandleRef texture, in Region region, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearTexture_TcSp(HandleRef self, HandleRef texture, in Slice slice, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsCompute_clearTexture_Tp(HandleRef self, HandleRef texture, IntPtr src);
		[DllImport(Base.Import)] private static extern void tsCompute_barrier_T(HandleRef self, HandleRef texture);
		[DllImport(Base.Import)] private static extern void tsCompute_barrier_B(HandleRef self, HandleRef buffer);
		[DllImport(Base.Import)] private static extern void tsCompute_barrier_cAT(HandleRef self, IntPtr[] textures, uint textures_size);
		[DllImport(Base.Import)] private static extern void tsCompute_barrier_cAB(HandleRef self, IntPtr[] buffers, uint buffers_size);
		[DllImport(Base.Import)] private static extern void tsCompute_beginConditional(HandleRef self, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsCompute_endConditional(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCompute_beginQuery(HandleRef self, HandleRef query);
		[DllImport(Base.Import)] private static extern void tsCompute_endQuery(HandleRef self, HandleRef query);
		[StructLayout(LayoutKind.Sequential)] public struct DispatchIndirect {
			public uint group_width;
			public uint group_height;
			public uint group_depth;
			public uint padding;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("group_width: {0}\n", group_width);
				ret += System.String.Format("group_height: {0}\n", group_height);
				ret += System.String.Format("group_depth: {0}\n", group_depth);
				return ret;
			}
		}
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Compute
	public sealed class D3D12Compute : Compute {
		public D3D12Compute() { self = new HandleRef(this, tsD3D12Compute_new()); owner = true; }
		public D3D12Compute(D3D12Compute ptr) { self = new HandleRef(this, tsD3D12Compute_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Compute(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Compute_isOwnerPtr(self); }
		public D3D12Compute(Compute ptr) { self = new HandleRef(this, tsD3D12Compute_castComputePtr(ptr.getSelf())); }
		public Compute toCompute() { return new Compute(tsD3D12Compute_baseComputePtr(self)); }
		public static new D3D12Compute Null() { return new D3D12Compute(IntPtr.Zero); }
		public IntPtr getCommand() { return tsD3D12Compute_getCommand(self); }
		public void update() { tsD3D12Compute_update(self); }
		public override string ToString() { return "Tellusim.D3D12Compute: Valid: " + tsD3D12Compute_isValidPtr(self) + "; Owner: " + tsD3D12Compute_isOwnerPtr(self) + "; Const: " + tsD3D12Compute_isConstPtr(self) + "; Count: " + tsD3D12Compute_getCountPtr(self) + "; Internal: 0x" + tsD3D12Compute_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Compute ptr) { return (ptr != null && tsD3D12Compute_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Compute_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Compute_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Compute_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Compute_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Compute_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Compute_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Compute_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Compute_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Compute_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Compute_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Compute_equalComputePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_castComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_baseComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Compute_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Compute_update(HandleRef self);
	}
	
	// Tellusim::MTLCompute
	public sealed class MTLCompute : Compute {
		public MTLCompute() { self = new HandleRef(this, tsMTLCompute_new()); owner = true; }
		public MTLCompute(MTLCompute ptr) { self = new HandleRef(this, tsMTLCompute_copyPtr(ptr.getSelf())); owner = true; }
		public MTLCompute(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLCompute_isOwnerPtr(self); }
		public MTLCompute(Compute ptr) { self = new HandleRef(this, tsMTLCompute_castComputePtr(ptr.getSelf())); }
		public Compute toCompute() { return new Compute(tsMTLCompute_baseComputePtr(self)); }
		public static new MTLCompute Null() { return new MTLCompute(IntPtr.Zero); }
		public IntPtr getEncoder() { return tsMTLCompute_getEncoder(self); }
		public void flush(IntPtr encoder, bool enqueue = false) { tsMTLCompute_flush_prb(self, encoder, enqueue); }
		public void flush(bool create = false, bool enqueue = false) { tsMTLCompute_flush_bb(self, create, enqueue); }
		public void update() { tsMTLCompute_update(self); }
		public override string ToString() { return "Tellusim.MTLCompute: Valid: " + tsMTLCompute_isValidPtr(self) + "; Owner: " + tsMTLCompute_isOwnerPtr(self) + "; Const: " + tsMTLCompute_isConstPtr(self) + "; Count: " + tsMTLCompute_getCountPtr(self) + "; Internal: 0x" + tsMTLCompute_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLCompute ptr) { return (ptr != null && tsMTLCompute_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_new();
		[DllImport(Base.Import)] private static extern void tsMTLCompute_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCompute_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCompute_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCompute_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCompute_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLCompute_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLCompute_equalComputePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_castComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_baseComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLCompute_getEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_flush_prb(HandleRef self, IntPtr encoder, bool enqueue);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_flush_bb(HandleRef self, bool create, bool enqueue);
		[DllImport(Base.Import)] private static extern void tsMTLCompute_update(HandleRef self);
	}
	
	// Tellusim::VKCompute
	public sealed class VKCompute : Compute {
		public VKCompute() { self = new HandleRef(this, tsVKCompute_new()); owner = true; }
		public VKCompute(VKCompute ptr) { self = new HandleRef(this, tsVKCompute_copyPtr(ptr.getSelf())); owner = true; }
		public VKCompute(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKCompute_isOwnerPtr(self); }
		public VKCompute(Compute ptr) { self = new HandleRef(this, tsVKCompute_castComputePtr(ptr.getSelf())); }
		public Compute toCompute() { return new Compute(tsVKCompute_baseComputePtr(self)); }
		public static new VKCompute Null() { return new VKCompute(IntPtr.Zero); }
		public IntPtr getCommand() { return tsVKCompute_getCommand(self); }
		public IntPtr getSamplerDescriptor() { return tsVKCompute_getSamplerDescriptor(self); }
		public IntPtr getImageDescriptor() { return tsVKCompute_getImageDescriptor(self); }
		public IntPtr getBufferDescriptor() { return tsVKCompute_getBufferDescriptor(self); }
		public IntPtr getTracingDescriptor() { return tsVKCompute_getTracingDescriptor(self); }
		public IntPtr getTexelDescriptor() { return tsVKCompute_getTexelDescriptor(self); }
		public void update() { tsVKCompute_update(self); }
		public override string ToString() { return "Tellusim.VKCompute: Valid: " + tsVKCompute_isValidPtr(self) + "; Owner: " + tsVKCompute_isOwnerPtr(self) + "; Const: " + tsVKCompute_isConstPtr(self) + "; Count: " + tsVKCompute_getCountPtr(self) + "; Internal: 0x" + tsVKCompute_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKCompute ptr) { return (ptr != null && tsVKCompute_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_new();
		[DllImport(Base.Import)] private static extern void tsVKCompute_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCompute_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCompute_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCompute_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCompute_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCompute_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCompute_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCompute_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCompute_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKCompute_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKCompute_equalComputePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_castComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_baseComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getSamplerDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getImageDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getBufferDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getTracingDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKCompute_getTexelDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKCompute_update(HandleRef self);
	}
	
	// Tellusim::FUCompute
	public sealed class FUCompute : Compute {
		public FUCompute() { self = new HandleRef(this, tsFUCompute_new()); owner = true; }
		public FUCompute(Compute[] computes, bool owner = false) {
			IntPtr[] computes_ = new IntPtr[computes.Length];
			for(int i = 0; i < computes.Length; i++) computes_[i] = computes[i].getSelfPtr();
			self = new HandleRef(this, tsFUCompute_new_cACb(computes_, (uint)computes.Length, owner)); owner = true;
		}
		public FUCompute(FUCompute ptr) { self = new HandleRef(this, tsFUCompute_copyPtr(ptr.getSelf())); owner = true; }
		public FUCompute(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUCompute_isOwnerPtr(self); }
		public FUCompute(Compute ptr) { self = new HandleRef(this, tsFUCompute_castComputePtr(ptr.getSelf())); }
		public Compute toCompute() { return new Compute(tsFUCompute_baseComputePtr(self)); }
		public static new FUCompute Null() { return new FUCompute(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUCompute_setMask(self, mask); }
		public uint getMask() { return tsFUCompute_getMask(self); }
		public uint getNumComputes() { return tsFUCompute_getNumComputes(self); }
		public Compute getCompute(uint index) { return new Compute(tsFUCompute_getCompute_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUCompute: Valid: " + tsFUCompute_isValidPtr(self) + "; Owner: " + tsFUCompute_isOwnerPtr(self) + "; Const: " + tsFUCompute_isConstPtr(self) + "; Count: " + tsFUCompute_getCountPtr(self) + "; Internal: 0x" + tsFUCompute_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUCompute ptr) { return (ptr != null && tsFUCompute_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_new_cACb(IntPtr[] computes, uint computes_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUCompute_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCompute_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCompute_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCompute_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCompute_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCompute_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCompute_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCompute_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCompute_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUCompute_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUCompute_equalComputePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_castComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_baseComputePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUCompute_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUCompute_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUCompute_getNumComputes(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUCompute_getCompute_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Context
	public class Context {
		public Context() { self = new HandleRef(this, tsContext_new()); owner = true; }
		public Context(Platform platform, uint index = Base.Maxu32) { self = new HandleRef(this, tsContext_new_Pu(platform, index)); owner = true; }
		public Context(Context ptr) { self = new HandleRef(this, tsContext_copyPtr(ptr.getSelf())); owner = true; }
		public Context(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsContext_isOwnerPtr(self); }
		public static Context Null() { return new Context(IntPtr.Zero); }
		~Context() { if(owner) tsContext_delete(self); }
		public bool equalPtr(Context ptr) { return tsContext_equalPtr(self, ptr.getSelf()); }
		public Context clonePtr() { return new Context(tsContext_clonePtr(self)); }
		public void clearPtr() { tsContext_clearPtr(self); }
		public void destroyPtr() { tsContext_destroyPtr(self); }
		public void acquirePtr() { tsContext_acquirePtr(self); }
		public void unacquirePtr() { tsContext_unacquirePtr(self); }
		public bool isValidPtr() { return tsContext_isValidPtr(self); }
		public bool isOwnerPtr() { return tsContext_isOwnerPtr(self); }
		public bool isConstPtr() { return tsContext_isConstPtr(self); }
		public uint getCountPtr() { return tsContext_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsContext_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsContext_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsContext_getPlatformName(self)); }
		public uint getIndex() { return tsContext_getIndex(self); }
		public bool isCreated() { return tsContext_isCreated(self); }
		public bool create() { return tsContext_create(self); }
		public bool flush() { return tsContext_flush(self); }
		public bool finish() { return tsContext_finish(self); }
		public override string ToString() { return "Tellusim.Context: Valid: " + tsContext_isValidPtr(self) + "; Owner: " + tsContext_isOwnerPtr(self) + "; Const: " + tsContext_isConstPtr(self) + "; Count: " + tsContext_getCountPtr(self) + "; Internal: 0x" + tsContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Context ptr) { return (ptr != null && tsContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsContext_new();
		[DllImport(Base.Import)] private static extern IntPtr tsContext_new_Pu(Platform platform, uint index);
		[DllImport(Base.Import)] private static extern void tsContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsContext_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsContext_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsContext_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_create(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_flush(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsContext_finish(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Context
	public sealed class D3D12Context : Context {
		public D3D12Context() { self = new HandleRef(this, tsD3D12Context_new()); owner = true; }
		public D3D12Context(D3D12Context ptr) { self = new HandleRef(this, tsD3D12Context_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Context(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Context_isOwnerPtr(self); }
		public D3D12Context(Context ptr) { self = new HandleRef(this, tsD3D12Context_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsD3D12Context_baseContextPtr(self)); }
		public static new D3D12Context Null() { return new D3D12Context(IntPtr.Zero); }
		public bool create(IntPtr device, IntPtr queue) { return tsD3D12Context_create(self, device, queue); }
		public IntPtr getFactory() { return tsD3D12Context_getFactory(self); }
		public IntPtr getDevice() { return tsD3D12Context_getDevice(self); }
		public IntPtr getQueue() { return tsD3D12Context_getQueue(self); }
		public IntPtr getCommand() { return tsD3D12Context_getCommand(self); }
		public static IntPtr getProcAddress(string name) { return tsD3D12Context_getProcAddress(name); }
		public static bool error(uint result) { return tsD3D12Context_error(result); }
		public override string ToString() { return "Tellusim.D3D12Context: Valid: " + tsD3D12Context_isValidPtr(self) + "; Owner: " + tsD3D12Context_isOwnerPtr(self) + "; Const: " + tsD3D12Context_isConstPtr(self) + "; Count: " + tsD3D12Context_getCountPtr(self) + "; Internal: 0x" + tsD3D12Context_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Context ptr) { return (ptr != null && tsD3D12Context_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Context_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Context_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Context_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Context_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Context_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Context_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_create(HandleRef self, IntPtr device, IntPtr queue);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_getFactory(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Context_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsD3D12Context_error(uint result);
	}
	
	// Tellusim::D3D11Context
	public sealed class D3D11Context : Context {
		public D3D11Context() { self = new HandleRef(this, tsD3D11Context_new()); owner = true; }
		public D3D11Context(D3D11Context ptr) { self = new HandleRef(this, tsD3D11Context_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Context(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Context_isOwnerPtr(self); }
		public D3D11Context(Context ptr) { self = new HandleRef(this, tsD3D11Context_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsD3D11Context_baseContextPtr(self)); }
		public static new D3D11Context Null() { return new D3D11Context(IntPtr.Zero); }
		public bool create(IntPtr device) { return tsD3D11Context_create(self, device); }
		public IntPtr getFactory() { return tsD3D11Context_getFactory(self); }
		public IntPtr getDevice() { return tsD3D11Context_getDevice(self); }
		public IntPtr getD3D11Context() { return tsD3D11Context_getD3D11Context(self); }
		public static IntPtr getProcAddress(string name) { return tsD3D11Context_getProcAddress(name); }
		public static bool error(uint result) { return tsD3D11Context_error(result); }
		public override string ToString() { return "Tellusim.D3D11Context: Valid: " + tsD3D11Context_isValidPtr(self) + "; Owner: " + tsD3D11Context_isOwnerPtr(self) + "; Const: " + tsD3D11Context_isConstPtr(self) + "; Count: " + tsD3D11Context_getCountPtr(self) + "; Internal: 0x" + tsD3D11Context_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Context ptr) { return (ptr != null && tsD3D11Context_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_new();
		[DllImport(Base.Import)] private static extern void tsD3D11Context_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Context_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Context_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Context_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Context_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Context_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_create(HandleRef self, IntPtr device);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_getFactory(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_getD3D11Context(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Context_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsD3D11Context_error(uint result);
	}
	
	// Tellusim::MTLContext
	public sealed class MTLContext : Context {
		public MTLContext() { self = new HandleRef(this, tsMTLContext_new()); owner = true; }
		public MTLContext(MTLContext ptr) { self = new HandleRef(this, tsMTLContext_copyPtr(ptr.getSelf())); owner = true; }
		public MTLContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLContext_isOwnerPtr(self); }
		public MTLContext(Context ptr) { self = new HandleRef(this, tsMTLContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsMTLContext_baseContextPtr(self)); }
		public static new MTLContext Null() { return new MTLContext(IntPtr.Zero); }
		public bool create(IntPtr device, IntPtr queue) { return tsMTLContext_create(self, device, queue); }
		public IntPtr getDevice() { return tsMTLContext_getDevice(self); }
		public IntPtr getQueue() { return tsMTLContext_getQueue(self); }
		public IntPtr getCommand() { return tsMTLContext_getCommand(self); }
		public IntPtr getEncoder() { return tsMTLContext_getEncoder(self); }
		public IntPtr getRenderEncoder(IntPtr descriptor) { return tsMTLContext_getRenderEncoder(self, descriptor); }
		public IntPtr getComputeEncoder() { return tsMTLContext_getComputeEncoder(self); }
		public IntPtr getTracingEncoder() { return tsMTLContext_getTracingEncoder(self); }
		public IntPtr getBlitEncoder() { return tsMTLContext_getBlitEncoder(self); }
		public void endEncoder() { tsMTLContext_endEncoder(self); }
		public override string ToString() { return "Tellusim.MTLContext: Valid: " + tsMTLContext_isValidPtr(self) + "; Owner: " + tsMTLContext_isOwnerPtr(self) + "; Const: " + tsMTLContext_isConstPtr(self) + "; Count: " + tsMTLContext_getCountPtr(self) + "; Internal: 0x" + tsMTLContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLContext ptr) { return (ptr != null && tsMTLContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_new();
		[DllImport(Base.Import)] private static extern void tsMTLContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLContext_create(HandleRef self, IntPtr device, IntPtr queue);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getRenderEncoder(HandleRef self, IntPtr descriptor);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getComputeEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getTracingEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLContext_getBlitEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLContext_endEncoder(HandleRef self);
	}
	
	// Tellusim::VKContext
	public sealed class VKContext : Context {
		public VKContext() { self = new HandleRef(this, tsVKContext_new()); owner = true; }
		public VKContext(VKContext ptr) { self = new HandleRef(this, tsVKContext_copyPtr(ptr.getSelf())); owner = true; }
		public VKContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKContext_isOwnerPtr(self); }
		public VKContext(Context ptr) { self = new HandleRef(this, tsVKContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsVKContext_baseContextPtr(self)); }
		public static new VKContext Null() { return new VKContext(IntPtr.Zero); }
		public bool create(IntPtr instance, IntPtr func, IntPtr adapter, IntPtr device, uint family, uint index) { return tsVKContext_create(self, instance, func, adapter, device, family, index); }
		public IntPtr getInstance() { return tsVKContext_getInstance(self); }
		public IntPtr getAdapter() { return tsVKContext_getAdapter(self); }
		public IntPtr getDevice() { return tsVKContext_getDevice(self); }
		public IntPtr getQueue() { return tsVKContext_getQueue(self); }
		public IntPtr getCommand() { return tsVKContext_getCommand(self); }
		public uint getFamily() { return tsVKContext_getFamily(self); }
		public uint getNumQueues() { return tsVKContext_getNumQueues(self); }
		public uint getQueueFlags(uint index) { return tsVKContext_getQueueFlags(self, index); }
		public uint getQueueFamily(uint index) { return tsVKContext_getQueueFamily(self, index); }
		public static void addContextExtension(string name) { tsVKContext_addContextExtension(name); }
		public static void addAdapterExtension(string name) { tsVKContext_addAdapterExtension(name); }
		public static void addAdapterFeatures(IntPtr features) { tsVKContext_addAdapterFeatures(features); }
		public static IntPtr getInstanceProcAddress() { return tsVKContext_getInstanceProcAddress(); }
		public static IntPtr getDeviceProcAddress() { return tsVKContext_getDeviceProcAddress(); }
		public static IntPtr getProcAddress(string name) { return tsVKContext_getProcAddress(name); }
		public static bool error(uint result) { return tsVKContext_error(result); }
		public override string ToString() { return "Tellusim.VKContext: Valid: " + tsVKContext_isValidPtr(self) + "; Owner: " + tsVKContext_isOwnerPtr(self) + "; Const: " + tsVKContext_isConstPtr(self) + "; Count: " + tsVKContext_getCountPtr(self) + "; Internal: 0x" + tsVKContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKContext ptr) { return (ptr != null && tsVKContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_new();
		[DllImport(Base.Import)] private static extern void tsVKContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKContext_create(HandleRef self, IntPtr instance, IntPtr func, IntPtr adapter, IntPtr device, uint family, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getInstance(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getAdapter(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKContext_getFamily(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKContext_getNumQueues(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKContext_getQueueFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsVKContext_getQueueFamily(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsVKContext_addContextExtension(string name);
		[DllImport(Base.Import)] private static extern void tsVKContext_addAdapterExtension(string name);
		[DllImport(Base.Import)] private static extern void tsVKContext_addAdapterFeatures(IntPtr features);
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getInstanceProcAddress();
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getDeviceProcAddress();
		[DllImport(Base.Import)] private static extern IntPtr tsVKContext_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsVKContext_error(uint result);
	}
	
	// Tellusim::GLContext
	public sealed class GLContext : Context {
		public GLContext() { self = new HandleRef(this, tsGLContext_new()); owner = true; }
		public GLContext(GLContext ptr) { self = new HandleRef(this, tsGLContext_copyPtr(ptr.getSelf())); owner = true; }
		public GLContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLContext_isOwnerPtr(self); }
		public GLContext(Context ptr) { self = new HandleRef(this, tsGLContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsGLContext_baseContextPtr(self)); }
		public static new GLContext Null() { return new GLContext(IntPtr.Zero); }
		public bool create(IntPtr context) { return tsGLContext_create(self, context); }
		public IntPtr getGLDisplay() { return tsGLContext_getGLDisplay(self); }
		public IntPtr getGLVisual() { return tsGLContext_getGLVisual(self); }
		public IntPtr getGLConfig() { return tsGLContext_getGLConfig(self); }
		public IntPtr getGLSurface() { return tsGLContext_getGLSurface(self); }
		public IntPtr getGLContext() { return tsGLContext_getGLContext(self); }
		public static IntPtr getProcAddress(string name) { return tsGLContext_getProcAddress(name); }
		public static bool error(uint result) { return tsGLContext_error(result); }
		public static bool check() { return tsGLContext_check(); }
		public override string ToString() { return "Tellusim.GLContext: Valid: " + tsGLContext_isValidPtr(self) + "; Owner: " + tsGLContext_isOwnerPtr(self) + "; Const: " + tsGLContext_isConstPtr(self) + "; Count: " + tsGLContext_getCountPtr(self) + "; Internal: 0x" + tsGLContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLContext ptr) { return (ptr != null && tsGLContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_new();
		[DllImport(Base.Import)] private static extern void tsGLContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLContext_create(HandleRef self, IntPtr context);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getGLDisplay(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getGLVisual(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getGLConfig(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getGLSurface(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getGLContext(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLContext_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsGLContext_error(uint result);
		[DllImport(Base.Import)] private static extern bool tsGLContext_check();
	}
	
	// Tellusim::GLESContext
	public sealed class GLESContext : Context {
		public GLESContext() { self = new HandleRef(this, tsGLESContext_new()); owner = true; }
		public GLESContext(GLESContext ptr) { self = new HandleRef(this, tsGLESContext_copyPtr(ptr.getSelf())); owner = true; }
		public GLESContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLESContext_isOwnerPtr(self); }
		public GLESContext(Context ptr) { self = new HandleRef(this, tsGLESContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsGLESContext_baseContextPtr(self)); }
		public static new GLESContext Null() { return new GLESContext(IntPtr.Zero); }
		public bool create(IntPtr context) { return tsGLESContext_create(self, context); }
		public IntPtr getGLESDisplay() { return tsGLESContext_getGLESDisplay(self); }
		public IntPtr getGLESConfig() { return tsGLESContext_getGLESConfig(self); }
		public IntPtr getGLESContext() { return tsGLESContext_getGLESContext(self); }
		public static IntPtr getProcAddress(string name) { return tsGLESContext_getProcAddress(name); }
		public static bool error(uint result) { return tsGLESContext_error(result); }
		public static bool check() { return tsGLESContext_check(); }
		public override string ToString() { return "Tellusim.GLESContext: Valid: " + tsGLESContext_isValidPtr(self) + "; Owner: " + tsGLESContext_isOwnerPtr(self) + "; Const: " + tsGLESContext_isConstPtr(self) + "; Count: " + tsGLESContext_getCountPtr(self) + "; Internal: 0x" + tsGLESContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLESContext ptr) { return (ptr != null && tsGLESContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_new();
		[DllImport(Base.Import)] private static extern void tsGLESContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_create(HandleRef self, IntPtr context);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_getGLESDisplay(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_getGLESConfig(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_getGLESContext(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESContext_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_error(uint result);
		[DllImport(Base.Import)] private static extern bool tsGLESContext_check();
	}
	
	// Tellusim::WGContext
	public sealed class WGContext : Context {
		public WGContext() { self = new HandleRef(this, tsWGContext_new()); owner = true; }
		public WGContext(WGContext ptr) { self = new HandleRef(this, tsWGContext_copyPtr(ptr.getSelf())); owner = true; }
		public WGContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsWGContext_isOwnerPtr(self); }
		public WGContext(Context ptr) { self = new HandleRef(this, tsWGContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsWGContext_baseContextPtr(self)); }
		public static new WGContext Null() { return new WGContext(IntPtr.Zero); }
		public static bool open(IntPtr instance, IntPtr adapter, IntPtr device) { return tsWGContext_open(instance, adapter, device); }
		public bool create(IntPtr instance, IntPtr adapter, IntPtr device) { return tsWGContext_create(self, instance, adapter, device); }
		public IntPtr getInstance() { return tsWGContext_getInstance(self); }
		public IntPtr getAdapter() { return tsWGContext_getAdapter(self); }
		public IntPtr getDevice() { return tsWGContext_getDevice(self); }
		public override string ToString() { return "Tellusim.WGContext: Valid: " + tsWGContext_isValidPtr(self) + "; Owner: " + tsWGContext_isOwnerPtr(self) + "; Const: " + tsWGContext_isConstPtr(self) + "; Count: " + tsWGContext_getCountPtr(self) + "; Internal: 0x" + tsWGContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(WGContext ptr) { return (ptr != null && tsWGContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_new();
		[DllImport(Base.Import)] private static extern void tsWGContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWGContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWGContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWGContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWGContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWGContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWGContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWGContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWGContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWGContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWGContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWGContext_open(IntPtr instance, IntPtr adapter, IntPtr device);
		[DllImport(Base.Import)] private static extern bool tsWGContext_create(HandleRef self, IntPtr instance, IntPtr adapter, IntPtr device);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_getInstance(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_getAdapter(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWGContext_getDevice(HandleRef self);
	}
	
	// Tellusim::CUContext
	public sealed class CUContext : Context {
		public CUContext() { self = new HandleRef(this, tsCUContext_new()); owner = true; }
		public CUContext(CUContext ptr) { self = new HandleRef(this, tsCUContext_copyPtr(ptr.getSelf())); owner = true; }
		public CUContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCUContext_isOwnerPtr(self); }
		public CUContext(Context ptr) { self = new HandleRef(this, tsCUContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsCUContext_baseContextPtr(self)); }
		public static new CUContext Null() { return new CUContext(IntPtr.Zero); }
		public int getDevice() { return tsCUContext_getDevice(self); }
		public IntPtr getCUContext() { return tsCUContext_getCUContext(self); }
		public IntPtr getStream() { return tsCUContext_getStream(self); }
		public static IntPtr getProcAddress(string name) { return tsCUContext_getProcAddress(name); }
		public static bool error(uint result) { return tsCUContext_error(result); }
		public override string ToString() { return "Tellusim.CUContext: Valid: " + tsCUContext_isValidPtr(self) + "; Owner: " + tsCUContext_isOwnerPtr(self) + "; Const: " + tsCUContext_isConstPtr(self) + "; Count: " + tsCUContext_getCountPtr(self) + "; Internal: 0x" + tsCUContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CUContext ptr) { return (ptr != null && tsCUContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_new();
		[DllImport(Base.Import)] private static extern void tsCUContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsCUContext_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_getCUContext(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_getStream(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUContext_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsCUContext_error(uint result);
	}
	
	// Tellusim::HIPContext
	public sealed class HIPContext : Context {
		public HIPContext() { self = new HandleRef(this, tsHIPContext_new()); owner = true; }
		public HIPContext(HIPContext ptr) { self = new HandleRef(this, tsHIPContext_copyPtr(ptr.getSelf())); owner = true; }
		public HIPContext(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsHIPContext_isOwnerPtr(self); }
		public HIPContext(Context ptr) { self = new HandleRef(this, tsHIPContext_castContextPtr(ptr.getSelf())); }
		public Context toContext() { return new Context(tsHIPContext_baseContextPtr(self)); }
		public static new HIPContext Null() { return new HIPContext(IntPtr.Zero); }
		public int getDevice() { return tsHIPContext_getDevice(self); }
		public IntPtr getHIPContext() { return tsHIPContext_getHIPContext(self); }
		public IntPtr getStream() { return tsHIPContext_getStream(self); }
		public static IntPtr getProcAddress(string name) { return tsHIPContext_getProcAddress(name); }
		public static bool error(uint result) { return tsHIPContext_error(result); }
		public override string ToString() { return "Tellusim.HIPContext: Valid: " + tsHIPContext_isValidPtr(self) + "; Owner: " + tsHIPContext_isOwnerPtr(self) + "; Const: " + tsHIPContext_isConstPtr(self) + "; Count: " + tsHIPContext_getCountPtr(self) + "; Internal: 0x" + tsHIPContext_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(HIPContext ptr) { return (ptr != null && tsHIPContext_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_new();
		[DllImport(Base.Import)] private static extern void tsHIPContext_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPContext_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPContext_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPContext_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPContext_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPContext_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPContext_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPContext_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPContext_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPContext_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPContext_equalContextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_castContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_baseContextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsHIPContext_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_getHIPContext(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_getStream(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPContext_getProcAddress(string name);
		[DllImport(Base.Import)] private static extern bool tsHIPContext_error(uint result);
	}
	
	// Tellusim::Query
	public class Query {
		public enum Type : uint {
			Unknown = 0,
			Time,
			Clock,
			Samples,
			Samples1,
			Statistics,
			NumTypes,
		}
		public Query() { self = new HandleRef(this, tsQuery_new()); owner = true; }
		public Query(Query ptr) { self = new HandleRef(this, tsQuery_copyPtr(ptr.getSelf())); owner = true; }
		public Query(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsQuery_isOwnerPtr(self); }
		public static Query Null() { return new Query(IntPtr.Zero); }
		~Query() { if(owner) tsQuery_delete(self); }
		public bool equalPtr(Query ptr) { return tsQuery_equalPtr(self, ptr.getSelf()); }
		public Query clonePtr() { return new Query(tsQuery_clonePtr(self)); }
		public void clearPtr() { tsQuery_clearPtr(self); }
		public void destroyPtr() { tsQuery_destroyPtr(self); }
		public void acquirePtr() { tsQuery_acquirePtr(self); }
		public void unacquirePtr() { tsQuery_unacquirePtr(self); }
		public bool isValidPtr() { return tsQuery_isValidPtr(self); }
		public bool isOwnerPtr() { return tsQuery_isOwnerPtr(self); }
		public bool isConstPtr() { return tsQuery_isConstPtr(self); }
		public uint getCountPtr() { return tsQuery_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsQuery_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsQuery_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsQuery_getPlatformName(self)); }
		public uint getIndex() { return tsQuery_getIndex(self); }
		public void clear() { tsQuery_clear(self); }
		public bool isCreated() { return tsQuery_isCreated(self); }
		public bool isAvailable() { return tsQuery_isAvailable(self); }
		public bool isBegan() { return tsQuery_isBegan(self); }
		public bool isEnded() { return tsQuery_isEnded(self); }
		public bool create(Type type) { return tsQuery_create(self, type); }
		public Type getType() { return tsQuery_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsQuery_getTypeName_QT(type)); }
		public string getTypeName() { return Base.getCString(tsQuery_getTypeName_c(self)); }
		public ulong getTypeSize() { return tsQuery_getTypeSize(self); }
		public bool isTime() { return tsQuery_isTime(self); }
		public bool isClock() { return tsQuery_isClock(self); }
		public bool isSamples() { return tsQuery_isSamples(self); }
		public bool isSamples1() { return tsQuery_isSamples1(self); }
		public bool isStatistics() { return tsQuery_isStatistics(self); }
		public bool isTimeType() { return tsQuery_isTimeType(self); }
		public bool isSamplesType() { return tsQuery_isSamplesType(self); }
		public bool get(IntPtr dest, ulong size, bool wait = true) { return tsQuery_get(self, dest, size, wait); }
		public bool get<Type>(ref Type[] dest, bool wait = true) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			bool ret_ = get(ptr_, (ulong)size_, wait);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public ulong getTime(bool wait, ref byte status) { return tsQuery_getTime(self, wait, ref status); }
		public ulong getTime(bool wait) { byte status = 1; return tsQuery_getTime(self, wait, ref status); }
		public uint getSamples(bool wait, ref byte status) { return tsQuery_getSamples(self, wait, ref status); }
		public uint getSamples(bool wait) { byte status = 1; return tsQuery_getSamples(self, wait, ref status); }
		public Statistics getStatistics(bool wait = false) { Statistics statistics = new Statistics(); tsQuery_getStatistics_bQS(self, wait, ref statistics); return statistics; }
		public Statistics getStatistics(bool wait, ref bool status) { Statistics statistics = new Statistics(); status = tsQuery_getStatistics_bQS(self, wait, ref statistics); return statistics; }
		[DllImport(Base.Import)] private static extern bool tsQuery_getStatistics_bQS(HandleRef self, bool wait, ref Statistics statistics);
		public override string ToString() { return "Tellusim.Query: Valid: " + tsQuery_isValidPtr(self) + "; Owner: " + tsQuery_isOwnerPtr(self) + "; Const: " + tsQuery_isConstPtr(self) + "; Count: " + tsQuery_getCountPtr(self) + "; Internal: 0x" + tsQuery_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Query ptr) { return (ptr != null && tsQuery_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_new();
		[DllImport(Base.Import)] private static extern void tsQuery_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsQuery_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsQuery_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsQuery_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsQuery_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsQuery_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsQuery_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsQuery_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsQuery_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isAvailable(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isBegan(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isEnded(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_create(HandleRef self, Type type);
		[DllImport(Base.Import)] private static extern Type tsQuery_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_getTypeName_QT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsQuery_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsQuery_getTypeSize(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isTime(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isClock(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isSamples(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isSamples1(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isStatistics(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isTimeType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_isSamplesType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsQuery_get(HandleRef self, IntPtr dest, ulong size, bool wait);
		[DllImport(Base.Import)] private static extern ulong tsQuery_getTime(HandleRef self, bool wait, ref byte status);
		[DllImport(Base.Import)] private static extern uint tsQuery_getSamples(HandleRef self, bool wait, ref byte status);
		[StructLayout(LayoutKind.Sequential)] public struct Statistics {
			public ulong num_vertices;
			public ulong num_primitives;
			public ulong vertex_invocations;
			public ulong control_invocations;
			public ulong evaluate_invocations;
			public ulong geometry_invocations;
			public ulong geometry_primitives;
			public ulong fragment_invocations;
			public ulong compute_invocations;
			public ulong clipping_invocations;
			public ulong clipping_primitives;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("num_vertices: {0}\n", num_vertices);
				ret += System.String.Format("num_primitives: {0}\n", num_primitives);
				ret += System.String.Format("vertex_invocations: {0}\n", vertex_invocations);
				ret += System.String.Format("control_invocations: {0}\n", control_invocations);
				ret += System.String.Format("evaluate_invocations: {0}\n", evaluate_invocations);
				ret += System.String.Format("geometry_invocations: {0}\n", geometry_invocations);
				ret += System.String.Format("geometry_primitives: {0}\n", geometry_primitives);
				ret += System.String.Format("fragment_invocations: {0}\n", fragment_invocations);
				ret += System.String.Format("compute_invocations: {0}\n", compute_invocations);
				ret += System.String.Format("clipping_invocations: {0}\n", clipping_invocations);
				ret += System.String.Format("clipping_primitives: {0}", clipping_primitives);
				return ret;
			}
		}
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::FUQuery
	public sealed class FUQuery : Query {
		public FUQuery() { self = new HandleRef(this, tsFUQuery_new()); owner = true; }
		public FUQuery(Query[] queries, bool owner = false) {
			IntPtr[] queries_ = new IntPtr[queries.Length];
			for(int i = 0; i < queries.Length; i++) queries_[i] = queries[i].getSelfPtr();
			self = new HandleRef(this, tsFUQuery_new_cAQb(queries_, (uint)queries.Length, owner)); owner = true;
		}
		public FUQuery(FUQuery ptr) { self = new HandleRef(this, tsFUQuery_copyPtr(ptr.getSelf())); owner = true; }
		public FUQuery(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUQuery_isOwnerPtr(self); }
		public FUQuery(Query ptr) { self = new HandleRef(this, tsFUQuery_castQueryPtr(ptr.getSelf())); }
		public Query toQuery() { return new Query(tsFUQuery_baseQueryPtr(self)); }
		public static new FUQuery Null() { return new FUQuery(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUQuery_setMask(self, mask); }
		public uint getMask() { return tsFUQuery_getMask(self); }
		public uint getNumQueries() { return tsFUQuery_getNumQueries(self); }
		public Query getQuery(uint index) { return new Query(tsFUQuery_getQuery_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUQuery: Valid: " + tsFUQuery_isValidPtr(self) + "; Owner: " + tsFUQuery_isOwnerPtr(self) + "; Const: " + tsFUQuery_isConstPtr(self) + "; Count: " + tsFUQuery_getCountPtr(self) + "; Internal: 0x" + tsFUQuery_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUQuery ptr) { return (ptr != null && tsFUQuery_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_new_cAQb(IntPtr[] queries, uint queries_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUQuery_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUQuery_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUQuery_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUQuery_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUQuery_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUQuery_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUQuery_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUQuery_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUQuery_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUQuery_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUQuery_equalQueryPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_castQueryPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_baseQueryPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUQuery_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUQuery_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUQuery_getNumQueries(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUQuery_getQuery_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Fence
	public class Fence {
		public enum Flags : uint {
			None = 0,
			Semaphore = 1,
			Signaled = 2,
			Shared = 4,
			Extern = 8,
			Default = 0,
			Num = 4,
		}
		public Fence() { self = new HandleRef(this, tsFence_new()); owner = true; }
		public Fence(Fence ptr) { self = new HandleRef(this, tsFence_copyPtr(ptr.getSelf())); owner = true; }
		public Fence(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFence_isOwnerPtr(self); }
		public static Fence Null() { return new Fence(IntPtr.Zero); }
		~Fence() { if(owner) tsFence_delete(self); }
		public bool equalPtr(Fence ptr) { return tsFence_equalPtr(self, ptr.getSelf()); }
		public Fence clonePtr() { return new Fence(tsFence_clonePtr(self)); }
		public void clearPtr() { tsFence_clearPtr(self); }
		public void destroyPtr() { tsFence_destroyPtr(self); }
		public void acquirePtr() { tsFence_acquirePtr(self); }
		public void unacquirePtr() { tsFence_unacquirePtr(self); }
		public bool isValidPtr() { return tsFence_isValidPtr(self); }
		public bool isOwnerPtr() { return tsFence_isOwnerPtr(self); }
		public bool isConstPtr() { return tsFence_isConstPtr(self); }
		public uint getCountPtr() { return tsFence_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsFence_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsFence_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsFence_getPlatformName(self)); }
		public uint getIndex() { return tsFence_getIndex(self); }
		public void clear() { tsFence_clear(self); }
		public bool isCreated() { return tsFence_isCreated(self); }
		public bool create(Flags flags = Flags.Default) { return tsFence_create(self, flags); }
		public Flags getFlags() { return tsFence_getFlags(self); }
		public bool hasFlag(Flags flags) { return tsFence_hasFlag(self, flags); }
		public bool hasFlags(Flags flags) { return tsFence_hasFlags(self, flags); }
		public string getFlagsName() { return Base.getString(tsFence_getFlagsName(self)); }
		public string getDescription() { return Base.getString(tsFence_getDescription(self)); }
		public override string ToString() { return "Tellusim.Fence: Valid: " + tsFence_isValidPtr(self) + "; Owner: " + tsFence_isOwnerPtr(self) + "; Const: " + tsFence_isConstPtr(self) + "; Count: " + tsFence_getCountPtr(self) + "; Internal: 0x" + tsFence_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Fence ptr) { return (ptr != null && tsFence_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFence_new();
		[DllImport(Base.Import)] private static extern void tsFence_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFence_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFence_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFence_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFence_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFence_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFence_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFence_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFence_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsFence_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFence_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFence_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFence_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_create(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern Flags tsFence_getFlags(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFence_hasFlag(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsFence_hasFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsFence_getFlagsName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFence_getDescription(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::VKFence
	public sealed class VKFence : Fence {
		public VKFence() { self = new HandleRef(this, tsVKFence_new()); owner = true; }
		public VKFence(VKFence ptr) { self = new HandleRef(this, tsVKFence_copyPtr(ptr.getSelf())); owner = true; }
		public VKFence(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKFence_isOwnerPtr(self); }
		public VKFence(Fence ptr) { self = new HandleRef(this, tsVKFence_castFencePtr(ptr.getSelf())); }
		public Fence toFence() { return new Fence(tsVKFence_baseFencePtr(self)); }
		public static new VKFence Null() { return new VKFence(IntPtr.Zero); }
		public IntPtr getVKFence() { return tsVKFence_getVKFence(self); }
		public IntPtr getSemaphore() { return tsVKFence_getSemaphore(self); }
		public IntPtr getSharedHandle() { return tsVKFence_getSharedHandle(self); }
		public override string ToString() { return "Tellusim.VKFence: Valid: " + tsVKFence_isValidPtr(self) + "; Owner: " + tsVKFence_isOwnerPtr(self) + "; Const: " + tsVKFence_isConstPtr(self) + "; Count: " + tsVKFence_getCountPtr(self) + "; Internal: 0x" + tsVKFence_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKFence ptr) { return (ptr != null && tsVKFence_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_new();
		[DllImport(Base.Import)] private static extern void tsVKFence_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKFence_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKFence_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKFence_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKFence_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKFence_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKFence_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKFence_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKFence_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKFence_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKFence_equalFencePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_castFencePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_baseFencePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_getVKFence(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_getSemaphore(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKFence_getSharedHandle(HandleRef self);
	}
	
	// Tellusim::FUFence
	public sealed class FUFence : Fence {
		public FUFence() { self = new HandleRef(this, tsFUFence_new()); owner = true; }
		public FUFence(Fence[] fences, bool owner = false) {
			IntPtr[] fences_ = new IntPtr[fences.Length];
			for(int i = 0; i < fences.Length; i++) fences_[i] = fences[i].getSelfPtr();
			self = new HandleRef(this, tsFUFence_new_cAFb(fences_, (uint)fences.Length, owner)); owner = true;
		}
		public FUFence(FUFence ptr) { self = new HandleRef(this, tsFUFence_copyPtr(ptr.getSelf())); owner = true; }
		public FUFence(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUFence_isOwnerPtr(self); }
		public FUFence(Fence ptr) { self = new HandleRef(this, tsFUFence_castFencePtr(ptr.getSelf())); }
		public Fence toFence() { return new Fence(tsFUFence_baseFencePtr(self)); }
		public static new FUFence Null() { return new FUFence(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUFence_setMask(self, mask); }
		public uint getMask() { return tsFUFence_getMask(self); }
		public uint getNumFences() { return tsFUFence_getNumFences(self); }
		public Fence getFence(uint index) { return new Fence(tsFUFence_getFence_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUFence: Valid: " + tsFUFence_isValidPtr(self) + "; Owner: " + tsFUFence_isOwnerPtr(self) + "; Const: " + tsFUFence_isConstPtr(self) + "; Count: " + tsFUFence_getCountPtr(self) + "; Internal: 0x" + tsFUFence_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUFence ptr) { return (ptr != null && tsFUFence_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_new_cAFb(IntPtr[] fences, uint fences_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUFence_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUFence_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUFence_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUFence_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUFence_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUFence_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUFence_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUFence_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUFence_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUFence_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUFence_equalFencePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_castFencePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_baseFencePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUFence_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUFence_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUFence_getNumFences(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUFence_getFence_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Shader
	public class Shader {
		public enum Type : uint {
			Unknown = 0,
			Vertex,
			Control,
			Evaluate,
			Geometry,
			Fragment,
			Compute,
			Task,
			Mesh,
			RayGen,
			RayMiss,
			Closest,
			FirstHit,
			Intersection,
			Callable,
			NumTypes,
		}
		public enum Mask : uint {
			None = 0,
			Vertex = 2,
			Control = 4,
			Evaluate = 8,
			Geometry = 16,
			Fragment = 32,
			Compute = 64,
			Task = 128,
			Mesh = 256,
			RayGen = 512,
			RayMiss = 1024,
			Closest = 2048,
			FirstHit = 4096,
			Intersection = 8192,
			Callable = 16384,
			VertexFragment = 34,
			Graphics = 62,
			Tracing = 32256,
			All = 32766,
		}
		public Shader() { self = new HandleRef(this, tsShader_new()); owner = true; }
		public Shader(Shader ptr) { self = new HandleRef(this, tsShader_copyPtr(ptr.getSelf())); owner = true; }
		public Shader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsShader_isOwnerPtr(self); }
		public static Shader Null() { return new Shader(IntPtr.Zero); }
		~Shader() { if(owner) tsShader_delete(self); }
		public bool equalPtr(Shader ptr) { return tsShader_equalPtr(self, ptr.getSelf()); }
		public Shader clonePtr() { return new Shader(tsShader_clonePtr(self)); }
		public void clearPtr() { tsShader_clearPtr(self); }
		public void destroyPtr() { tsShader_destroyPtr(self); }
		public void acquirePtr() { tsShader_acquirePtr(self); }
		public void unacquirePtr() { tsShader_unacquirePtr(self); }
		public bool isValidPtr() { return tsShader_isValidPtr(self); }
		public bool isOwnerPtr() { return tsShader_isOwnerPtr(self); }
		public bool isConstPtr() { return tsShader_isConstPtr(self); }
		public uint getCountPtr() { return tsShader_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsShader_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsShader_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsShader_getPlatformName(self)); }
		public uint getIndex() { return tsShader_getIndex(self); }
		public void clear() { tsShader_clear(self); }
		public bool isCreated() { return tsShader_isCreated(self); }
		public bool saveState(Stream stream) { return tsShader_saveState(self, stream.getSelf()); }
		public Type getType() { return tsShader_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsShader_getTypeName_ST(type)); }
		public string getTypeName() { return Base.getCString(tsShader_getTypeName_c(self)); }
		public bool isVertex() { return tsShader_isVertex(self); }
		public bool isControl() { return tsShader_isControl(self); }
		public bool isEvaluate() { return tsShader_isEvaluate(self); }
		public bool isGeometry() { return tsShader_isGeometry(self); }
		public bool isFragment() { return tsShader_isFragment(self); }
		public bool isCompute() { return tsShader_isCompute(self); }
		public bool isTask() { return tsShader_isTask(self); }
		public bool isMesh() { return tsShader_isMesh(self); }
		public bool isRayGen() { return tsShader_isRayGen(self); }
		public bool isRayMiss() { return tsShader_isRayMiss(self); }
		public bool isClosest() { return tsShader_isClosest(self); }
		public bool isFirstHit() { return tsShader_isFirstHit(self); }
		public bool isIntersection() { return tsShader_isIntersection(self); }
		public bool isCallable() { return tsShader_isCallable(self); }
		public bool isGraphicsType() { return tsShader_isGraphicsType(self); }
		public bool isTessellationType() { return tsShader_isTessellationType(self); }
		public bool isTracingType() { return tsShader_isTracingType(self); }
		public bool isMeshType() { return tsShader_isMeshType(self); }
		public string getName() { return Base.getString(tsShader_getName(self)); }
		public string getMacros() { return Base.getString(tsShader_getMacros(self)); }
		public void setSamplerOffset(int offset) { tsShader_setSamplerOffset(self, offset); }
		public int getSamplerOffset() { return tsShader_getSamplerOffset(self); }
		public void setTextureOffset(int offset) { tsShader_setTextureOffset(self, offset); }
		public int getTextureOffset() { return tsShader_getTextureOffset(self); }
		public void setSurfaceOffset(int offset) { tsShader_setSurfaceOffset(self, offset); }
		public int getSurfaceOffset() { return tsShader_getSurfaceOffset(self); }
		public void setUniformOffset(int offset) { tsShader_setUniformOffset(self, offset); }
		public int getUniformOffset() { return tsShader_getUniformOffset(self); }
		public void setStorageOffset(int offset) { tsShader_setStorageOffset(self, offset); }
		public int getStorageOffset() { return tsShader_getStorageOffset(self); }
		public void setTracingOffset(int offset) { tsShader_setTracingOffset(self, offset); }
		public int getTracingOffset() { return tsShader_getTracingOffset(self); }
		public void setTexelOffset(int offset) { tsShader_setTexelOffset(self, offset); }
		public int getTexelOffset() { return tsShader_getTexelOffset(self); }
		public void setTableOffset(int offset) { tsShader_setTableOffset(self, offset); }
		public int getTableOffset() { return tsShader_getTableOffset(self); }
		public void setPatchSize(uint size) { tsShader_setPatchSize(self, size); }
		public uint getPatchSize() { return tsShader_getPatchSize(self); }
		public void setInputSize(uint size) { tsShader_setInputSize(self, size); }
		public uint getInputSize() { return tsShader_getInputSize(self); }
		public void setOutputSize(uint size) { tsShader_setOutputSize(self, size); }
		public uint getOutputSize() { return tsShader_getOutputSize(self); }
		public bool load(Type type, string name, string format, params object[] args) { return tsShader_load_STss(self, type, name, System.String.Format(format, args)); }
		public bool create(Type type, string src, string format) { return tsShader_create_STss(self, type, src, format); }
		public bool load(Type type, string name, String macros = null, string[] includes = null) { return tsShader_load_STscSspu(self, type, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool create(Type type, string src, String macros = null, string[] includes = null) { return tsShader_create_STscSspu(self, type, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadGLSL(Type type, string name, string format, params object[] args) { return tsShader_loadGLSL_STss(self, type, name, System.String.Format(format, args)); }
		public bool createGLSL(Type type, string src, string format) { return tsShader_createGLSL_STss(self, type, src, format); }
		public bool loadGLSL(Type type, string name, String macros = null, string[] includes = null) { return tsShader_loadGLSL_STscSspu(self, type, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createGLSL(Type type, string src, String macros = null, string[] includes = null) { return tsShader_createGLSL_STscSspu(self, type, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadSPIRV(Type type, string name) { return tsShader_loadSPIRV(self, type, name); }
		public bool createSPIRV(Type type, uint[] data) { return tsShader_createSPIRV(self, type, data, (uint)data.Length); }
		public static bool hasCache() { return tsShader_hasCache(); }
		public static bool setCache(string name) { return tsShader_setCache(name); }
		public static bool loadCache(String hash, Stream stream) { return tsShader_loadCache(hash.getSelf(), stream.getSelf()); }
		public static bool saveCache(String hash, Stream stream) { return tsShader_saveCache(hash.getSelf(), stream.getSelf()); }
		public static void clearCache() { tsShader_clearCache(); }
		public static bool isMacro(string name) { return tsShader_isMacro(name); }
		public static bool setMacro(string name, int value) { return tsShader_setMacro_si(name, value); }
		public static bool setMacro(string name, uint value) { return tsShader_setMacro_su(name, value); }
		public static bool setMacro(string name, string value = "") { return tsShader_setMacro_ss(name, value); }
		public static bool setMacros(string macros) { return tsShader_setMacros(macros); }
		public static bool removeMacro(string name) { return tsShader_removeMacro(name); }
		public static void clearMacros() { tsShader_clearMacros(); }
		public static bool isInclude(string name) { return tsShader_isInclude(name); }
		public static bool setInclude(string name, String src) { return tsShader_setInclude(name, src.getSelf()); }
		public static bool removeInclude(string name) { return tsShader_removeInclude(name); }
		public static void clearIncludes() { tsShader_clearIncludes(); }
		public static string preprocessor(string src, string format) { return Base.getString(tsShader_preprocessor_ss(src, format)); }
		public static string preprocessor(string src, String macros = null, string[] includes = null) { return Base.getString(tsShader_preprocessor_scSspu(src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0)); }
		public override string ToString() { return "Tellusim.Shader: Valid: " + tsShader_isValidPtr(self) + "; Owner: " + tsShader_isOwnerPtr(self) + "; Const: " + tsShader_isConstPtr(self) + "; Count: " + tsShader_getCountPtr(self) + "; Internal: 0x" + tsShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Shader ptr) { return (ptr != null && tsShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsShader_new();
		[DllImport(Base.Import)] private static extern void tsShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsShader_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsShader_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_saveState(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern Type tsShader_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_getTypeName_ST(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isVertex(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isEvaluate(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isGeometry(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isFragment(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isCompute(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isTask(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isMesh(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isRayGen(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isRayMiss(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isClosest(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isFirstHit(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isIntersection(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isCallable(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isGraphicsType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isTessellationType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isTracingType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_isMeshType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_getMacros(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setSamplerOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getSamplerOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setTextureOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getTextureOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setSurfaceOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getSurfaceOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setUniformOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getUniformOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setStorageOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getStorageOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setTracingOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getTracingOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setTexelOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getTexelOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setTableOffset(HandleRef self, int offset);
		[DllImport(Base.Import)] private static extern int tsShader_getTableOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setPatchSize(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern uint tsShader_getPatchSize(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setInputSize(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern uint tsShader_getInputSize(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShader_setOutputSize(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern uint tsShader_getOutputSize(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShader_load_STss(HandleRef self, Type type, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsShader_create_STss(HandleRef self, Type type, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsShader_load_STscSspu(HandleRef self, Type type, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsShader_create_STscSspu(HandleRef self, Type type, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsShader_loadGLSL_STss(HandleRef self, Type type, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsShader_createGLSL_STss(HandleRef self, Type type, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsShader_loadGLSL_STscSspu(HandleRef self, Type type, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsShader_createGLSL_STscSspu(HandleRef self, Type type, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsShader_loadSPIRV(HandleRef self, Type type, string name);
		[DllImport(Base.Import)] private static extern bool tsShader_createSPIRV(HandleRef self, Type type, uint[] data, uint data_size);
		[DllImport(Base.Import)] private static extern bool tsShader_hasCache();
		[DllImport(Base.Import)] private static extern bool tsShader_setCache(string name);
		[DllImport(Base.Import)] private static extern bool tsShader_loadCache(HandleRef hash, HandleRef stream);
		[DllImport(Base.Import)] private static extern bool tsShader_saveCache(HandleRef hash, HandleRef stream);
		[DllImport(Base.Import)] private static extern void tsShader_clearCache();
		[DllImport(Base.Import)] private static extern bool tsShader_isMacro(string name);
		[DllImport(Base.Import)] private static extern bool tsShader_setMacro_si(string name, int value);
		[DllImport(Base.Import)] private static extern bool tsShader_setMacro_su(string name, uint value);
		[DllImport(Base.Import)] private static extern bool tsShader_setMacro_ss(string name, string value);
		[DllImport(Base.Import)] private static extern bool tsShader_setMacros(string macros);
		[DllImport(Base.Import)] private static extern bool tsShader_removeMacro(string name);
		[DllImport(Base.Import)] private static extern void tsShader_clearMacros();
		[DllImport(Base.Import)] private static extern bool tsShader_isInclude(string name);
		[DllImport(Base.Import)] private static extern bool tsShader_setInclude(string name, HandleRef src);
		[DllImport(Base.Import)] private static extern bool tsShader_removeInclude(string name);
		[DllImport(Base.Import)] private static extern void tsShader_clearIncludes();
		[DllImport(Base.Import)] private static extern IntPtr tsShader_preprocessor_ss(string src, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsShader_preprocessor_scSspu(string src, HandleRef macros, string[] includes, uint size);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::ShaderCompiler
	public sealed class ShaderCompiler : Shader {
		public enum Flags : uint {
			None = 0,
			MSLIndirect = 1,
		}
		public ShaderCompiler() { self = new HandleRef(this, tsShaderCompiler_new()); owner = true; }
		public ShaderCompiler(ShaderCompiler ptr) { self = new HandleRef(this, tsShaderCompiler_copyPtr(ptr.getSelf())); owner = true; }
		public ShaderCompiler(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsShaderCompiler_isOwnerPtr(self); }
		public ShaderCompiler(Shader ptr) { self = new HandleRef(this, tsShaderCompiler_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsShaderCompiler_baseShaderPtr(self)); }
		public static new ShaderCompiler Null() { return new ShaderCompiler(IntPtr.Zero); }
		public void setFlags(Flags flags) { tsShaderCompiler_setFlags(self, flags); }
		public Flags getFlags() { return tsShaderCompiler_getFlags(self); }
		public bool getBinary(Stream stream, Platform platform = Platform.Unknown) { return tsShaderCompiler_getBinary(self, stream.getSelf(), platform); }
		public string getSource(Platform platform = Platform.Unknown) { return Base.getString(tsShaderCompiler_getSource(self, platform)); }
		public override string ToString() { return "Tellusim.ShaderCompiler: Valid: " + tsShaderCompiler_isValidPtr(self) + "; Owner: " + tsShaderCompiler_isOwnerPtr(self) + "; Const: " + tsShaderCompiler_isConstPtr(self) + "; Count: " + tsShaderCompiler_getCountPtr(self) + "; Internal: 0x" + tsShaderCompiler_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ShaderCompiler ptr) { return (ptr != null && tsShaderCompiler_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_new();
		[DllImport(Base.Import)] private static extern void tsShaderCompiler_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShaderCompiler_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShaderCompiler_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShaderCompiler_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShaderCompiler_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShaderCompiler_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShaderCompiler_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShaderCompiler_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShaderCompiler_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsShaderCompiler_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShaderCompiler_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsShaderCompiler_setFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern Flags tsShaderCompiler_getFlags(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsShaderCompiler_getBinary(HandleRef self, HandleRef stream, Platform platform);
		[DllImport(Base.Import)] private static extern IntPtr tsShaderCompiler_getSource(HandleRef self, Platform platform);
	}
	
	// Tellusim::D3D12Shader
	public sealed class D3D12Shader : Shader {
		public D3D12Shader() { self = new HandleRef(this, tsD3D12Shader_new()); owner = true; }
		public D3D12Shader(D3D12Shader ptr) { self = new HandleRef(this, tsD3D12Shader_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Shader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Shader_isOwnerPtr(self); }
		public D3D12Shader(Shader ptr) { self = new HandleRef(this, tsD3D12Shader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsD3D12Shader_baseShaderPtr(self)); }
		public static new D3D12Shader Null() { return new D3D12Shader(IntPtr.Zero); }
		public IntPtr getShaderBlob() { return tsD3D12Shader_getShaderBlob(self); }
		public override string ToString() { return "Tellusim.D3D12Shader: Valid: " + tsD3D12Shader_isValidPtr(self) + "; Owner: " + tsD3D12Shader_isOwnerPtr(self) + "; Const: " + tsD3D12Shader_isConstPtr(self) + "; Count: " + tsD3D12Shader_getCountPtr(self) + "; Internal: 0x" + tsD3D12Shader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Shader ptr) { return (ptr != null && tsD3D12Shader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Shader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Shader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Shader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Shader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Shader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Shader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Shader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Shader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Shader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Shader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Shader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Shader_getShaderBlob(HandleRef self);
	}
	
	// Tellusim::D3D11Shader
	public sealed class D3D11Shader : Shader {
		public D3D11Shader() { self = new HandleRef(this, tsD3D11Shader_new()); owner = true; }
		public D3D11Shader(D3D11Shader ptr) { self = new HandleRef(this, tsD3D11Shader_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Shader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Shader_isOwnerPtr(self); }
		public D3D11Shader(Shader ptr) { self = new HandleRef(this, tsD3D11Shader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsD3D11Shader_baseShaderPtr(self)); }
		public static new D3D11Shader Null() { return new D3D11Shader(IntPtr.Zero); }
		public IntPtr getD3D11Shader() { return tsD3D11Shader_getD3D11Shader(self); }
		public IntPtr getShaderBlob() { return tsD3D11Shader_getShaderBlob(self); }
		public override string ToString() { return "Tellusim.D3D11Shader: Valid: " + tsD3D11Shader_isValidPtr(self) + "; Owner: " + tsD3D11Shader_isOwnerPtr(self) + "; Const: " + tsD3D11Shader_isConstPtr(self) + "; Count: " + tsD3D11Shader_getCountPtr(self) + "; Internal: 0x" + tsD3D11Shader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Shader ptr) { return (ptr != null && tsD3D11Shader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_new();
		[DllImport(Base.Import)] private static extern void tsD3D11Shader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Shader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Shader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Shader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Shader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Shader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Shader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Shader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Shader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Shader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Shader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_getD3D11Shader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Shader_getShaderBlob(HandleRef self);
	}
	
	// Tellusim::MTLShader
	public sealed class MTLShader : Shader {
		public MTLShader() { self = new HandleRef(this, tsMTLShader_new()); owner = true; }
		public MTLShader(MTLShader ptr) { self = new HandleRef(this, tsMTLShader_copyPtr(ptr.getSelf())); owner = true; }
		public MTLShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLShader_isOwnerPtr(self); }
		public MTLShader(Shader ptr) { self = new HandleRef(this, tsMTLShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsMTLShader_baseShaderPtr(self)); }
		public static new MTLShader Null() { return new MTLShader(IntPtr.Zero); }
		public void setIndirect(bool enabled) { tsMTLShader_setIndirect(self, enabled); }
		public bool isIndirect() { return tsMTLShader_isIndirect(self); }
		public IntPtr getLibrary() { return tsMTLShader_getLibrary(self); }
		public IntPtr getFunction() { return tsMTLShader_getFunction(self); }
		public override string ToString() { return "Tellusim.MTLShader: Valid: " + tsMTLShader_isValidPtr(self) + "; Owner: " + tsMTLShader_isOwnerPtr(self) + "; Const: " + tsMTLShader_isConstPtr(self) + "; Count: " + tsMTLShader_getCountPtr(self) + "; Internal: 0x" + tsMTLShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLShader ptr) { return (ptr != null && tsMTLShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_new();
		[DllImport(Base.Import)] private static extern void tsMTLShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLShader_setIndirect(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsMTLShader_isIndirect(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_getLibrary(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLShader_getFunction(HandleRef self);
	}
	
	// Tellusim::VKShader
	public sealed class VKShader : Shader {
		public VKShader() { self = new HandleRef(this, tsVKShader_new()); owner = true; }
		public VKShader(VKShader ptr) { self = new HandleRef(this, tsVKShader_copyPtr(ptr.getSelf())); owner = true; }
		public VKShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKShader_isOwnerPtr(self); }
		public VKShader(Shader ptr) { self = new HandleRef(this, tsVKShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsVKShader_baseShaderPtr(self)); }
		public static new VKShader Null() { return new VKShader(IntPtr.Zero); }
		public IntPtr getModule() { return tsVKShader_getModule(self); }
		public override string ToString() { return "Tellusim.VKShader: Valid: " + tsVKShader_isValidPtr(self) + "; Owner: " + tsVKShader_isOwnerPtr(self) + "; Const: " + tsVKShader_isConstPtr(self) + "; Count: " + tsVKShader_getCountPtr(self) + "; Internal: 0x" + tsVKShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKShader ptr) { return (ptr != null && tsVKShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_new();
		[DllImport(Base.Import)] private static extern void tsVKShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKShader_getModule(HandleRef self);
	}
	
	// Tellusim::GLShader
	public sealed class GLShader : Shader {
		public GLShader() { self = new HandleRef(this, tsGLShader_new()); owner = true; }
		public GLShader(GLShader ptr) { self = new HandleRef(this, tsGLShader_copyPtr(ptr.getSelf())); owner = true; }
		public GLShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLShader_isOwnerPtr(self); }
		public GLShader(Shader ptr) { self = new HandleRef(this, tsGLShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsGLShader_baseShaderPtr(self)); }
		public static new GLShader Null() { return new GLShader(IntPtr.Zero); }
		public bool attachShader(uint program_id) { return tsGLShader_attachShader(self, program_id); }
		public uint getShaderType() { return tsGLShader_getShaderType(self); }
		public uint getShaderID() { return tsGLShader_getShaderID(self); }
		public override string ToString() { return "Tellusim.GLShader: Valid: " + tsGLShader_isValidPtr(self) + "; Owner: " + tsGLShader_isOwnerPtr(self) + "; Const: " + tsGLShader_isConstPtr(self) + "; Count: " + tsGLShader_getCountPtr(self) + "; Internal: 0x" + tsGLShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLShader ptr) { return (ptr != null && tsGLShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLShader_new();
		[DllImport(Base.Import)] private static extern void tsGLShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLShader_attachShader(HandleRef self, uint program_id);
		[DllImport(Base.Import)] private static extern uint tsGLShader_getShaderType(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLShader_getShaderID(HandleRef self);
	}
	
	// Tellusim::GLESShader
	public sealed class GLESShader : Shader {
		public GLESShader() { self = new HandleRef(this, tsGLESShader_new()); owner = true; }
		public GLESShader(GLESShader ptr) { self = new HandleRef(this, tsGLESShader_copyPtr(ptr.getSelf())); owner = true; }
		public GLESShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLESShader_isOwnerPtr(self); }
		public GLESShader(Shader ptr) { self = new HandleRef(this, tsGLESShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsGLESShader_baseShaderPtr(self)); }
		public static new GLESShader Null() { return new GLESShader(IntPtr.Zero); }
		public bool attachShader(uint program_id) { return tsGLESShader_attachShader(self, program_id); }
		public uint getShaderType() { return tsGLESShader_getShaderType(self); }
		public uint getShaderID() { return tsGLESShader_getShaderID(self); }
		public override string ToString() { return "Tellusim.GLESShader: Valid: " + tsGLESShader_isValidPtr(self) + "; Owner: " + tsGLESShader_isOwnerPtr(self) + "; Const: " + tsGLESShader_isConstPtr(self) + "; Count: " + tsGLESShader_getCountPtr(self) + "; Internal: 0x" + tsGLESShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLESShader ptr) { return (ptr != null && tsGLESShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLESShader_new();
		[DllImport(Base.Import)] private static extern void tsGLESShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESShader_attachShader(HandleRef self, uint program_id);
		[DllImport(Base.Import)] private static extern uint tsGLESShader_getShaderType(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESShader_getShaderID(HandleRef self);
	}
	
	// Tellusim::CUShader
	public sealed class CUShader : Shader {
		public CUShader() { self = new HandleRef(this, tsCUShader_new()); owner = true; }
		public CUShader(CUShader ptr) { self = new HandleRef(this, tsCUShader_copyPtr(ptr.getSelf())); owner = true; }
		public CUShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCUShader_isOwnerPtr(self); }
		public CUShader(Shader ptr) { self = new HandleRef(this, tsCUShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsCUShader_baseShaderPtr(self)); }
		public static new CUShader Null() { return new CUShader(IntPtr.Zero); }
		public IntPtr getModule() { return tsCUShader_getModule(self); }
		public IntPtr getFunction() { return tsCUShader_getFunction(self); }
		public override string ToString() { return "Tellusim.CUShader: Valid: " + tsCUShader_isValidPtr(self) + "; Owner: " + tsCUShader_isOwnerPtr(self) + "; Const: " + tsCUShader_isConstPtr(self) + "; Count: " + tsCUShader_getCountPtr(self) + "; Internal: 0x" + tsCUShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CUShader ptr) { return (ptr != null && tsCUShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_new();
		[DllImport(Base.Import)] private static extern void tsCUShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_getModule(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUShader_getFunction(HandleRef self);
	}
	
	// Tellusim::HIPShader
	public sealed class HIPShader : Shader {
		public HIPShader() { self = new HandleRef(this, tsHIPShader_new()); owner = true; }
		public HIPShader(HIPShader ptr) { self = new HandleRef(this, tsHIPShader_copyPtr(ptr.getSelf())); owner = true; }
		public HIPShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsHIPShader_isOwnerPtr(self); }
		public HIPShader(Shader ptr) { self = new HandleRef(this, tsHIPShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsHIPShader_baseShaderPtr(self)); }
		public static new HIPShader Null() { return new HIPShader(IntPtr.Zero); }
		public IntPtr getModule() { return tsHIPShader_getModule(self); }
		public IntPtr getFunction() { return tsHIPShader_getFunction(self); }
		public override string ToString() { return "Tellusim.HIPShader: Valid: " + tsHIPShader_isValidPtr(self) + "; Owner: " + tsHIPShader_isOwnerPtr(self) + "; Const: " + tsHIPShader_isConstPtr(self) + "; Count: " + tsHIPShader_getCountPtr(self) + "; Internal: 0x" + tsHIPShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(HIPShader ptr) { return (ptr != null && tsHIPShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_new();
		[DllImport(Base.Import)] private static extern void tsHIPShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_getModule(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPShader_getFunction(HandleRef self);
	}
	
	// Tellusim::FUShader
	public sealed class FUShader : Shader {
		public FUShader() { self = new HandleRef(this, tsFUShader_new()); owner = true; }
		public FUShader(Shader[] shaders, bool owner = false) {
			IntPtr[] shaders_ = new IntPtr[shaders.Length];
			for(int i = 0; i < shaders.Length; i++) shaders_[i] = shaders[i].getSelfPtr();
			self = new HandleRef(this, tsFUShader_new_cASb(shaders_, (uint)shaders.Length, owner)); owner = true;
		}
		public FUShader(FUShader ptr) { self = new HandleRef(this, tsFUShader_copyPtr(ptr.getSelf())); owner = true; }
		public FUShader(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUShader_isOwnerPtr(self); }
		public FUShader(Shader ptr) { self = new HandleRef(this, tsFUShader_castShaderPtr(ptr.getSelf())); }
		public Shader toShader() { return new Shader(tsFUShader_baseShaderPtr(self)); }
		public static new FUShader Null() { return new FUShader(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUShader_setMask(self, mask); }
		public uint getMask() { return tsFUShader_getMask(self); }
		public uint getNumShaders() { return tsFUShader_getNumShaders(self); }
		public Shader getShader(uint index) { return new Shader(tsFUShader_getShader_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUShader: Valid: " + tsFUShader_isValidPtr(self) + "; Owner: " + tsFUShader_isOwnerPtr(self) + "; Const: " + tsFUShader_isConstPtr(self) + "; Count: " + tsFUShader_getCountPtr(self) + "; Internal: 0x" + tsFUShader_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUShader ptr) { return (ptr != null && tsFUShader_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_new_cASb(IntPtr[] shaders, uint shaders_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUShader_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUShader_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUShader_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUShader_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUShader_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUShader_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUShader_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUShader_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUShader_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUShader_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUShader_equalShaderPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_castShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_baseShaderPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUShader_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUShader_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUShader_getNumShaders(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUShader_getShader_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Sampler
	public class Sampler {
		public enum Filter : uint {
			Point = 0,
			Linear,
			Bipoint,
			Bilinear,
			Trilinear,
			NumFilters,
		}
		public const uint MinAnisotropy = 1;
		public const uint MaxAnisotropy = 16;
		public enum WrapMode : uint {
			Clamp = 0,
			Repeat,
			Mirror,
			Border,
			NumWrapModes,
		}
		public enum CompareFunc : uint {
			None = 0,
			Equal,
			Less,
			Greater,
			NotEqual,
			LessEqual,
			GreaterEqual,
			NumCompareFunctions,
		}
		public enum ReductionMode : uint {
			Average = 0,
			Min,
			Max,
			NumReductionModes,
		}
		public Sampler() { self = new HandleRef(this, tsSampler_new()); owner = true; }
		public Sampler(Sampler ptr) { self = new HandleRef(this, tsSampler_copyPtr(ptr.getSelf())); owner = true; }
		public Sampler(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSampler_isOwnerPtr(self); }
		public static Sampler Null() { return new Sampler(IntPtr.Zero); }
		~Sampler() { if(owner) tsSampler_delete(self); }
		public bool equalPtr(Sampler ptr) { return tsSampler_equalPtr(self, ptr.getSelf()); }
		public Sampler clonePtr() { return new Sampler(tsSampler_clonePtr(self)); }
		public void clearPtr() { tsSampler_clearPtr(self); }
		public void destroyPtr() { tsSampler_destroyPtr(self); }
		public void acquirePtr() { tsSampler_acquirePtr(self); }
		public void unacquirePtr() { tsSampler_unacquirePtr(self); }
		public bool isValidPtr() { return tsSampler_isValidPtr(self); }
		public bool isOwnerPtr() { return tsSampler_isOwnerPtr(self); }
		public bool isConstPtr() { return tsSampler_isConstPtr(self); }
		public uint getCountPtr() { return tsSampler_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsSampler_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsSampler_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsSampler_getPlatformName(self)); }
		public uint getIndex() { return tsSampler_getIndex(self); }
		public void clear() { tsSampler_clear(self); }
		public bool isCreated() { return tsSampler_isCreated(self); }
		public bool create() { return tsSampler_create(self); }
		public void setParameters(Sampler sampler) { tsSampler_setParameters(self, sampler.getSelf()); }
		public void setFilter(Filter filter) { tsSampler_setFilter(self, filter); }
		public Filter getFilter() { return tsSampler_getFilter(self); }
		public bool isPointFilter() { return tsSampler_isPointFilter(self); }
		public void setAnisotropy(uint anisotropy) { tsSampler_setAnisotropy(self, anisotropy); }
		public uint getAnisotropy() { return tsSampler_getAnisotropy(self); }
		public bool hasAnisotropy() { return tsSampler_hasAnisotropy(self); }
		public void setWrapMode(WrapMode mode) { tsSampler_setWrapMode_SWM(self, mode); }
		public void setWrapMode(WrapMode mode_s, WrapMode mode_t, WrapMode mode_r) { tsSampler_setWrapMode_SWMSWMSWM(self, mode_s, mode_t, mode_r); }
		public void setWrapModeS(WrapMode mode) { tsSampler_setWrapModeS(self, mode); }
		public WrapMode getWrapModeS() { return tsSampler_getWrapModeS(self); }
		public void setWrapModeT(WrapMode mode) { tsSampler_setWrapModeT(self, mode); }
		public WrapMode getWrapModeT() { return tsSampler_getWrapModeT(self); }
		public void setWrapModeR(WrapMode mode) { tsSampler_setWrapModeR(self, mode); }
		public WrapMode getWrapModeR() { return tsSampler_getWrapModeR(self); }
		public void setLod(float min, float max, float bias) { tsSampler_setLod(self, min, max, bias); }
		public void setLodMin(float min) { tsSampler_setLodMin(self, min); }
		public float getLodMin() { return tsSampler_getLodMin(self); }
		public void setLodMax(float max) { tsSampler_setLodMax(self, max); }
		public float getLodMax() { return tsSampler_getLodMax(self); }
		public void setLodBias(float bias) { tsSampler_setLodBias(self, bias); }
		public float getLodBias() { return tsSampler_getLodBias(self); }
		public void setBorderColor(in Color color) { tsSampler_setBorderColor_cC(self, in color); }
		public void setBorderColor(float r, float g, float b, float a) { tsSampler_setBorderColor_ffff(self, r, g, b, a); }
		public Color getBorderColor() { return tsSampler_getBorderColor(self); }
		public void setCompareFunc(CompareFunc func) { tsSampler_setCompareFunc(self, func); }
		public CompareFunc getCompareFunc() { return tsSampler_getCompareFunc(self); }
		public void setReductionMode(ReductionMode mode) { tsSampler_setReductionMode(self, mode); }
		public ReductionMode getReductionMode() { return tsSampler_getReductionMode(self); }
		public override string ToString() { return "Tellusim.Sampler: Valid: " + tsSampler_isValidPtr(self) + "; Owner: " + tsSampler_isOwnerPtr(self) + "; Const: " + tsSampler_isConstPtr(self) + "; Count: " + tsSampler_getCountPtr(self) + "; Internal: 0x" + tsSampler_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Sampler ptr) { return (ptr != null && tsSampler_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSampler_new();
		[DllImport(Base.Import)] private static extern void tsSampler_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSampler_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSampler_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSampler_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSampler_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsSampler_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSampler_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSampler_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_create(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setParameters(HandleRef self, HandleRef sampler);
		[DllImport(Base.Import)] private static extern void tsSampler_setFilter(HandleRef self, Filter filter);
		[DllImport(Base.Import)] private static extern Filter tsSampler_getFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_isPointFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setAnisotropy(HandleRef self, uint anisotropy);
		[DllImport(Base.Import)] private static extern uint tsSampler_getAnisotropy(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSampler_hasAnisotropy(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setWrapMode_SWM(HandleRef self, WrapMode mode);
		[DllImport(Base.Import)] private static extern void tsSampler_setWrapMode_SWMSWMSWM(HandleRef self, WrapMode mode_s, WrapMode mode_t, WrapMode mode_r);
		[DllImport(Base.Import)] private static extern void tsSampler_setWrapModeS(HandleRef self, WrapMode mode);
		[DllImport(Base.Import)] private static extern WrapMode tsSampler_getWrapModeS(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setWrapModeT(HandleRef self, WrapMode mode);
		[DllImport(Base.Import)] private static extern WrapMode tsSampler_getWrapModeT(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setWrapModeR(HandleRef self, WrapMode mode);
		[DllImport(Base.Import)] private static extern WrapMode tsSampler_getWrapModeR(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setLod(HandleRef self, float min, float max, float bias);
		[DllImport(Base.Import)] private static extern void tsSampler_setLodMin(HandleRef self, float min);
		[DllImport(Base.Import)] private static extern float tsSampler_getLodMin(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setLodMax(HandleRef self, float max);
		[DllImport(Base.Import)] private static extern float tsSampler_getLodMax(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setLodBias(HandleRef self, float bias);
		[DllImport(Base.Import)] private static extern float tsSampler_getLodBias(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setBorderColor_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern void tsSampler_setBorderColor_ffff(HandleRef self, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern Color tsSampler_getBorderColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setCompareFunc(HandleRef self, CompareFunc func);
		[DllImport(Base.Import)] private static extern CompareFunc tsSampler_getCompareFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSampler_setReductionMode(HandleRef self, ReductionMode mode);
		[DllImport(Base.Import)] private static extern ReductionMode tsSampler_getReductionMode(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::MTLSampler
	public sealed class MTLSampler : Sampler {
		public MTLSampler() { self = new HandleRef(this, tsMTLSampler_new()); owner = true; }
		public MTLSampler(MTLSampler ptr) { self = new HandleRef(this, tsMTLSampler_copyPtr(ptr.getSelf())); owner = true; }
		public MTLSampler(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLSampler_isOwnerPtr(self); }
		public MTLSampler(Sampler ptr) { self = new HandleRef(this, tsMTLSampler_castSamplerPtr(ptr.getSelf())); }
		public Sampler toSampler() { return new Sampler(tsMTLSampler_baseSamplerPtr(self)); }
		public static new MTLSampler Null() { return new MTLSampler(IntPtr.Zero); }
		public void setIndirect(bool enabled) { tsMTLSampler_setIndirect(self, enabled); }
		public bool isIndirect() { return tsMTLSampler_isIndirect(self); }
		public override string ToString() { return "Tellusim.MTLSampler: Valid: " + tsMTLSampler_isValidPtr(self) + "; Owner: " + tsMTLSampler_isOwnerPtr(self) + "; Const: " + tsMTLSampler_isConstPtr(self) + "; Count: " + tsMTLSampler_getCountPtr(self) + "; Internal: 0x" + tsMTLSampler_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLSampler ptr) { return (ptr != null && tsMTLSampler_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSampler_new();
		[DllImport(Base.Import)] private static extern void tsMTLSampler_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSampler_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSampler_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSampler_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSampler_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSampler_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSampler_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSampler_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSampler_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSampler_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSampler_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLSampler_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSampler_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSampler_equalSamplerPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSampler_castSamplerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSampler_baseSamplerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSampler_setIndirect(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsMTLSampler_isIndirect(HandleRef self);
	}
	
	// Tellusim::FUSampler
	public sealed class FUSampler : Sampler {
		public FUSampler() { self = new HandleRef(this, tsFUSampler_new()); owner = true; }
		public FUSampler(Sampler[] samplers, bool owner = false) {
			IntPtr[] samplers_ = new IntPtr[samplers.Length];
			for(int i = 0; i < samplers.Length; i++) samplers_[i] = samplers[i].getSelfPtr();
			self = new HandleRef(this, tsFUSampler_new_cASb(samplers_, (uint)samplers.Length, owner)); owner = true;
		}
		public FUSampler(FUSampler ptr) { self = new HandleRef(this, tsFUSampler_copyPtr(ptr.getSelf())); owner = true; }
		public FUSampler(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUSampler_isOwnerPtr(self); }
		public FUSampler(Sampler ptr) { self = new HandleRef(this, tsFUSampler_castSamplerPtr(ptr.getSelf())); }
		public Sampler toSampler() { return new Sampler(tsFUSampler_baseSamplerPtr(self)); }
		public static new FUSampler Null() { return new FUSampler(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUSampler_setMask(self, mask); }
		public uint getMask() { return tsFUSampler_getMask(self); }
		public uint getNumSamplers() { return tsFUSampler_getNumSamplers(self); }
		public Sampler getSampler(uint index) { return new Sampler(tsFUSampler_getSampler_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUSampler: Valid: " + tsFUSampler_isValidPtr(self) + "; Owner: " + tsFUSampler_isOwnerPtr(self) + "; Const: " + tsFUSampler_isConstPtr(self) + "; Count: " + tsFUSampler_getCountPtr(self) + "; Internal: 0x" + tsFUSampler_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUSampler ptr) { return (ptr != null && tsFUSampler_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_new_cASb(IntPtr[] samplers, uint samplers_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUSampler_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUSampler_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUSampler_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUSampler_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUSampler_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUSampler_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUSampler_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUSampler_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUSampler_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUSampler_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUSampler_equalSamplerPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_castSamplerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_baseSamplerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUSampler_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUSampler_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUSampler_getNumSamplers(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUSampler_getSampler_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Texture
	public class Texture {
		public enum Type : uint {
			Unknown = 0,
			_2D,
			_3D,
			Cube,
			NumTypes,
		}
		public enum Flags : uint {
			None = 0,
			Read = 1,
			Write = 2,
			Target = 4,
			Buffer = 8,
			Source = 16,
			Sparse = 32,
			Shared = 64,
			Extern = 128,
			Interop = 256,
			Surface = 512,
			Mutable = 1024,
			Mipmaps = 2048,
			Generate = 4096,
			FormatNorm = 8192,
			FormatSRGB = 16384,
			FormatSigned = 32768,
			Multisample2 = 65536,
			Multisample4 = 131072,
			Multisample8 = 262144,
			ClearOne = 524288,
			ClearZero = 1048576,
			ClearNormal = 2097152,
			Multisample = 458752,
			Default = 0,
			Num = 22,
		}
		public Texture() { self = new HandleRef(this, tsTexture_new()); owner = true; }
		public Texture(Texture ptr) { self = new HandleRef(this, tsTexture_copyPtr(ptr.getSelf())); owner = true; }
		public Texture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsTexture_isOwnerPtr(self); }
		public static Texture Null() { return new Texture(IntPtr.Zero); }
		~Texture() { if(owner) tsTexture_delete(self); }
		public bool equalPtr(Texture ptr) { return tsTexture_equalPtr(self, ptr.getSelf()); }
		public Texture clonePtr() { return new Texture(tsTexture_clonePtr(self)); }
		public void clearPtr() { tsTexture_clearPtr(self); }
		public void destroyPtr() { tsTexture_destroyPtr(self); }
		public void acquirePtr() { tsTexture_acquirePtr(self); }
		public void unacquirePtr() { tsTexture_unacquirePtr(self); }
		public bool isValidPtr() { return tsTexture_isValidPtr(self); }
		public bool isOwnerPtr() { return tsTexture_isOwnerPtr(self); }
		public bool isConstPtr() { return tsTexture_isConstPtr(self); }
		public uint getCountPtr() { return tsTexture_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsTexture_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsTexture_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsTexture_getPlatformName(self)); }
		public uint getIndex() { return tsTexture_getIndex(self); }
		public void clear() { tsTexture_clear(self); }
		public bool isCreated() { return tsTexture_isCreated(self); }
		public void setName(string name) { tsTexture_setName(self, name); }
		public string getName() { return Base.getString(tsTexture_getName(self)); }
		public bool create(Type type, Format format, in Size size, uint layers, Flags flags = Flags.Default) { return tsTexture_create(self, type, format, in size, layers, flags); }
		public bool create2D(Format format, uint size, Flags flags = Flags.Default) { return tsTexture_create2D_FuTF(self, format, size, flags); }
		public bool create3D(Format format, uint size, Flags flags = Flags.Default) { return tsTexture_create3D_FuTF(self, format, size, flags); }
		public bool createCube(Format format, uint size, Flags flags = Flags.Default) { return tsTexture_createCube_FuTF(self, format, size, flags); }
		public bool create2D(Format format, uint width, uint height, Flags flags = Flags.Default) { return tsTexture_create2D_FuuTF(self, format, width, height, flags); }
		public bool create3D(Format format, uint width, uint height, uint depth, Flags flags = Flags.Default) { return tsTexture_create3D_FuuuTF(self, format, width, height, depth, flags); }
		public bool create2D(Format format, uint width, uint height, uint layers, Flags flags = Flags.Default) { return tsTexture_create2D_FuuuTF(self, format, width, height, layers, flags); }
		public bool createCube(Format format, uint size, uint layers, Flags flags = Flags.Default) { return tsTexture_createCube_FuuTF(self, format, size, layers, flags); }
		public Type getType() { return tsTexture_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsTexture_getTypeName_TT(type)); }
		public string getTypeName() { return Base.getCString(tsTexture_getTypeName_c(self)); }
		public bool is2DType() { return tsTexture_is2DType(self); }
		public bool is3DType() { return tsTexture_is3DType(self); }
		public bool isCubeType() { return tsTexture_isCubeType(self); }
		public Format getFormat() { return tsTexture_getFormat(self); }
		public string getFormatName() { return Base.getCString(tsTexture_getFormatName(self)); }
		public bool isColorFormat() { return tsTexture_isColorFormat(self); }
		public bool isDepthFormat() { return tsTexture_isDepthFormat(self); }
		public bool isPixelFormat() { return tsTexture_isPixelFormat(self); }
		public bool isPlainFormat() { return tsTexture_isPlainFormat(self); }
		public bool isMixedFormat() { return tsTexture_isMixedFormat(self); }
		public bool isBlockFormat() { return tsTexture_isBlockFormat(self); }
		public bool isStencilFormat() { return tsTexture_isStencilFormat(self); }
		public bool isNormFormat() { return tsTexture_isNormFormat(self); }
		public bool isSRGBFormat() { return tsTexture_isSRGBFormat(self); }
		public bool isFloatFormat() { return tsTexture_isFloatFormat(self); }
		public bool isSignedFormat() { return tsTexture_isSignedFormat(self); }
		public bool isUnsignedFormat() { return tsTexture_isUnsignedFormat(self); }
		public bool isIntegerFormat() { return tsTexture_isIntegerFormat(self); }
		public bool isi8Format() { return tsTexture_isi8Format(self); }
		public bool isu8Format() { return tsTexture_isu8Format(self); }
		public bool is8BitFormat() { return tsTexture_is8BitFormat(self); }
		public bool isi16Format() { return tsTexture_isi16Format(self); }
		public bool isu16Format() { return tsTexture_isu16Format(self); }
		public bool isf16Format() { return tsTexture_isf16Format(self); }
		public bool is16BitFormat() { return tsTexture_is16BitFormat(self); }
		public bool isi32Format() { return tsTexture_isi32Format(self); }
		public bool isu32Format() { return tsTexture_isu32Format(self); }
		public bool isf32Format() { return tsTexture_isf32Format(self); }
		public bool is32BitFormat() { return tsTexture_is32BitFormat(self); }
		public bool isi64Format() { return tsTexture_isi64Format(self); }
		public bool isu64Format() { return tsTexture_isu64Format(self); }
		public bool isf64Format() { return tsTexture_isf64Format(self); }
		public bool is64BitFormat() { return tsTexture_is64BitFormat(self); }
		public bool isBC15Format() { return tsTexture_isBC15Format(self); }
		public bool isBC67Format() { return tsTexture_isBC67Format(self); }
		public bool isETC2Format() { return tsTexture_isETC2Format(self); }
		public bool isASTCFormat() { return tsTexture_isASTCFormat(self); }
		public uint getComponents() { return tsTexture_getComponents(self); }
		public uint getPixelSize() { return tsTexture_getPixelSize(self); }
		public uint getBlockSize() { return tsTexture_getBlockSize(self); }
		public uint getBlockWidth() { return tsTexture_getBlockWidth(self); }
		public uint getBlockHeight() { return tsTexture_getBlockHeight(self); }
		public Flags getFlags() { return tsTexture_getFlags(self); }
		public bool hasFlag(Flags flags) { return tsTexture_hasFlag(self, flags); }
		public bool hasFlags(Flags flags) { return tsTexture_hasFlags(self, flags); }
		public string getFlagsName() { return Base.getString(tsTexture_getFlagsName(self)); }
		public uint getMultisample() { return tsTexture_getMultisample(self); }
		public bool hasMultisample() { return tsTexture_hasMultisample(self); }
		public uint getWidth() { return tsTexture_getWidth_c(self); }
		public uint getHeight() { return tsTexture_getHeight_c(self); }
		public uint getDepth() { return tsTexture_getDepth_c(self); }
		public uint getFaces() { return tsTexture_getFaces(self); }
		public uint getLayers() { return tsTexture_getLayers(self); }
		public uint getMipmaps() { return tsTexture_getMipmaps(self); }
		public uint findMipmap(in Size size) { return tsTexture_findMipmap(self, in size); }
		public uint getWidth(uint mipmap) { return tsTexture_getWidth_cu(self, mipmap); }
		public uint getHeight(uint mipmap) { return tsTexture_getHeight_cu(self, mipmap); }
		public uint getDepth(uint mipmap) { return tsTexture_getDepth_cu(self, mipmap); }
		public bool hasFaces() { return tsTexture_hasFaces(self); }
		public bool hasLayers() { return tsTexture_hasLayers(self); }
		public bool hasMipmaps() { return tsTexture_hasMipmaps(self); }
		public Size getSize() { return tsTexture_getSize_c(self); }
		public Region getRegion() { return tsTexture_getRegion_c(self); }
		public Slice getSlice() { return tsTexture_getSlice_c(self); }
		public Size getSize(uint mipmap) { return tsTexture_getSize_cu(self, mipmap); }
		public Region getRegion(uint mipmap) { return tsTexture_getRegion_cu(self, mipmap); }
		public Slice getSlice(uint mipmap) { return tsTexture_getSlice_cu(self, mipmap); }
		public uint getTileWidth() { return tsTexture_getTileWidth(self); }
		public uint getTileHeight() { return tsTexture_getTileHeight(self); }
		public uint getTileDepth() { return tsTexture_getTileDepth(self); }
		public uint getTileMipmaps() { return tsTexture_getTileMipmaps(self); }
		public Size getTileSize() { return tsTexture_getTileSize(self); }
		public string getDescription() { return Base.getString(tsTexture_getDescription(self)); }
		public ulong getMemory() { return tsTexture_getMemory(self); }
		public override string ToString() { return "Tellusim.Texture: Valid: " + tsTexture_isValidPtr(self) + "; Owner: " + tsTexture_isOwnerPtr(self) + "; Const: " + tsTexture_isConstPtr(self) + "; Count: " + tsTexture_getCountPtr(self) + "; Internal: 0x" + tsTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Texture ptr) { return (ptr != null && tsTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_new();
		[DllImport(Base.Import)] private static extern void tsTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsTexture_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTexture_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTexture_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_create(HandleRef self, Type type, Format format, in Size size, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_create2D_FuTF(HandleRef self, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_create3D_FuTF(HandleRef self, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_createCube_FuTF(HandleRef self, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_create2D_FuuTF(HandleRef self, Format format, uint width, uint height, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_create3D_FuuuTF(HandleRef self, Format format, uint width, uint height, uint depth, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_create2D_FuuuTF(HandleRef self, Format format, uint width, uint height, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_createCube_FuuTF(HandleRef self, Format format, uint size, uint layers, Flags flags);
		[DllImport(Base.Import)] private static extern Type tsTexture_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getTypeName_TT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_is2DType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_is3DType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isCubeType(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsTexture_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getFormatName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isColorFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isDepthFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isPixelFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isPlainFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isMixedFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isBlockFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isStencilFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isNormFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isSRGBFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isFloatFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isSignedFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isUnsignedFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isIntegerFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isi8Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isu8Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_is8BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isi16Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isu16Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isf16Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_is16BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isi32Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isu32Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isf32Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_is32BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isi64Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isu64Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isf64Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_is64BitFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isBC15Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isBC67Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isETC2Format(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_isASTCFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getComponents(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getPixelSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getBlockSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getBlockWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getBlockHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern Flags tsTexture_getFlags(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_hasFlag(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTexture_hasFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getFlagsName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_hasMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getWidth_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getHeight_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getDepth_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getFaces(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getMipmaps(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_findMipmap(HandleRef self, in Size size);
		[DllImport(Base.Import)] private static extern uint tsTexture_getWidth_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern uint tsTexture_getHeight_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern uint tsTexture_getDepth_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern bool tsTexture_hasFaces(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_hasLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTexture_hasMipmaps(HandleRef self);
		[DllImport(Base.Import)] private static extern Size tsTexture_getSize_c(HandleRef self);
		[DllImport(Base.Import)] private static extern Region tsTexture_getRegion_c(HandleRef self);
		[DllImport(Base.Import)] private static extern Slice tsTexture_getSlice_c(HandleRef self);
		[DllImport(Base.Import)] private static extern Size tsTexture_getSize_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern Region tsTexture_getRegion_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern Slice tsTexture_getSlice_cu(HandleRef self, uint mipmap);
		[DllImport(Base.Import)] private static extern uint tsTexture_getTileWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getTileHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getTileDepth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTexture_getTileMipmaps(HandleRef self);
		[DllImport(Base.Import)] private static extern Size tsTexture_getTileSize(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTexture_getDescription(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTexture_getMemory(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::TextureTable
	public sealed class TextureTable {
		public TextureTable() { self = new HandleRef(this, tsTextureTable_new()); owner = true; }
		public TextureTable(TextureTable ptr) { self = new HandleRef(this, tsTextureTable_copyPtr(ptr.getSelf())); owner = true; }
		public TextureTable(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsTextureTable_isOwnerPtr(self); }
		public static TextureTable Null() { return new TextureTable(IntPtr.Zero); }
		~TextureTable() { if(owner) tsTextureTable_delete(self); }
		public bool equalPtr(TextureTable ptr) { return tsTextureTable_equalPtr(self, ptr.getSelf()); }
		public TextureTable clonePtr() { return new TextureTable(tsTextureTable_clonePtr(self)); }
		public void clearPtr() { tsTextureTable_clearPtr(self); }
		public void destroyPtr() { tsTextureTable_destroyPtr(self); }
		public void acquirePtr() { tsTextureTable_acquirePtr(self); }
		public void unacquirePtr() { tsTextureTable_unacquirePtr(self); }
		public bool isValidPtr() { return tsTextureTable_isValidPtr(self); }
		public bool isOwnerPtr() { return tsTextureTable_isOwnerPtr(self); }
		public bool isConstPtr() { return tsTextureTable_isConstPtr(self); }
		public uint getCountPtr() { return tsTextureTable_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsTextureTable_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsTextureTable_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsTextureTable_getPlatformName(self)); }
		public uint getIndex() { return tsTextureTable_getIndex(self); }
		public void clear() { tsTextureTable_clear(self); }
		public bool isCreated() { return tsTextureTable_isCreated(self); }
		public void setName(string name) { tsTextureTable_setName(self, name); }
		public string getName() { return Base.getString(tsTextureTable_getName(self)); }
		public bool create(Texture.Type type, uint size) { return tsTextureTable_create(self, type, size); }
		public Texture.Type getType() { return tsTextureTable_getType(self); }
		public string getTypeName() { return Base.getCString(tsTextureTable_getTypeName(self)); }
		public uint getSize() { return tsTextureTable_getSize(self); }
		public Texture get(uint index) { return new Texture(tsTextureTable_get(self, index)); }
		public bool isOwner(uint index) { return tsTextureTable_isOwner(self, index); }
		public ulong getMemory() { return tsTextureTable_getMemory(self); }
		public override string ToString() { return "Tellusim.TextureTable: Valid: " + tsTextureTable_isValidPtr(self) + "; Owner: " + tsTextureTable_isOwnerPtr(self) + "; Const: " + tsTextureTable_isConstPtr(self) + "; Count: " + tsTextureTable_getCountPtr(self) + "; Internal: 0x" + tsTextureTable_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(TextureTable ptr) { return (ptr != null && tsTextureTable_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_new();
		[DllImport(Base.Import)] private static extern void tsTextureTable_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTextureTable_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTextureTable_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTextureTable_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTextureTable_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTextureTable_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsTextureTable_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTextureTable_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTextureTable_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTextureTable_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_create(HandleRef self, Texture.Type type, uint size);
		[DllImport(Base.Import)] private static extern Texture.Type tsTextureTable_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_getTypeName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTextureTable_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTextureTable_get(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsTextureTable_isOwner(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsTextureTable_getMemory(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::D3D12Texture
	public sealed class D3D12Texture : Texture {
		public D3D12Texture() { self = new HandleRef(this, tsD3D12Texture_new()); owner = true; }
		public D3D12Texture(D3D12Texture ptr) { self = new HandleRef(this, tsD3D12Texture_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Texture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Texture_isOwnerPtr(self); }
		public D3D12Texture(Texture ptr) { self = new HandleRef(this, tsD3D12Texture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsD3D12Texture_baseTexturePtr(self)); }
		public static new D3D12Texture Null() { return new D3D12Texture(IntPtr.Zero); }
		public bool create(Type type, IntPtr texture, uint state, Flags flags = Flags.Default, Format format = Format.Unknown) { return tsD3D12Texture_create(self, type, texture, state, flags, format); }
		public uint getDXGIFormat() { return tsD3D12Texture_getDXGIFormat(self); }
		public IntPtr getD3D12Texture() { return tsD3D12Texture_getD3D12Texture(self); }
		public ulong getShaderResourceView() { return tsD3D12Texture_getShaderResourceView(self); }
		public ulong getRenderTargetView() { return tsD3D12Texture_getRenderTargetView(self); }
		public ulong getDepthStencilView() { return tsD3D12Texture_getDepthStencilView(self); }
		public ulong getUnorderedAccessView() { return tsD3D12Texture_getUnorderedAccessView(self); }
		public void setTextureState(uint state) { tsD3D12Texture_setTextureState(self, state); }
		public uint getTextureState() { return tsD3D12Texture_getTextureState(self); }
		public IntPtr getSharedHandle() { return tsD3D12Texture_getSharedHandle(self); }
		public IntPtr getInteropHandle() { return tsD3D12Texture_getInteropHandle(self); }
		public override string ToString() { return "Tellusim.D3D12Texture: Valid: " + tsD3D12Texture_isValidPtr(self) + "; Owner: " + tsD3D12Texture_isOwnerPtr(self) + "; Const: " + tsD3D12Texture_isConstPtr(self) + "; Count: " + tsD3D12Texture_getCountPtr(self) + "; Internal: 0x" + tsD3D12Texture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Texture ptr) { return (ptr != null && tsD3D12Texture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Texture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Texture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Texture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Texture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Texture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Texture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Texture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Texture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Texture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Texture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Texture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Texture_create(HandleRef self, Type type, IntPtr texture, uint state, Flags flags, Format format);
		[DllImport(Base.Import)] private static extern uint tsD3D12Texture_getDXGIFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_getD3D12Texture(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Texture_getShaderResourceView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Texture_getRenderTargetView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Texture_getDepthStencilView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Texture_getUnorderedAccessView(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Texture_setTextureState(HandleRef self, uint state);
		[DllImport(Base.Import)] private static extern uint tsD3D12Texture_getTextureState(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_getSharedHandle(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Texture_getInteropHandle(HandleRef self);
	}
	
	// Tellusim::D3D11Texture
	public sealed class D3D11Texture : Texture {
		public D3D11Texture() { self = new HandleRef(this, tsD3D11Texture_new()); owner = true; }
		public D3D11Texture(D3D11Texture ptr) { self = new HandleRef(this, tsD3D11Texture_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Texture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Texture_isOwnerPtr(self); }
		public D3D11Texture(Texture ptr) { self = new HandleRef(this, tsD3D11Texture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsD3D11Texture_baseTexturePtr(self)); }
		public static new D3D11Texture Null() { return new D3D11Texture(IntPtr.Zero); }
		public bool create(Type type, IntPtr texture, Flags flags = Flags.Default, Format format = Format.Unknown) { return tsD3D11Texture_create(self, type, texture, flags, format); }
		public uint getDXGIFormat() { return tsD3D11Texture_getDXGIFormat(self); }
		public IntPtr getD3D11Texture() { return tsD3D11Texture_getD3D11Texture(self); }
		public IntPtr getShaderResourceView() { return tsD3D11Texture_getShaderResourceView(self); }
		public IntPtr getRenderTargetView() { return tsD3D11Texture_getRenderTargetView(self); }
		public IntPtr getDepthStencilView() { return tsD3D11Texture_getDepthStencilView(self); }
		public IntPtr getUnorderedAccessView() { return tsD3D11Texture_getUnorderedAccessView(self); }
		public IntPtr getInteropHandle() { return tsD3D11Texture_getInteropHandle(self); }
		public override string ToString() { return "Tellusim.D3D11Texture: Valid: " + tsD3D11Texture_isValidPtr(self) + "; Owner: " + tsD3D11Texture_isOwnerPtr(self) + "; Const: " + tsD3D11Texture_isConstPtr(self) + "; Count: " + tsD3D11Texture_getCountPtr(self) + "; Internal: 0x" + tsD3D11Texture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Texture ptr) { return (ptr != null && tsD3D11Texture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_new();
		[DllImport(Base.Import)] private static extern void tsD3D11Texture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Texture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Texture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Texture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Texture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Texture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Texture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Texture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Texture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Texture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Texture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Texture_create(HandleRef self, Type type, IntPtr texture, Flags flags, Format format);
		[DllImport(Base.Import)] private static extern uint tsD3D11Texture_getDXGIFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getD3D11Texture(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getShaderResourceView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getRenderTargetView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getDepthStencilView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getUnorderedAccessView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Texture_getInteropHandle(HandleRef self);
	}
	
	// Tellusim::MTLTexture
	public sealed class MTLTexture : Texture {
		public MTLTexture() { self = new HandleRef(this, tsMTLTexture_new()); owner = true; }
		public MTLTexture(MTLTexture ptr) { self = new HandleRef(this, tsMTLTexture_copyPtr(ptr.getSelf())); owner = true; }
		public MTLTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLTexture_isOwnerPtr(self); }
		public MTLTexture(Texture ptr) { self = new HandleRef(this, tsMTLTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsMTLTexture_baseTexturePtr(self)); }
		public static new MTLTexture Null() { return new MTLTexture(IntPtr.Zero); }
		public bool create(IntPtr texture, Flags flags = Flags.Default, Format format = Format.Unknown) { return tsMTLTexture_create(self, texture, flags, format); }
		public uint getPixelFormat() { return tsMTLTexture_getPixelFormat(self); }
		public uint getTextureType() { return tsMTLTexture_getTextureType(self); }
		public IntPtr getMTLTexture() { return tsMTLTexture_getMTLTexture(self); }
		public IntPtr getMTLBuffer() { return tsMTLTexture_getMTLBuffer(self); }
		public IntPtr getSharedPtr() { return tsMTLTexture_getSharedPtr(self); }
		public override string ToString() { return "Tellusim.MTLTexture: Valid: " + tsMTLTexture_isValidPtr(self) + "; Owner: " + tsMTLTexture_isOwnerPtr(self) + "; Const: " + tsMTLTexture_isConstPtr(self) + "; Count: " + tsMTLTexture_getCountPtr(self) + "; Internal: 0x" + tsMTLTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLTexture ptr) { return (ptr != null && tsMTLTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_new();
		[DllImport(Base.Import)] private static extern void tsMTLTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTexture_create(HandleRef self, IntPtr texture, Flags flags, Format format);
		[DllImport(Base.Import)] private static extern uint tsMTLTexture_getPixelFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLTexture_getTextureType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_getMTLTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_getMTLBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTexture_getSharedPtr(HandleRef self);
	}
	
	// Tellusim::VKTexture
	public sealed class VKTexture : Texture {
		public VKTexture() { self = new HandleRef(this, tsVKTexture_new()); owner = true; }
		public VKTexture(VKTexture ptr) { self = new HandleRef(this, tsVKTexture_copyPtr(ptr.getSelf())); owner = true; }
		public VKTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKTexture_isOwnerPtr(self); }
		public VKTexture(Texture ptr) { self = new HandleRef(this, tsVKTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsVKTexture_baseTexturePtr(self)); }
		public static new VKTexture Null() { return new VKTexture(IntPtr.Zero); }
		public bool create(Type type, uint format, IntPtr texture, uint layout, Flags flags = Flags.Default, Format texture_format = Format.Unknown) { return tsVKTexture_create(self, type, format, texture, layout, flags, texture_format); }
		public uint getPixelFormat() { return tsVKTexture_getPixelFormat(self); }
		public IntPtr getVKTexture() { return tsVKTexture_getVKTexture(self); }
		public IntPtr getTextureView() { return tsVKTexture_getTextureView(self); }
		public void setTextureLayout(uint layout) { tsVKTexture_setTextureLayout(self, layout); }
		public uint getTextureLayout() { return tsVKTexture_getTextureLayout(self); }
		public void getTextureRange(IntPtr range, in Slice slice) { tsVKTexture_getTextureRange(self, range, in slice); }
		public IntPtr getSharedPtr() { return tsVKTexture_getSharedPtr(self); }
		public IntPtr getInteropHandle() { return tsVKTexture_getInteropHandle(self); }
		public override string ToString() { return "Tellusim.VKTexture: Valid: " + tsVKTexture_isValidPtr(self) + "; Owner: " + tsVKTexture_isOwnerPtr(self) + "; Const: " + tsVKTexture_isConstPtr(self) + "; Count: " + tsVKTexture_getCountPtr(self) + "; Internal: 0x" + tsVKTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKTexture ptr) { return (ptr != null && tsVKTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_new();
		[DllImport(Base.Import)] private static extern void tsVKTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTexture_create(HandleRef self, Type type, uint format, IntPtr texture, uint layout, Flags flags, Format texture_format);
		[DllImport(Base.Import)] private static extern uint tsVKTexture_getPixelFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_getVKTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_getTextureView(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTexture_setTextureLayout(HandleRef self, uint layout);
		[DllImport(Base.Import)] private static extern uint tsVKTexture_getTextureLayout(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTexture_getTextureRange(HandleRef self, IntPtr range, in Slice slice);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_getSharedPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTexture_getInteropHandle(HandleRef self);
	}
	
	// Tellusim::GLTexture
	public sealed class GLTexture : Texture {
		public GLTexture() { self = new HandleRef(this, tsGLTexture_new()); owner = true; }
		public GLTexture(GLTexture ptr) { self = new HandleRef(this, tsGLTexture_copyPtr(ptr.getSelf())); owner = true; }
		public GLTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLTexture_isOwnerPtr(self); }
		public GLTexture(Texture ptr) { self = new HandleRef(this, tsGLTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsGLTexture_baseTexturePtr(self)); }
		public static new GLTexture Null() { return new GLTexture(IntPtr.Zero); }
		public bool create(uint target, uint texture_id, Flags flags = Flags.Default, Format format = Format.Unknown) { return tsGLTexture_create(self, target, texture_id, flags, format); }
		public uint getTarget() { return tsGLTexture_getTarget(self); }
		public uint getInternalFormat() { return tsGLTexture_getInternalFormat(self); }
		public uint getTextureID() { return tsGLTexture_getTextureID(self); }
		public override string ToString() { return "Tellusim.GLTexture: Valid: " + tsGLTexture_isValidPtr(self) + "; Owner: " + tsGLTexture_isOwnerPtr(self) + "; Const: " + tsGLTexture_isConstPtr(self) + "; Count: " + tsGLTexture_getCountPtr(self) + "; Internal: 0x" + tsGLTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLTexture ptr) { return (ptr != null && tsGLTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLTexture_new();
		[DllImport(Base.Import)] private static extern void tsGLTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTexture_create(HandleRef self, uint target, uint texture_id, Flags flags, Format format);
		[DllImport(Base.Import)] private static extern uint tsGLTexture_getTarget(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLTexture_getInternalFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLTexture_getTextureID(HandleRef self);
	}
	
	// Tellusim::GLESTexture
	public sealed class GLESTexture : Texture {
		public GLESTexture() { self = new HandleRef(this, tsGLESTexture_new()); owner = true; }
		public GLESTexture(GLESTexture ptr) { self = new HandleRef(this, tsGLESTexture_copyPtr(ptr.getSelf())); owner = true; }
		public GLESTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLESTexture_isOwnerPtr(self); }
		public GLESTexture(Texture ptr) { self = new HandleRef(this, tsGLESTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsGLESTexture_baseTexturePtr(self)); }
		public static new GLESTexture Null() { return new GLESTexture(IntPtr.Zero); }
		public bool create(uint target, uint texture_id, Flags flags = Flags.Default, Format format = Format.Unknown) { return tsGLESTexture_create(self, target, texture_id, flags, format); }
		public uint getTarget() { return tsGLESTexture_getTarget(self); }
		public uint getInternalFormat() { return tsGLESTexture_getInternalFormat(self); }
		public uint getTextureID() { return tsGLESTexture_getTextureID(self); }
		public override string ToString() { return "Tellusim.GLESTexture: Valid: " + tsGLESTexture_isValidPtr(self) + "; Owner: " + tsGLESTexture_isOwnerPtr(self) + "; Const: " + tsGLESTexture_isConstPtr(self) + "; Count: " + tsGLESTexture_getCountPtr(self) + "; Internal: 0x" + tsGLESTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLESTexture ptr) { return (ptr != null && tsGLESTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTexture_new();
		[DllImport(Base.Import)] private static extern void tsGLESTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTexture_create(HandleRef self, uint target, uint texture_id, Flags flags, Format format);
		[DllImport(Base.Import)] private static extern uint tsGLESTexture_getTarget(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESTexture_getInternalFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESTexture_getTextureID(HandleRef self);
	}
	
	// Tellusim::CUTexture
	public sealed class CUTexture : Texture {
		public CUTexture() { self = new HandleRef(this, tsCUTexture_new()); owner = true; }
		public CUTexture(CUTexture ptr) { self = new HandleRef(this, tsCUTexture_copyPtr(ptr.getSelf())); owner = true; }
		public CUTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCUTexture_isOwnerPtr(self); }
		public CUTexture(Texture ptr) { self = new HandleRef(this, tsCUTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsCUTexture_baseTexturePtr(self)); }
		public static new CUTexture Null() { return new CUTexture(IntPtr.Zero); }
		public IntPtr getTextureLevel(uint index) { return tsCUTexture_getTextureLevel(self, index); }
		public uint getArrayFormat() { return tsCUTexture_getArrayFormat(self); }
		public uint getArrayChannels() { return tsCUTexture_getArrayChannels(self); }
		public IntPtr getSharedMemory() { return tsCUTexture_getSharedMemory(self); }
		public override string ToString() { return "Tellusim.CUTexture: Valid: " + tsCUTexture_isValidPtr(self) + "; Owner: " + tsCUTexture_isOwnerPtr(self) + "; Const: " + tsCUTexture_isConstPtr(self) + "; Count: " + tsCUTexture_getCountPtr(self) + "; Internal: 0x" + tsCUTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CUTexture ptr) { return (ptr != null && tsCUTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_new();
		[DllImport(Base.Import)] private static extern void tsCUTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCUTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCUTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_getTextureLevel(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsCUTexture_getArrayFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCUTexture_getArrayChannels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCUTexture_getSharedMemory(HandleRef self);
	}
	
	// Tellusim::HIPTexture
	public sealed class HIPTexture : Texture {
		public HIPTexture() { self = new HandleRef(this, tsHIPTexture_new()); owner = true; }
		public HIPTexture(HIPTexture ptr) { self = new HandleRef(this, tsHIPTexture_copyPtr(ptr.getSelf())); owner = true; }
		public HIPTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsHIPTexture_isOwnerPtr(self); }
		public HIPTexture(Texture ptr) { self = new HandleRef(this, tsHIPTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsHIPTexture_baseTexturePtr(self)); }
		public static new HIPTexture Null() { return new HIPTexture(IntPtr.Zero); }
		public IntPtr getTextureArray() { return tsHIPTexture_getTextureArray(self); }
		public IntPtr getTextureLevel(uint index) { return tsHIPTexture_getTextureLevel(self, index); }
		public uint getArrayFormat() { return tsHIPTexture_getArrayFormat(self); }
		public uint getArrayChannels() { return tsHIPTexture_getArrayChannels(self); }
		public IntPtr getSharedMemory() { return tsHIPTexture_getSharedMemory(self); }
		public override string ToString() { return "Tellusim.HIPTexture: Valid: " + tsHIPTexture_isValidPtr(self) + "; Owner: " + tsHIPTexture_isOwnerPtr(self) + "; Const: " + tsHIPTexture_isConstPtr(self) + "; Count: " + tsHIPTexture_getCountPtr(self) + "; Internal: 0x" + tsHIPTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(HIPTexture ptr) { return (ptr != null && tsHIPTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_new();
		[DllImport(Base.Import)] private static extern void tsHIPTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsHIPTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsHIPTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_getTextureArray(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_getTextureLevel(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsHIPTexture_getArrayFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsHIPTexture_getArrayChannels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsHIPTexture_getSharedMemory(HandleRef self);
	}
	
	// Tellusim::FUTexture
	public sealed class FUTexture : Texture {
		public FUTexture() { self = new HandleRef(this, tsFUTexture_new()); owner = true; }
		public FUTexture(Texture[] textures, bool owner = false) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			self = new HandleRef(this, tsFUTexture_new_cATb(textures_, (uint)textures.Length, owner)); owner = true;
		}
		public FUTexture(FUTexture ptr) { self = new HandleRef(this, tsFUTexture_copyPtr(ptr.getSelf())); owner = true; }
		public FUTexture(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUTexture_isOwnerPtr(self); }
		public FUTexture(Texture ptr) { self = new HandleRef(this, tsFUTexture_castTexturePtr(ptr.getSelf())); }
		public Texture toTexture() { return new Texture(tsFUTexture_baseTexturePtr(self)); }
		public static new FUTexture Null() { return new FUTexture(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUTexture_setMask(self, mask); }
		public uint getMask() { return tsFUTexture_getMask(self); }
		public uint getNumTextures() { return tsFUTexture_getNumTextures(self); }
		public Texture getTexture(uint index) { return new Texture(tsFUTexture_getTexture_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUTexture: Valid: " + tsFUTexture_isValidPtr(self) + "; Owner: " + tsFUTexture_isOwnerPtr(self) + "; Const: " + tsFUTexture_isConstPtr(self) + "; Count: " + tsFUTexture_getCountPtr(self) + "; Internal: 0x" + tsFUTexture_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUTexture ptr) { return (ptr != null && tsFUTexture_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_new_cATb(IntPtr[] textures, uint textures_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUTexture_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTexture_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTexture_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTexture_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTexture_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTexture_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTexture_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTexture_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTexture_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTexture_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTexture_equalTexturePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_castTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_baseTexturePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTexture_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUTexture_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTexture_getNumTextures(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTexture_getTexture_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Tracing
	public class Tracing {
		public enum Type : uint {
			Unknown = 0,
			Instance,
			Triangle,
			Bound,
			NumTypes,
		}
		public enum Flags : uint {
			None = 0,
			Info = 1,
			Update = 2,
			Compact = 4,
			Transparent = 8,
			FastBuild = 16,
			FastTrace = 32,
			Default = 0,
			Num = 6,
		}
		public const uint InstanceSize = 64;
		public Tracing() { self = new HandleRef(this, tsTracing_new()); owner = true; }
		public Tracing(Tracing ptr) { self = new HandleRef(this, tsTracing_copyPtr(ptr.getSelf())); owner = true; }
		public Tracing(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsTracing_isOwnerPtr(self); }
		public static Tracing Null() { return new Tracing(IntPtr.Zero); }
		~Tracing() { if(owner) tsTracing_delete(self); }
		public bool equalPtr(Tracing ptr) { return tsTracing_equalPtr(self, ptr.getSelf()); }
		public Tracing clonePtr() { return new Tracing(tsTracing_clonePtr(self)); }
		public void clearPtr() { tsTracing_clearPtr(self); }
		public void destroyPtr() { tsTracing_destroyPtr(self); }
		public void acquirePtr() { tsTracing_acquirePtr(self); }
		public void unacquirePtr() { tsTracing_unacquirePtr(self); }
		public bool isValidPtr() { return tsTracing_isValidPtr(self); }
		public bool isOwnerPtr() { return tsTracing_isOwnerPtr(self); }
		public bool isConstPtr() { return tsTracing_isConstPtr(self); }
		public uint getCountPtr() { return tsTracing_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsTracing_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsTracing_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsTracing_getPlatformName(self)); }
		public uint getIndex() { return tsTracing_getIndex(self); }
		public void clear() { tsTracing_clear(self); }
		public bool isCreated() { return tsTracing_isCreated(self); }
		public bool isBuilt() { return tsTracing_isBuilt(self); }
		public void setName(string name) { tsTracing_setName(self, name); }
		public string getName() { return Base.getString(tsTracing_getName(self)); }
		public bool create(Type type, Flags flags = Flags.Default) { return tsTracing_create(self, type, flags); }
		public Type getType() { return tsTracing_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsTracing_getTypeName_TT(type)); }
		public string getTypeName() { return Base.getCString(tsTracing_getTypeName_c(self)); }
		public bool isInstanceType() { return tsTracing_isInstanceType(self); }
		public bool isTriangleType() { return tsTracing_isTriangleType(self); }
		public bool isBoundType() { return tsTracing_isBoundType(self); }
		public bool isGeometryType() { return tsTracing_isGeometryType(self); }
		public void setParameters(Tracing tracing) { tsTracing_setParameters(self, tracing.getSelf()); }
		public uint getNumGeometries() { return tsTracing_getNumGeometries(self); }
		public void setInstanceBuffer(uint num_instances, Buffer buffer, ulong offset = 0) { tsTracing_setInstanceBuffer_uBz(self, num_instances, buffer.getSelf(), offset); }
		public void setInstanceBuffer(Buffer buffer, ulong offset = 0) { tsTracing_setInstanceBuffer_Bz(self, buffer.getSelf(), offset); }
		public void setNumInstances(uint num_instances) { tsTracing_setNumInstances(self, num_instances); }
		public uint getNumInstances() { return tsTracing_getNumInstances(self); }
		public Buffer getInstanceBuffer() { return new Buffer(tsTracing_getInstanceBuffer(self)); }
		public ulong getInstanceOffset() { return tsTracing_getInstanceOffset(self); }
		public void setIndirectBuffer(Buffer buffer, ulong offset = 0) { tsTracing_setIndirectBuffer(self, buffer.getSelf(), offset); }
		public Buffer getIndirectBuffer() { return new Buffer(tsTracing_getIndirectBuffer(self)); }
		public ulong getIndirectOffset() { return tsTracing_getIndirectOffset(self); }
		public uint addVertexBuffer(uint num_vertices, Format format, ulong stride, Buffer buffer = null, ulong offset = 0) { return tsTracing_addVertexBuffer(self, num_vertices, format, stride, (buffer != null) ? buffer.getSelf() : Base.Null, offset); }
		public void setVertexBuffer(uint index, uint num_vertices, Buffer buffer, ulong offset = 0) { tsTracing_setVertexBuffer_uuBz(self, index, num_vertices, buffer.getSelf(), offset); }
		public void setVertexBuffer(uint index, Buffer buffer, ulong offset = 0) { tsTracing_setVertexBuffer_uBz(self, index, buffer.getSelf(), offset); }
		public void setNumVertices(uint index, uint num_vertices) { tsTracing_setNumVertices(self, index, num_vertices); }
		public uint getNumVertices(uint index) { return tsTracing_getNumVertices(self, index); }
		public Format getVertexFormat(uint index) { return tsTracing_getVertexFormat(self, index); }
		public uint getVertexStride(uint index) { return tsTracing_getVertexStride(self, index); }
		public Buffer getVertexBuffer(uint index) { return new Buffer(tsTracing_getVertexBuffer(self, index)); }
		public ulong getVertexOffset(uint index) { return tsTracing_getVertexOffset(self, index); }
		public uint addIndexBuffer(uint num_indices, Format format, Buffer buffer = null, ulong offset = 0) { return tsTracing_addIndexBuffer(self, num_indices, format, (buffer != null) ? buffer.getSelf() : Base.Null, offset); }
		public void setIndexBuffer(uint index, uint num_indices, Buffer buffer, ulong offset = 0) { tsTracing_setIndexBuffer_uuBz(self, index, num_indices, buffer.getSelf(), offset); }
		public void setIndexBuffer(uint index, Buffer buffer, ulong offset = 0) { tsTracing_setIndexBuffer_uBz(self, index, buffer.getSelf(), offset); }
		public void setNumIndices(uint index, uint num_indices) { tsTracing_setNumIndices(self, index, num_indices); }
		public uint getNumIndices(uint index) { return tsTracing_getNumIndices(self, index); }
		public Format getIndexFormat(uint index) { return tsTracing_getIndexFormat(self, index); }
		public Buffer getIndexBuffer(uint index) { return new Buffer(tsTracing_getIndexBuffer(self, index)); }
		public ulong getIndexOffset(uint index) { return tsTracing_getIndexOffset(self, index); }
		public uint addBoundBuffer(uint num_bounds, ulong stride, Buffer buffer = null, ulong offset = 0) { return tsTracing_addBoundBuffer(self, num_bounds, stride, (buffer != null) ? buffer.getSelf() : Base.Null, offset); }
		public void setBoundBuffer(uint index, uint num_bounds, Buffer buffer, ulong offset = 0) { tsTracing_setBoundBuffer_uuBz(self, index, num_bounds, buffer.getSelf(), offset); }
		public void setBoundBuffer(uint index, Buffer buffer, ulong offset = 0) { tsTracing_setBoundBuffer_uBz(self, index, buffer.getSelf(), offset); }
		public void setNumBounds(uint index, uint num_bounds) { tsTracing_setNumBounds(self, index, num_bounds); }
		public uint getNumBounds(uint index) { return tsTracing_getNumBounds(self, index); }
		public uint getBoundStride(uint index) { return tsTracing_getBoundStride(self, index); }
		public Buffer getBoundBuffer(uint index) { return new Buffer(tsTracing_getBoundBuffer(self, index)); }
		public ulong getBoundOffset(uint index) { return tsTracing_getBoundOffset(self, index); }
		public string getDescription() { return Base.getString(tsTracing_getDescription(self)); }
		public ulong getTracingAddress() { return tsTracing_getTracingAddress(self); }
		public ulong getBuildSize() { return tsTracing_getBuildSize(self); }
		public ulong getUpdateSize() { return tsTracing_getUpdateSize(self); }
		public ulong getMemory() { return tsTracing_getMemory(self); }
		public override string ToString() { return "Tellusim.Tracing: Valid: " + tsTracing_isValidPtr(self) + "; Owner: " + tsTracing_isOwnerPtr(self) + "; Const: " + tsTracing_isConstPtr(self) + "; Count: " + tsTracing_getCountPtr(self) + "; Internal: 0x" + tsTracing_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Tracing ptr) { return (ptr != null && tsTracing_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_new();
		[DllImport(Base.Import)] private static extern void tsTracing_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTracing_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsTracing_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTracing_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isBuilt(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_create(HandleRef self, Type type, Flags flags);
		[DllImport(Base.Import)] private static extern Type tsTracing_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getTypeName_TT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isInstanceType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isTriangleType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isBoundType(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTracing_isGeometryType(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_setParameters(HandleRef self, HandleRef tracing);
		[DllImport(Base.Import)] private static extern uint tsTracing_getNumGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_setInstanceBuffer_uBz(HandleRef self, uint num_instances, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setInstanceBuffer_Bz(HandleRef self, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setNumInstances(HandleRef self, uint num_instances);
		[DllImport(Base.Import)] private static extern uint tsTracing_getNumInstances(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getInstanceBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getInstanceOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTracing_setIndirectBuffer(HandleRef self, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getIndirectBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getIndirectOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTracing_addVertexBuffer(HandleRef self, uint num_vertices, Format format, ulong stride, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setVertexBuffer_uuBz(HandleRef self, uint index, uint num_vertices, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setVertexBuffer_uBz(HandleRef self, uint index, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setNumVertices(HandleRef self, uint index, uint num_vertices);
		[DllImport(Base.Import)] private static extern uint tsTracing_getNumVertices(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Format tsTracing_getVertexFormat(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTracing_getVertexStride(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getVertexBuffer(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getVertexOffset(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTracing_addIndexBuffer(HandleRef self, uint num_indices, Format format, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setIndexBuffer_uuBz(HandleRef self, uint index, uint num_indices, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setIndexBuffer_uBz(HandleRef self, uint index, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setNumIndices(HandleRef self, uint index, uint num_indices);
		[DllImport(Base.Import)] private static extern uint tsTracing_getNumIndices(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Format tsTracing_getIndexFormat(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getIndexBuffer(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getIndexOffset(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTracing_addBoundBuffer(HandleRef self, uint num_bounds, ulong stride, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setBoundBuffer_uuBz(HandleRef self, uint index, uint num_bounds, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setBoundBuffer_uBz(HandleRef self, uint index, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern void tsTracing_setNumBounds(HandleRef self, uint index, uint num_bounds);
		[DllImport(Base.Import)] private static extern uint tsTracing_getNumBounds(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTracing_getBoundStride(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getBoundBuffer(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getBoundOffset(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTracing_getDescription(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getTracingAddress(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getBuildSize(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getUpdateSize(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsTracing_getMemory(HandleRef self);
		[StructLayout(LayoutKind.Sequential, Pack=16)] public struct Instance {
			public Matrix4x3f transform;
			public uint data;
			public uint mask;
			public uint flags;
			public uint offset;
			public IntPtr tracing;
			public IntPtr padding;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("transform: {0}\n", transform);
				ret += System.String.Format("data: {0}\n", data);
				ret += System.String.Format("mask: {0}\n", mask);
				ret += System.String.Format("flags: {0}\n", flags);
				ret += System.String.Format("offset: {0}\n", offset);
				ret += System.String.Format("tracing: {0}", tracing);
				return ret;
			}
		}
		[StructLayout(LayoutKind.Sequential)] public struct BuildIndirect {
			public uint num_primitives;
			public uint base_primitive;
			public uint base_vertex;
			public uint base_transform;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("num_primitives: {0}\n", num_primitives);
				ret += System.String.Format("base_primitive: {0}\n", base_primitive);
				ret += System.String.Format("base_vertex: {0}\n", base_vertex);
				ret += System.String.Format("base_transform: {0}", base_transform);
				return ret;
			}
		}
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Tracing
	public sealed class D3D12Tracing : Tracing {
		public D3D12Tracing() { self = new HandleRef(this, tsD3D12Tracing_new()); owner = true; }
		public D3D12Tracing(D3D12Tracing ptr) { self = new HandleRef(this, tsD3D12Tracing_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Tracing(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Tracing_isOwnerPtr(self); }
		public D3D12Tracing(Tracing ptr) { self = new HandleRef(this, tsD3D12Tracing_castTracingPtr(ptr.getSelf())); }
		public Tracing toTracing() { return new Tracing(tsD3D12Tracing_baseTracingPtr(self)); }
		public static new D3D12Tracing Null() { return new D3D12Tracing(IntPtr.Zero); }
		public IntPtr getGeometryDesc(uint index) { return tsD3D12Tracing_getGeometryDesc(self, index); }
		public IntPtr getBuildInputs() { return tsD3D12Tracing_getBuildInputs(self); }
		public IntPtr getPrebuildInfo() { return tsD3D12Tracing_getPrebuildInfo(self); }
		public IntPtr getBuildDesc() { return tsD3D12Tracing_getBuildDesc(self); }
		public Buffer getTracingBuffer() { return new Buffer(tsD3D12Tracing_getTracingBuffer(self)); }
		public ulong getShaderResourceView() { return tsD3D12Tracing_getShaderResourceView(self); }
		public override string ToString() { return "Tellusim.D3D12Tracing: Valid: " + tsD3D12Tracing_isValidPtr(self) + "; Owner: " + tsD3D12Tracing_isOwnerPtr(self) + "; Const: " + tsD3D12Tracing_isConstPtr(self) + "; Count: " + tsD3D12Tracing_getCountPtr(self) + "; Internal: 0x" + tsD3D12Tracing_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Tracing ptr) { return (ptr != null && tsD3D12Tracing_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Tracing_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Tracing_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Tracing_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Tracing_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Tracing_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Tracing_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Tracing_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Tracing_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Tracing_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Tracing_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Tracing_equalTracingPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_castTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_baseTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_getGeometryDesc(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_getBuildInputs(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_getPrebuildInfo(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_getBuildDesc(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Tracing_getTracingBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Tracing_getShaderResourceView(HandleRef self);
	}
	
	// Tellusim::MTLTracing
	public sealed class MTLTracing : Tracing {
		public MTLTracing() { self = new HandleRef(this, tsMTLTracing_new()); owner = true; }
		public MTLTracing(MTLTracing ptr) { self = new HandleRef(this, tsMTLTracing_copyPtr(ptr.getSelf())); owner = true; }
		public MTLTracing(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLTracing_isOwnerPtr(self); }
		public MTLTracing(Tracing ptr) { self = new HandleRef(this, tsMTLTracing_castTracingPtr(ptr.getSelf())); }
		public Tracing toTracing() { return new Tracing(tsMTLTracing_baseTracingPtr(self)); }
		public static new MTLTracing Null() { return new MTLTracing(IntPtr.Zero); }
		public IntPtr getGeometryDesc(uint index) { return tsMTLTracing_getGeometryDesc(self, index); }
		public IntPtr getPrimitiveDesc() { return tsMTLTracing_getPrimitiveDesc(self); }
		public IntPtr getInstanceDesc() { return tsMTLTracing_getInstanceDesc(self); }
		public IntPtr getAccelerationStructure() { return tsMTLTracing_getAccelerationStructure(self); }
		public override string ToString() { return "Tellusim.MTLTracing: Valid: " + tsMTLTracing_isValidPtr(self) + "; Owner: " + tsMTLTracing_isOwnerPtr(self) + "; Const: " + tsMTLTracing_isConstPtr(self) + "; Count: " + tsMTLTracing_getCountPtr(self) + "; Internal: 0x" + tsMTLTracing_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLTracing ptr) { return (ptr != null && tsMTLTracing_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_new();
		[DllImport(Base.Import)] private static extern void tsMTLTracing_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTracing_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTracing_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTracing_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTracing_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTracing_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTracing_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTracing_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTracing_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLTracing_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTracing_equalTracingPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_castTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_baseTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_getGeometryDesc(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_getPrimitiveDesc(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_getInstanceDesc(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTracing_getAccelerationStructure(HandleRef self);
	}
	
	// Tellusim::VKTracing
	public sealed class VKTracing : Tracing {
		public VKTracing() { self = new HandleRef(this, tsVKTracing_new()); owner = true; }
		public VKTracing(VKTracing ptr) { self = new HandleRef(this, tsVKTracing_copyPtr(ptr.getSelf())); owner = true; }
		public VKTracing(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKTracing_isOwnerPtr(self); }
		public VKTracing(Tracing ptr) { self = new HandleRef(this, tsVKTracing_castTracingPtr(ptr.getSelf())); }
		public Tracing toTracing() { return new Tracing(tsVKTracing_baseTracingPtr(self)); }
		public static new VKTracing Null() { return new VKTracing(IntPtr.Zero); }
		public IntPtr getBuildGeometryInfo() { return tsVKTracing_getBuildGeometryInfo(self); }
		public IntPtr getBuildSizeInfo() { return tsVKTracing_getBuildSizeInfo(self); }
		public Buffer getTracingBuffer() { return new Buffer(tsVKTracing_getTracingBuffer(self)); }
		public IntPtr getAccelerationStructure() { return tsVKTracing_getAccelerationStructure(self); }
		public override string ToString() { return "Tellusim.VKTracing: Valid: " + tsVKTracing_isValidPtr(self) + "; Owner: " + tsVKTracing_isOwnerPtr(self) + "; Const: " + tsVKTracing_isConstPtr(self) + "; Count: " + tsVKTracing_getCountPtr(self) + "; Internal: 0x" + tsVKTracing_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKTracing ptr) { return (ptr != null && tsVKTracing_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_new();
		[DllImport(Base.Import)] private static extern void tsVKTracing_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTracing_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTracing_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTracing_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTracing_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTracing_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTracing_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTracing_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTracing_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKTracing_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTracing_equalTracingPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_castTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_baseTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_getBuildGeometryInfo(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_getBuildSizeInfo(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_getTracingBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTracing_getAccelerationStructure(HandleRef self);
	}
	
	// Tellusim::FUTracing
	public sealed class FUTracing : Tracing {
		public FUTracing() { self = new HandleRef(this, tsFUTracing_new()); owner = true; }
		public FUTracing(Tracing[] tracings, bool owner = false) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			self = new HandleRef(this, tsFUTracing_new_cATb(tracings_, (uint)tracings.Length, owner)); owner = true;
		}
		public FUTracing(FUTracing ptr) { self = new HandleRef(this, tsFUTracing_copyPtr(ptr.getSelf())); owner = true; }
		public FUTracing(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUTracing_isOwnerPtr(self); }
		public FUTracing(Tracing ptr) { self = new HandleRef(this, tsFUTracing_castTracingPtr(ptr.getSelf())); }
		public Tracing toTracing() { return new Tracing(tsFUTracing_baseTracingPtr(self)); }
		public static new FUTracing Null() { return new FUTracing(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUTracing_setMask(self, mask); }
		public uint getMask() { return tsFUTracing_getMask(self); }
		public uint getNumTracings() { return tsFUTracing_getNumTracings(self); }
		public Tracing getTracing(uint index) { return new Tracing(tsFUTracing_getTracing_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUTracing: Valid: " + tsFUTracing_isValidPtr(self) + "; Owner: " + tsFUTracing_isOwnerPtr(self) + "; Const: " + tsFUTracing_isConstPtr(self) + "; Count: " + tsFUTracing_getCountPtr(self) + "; Internal: 0x" + tsFUTracing_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUTracing ptr) { return (ptr != null && tsFUTracing_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_new_cATb(IntPtr[] tracings, uint tracings_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUTracing_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTracing_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTracing_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTracing_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTracing_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTracing_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTracing_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTracing_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTracing_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTracing_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTracing_equalTracingPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_castTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_baseTracingPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTracing_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUTracing_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTracing_getNumTracings(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTracing_getTracing_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Target
	public class Target {
		public enum Operation : uint {
			BeginLoad = 1,
			BeginClear = 2,
			BeginDiscard = 4,
			BeginMask = 7,
			EndStore = 8,
			EndResolve = 16,
			EndDiscard = 32,
			EndMask = 56,
			OpNone = 0,
			OpLoad = 1,
			OpLoadStore = 9,
			OpClearStore = 10,
			OpClearDiscard = 34,
			OpDefault = 10,
		}
		public Target() { self = new HandleRef(this, tsTarget_new()); owner = true; }
		public Target(Target ptr) { self = new HandleRef(this, tsTarget_copyPtr(ptr.getSelf())); owner = true; }
		public Target(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsTarget_isOwnerPtr(self); }
		public static Target Null() { return new Target(IntPtr.Zero); }
		~Target() { if(owner) tsTarget_delete(self); }
		public bool equalPtr(Target ptr) { return tsTarget_equalPtr(self, ptr.getSelf()); }
		public Target clonePtr() { return new Target(tsTarget_clonePtr(self)); }
		public void clearPtr() { tsTarget_clearPtr(self); }
		public void destroyPtr() { tsTarget_destroyPtr(self); }
		public void acquirePtr() { tsTarget_acquirePtr(self); }
		public void unacquirePtr() { tsTarget_unacquirePtr(self); }
		public bool isValidPtr() { return tsTarget_isValidPtr(self); }
		public bool isOwnerPtr() { return tsTarget_isOwnerPtr(self); }
		public bool isConstPtr() { return tsTarget_isConstPtr(self); }
		public uint getCountPtr() { return tsTarget_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsTarget_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsTarget_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsTarget_getPlatformName(self)); }
		public uint getIndex() { return tsTarget_getIndex(self); }
		public bool begin(Fence fence) { return tsTarget_begin_F(self, fence.getSelf()); }
		public bool begin() { return tsTarget_begin(self); }
		public void end(Fence fence) { tsTarget_end_F(self, fence.getSelf()); }
		public void end() { tsTarget_end(self); }
		public void swap(Surface surface) { tsTarget_swap(self, surface.getSelf()); }
		public bool isEnabled() { return tsTarget_isEnabled(self); }
		public Format getColorFormat(uint index = 0) { return tsTarget_getColorFormat(self, index); }
		public Format getDepthFormat() { return tsTarget_getDepthFormat(self); }
		public uint getMultisample() { return tsTarget_getMultisample(self); }
		public bool hasMultisample() { return tsTarget_hasMultisample(self); }
		public bool isFlipped() { return tsTarget_isFlipped(self); }
		public bool isAtomic() { return tsTarget_isAtomic(self); }
		public uint getWidth() { return tsTarget_getWidth(self); }
		public uint getHeight() { return tsTarget_getHeight(self); }
		public uint getDepth() { return tsTarget_getDepth(self); }
		public uint getFaces() { return tsTarget_getFaces(self); }
		public uint getLayers() { return tsTarget_getLayers(self); }
		public uint getMipmaps() { return tsTarget_getMipmaps(self); }
		public void setClearColor(in Color color) { tsTarget_setClearColor_cC(self, in color); }
		public void setClearColor(uint index, in Color color) { tsTarget_setClearColor_ucC(self, index, in color); }
		public void setClearColor(float r, float g, float b, float a) { tsTarget_setClearColor_ffff(self, r, g, b, a); }
		public void setClearColor(uint index, float r, float g, float b, float a) { tsTarget_setClearColor_uffff(self, index, r, g, b, a); }
		public void setColorTexture(Texture texture, Operation op, in Slice slice) { tsTarget_setColorTexture_TTOcS(self, texture.getSelf(), op, in slice); }
		public void setColorTexture(uint index, Texture texture, Operation op, in Slice slice) { tsTarget_setColorTexture_uTTOcS(self, index, texture.getSelf(), op, in slice); }
		public void setColorResolve(Texture texture, in Slice slice) { tsTarget_setColorResolve_TcS(self, texture.getSelf(), in slice); }
		public void setColorResolve(uint index, Texture texture, in Slice slice) { tsTarget_setColorResolve_uTcS(self, index, texture.getSelf(), in slice); }
		public uint getNumTargets() { return tsTarget_getNumTargets(self); }
		public Color getClearColor(uint index = 0) { return tsTarget_getClearColor(self, index); }
		public Operation getColorOp(uint index = 0) { return tsTarget_getColorOp(self, index); }
		public Texture getColorTexture(uint index) { return new Texture(tsTarget_getColorTexture(self, index)); }
		public Texture getColorResolve(uint index) { return new Texture(tsTarget_getColorResolve(self, index)); }
		public Slice getColorTextureSlice(uint index) { return tsTarget_getColorTextureSlice(self, index); }
		public Slice getColorResolveSlice(uint index) { return tsTarget_getColorResolveSlice(self, index); }
		public void setClearDepth(float depth, uint stencil = 0) { tsTarget_setClearDepth(self, depth, stencil); }
		public void setDepthTexture(Texture texture, Operation op, in Slice slice) { tsTarget_setDepthTexture(self, texture.getSelf(), op, in slice); }
		public void setDepthResolve(Texture texture, in Slice slice) { tsTarget_setDepthResolve(self, texture.getSelf(), in slice); }
		public float getClearDepth() { return tsTarget_getClearDepth(self); }
		public uint getClearStencil() { return tsTarget_getClearStencil(self); }
		public Operation getDepthOp() { return tsTarget_getDepthOp(self); }
		public Texture getDepthTexture() { return new Texture(tsTarget_getDepthTexture(self)); }
		public Texture getDepthResolve() { return new Texture(tsTarget_getDepthResolve(self)); }
		public Slice getDepthTextureSlice() { return tsTarget_getDepthTextureSlice(self); }
		public Slice getDepthResolveSlice() { return tsTarget_getDepthResolveSlice(self); }
		public override string ToString() { return "Tellusim.Target: Valid: " + tsTarget_isValidPtr(self) + "; Owner: " + tsTarget_isOwnerPtr(self) + "; Const: " + tsTarget_isConstPtr(self) + "; Count: " + tsTarget_getCountPtr(self) + "; Internal: 0x" + tsTarget_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Target ptr) { return (ptr != null && tsTarget_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_new();
		[DllImport(Base.Import)] private static extern void tsTarget_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsTarget_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_begin_F(HandleRef self, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsTarget_begin(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_end_F(HandleRef self, HandleRef fence);
		[DllImport(Base.Import)] private static extern void tsTarget_end(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_swap(HandleRef self, HandleRef surface);
		[DllImport(Base.Import)] private static extern bool tsTarget_isEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsTarget_getColorFormat(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Format tsTarget_getDepthFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_hasMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_isFlipped(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTarget_isAtomic(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getDepth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getFaces(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getMipmaps(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTarget_setClearColor_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern void tsTarget_setClearColor_ucC(HandleRef self, uint index, in Color color);
		[DllImport(Base.Import)] private static extern void tsTarget_setClearColor_ffff(HandleRef self, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern void tsTarget_setClearColor_uffff(HandleRef self, uint index, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern void tsTarget_setColorTexture_TTOcS(HandleRef self, HandleRef texture, Operation op, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsTarget_setColorTexture_uTTOcS(HandleRef self, uint index, HandleRef texture, Operation op, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsTarget_setColorResolve_TcS(HandleRef self, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsTarget_setColorResolve_uTcS(HandleRef self, uint index, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern uint tsTarget_getNumTargets(HandleRef self);
		[DllImport(Base.Import)] private static extern Color tsTarget_getClearColor(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Operation tsTarget_getColorOp(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_getColorTexture(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_getColorResolve(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Slice tsTarget_getColorTextureSlice(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Slice tsTarget_getColorResolveSlice(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsTarget_setClearDepth(HandleRef self, float depth, uint stencil);
		[DllImport(Base.Import)] private static extern void tsTarget_setDepthTexture(HandleRef self, HandleRef texture, Operation op, in Slice slice);
		[DllImport(Base.Import)] private static extern void tsTarget_setDepthResolve(HandleRef self, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern float tsTarget_getClearDepth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTarget_getClearStencil(HandleRef self);
		[DllImport(Base.Import)] private static extern Operation tsTarget_getDepthOp(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_getDepthTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTarget_getDepthResolve(HandleRef self);
		[DllImport(Base.Import)] private static extern Slice tsTarget_getDepthTextureSlice(HandleRef self);
		[DllImport(Base.Import)] private static extern Slice tsTarget_getDepthResolveSlice(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Target
	public sealed class D3D12Target : Target {
		public D3D12Target() { self = new HandleRef(this, tsD3D12Target_new()); owner = true; }
		public D3D12Target(D3D12Target ptr) { self = new HandleRef(this, tsD3D12Target_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Target(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Target_isOwnerPtr(self); }
		public D3D12Target(Target ptr) { self = new HandleRef(this, tsD3D12Target_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsD3D12Target_baseTargetPtr(self)); }
		public static new D3D12Target Null() { return new D3D12Target(IntPtr.Zero); }
		public ulong[] getRenderTargetViews() { return tsD3D12Target_getRenderTargetViews(self); }
		public ulong getDepthStencilView() { return tsD3D12Target_getDepthStencilView(self); }
		public override string ToString() { return "Tellusim.D3D12Target: Valid: " + tsD3D12Target_isValidPtr(self) + "; Owner: " + tsD3D12Target_isOwnerPtr(self) + "; Const: " + tsD3D12Target_isConstPtr(self) + "; Count: " + tsD3D12Target_getCountPtr(self) + "; Internal: 0x" + tsD3D12Target_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Target ptr) { return (ptr != null && tsD3D12Target_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Target_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Target_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Target_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Target_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Target_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Target_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Target_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Target_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Target_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Target_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Target_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Target_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Target_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Target_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Target_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Target_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Target_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong[] tsD3D12Target_getRenderTargetViews(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Target_getDepthStencilView(HandleRef self);
	}
	
	// Tellusim::D3D11Target
	public sealed class D3D11Target : Target {
		public D3D11Target() { self = new HandleRef(this, tsD3D11Target_new()); owner = true; }
		public D3D11Target(D3D11Target ptr) { self = new HandleRef(this, tsD3D11Target_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Target(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Target_isOwnerPtr(self); }
		public D3D11Target(Target ptr) { self = new HandleRef(this, tsD3D11Target_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsD3D11Target_baseTargetPtr(self)); }
		public static new D3D11Target Null() { return new D3D11Target(IntPtr.Zero); }
		public IntPtr[] getRenderTargetViews() { return tsD3D11Target_getRenderTargetViews(self); }
		public IntPtr getDepthStencilView() { return tsD3D11Target_getDepthStencilView(self); }
		public override string ToString() { return "Tellusim.D3D11Target: Valid: " + tsD3D11Target_isValidPtr(self) + "; Owner: " + tsD3D11Target_isOwnerPtr(self) + "; Const: " + tsD3D11Target_isConstPtr(self) + "; Count: " + tsD3D11Target_getCountPtr(self) + "; Internal: 0x" + tsD3D11Target_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Target ptr) { return (ptr != null && tsD3D11Target_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_new();
		[DllImport(Base.Import)] private static extern void tsD3D11Target_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Target_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Target_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Target_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Target_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Target_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Target_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Target_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Target_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Target_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Target_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr[] tsD3D11Target_getRenderTargetViews(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Target_getDepthStencilView(HandleRef self);
	}
	
	// Tellusim::MTLTarget
	public sealed class MTLTarget : Target {
		public MTLTarget() { self = new HandleRef(this, tsMTLTarget_new()); owner = true; }
		public MTLTarget(MTLTarget ptr) { self = new HandleRef(this, tsMTLTarget_copyPtr(ptr.getSelf())); owner = true; }
		public MTLTarget(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLTarget_isOwnerPtr(self); }
		public MTLTarget(Target ptr) { self = new HandleRef(this, tsMTLTarget_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsMTLTarget_baseTargetPtr(self)); }
		public static new MTLTarget Null() { return new MTLTarget(IntPtr.Zero); }
		public IntPtr getDescriptor() { return tsMTLTarget_getDescriptor(self); }
		public override string ToString() { return "Tellusim.MTLTarget: Valid: " + tsMTLTarget_isValidPtr(self) + "; Owner: " + tsMTLTarget_isOwnerPtr(self) + "; Const: " + tsMTLTarget_isConstPtr(self) + "; Count: " + tsMTLTarget_getCountPtr(self) + "; Internal: 0x" + tsMTLTarget_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLTarget ptr) { return (ptr != null && tsMTLTarget_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_new();
		[DllImport(Base.Import)] private static extern void tsMTLTarget_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTarget_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTarget_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTarget_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTarget_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLTarget_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTarget_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTarget_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTarget_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLTarget_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLTarget_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLTarget_getDescriptor(HandleRef self);
	}
	
	// Tellusim::VKTarget
	public sealed class VKTarget : Target {
		public VKTarget() { self = new HandleRef(this, tsVKTarget_new()); owner = true; }
		public VKTarget(VKTarget ptr) { self = new HandleRef(this, tsVKTarget_copyPtr(ptr.getSelf())); owner = true; }
		public VKTarget(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKTarget_isOwnerPtr(self); }
		public VKTarget(Target ptr) { self = new HandleRef(this, tsVKTarget_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsVKTarget_baseTargetPtr(self)); }
		public static new VKTarget Null() { return new VKTarget(IntPtr.Zero); }
		public IntPtr getRenderPass() { return tsVKTarget_getRenderPass(self); }
		public IntPtr getFramebuffer() { return tsVKTarget_getFramebuffer(self); }
		public override string ToString() { return "Tellusim.VKTarget: Valid: " + tsVKTarget_isValidPtr(self) + "; Owner: " + tsVKTarget_isOwnerPtr(self) + "; Const: " + tsVKTarget_isConstPtr(self) + "; Count: " + tsVKTarget_getCountPtr(self) + "; Internal: 0x" + tsVKTarget_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKTarget ptr) { return (ptr != null && tsVKTarget_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_new();
		[DllImport(Base.Import)] private static extern void tsVKTarget_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTarget_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTarget_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTarget_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTarget_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKTarget_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTarget_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTarget_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTarget_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKTarget_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKTarget_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_getRenderPass(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKTarget_getFramebuffer(HandleRef self);
	}
	
	// Tellusim::GLTarget
	public sealed class GLTarget : Target {
		public GLTarget() { self = new HandleRef(this, tsGLTarget_new()); owner = true; }
		public GLTarget(GLTarget ptr) { self = new HandleRef(this, tsGLTarget_copyPtr(ptr.getSelf())); owner = true; }
		public GLTarget(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLTarget_isOwnerPtr(self); }
		public GLTarget(Target ptr) { self = new HandleRef(this, tsGLTarget_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsGLTarget_baseTargetPtr(self)); }
		public static new GLTarget Null() { return new GLTarget(IntPtr.Zero); }
		public uint getFramebufferID() { return tsGLTarget_getFramebufferID(self); }
		public override string ToString() { return "Tellusim.GLTarget: Valid: " + tsGLTarget_isValidPtr(self) + "; Owner: " + tsGLTarget_isOwnerPtr(self) + "; Const: " + tsGLTarget_isConstPtr(self) + "; Count: " + tsGLTarget_getCountPtr(self) + "; Internal: 0x" + tsGLTarget_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLTarget ptr) { return (ptr != null && tsGLTarget_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLTarget_new();
		[DllImport(Base.Import)] private static extern void tsGLTarget_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTarget_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTarget_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTarget_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTarget_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTarget_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTarget_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLTarget_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTarget_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTarget_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTarget_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLTarget_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTarget_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLTarget_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTarget_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLTarget_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLTarget_getFramebufferID(HandleRef self);
	}
	
	// Tellusim::GLESTarget
	public sealed class GLESTarget : Target {
		public GLESTarget() { self = new HandleRef(this, tsGLESTarget_new()); owner = true; }
		public GLESTarget(GLESTarget ptr) { self = new HandleRef(this, tsGLESTarget_copyPtr(ptr.getSelf())); owner = true; }
		public GLESTarget(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLESTarget_isOwnerPtr(self); }
		public GLESTarget(Target ptr) { self = new HandleRef(this, tsGLESTarget_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsGLESTarget_baseTargetPtr(self)); }
		public static new GLESTarget Null() { return new GLESTarget(IntPtr.Zero); }
		public uint getFramebufferID() { return tsGLESTarget_getFramebufferID(self); }
		public override string ToString() { return "Tellusim.GLESTarget: Valid: " + tsGLESTarget_isValidPtr(self) + "; Owner: " + tsGLESTarget_isOwnerPtr(self) + "; Const: " + tsGLESTarget_isConstPtr(self) + "; Count: " + tsGLESTarget_getCountPtr(self) + "; Internal: 0x" + tsGLESTarget_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLESTarget ptr) { return (ptr != null && tsGLESTarget_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTarget_new();
		[DllImport(Base.Import)] private static extern void tsGLESTarget_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTarget_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTarget_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTarget_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTarget_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTarget_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTarget_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESTarget_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTarget_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTarget_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTarget_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESTarget_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTarget_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESTarget_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTarget_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESTarget_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESTarget_getFramebufferID(HandleRef self);
	}
	
	// Tellusim::FUTarget
	public sealed class FUTarget : Target {
		public FUTarget() { self = new HandleRef(this, tsFUTarget_new()); owner = true; }
		public FUTarget(Target[] targets, bool owner = false) {
			IntPtr[] targets_ = new IntPtr[targets.Length];
			for(int i = 0; i < targets.Length; i++) targets_[i] = targets[i].getSelfPtr();
			self = new HandleRef(this, tsFUTarget_new_cATb(targets_, (uint)targets.Length, owner)); owner = true;
		}
		public FUTarget(FUTarget ptr) { self = new HandleRef(this, tsFUTarget_copyPtr(ptr.getSelf())); owner = true; }
		public FUTarget(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUTarget_isOwnerPtr(self); }
		public FUTarget(Target ptr) { self = new HandleRef(this, tsFUTarget_castTargetPtr(ptr.getSelf())); }
		public Target toTarget() { return new Target(tsFUTarget_baseTargetPtr(self)); }
		public static new FUTarget Null() { return new FUTarget(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUTarget_setMask(self, mask); }
		public uint getMask() { return tsFUTarget_getMask(self); }
		public new uint getNumTargets() { return tsFUTarget_getNumTargets(self); }
		public Target getTarget(uint index) { return new Target(tsFUTarget_getTarget_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUTarget: Valid: " + tsFUTarget_isValidPtr(self) + "; Owner: " + tsFUTarget_isOwnerPtr(self) + "; Const: " + tsFUTarget_isConstPtr(self) + "; Count: " + tsFUTarget_getCountPtr(self) + "; Internal: 0x" + tsFUTarget_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUTarget ptr) { return (ptr != null && tsFUTarget_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_new_cATb(IntPtr[] targets, uint targets_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUTarget_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTarget_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTarget_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTarget_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTarget_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTarget_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTarget_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTarget_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTarget_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTarget_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTarget_equalTargetPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_castTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_baseTargetPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTarget_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUTarget_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTarget_getNumTargets(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTarget_getTarget_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Device
	public class Device {
		public Device() { self = new HandleRef(this, tsDevice_new()); owner = true; }
		public Device(Context context) { self = new HandleRef(this, tsDevice_new_C(context.getSelf())); owner = true; }
		public Device(Surface surface) { self = new HandleRef(this, tsDevice_new_S(surface.getSelf())); owner = true; }
		public Device(Window window) { self = new HandleRef(this, tsDevice_new_W(window.getSelf())); owner = true; }
		public Device(Device ptr) { self = new HandleRef(this, tsDevice_copyPtr(ptr.getSelf())); owner = true; }
		public Device(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDevice_isOwnerPtr(self); }
		public static Device Null() { return new Device(IntPtr.Zero); }
		~Device() { if(owner) tsDevice_delete(self); }
		public bool equalPtr(Device ptr) { return tsDevice_equalPtr(self, ptr.getSelf()); }
		public Device clonePtr() { return new Device(tsDevice_clonePtr(self)); }
		public void clearPtr() { tsDevice_clearPtr(self); }
		public void destroyPtr() { tsDevice_destroyPtr(self); }
		public void acquirePtr() { tsDevice_acquirePtr(self); }
		public void unacquirePtr() { tsDevice_unacquirePtr(self); }
		public bool isValidPtr() { return tsDevice_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDevice_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDevice_isConstPtr(self); }
		public uint getCountPtr() { return tsDevice_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDevice_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsDevice_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsDevice_getPlatformName(self)); }
		public uint getIndex() { return tsDevice_getIndex(self); }
		public string getName() { return Base.getString(tsDevice_getName(self)); }
		public string getVendor() { return Base.getString(tsDevice_getVendor(self)); }
		public string getVersion() { return Base.getString(tsDevice_getVersion(self)); }
		public bool hasQuery(Query.Type type) { return tsDevice_hasQuery(self, type); }
		public bool hasShader(Shader.Type type) { return tsDevice_hasShader(self, type); }
		public bool hasTarget(Format format) { return tsDevice_hasTarget(self, format); }
		public bool hasTexture(Format format) { return tsDevice_hasTexture(self, format); }
		public bool hasSurface(Format format) { return tsDevice_hasSurface(self, format); }
		public Device createDevice(uint index, uint frames = 3) { return new Device(tsDevice_createDevice(self, index, frames)); }
		public Device createCommandDevice(uint frames = 3) { return new Device(tsDevice_createCommandDevice(self, frames)); }
		public Device createComputeDevice(uint frames = 3) { return new Device(tsDevice_createComputeDevice(self, frames)); }
		public Device createCopyDevice(uint frames = 3) { return new Device(tsDevice_createCopyDevice(self, frames)); }
		public Query createQuery() { return new Query(tsDevice_createQuery_c(self)); }
		public Query createQuery(Query.Type type) { return new Query(tsDevice_createQuery_cQT(self, type)); }
		public Fence createFence() { return new Fence(tsDevice_createFence_c(self)); }
		public Fence createFence(Fence shared) { return new Fence(tsDevice_createFence_cF(self, shared.getSelf())); }
		public Fence createFence(Fence.Flags flags) { return new Fence(tsDevice_createFence_cFF(self, flags)); }
		public Buffer createBuffer() { return new Buffer(tsDevice_createBuffer_c(self)); }
		public Buffer createBuffer(Buffer shared) { return new Buffer(tsDevice_createBuffer_cB(self, shared.getSelf())); }
		public Buffer createBuffer(Buffer.Flags flags, ulong size, Format format = Format.Unknown) { return new Buffer(tsDevice_createBuffer_cBFzF(self, flags, size, format)); }
		public Buffer createBuffer(Buffer.Flags flags, IntPtr src, ulong size, Format format = Format.Unknown) { return new Buffer(tsDevice_createBuffer_cBFpzF(self, flags, src, size, format)); }
		public Buffer createBuffer<Type>(Buffer.Flags flags, Type[] src, Format format = Format.Unknown) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			Buffer ret_ = createBuffer(flags, ptr_, (ulong)size_, format);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public Sampler createSampler() { return new Sampler(tsDevice_createSampler_c(self)); }
		public Sampler createSampler(Sampler sampler) { return new Sampler(tsDevice_createSampler_ccS(self, sampler.getSelf())); }
		public Sampler createSampler(Sampler.Filter filter, Sampler.WrapMode mode = Sampler.WrapMode.Repeat, uint anisotropy = Sampler.MaxAnisotropy) { return new Sampler(tsDevice_createSampler_cSFSWMu(self, filter, mode, anisotropy)); }
		public Texture createTexture() { return new Texture(tsDevice_createTexture_c(self)); }
		public Texture createTexture(Texture shared) { return new Texture(tsDevice_createTexture_cT(self, shared.getSelf())); }
		public Texture createTexture(Texture.Type type, Format format, in Size size, uint layers, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture_cTTFcSuTF(self, type, format, in size, layers, flags)); }
		public Texture createTexture(Texture.Type type, Format format, in Size size, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture_cTTFcSTF(self, type, format, in size, flags)); }
		public Texture createTexture(Image image, Texture.Flags flags = Texture.Flags.Default, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Texture(tsDevice_createTexture_ccITFA(self, image.getSelf(), flags, ref async_));
		}
		public Texture createTexture2D(Format format, uint size, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture2D_cFuTF(self, format, size, flags)); }
		public Texture createTexture3D(Format format, uint size, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture3D_cFuTF(self, format, size, flags)); }
		public Texture createTextureCube(Format format, uint size, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTextureCube_cFuTF(self, format, size, flags)); }
		public Texture createTexture2D(Format format, uint width, uint height, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture2D_cFuuTF(self, format, width, height, flags)); }
		public Texture createTexture3D(Format format, uint width, uint height, uint depth, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture3D_cFuuuTF(self, format, width, height, depth, flags)); }
		public Texture createTexture2D(Format format, uint width, uint height, uint layers, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTexture2D_cFuuuTF(self, format, width, height, layers, flags)); }
		public Texture createTextureCube(Format format, uint size, uint layers, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDevice_createTextureCube_cFuuTF(self, format, size, layers, flags)); }
		public Texture loadTexture(string name, Texture.Flags flags = Texture.Flags.Default, Image.Flags image_flags = Image.Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Texture(tsDevice_loadTexture_csTFIFuA(self, name, flags, image_flags, offset, ref async_));
		}
		public Texture loadTexture(String name, Texture.Flags flags = Texture.Flags.Default, Image.Flags image_flags = Image.Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Texture(tsDevice_loadTexture_ccSTFIFuA(self, name.getSelf(), flags, image_flags, offset, ref async_));
		}
		public Texture loadTexture(Stream stream, Texture.Flags flags = Texture.Flags.Default, Image.Flags image_flags = Image.Flags.None, uint offset = 0, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return new Texture(tsDevice_loadTexture_cStTFIFuA(self, stream.getSelf(), flags, image_flags, offset, ref async_));
		}
		public Tracing createTracing() { return new Tracing(tsDevice_createTracing_c(self)); }
		public Tracing createTracing(Tracing tracing) { return new Tracing(tsDevice_createTracing_ccT(self, tracing.getSelf())); }
		public Tracing createTracing(uint num_instances, Buffer instance_buffer = null, ulong instance_offset = 0, Tracing.Flags flags = Tracing.Flags.Default) { return new Tracing(tsDevice_createTracing_cuBzTF(self, num_instances, (instance_buffer != null) ? instance_buffer.getSelf() : Base.Null, instance_offset, flags)); }
		public Tracing createTracing(uint num_vertices, Format vertex_format, ulong vertex_stride, uint num_indices, Format index_format, Tracing.Flags flags = Tracing.Flags.Default) { return new Tracing(tsDevice_createTracing_cuFzuFTF(self, num_vertices, vertex_format, vertex_stride, num_indices, index_format, flags)); }
		public Tracing createTracing(uint num_bounds, ulong bound_stride, Buffer bound_buffer = null, ulong bound_offset = 0, Tracing.Flags flags = Tracing.Flags.Default) { return new Tracing(tsDevice_createTracing_cuzBzTF(self, num_bounds, bound_stride, (bound_buffer != null) ? bound_buffer.getSelf() : Base.Null, bound_offset, flags)); }
		public BufferTable createBufferTable() { return new BufferTable(tsDevice_createBufferTable_c(self)); }
		public BufferTable createBufferTable(uint size) { return new BufferTable(tsDevice_createBufferTable_cu(self, size)); }
		public BufferTable createBufferTable(Buffer[] buffers, bool owner = false) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			return new BufferTable(tsDevice_createBufferTable_ccABb(self, buffers_, (uint)buffers.Length, owner));
		}
		public TextureTable createTextureTable() { return new TextureTable(tsDevice_createTextureTable_c(self)); }
		public TextureTable createTextureTable(Texture.Type type, uint size) { return new TextureTable(tsDevice_createTextureTable_cTTu(self, type, size)); }
		public TextureTable createTextureTable(Texture[] textures, bool owner = false) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			return new TextureTable(tsDevice_createTextureTable_ccATb(self, textures_, (uint)textures.Length, owner));
		}
		public Shader createShader() { return new Shader(tsDevice_createShader_c(self)); }
		public Shader loadShader(Shader.Type type, string name, string format, params object[] args) { return new Shader(tsDevice_loadShader_cSTss(self, type, name, System.String.Format(format, args))); }
		public Shader loadShaderGLSL(Shader.Type type, string name, string format, params object[] args) { return new Shader(tsDevice_loadShaderGLSL_cSTss(self, type, name, System.String.Format(format, args))); }
		public Shader loadShader(Shader.Type type, string name, String macros = null) { return new Shader(tsDevice_loadShader_cSTscS(self, type, name, (macros != null) ? macros.getSelf() : Base.Null)); }
		public Shader loadShaderGLSL(Shader.Type type, string name, String macros = null) { return new Shader(tsDevice_loadShaderGLSL_cSTscS(self, type, name, (macros != null) ? macros.getSelf() : Base.Null)); }
		public Shader loadShaderSPIRV(Shader.Type type, string name) { return new Shader(tsDevice_loadShaderSPIRV(self, type, name)); }
		public Shader createShader(Shader.Type type, string src, string format) { return new Shader(tsDevice_createShader_cSTss(self, type, src, format)); }
		public Shader createShaderGLSL(Shader.Type type, string src, string format) { return new Shader(tsDevice_createShaderGLSL_cSTss(self, type, src, format)); }
		public Shader createShader(Shader.Type type, string src, String macros = null) { return new Shader(tsDevice_createShader_cSTscS(self, type, src, (macros != null) ? macros.getSelf() : Base.Null)); }
		public Shader createShaderGLSL(Shader.Type type, string src, String macros = null) { return new Shader(tsDevice_createShaderGLSL_cSTscS(self, type, src, (macros != null) ? macros.getSelf() : Base.Null)); }
		public Shader createShaderSPIRV(Shader.Type type, uint[] data) { return new Shader(tsDevice_createShaderSPIRV(self, type, data, (uint)data.Length)); }
		public Kernel createKernel() { return new Kernel(tsDevice_createKernel_c(self)); }
		public Kernel createKernel(Kernel kernel) { return new Kernel(tsDevice_createKernel_ccK(self, kernel.getSelf())); }
		public void releaseKernel(Kernel kernel) { tsDevice_releaseKernel(self, kernel.getSelf()); }
		public Pipeline createPipeline() { return new Pipeline(tsDevice_createPipeline_c(self)); }
		public Pipeline createPipeline(Pipeline pipeline) { return new Pipeline(tsDevice_createPipeline_ccP(self, pipeline.getSelf())); }
		public void releasePipeline(Pipeline pipeline) { tsDevice_releasePipeline(self, pipeline.getSelf()); }
		public Traversal createTraversal() { return new Traversal(tsDevice_createTraversal_c(self)); }
		public Traversal createTraversal(Traversal traversal) { return new Traversal(tsDevice_createTraversal_ccT(self, traversal.getSelf())); }
		public void releaseTraversal(Traversal traversal) { tsDevice_releaseTraversal(self, traversal.getSelf()); }
		public Target createTarget() { return new Target(tsDevice_createTarget_c(self)); }
		public Target createTarget(Surface surface) { return new Target(tsDevice_createTarget_cS(self, surface.getSelf())); }
		public Target createTarget(Window window) { return new Target(tsDevice_createTarget_cW(self, window.getSelf())); }
		public Compute createCompute() { return new Compute(tsDevice_createCompute(self)); }
		public Command createCommand() { return new Command(tsDevice_createCommand_c(self)); }
		public Command createCommand(Target target) { return new Command(tsDevice_createCommand_cT(self, target.getSelf())); }
		public bool setBuffer(Buffer buffer, ulong offset, IntPtr src, ulong size) { return tsDevice_setBuffer_cBzpz(self, buffer.getSelf(), offset, src, size); }
		public bool setBuffer<Type>(Buffer buffer, ulong offset, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = setBuffer(buffer, offset, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool setBuffer(Buffer buffer, IntPtr src, ulong size) { return tsDevice_setBuffer_cBpz(self, buffer.getSelf(), src, size); }
		public bool setBuffer<Type>(Buffer buffer, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = setBuffer(buffer, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool setBuffer(Buffer buffer, IntPtr src) { return tsDevice_setBuffer_cBp(self, buffer.getSelf(), src); }
		public bool getBuffer(Buffer buffer, ulong offset, IntPtr dest, ulong size) { return tsDevice_getBuffer_cBzprz(self, buffer.getSelf(), offset, dest, size); }
		public bool getBuffer<Type>(Buffer buffer, ulong offset, ref Type[] dest) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			bool ret_ = getBuffer(buffer, offset, ptr_, (ulong)size_);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool getBuffer(Buffer buffer, IntPtr dest, ulong size) { return tsDevice_getBuffer_cBprz(self, buffer.getSelf(), dest, size); }
		public bool getBuffer<Type>(Buffer buffer, ref Type[] dest) {
			int stride_ = Marshal.SizeOf(dest[0]);
			int size_ = stride_ * dest.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			bool ret_ = getBuffer(buffer, ptr_, (ulong)size_);
			Base.setData(ref dest, ptr_, stride_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool getBuffer(Buffer buffer, IntPtr dest) { return tsDevice_getBuffer_cBpr(self, buffer.getSelf(), dest); }
		public IntPtr mapBuffer(Buffer buffer, ulong offset, ulong size) { return tsDevice_mapBuffer_cBzz(self, buffer.getSelf(), offset, size); }
		public IntPtr mapBuffer(Buffer buffer, ulong size) { return tsDevice_mapBuffer_cBz(self, buffer.getSelf(), size); }
		public IntPtr mapBuffer(Buffer buffer) { return tsDevice_mapBuffer_cB(self, buffer.getSelf()); }
		public bool unmapBuffer(Buffer buffer) { return tsDevice_unmapBuffer(self, buffer.getSelf()); }
		public bool copyBuffer(Buffer buffer, ulong dest_offset, Buffer src, ulong src_offset, ulong size) { return tsDevice_copyBuffer_cBzBzz(self, buffer.getSelf(), dest_offset, src.getSelf(), src_offset, size); }
		public bool copyBuffer(Buffer buffer, ulong dest_offset, Buffer src, ulong size) { return tsDevice_copyBuffer_cBzBz(self, buffer.getSelf(), dest_offset, src.getSelf(), size); }
		public bool copyBuffer(Buffer buffer, Buffer src, ulong size) { return tsDevice_copyBuffer_cBBz(self, buffer.getSelf(), src.getSelf(), size); }
		public bool copyBuffer(Buffer buffer, Buffer src) { return tsDevice_copyBuffer_cBB(self, buffer.getSelf(), src.getSelf()); }
		public bool clearBuffer(Buffer buffer, Format format, ulong offset, IntPtr src, ulong size) { return tsDevice_clearBuffer_cBFzpz(self, buffer.getSelf(), format, offset, src, size); }
		public bool clearBuffer<Type>(Buffer buffer, Format format, ulong offset, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = clearBuffer(buffer, format, offset, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool clearBuffer(Buffer buffer, Format format, IntPtr src, ulong size) { return tsDevice_clearBuffer_cBFpz(self, buffer.getSelf(), format, src, size); }
		public bool clearBuffer<Type>(Buffer buffer, Format format, Type[] src) {
			int stride_ = Marshal.SizeOf(src[0]);
			int size_ = stride_ * src.Length;
			IntPtr ptr_ = Marshal.AllocHGlobal(size_);
			Base.getData(src, ptr_, stride_);
			bool ret_ = clearBuffer(buffer, format, ptr_, (ulong)size_);
			Marshal.FreeHGlobal(ptr_);
			return ret_;
		}
		public bool clearBuffer(Buffer buffer, Format format, IntPtr src) { return tsDevice_clearBuffer_cBFp(self, buffer.getSelf(), format, src); }
		public bool clearBuffer(Buffer buffer) { return tsDevice_clearBuffer_cB(self, buffer.getSelf()); }
		public bool bindBuffer(Buffer buffer, ulong[] offsets, ulong[] sizes, bool commit, Fence fence) { return tsDevice_bindBuffer_cBcAcAbF(self, buffer.getSelf(), offsets, (uint)offsets.Length, sizes, (uint)sizes.Length, commit, fence.getSelf()); }
		public bool bindBuffer(Buffer buffer, ulong[] offsets, ulong[] sizes, bool commit) { return tsDevice_bindBuffer_cBcAcAb(self, buffer.getSelf(), offsets, (uint)offsets.Length, sizes, (uint)sizes.Length, commit); }
		public bool bindBuffer(Buffer buffer, ulong offset, ulong size, bool commit, Fence fence) { return tsDevice_bindBuffer_cBzzbF(self, buffer.getSelf(), offset, size, commit, fence.getSelf()); }
		public bool bindBuffer(Buffer buffer, ulong offset, ulong size, bool commit) { return tsDevice_bindBuffer_cBzzb(self, buffer.getSelf(), offset, size, commit); }
		public bool flushBuffer(Buffer buffer, Buffer.Flags flags = Buffer.Flags.None) { return tsDevice_flushBuffer(self, buffer.getSelf(), flags); }
		public bool flushBuffers(Buffer[] buffers, Buffer.Flags flags = Buffer.Flags.None) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			return tsDevice_flushBuffers_ccABBF(self, buffers_, (uint)buffers.Length, flags);
		}
		public void releaseBuffer(Buffer buffer) { tsDevice_releaseBuffer(self, buffer.getSelf()); }
		public void releaseSampler(Sampler sampler) { tsDevice_releaseSampler(self, sampler.getSelf()); }
		public bool setTexture(Texture texture, in Origin dest_origin, in Slice dest_slice, Image image, in Slice src_slice) { return tsDevice_setTexture_cTcOcScIcS(self, texture.getSelf(), in dest_origin, in dest_slice, image.getSelf(), in src_slice); }
		public bool setTexture(Texture texture, in Origin dest_origin, Image image) { return tsDevice_setTexture_cTcOcI(self, texture.getSelf(), in dest_origin, image.getSelf()); }
		public bool setTexture(Texture texture, in Slice dest_slice, Image image) { return tsDevice_setTexture_cTcScI(self, texture.getSelf(), in dest_slice, image.getSelf()); }
		public bool setTexture(Texture texture, Image image) { return tsDevice_setTexture_cTcI(self, texture.getSelf(), image.getSelf()); }
		public bool getTexture(Texture texture, in Slice src_slice, Image image, in Slice dest_slice) { return tsDevice_getTexture_cTcSIcS(self, texture.getSelf(), in src_slice, image.getSelf(), in dest_slice); }
		public bool getTexture(Texture texture, Image image, in Slice dest_slice) { return tsDevice_getTexture_cTIcS(self, texture.getSelf(), image.getSelf(), in dest_slice); }
		public bool getTexture(Texture texture, Image image) { return tsDevice_getTexture_cTI(self, texture.getSelf(), image.getSelf()); }
		public bool copyTexture(Texture texture, in Origin dest_origin, in Slice dest_slice, Texture src, in Region src_region, in Slice src_slice) { return tsDevice_copyTexture_cTcOcSTcRcS(self, texture.getSelf(), in dest_origin, in dest_slice, src.getSelf(), in src_region, in src_slice); }
		public bool copyTexture(Texture texture, in Origin dest_origin, Texture src, in Region src_region) { return tsDevice_copyTexture_cTcOTcR(self, texture.getSelf(), in dest_origin, src.getSelf(), in src_region); }
		public bool copyTexture(Texture texture, in Slice dest_slice, Texture src, in Slice src_slice) { return tsDevice_copyTexture_cTcSTcS(self, texture.getSelf(), in dest_slice, src.getSelf(), in src_slice); }
		public bool copyTexture(Texture texture, Texture src) { return tsDevice_copyTexture_cTT(self, texture.getSelf(), src.getSelf()); }
		public bool clearTexture(Texture texture, in Region region, in Slice slice, IntPtr src) { return tsDevice_clearTexture_cTcRcSp(self, texture.getSelf(), in region, in slice, src); }
		public bool clearTexture(Texture texture, in Region region, IntPtr src) { return tsDevice_clearTexture_cTcRp(self, texture.getSelf(), in region, src); }
		public bool clearTexture(Texture texture, in Slice slice, IntPtr src) { return tsDevice_clearTexture_cTcSp(self, texture.getSelf(), in slice, src); }
		public bool clearTexture(Texture texture, IntPtr src) { return tsDevice_clearTexture_cTp(self, texture.getSelf(), src); }
		public bool bindTexture(Texture texture, Region[] regions, Slice[] slices, bool commit, Fence fence) { return tsDevice_bindTexture_cTcRucSubF(self, texture.getSelf(), regions, (uint)regions.Length, slices, (uint)slices.Length, commit, fence.getSelf()); }
		public bool bindTexture(Texture texture, Region[] regions, Slice[] slices, bool commit) { return tsDevice_bindTexture_cTcRucSub(self, texture.getSelf(), regions, (uint)regions.Length, slices, (uint)slices.Length, commit); }
		public bool bindTexture(Texture texture, in Region region, in Slice slice, bool commit, Fence fence) { return tsDevice_bindTexture_cTcRcSbF(self, texture.getSelf(), in region, in slice, commit, fence.getSelf()); }
		public bool bindTexture(Texture texture, in Region region, in Slice slice, bool commit) { return tsDevice_bindTexture_cTcRcSb(self, texture.getSelf(), in region, in slice, commit); }
		public bool createMipmaps(Texture texture, in Slice slice) { return tsDevice_createMipmaps_cTcS(self, texture.getSelf(), in slice); }
		public bool createMipmaps(Texture texture) { return tsDevice_createMipmaps_cT(self, texture.getSelf()); }
		public bool flushTexture(Texture texture, Texture.Flags flags = Texture.Flags.None) { return tsDevice_flushTexture_cTTF(self, texture.getSelf(), flags); }
		public bool flushTexture(Texture texture, in Slice slice, Texture.Flags flags = Texture.Flags.None) { return tsDevice_flushTexture_cTcSTF(self, texture.getSelf(), in slice, flags); }
		public bool flushTextures(Texture[] textures, Texture.Flags flags = Texture.Flags.None) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			return tsDevice_flushTextures_ccATTF(self, textures_, (uint)textures.Length, flags);
		}
		public void releaseTexture(Texture texture) { tsDevice_releaseTexture(self, texture.getSelf()); }
		public bool setTracing(Tracing tracing, Tracing.Instance[] instances) { return tsDevice_setTracing(self, tracing.getSelf(), instances, (uint)instances.Length); }
		public bool buildTracing(Tracing tracing, Buffer buffer, Tracing.Flags flags = Tracing.Flags.None) { return tsDevice_buildTracing_cTBTF(self, tracing.getSelf(), buffer.getSelf(), flags); }
		public bool buildTracing(Tracing tracing, Buffer buffer, ulong offset, Tracing.Flags flags = Tracing.Flags.None) { return tsDevice_buildTracing_cTBzTF(self, tracing.getSelf(), buffer.getSelf(), offset, flags); }
		public bool buildTracings(Tracing[] tracings, Buffer buffer, Tracing.Flags flags = Tracing.Flags.None) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			return tsDevice_buildTracings_ccATBTF(self, tracings_, (uint)tracings.Length, buffer.getSelf(), flags);
		}
		public bool buildTracings(Tracing[] tracings, Buffer buffer, ulong offset, Tracing.Flags flags = Tracing.Flags.None) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			return tsDevice_buildTracings_ccATBzTF(self, tracings_, (uint)tracings.Length, buffer.getSelf(), offset, flags);
		}
		public bool copyTracing(Tracing tracing, Buffer buffer, ulong offset = 0) { return tsDevice_copyTracing(self, tracing.getSelf(), buffer.getSelf(), offset); }
		public bool copyTracings(Tracing[] tracings, Buffer buffer, ulong offset, ulong stride = 0) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			return tsDevice_copyTracings(self, tracings_, (uint)tracings.Length, buffer.getSelf(), offset, stride);
		}
		public bool flushTracing(Tracing tracing) { return tsDevice_flushTracing(self, tracing.getSelf()); }
		public bool flushTracings(Tracing[] tracings) {
			IntPtr[] tracings_ = new IntPtr[tracings.Length];
			for(int i = 0; i < tracings.Length; i++) tracings_[i] = tracings[i].getSelfPtr();
			return tsDevice_flushTracings(self, tracings_, (uint)tracings.Length);
		}
		public void releaseTracing(Tracing tracing) { tsDevice_releaseTracing(self, tracing.getSelf()); }
		public bool setBufferTable(BufferTable table, uint index, Buffer buffer, bool owner = false) { return tsDevice_setBufferTable_cBTuBb(self, table.getSelf(), index, buffer.getSelf(), owner); }
		public bool setBufferTable(BufferTable table, uint index, Buffer[] buffers, bool owner = false) {
			IntPtr[] buffers_ = new IntPtr[buffers.Length];
			for(int i = 0; i < buffers.Length; i++) buffers_[i] = buffers[i].getSelfPtr();
			return tsDevice_setBufferTable_cBTucABb(self, table.getSelf(), index, buffers_, (uint)buffers.Length, owner);
		}
		public void releaseBufferTable(BufferTable table) { tsDevice_releaseBufferTable(self, table.getSelf()); }
		public bool setTextureTable(TextureTable table, uint index, Texture texture, bool owner = false) { return tsDevice_setTextureTable_cTTuTb(self, table.getSelf(), index, texture.getSelf(), owner); }
		public bool setTextureTable(TextureTable table, uint index, Texture[] textures, bool owner = false) {
			IntPtr[] textures_ = new IntPtr[textures.Length];
			for(int i = 0; i < textures.Length; i++) textures_[i] = textures[i].getSelfPtr();
			return tsDevice_setTextureTable_cTTucATb(self, table.getSelf(), index, textures_, (uint)textures.Length, owner);
		}
		public void releaseTextureTable(TextureTable table) { tsDevice_releaseTextureTable(self, table.getSelf()); }
		public bool beginQuery(Query query) { return tsDevice_beginQuery(self, query.getSelf()); }
		public void endQuery(Query query) { tsDevice_endQuery(self, query.getSelf()); }
		public bool copyQuery(Query query, Buffer buffer, ulong offset = 0) { return tsDevice_copyQuery(self, query.getSelf(), buffer.getSelf(), offset); }
		public bool copyQueries(Query[] queries, Buffer buffer, ulong offset = 0, ulong stride = 0) {
			IntPtr[] queries_ = new IntPtr[queries.Length];
			for(int i = 0; i < queries.Length; i++) queries_[i] = queries[i].getSelfPtr();
			return tsDevice_copyQueries_ccAQBzz(self, queries_, (uint)queries.Length, buffer.getSelf(), offset, stride);
		}
		public bool waitFence(Fence fence) { return tsDevice_waitFence(self, fence.getSelf()); }
		public bool signalFence(Fence fence) { return tsDevice_signalFence(self, fence.getSelf()); }
		public bool execute(Device device) { return tsDevice_execute(self, device.getSelf()); }
		public bool flip(Fence fence) { return tsDevice_flip_cF(self, fence.getSelf()); }
		public bool flip() { return tsDevice_flip_c(self); }
		public bool flush() { return tsDevice_flush(self); }
		public bool finish() { return tsDevice_finish(self); }
		public bool check() { return tsDevice_check(self); }
		public Features getFeatures() { Features features = new Features(); tsDevice_getFeatures_DF(self, ref features); return features; }
		[DllImport(Base.Import)] private static extern void tsDevice_getFeatures_DF(HandleRef self, ref Features features);
		public override string ToString() { return "Tellusim.Device: Valid: " + tsDevice_isValidPtr(self) + "; Owner: " + tsDevice_isOwnerPtr(self) + "; Const: " + tsDevice_isConstPtr(self) + "; Count: " + tsDevice_getCountPtr(self) + "; Internal: 0x" + tsDevice_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Device ptr) { return (ptr != null && tsDevice_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_new();
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_new_C(HandleRef context);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_new_S(HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_new_W(HandleRef window);
		[DllImport(Base.Import)] private static extern void tsDevice_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDevice_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDevice_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDevice_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDevice_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDevice_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsDevice_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDevice_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_getVendor(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_getVersion(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_hasQuery(HandleRef self, Query.Type type);
		[DllImport(Base.Import)] private static extern bool tsDevice_hasShader(HandleRef self, Shader.Type type);
		[DllImport(Base.Import)] private static extern bool tsDevice_hasTarget(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern bool tsDevice_hasTexture(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern bool tsDevice_hasSurface(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createDevice(HandleRef self, uint index, uint frames);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createCommandDevice(HandleRef self, uint frames);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createComputeDevice(HandleRef self, uint frames);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createCopyDevice(HandleRef self, uint frames);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createQuery_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createQuery_cQT(HandleRef self, Query.Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createFence_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createFence_cF(HandleRef self, HandleRef shared);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createFence_cFF(HandleRef self, Fence.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBuffer_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBuffer_cB(HandleRef self, HandleRef shared);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBuffer_cBFzF(HandleRef self, Buffer.Flags flags, ulong size, Format format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBuffer_cBFpzF(HandleRef self, Buffer.Flags flags, IntPtr src, ulong size, Format format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createSampler_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createSampler_ccS(HandleRef self, HandleRef sampler);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createSampler_cSFSWMu(HandleRef self, Sampler.Filter filter, Sampler.WrapMode mode, uint anisotropy);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture_cT(HandleRef self, HandleRef shared);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture_cTTFcSuTF(HandleRef self, Texture.Type type, Format format, in Size size, uint layers, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture_cTTFcSTF(HandleRef self, Texture.Type type, Format format, in Size size, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture_ccITFA(HandleRef self, HandleRef image, Texture.Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture2D_cFuTF(HandleRef self, Format format, uint size, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture3D_cFuTF(HandleRef self, Format format, uint size, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTextureCube_cFuTF(HandleRef self, Format format, uint size, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture2D_cFuuTF(HandleRef self, Format format, uint width, uint height, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture3D_cFuuuTF(HandleRef self, Format format, uint width, uint height, uint depth, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTexture2D_cFuuuTF(HandleRef self, Format format, uint width, uint height, uint layers, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTextureCube_cFuuTF(HandleRef self, Format format, uint size, uint layers, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadTexture_csTFIFuA(HandleRef self, string name, Texture.Flags flags, Image.Flags image_flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadTexture_ccSTFIFuA(HandleRef self, HandleRef name, Texture.Flags flags, Image.Flags image_flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadTexture_cStTFIFuA(HandleRef self, HandleRef stream, Texture.Flags flags, Image.Flags image_flags, uint offset, ref IntPtr async);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTracing_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTracing_ccT(HandleRef self, HandleRef tracing);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTracing_cuBzTF(HandleRef self, uint num_instances, HandleRef instance_buffer, ulong instance_offset, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTracing_cuFzuFTF(HandleRef self, uint num_vertices, Format vertex_format, ulong vertex_stride, uint num_indices, Format index_format, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTracing_cuzBzTF(HandleRef self, uint num_bounds, ulong bound_stride, HandleRef bound_buffer, ulong bound_offset, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBufferTable_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBufferTable_cu(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createBufferTable_ccABb(HandleRef self, IntPtr[] buffers, uint buffers_size, bool owner);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTextureTable_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTextureTable_cTTu(HandleRef self, Texture.Type type, uint size);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTextureTable_ccATb(HandleRef self, IntPtr[] textures, uint textures_size, bool owner);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createShader_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadShader_cSTss(HandleRef self, Shader.Type type, string name, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadShaderGLSL_cSTss(HandleRef self, Shader.Type type, string name, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadShader_cSTscS(HandleRef self, Shader.Type type, string name, HandleRef macros);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadShaderGLSL_cSTscS(HandleRef self, Shader.Type type, string name, HandleRef macros);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_loadShaderSPIRV(HandleRef self, Shader.Type type, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createShader_cSTss(HandleRef self, Shader.Type type, string src, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createShaderGLSL_cSTss(HandleRef self, Shader.Type type, string src, string format);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createShader_cSTscS(HandleRef self, Shader.Type type, string src, HandleRef macros);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createShaderGLSL_cSTscS(HandleRef self, Shader.Type type, string src, HandleRef macros);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createShaderSPIRV(HandleRef self, Shader.Type type, uint[] data, uint data_size);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createKernel_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createKernel_ccK(HandleRef self, HandleRef kernel);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseKernel(HandleRef self, HandleRef kernel);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createPipeline_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createPipeline_ccP(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern void tsDevice_releasePipeline(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTraversal_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTraversal_ccT(HandleRef self, HandleRef traversal);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseTraversal(HandleRef self, HandleRef traversal);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTarget_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTarget_cS(HandleRef self, HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createTarget_cW(HandleRef self, HandleRef window);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createCompute(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createCommand_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_createCommand_cT(HandleRef self, HandleRef target);
		[DllImport(Base.Import)] private static extern bool tsDevice_setBuffer_cBzpz(HandleRef self, HandleRef buffer, ulong offset, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_setBuffer_cBpz(HandleRef self, HandleRef buffer, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_setBuffer_cBp(HandleRef self, HandleRef buffer, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsDevice_getBuffer_cBzprz(HandleRef self, HandleRef buffer, ulong offset, IntPtr dest, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_getBuffer_cBprz(HandleRef self, HandleRef buffer, IntPtr dest, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_getBuffer_cBpr(HandleRef self, HandleRef buffer, IntPtr dest);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_mapBuffer_cBzz(HandleRef self, HandleRef buffer, ulong offset, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_mapBuffer_cBz(HandleRef self, HandleRef buffer, ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsDevice_mapBuffer_cB(HandleRef self, HandleRef buffer);
		[DllImport(Base.Import)] private static extern bool tsDevice_unmapBuffer(HandleRef self, HandleRef buffer);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyBuffer_cBzBzz(HandleRef self, HandleRef buffer, ulong dest_offset, HandleRef src, ulong src_offset, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyBuffer_cBzBz(HandleRef self, HandleRef buffer, ulong dest_offset, HandleRef src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyBuffer_cBBz(HandleRef self, HandleRef buffer, HandleRef src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyBuffer_cBB(HandleRef self, HandleRef buffer, HandleRef src);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearBuffer_cBFzpz(HandleRef self, HandleRef buffer, Format format, ulong offset, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearBuffer_cBFpz(HandleRef self, HandleRef buffer, Format format, IntPtr src, ulong size);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearBuffer_cBFp(HandleRef self, HandleRef buffer, Format format, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearBuffer_cB(HandleRef self, HandleRef buffer);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindBuffer_cBcAcAbF(HandleRef self, HandleRef buffer, ulong[] offsets, uint offsets_size, ulong[] sizes, uint sizes_size, bool commit, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindBuffer_cBcAcAb(HandleRef self, HandleRef buffer, ulong[] offsets, uint offsets_size, ulong[] sizes, uint sizes_size, bool commit);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindBuffer_cBzzbF(HandleRef self, HandleRef buffer, ulong offset, ulong size, bool commit, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindBuffer_cBzzb(HandleRef self, HandleRef buffer, ulong offset, ulong size, bool commit);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushBuffer(HandleRef self, HandleRef buffer, Buffer.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushBuffers_ccABBF(HandleRef self, IntPtr[] buffers, uint buffers_size, Buffer.Flags flags);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseBuffer(HandleRef self, HandleRef buffer);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseSampler(HandleRef self, HandleRef sampler);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTexture_cTcOcScIcS(HandleRef self, HandleRef texture, in Origin dest_origin, in Slice dest_slice, HandleRef image, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTexture_cTcOcI(HandleRef self, HandleRef texture, in Origin dest_origin, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTexture_cTcScI(HandleRef self, HandleRef texture, in Slice dest_slice, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTexture_cTcI(HandleRef self, HandleRef texture, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsDevice_getTexture_cTcSIcS(HandleRef self, HandleRef texture, in Slice src_slice, HandleRef image, in Slice dest_slice);
		[DllImport(Base.Import)] private static extern bool tsDevice_getTexture_cTIcS(HandleRef self, HandleRef texture, HandleRef image, in Slice dest_slice);
		[DllImport(Base.Import)] private static extern bool tsDevice_getTexture_cTI(HandleRef self, HandleRef texture, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyTexture_cTcOcSTcRcS(HandleRef self, HandleRef texture, in Origin dest_origin, in Slice dest_slice, HandleRef src, in Region src_region, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyTexture_cTcOTcR(HandleRef self, HandleRef texture, in Origin dest_origin, HandleRef src, in Region src_region);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyTexture_cTcSTcS(HandleRef self, HandleRef texture, in Slice dest_slice, HandleRef src, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyTexture_cTT(HandleRef self, HandleRef texture, HandleRef src);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearTexture_cTcRcSp(HandleRef self, HandleRef texture, in Region region, in Slice slice, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearTexture_cTcRp(HandleRef self, HandleRef texture, in Region region, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearTexture_cTcSp(HandleRef self, HandleRef texture, in Slice slice, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsDevice_clearTexture_cTp(HandleRef self, HandleRef texture, IntPtr src);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindTexture_cTcRucSubF(HandleRef self, HandleRef texture, Region[] regions, uint num_regions, Slice[] slices, uint num_slices, bool commit, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindTexture_cTcRucSub(HandleRef self, HandleRef texture, Region[] regions, uint num_regions, Slice[] slices, uint num_slices, bool commit);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindTexture_cTcRcSbF(HandleRef self, HandleRef texture, in Region region, in Slice slice, bool commit, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_bindTexture_cTcRcSb(HandleRef self, HandleRef texture, in Region region, in Slice slice, bool commit);
		[DllImport(Base.Import)] private static extern bool tsDevice_createMipmaps_cTcS(HandleRef self, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsDevice_createMipmaps_cT(HandleRef self, HandleRef texture);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushTexture_cTTF(HandleRef self, HandleRef texture, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushTexture_cTcSTF(HandleRef self, HandleRef texture, in Slice slice, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushTextures_ccATTF(HandleRef self, IntPtr[] textures, uint textures_size, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseTexture(HandleRef self, HandleRef texture);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTracing(HandleRef self, HandleRef tracing, Tracing.Instance[] instances, uint num_instances);
		[DllImport(Base.Import)] private static extern bool tsDevice_buildTracing_cTBTF(HandleRef self, HandleRef tracing, HandleRef buffer, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_buildTracing_cTBzTF(HandleRef self, HandleRef tracing, HandleRef buffer, ulong offset, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_buildTracings_ccATBTF(HandleRef self, IntPtr[] tracings, uint tracings_size, HandleRef buffer, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_buildTracings_ccATBzTF(HandleRef self, IntPtr[] tracings, uint tracings_size, HandleRef buffer, ulong offset, Tracing.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyTracing(HandleRef self, HandleRef tracing, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyTracings(HandleRef self, IntPtr[] tracings, uint tracings_size, HandleRef buffer, ulong offset, ulong stride);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushTracing(HandleRef self, HandleRef tracing);
		[DllImport(Base.Import)] private static extern bool tsDevice_flushTracings(HandleRef self, IntPtr[] tracings, uint tracings_size);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseTracing(HandleRef self, HandleRef tracing);
		[DllImport(Base.Import)] private static extern bool tsDevice_setBufferTable_cBTuBb(HandleRef self, HandleRef table, uint index, HandleRef buffer, bool owner);
		[DllImport(Base.Import)] private static extern bool tsDevice_setBufferTable_cBTucABb(HandleRef self, HandleRef table, uint index, IntPtr[] buffers, uint buffers_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseBufferTable(HandleRef self, HandleRef table);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTextureTable_cTTuTb(HandleRef self, HandleRef table, uint index, HandleRef texture, bool owner);
		[DllImport(Base.Import)] private static extern bool tsDevice_setTextureTable_cTTucATb(HandleRef self, HandleRef table, uint index, IntPtr[] textures, uint textures_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsDevice_releaseTextureTable(HandleRef self, HandleRef table);
		[DllImport(Base.Import)] private static extern bool tsDevice_beginQuery(HandleRef self, HandleRef query);
		[DllImport(Base.Import)] private static extern void tsDevice_endQuery(HandleRef self, HandleRef query);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyQuery(HandleRef self, HandleRef query, HandleRef buffer, ulong offset);
		[DllImport(Base.Import)] private static extern bool tsDevice_copyQueries_ccAQBzz(HandleRef self, IntPtr[] queries, uint queries_size, HandleRef buffer, ulong offset, ulong stride);
		[DllImport(Base.Import)] private static extern bool tsDevice_waitFence(HandleRef self, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_signalFence(HandleRef self, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_execute(HandleRef self, HandleRef device);
		[DllImport(Base.Import)] private static extern bool tsDevice_flip_cF(HandleRef self, HandleRef fence);
		[DllImport(Base.Import)] private static extern bool tsDevice_flip_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_flush(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_finish(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDevice_check(HandleRef self);
		[StructLayout(LayoutKind.Sequential)] public struct Features {
			[MarshalAs(UnmanagedType.U1)] public bool threadAccess;
			[MarshalAs(UnmanagedType.U1)] public bool sparseBuffer;
			[MarshalAs(UnmanagedType.U1)] public bool bufferTable;
			[MarshalAs(UnmanagedType.U1)] public bool sparseTexture;
			[MarshalAs(UnmanagedType.U1)] public bool sparseArrayTexture;
			[MarshalAs(UnmanagedType.U1)] public bool cubeArrayTexture;
			[MarshalAs(UnmanagedType.U1)] public bool textureTable;
			[MarshalAs(UnmanagedType.U1)] public bool baseInstanceIndex;
			[MarshalAs(UnmanagedType.U1)] public bool drawIndirectIndex;
			[MarshalAs(UnmanagedType.U1)] public bool drawIndirectCount;
			[MarshalAs(UnmanagedType.U1)] public bool taskIndirectCount;
			[MarshalAs(UnmanagedType.U1)] public bool vertexStorage;
			[MarshalAs(UnmanagedType.U1)] public bool vertexIndexLayer;
			[MarshalAs(UnmanagedType.U1)] public bool geometryPassthrough;
			[MarshalAs(UnmanagedType.U1)] public bool fragmentBarycentric;
			[MarshalAs(UnmanagedType.U1)] public bool fragmentStencilExport;
			[MarshalAs(UnmanagedType.U1)] public bool dualSourceBlending;
			[MarshalAs(UnmanagedType.U1)] public bool depthRangeOneToOne;
			[MarshalAs(UnmanagedType.U1)] public bool conservativeRaster;
			[MarshalAs(UnmanagedType.U1)] public bool conditionalRendering;
			[MarshalAs(UnmanagedType.U1)] public bool rayTracing;
			[MarshalAs(UnmanagedType.U1)] public bool computeTracing;
			[MarshalAs(UnmanagedType.U1)] public bool fragmentTracing;
			[MarshalAs(UnmanagedType.U1)] public bool indirectTracing;
			public uint recursionDepth;
			[MarshalAs(UnmanagedType.U1)] public bool subgroupVote;
			[MarshalAs(UnmanagedType.U1)] public bool subgroupMath;
			[MarshalAs(UnmanagedType.U1)] public bool subgroupShuffle;
			public uint subgroupSize;
			public uint minSubgroupSize;
			public uint maxSubgroupSize;
			[MarshalAs(UnmanagedType.U1)] public bool shaderu8;
			[MarshalAs(UnmanagedType.U1)] public bool shaderf16;
			[MarshalAs(UnmanagedType.U1)] public bool shaderu16;
			[MarshalAs(UnmanagedType.U1)] public bool shaderf64;
			[MarshalAs(UnmanagedType.U1)] public bool shaderu64;
			[MarshalAs(UnmanagedType.U1)] public bool atomicGroupf32;
			[MarshalAs(UnmanagedType.U1)] public bool atomicGroupu64;
			[MarshalAs(UnmanagedType.U1)] public bool atomicBufferf32;
			[MarshalAs(UnmanagedType.U1)] public bool atomicBufferu64;
			[MarshalAs(UnmanagedType.U1)] public bool atomicTexturef32;
			[MarshalAs(UnmanagedType.U1)] public bool atomicTextureu32;
			[MarshalAs(UnmanagedType.U1)] public bool atomicTextureu64;
			[MarshalAs(UnmanagedType.U1)] public bool matrix16f16;
			[MarshalAs(UnmanagedType.U1)] public bool matrix16x8x8f16;
			[MarshalAs(UnmanagedType.U1)] public bool matrix16x8x16f16;
			[MarshalAs(UnmanagedType.U1)] public bool matrix16f16f32;
			[MarshalAs(UnmanagedType.U1)] public bool matrix16x8x8f16f32;
			[MarshalAs(UnmanagedType.U1)] public bool matrix16x8x16f16f32;
			public uint uniformAlignment;
			public uint storageAlignment;
			public uint maxTextureSamples;
			public uint maxTexture2DSize;
			public uint maxTexture3DSize;
			public uint maxTextureLayers;
			public uint maxGroupSizeX;
			public uint maxGroupSizeY;
			public uint maxGroupSizeZ;
			public uint maxGroupCountX;
			public uint maxGroupCountY;
			public uint maxGroupCountZ;
			public uint maxTaskCount;
			public uint maxTaskMemory;
			public uint maxTaskMeshes;
			public uint maxMeshMemory;
			public uint maxMeshVertices;
			public uint maxMeshPrimitives;
			public uint maxViewportCount;
			public uint maxClipCullCount;
			public ulong maxUniformSize;
			public ulong maxStorageSize;
			public uint groupMemory;
			public ulong videoMemory;
			public uint vendorID;
			public uint deviceID;
			public uint pciBusID;
			public uint pciDomainID;
			public uint pciDeviceID;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("threadAccess: {0}\n", threadAccess);
				ret += System.String.Format("sparseBuffer: {0}\n", sparseBuffer);
				ret += System.String.Format("bufferTable: {0}\n", bufferTable);
				ret += System.String.Format("sparseTexture: {0}\n", sparseTexture);
				ret += System.String.Format("sparseArrayTexture: {0}\n", sparseArrayTexture);
				ret += System.String.Format("cubeArrayTexture: {0}\n", cubeArrayTexture);
				ret += System.String.Format("textureTable: {0}\n", textureTable);
				ret += System.String.Format("baseInstanceIndex: {0}\n", baseInstanceIndex);
				ret += System.String.Format("drawIndirectIndex: {0}\n", drawIndirectIndex);
				ret += System.String.Format("drawIndirectCount: {0}\n", drawIndirectCount);
				ret += System.String.Format("taskIndirectCount: {0}\n", taskIndirectCount);
				ret += System.String.Format("vertexStorage: {0}\n", vertexStorage);
				ret += System.String.Format("vertexIndexLayer: {0}\n", vertexIndexLayer);
				ret += System.String.Format("geometryPassthrough: {0}\n", geometryPassthrough);
				ret += System.String.Format("fragmentBarycentric: {0}\n", fragmentBarycentric);
				ret += System.String.Format("fragmentStencilExport: {0}\n", fragmentStencilExport);
				ret += System.String.Format("dualSourceBlending: {0}\n", dualSourceBlending);
				ret += System.String.Format("depthRangeOneToOne: {0}\n", depthRangeOneToOne);
				ret += System.String.Format("conservativeRaster: {0}\n", conservativeRaster);
				ret += System.String.Format("conditionalRendering: {0}\n", conditionalRendering);
				ret += System.String.Format("rayTracing: {0}\n", rayTracing);
				ret += System.String.Format("computeTracing: {0}\n", computeTracing);
				ret += System.String.Format("fragmentTracing: {0}\n", fragmentTracing);
				ret += System.String.Format("indirectTracing: {0}\n", indirectTracing);
				ret += System.String.Format("recursionDepth: {0}\n", recursionDepth);
				ret += System.String.Format("subgroupVote: {0}\n", subgroupVote);
				ret += System.String.Format("subgroupMath: {0}\n", subgroupMath);
				ret += System.String.Format("subgroupShuffle: {0}\n", subgroupShuffle);
				ret += System.String.Format("subgroupSize: {0}\n", subgroupSize);
				ret += System.String.Format("minSubgroupSize: {0}\n", minSubgroupSize);
				ret += System.String.Format("maxSubgroupSize: {0}\n", maxSubgroupSize);
				ret += System.String.Format("shaderu8: {0}\n", shaderu8);
				ret += System.String.Format("shaderf16: {0}\n", shaderf16);
				ret += System.String.Format("shaderu16: {0}\n", shaderu16);
				ret += System.String.Format("shaderf64: {0}\n", shaderf64);
				ret += System.String.Format("shaderu64: {0}\n", shaderu64);
				ret += System.String.Format("atomicGroupf32: {0}\n", atomicGroupf32);
				ret += System.String.Format("atomicGroupu64: {0}\n", atomicGroupu64);
				ret += System.String.Format("atomicBufferf32: {0}\n", atomicBufferf32);
				ret += System.String.Format("atomicBufferu64: {0}\n", atomicBufferu64);
				ret += System.String.Format("atomicTexturef32: {0}\n", atomicTexturef32);
				ret += System.String.Format("atomicTextureu32: {0}\n", atomicTextureu32);
				ret += System.String.Format("atomicTextureu64: {0}\n", atomicTextureu64);
				ret += System.String.Format("matrix16f16: {0}\n", matrix16f16);
				ret += System.String.Format("matrix16x8x8f16: {0}\n", matrix16x8x8f16);
				ret += System.String.Format("matrix16x8x16f16: {0}\n", matrix16x8x16f16);
				ret += System.String.Format("matrix16f16f32: {0}\n", matrix16f16f32);
				ret += System.String.Format("matrix16x8x8f16f32: {0}\n", matrix16x8x8f16f32);
				ret += System.String.Format("matrix16x8x16f16f32: {0}\n", matrix16x8x16f16f32);
				ret += System.String.Format("uniformAlignment: {0}\n", uniformAlignment);
				ret += System.String.Format("storageAlignment: {0}\n", storageAlignment);
				ret += System.String.Format("maxTextureSamples: {0}\n", maxTextureSamples);
				ret += System.String.Format("maxTexture2DSize: {0}\n", maxTexture2DSize);
				ret += System.String.Format("maxTexture3DSize: {0}\n", maxTexture3DSize);
				ret += System.String.Format("maxTextureLayers: {0}\n", maxTextureLayers);
				ret += System.String.Format("maxGroupSizeX: {0}\n", maxGroupSizeX);
				ret += System.String.Format("maxGroupSizeY: {0}\n", maxGroupSizeY);
				ret += System.String.Format("maxGroupSizeZ: {0}\n", maxGroupSizeZ);
				ret += System.String.Format("maxGroupCountX: {0}\n", maxGroupCountX);
				ret += System.String.Format("maxGroupCountY: {0}\n", maxGroupCountY);
				ret += System.String.Format("maxGroupCountZ: {0}\n", maxGroupCountZ);
				ret += System.String.Format("maxTaskCount: {0}\n", maxTaskCount);
				ret += System.String.Format("maxTaskMemory: {0}\n", maxTaskMemory);
				ret += System.String.Format("maxTaskMeshes: {0}\n", maxTaskMeshes);
				ret += System.String.Format("maxMeshMemory: {0}\n", maxMeshMemory);
				ret += System.String.Format("maxMeshVertices: {0}\n", maxMeshVertices);
				ret += System.String.Format("maxMeshPrimitives: {0}\n", maxMeshPrimitives);
				ret += System.String.Format("maxViewportCount: {0}\n", maxViewportCount);
				ret += System.String.Format("maxClipCullCount: {0}\n", maxClipCullCount);
				ret += System.String.Format("maxUniformSize: {0}\n", maxUniformSize);
				ret += System.String.Format("maxStorageSize: {0}\n", maxStorageSize);
				ret += System.String.Format("groupMemory: {0}\n", groupMemory);
				ret += System.String.Format("videoMemory: {0}\n", videoMemory);
				ret += System.String.Format("vendorID: 0x{0:x}\n", vendorID);
				ret += System.String.Format("deviceID: 0x{0:x}\n", deviceID);
				ret += System.String.Format("pciBusID: 0x{0:x}\n", pciBusID);
				ret += System.String.Format("pciDomainID: 0x{0:x}\n", pciDomainID);
				ret += System.String.Format("pciDeviceID: 0x{0:x}", pciDeviceID);
				return ret;
			}
		}
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Device
	public sealed class D3D12Device : Device {
		public D3D12Device() { self = new HandleRef(this, tsD3D12Device_new()); owner = true; }
		public D3D12Device(Context context) { self = new HandleRef(this, tsD3D12Device_new_C(context.getSelf())); owner = true; }
		public D3D12Device(Surface surface) { self = new HandleRef(this, tsD3D12Device_new_S(surface.getSelf())); owner = true; }
		public D3D12Device(Window window) { self = new HandleRef(this, tsD3D12Device_new_W(window.getSelf())); owner = true; }
		public D3D12Device(D3D12Device ptr) { self = new HandleRef(this, tsD3D12Device_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Device(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Device_isOwnerPtr(self); }
		public D3D12Device(Device ptr) { self = new HandleRef(this, tsD3D12Device_castDevicePtr(ptr.getSelf())); }
		public Device toDevice() { return new Device(tsD3D12Device_baseDevicePtr(self)); }
		public static new D3D12Device Null() { return new D3D12Device(IntPtr.Zero); }
		public void setBufferState(Buffer buffer, uint state) { tsD3D12Device_setBufferState(self, buffer.getSelf(), state); }
		public void setTextureState(Texture texture, uint state) { tsD3D12Device_setTextureState(self, texture.getSelf(), state); }
		public IntPtr getD3D12Device() { return tsD3D12Device_getD3D12Device(self); }
		public IntPtr getQueue() { return tsD3D12Device_getQueue(self); }
		public IntPtr getCommand() { return tsD3D12Device_getCommand(self); }
		public override string ToString() { return "Tellusim.D3D12Device: Valid: " + tsD3D12Device_isValidPtr(self) + "; Owner: " + tsD3D12Device_isOwnerPtr(self) + "; Const: " + tsD3D12Device_isConstPtr(self) + "; Count: " + tsD3D12Device_getCountPtr(self) + "; Internal: 0x" + tsD3D12Device_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Device ptr) { return (ptr != null && tsD3D12Device_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_new();
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_new_C(HandleRef context);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_new_S(HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_new_W(HandleRef window);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Device_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Device_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Device_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Device_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Device_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Device_equalDevicePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_castDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_baseDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_setBufferState(HandleRef self, HandleRef buffer, uint state);
		[DllImport(Base.Import)] private static extern void tsD3D12Device_setTextureState(HandleRef self, HandleRef texture, uint state);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_getD3D12Device(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Device_getCommand(HandleRef self);
	}
	
	// Tellusim::D3D11Device
	public sealed class D3D11Device : Device {
		public D3D11Device() { self = new HandleRef(this, tsD3D11Device_new()); owner = true; }
		public D3D11Device(Context context) { self = new HandleRef(this, tsD3D11Device_new_C(context.getSelf())); owner = true; }
		public D3D11Device(Surface surface) { self = new HandleRef(this, tsD3D11Device_new_S(surface.getSelf())); owner = true; }
		public D3D11Device(Window window) { self = new HandleRef(this, tsD3D11Device_new_W(window.getSelf())); owner = true; }
		public D3D11Device(D3D11Device ptr) { self = new HandleRef(this, tsD3D11Device_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Device(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Device_isOwnerPtr(self); }
		public D3D11Device(Device ptr) { self = new HandleRef(this, tsD3D11Device_castDevicePtr(ptr.getSelf())); }
		public Device toDevice() { return new Device(tsD3D11Device_baseDevicePtr(self)); }
		public static new D3D11Device Null() { return new D3D11Device(IntPtr.Zero); }
		public IntPtr getD3D11Device() { return tsD3D11Device_getD3D11Device(self); }
		public IntPtr getCommand() { return tsD3D11Device_getCommand(self); }
		public override string ToString() { return "Tellusim.D3D11Device: Valid: " + tsD3D11Device_isValidPtr(self) + "; Owner: " + tsD3D11Device_isOwnerPtr(self) + "; Const: " + tsD3D11Device_isConstPtr(self) + "; Count: " + tsD3D11Device_getCountPtr(self) + "; Internal: 0x" + tsD3D11Device_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Device ptr) { return (ptr != null && tsD3D11Device_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_new();
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_new_C(HandleRef context);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_new_S(HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_new_W(HandleRef window);
		[DllImport(Base.Import)] private static extern void tsD3D11Device_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Device_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Device_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Device_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Device_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Device_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Device_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Device_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Device_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Device_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Device_equalDevicePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_castDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_baseDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_getD3D11Device(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Device_getCommand(HandleRef self);
	}
	
	// Tellusim::MTLDevice
	public sealed class MTLDevice : Device {
		public MTLDevice() { self = new HandleRef(this, tsMTLDevice_new()); owner = true; }
		public MTLDevice(Context context) { self = new HandleRef(this, tsMTLDevice_new_C(context.getSelf())); owner = true; }
		public MTLDevice(Surface surface) { self = new HandleRef(this, tsMTLDevice_new_S(surface.getSelf())); owner = true; }
		public MTLDevice(Window window) { self = new HandleRef(this, tsMTLDevice_new_W(window.getSelf())); owner = true; }
		public MTLDevice(MTLDevice ptr) { self = new HandleRef(this, tsMTLDevice_copyPtr(ptr.getSelf())); owner = true; }
		public MTLDevice(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLDevice_isOwnerPtr(self); }
		public MTLDevice(Device ptr) { self = new HandleRef(this, tsMTLDevice_castDevicePtr(ptr.getSelf())); }
		public Device toDevice() { return new Device(tsMTLDevice_baseDevicePtr(self)); }
		public static new MTLDevice Null() { return new MTLDevice(IntPtr.Zero); }
		public IntPtr getMTLDevice() { return tsMTLDevice_getMTLDevice(self); }
		public IntPtr getQueue() { return tsMTLDevice_getQueue(self); }
		public IntPtr getCommand() { return tsMTLDevice_getCommand(self); }
		public IntPtr getEncoder() { return tsMTLDevice_getEncoder(self); }
		public IntPtr getRenderEncoder(IntPtr descriptor) { return tsMTLDevice_getRenderEncoder(self, descriptor); }
		public IntPtr getComputeEncoder() { return tsMTLDevice_getComputeEncoder(self); }
		public IntPtr getTracingEncoder() { return tsMTLDevice_getTracingEncoder(self); }
		public IntPtr getBlitEncoder() { return tsMTLDevice_getBlitEncoder(self); }
		public void endEncoder() { tsMTLDevice_endEncoder(self); }
		public override string ToString() { return "Tellusim.MTLDevice: Valid: " + tsMTLDevice_isValidPtr(self) + "; Owner: " + tsMTLDevice_isOwnerPtr(self) + "; Const: " + tsMTLDevice_isConstPtr(self) + "; Count: " + tsMTLDevice_getCountPtr(self) + "; Internal: 0x" + tsMTLDevice_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLDevice ptr) { return (ptr != null && tsMTLDevice_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_new();
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_new_C(HandleRef context);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_new_S(HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_new_W(HandleRef window);
		[DllImport(Base.Import)] private static extern void tsMTLDevice_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLDevice_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLDevice_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLDevice_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLDevice_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLDevice_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLDevice_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLDevice_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLDevice_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLDevice_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLDevice_equalDevicePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_castDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_baseDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getMTLDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getRenderEncoder(HandleRef self, IntPtr descriptor);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getComputeEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getTracingEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLDevice_getBlitEncoder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLDevice_endEncoder(HandleRef self);
	}
	
	// Tellusim::VKDevice
	public sealed class VKDevice : Device {
		public VKDevice() { self = new HandleRef(this, tsVKDevice_new()); owner = true; }
		public VKDevice(Context context) { self = new HandleRef(this, tsVKDevice_new_C(context.getSelf())); owner = true; }
		public VKDevice(Surface surface) { self = new HandleRef(this, tsVKDevice_new_S(surface.getSelf())); owner = true; }
		public VKDevice(Window window) { self = new HandleRef(this, tsVKDevice_new_W(window.getSelf())); owner = true; }
		public VKDevice(VKDevice ptr) { self = new HandleRef(this, tsVKDevice_copyPtr(ptr.getSelf())); owner = true; }
		public VKDevice(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKDevice_isOwnerPtr(self); }
		public VKDevice(Device ptr) { self = new HandleRef(this, tsVKDevice_castDevicePtr(ptr.getSelf())); }
		public Device toDevice() { return new Device(tsVKDevice_baseDevicePtr(self)); }
		public static new VKDevice Null() { return new VKDevice(IntPtr.Zero); }
		public void setBufferAccess(Buffer buffer, uint access) { tsVKDevice_setBufferAccess(self, buffer.getSelf(), access); }
		public void setTextureLayout(Texture texture, uint layout) { tsVKDevice_setTextureLayout(self, texture.getSelf(), layout); }
		public bool waitVKFence(IntPtr fence, ulong timeout, bool reset) { return tsVKDevice_waitVKFence(self, fence, timeout, reset); }
		public bool signalVKFence(IntPtr fence) { return tsVKDevice_signalVKFence(self, fence); }
		public void waitSemaphore(IntPtr semaphore, uint mask) { tsVKDevice_waitSemaphore(self, semaphore, mask); }
		public void signalSemaphore(IntPtr semaphore) { tsVKDevice_signalSemaphore(self, semaphore); }
		public bool hasMemoryType(uint flags) { return tsVKDevice_hasMemoryType(self, flags); }
		public uint getMemoryIndex(uint types, uint flags) { return tsVKDevice_getMemoryIndex(self, types, flags); }
		public IntPtr getInstance() { return tsVKDevice_getInstance(self); }
		public IntPtr getAdapter() { return tsVKDevice_getAdapter(self); }
		public IntPtr getVKDevice() { return tsVKDevice_getVKDevice(self); }
		public IntPtr getQueue() { return tsVKDevice_getQueue(self); }
		public IntPtr getCommand() { return tsVKDevice_getCommand(self); }
		public uint getFamily() { return tsVKDevice_getFamily(self); }
		public override string ToString() { return "Tellusim.VKDevice: Valid: " + tsVKDevice_isValidPtr(self) + "; Owner: " + tsVKDevice_isOwnerPtr(self) + "; Const: " + tsVKDevice_isConstPtr(self) + "; Count: " + tsVKDevice_getCountPtr(self) + "; Internal: 0x" + tsVKDevice_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKDevice ptr) { return (ptr != null && tsVKDevice_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_new();
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_new_C(HandleRef context);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_new_S(HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_new_W(HandleRef window);
		[DllImport(Base.Import)] private static extern void tsVKDevice_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKDevice_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKDevice_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKDevice_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKDevice_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKDevice_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_equalDevicePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_castDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_baseDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKDevice_setBufferAccess(HandleRef self, HandleRef buffer, uint access);
		[DllImport(Base.Import)] private static extern void tsVKDevice_setTextureLayout(HandleRef self, HandleRef texture, uint layout);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_waitVKFence(HandleRef self, IntPtr fence, ulong timeout, bool reset);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_signalVKFence(HandleRef self, IntPtr fence);
		[DllImport(Base.Import)] private static extern void tsVKDevice_waitSemaphore(HandleRef self, IntPtr semaphore, uint mask);
		[DllImport(Base.Import)] private static extern void tsVKDevice_signalSemaphore(HandleRef self, IntPtr semaphore);
		[DllImport(Base.Import)] private static extern bool tsVKDevice_hasMemoryType(HandleRef self, uint flags);
		[DllImport(Base.Import)] private static extern uint tsVKDevice_getMemoryIndex(HandleRef self, uint types, uint flags);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_getInstance(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_getAdapter(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_getVKDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKDevice_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKDevice_getFamily(HandleRef self);
	}
	
	// Tellusim::FUDevice
	public sealed class FUDevice : Device {
		public FUDevice() { self = new HandleRef(this, tsFUDevice_new()); owner = true; }
		public FUDevice(Device[] devices, bool owner = false) {
			IntPtr[] devices_ = new IntPtr[devices.Length];
			for(int i = 0; i < devices.Length; i++) devices_[i] = devices[i].getSelfPtr();
			self = new HandleRef(this, tsFUDevice_new_cADb(devices_, (uint)devices.Length, owner)); owner = true;
		}
		public FUDevice(FUDevice ptr) { self = new HandleRef(this, tsFUDevice_copyPtr(ptr.getSelf())); owner = true; }
		public FUDevice(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUDevice_isOwnerPtr(self); }
		public FUDevice(Device ptr) { self = new HandleRef(this, tsFUDevice_castDevicePtr(ptr.getSelf())); }
		public Device toDevice() { return new Device(tsFUDevice_baseDevicePtr(self)); }
		public static new FUDevice Null() { return new FUDevice(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUDevice_setMask(self, mask); }
		public uint getMask() { return tsFUDevice_getMask(self); }
		public uint getNumDevices() { return tsFUDevice_getNumDevices(self); }
		public Device getDevice(uint index) { return new Device(tsFUDevice_getDevice_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUDevice: Valid: " + tsFUDevice_isValidPtr(self) + "; Owner: " + tsFUDevice_isOwnerPtr(self) + "; Const: " + tsFUDevice_isConstPtr(self) + "; Count: " + tsFUDevice_getCountPtr(self) + "; Internal: 0x" + tsFUDevice_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUDevice ptr) { return (ptr != null && tsFUDevice_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_new_cADb(IntPtr[] devices, uint devices_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUDevice_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUDevice_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUDevice_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUDevice_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUDevice_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUDevice_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUDevice_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUDevice_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUDevice_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUDevice_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUDevice_equalDevicePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_castDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_baseDevicePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUDevice_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUDevice_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUDevice_getNumDevices(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUDevice_getDevice_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Kernel
	public class Kernel {
		public Kernel() { self = new HandleRef(this, tsKernel_new()); owner = true; }
		public Kernel(Kernel ptr) { self = new HandleRef(this, tsKernel_copyPtr(ptr.getSelf())); owner = true; }
		public Kernel(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsKernel_isOwnerPtr(self); }
		public static Kernel Null() { return new Kernel(IntPtr.Zero); }
		~Kernel() { if(owner) tsKernel_delete(self); }
		public bool equalPtr(Kernel ptr) { return tsKernel_equalPtr(self, ptr.getSelf()); }
		public Kernel clonePtr() { return new Kernel(tsKernel_clonePtr(self)); }
		public void clearPtr() { tsKernel_clearPtr(self); }
		public void destroyPtr() { tsKernel_destroyPtr(self); }
		public void acquirePtr() { tsKernel_acquirePtr(self); }
		public void unacquirePtr() { tsKernel_unacquirePtr(self); }
		public bool isValidPtr() { return tsKernel_isValidPtr(self); }
		public bool isOwnerPtr() { return tsKernel_isOwnerPtr(self); }
		public bool isConstPtr() { return tsKernel_isConstPtr(self); }
		public uint getCountPtr() { return tsKernel_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsKernel_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsKernel_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsKernel_getPlatformName(self)); }
		public uint getIndex() { return tsKernel_getIndex(self); }
		public void clear() { tsKernel_clear(self); }
		public bool isCreated() { return tsKernel_isCreated(self); }
		public void setName(string name) { tsKernel_setName(self, name); }
		public string getName() { return Base.getString(tsKernel_getName(self)); }
		public bool create() { return tsKernel_create(self); }
		public void setParameters(Kernel kernel) { tsKernel_setParameters(self, kernel.getSelf()); }
		public bool saveState(Stream stream) { return tsKernel_saveState(self, stream.getSelf()); }
		public void setShader(Shader shader, bool owner = false) { tsKernel_setShader(self, shader.getSelf(), owner); }
		public Shader getComputeShader() { return new Shader(tsKernel_getComputeShader(self)); }
		public bool loadShader(string name, string format, params object[] args) { return tsKernel_loadShader_ss(self, name, System.String.Format(format, args)); }
		public bool loadShaderGLSL(string name, string format, params object[] args) { return tsKernel_loadShaderGLSL_ss(self, name, System.String.Format(format, args)); }
		public bool loadShader(string name, String macros = null, string[] includes = null) { return tsKernel_loadShader_scSspu(self, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadShaderGLSL(string name, String macros = null, string[] includes = null) { return tsKernel_loadShaderGLSL_scSspu(self, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadShaderSPIRV(string name) { return tsKernel_loadShaderSPIRV(self, name); }
		public bool createShader(string src, string format) { return tsKernel_createShader_ss(self, src, format); }
		public bool createShaderGLSL(string src, string format) { return tsKernel_createShaderGLSL_ss(self, src, format); }
		public bool createShader(string src, String macros = null, string[] includes = null) { return tsKernel_createShader_scSspu(self, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createShaderGLSL(string src, String macros = null, string[] includes = null) { return tsKernel_createShaderGLSL_scSspu(self, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createShaderSPIRV(uint[] data) { return tsKernel_createShaderSPIRV(self, data, (uint)data.Length); }
		public uint addSampler() { return tsKernel_addSampler(self); }
		public Kernel setSamplers(uint num) { tsKernel_setSamplers(self, num); return this; }
		public uint getNumSamplers() { return tsKernel_getNumSamplers(self); }
		public Kernel setSamplerOffset(uint offset) { tsKernel_setSamplerOffset(self, offset); return this; }
		public uint getSamplerOffset() { return tsKernel_getSamplerOffset(self); }
		public Kernel setSamplerArray(uint index, uint num, bool array) { tsKernel_setSamplerArray(self, index, num, array); return this; }
		public uint getSamplerArray(uint index) { return tsKernel_getSamplerArray(self, index); }
		public uint addTexture() { return tsKernel_addTexture(self); }
		public Kernel setTextures(uint num) { tsKernel_setTextures(self, num); return this; }
		public uint getNumTextures() { return tsKernel_getNumTextures(self); }
		public Kernel setTextureOffset(uint offset) { tsKernel_setTextureOffset(self, offset); return this; }
		public uint getTextureOffset() { return tsKernel_getTextureOffset(self); }
		public Kernel setTextureArray(uint index, uint num, bool array) { tsKernel_setTextureArray(self, index, num, array); return this; }
		public uint getTextureArray(uint index) { return tsKernel_getTextureArray(self, index); }
		public uint addSurface() { return tsKernel_addSurface(self); }
		public Kernel setSurfaces(uint num) { tsKernel_setSurfaces(self, num); return this; }
		public uint getNumSurfaces() { return tsKernel_getNumSurfaces(self); }
		public Kernel setSurfaceOffset(uint offset) { tsKernel_setSurfaceOffset(self, offset); return this; }
		public uint getSurfaceOffset() { return tsKernel_getSurfaceOffset(self); }
		public Kernel setSurfaceArray(uint index, uint num, bool array) { tsKernel_setSurfaceArray(self, index, num, array); return this; }
		public uint getSurfaceArray(uint index) { return tsKernel_getSurfaceArray(self, index); }
		public uint addUniform(BindFlags flags = BindFlags.BindFlagNone) { return tsKernel_addUniform(self, flags); }
		public Kernel setUniforms(uint num, BindFlags flags = BindFlags.BindFlagNone) { tsKernel_setUniforms(self, num, flags); return this; }
		public uint getNumUniforms() { return tsKernel_getNumUniforms(self); }
		public Kernel setUniformOffset(uint offset) { tsKernel_setUniformOffset(self, offset); return this; }
		public uint getUniformOffset() { return tsKernel_getUniformOffset(self); }
		public Kernel setUniformFlags(uint index, BindFlags flags) { tsKernel_setUniformFlags(self, index, flags); return this; }
		public BindFlags getUniformFlags(uint index) { return tsKernel_getUniformFlags(self, index); }
		public uint addStorage(BindFlags flags = BindFlags.BindFlagNone) { return tsKernel_addStorage(self, flags); }
		public Kernel setStorages(uint num, BindFlags flags = BindFlags.BindFlagNone) { tsKernel_setStorages(self, num, flags); return this; }
		public uint getNumStorages() { return tsKernel_getNumStorages(self); }
		public Kernel setStorageOffset(uint offset) { tsKernel_setStorageOffset(self, offset); return this; }
		public uint getStorageOffset() { return tsKernel_getStorageOffset(self); }
		public Kernel setStorageFlags(uint index, BindFlags flags) { tsKernel_setStorageFlags(self, index, flags); return this; }
		public BindFlags getStorageFlags(uint index) { return tsKernel_getStorageFlags(self, index); }
		public uint addTracing() { return tsKernel_addTracing(self); }
		public Kernel setTracings(uint num) { tsKernel_setTracings(self, num); return this; }
		public uint getNumTracings() { return tsKernel_getNumTracings(self); }
		public Kernel setTracingOffset(uint offset) { tsKernel_setTracingOffset(self, offset); return this; }
		public uint getTracingOffset() { return tsKernel_getTracingOffset(self); }
		public uint addTexel() { return tsKernel_addTexel(self); }
		public Kernel setTexels(uint num) { tsKernel_setTexels(self, num); return this; }
		public uint getNumTexels() { return tsKernel_getNumTexels(self); }
		public Kernel setTexelOffset(uint offset) { tsKernel_setTexelOffset(self, offset); return this; }
		public uint getTexelOffset() { return tsKernel_getTexelOffset(self); }
		public uint addTable(TableType type, uint size) { return tsKernel_addTable(self, type, size); }
		public uint getNumTables() { return tsKernel_getNumTables(self); }
		public Kernel setTableOffset(uint offset) { tsKernel_setTableOffset(self, offset); return this; }
		public uint getTableOffset() { return tsKernel_getTableOffset(self); }
		public Kernel setTableType(uint index, TableType type, uint size, BindFlags flags = BindFlags.BindFlagNone) { tsKernel_setTableType(self, index, type, size, flags); return this; }
		public TableType getTableType(uint index) { return tsKernel_getTableType(self, index); }
		public uint getTableSize(uint index) { return tsKernel_getTableSize(self, index); }
		public Kernel setTableFlags(uint index, BindFlags flags) { tsKernel_setTableFlags(self, index, flags); return this; }
		public BindFlags getTableFlags(uint index) { return tsKernel_getTableFlags(self, index); }
		public void setGroupSize(uint width, uint height = 1, uint depth = 1) { tsKernel_setGroupSize(self, width, height, depth); }
		public uint getGroupSizeX() { return tsKernel_getGroupSizeX(self); }
		public uint getGroupSizeY() { return tsKernel_getGroupSizeY(self); }
		public uint getGroupSizeZ() { return tsKernel_getGroupSizeZ(self); }
		public override string ToString() { return "Tellusim.Kernel: Valid: " + tsKernel_isValidPtr(self) + "; Owner: " + tsKernel_isOwnerPtr(self) + "; Const: " + tsKernel_isConstPtr(self) + "; Count: " + tsKernel_getCountPtr(self) + "; Internal: 0x" + tsKernel_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Kernel ptr) { return (ptr != null && tsKernel_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_new();
		[DllImport(Base.Import)] private static extern void tsKernel_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsKernel_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsKernel_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsKernel_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_create(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsKernel_setParameters(HandleRef self, HandleRef kernel);
		[DllImport(Base.Import)] private static extern bool tsKernel_saveState(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern void tsKernel_setShader(HandleRef self, HandleRef shader, bool owner);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_getComputeShader(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsKernel_loadShader_ss(HandleRef self, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsKernel_loadShaderGLSL_ss(HandleRef self, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsKernel_loadShader_scSspu(HandleRef self, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsKernel_loadShaderGLSL_scSspu(HandleRef self, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsKernel_loadShaderSPIRV(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsKernel_createShader_ss(HandleRef self, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsKernel_createShaderGLSL_ss(HandleRef self, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsKernel_createShader_scSspu(HandleRef self, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsKernel_createShaderGLSL_scSspu(HandleRef self, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsKernel_createShaderSPIRV(HandleRef self, uint[] data, uint data_size);
		[DllImport(Base.Import)] private static extern uint tsKernel_addSampler(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setSamplers(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumSamplers(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setSamplerOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getSamplerOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setSamplerArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsKernel_getSamplerArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsKernel_addTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTextures(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumTextures(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTextureOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getTextureOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTextureArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsKernel_getTextureArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsKernel_addSurface(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setSurfaces(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumSurfaces(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setSurfaceOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getSurfaceOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setSurfaceArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsKernel_getSurfaceArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsKernel_addUniform(HandleRef self, BindFlags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setUniforms(HandleRef self, uint num, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumUniforms(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setUniformOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getUniformOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setUniformFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsKernel_getUniformFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsKernel_addStorage(HandleRef self, BindFlags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setStorages(HandleRef self, uint num, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumStorages(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setStorageOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getStorageOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setStorageFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsKernel_getStorageFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsKernel_addTracing(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTracings(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumTracings(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTracingOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getTracingOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsKernel_addTexel(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTexels(HandleRef self, uint num);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumTexels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTexelOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getTexelOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsKernel_addTable(HandleRef self, TableType type, uint size);
		[DllImport(Base.Import)] private static extern uint tsKernel_getNumTables(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTableOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsKernel_getTableOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTableType(HandleRef self, uint index, TableType type, uint size, BindFlags flags);
		[DllImport(Base.Import)] private static extern TableType tsKernel_getTableType(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsKernel_getTableSize(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsKernel_setTableFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsKernel_getTableFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsKernel_setGroupSize(HandleRef self, uint width, uint height, uint depth);
		[DllImport(Base.Import)] private static extern uint tsKernel_getGroupSizeX(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsKernel_getGroupSizeY(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsKernel_getGroupSizeZ(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Kernel
	public sealed class D3D12Kernel : Kernel {
		public D3D12Kernel() { self = new HandleRef(this, tsD3D12Kernel_new()); owner = true; }
		public D3D12Kernel(D3D12Kernel ptr) { self = new HandleRef(this, tsD3D12Kernel_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Kernel(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Kernel_isOwnerPtr(self); }
		public D3D12Kernel(Kernel ptr) { self = new HandleRef(this, tsD3D12Kernel_castKernelPtr(ptr.getSelf())); }
		public Kernel toKernel() { return new Kernel(tsD3D12Kernel_baseKernelPtr(self)); }
		public static new D3D12Kernel Null() { return new D3D12Kernel(IntPtr.Zero); }
		public IntPtr getRootSignature() { return tsD3D12Kernel_getRootSignature(self); }
		public override string ToString() { return "Tellusim.D3D12Kernel: Valid: " + tsD3D12Kernel_isValidPtr(self) + "; Owner: " + tsD3D12Kernel_isOwnerPtr(self) + "; Const: " + tsD3D12Kernel_isConstPtr(self) + "; Count: " + tsD3D12Kernel_getCountPtr(self) + "; Internal: 0x" + tsD3D12Kernel_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Kernel ptr) { return (ptr != null && tsD3D12Kernel_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Kernel_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Kernel_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Kernel_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Kernel_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Kernel_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Kernel_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Kernel_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Kernel_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Kernel_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Kernel_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Kernel_equalKernelPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_castKernelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_baseKernelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Kernel_getRootSignature(HandleRef self);
	}
	
	// Tellusim::MTLKernel
	public sealed class MTLKernel : Kernel {
		public MTLKernel() { self = new HandleRef(this, tsMTLKernel_new()); owner = true; }
		public MTLKernel(MTLKernel ptr) { self = new HandleRef(this, tsMTLKernel_copyPtr(ptr.getSelf())); owner = true; }
		public MTLKernel(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLKernel_isOwnerPtr(self); }
		public MTLKernel(Kernel ptr) { self = new HandleRef(this, tsMTLKernel_castKernelPtr(ptr.getSelf())); }
		public Kernel toKernel() { return new Kernel(tsMTLKernel_baseKernelPtr(self)); }
		public static new MTLKernel Null() { return new MTLKernel(IntPtr.Zero); }
		public void setIndirect(bool enabled) { tsMTLKernel_setIndirect(self, enabled); }
		public bool isIndirect() { return tsMTLKernel_isIndirect(self); }
		public IntPtr getComputeFunction() { return tsMTLKernel_getComputeFunction(self); }
		public override string ToString() { return "Tellusim.MTLKernel: Valid: " + tsMTLKernel_isValidPtr(self) + "; Owner: " + tsMTLKernel_isOwnerPtr(self) + "; Const: " + tsMTLKernel_isConstPtr(self) + "; Count: " + tsMTLKernel_getCountPtr(self) + "; Internal: 0x" + tsMTLKernel_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLKernel ptr) { return (ptr != null && tsMTLKernel_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_new();
		[DllImport(Base.Import)] private static extern void tsMTLKernel_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLKernel_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLKernel_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLKernel_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLKernel_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLKernel_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLKernel_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLKernel_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLKernel_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLKernel_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLKernel_equalKernelPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_castKernelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_baseKernelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLKernel_setIndirect(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsMTLKernel_isIndirect(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLKernel_getComputeFunction(HandleRef self);
	}
	
	// Tellusim::FUKernel
	public sealed class FUKernel : Kernel {
		public FUKernel() { self = new HandleRef(this, tsFUKernel_new()); owner = true; }
		public FUKernel(Kernel[] kernels, bool owner = false) {
			IntPtr[] kernels_ = new IntPtr[kernels.Length];
			for(int i = 0; i < kernels.Length; i++) kernels_[i] = kernels[i].getSelfPtr();
			self = new HandleRef(this, tsFUKernel_new_cAKb(kernels_, (uint)kernels.Length, owner)); owner = true;
		}
		public FUKernel(FUKernel ptr) { self = new HandleRef(this, tsFUKernel_copyPtr(ptr.getSelf())); owner = true; }
		public FUKernel(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUKernel_isOwnerPtr(self); }
		public FUKernel(Kernel ptr) { self = new HandleRef(this, tsFUKernel_castKernelPtr(ptr.getSelf())); }
		public Kernel toKernel() { return new Kernel(tsFUKernel_baseKernelPtr(self)); }
		public static new FUKernel Null() { return new FUKernel(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUKernel_setMask(self, mask); }
		public uint getMask() { return tsFUKernel_getMask(self); }
		public uint getNumKernels() { return tsFUKernel_getNumKernels(self); }
		public Kernel getKernel(uint index) { return new Kernel(tsFUKernel_getKernel_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUKernel: Valid: " + tsFUKernel_isValidPtr(self) + "; Owner: " + tsFUKernel_isOwnerPtr(self) + "; Const: " + tsFUKernel_isConstPtr(self) + "; Count: " + tsFUKernel_getCountPtr(self) + "; Internal: 0x" + tsFUKernel_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUKernel ptr) { return (ptr != null && tsFUKernel_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_new_cAKb(IntPtr[] kernels, uint kernels_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUKernel_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUKernel_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUKernel_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUKernel_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUKernel_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUKernel_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUKernel_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUKernel_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUKernel_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUKernel_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUKernel_equalKernelPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_castKernelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_baseKernelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUKernel_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUKernel_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUKernel_getNumKernels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUKernel_getKernel_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Pipeline
	public class Pipeline {
		public enum Primitive : uint {
			Point = 0,
			PointPatch,
			Line,
			LineAdj,
			LineStrip,
			LinePatch,
			Triangle,
			TriangleAdj,
			TriangleStrip,
			TrianglePatch,
			QuadrilateralPatch,
			NumPrimitiveTypes,
		}
		public enum Attribute : uint {
			Position = 0,
			Basis,
			Normal,
			Tangent,
			Binormal,
			TexCoord,
			Weights,
			Joints,
			Color,
			Index,
			NumAttributeTypes,
		}
		public enum FillMode : uint {
			Line = 0,
			Solid,
			NumFillModes,
		}
		public enum CullMode : uint {
			None = 0,
			Back,
			Front,
			NumCullModes,
		}
		public enum FrontMode : uint {
			CCW = 0,
			CW,
			NumFrontModes,
		}
		public enum BlendOp : uint {
			Add = 0,
			Sub,
			Min,
			Max,
			NumBlendOperations,
		}
		public enum BlendFunc : uint {
			None = 0,
			Zero,
			One,
			SrcColor,
			SrcAlpha,
			Src1Color,
			Src1Alpha,
			DestColor,
			DestAlpha,
			FactorColor,
			FactorAlpha,
			InvSrcColor,
			InvSrcAlpha,
			InvSrc1Color,
			InvSrc1Alpha,
			InvDestColor,
			InvDestAlpha,
			InvFactorColor,
			InvFactorAlpha,
			NumBlendFunctions,
		}
		public enum ColorMask : uint {
			None = 0,
			R = 1,
			G = 2,
			B = 4,
			A = 8,
			Unknown = 16,
			RGB = 7,
			All = 15,
		}
		public enum DepthMask : uint {
			None = 0,
			Read,
			Write,
			NumDepthMasks,
		}
		public enum DepthFunc : uint {
			None = 0,
			Never,
			Always,
			Equal,
			Less,
			Greater,
			NotEqual,
			LessEqual,
			GreaterEqual,
			NumDepthFunctions,
		}
		public enum StencilOp : uint {
			Keep = 0,
			Invert,
			Replace,
			IncrWrap,
			DecrWrap,
			IncrSat,
			DecrSat,
			NumStencilOperations,
		}
		public enum StencilFunc : uint {
			None = 0,
			Never,
			Always,
			Equal,
			Less,
			Greater,
			NotEqual,
			LessEqual,
			GreaterEqual,
			NumStencilFunctions,
		}
		public Pipeline() { self = new HandleRef(this, tsPipeline_new()); owner = true; }
		public Pipeline(Pipeline ptr) { self = new HandleRef(this, tsPipeline_copyPtr(ptr.getSelf())); owner = true; }
		public Pipeline(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsPipeline_isOwnerPtr(self); }
		public static Pipeline Null() { return new Pipeline(IntPtr.Zero); }
		~Pipeline() { if(owner) tsPipeline_delete(self); }
		public bool equalPtr(Pipeline ptr) { return tsPipeline_equalPtr(self, ptr.getSelf()); }
		public Pipeline clonePtr() { return new Pipeline(tsPipeline_clonePtr(self)); }
		public void clearPtr() { tsPipeline_clearPtr(self); }
		public void destroyPtr() { tsPipeline_destroyPtr(self); }
		public void acquirePtr() { tsPipeline_acquirePtr(self); }
		public void unacquirePtr() { tsPipeline_unacquirePtr(self); }
		public bool isValidPtr() { return tsPipeline_isValidPtr(self); }
		public bool isOwnerPtr() { return tsPipeline_isOwnerPtr(self); }
		public bool isConstPtr() { return tsPipeline_isConstPtr(self); }
		public uint getCountPtr() { return tsPipeline_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsPipeline_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsPipeline_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsPipeline_getPlatformName(self)); }
		public uint getIndex() { return tsPipeline_getIndex(self); }
		public void clear() { tsPipeline_clear(self); }
		public bool isCreated() { return tsPipeline_isCreated(self); }
		public void setName(string name) { tsPipeline_setName(self, name); }
		public string getName() { return Base.getString(tsPipeline_getName(self)); }
		public bool create() { return tsPipeline_create(self); }
		public void setParameters(Pipeline pipeline) { tsPipeline_setParameters(self, pipeline.getSelf()); }
		public bool saveState(Stream stream) { return tsPipeline_saveState(self, stream.getSelf()); }
		public void addShader(Shader shader, bool owner = false) { tsPipeline_addShader(self, shader.getSelf(), owner); }
		public Shader getVertexShader() { return new Shader(tsPipeline_getVertexShader(self)); }
		public Shader getControlShader() { return new Shader(tsPipeline_getControlShader(self)); }
		public Shader getEvaluateShader() { return new Shader(tsPipeline_getEvaluateShader(self)); }
		public Shader getGeometryShader() { return new Shader(tsPipeline_getGeometryShader(self)); }
		public Shader getFragmentShader() { return new Shader(tsPipeline_getFragmentShader(self)); }
		public Shader getTaskShader() { return new Shader(tsPipeline_getTaskShader(self)); }
		public Shader getMeshShader() { return new Shader(tsPipeline_getMeshShader(self)); }
		public bool loadShader(Shader.Type type, string name, string format, params object[] args) { return tsPipeline_loadShader_STss(self, type, name, System.String.Format(format, args)); }
		public bool loadShaderGLSL(Shader.Type type, string name, string format, params object[] args) { return tsPipeline_loadShaderGLSL_STss(self, type, name, System.String.Format(format, args)); }
		public bool loadShader(Shader.Type type, string name, String macros = null, string[] includes = null) { return tsPipeline_loadShader_STscSspu(self, type, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadShaderGLSL(Shader.Type type, string name, String macros = null, string[] includes = null) { return tsPipeline_loadShaderGLSL_STscSspu(self, type, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadShaderSPIRV(Shader.Type type, string name) { return tsPipeline_loadShaderSPIRV(self, type, name); }
		public bool createShader(Shader.Type type, string src, string format) { return tsPipeline_createShader_STss(self, type, src, format); }
		public bool createShaderGLSL(Shader.Type type, string src, string format) { return tsPipeline_createShaderGLSL_STss(self, type, src, format); }
		public bool createShader(Shader.Type type, string src, String macros = null, string[] includes = null) { return tsPipeline_createShader_STscSspu(self, type, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createShaderGLSL(Shader.Type type, string src, String macros = null, string[] includes = null) { return tsPipeline_createShaderGLSL_STscSspu(self, type, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createShaderSPIRV(Shader.Type type, uint[] data) { return tsPipeline_createShaderSPIRV(self, type, data, (uint)data.Length); }
		public uint addSampler(Shader.Mask mask) { return tsPipeline_addSampler(self, mask); }
		public uint getNumSamplers() { return tsPipeline_getNumSamplers(self); }
		public Pipeline setSamplerOffset(uint offset) { tsPipeline_setSamplerOffset(self, offset); return this; }
		public uint getSamplerOffset() { return tsPipeline_getSamplerOffset(self); }
		public Pipeline setSamplerMask(uint index, Shader.Mask mask) { tsPipeline_setSamplerMask(self, index, mask); return this; }
		public Shader.Mask getSamplerMask(uint index) { return tsPipeline_getSamplerMask(self, index); }
		public Pipeline setSamplerMasks(uint index, uint num, Shader.Mask mask, bool array = false) { tsPipeline_setSamplerMasks(self, index, num, mask, array); return this; }
		public Shader.Mask getSamplerMasks(uint index, uint num) { return tsPipeline_getSamplerMasks(self, index, num); }
		public Pipeline setSamplerArray(uint index, uint num, bool array) { tsPipeline_setSamplerArray(self, index, num, array); return this; }
		public uint getSamplerArray(uint index) { return tsPipeline_getSamplerArray(self, index); }
		public uint addTexture(Shader.Mask mask) { return tsPipeline_addTexture(self, mask); }
		public uint getNumTextures() { return tsPipeline_getNumTextures(self); }
		public Pipeline setTextureOffset(uint offset) { tsPipeline_setTextureOffset(self, offset); return this; }
		public uint getTextureOffset() { return tsPipeline_getTextureOffset(self); }
		public Pipeline setTextureMask(uint index, Shader.Mask mask) { tsPipeline_setTextureMask(self, index, mask); return this; }
		public Shader.Mask getTextureMask(uint index) { return tsPipeline_getTextureMask(self, index); }
		public Pipeline setTextureMasks(uint index, uint num, Shader.Mask mask, bool array = false) { tsPipeline_setTextureMasks(self, index, num, mask, array); return this; }
		public Shader.Mask getTextureMasks(uint index, uint num) { return tsPipeline_getTextureMasks(self, index, num); }
		public Pipeline setTextureArray(uint index, uint num, bool array) { tsPipeline_setTextureArray(self, index, num, array); return this; }
		public uint getTextureArray(uint index) { return tsPipeline_getTextureArray(self, index); }
		public uint addSurface(Shader.Mask mask) { return tsPipeline_addSurface(self, mask); }
		public uint getNumSurfaces() { return tsPipeline_getNumSurfaces(self); }
		public Pipeline setSurfaceOffset(uint offset) { tsPipeline_setSurfaceOffset(self, offset); return this; }
		public uint getSurfaceOffset() { return tsPipeline_getSurfaceOffset(self); }
		public Pipeline setSurfaceMask(uint index, Shader.Mask mask) { tsPipeline_setSurfaceMask(self, index, mask); return this; }
		public Shader.Mask getSurfaceMask(uint index) { return tsPipeline_getSurfaceMask(self, index); }
		public Pipeline setSurfaceMasks(uint index, uint num, Shader.Mask mask, bool array = false) { tsPipeline_setSurfaceMasks(self, index, num, mask, array); return this; }
		public Shader.Mask getSurfaceMasks(uint index, uint num) { return tsPipeline_getSurfaceMasks(self, index, num); }
		public Pipeline setSurfaceArray(uint index, uint num, bool array) { tsPipeline_setSurfaceArray(self, index, num, array); return this; }
		public uint getSurfaceArray(uint index) { return tsPipeline_getSurfaceArray(self, index); }
		public uint addUniform(Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { return tsPipeline_addUniform(self, mask, flags); }
		public uint getNumUniforms() { return tsPipeline_getNumUniforms(self); }
		public Pipeline setUniformOffset(uint offset) { tsPipeline_setUniformOffset(self, offset); return this; }
		public uint getUniformOffset() { return tsPipeline_getUniformOffset(self); }
		public Pipeline setUniformMask(uint index, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsPipeline_setUniformMask(self, index, mask, flags); return this; }
		public Shader.Mask getUniformMask(uint index) { return tsPipeline_getUniformMask(self, index); }
		public Pipeline setUniformMasks(uint index, uint num, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsPipeline_setUniformMasks(self, index, num, mask, flags); return this; }
		public Shader.Mask getUniformMasks(uint index, uint num) { return tsPipeline_getUniformMasks(self, index, num); }
		public Pipeline setUniformFlags(uint index, BindFlags flags) { tsPipeline_setUniformFlags(self, index, flags); return this; }
		public BindFlags getUniformFlags(uint index) { return tsPipeline_getUniformFlags(self, index); }
		public uint addStorage(Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { return tsPipeline_addStorage(self, mask, flags); }
		public uint getNumStorages() { return tsPipeline_getNumStorages(self); }
		public Pipeline setStorageOffset(uint offset) { tsPipeline_setStorageOffset(self, offset); return this; }
		public uint getStorageOffset() { return tsPipeline_getStorageOffset(self); }
		public Pipeline setStorageMask(uint index, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsPipeline_setStorageMask(self, index, mask, flags); return this; }
		public Shader.Mask getStorageMask(uint index) { return tsPipeline_getStorageMask(self, index); }
		public Pipeline setStorageMasks(uint index, uint num, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsPipeline_setStorageMasks(self, index, num, mask, flags); return this; }
		public Shader.Mask getStorageMasks(uint index, uint num) { return tsPipeline_getStorageMasks(self, index, num); }
		public Pipeline setStorageFlags(uint index, BindFlags flags) { tsPipeline_setStorageFlags(self, index, flags); return this; }
		public BindFlags getStorageFlags(uint index) { return tsPipeline_getStorageFlags(self, index); }
		public uint addTracing(Shader.Mask mask) { return tsPipeline_addTracing(self, mask); }
		public uint getNumTracings() { return tsPipeline_getNumTracings(self); }
		public Pipeline setTracingOffset(uint offset) { tsPipeline_setTracingOffset(self, offset); return this; }
		public uint getTracingOffset() { return tsPipeline_getTracingOffset(self); }
		public Pipeline setTracingMask(uint index, Shader.Mask mask) { tsPipeline_setTracingMask(self, index, mask); return this; }
		public Shader.Mask getTracingMask(uint index) { return tsPipeline_getTracingMask(self, index); }
		public Pipeline setTracingMasks(uint index, uint num, Shader.Mask mask) { tsPipeline_setTracingMasks(self, index, num, mask); return this; }
		public Shader.Mask getTracingMasks(uint index, uint num) { return tsPipeline_getTracingMasks(self, index, num); }
		public uint addTexel(Shader.Mask mask) { return tsPipeline_addTexel(self, mask); }
		public uint getNumTexels() { return tsPipeline_getNumTexels(self); }
		public Pipeline setTexelOffset(uint offset) { tsPipeline_setTexelOffset(self, offset); return this; }
		public uint getTexelOffset() { return tsPipeline_getTexelOffset(self); }
		public Pipeline setTexelMask(uint index, Shader.Mask mask) { tsPipeline_setTexelMask(self, index, mask); return this; }
		public Shader.Mask getTexelMask(uint index) { return tsPipeline_getTexelMask(self, index); }
		public Pipeline setTexelMasks(uint index, uint num, Shader.Mask mask) { tsPipeline_setTexelMasks(self, index, num, mask); return this; }
		public Shader.Mask getTexelMasks(uint index, uint num) { return tsPipeline_getTexelMasks(self, index, num); }
		public uint addTable(TableType type, uint size, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { return tsPipeline_addTable(self, type, size, mask, flags); }
		public uint getNumTables() { return tsPipeline_getNumTables(self); }
		public Pipeline setTableOffset(uint offset) { tsPipeline_setTableOffset(self, offset); return this; }
		public uint getTableOffset() { return tsPipeline_getTableOffset(self); }
		public Pipeline setTableType(uint index, TableType type, uint size, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsPipeline_setTableType(self, index, type, size, mask, flags); return this; }
		public TableType getTableType(uint index) { return tsPipeline_getTableType(self, index); }
		public uint getTableSize(uint index) { return tsPipeline_getTableSize(self, index); }
		public Pipeline setTableMask(uint index, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsPipeline_setTableMask(self, index, mask, flags); return this; }
		public Shader.Mask getTableMask(uint index) { return tsPipeline_getTableMask(self, index); }
		public Pipeline setTableFlags(uint index, BindFlags flags) { tsPipeline_setTableFlags(self, index, flags); return this; }
		public BindFlags getTableFlags(uint index) { return tsPipeline_getTableFlags(self, index); }
		public uint getNumVertices() { return tsPipeline_getNumVertices(self); }
		public uint getVertexStride(uint index) { return tsPipeline_getVertexStride(self, index); }
		public uint getVertexRate(uint index) { return tsPipeline_getVertexRate(self, index); }
		public uint addAttribute(Attribute attribute, Format format, uint vertex, ulong offset, ulong stride, uint rate = 0) { return tsPipeline_addAttribute(self, attribute, format, vertex, offset, stride, rate); }
		public Pipeline setAttribute(uint index, Attribute attribute, Format format, uint vertex, ulong offset, ulong stride, uint rate = 0) { tsPipeline_setAttribute(self, index, attribute, format, vertex, offset, stride, rate); return this; }
		public Pipeline setAttributeType(uint index, Attribute attribute) { tsPipeline_setAttributeType(self, index, attribute); return this; }
		public Pipeline setAttributeFormat(uint index, Format format) { tsPipeline_setAttributeFormat(self, index, format); return this; }
		public Pipeline setAttributeVertex(uint index, uint vertex) { tsPipeline_setAttributeVertex(self, index, vertex); return this; }
		public Pipeline setAttributeOffset(uint index, ulong offset) { tsPipeline_setAttributeOffset(self, index, offset); return this; }
		public Pipeline setAttributeStride(uint index, ulong stride) { tsPipeline_setAttributeStride(self, index, stride); return this; }
		public Pipeline setAttributeRate(uint index, uint rate) { tsPipeline_setAttributeRate(self, index, rate); return this; }
		public uint getNumAttributes() { return tsPipeline_getNumAttributes(self); }
		public Attribute getAttributeType(uint index) { return tsPipeline_getAttributeType(self, index); }
		public Format getAttributeFormat(uint index) { return tsPipeline_getAttributeFormat(self, index); }
		public uint getAttributeVertex(uint index) { return tsPipeline_getAttributeVertex(self, index); }
		public uint getAttributeOffset(uint index) { return tsPipeline_getAttributeOffset(self, index); }
		public uint getAttributeStride(uint index) { return tsPipeline_getAttributeStride(self, index); }
		public uint getAttributeRate(uint index) { return tsPipeline_getAttributeRate(self, index); }
		public void setPrimitive(Primitive primitive) { tsPipeline_setPrimitive(self, primitive); }
		public Primitive getPrimitive() { return tsPipeline_getPrimitive(self); }
		public void setFillMode(FillMode mode) { tsPipeline_setFillMode(self, mode); }
		public FillMode getFillMode() { return tsPipeline_getFillMode(self); }
		public void setCullMode(CullMode mode) { tsPipeline_setCullMode(self, mode); }
		public CullMode getCullMode() { return tsPipeline_getCullMode(self); }
		public void setFrontMode(FrontMode mode) { tsPipeline_setFrontMode(self, mode); }
		public FrontMode getFrontMode() { return tsPipeline_getFrontMode(self); }
		public void setDepthBias(float bias, float slope, float clamp = 0.0f) { tsPipeline_setDepthBias(self, bias, slope, clamp); }
		public float getDepthBias() { return tsPipeline_getDepthBias(self); }
		public float getDepthSlope() { return tsPipeline_getDepthSlope(self); }
		public float getDepthClamp() { return tsPipeline_getDepthClamp(self); }
		public void setMultisample(uint multisample) { tsPipeline_setMultisample(self, multisample); }
		public uint getMultisample() { return tsPipeline_getMultisample(self); }
		public void setSampleMask(uint sample_mask) { tsPipeline_setSampleMask(self, sample_mask); }
		public uint getSampleMask() { return tsPipeline_getSampleMask(self); }
		public void setDepthClip(bool enabled) { tsPipeline_setDepthClip(self, enabled); }
		public bool getDepthClip() { return tsPipeline_getDepthClip(self); }
		public void setDepthReplace(bool enabled) { tsPipeline_setDepthReplace(self, enabled); }
		public bool getDepthReplace() { return tsPipeline_getDepthReplace(self); }
		public void setScissorTest(bool enabled) { tsPipeline_setScissorTest(self, enabled); }
		public bool getScissorTest() { return tsPipeline_getScissorTest(self); }
		public void setRasterDiscard(bool enabled) { tsPipeline_setRasterDiscard(self, enabled); }
		public bool getRasterDiscard() { return tsPipeline_getRasterDiscard(self); }
		public void setSampleShading(bool enabled) { tsPipeline_setSampleShading(self, enabled); }
		public bool getSampleShading() { return tsPipeline_getSampleShading(self); }
		public void setAlphaToCoverage(bool enabled) { tsPipeline_setAlphaToCoverage(self, enabled); }
		public bool getAlphaToCoverage() { return tsPipeline_getAlphaToCoverage(self); }
		public void setMultisampleRaster(bool enabled) { tsPipeline_setMultisampleRaster(self, enabled); }
		public bool getMultisampleRaster() { return tsPipeline_getMultisampleRaster(self); }
		public void setConservativeRaster(bool enabled) { tsPipeline_setConservativeRaster(self, enabled); }
		public bool getConservativeRaster() { return tsPipeline_getConservativeRaster(self); }
		public void setNumViewports(uint num_viewports) { tsPipeline_setNumViewports(self, num_viewports); }
		public uint getNumTargets() { return tsPipeline_getNumTargets(self); }
		public uint getNumViewports() { return tsPipeline_getNumViewports(self); }
		public void setNumClipDistances(uint num_distances) { tsPipeline_setNumClipDistances(self, num_distances); }
		public uint getNumClipDistances() { return tsPipeline_getNumClipDistances(self); }
		public void setBlend(BlendOp op, BlendFunc src, BlendFunc dest) { tsPipeline_setBlend_PBOPBFPBF(self, op, src, dest); }
		public void setBlendColor(BlendOp op, BlendFunc src, BlendFunc dest) { tsPipeline_setBlendColor_PBOPBFPBF(self, op, src, dest); }
		public void setBlendAlpha(BlendOp op, BlendFunc src, BlendFunc dest) { tsPipeline_setBlendAlpha_PBOPBFPBF(self, op, src, dest); }
		public void setBlend(uint index, BlendOp op, BlendFunc src, BlendFunc dest) { tsPipeline_setBlend_uPBOPBFPBF(self, index, op, src, dest); }
		public void setBlendColor(uint index, BlendOp op, BlendFunc src, BlendFunc dest) { tsPipeline_setBlendColor_uPBOPBFPBF(self, index, op, src, dest); }
		public void setBlendAlpha(uint index, BlendOp op, BlendFunc src, BlendFunc dest) { tsPipeline_setBlendAlpha_uPBOPBFPBF(self, index, op, src, dest); }
		public BlendOp getBlendColorOp(uint index) { return tsPipeline_getBlendColorOp(self, index); }
		public BlendOp getBlendAlphaOp(uint index) { return tsPipeline_getBlendAlphaOp(self, index); }
		public BlendFunc getBlendSrcColorFunc(uint index) { return tsPipeline_getBlendSrcColorFunc(self, index); }
		public BlendFunc getBlendSrcAlphaFunc(uint index) { return tsPipeline_getBlendSrcAlphaFunc(self, index); }
		public BlendFunc getBlendDestColorFunc(uint index) { return tsPipeline_getBlendDestColorFunc(self, index); }
		public BlendFunc getBlendDestAlphaFunc(uint index) { return tsPipeline_getBlendDestAlphaFunc(self, index); }
		public void setColorMask(ColorMask mask) { tsPipeline_setColorMask_PCM(self, mask); }
		public void setColorMask(uint index, ColorMask mask) { tsPipeline_setColorMask_uPCM(self, index, mask); }
		public void setColorFormat(uint index, Format format) { tsPipeline_setColorFormat_uF(self, index, format); }
		public void setColorFormat(Format format, uint num = 1) { tsPipeline_setColorFormat_Fu(self, format, num); }
		public ColorMask getColorMask(uint index) { return tsPipeline_getColorMask(self, index); }
		public Format getColorFormat(uint index) { return tsPipeline_getColorFormat(self, index); }
		public void setDepthMask(DepthMask mask) { tsPipeline_setDepthMask(self, mask); }
		public void setDepthFunc(DepthFunc func) { tsPipeline_setDepthFunc(self, func); }
		public void setDepthFormat(Format format) { tsPipeline_setDepthFormat(self, format); }
		public DepthMask getDepthMask() { return tsPipeline_getDepthMask(self); }
		public DepthFunc getDepthFunc() { return tsPipeline_getDepthFunc(self); }
		public Format getDepthFormat() { return tsPipeline_getDepthFormat(self); }
		public void setStencilMask(uint mask) { tsPipeline_setStencilMask(self, mask); }
		public void setStencilBackMask(uint mask) { tsPipeline_setStencilBackMask(self, mask); }
		public void setStencilFrontMask(uint mask) { tsPipeline_setStencilFrontMask(self, mask); }
		public void setStencilFunc(StencilFunc func, StencilOp dpass_op) { tsPipeline_setStencilFunc_PSFPSO(self, func, dpass_op); }
		public void setStencilBackFunc(StencilFunc func, StencilOp dpass_op) { tsPipeline_setStencilBackFunc_PSFPSO(self, func, dpass_op); }
		public void setStencilFrontFunc(StencilFunc func, StencilOp dpass_op) { tsPipeline_setStencilFrontFunc_PSFPSO(self, func, dpass_op); }
		public void setStencilFunc(StencilFunc func, StencilOp fail_op, StencilOp dfail_op, StencilOp dpass_op) { tsPipeline_setStencilFunc_PSFPSOPSOPSO(self, func, fail_op, dfail_op, dpass_op); }
		public void setStencilBackFunc(StencilFunc func, StencilOp fail_op, StencilOp dfail_op, StencilOp dpass_op) { tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(self, func, fail_op, dfail_op, dpass_op); }
		public void setStencilFrontFunc(StencilFunc func, StencilOp fail_op, StencilOp dfail_op, StencilOp dpass_op) { tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(self, func, fail_op, dfail_op, dpass_op); }
		public uint getStencilBackMask() { return tsPipeline_getStencilBackMask(self); }
		public StencilFunc getStencilBackFunc() { return tsPipeline_getStencilBackFunc(self); }
		public StencilOp getStencilBackFailOp() { return tsPipeline_getStencilBackFailOp(self); }
		public StencilOp getStencilBackDepthFailOp() { return tsPipeline_getStencilBackDepthFailOp(self); }
		public StencilOp getStencilBackDepthPassOp() { return tsPipeline_getStencilBackDepthPassOp(self); }
		public uint getStencilFrontMask() { return tsPipeline_getStencilFrontMask(self); }
		public StencilFunc getStencilFrontFunc() { return tsPipeline_getStencilFrontFunc(self); }
		public StencilOp getStencilFrontFailOp() { return tsPipeline_getStencilFrontFailOp(self); }
		public StencilOp getStencilFrontDepthFailOp() { return tsPipeline_getStencilFrontDepthFailOp(self); }
		public StencilOp getStencilFrontDepthPassOp() { return tsPipeline_getStencilFrontDepthPassOp(self); }
		public override string ToString() { return "Tellusim.Pipeline: Valid: " + tsPipeline_isValidPtr(self) + "; Owner: " + tsPipeline_isOwnerPtr(self) + "; Const: " + tsPipeline_isConstPtr(self) + "; Count: " + tsPipeline_getCountPtr(self) + "; Internal: 0x" + tsPipeline_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Pipeline ptr) { return (ptr != null && tsPipeline_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_new();
		[DllImport(Base.Import)] private static extern void tsPipeline_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsPipeline_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_create(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setParameters(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern bool tsPipeline_saveState(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern void tsPipeline_addShader(HandleRef self, HandleRef shader, bool owner);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getVertexShader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getControlShader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getEvaluateShader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getGeometryShader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getFragmentShader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getTaskShader(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_getMeshShader(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPipeline_loadShader_STss(HandleRef self, Shader.Type type, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsPipeline_loadShaderGLSL_STss(HandleRef self, Shader.Type type, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsPipeline_loadShader_STscSspu(HandleRef self, Shader.Type type, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsPipeline_loadShaderGLSL_STscSspu(HandleRef self, Shader.Type type, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsPipeline_loadShaderSPIRV(HandleRef self, Shader.Type type, string name);
		[DllImport(Base.Import)] private static extern bool tsPipeline_createShader_STss(HandleRef self, Shader.Type type, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsPipeline_createShaderGLSL_STss(HandleRef self, Shader.Type type, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsPipeline_createShader_STscSspu(HandleRef self, Shader.Type type, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsPipeline_createShaderGLSL_STscSspu(HandleRef self, Shader.Type type, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsPipeline_createShaderSPIRV(HandleRef self, Shader.Type type, uint[] data, uint data_size);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addSampler(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumSamplers(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSamplerOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getSamplerOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSamplerMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getSamplerMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSamplerMasks(HandleRef self, uint index, uint num, Shader.Mask mask, bool array);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getSamplerMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSamplerArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getSamplerArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addTexture(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumTextures(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTextureOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getTextureOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTextureMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTextureMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTextureMasks(HandleRef self, uint index, uint num, Shader.Mask mask, bool array);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTextureMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTextureArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getTextureArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addSurface(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumSurfaces(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSurfaceOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getSurfaceOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSurfaceMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getSurfaceMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSurfaceMasks(HandleRef self, uint index, uint num, Shader.Mask mask, bool array);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getSurfaceMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setSurfaceArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getSurfaceArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addUniform(HandleRef self, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumUniforms(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setUniformOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getUniformOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setUniformMask(HandleRef self, uint index, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getUniformMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setUniformMasks(HandleRef self, uint index, uint num, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getUniformMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setUniformFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsPipeline_getUniformFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addStorage(HandleRef self, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumStorages(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setStorageOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getStorageOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setStorageMask(HandleRef self, uint index, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getStorageMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setStorageMasks(HandleRef self, uint index, uint num, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getStorageMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setStorageFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsPipeline_getStorageFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addTracing(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumTracings(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTracingOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getTracingOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTracingMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTracingMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTracingMasks(HandleRef self, uint index, uint num, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTracingMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addTexel(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumTexels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTexelOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getTexelOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTexelMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTexelMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTexelMasks(HandleRef self, uint index, uint num, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTexelMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addTable(HandleRef self, TableType type, uint size, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumTables(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTableOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getTableOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTableType(HandleRef self, uint index, TableType type, uint size, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern TableType tsPipeline_getTableType(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getTableSize(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTableMask(HandleRef self, uint index, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsPipeline_getTableMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setTableFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsPipeline_getTableFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumVertices(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getVertexStride(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getVertexRate(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_addAttribute(HandleRef self, Attribute attribute, Format format, uint vertex, ulong offset, ulong stride, uint rate);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttribute(HandleRef self, uint index, Attribute attribute, Format format, uint vertex, ulong offset, ulong stride, uint rate);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttributeType(HandleRef self, uint index, Attribute attribute);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttributeFormat(HandleRef self, uint index, Format format);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttributeVertex(HandleRef self, uint index, uint vertex);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttributeOffset(HandleRef self, uint index, ulong offset);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttributeStride(HandleRef self, uint index, ulong stride);
		[DllImport(Base.Import)] private static extern IntPtr tsPipeline_setAttributeRate(HandleRef self, uint index, uint rate);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumAttributes(HandleRef self);
		[DllImport(Base.Import)] private static extern Attribute tsPipeline_getAttributeType(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Format tsPipeline_getAttributeFormat(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getAttributeVertex(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getAttributeOffset(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getAttributeStride(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getAttributeRate(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsPipeline_setPrimitive(HandleRef self, Primitive primitive);
		[DllImport(Base.Import)] private static extern Primitive tsPipeline_getPrimitive(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setFillMode(HandleRef self, FillMode mode);
		[DllImport(Base.Import)] private static extern FillMode tsPipeline_getFillMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setCullMode(HandleRef self, CullMode mode);
		[DllImport(Base.Import)] private static extern CullMode tsPipeline_getCullMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setFrontMode(HandleRef self, FrontMode mode);
		[DllImport(Base.Import)] private static extern FrontMode tsPipeline_getFrontMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setDepthBias(HandleRef self, float bias, float slope, float clamp);
		[DllImport(Base.Import)] private static extern float tsPipeline_getDepthBias(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsPipeline_getDepthSlope(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsPipeline_getDepthClamp(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setMultisample(HandleRef self, uint multisample);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setSampleMask(HandleRef self, uint sample_mask);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getSampleMask(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setDepthClip(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getDepthClip(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setDepthReplace(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getDepthReplace(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setScissorTest(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getScissorTest(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setRasterDiscard(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getRasterDiscard(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setSampleShading(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getSampleShading(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setAlphaToCoverage(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getAlphaToCoverage(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setMultisampleRaster(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getMultisampleRaster(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setConservativeRaster(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsPipeline_getConservativeRaster(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setNumViewports(HandleRef self, uint num_viewports);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumTargets(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumViewports(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setNumClipDistances(HandleRef self, uint num_distances);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getNumClipDistances(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setBlend_PBOPBFPBF(HandleRef self, BlendOp op, BlendFunc src, BlendFunc dest);
		[DllImport(Base.Import)] private static extern void tsPipeline_setBlendColor_PBOPBFPBF(HandleRef self, BlendOp op, BlendFunc src, BlendFunc dest);
		[DllImport(Base.Import)] private static extern void tsPipeline_setBlendAlpha_PBOPBFPBF(HandleRef self, BlendOp op, BlendFunc src, BlendFunc dest);
		[DllImport(Base.Import)] private static extern void tsPipeline_setBlend_uPBOPBFPBF(HandleRef self, uint index, BlendOp op, BlendFunc src, BlendFunc dest);
		[DllImport(Base.Import)] private static extern void tsPipeline_setBlendColor_uPBOPBFPBF(HandleRef self, uint index, BlendOp op, BlendFunc src, BlendFunc dest);
		[DllImport(Base.Import)] private static extern void tsPipeline_setBlendAlpha_uPBOPBFPBF(HandleRef self, uint index, BlendOp op, BlendFunc src, BlendFunc dest);
		[DllImport(Base.Import)] private static extern BlendOp tsPipeline_getBlendColorOp(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern BlendOp tsPipeline_getBlendAlphaOp(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern BlendFunc tsPipeline_getBlendSrcColorFunc(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern BlendFunc tsPipeline_getBlendSrcAlphaFunc(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern BlendFunc tsPipeline_getBlendDestColorFunc(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern BlendFunc tsPipeline_getBlendDestAlphaFunc(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsPipeline_setColorMask_PCM(HandleRef self, ColorMask mask);
		[DllImport(Base.Import)] private static extern void tsPipeline_setColorMask_uPCM(HandleRef self, uint index, ColorMask mask);
		[DllImport(Base.Import)] private static extern void tsPipeline_setColorFormat_uF(HandleRef self, uint index, Format format);
		[DllImport(Base.Import)] private static extern void tsPipeline_setColorFormat_Fu(HandleRef self, Format format, uint num);
		[DllImport(Base.Import)] private static extern ColorMask tsPipeline_getColorMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Format tsPipeline_getColorFormat(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsPipeline_setDepthMask(HandleRef self, DepthMask mask);
		[DllImport(Base.Import)] private static extern void tsPipeline_setDepthFunc(HandleRef self, DepthFunc func);
		[DllImport(Base.Import)] private static extern void tsPipeline_setDepthFormat(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern DepthMask tsPipeline_getDepthMask(HandleRef self);
		[DllImport(Base.Import)] private static extern DepthFunc tsPipeline_getDepthFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsPipeline_getDepthFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilBackMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilFrontMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilFunc_PSFPSO(HandleRef self, StencilFunc func, StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilBackFunc_PSFPSO(HandleRef self, StencilFunc func, StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilFrontFunc_PSFPSO(HandleRef self, StencilFunc func, StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilFunc_PSFPSOPSOPSO(HandleRef self, StencilFunc func, StencilOp fail_op, StencilOp dfail_op, StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(HandleRef self, StencilFunc func, StencilOp fail_op, StencilOp dfail_op, StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern void tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(HandleRef self, StencilFunc func, StencilOp fail_op, StencilOp dfail_op, StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getStencilBackMask(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilFunc tsPipeline_getStencilBackFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilOp tsPipeline_getStencilBackFailOp(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilOp tsPipeline_getStencilBackDepthFailOp(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilOp tsPipeline_getStencilBackDepthPassOp(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPipeline_getStencilFrontMask(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilFunc tsPipeline_getStencilFrontFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilOp tsPipeline_getStencilFrontFailOp(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilOp tsPipeline_getStencilFrontDepthFailOp(HandleRef self);
		[DllImport(Base.Import)] private static extern StencilOp tsPipeline_getStencilFrontDepthPassOp(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Pipeline
	public sealed class D3D12Pipeline : Pipeline {
		public D3D12Pipeline() { self = new HandleRef(this, tsD3D12Pipeline_new()); owner = true; }
		public D3D12Pipeline(D3D12Pipeline ptr) { self = new HandleRef(this, tsD3D12Pipeline_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Pipeline(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Pipeline_isOwnerPtr(self); }
		public D3D12Pipeline(Pipeline ptr) { self = new HandleRef(this, tsD3D12Pipeline_castPipelinePtr(ptr.getSelf())); }
		public Pipeline toPipeline() { return new Pipeline(tsD3D12Pipeline_basePipelinePtr(self)); }
		public static new D3D12Pipeline Null() { return new D3D12Pipeline(IntPtr.Zero); }
		public IntPtr getRootSignature() { return tsD3D12Pipeline_getRootSignature(self); }
		public override string ToString() { return "Tellusim.D3D12Pipeline: Valid: " + tsD3D12Pipeline_isValidPtr(self) + "; Owner: " + tsD3D12Pipeline_isOwnerPtr(self) + "; Const: " + tsD3D12Pipeline_isConstPtr(self) + "; Count: " + tsD3D12Pipeline_getCountPtr(self) + "; Internal: 0x" + tsD3D12Pipeline_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Pipeline ptr) { return (ptr != null && tsD3D12Pipeline_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Pipeline_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Pipeline_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Pipeline_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Pipeline_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Pipeline_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Pipeline_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Pipeline_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Pipeline_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Pipeline_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Pipeline_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Pipeline_equalPipelinePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_castPipelinePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_basePipelinePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Pipeline_getRootSignature(HandleRef self);
	}
	
	// Tellusim::MTLPipeline
	public sealed class MTLPipeline : Pipeline {
		public MTLPipeline() { self = new HandleRef(this, tsMTLPipeline_new()); owner = true; }
		public MTLPipeline(MTLPipeline ptr) { self = new HandleRef(this, tsMTLPipeline_copyPtr(ptr.getSelf())); owner = true; }
		public MTLPipeline(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLPipeline_isOwnerPtr(self); }
		public MTLPipeline(Pipeline ptr) { self = new HandleRef(this, tsMTLPipeline_castPipelinePtr(ptr.getSelf())); }
		public Pipeline toPipeline() { return new Pipeline(tsMTLPipeline_basePipelinePtr(self)); }
		public static new MTLPipeline Null() { return new MTLPipeline(IntPtr.Zero); }
		public void setIndirect(bool enabled) { tsMTLPipeline_setIndirect(self, enabled); }
		public bool isIndirect() { return tsMTLPipeline_isIndirect(self); }
		public IntPtr getVertexFunction() { return tsMTLPipeline_getVertexFunction(self); }
		public IntPtr getFragmentFunction() { return tsMTLPipeline_getFragmentFunction(self); }
		public override string ToString() { return "Tellusim.MTLPipeline: Valid: " + tsMTLPipeline_isValidPtr(self) + "; Owner: " + tsMTLPipeline_isOwnerPtr(self) + "; Const: " + tsMTLPipeline_isConstPtr(self) + "; Count: " + tsMTLPipeline_getCountPtr(self) + "; Internal: 0x" + tsMTLPipeline_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLPipeline ptr) { return (ptr != null && tsMTLPipeline_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_new();
		[DllImport(Base.Import)] private static extern void tsMTLPipeline_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLPipeline_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLPipeline_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLPipeline_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLPipeline_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLPipeline_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLPipeline_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLPipeline_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLPipeline_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLPipeline_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLPipeline_equalPipelinePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_castPipelinePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_basePipelinePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLPipeline_setIndirect(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsMTLPipeline_isIndirect(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_getVertexFunction(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLPipeline_getFragmentFunction(HandleRef self);
	}
	
	// Tellusim::FUPipeline
	public sealed class FUPipeline : Pipeline {
		public FUPipeline() { self = new HandleRef(this, tsFUPipeline_new()); owner = true; }
		public FUPipeline(Pipeline[] pipelines, bool owner = false) {
			IntPtr[] pipelines_ = new IntPtr[pipelines.Length];
			for(int i = 0; i < pipelines.Length; i++) pipelines_[i] = pipelines[i].getSelfPtr();
			self = new HandleRef(this, tsFUPipeline_new_cAPb(pipelines_, (uint)pipelines.Length, owner)); owner = true;
		}
		public FUPipeline(FUPipeline ptr) { self = new HandleRef(this, tsFUPipeline_copyPtr(ptr.getSelf())); owner = true; }
		public FUPipeline(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUPipeline_isOwnerPtr(self); }
		public FUPipeline(Pipeline ptr) { self = new HandleRef(this, tsFUPipeline_castPipelinePtr(ptr.getSelf())); }
		public Pipeline toPipeline() { return new Pipeline(tsFUPipeline_basePipelinePtr(self)); }
		public static new FUPipeline Null() { return new FUPipeline(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUPipeline_setMask(self, mask); }
		public uint getMask() { return tsFUPipeline_getMask(self); }
		public uint getNumPipelines() { return tsFUPipeline_getNumPipelines(self); }
		public Pipeline getPipeline(uint index) { return new Pipeline(tsFUPipeline_getPipeline_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUPipeline: Valid: " + tsFUPipeline_isValidPtr(self) + "; Owner: " + tsFUPipeline_isOwnerPtr(self) + "; Const: " + tsFUPipeline_isConstPtr(self) + "; Count: " + tsFUPipeline_getCountPtr(self) + "; Internal: 0x" + tsFUPipeline_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUPipeline ptr) { return (ptr != null && tsFUPipeline_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_new_cAPb(IntPtr[] pipelines, uint pipelines_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUPipeline_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUPipeline_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUPipeline_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUPipeline_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUPipeline_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUPipeline_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUPipeline_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUPipeline_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUPipeline_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUPipeline_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUPipeline_equalPipelinePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_castPipelinePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_basePipelinePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUPipeline_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUPipeline_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUPipeline_getNumPipelines(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUPipeline_getPipeline_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Traversal
	public class Traversal {
		public Traversal() { self = new HandleRef(this, tsTraversal_new()); owner = true; }
		public Traversal(Traversal ptr) { self = new HandleRef(this, tsTraversal_copyPtr(ptr.getSelf())); owner = true; }
		public Traversal(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsTraversal_isOwnerPtr(self); }
		public static Traversal Null() { return new Traversal(IntPtr.Zero); }
		~Traversal() { if(owner) tsTraversal_delete(self); }
		public bool equalPtr(Traversal ptr) { return tsTraversal_equalPtr(self, ptr.getSelf()); }
		public Traversal clonePtr() { return new Traversal(tsTraversal_clonePtr(self)); }
		public void clearPtr() { tsTraversal_clearPtr(self); }
		public void destroyPtr() { tsTraversal_destroyPtr(self); }
		public void acquirePtr() { tsTraversal_acquirePtr(self); }
		public void unacquirePtr() { tsTraversal_unacquirePtr(self); }
		public bool isValidPtr() { return tsTraversal_isValidPtr(self); }
		public bool isOwnerPtr() { return tsTraversal_isOwnerPtr(self); }
		public bool isConstPtr() { return tsTraversal_isConstPtr(self); }
		public uint getCountPtr() { return tsTraversal_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsTraversal_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsTraversal_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsTraversal_getPlatformName(self)); }
		public uint getIndex() { return tsTraversal_getIndex(self); }
		public void clear() { tsTraversal_clear(self); }
		public bool isCreated() { return tsTraversal_isCreated(self); }
		public void setName(string name) { tsTraversal_setName(self, name); }
		public string getName() { return Base.getString(tsTraversal_getName(self)); }
		public bool create() { return tsTraversal_create(self); }
		public void setParameters(Traversal traversal) { tsTraversal_setParameters(self, traversal.getSelf()); }
		public bool saveState(Stream stream) { return tsTraversal_saveState(self, stream.getSelf()); }
		public void addShader(Shader shader, bool owner = false) { tsTraversal_addShader(self, shader.getSelf(), owner); }
		public Shader getRayGenShader() { return new Shader(tsTraversal_getRayGenShader(self)); }
		public bool loadShader(Shader.Type type, string name, string format, params object[] args) { return tsTraversal_loadShader_STss(self, type, name, System.String.Format(format, args)); }
		public bool loadShaderGLSL(Shader.Type type, string name, string format, params object[] args) { return tsTraversal_loadShaderGLSL_STss(self, type, name, System.String.Format(format, args)); }
		public bool loadShader(Shader.Type type, string name, String macros = null, string[] includes = null) { return tsTraversal_loadShader_STscSspu(self, type, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadShaderGLSL(Shader.Type type, string name, String macros = null, string[] includes = null) { return tsTraversal_loadShaderGLSL_STscSspu(self, type, name, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool loadShaderSPIRV(Shader.Type type, string name) { return tsTraversal_loadShaderSPIRV(self, type, name); }
		public bool createShader(Shader.Type type, string src, string format) { return tsTraversal_createShader_STss(self, type, src, format); }
		public bool createShaderGLSL(Shader.Type type, string src, string format) { return tsTraversal_createShaderGLSL_STss(self, type, src, format); }
		public bool createShader(Shader.Type type, string src, String macros = null, string[] includes = null) { return tsTraversal_createShader_STscSspu(self, type, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createShaderGLSL(Shader.Type type, string src, String macros = null, string[] includes = null) { return tsTraversal_createShaderGLSL_STscSspu(self, type, src, (macros != null) ? macros.getSelf() : Base.Null, includes, (includes != null) ? (uint)includes.Length : 0); }
		public bool createShaderSPIRV(Shader.Type type, uint[] data) { return tsTraversal_createShaderSPIRV(self, type, data, (uint)data.Length); }
		public uint addSampler(Shader.Mask mask) { return tsTraversal_addSampler(self, mask); }
		public uint getNumSamplers() { return tsTraversal_getNumSamplers(self); }
		public Traversal setSamplerOffset(uint offset) { tsTraversal_setSamplerOffset(self, offset); return this; }
		public uint getSamplerOffset() { return tsTraversal_getSamplerOffset(self); }
		public Traversal setSamplerMask(uint index, Shader.Mask mask) { tsTraversal_setSamplerMask(self, index, mask); return this; }
		public Shader.Mask getSamplerMask(uint index) { return tsTraversal_getSamplerMask(self, index); }
		public Traversal setSamplerMasks(uint index, uint num, Shader.Mask mask, bool array = false) { tsTraversal_setSamplerMasks(self, index, num, mask, array); return this; }
		public Shader.Mask getSamplerMasks(uint index, uint num) { return tsTraversal_getSamplerMasks(self, index, num); }
		public Traversal setSamplerArray(uint index, uint num, bool array) { tsTraversal_setSamplerArray(self, index, num, array); return this; }
		public uint getSamplerArray(uint index) { return tsTraversal_getSamplerArray(self, index); }
		public uint addTexture(Shader.Mask mask) { return tsTraversal_addTexture(self, mask); }
		public uint getNumTextures() { return tsTraversal_getNumTextures(self); }
		public Traversal setTextureOffset(uint offset) { tsTraversal_setTextureOffset(self, offset); return this; }
		public uint getTextureOffset() { return tsTraversal_getTextureOffset(self); }
		public Traversal setTextureMask(uint index, Shader.Mask mask) { tsTraversal_setTextureMask(self, index, mask); return this; }
		public Shader.Mask getTextureMask(uint index) { return tsTraversal_getTextureMask(self, index); }
		public Traversal setTextureMasks(uint index, uint num, Shader.Mask mask, bool array = false) { tsTraversal_setTextureMasks(self, index, num, mask, array); return this; }
		public Shader.Mask getTextureMasks(uint index, uint num) { return tsTraversal_getTextureMasks(self, index, num); }
		public Traversal setTextureArray(uint index, uint num, bool array) { tsTraversal_setTextureArray(self, index, num, array); return this; }
		public uint getTextureArray(uint index) { return tsTraversal_getTextureArray(self, index); }
		public uint addSurface(Shader.Mask mask) { return tsTraversal_addSurface(self, mask); }
		public uint getNumSurfaces() { return tsTraversal_getNumSurfaces(self); }
		public Traversal setSurfaceOffset(uint offset) { tsTraversal_setSurfaceOffset(self, offset); return this; }
		public uint getSurfaceOffset() { return tsTraversal_getSurfaceOffset(self); }
		public Traversal setSurfaceMask(uint index, Shader.Mask mask) { tsTraversal_setSurfaceMask(self, index, mask); return this; }
		public Shader.Mask getSurfaceMask(uint index) { return tsTraversal_getSurfaceMask(self, index); }
		public Traversal setSurfaceMasks(uint index, uint num, Shader.Mask mask, bool array = false) { tsTraversal_setSurfaceMasks(self, index, num, mask, array); return this; }
		public Shader.Mask getSurfaceMasks(uint index, uint num) { return tsTraversal_getSurfaceMasks(self, index, num); }
		public Traversal setSurfaceArray(uint index, uint num, bool array) { tsTraversal_setSurfaceArray(self, index, num, array); return this; }
		public uint getSurfaceArray(uint index) { return tsTraversal_getSurfaceArray(self, index); }
		public uint addUniform(Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { return tsTraversal_addUniform(self, mask, flags); }
		public uint getNumUniforms() { return tsTraversal_getNumUniforms(self); }
		public Traversal setUniformOffset(uint offset) { tsTraversal_setUniformOffset(self, offset); return this; }
		public uint getUniformOffset() { return tsTraversal_getUniformOffset(self); }
		public Traversal setUniformMask(uint index, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsTraversal_setUniformMask(self, index, mask, flags); return this; }
		public Shader.Mask getUniformMask(uint index) { return tsTraversal_getUniformMask(self, index); }
		public Traversal setUniformMasks(uint index, uint num, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsTraversal_setUniformMasks(self, index, num, mask, flags); return this; }
		public Shader.Mask getUniformMasks(uint index, uint num) { return tsTraversal_getUniformMasks(self, index, num); }
		public Traversal setUniformFlags(uint index, BindFlags flags) { tsTraversal_setUniformFlags(self, index, flags); return this; }
		public BindFlags getUniformFlags(uint index) { return tsTraversal_getUniformFlags(self, index); }
		public uint addStorage(Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { return tsTraversal_addStorage(self, mask, flags); }
		public uint getNumStorages() { return tsTraversal_getNumStorages(self); }
		public Traversal setStorageOffset(uint offset) { tsTraversal_setStorageOffset(self, offset); return this; }
		public uint getStorageOffset() { return tsTraversal_getStorageOffset(self); }
		public Traversal setStorageMask(uint index, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsTraversal_setStorageMask(self, index, mask, flags); return this; }
		public Shader.Mask getStorageMask(uint index) { return tsTraversal_getStorageMask(self, index); }
		public Traversal setStorageMasks(uint index, uint num, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsTraversal_setStorageMasks(self, index, num, mask, flags); return this; }
		public Shader.Mask getStorageMasks(uint index, uint num) { return tsTraversal_getStorageMasks(self, index, num); }
		public Traversal setStorageFlags(uint index, BindFlags flags) { tsTraversal_setStorageFlags(self, index, flags); return this; }
		public BindFlags getStorageFlags(uint index) { return tsTraversal_getStorageFlags(self, index); }
		public uint addTracing(Shader.Mask mask) { return tsTraversal_addTracing(self, mask); }
		public uint getNumTracings() { return tsTraversal_getNumTracings(self); }
		public Traversal setTracingOffset(uint offset) { tsTraversal_setTracingOffset(self, offset); return this; }
		public uint getTracingOffset() { return tsTraversal_getTracingOffset(self); }
		public Traversal setTracingMask(uint index, Shader.Mask mask) { tsTraversal_setTracingMask(self, index, mask); return this; }
		public Shader.Mask getTracingMask(uint index) { return tsTraversal_getTracingMask(self, index); }
		public Traversal setTracingMasks(uint index, uint num, Shader.Mask mask) { tsTraversal_setTracingMasks(self, index, num, mask); return this; }
		public Shader.Mask getTracingMasks(uint index, uint num) { return tsTraversal_getTracingMasks(self, index, num); }
		public uint addTexel(Shader.Mask mask) { return tsTraversal_addTexel(self, mask); }
		public uint getNumTexels() { return tsTraversal_getNumTexels(self); }
		public Traversal setTexelOffset(uint offset) { tsTraversal_setTexelOffset(self, offset); return this; }
		public uint getTexelOffset() { return tsTraversal_getTexelOffset(self); }
		public Traversal setTexelMask(uint index, Shader.Mask mask) { tsTraversal_setTexelMask(self, index, mask); return this; }
		public Shader.Mask getTexelMask(uint index) { return tsTraversal_getTexelMask(self, index); }
		public Traversal setTexelMasks(uint index, uint num, Shader.Mask mask) { tsTraversal_setTexelMasks(self, index, num, mask); return this; }
		public Shader.Mask getTexelMasks(uint index, uint num) { return tsTraversal_getTexelMasks(self, index, num); }
		public uint addTable(TableType type, uint size, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { return tsTraversal_addTable(self, type, size, mask, flags); }
		public uint getNumTables() { return tsTraversal_getNumTables(self); }
		public Traversal setTableOffset(uint offset) { tsTraversal_setTableOffset(self, offset); return this; }
		public uint getTableOffset() { return tsTraversal_getTableOffset(self); }
		public Traversal setTableType(uint index, TableType type, uint size, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsTraversal_setTableType(self, index, type, size, mask, flags); return this; }
		public TableType getTableType(uint index) { return tsTraversal_getTableType(self, index); }
		public uint getTableSize(uint index) { return tsTraversal_getTableSize(self, index); }
		public Traversal setTableMask(uint index, Shader.Mask mask, BindFlags flags = BindFlags.BindFlagNone) { tsTraversal_setTableMask(self, index, mask, flags); return this; }
		public Shader.Mask getTableMask(uint index) { return tsTraversal_getTableMask(self, index); }
		public Traversal setTableFlags(uint index, BindFlags flags) { tsTraversal_setTableFlags(self, index, flags); return this; }
		public BindFlags getTableFlags(uint index) { return tsTraversal_getTableFlags(self, index); }
		public void setRecursionDepth(uint depth) { tsTraversal_setRecursionDepth(self, depth); }
		public uint getRecursionDepth() { return tsTraversal_getRecursionDepth(self); }
		public override string ToString() { return "Tellusim.Traversal: Valid: " + tsTraversal_isValidPtr(self) + "; Owner: " + tsTraversal_isOwnerPtr(self) + "; Const: " + tsTraversal_isConstPtr(self) + "; Count: " + tsTraversal_getCountPtr(self) + "; Internal: 0x" + tsTraversal_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Traversal ptr) { return (ptr != null && tsTraversal_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_new();
		[DllImport(Base.Import)] private static extern void tsTraversal_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsTraversal_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_create(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTraversal_setParameters(HandleRef self, HandleRef traversal);
		[DllImport(Base.Import)] private static extern bool tsTraversal_saveState(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern void tsTraversal_addShader(HandleRef self, HandleRef shader, bool owner);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_getRayGenShader(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTraversal_loadShader_STss(HandleRef self, Shader.Type type, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsTraversal_loadShaderGLSL_STss(HandleRef self, Shader.Type type, string name, string format);
		[DllImport(Base.Import)] private static extern bool tsTraversal_loadShader_STscSspu(HandleRef self, Shader.Type type, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsTraversal_loadShaderGLSL_STscSspu(HandleRef self, Shader.Type type, string name, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsTraversal_loadShaderSPIRV(HandleRef self, Shader.Type type, string name);
		[DllImport(Base.Import)] private static extern bool tsTraversal_createShader_STss(HandleRef self, Shader.Type type, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsTraversal_createShaderGLSL_STss(HandleRef self, Shader.Type type, string src, string format);
		[DllImport(Base.Import)] private static extern bool tsTraversal_createShader_STscSspu(HandleRef self, Shader.Type type, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsTraversal_createShaderGLSL_STscSspu(HandleRef self, Shader.Type type, string src, HandleRef macros, string[] includes, uint size);
		[DllImport(Base.Import)] private static extern bool tsTraversal_createShaderSPIRV(HandleRef self, Shader.Type type, uint[] data, uint data_size);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addSampler(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumSamplers(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSamplerOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getSamplerOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSamplerMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getSamplerMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSamplerMasks(HandleRef self, uint index, uint num, Shader.Mask mask, bool array);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getSamplerMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSamplerArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getSamplerArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addTexture(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumTextures(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTextureOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getTextureOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTextureMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTextureMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTextureMasks(HandleRef self, uint index, uint num, Shader.Mask mask, bool array);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTextureMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTextureArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getTextureArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addSurface(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumSurfaces(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSurfaceOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getSurfaceOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSurfaceMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getSurfaceMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSurfaceMasks(HandleRef self, uint index, uint num, Shader.Mask mask, bool array);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getSurfaceMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setSurfaceArray(HandleRef self, uint index, uint num, bool array);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getSurfaceArray(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addUniform(HandleRef self, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumUniforms(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setUniformOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getUniformOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setUniformMask(HandleRef self, uint index, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getUniformMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setUniformMasks(HandleRef self, uint index, uint num, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getUniformMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setUniformFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsTraversal_getUniformFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addStorage(HandleRef self, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumStorages(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setStorageOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getStorageOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setStorageMask(HandleRef self, uint index, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getStorageMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setStorageMasks(HandleRef self, uint index, uint num, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getStorageMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setStorageFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsTraversal_getStorageFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addTracing(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumTracings(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTracingOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getTracingOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTracingMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTracingMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTracingMasks(HandleRef self, uint index, uint num, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTracingMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addTexel(HandleRef self, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumTexels(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTexelOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getTexelOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTexelMask(HandleRef self, uint index, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTexelMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTexelMasks(HandleRef self, uint index, uint num, Shader.Mask mask);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTexelMasks(HandleRef self, uint index, uint num);
		[DllImport(Base.Import)] private static extern uint tsTraversal_addTable(HandleRef self, TableType type, uint size, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getNumTables(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTableOffset(HandleRef self, uint offset);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getTableOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTableType(HandleRef self, uint index, TableType type, uint size, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern TableType tsTraversal_getTableType(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getTableSize(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTableMask(HandleRef self, uint index, Shader.Mask mask, BindFlags flags);
		[DllImport(Base.Import)] private static extern Shader.Mask tsTraversal_getTableMask(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsTraversal_setTableFlags(HandleRef self, uint index, BindFlags flags);
		[DllImport(Base.Import)] private static extern BindFlags tsTraversal_getTableFlags(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsTraversal_setRecursionDepth(HandleRef self, uint depth);
		[DllImport(Base.Import)] private static extern uint tsTraversal_getRecursionDepth(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Traversal
	public sealed class D3D12Traversal : Traversal {
		public D3D12Traversal() { self = new HandleRef(this, tsD3D12Traversal_new()); owner = true; }
		public D3D12Traversal(D3D12Traversal ptr) { self = new HandleRef(this, tsD3D12Traversal_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Traversal(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Traversal_isOwnerPtr(self); }
		public D3D12Traversal(Traversal ptr) { self = new HandleRef(this, tsD3D12Traversal_castTraversalPtr(ptr.getSelf())); }
		public Traversal toTraversal() { return new Traversal(tsD3D12Traversal_baseTraversalPtr(self)); }
		public static new D3D12Traversal Null() { return new D3D12Traversal(IntPtr.Zero); }
		public IntPtr getRootSignature() { return tsD3D12Traversal_getRootSignature(self); }
		public override string ToString() { return "Tellusim.D3D12Traversal: Valid: " + tsD3D12Traversal_isValidPtr(self) + "; Owner: " + tsD3D12Traversal_isOwnerPtr(self) + "; Const: " + tsD3D12Traversal_isConstPtr(self) + "; Count: " + tsD3D12Traversal_getCountPtr(self) + "; Internal: 0x" + tsD3D12Traversal_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Traversal ptr) { return (ptr != null && tsD3D12Traversal_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_new();
		[DllImport(Base.Import)] private static extern void tsD3D12Traversal_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Traversal_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Traversal_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Traversal_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Traversal_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Traversal_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Traversal_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Traversal_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Traversal_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Traversal_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Traversal_equalTraversalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_castTraversalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_baseTraversalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Traversal_getRootSignature(HandleRef self);
	}
	
	// Tellusim::FUTraversal
	public sealed class FUTraversal : Traversal {
		public FUTraversal() { self = new HandleRef(this, tsFUTraversal_new()); owner = true; }
		public FUTraversal(Traversal[] traversals, bool owner = false) {
			IntPtr[] traversals_ = new IntPtr[traversals.Length];
			for(int i = 0; i < traversals.Length; i++) traversals_[i] = traversals[i].getSelfPtr();
			self = new HandleRef(this, tsFUTraversal_new_cATb(traversals_, (uint)traversals.Length, owner)); owner = true;
		}
		public FUTraversal(FUTraversal ptr) { self = new HandleRef(this, tsFUTraversal_copyPtr(ptr.getSelf())); owner = true; }
		public FUTraversal(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFUTraversal_isOwnerPtr(self); }
		public FUTraversal(Traversal ptr) { self = new HandleRef(this, tsFUTraversal_castTraversalPtr(ptr.getSelf())); }
		public Traversal toTraversal() { return new Traversal(tsFUTraversal_baseTraversalPtr(self)); }
		public static new FUTraversal Null() { return new FUTraversal(IntPtr.Zero); }
		public void setMask(uint mask) { tsFUTraversal_setMask(self, mask); }
		public uint getMask() { return tsFUTraversal_getMask(self); }
		public uint getNumTraversals() { return tsFUTraversal_getNumTraversals(self); }
		public Traversal getTraversal(uint index) { return new Traversal(tsFUTraversal_getTraversal_cu(self, index)); }
		public override string ToString() { return "Tellusim.FUTraversal: Valid: " + tsFUTraversal_isValidPtr(self) + "; Owner: " + tsFUTraversal_isOwnerPtr(self) + "; Const: " + tsFUTraversal_isConstPtr(self) + "; Count: " + tsFUTraversal_getCountPtr(self) + "; Internal: 0x" + tsFUTraversal_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FUTraversal ptr) { return (ptr != null && tsFUTraversal_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_new();
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_new_cATb(IntPtr[] traversals, uint traversals_size, bool owner);
		[DllImport(Base.Import)] private static extern void tsFUTraversal_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTraversal_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTraversal_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTraversal_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTraversal_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTraversal_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTraversal_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTraversal_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTraversal_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTraversal_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFUTraversal_equalTraversalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_castTraversalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_baseTraversalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFUTraversal_setMask(HandleRef self, uint mask);
		[DllImport(Base.Import)] private static extern uint tsFUTraversal_getMask(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFUTraversal_getNumTraversals(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFUTraversal_getTraversal_cu(HandleRef self, uint index);
	}
	
	// Tellusim::Surface
	public class Surface {
		public Surface() { self = new HandleRef(this, tsSurface_new()); owner = true; }
		public Surface(Context context) { self = new HandleRef(this, tsSurface_new_C(context.getSelf())); owner = true; }
		public Surface(Platform platform) { self = new HandleRef(this, tsSurface_new_P(platform)); owner = true; }
		public Surface(Surface ptr) { self = new HandleRef(this, tsSurface_copyPtr(ptr.getSelf())); owner = true; }
		public Surface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSurface_isOwnerPtr(self); }
		public static Surface Null() { return new Surface(IntPtr.Zero); }
		~Surface() { if(owner) tsSurface_delete(self); }
		public bool equalPtr(Surface ptr) { return tsSurface_equalPtr(self, ptr.getSelf()); }
		public Surface clonePtr() { return new Surface(tsSurface_clonePtr(self)); }
		public void clearPtr() { tsSurface_clearPtr(self); }
		public void destroyPtr() { tsSurface_destroyPtr(self); }
		public void acquirePtr() { tsSurface_acquirePtr(self); }
		public void unacquirePtr() { tsSurface_unacquirePtr(self); }
		public bool isValidPtr() { return tsSurface_isValidPtr(self); }
		public bool isOwnerPtr() { return tsSurface_isOwnerPtr(self); }
		public bool isConstPtr() { return tsSurface_isConstPtr(self); }
		public uint getCountPtr() { return tsSurface_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsSurface_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Platform getPlatform() { return tsSurface_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsSurface_getPlatformName(self)); }
		public uint getIndex() { return tsSurface_getIndex(self); }
		public void setSize(uint width, uint height) { tsSurface_setSize(self, width, height); }
		public uint getWidth() { return tsSurface_getWidth(self); }
		public uint getHeight() { return tsSurface_getHeight(self); }
		public void setMultisample(uint multisample) { tsSurface_setMultisample(self, multisample); }
		public uint getMultisample() { return tsSurface_getMultisample(self); }
		public bool hasMultisample() { return tsSurface_hasMultisample(self); }
		public void setColorLayer(uint layer, uint layers) { tsSurface_setColorLayer(self, layer, layers); }
		public void setDepthLayer(uint layer, uint layers) { tsSurface_setDepthLayer(self, layer, layers); }
		public uint getColorLayer() { return tsSurface_getColorLayer(self); }
		public uint getDepthLayer() { return tsSurface_getDepthLayer(self); }
		public uint getColorLayers() { return tsSurface_getColorLayers(self); }
		public uint getDepthLayers() { return tsSurface_getDepthLayers(self); }
		public bool hasColorLayers() { return tsSurface_hasColorLayers(self); }
		public bool hasDepthLayers() { return tsSurface_hasDepthLayers(self); }
		public void setColorFormat(Format format) { tsSurface_setColorFormat(self, format); }
		public void setDepthFormat(Format format) { tsSurface_setDepthFormat(self, format); }
		public Format getColorFormat() { return tsSurface_getColorFormat(self); }
		public Format getDepthFormat() { return tsSurface_getDepthFormat(self); }
		public override string ToString() { return "Tellusim.Surface: Valid: " + tsSurface_isValidPtr(self) + "; Owner: " + tsSurface_isOwnerPtr(self) + "; Const: " + tsSurface_isConstPtr(self) + "; Count: " + tsSurface_getCountPtr(self) + "; Internal: 0x" + tsSurface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Surface ptr) { return (ptr != null && tsSurface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_new_C(HandleRef context);
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_new_P(Platform platform);
		[DllImport(Base.Import)] private static extern void tsSurface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSurface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Platform tsSurface_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSurface_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSurface_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_setSize(HandleRef self, uint width, uint height);
		[DllImport(Base.Import)] private static extern uint tsSurface_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSurface_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_setMultisample(HandleRef self, uint multisample);
		[DllImport(Base.Import)] private static extern uint tsSurface_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_hasMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_setColorLayer(HandleRef self, uint layer, uint layers);
		[DllImport(Base.Import)] private static extern void tsSurface_setDepthLayer(HandleRef self, uint layer, uint layers);
		[DllImport(Base.Import)] private static extern uint tsSurface_getColorLayer(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSurface_getDepthLayer(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSurface_getColorLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSurface_getDepthLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_hasColorLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSurface_hasDepthLayers(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSurface_setColorFormat(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern void tsSurface_setDepthFormat(HandleRef self, Format format);
		[DllImport(Base.Import)] private static extern Format tsSurface_getColorFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsSurface_getDepthFormat(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::D3D12Surface
	public sealed class D3D12Surface : Surface {
		public D3D12Surface() { self = new HandleRef(this, tsD3D12Surface_new()); owner = true; }
		public D3D12Surface(D3D12Context context) { self = new HandleRef(this, tsD3D12Surface_new_D3D12C(context.getSelf())); owner = true; }
		public D3D12Surface(D3D12Surface ptr) { self = new HandleRef(this, tsD3D12Surface_copyPtr(ptr.getSelf())); owner = true; }
		public D3D12Surface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D12Surface_isOwnerPtr(self); }
		public D3D12Surface(Surface ptr) { self = new HandleRef(this, tsD3D12Surface_castSurfacePtr(ptr.getSelf())); }
		public Surface toSurface() { return new Surface(tsD3D12Surface_baseSurfacePtr(self)); }
		public static new D3D12Surface Null() { return new D3D12Surface(IntPtr.Zero); }
		public IntPtr getFactory() { return tsD3D12Surface_getFactory(self); }
		public IntPtr getDevice() { return tsD3D12Surface_getDevice(self); }
		public IntPtr getQueue() { return tsD3D12Surface_getQueue(self); }
		public IntPtr getCommand() { return tsD3D12Surface_getCommand(self); }
		public void setSwapChain(IntPtr swap_chain) { tsD3D12Surface_setSwapChain(self, swap_chain); }
		public IntPtr getSwapChain() { return tsD3D12Surface_getSwapChain(self); }
		public void setRenderTarget(IntPtr render_target) { tsD3D12Surface_setRenderTarget(self, render_target); }
		public void setDepthStencil(IntPtr depth_stencil) { tsD3D12Surface_setDepthStencil(self, depth_stencil); }
		public IntPtr getRenderTarget() { return tsD3D12Surface_getRenderTarget(self); }
		public IntPtr getDepthStencil() { return tsD3D12Surface_getDepthStencil(self); }
		public void setRenderTargetView(ulong render_target_view) { tsD3D12Surface_setRenderTargetView(self, render_target_view); }
		public void setDepthStencilView(ulong depth_stencil_view) { tsD3D12Surface_setDepthStencilView(self, depth_stencil_view); }
		public ulong getRenderTargetView() { return tsD3D12Surface_getRenderTargetView(self); }
		public ulong getDepthStencilView() { return tsD3D12Surface_getDepthStencilView(self); }
		public uint getColorDXGIFormat() { return tsD3D12Surface_getColorDXGIFormat(self); }
		public uint getDepthDXGIFormat() { return tsD3D12Surface_getDepthDXGIFormat(self); }
		public override string ToString() { return "Tellusim.D3D12Surface: Valid: " + tsD3D12Surface_isValidPtr(self) + "; Owner: " + tsD3D12Surface_isOwnerPtr(self) + "; Const: " + tsD3D12Surface_isConstPtr(self) + "; Count: " + tsD3D12Surface_getCountPtr(self) + "; Internal: 0x" + tsD3D12Surface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D12Surface ptr) { return (ptr != null && tsD3D12Surface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_new_D3D12C(HandleRef context);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Surface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Surface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Surface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Surface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Surface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D12Surface_equalSurfacePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_castSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_baseSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getFactory(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_setSwapChain(HandleRef self, IntPtr swap_chain);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getSwapChain(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_setRenderTarget(HandleRef self, IntPtr render_target);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_setDepthStencil(HandleRef self, IntPtr depth_stencil);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getRenderTarget(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D12Surface_getDepthStencil(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_setRenderTargetView(HandleRef self, ulong render_target_view);
		[DllImport(Base.Import)] private static extern void tsD3D12Surface_setDepthStencilView(HandleRef self, ulong depth_stencil_view);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Surface_getRenderTargetView(HandleRef self);
		[DllImport(Base.Import)] private static extern ulong tsD3D12Surface_getDepthStencilView(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Surface_getColorDXGIFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D12Surface_getDepthDXGIFormat(HandleRef self);
	}
	
	// Tellusim::D3D11Surface
	public sealed class D3D11Surface : Surface {
		public D3D11Surface() { self = new HandleRef(this, tsD3D11Surface_new()); owner = true; }
		public D3D11Surface(D3D11Context context) { self = new HandleRef(this, tsD3D11Surface_new_D3D11C(context.getSelf())); owner = true; }
		public D3D11Surface(D3D11Surface ptr) { self = new HandleRef(this, tsD3D11Surface_copyPtr(ptr.getSelf())); owner = true; }
		public D3D11Surface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsD3D11Surface_isOwnerPtr(self); }
		public D3D11Surface(Surface ptr) { self = new HandleRef(this, tsD3D11Surface_castSurfacePtr(ptr.getSelf())); }
		public Surface toSurface() { return new Surface(tsD3D11Surface_baseSurfacePtr(self)); }
		public static new D3D11Surface Null() { return new D3D11Surface(IntPtr.Zero); }
		public IntPtr getFactory() { return tsD3D11Surface_getFactory(self); }
		public IntPtr getDevice() { return tsD3D11Surface_getDevice(self); }
		public IntPtr getContext() { return tsD3D11Surface_getContext(self); }
		public void setSwapChain(IntPtr swap_chain) { tsD3D11Surface_setSwapChain(self, swap_chain); }
		public IntPtr getSwapChain() { return tsD3D11Surface_getSwapChain(self); }
		public void setRenderTarget(IntPtr render_target) { tsD3D11Surface_setRenderTarget(self, render_target); }
		public void setDepthStencil(IntPtr depth_stencil) { tsD3D11Surface_setDepthStencil(self, depth_stencil); }
		public IntPtr getRenderTarget() { return tsD3D11Surface_getRenderTarget(self); }
		public IntPtr getDepthStencil() { return tsD3D11Surface_getDepthStencil(self); }
		public void setRenderTargetView(IntPtr render_target_view) { tsD3D11Surface_setRenderTargetView(self, render_target_view); }
		public void setDepthStencilView(IntPtr depth_stencil_view) { tsD3D11Surface_setDepthStencilView(self, depth_stencil_view); }
		public IntPtr getRenderTargetView() { return tsD3D11Surface_getRenderTargetView(self); }
		public IntPtr getDepthStencilView() { return tsD3D11Surface_getDepthStencilView(self); }
		public uint getColorDXGIFormat() { return tsD3D11Surface_getColorDXGIFormat(self); }
		public uint getDepthDXGIFormat() { return tsD3D11Surface_getDepthDXGIFormat(self); }
		public override string ToString() { return "Tellusim.D3D11Surface: Valid: " + tsD3D11Surface_isValidPtr(self) + "; Owner: " + tsD3D11Surface_isOwnerPtr(self) + "; Const: " + tsD3D11Surface_isConstPtr(self) + "; Count: " + tsD3D11Surface_getCountPtr(self) + "; Internal: 0x" + tsD3D11Surface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(D3D11Surface ptr) { return (ptr != null && tsD3D11Surface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_new_D3D11C(HandleRef context);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Surface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Surface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Surface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Surface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Surface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsD3D11Surface_equalSurfacePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_castSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_baseSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getFactory(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getContext(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_setSwapChain(HandleRef self, IntPtr swap_chain);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getSwapChain(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_setRenderTarget(HandleRef self, IntPtr render_target);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_setDepthStencil(HandleRef self, IntPtr depth_stencil);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getRenderTarget(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getDepthStencil(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_setRenderTargetView(HandleRef self, IntPtr render_target_view);
		[DllImport(Base.Import)] private static extern void tsD3D11Surface_setDepthStencilView(HandleRef self, IntPtr depth_stencil_view);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getRenderTargetView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsD3D11Surface_getDepthStencilView(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Surface_getColorDXGIFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsD3D11Surface_getDepthDXGIFormat(HandleRef self);
	}
	
	// Tellusim::MTLSurface
	public sealed class MTLSurface : Surface {
		public MTLSurface() { self = new HandleRef(this, tsMTLSurface_new()); owner = true; }
		public MTLSurface(MTLContext context) { self = new HandleRef(this, tsMTLSurface_new_M(context.getSelf())); owner = true; }
		public MTLSurface(MTLSurface ptr) { self = new HandleRef(this, tsMTLSurface_copyPtr(ptr.getSelf())); owner = true; }
		public MTLSurface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsMTLSurface_isOwnerPtr(self); }
		public MTLSurface(Surface ptr) { self = new HandleRef(this, tsMTLSurface_castSurfacePtr(ptr.getSelf())); }
		public Surface toSurface() { return new Surface(tsMTLSurface_baseSurfacePtr(self)); }
		public static new MTLSurface Null() { return new MTLSurface(IntPtr.Zero); }
		public IntPtr getDevice() { return tsMTLSurface_getDevice(self); }
		public IntPtr getQueue() { return tsMTLSurface_getQueue(self); }
		public IntPtr getCommand() { return tsMTLSurface_getCommand(self); }
		public void setDescriptor(IntPtr descriptor) { tsMTLSurface_setDescriptor(self, descriptor); }
		public IntPtr getDescriptor() { return tsMTLSurface_getDescriptor(self); }
		public uint getColorPixelFormat() { return tsMTLSurface_getColorPixelFormat(self); }
		public uint getDepthPixelFormat() { return tsMTLSurface_getDepthPixelFormat(self); }
		public override string ToString() { return "Tellusim.MTLSurface: Valid: " + tsMTLSurface_isValidPtr(self) + "; Owner: " + tsMTLSurface_isOwnerPtr(self) + "; Const: " + tsMTLSurface_isConstPtr(self) + "; Count: " + tsMTLSurface_getCountPtr(self) + "; Internal: 0x" + tsMTLSurface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MTLSurface ptr) { return (ptr != null && tsMTLSurface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_new_M(HandleRef context);
		[DllImport(Base.Import)] private static extern void tsMTLSurface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSurface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSurface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSurface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSurface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSurface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSurface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSurface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSurface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLSurface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMTLSurface_equalSurfacePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_castSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_baseSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMTLSurface_setDescriptor(HandleRef self, IntPtr descriptor);
		[DllImport(Base.Import)] private static extern IntPtr tsMTLSurface_getDescriptor(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLSurface_getColorPixelFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMTLSurface_getDepthPixelFormat(HandleRef self);
	}
	
	// Tellusim::VKSurface
	public sealed class VKSurface : Surface {
		public VKSurface() { self = new HandleRef(this, tsVKSurface_new()); owner = true; }
		public VKSurface(VKContext context) { self = new HandleRef(this, tsVKSurface_new_V(context.getSelf())); owner = true; }
		public VKSurface(VKSurface ptr) { self = new HandleRef(this, tsVKSurface_copyPtr(ptr.getSelf())); owner = true; }
		public VKSurface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsVKSurface_isOwnerPtr(self); }
		public VKSurface(Surface ptr) { self = new HandleRef(this, tsVKSurface_castSurfacePtr(ptr.getSelf())); }
		public Surface toSurface() { return new Surface(tsVKSurface_baseSurfacePtr(self)); }
		public static new VKSurface Null() { return new VKSurface(IntPtr.Zero); }
		public IntPtr getInstance() { return tsVKSurface_getInstance(self); }
		public IntPtr getAdapter() { return tsVKSurface_getAdapter(self); }
		public IntPtr getDevice() { return tsVKSurface_getDevice(self); }
		public IntPtr getQueue() { return tsVKSurface_getQueue(self); }
		public IntPtr getCommand() { return tsVKSurface_getCommand(self); }
		public uint getFamily() { return tsVKSurface_getFamily(self); }
		public void setSwapChain(IntPtr swap_chain) { tsVKSurface_setSwapChain(self, swap_chain); }
		public IntPtr getSwapChain() { return tsVKSurface_getSwapChain(self); }
		public void setColorImage(IntPtr image) { tsVKSurface_setColorImage(self, image); }
		public void setDepthImage(IntPtr image) { tsVKSurface_setDepthImage(self, image); }
		public IntPtr getColorImage() { return tsVKSurface_getColorImage(self); }
		public IntPtr getDepthImage() { return tsVKSurface_getDepthImage(self); }
		public void setColorImageView(IntPtr image_view) { tsVKSurface_setColorImageView(self, image_view); }
		public void setDepthImageView(IntPtr image_view) { tsVKSurface_setDepthImageView(self, image_view); }
		public IntPtr getColorImageView() { return tsVKSurface_getColorImageView(self); }
		public IntPtr getDepthImageView() { return tsVKSurface_getDepthImageView(self); }
		public void setRenderPass(IntPtr render_pass) { tsVKSurface_setRenderPass(self, render_pass); }
		public void setFramebuffer(IntPtr framebuffer) { tsVKSurface_setFramebuffer(self, framebuffer); }
		public IntPtr getRenderPass() { return tsVKSurface_getRenderPass(self); }
		public IntPtr getFramebuffer() { return tsVKSurface_getFramebuffer(self); }
		public uint getColorPixelFormat() { return tsVKSurface_getColorPixelFormat(self); }
		public uint getDepthPixelFormat() { return tsVKSurface_getDepthPixelFormat(self); }
		public override string ToString() { return "Tellusim.VKSurface: Valid: " + tsVKSurface_isValidPtr(self) + "; Owner: " + tsVKSurface_isOwnerPtr(self) + "; Const: " + tsVKSurface_isConstPtr(self) + "; Count: " + tsVKSurface_getCountPtr(self) + "; Internal: 0x" + tsVKSurface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(VKSurface ptr) { return (ptr != null && tsVKSurface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_new_V(HandleRef context);
		[DllImport(Base.Import)] private static extern void tsVKSurface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKSurface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKSurface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKSurface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKSurface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKSurface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsVKSurface_equalSurfacePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_castSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_baseSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getInstance(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getAdapter(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getDevice(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getQueue(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getCommand(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKSurface_getFamily(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setSwapChain(HandleRef self, IntPtr swap_chain);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getSwapChain(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setColorImage(HandleRef self, IntPtr image);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setDepthImage(HandleRef self, IntPtr image);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getColorImage(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getDepthImage(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setColorImageView(HandleRef self, IntPtr image_view);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setDepthImageView(HandleRef self, IntPtr image_view);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getColorImageView(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getDepthImageView(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setRenderPass(HandleRef self, IntPtr render_pass);
		[DllImport(Base.Import)] private static extern void tsVKSurface_setFramebuffer(HandleRef self, IntPtr framebuffer);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getRenderPass(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsVKSurface_getFramebuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKSurface_getColorPixelFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsVKSurface_getDepthPixelFormat(HandleRef self);
	}
	
	// Tellusim::GLSurface
	public sealed class GLSurface : Surface {
		public GLSurface() { self = new HandleRef(this, tsGLSurface_new()); owner = true; }
		public GLSurface(GLContext context) { self = new HandleRef(this, tsGLSurface_new_G(context.getSelf())); owner = true; }
		public GLSurface(GLSurface ptr) { self = new HandleRef(this, tsGLSurface_copyPtr(ptr.getSelf())); owner = true; }
		public GLSurface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLSurface_isOwnerPtr(self); }
		public GLSurface(Surface ptr) { self = new HandleRef(this, tsGLSurface_castSurfacePtr(ptr.getSelf())); }
		public Surface toSurface() { return new Surface(tsGLSurface_baseSurfacePtr(self)); }
		public static new GLSurface Null() { return new GLSurface(IntPtr.Zero); }
		public IntPtr getContext() { return tsGLSurface_getContext(self); }
		public void setColorTextureID(uint texture_id) { tsGLSurface_setColorTextureID(self, texture_id); }
		public void setDepthTextureID(uint texture_id) { tsGLSurface_setDepthTextureID(self, texture_id); }
		public uint getColorTextureID() { return tsGLSurface_getColorTextureID(self); }
		public uint getDepthTextureID() { return tsGLSurface_getDepthTextureID(self); }
		public void setFramebufferID(uint framebuffer_id) { tsGLSurface_setFramebufferID(self, framebuffer_id); }
		public uint getFramebufferID() { return tsGLSurface_getFramebufferID(self); }
		public uint getColorInternalFormat() { return tsGLSurface_getColorInternalFormat(self); }
		public uint getDepthInternalFormat() { return tsGLSurface_getDepthInternalFormat(self); }
		public override string ToString() { return "Tellusim.GLSurface: Valid: " + tsGLSurface_isValidPtr(self) + "; Owner: " + tsGLSurface_isOwnerPtr(self) + "; Const: " + tsGLSurface_isConstPtr(self) + "; Count: " + tsGLSurface_getCountPtr(self) + "; Internal: 0x" + tsGLSurface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLSurface ptr) { return (ptr != null && tsGLSurface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_new_G(HandleRef context);
		[DllImport(Base.Import)] private static extern void tsGLSurface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLSurface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLSurface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLSurface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLSurface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLSurface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLSurface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLSurface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLSurface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLSurface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLSurface_equalSurfacePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_castSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_baseSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLSurface_getContext(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLSurface_setColorTextureID(HandleRef self, uint texture_id);
		[DllImport(Base.Import)] private static extern void tsGLSurface_setDepthTextureID(HandleRef self, uint texture_id);
		[DllImport(Base.Import)] private static extern uint tsGLSurface_getColorTextureID(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLSurface_getDepthTextureID(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLSurface_setFramebufferID(HandleRef self, uint framebuffer_id);
		[DllImport(Base.Import)] private static extern uint tsGLSurface_getFramebufferID(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLSurface_getColorInternalFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLSurface_getDepthInternalFormat(HandleRef self);
	}
	
	// Tellusim::GLESSurface
	public sealed class GLESSurface : Surface {
		public GLESSurface() { self = new HandleRef(this, tsGLESSurface_new()); owner = true; }
		public GLESSurface(GLESContext context) { self = new HandleRef(this, tsGLESSurface_new_G(context.getSelf())); owner = true; }
		public GLESSurface(GLESSurface ptr) { self = new HandleRef(this, tsGLESSurface_copyPtr(ptr.getSelf())); owner = true; }
		public GLESSurface(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsGLESSurface_isOwnerPtr(self); }
		public GLESSurface(Surface ptr) { self = new HandleRef(this, tsGLESSurface_castSurfacePtr(ptr.getSelf())); }
		public Surface toSurface() { return new Surface(tsGLESSurface_baseSurfacePtr(self)); }
		public static new GLESSurface Null() { return new GLESSurface(IntPtr.Zero); }
		public IntPtr getContext() { return tsGLESSurface_getContext(self); }
		public void setColorTextureID(uint texture_id) { tsGLESSurface_setColorTextureID(self, texture_id); }
		public void setDepthTextureID(uint texture_id) { tsGLESSurface_setDepthTextureID(self, texture_id); }
		public uint getColorTextureID() { return tsGLESSurface_getColorTextureID(self); }
		public uint getDepthTextureID() { return tsGLESSurface_getDepthTextureID(self); }
		public void setFramebufferID(uint framebuffer_id) { tsGLESSurface_setFramebufferID(self, framebuffer_id); }
		public uint getFramebufferID() { return tsGLESSurface_getFramebufferID(self); }
		public uint getColorInternalFormat() { return tsGLESSurface_getColorInternalFormat(self); }
		public uint getDepthInternalFormat() { return tsGLESSurface_getDepthInternalFormat(self); }
		public override string ToString() { return "Tellusim.GLESSurface: Valid: " + tsGLESSurface_isValidPtr(self) + "; Owner: " + tsGLESSurface_isOwnerPtr(self) + "; Const: " + tsGLESSurface_isConstPtr(self) + "; Count: " + tsGLESSurface_getCountPtr(self) + "; Internal: 0x" + tsGLESSurface_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(GLESSurface ptr) { return (ptr != null && tsGLESSurface_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_new();
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_new_G(HandleRef context);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESSurface_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESSurface_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESSurface_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESSurface_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESSurface_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsGLESSurface_equalSurfacePtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_castSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_baseSurfacePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsGLESSurface_getContext(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_setColorTextureID(HandleRef self, uint texture_id);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_setDepthTextureID(HandleRef self, uint texture_id);
		[DllImport(Base.Import)] private static extern uint tsGLESSurface_getColorTextureID(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESSurface_getDepthTextureID(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsGLESSurface_setFramebufferID(HandleRef self, uint framebuffer_id);
		[DllImport(Base.Import)] private static extern uint tsGLESSurface_getFramebufferID(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESSurface_getColorInternalFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsGLESSurface_getDepthInternalFormat(HandleRef self);
	}
	
	// Tellusim::Window
	public sealed class Window {
		public enum Flags : uint {
			None = 0,
			Title = 1,
			Close = 2,
			Frame = 4,
			Resize = 8,
			Minimize = 16,
			Maximize = 32,
			Transient = 64,
			Fullscreen = 128,
			Transparent = 256,
			FileDropped = 512,
			Multisample2 = 1024,
			Multisample4 = 2048,
			Multisample8 = 4096,
			VerticalSync = 8192,
			RefreshSync = 16384,
			ColorRGBAu8ns = 32768,
			ColorRGBu10Au2n = 65536,
			ColorRGBAf16 = 131072,
			Multisample = 7168,
			Default = 59,
			Num = 18,
		}
		public enum Cursor : uint {
			Arrow = 0,
			Invalid,
			Left,
			Right,
			Bottom,
			Top,
			Width,
			Height,
			Major,
			Minor,
			All,
			NumCursors,
		}
		public enum Button : uint {
			None = 0,
			Left = 1,
			Left2 = 2,
			Right = 4,
			Right2 = 8,
			Middle = 16,
			Middle2 = 32,
			Back = 64,
			Back2 = 128,
			Forward = 256,
			Forward2 = 512,
			NumButtons = 10,
		}
		public enum Axis : uint {
			X = 0,
			Y,
			Z,
			W,
			NumAxes,
		}
		public const uint NumTouches = 16;
		public enum Key : uint {
			None = 128,
			Esc,
			Tab,
			Backspace,
			Delete,
			Insert,
			Return,
			Pause,
			Prior,
			Next,
			End,
			Home,
			Up,
			Down,
			Left,
			Right,
			Num,
			Caps,
			Scroll,
			Shift,
			Ctrl,
			Alt,
			Win,
			Cmd,
			Menu,
			F1,
			F2,
			F3,
			F4,
			F5,
			F6,
			F7,
			F8,
			F9,
			F10,
			F11,
			F12,
			NumKeys,
		}
		public delegate void MousePressedCallback(Button button, IntPtr data_);
		public delegate void MouseReleasedCallback(Button button, IntPtr data_);
		public delegate void MouseChangedCallback(int x, int y, IntPtr data_);
		public delegate void MouseRotatedCallback(Axis axis, float delta, IntPtr data_);
		public delegate void TouchChangedCallback(IntPtr data_);
		public delegate void KeyboardPressedCallback(uint key, uint code, IntPtr data_);
		public delegate void KeyboardReleasedCallback(uint key, IntPtr data_);
		public delegate void SizeChangedCallback(uint width, uint height, IntPtr data_);
		public delegate void FocusChangedCallback(bool changed, IntPtr data_);
		public delegate void CloseClickedCallback(IntPtr data_);
		public delegate void PauseChangedCallback(bool paused, IntPtr data_);
		public delegate void FileDroppedCallback(string name, uint remain, IntPtr data_);
		public delegate void UpdateCallback(IntPtr data_);
		public delegate void PresentCallback(IntPtr data_);
		public delegate bool MainLoopCallback(IntPtr data_);
		public Window() { self = new HandleRef(this, tsWindow_new()); owner = true; }
		public Window(Platform platform, uint index = Base.Maxu32) { self = new HandleRef(this, tsWindow_new_Pu(platform, index)); owner = true; }
		public Window(Surface surface) { self = new HandleRef(this, tsWindow_new_S(surface.getSelf())); owner = true; }
		public Window(Window ptr) { self = new HandleRef(this, tsWindow_copyPtr(ptr.getSelf())); owner = true; }
		public Window(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsWindow_isOwnerPtr(self); }
		public static Window Null() { return new Window(IntPtr.Zero); }
		~Window() { if(owner) tsWindow_delete(self); }
		public bool equalPtr(Window ptr) { return tsWindow_equalPtr(self, ptr.getSelf()); }
		public Window clonePtr() { return new Window(tsWindow_clonePtr(self)); }
		public void clearPtr() { tsWindow_clearPtr(self); }
		public void destroyPtr() { tsWindow_destroyPtr(self); }
		public void acquirePtr() { tsWindow_acquirePtr(self); }
		public void unacquirePtr() { tsWindow_unacquirePtr(self); }
		public bool isValidPtr() { return tsWindow_isValidPtr(self); }
		public bool isOwnerPtr() { return tsWindow_isOwnerPtr(self); }
		public bool isConstPtr() { return tsWindow_isConstPtr(self); }
		public uint getCountPtr() { return tsWindow_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsWindow_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public static uint getNumWindows() { return tsWindow_getNumWindows(); }
		public static Window getWindow(uint index) { return new Window(tsWindow_getWindow(index)); }
		public static void update(bool wait = false) { tsWindow_update(wait); }
		public Platform getPlatform() { return tsWindow_getPlatform(self); }
		public string getPlatformName() { return Base.getCString(tsWindow_getPlatformName(self)); }
		public uint getIndex() { return tsWindow_getIndex(self); }
		public void setSurface(Surface surface) { tsWindow_setSurface(self, surface.getSelf()); }
		public Surface getSurface() { return new Surface(tsWindow_getSurface(self)); }
		public IntPtr getHandle() { return tsWindow_getHandle(self); }
		public bool isCreated() { return tsWindow_isCreated(self); }
		public bool create(string title, Flags flags = Flags.Default) { return tsWindow_create_sWF(self, title, flags); }
		public bool create(String title, Flags flags = Flags.Default) { return tsWindow_create_cSWF(self, title.getSelf(), flags); }
		public bool create(Flags flags = Flags.Default) { return tsWindow_create_WF(self, flags); }
		public void release() { tsWindow_release(self); }
		public bool clear(in Color color) { return tsWindow_clear(self, in color); }
		public bool grab(Image image) { return tsWindow_grab(self, image.getSelf()); }
		public bool render() { return tsWindow_render(self); }
		public bool present() { return tsWindow_present(self); }
		public bool finish() { return tsWindow_finish(self); }
		public Format getColorFormat() { return tsWindow_getColorFormat(self); }
		public Format getDepthFormat() { return tsWindow_getDepthFormat(self); }
		public uint getMultisample() { return tsWindow_getMultisample(self); }
		public bool hasMultisample() { return tsWindow_hasMultisample(self); }
		public void setFlags(Flags flags) { tsWindow_setFlags(self, flags); }
		public Flags getFlags() { return tsWindow_getFlags(self); }
		public bool hasFlag(Flags flags) { return tsWindow_hasFlag(self, flags); }
		public bool hasFlags(Flags flags) { return tsWindow_hasFlags(self, flags); }
		public void setRefreshRate(uint rate) { tsWindow_setRefreshRate(self, rate); }
		public uint getRefreshRate() { return tsWindow_getRefreshRate(self); }
		public bool setHidden(bool hidden) { return tsWindow_setHidden(self, hidden); }
		public bool isHidden() { return tsWindow_isHidden(self); }
		public bool setFocused(bool focused) { return tsWindow_setFocused(self, focused); }
		public bool isFocused() { return tsWindow_isFocused(self); }
		public bool setMinimized(bool minimized) { return tsWindow_setMinimized(self, minimized); }
		public bool isMinimized() { return tsWindow_isMinimized(self); }
		public bool setFullscreen(bool fullscreen) { return tsWindow_setFullscreen(self, fullscreen); }
		public bool isFullscreen() { return tsWindow_isFullscreen(self); }
		public bool isOccluded() { return tsWindow_isOccluded(self); }
		public bool setTitle(string title) { return tsWindow_setTitle_s(self, title); }
		public bool setTitle(String title) { return tsWindow_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsWindow_getTitle(self)); }
		public bool setIcon(Image image) { return tsWindow_setIcon(self, image.getSelf()); }
		public Image getIcon() { return new Image(tsWindow_getIcon(self)); }
		public bool setGeometry(int x, int y, uint width, uint height, bool force = false) { return tsWindow_setGeometry(self, x, y, width, height, force); }
		public bool setPosition(int x, int y, bool force = false) { return tsWindow_setPosition(self, x, y, force); }
		public int getPositionX(bool title = false) { return tsWindow_getPositionX(self, title); }
		public int getPositionY(bool title = false) { return tsWindow_getPositionY(self, title); }
		public bool setSize(uint width, uint height, bool force = false) { return tsWindow_setSize(self, width, height, force); }
		public uint getWidth() { return tsWindow_getWidth(self); }
		public uint getHeight() { return tsWindow_getHeight(self); }
		public float getScale() { return tsWindow_getScale(self); }
		public uint getDpiX() { return tsWindow_getDpiX(self); }
		public uint getDpiY() { return tsWindow_getDpiY(self); }
		public bool setMinSize(uint width, uint height, bool force = false) { return tsWindow_setMinSize(self, width, height, force); }
		public uint getMinWidth() { return tsWindow_getMinWidth(self); }
		public uint getMinHeight() { return tsWindow_getMinHeight(self); }
		public bool setMaxSize(uint width, uint height, bool force = false) { return tsWindow_setMaxSize(self, width, height, force); }
		public uint getMaxWidth() { return tsWindow_getMaxWidth(self); }
		public uint getMaxHeight() { return tsWindow_getMaxHeight(self); }
		public bool setMouse(int x, int y, bool force = false) { return tsWindow_setMouse(self, x, y, force); }
		public int getMouseX() { return tsWindow_getMouseX(self); }
		public int getMouseY() { return tsWindow_getMouseY(self); }
		public bool setMouseDelta(int dx, int dy) { return tsWindow_setMouseDelta(self, dx, dy); }
		public int getMouseDX() { return tsWindow_getMouseDX(self); }
		public int getMouseDY() { return tsWindow_getMouseDY(self); }
		public bool setMouseHidden(bool hidden, bool force = false) { return tsWindow_setMouseHidden(self, hidden, force); }
		public bool isMouseHidden() { return tsWindow_isMouseHidden(self); }
		public bool setMouseClipped(bool clipped, bool force = false) { return tsWindow_setMouseClipped(self, clipped, force); }
		public bool isMouseClipped() { return tsWindow_isMouseClipped(self); }
		public bool isMouseInside() { return tsWindow_isMouseInside(self); }
		public bool setMouseCursor(Cursor cursor, bool force = false) { return tsWindow_setMouseCursor(self, cursor, force); }
		public Cursor getMouseCursor() { return tsWindow_getMouseCursor(self); }
		public bool setMouseButtons(Button buttons) { return tsWindow_setMouseButtons(self, buttons); }
		public Button getMouseButtons() { return tsWindow_getMouseButtons(self); }
		public bool setMouseButton(Button button, bool value) { return tsWindow_setMouseButton(self, button, value); }
		public bool getMouseButton(Button button, bool clear = false) { return tsWindow_getMouseButton(self, button, clear); }
		public bool wasMouseButtonReleased(Button button) { return tsWindow_wasMouseButtonReleased(self, button); }
		public void releaseMouseButtons(Button buttons) { tsWindow_releaseMouseButtons(self, buttons); }
		public Button clearMouseButtons() { return tsWindow_clearMouseButtons(self); }
		public bool setMouseAxis(Axis axis, float value) { return tsWindow_setMouseAxis(self, axis, value); }
		public float getMouseAxis(Axis axis) { return tsWindow_getMouseAxis(self, axis); }
		public float clearMouseAxis(Axis axis) { return tsWindow_clearMouseAxis(self, axis); }
		public void setMousePressedCallback(MousePressedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) MousePressedCallback_85 = GCHandle.Alloc(func);
			tsWindow_setMousePressedCallback(self, Base.getFunc(func), data);
		}
		public void setMouseReleasedCallback(MouseReleasedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) MouseReleasedCallback_87 = GCHandle.Alloc(func);
			tsWindow_setMouseReleasedCallback(self, Base.getFunc(func), data);
		}
		public void setMouseChangedCallback(MouseChangedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) MouseChangedCallback_89 = GCHandle.Alloc(func);
			tsWindow_setMouseChangedCallback(self, Base.getFunc(func), data);
		}
		public void setMouseRotatedCallback(MouseRotatedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) MouseRotatedCallback_91 = GCHandle.Alloc(func);
			tsWindow_setMouseRotatedCallback(self, Base.getFunc(func), data);
		}
		public uint getNumTouches() { return tsWindow_getNumTouches(self); }
		public uint addTouch(int x, int y) { return tsWindow_addTouch(self, x, y); }
		public int getTouchX(uint touch) { return tsWindow_getTouchX(self, touch); }
		public int getTouchY(uint touch) { return tsWindow_getTouchY(self, touch); }
		public uint findTouch(int x, int y) { return tsWindow_findTouch(self, x, y); }
		public void clearTouches() { tsWindow_clearTouches(self); }
		public void setTouchChangedCallback(TouchChangedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) TouchChangedCallback_99 = GCHandle.Alloc(func);
			tsWindow_setTouchChangedCallback(self, Base.getFunc(func), data);
		}
		public void setKeyboardKey(uint key, bool value) { tsWindow_setKeyboardKey(self, key, value); }
		public bool getKeyboardKey(uint key, bool clear = false) { return tsWindow_getKeyboardKey(self, key, clear); }
		public bool wasKeyboardKeyPressed(uint key) { return tsWindow_wasKeyboardKeyPressed(self, key); }
		public bool wasKeyboardKeyReleased(uint key) { return tsWindow_wasKeyboardKeyReleased(self, key); }
		public void setKeyboardPressedCallback(KeyboardPressedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) KeyboardPressedCallback_105 = GCHandle.Alloc(func);
			tsWindow_setKeyboardPressedCallback(self, Base.getFunc(func), data);
		}
		public void setKeyboardReleasedCallback(KeyboardReleasedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) KeyboardReleasedCallback_107 = GCHandle.Alloc(func);
			tsWindow_setKeyboardReleasedCallback(self, Base.getFunc(func), data);
		}
		public void setSizeChangedCallback(SizeChangedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) SizeChangedCallback_109 = GCHandle.Alloc(func);
			tsWindow_setSizeChangedCallback(self, Base.getFunc(func), data);
		}
		public void setFocusChangedCallback(FocusChangedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) FocusChangedCallback_111 = GCHandle.Alloc(func);
			tsWindow_setFocusChangedCallback(self, Base.getFunc(func), data);
		}
		public void setCloseClickedCallback(CloseClickedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) CloseClickedCallback_113 = GCHandle.Alloc(func);
			tsWindow_setCloseClickedCallback(self, Base.getFunc(func), data);
		}
		public void setPauseChangedCallback(PauseChangedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) PauseChangedCallback_115 = GCHandle.Alloc(func);
			tsWindow_setPauseChangedCallback(self, Base.getFunc(func), data);
		}
		public void setFileDroppedCallback(FileDroppedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) FileDroppedCallback_117 = GCHandle.Alloc(func);
			tsWindow_setFileDroppedCallback(self, Base.getFunc(func), data);
		}
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_119 = GCHandle.Alloc(func);
			tsWindow_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public void setPresentCallback(PresentCallback func, IntPtr data = new IntPtr()) {
			if(func != null) PresentCallback_121 = GCHandle.Alloc(func);
			tsWindow_setPresentCallback(self, Base.getFunc(func), data);
		}
		public bool run(MainLoopCallback func, IntPtr data = new IntPtr()) {
			if(func != null) MainLoopCallback_124 = GCHandle.Alloc(func);
			return tsWindow_run(self, Base.getFunc(func), data);
		}
		public bool isRunning() { return tsWindow_isRunning(self); }
		public void stop() { tsWindow_stop(self); }
		public bool setCopyText(string text) { return tsWindow_setCopyText_s(self, text); }
		public bool setCopyText(String text) { return tsWindow_setCopyText_cS(self, text.getSelf()); }
		public string getPasteText() { return Base.getString(tsWindow_getPasteText(self)); }
		private GCHandle MousePressedCallback_85;
		private GCHandle MouseReleasedCallback_87;
		private GCHandle MouseChangedCallback_89;
		private GCHandle MouseRotatedCallback_91;
		private GCHandle TouchChangedCallback_99;
		private GCHandle KeyboardPressedCallback_105;
		private GCHandle KeyboardReleasedCallback_107;
		private GCHandle SizeChangedCallback_109;
		private GCHandle FocusChangedCallback_111;
		private GCHandle CloseClickedCallback_113;
		private GCHandle PauseChangedCallback_115;
		private GCHandle FileDroppedCallback_117;
		private GCHandle UpdateCallback_119;
		private GCHandle PresentCallback_121;
		private GCHandle MainLoopCallback_124;
		public override string ToString() { return "Tellusim.Window: Valid: " + tsWindow_isValidPtr(self) + "; Owner: " + tsWindow_isOwnerPtr(self) + "; Const: " + tsWindow_isConstPtr(self) + "; Count: " + tsWindow_getCountPtr(self) + "; Internal: 0x" + tsWindow_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Window ptr) { return (ptr != null && tsWindow_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_new();
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_new_Pu(Platform platform, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_new_S(HandleRef surface);
		[DllImport(Base.Import)] private static extern void tsWindow_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getNumWindows();
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getWindow(uint index);
		[DllImport(Base.Import)] private static extern void tsWindow_update(bool wait);
		[DllImport(Base.Import)] private static extern Platform tsWindow_getPlatform(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getPlatformName(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_setSurface(HandleRef self, HandleRef surface);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getSurface(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getHandle(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_create_sWF(HandleRef self, string title, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsWindow_create_cSWF(HandleRef self, HandleRef title, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsWindow_create_WF(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern void tsWindow_release(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_clear(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern bool tsWindow_grab(HandleRef self, HandleRef image);
		[DllImport(Base.Import)] private static extern bool tsWindow_render(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_present(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_finish(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsWindow_getColorFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsWindow_getDepthFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_hasMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_setFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern Flags tsWindow_getFlags(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_hasFlag(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsWindow_hasFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern void tsWindow_setRefreshRate(HandleRef self, uint rate);
		[DllImport(Base.Import)] private static extern uint tsWindow_getRefreshRate(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setHidden(HandleRef self, bool hidden);
		[DllImport(Base.Import)] private static extern bool tsWindow_isHidden(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setFocused(HandleRef self, bool focused);
		[DllImport(Base.Import)] private static extern bool tsWindow_isFocused(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMinimized(HandleRef self, bool minimized);
		[DllImport(Base.Import)] private static extern bool tsWindow_isMinimized(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setFullscreen(HandleRef self, bool fullscreen);
		[DllImport(Base.Import)] private static extern bool tsWindow_isFullscreen(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_isOccluded(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern bool tsWindow_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setIcon(HandleRef self, HandleRef image);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getIcon(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setGeometry(HandleRef self, int x, int y, uint width, uint height, bool force);
		[DllImport(Base.Import)] private static extern bool tsWindow_setPosition(HandleRef self, int x, int y, bool force);
		[DllImport(Base.Import)] private static extern int tsWindow_getPositionX(HandleRef self, bool title);
		[DllImport(Base.Import)] private static extern int tsWindow_getPositionY(HandleRef self, bool title);
		[DllImport(Base.Import)] private static extern bool tsWindow_setSize(HandleRef self, uint width, uint height, bool force);
		[DllImport(Base.Import)] private static extern uint tsWindow_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsWindow_getScale(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getDpiX(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getDpiY(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMinSize(HandleRef self, uint width, uint height, bool force);
		[DllImport(Base.Import)] private static extern uint tsWindow_getMinWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getMinHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMaxSize(HandleRef self, uint width, uint height, bool force);
		[DllImport(Base.Import)] private static extern uint tsWindow_getMaxWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_getMaxHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouse(HandleRef self, int x, int y, bool force);
		[DllImport(Base.Import)] private static extern int tsWindow_getMouseX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsWindow_getMouseY(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseDelta(HandleRef self, int dx, int dy);
		[DllImport(Base.Import)] private static extern int tsWindow_getMouseDX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsWindow_getMouseDY(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseHidden(HandleRef self, bool hidden, bool force);
		[DllImport(Base.Import)] private static extern bool tsWindow_isMouseHidden(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseClipped(HandleRef self, bool clipped, bool force);
		[DllImport(Base.Import)] private static extern bool tsWindow_isMouseClipped(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_isMouseInside(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseCursor(HandleRef self, Cursor cursor, bool force);
		[DllImport(Base.Import)] private static extern Cursor tsWindow_getMouseCursor(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseButtons(HandleRef self, Button buttons);
		[DllImport(Base.Import)] private static extern Button tsWindow_getMouseButtons(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseButton(HandleRef self, Button button, bool value);
		[DllImport(Base.Import)] private static extern bool tsWindow_getMouseButton(HandleRef self, Button button, bool clear);
		[DllImport(Base.Import)] private static extern bool tsWindow_wasMouseButtonReleased(HandleRef self, Button button);
		[DllImport(Base.Import)] private static extern void tsWindow_releaseMouseButtons(HandleRef self, Button buttons);
		[DllImport(Base.Import)] private static extern Button tsWindow_clearMouseButtons(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setMouseAxis(HandleRef self, Axis axis, float value);
		[DllImport(Base.Import)] private static extern float tsWindow_getMouseAxis(HandleRef self, Axis axis);
		[DllImport(Base.Import)] private static extern float tsWindow_clearMouseAxis(HandleRef self, Axis axis);
		[DllImport(Base.Import)] private static extern void tsWindow_setMousePressedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setMouseReleasedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setMouseChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setMouseRotatedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsWindow_getNumTouches(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsWindow_addTouch(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsWindow_getTouchX(HandleRef self, uint touch);
		[DllImport(Base.Import)] private static extern int tsWindow_getTouchY(HandleRef self, uint touch);
		[DllImport(Base.Import)] private static extern uint tsWindow_findTouch(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern void tsWindow_clearTouches(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_setTouchChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setKeyboardKey(HandleRef self, uint key, bool value);
		[DllImport(Base.Import)] private static extern bool tsWindow_getKeyboardKey(HandleRef self, uint key, bool clear);
		[DllImport(Base.Import)] private static extern bool tsWindow_wasKeyboardKeyPressed(HandleRef self, uint key);
		[DllImport(Base.Import)] private static extern bool tsWindow_wasKeyboardKeyReleased(HandleRef self, uint key);
		[DllImport(Base.Import)] private static extern void tsWindow_setKeyboardPressedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setKeyboardReleasedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setSizeChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setFocusChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setCloseClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setPauseChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setFileDroppedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsWindow_setPresentCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsWindow_run(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsWindow_isRunning(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsWindow_stop(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsWindow_setCopyText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern bool tsWindow_setCopyText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsWindow_getPasteText(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Font
	public sealed class Font {
		public Font() { self = new HandleRef(this, tsFont_new()); owner = true; }
		public Font(Font ptr) { self = new HandleRef(this, tsFont_copyPtr(ptr.getSelf())); owner = true; }
		public Font(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFont_isOwnerPtr(self); }
		public static Font Null() { return new Font(IntPtr.Zero); }
		~Font() { if(owner) tsFont_delete(self); }
		public bool equalPtr(Font ptr) { return tsFont_equalPtr(self, ptr.getSelf()); }
		public Font clonePtr() { return new Font(tsFont_clonePtr(self)); }
		public void clearPtr() { tsFont_clearPtr(self); }
		public void destroyPtr() { tsFont_destroyPtr(self); }
		public void acquirePtr() { tsFont_acquirePtr(self); }
		public void unacquirePtr() { tsFont_unacquirePtr(self); }
		public bool isValidPtr() { return tsFont_isValidPtr(self); }
		public bool isOwnerPtr() { return tsFont_isOwnerPtr(self); }
		public bool isConstPtr() { return tsFont_isConstPtr(self); }
		public uint getCountPtr() { return tsFont_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsFont_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsFont_clear(self); }
		public bool isLoaded() { return tsFont_isLoaded(self); }
		public bool load(string name) { return tsFont_load_s(self, name); }
		public bool load(Stream stream) { return tsFont_load_St(self, stream.getSelf()); }
		public float getAdvance(in FontStyle style, uint code) { return tsFont_getAdvance(self, in style, code); }
		public Rect getRect(in Vector3f position, in FontStyle style, string str) { return tsFont_getRect_cV3cFSs(self, in position, in style, str); }
		public Rect getRect(in Vector3f position, in FontStyle style, uint[] str) { return tsFont_getRect_cV3cFSup(self, in position, in style, str); }
		public void create(Device device, in FontStyle style, string str) { tsFont_create_cDcFSs(self, device.getSelf(), in style, str); }
		public void create(Device device, in FontStyle style, uint[] str) { tsFont_create_cDcFSup(self, device.getSelf(), in style, str); }
		public void draw(Command command, in Vector3f position, in FontStyle style, string str) { tsFont_draw_CcV3cFSs(self, command.getSelf(), in position, in style, str); }
		public void draw(Command command, in Vector3f position, in FontStyle style, uint[] str) { tsFont_draw_CcV3cFSup(self, command.getSelf(), in position, in style, str); }
		public bool flush(Device device) { return tsFont_flush(self, device.getSelf()); }
		public override string ToString() { return "Tellusim.Font: Valid: " + tsFont_isValidPtr(self) + "; Owner: " + tsFont_isOwnerPtr(self) + "; Const: " + tsFont_isConstPtr(self) + "; Count: " + tsFont_getCountPtr(self) + "; Internal: 0x" + tsFont_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Font ptr) { return (ptr != null && tsFont_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFont_new();
		[DllImport(Base.Import)] private static extern void tsFont_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFont_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFont_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFont_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFont_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFont_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFont_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFont_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFont_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFont_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFont_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFont_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFont_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFont_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFont_isLoaded(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFont_load_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsFont_load_St(HandleRef self, HandleRef stream);
		[DllImport(Base.Import)] private static extern float tsFont_getAdvance(HandleRef self, in FontStyle style, uint code);
		[DllImport(Base.Import)] private static extern Rect tsFont_getRect_cV3cFSs(HandleRef self, in Vector3f position, in FontStyle style, string str);
		[DllImport(Base.Import)] private static extern Rect tsFont_getRect_cV3cFSup(HandleRef self, in Vector3f position, in FontStyle style, uint[] str);
		[DllImport(Base.Import)] private static extern void tsFont_create_cDcFSs(HandleRef self, HandleRef device, in FontStyle style, string str);
		[DllImport(Base.Import)] private static extern void tsFont_create_cDcFSup(HandleRef self, HandleRef device, in FontStyle style, uint[] str);
		[DllImport(Base.Import)] private static extern void tsFont_draw_CcV3cFSs(HandleRef self, HandleRef command, in Vector3f position, in FontStyle style, string str);
		[DllImport(Base.Import)] private static extern void tsFont_draw_CcV3cFSup(HandleRef self, HandleRef command, in Vector3f position, in FontStyle style, uint[] str);
		[DllImport(Base.Import)] private static extern bool tsFont_flush(HandleRef self, HandleRef device);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::CanvasElement
	public class CanvasElement {
		public enum Type : uint {
			Unknown = 0,
			Text,
			Mesh,
			Rect,
			Triangle,
			Ellipse,
			Shape,
			Strip,
			NumTypes,
		}
		public enum Mode : uint {
			Solid = 0,
			Texture,
			TextureFetch,
			TextureClamp,
			TextureCubic,
			TextureCubic3x3,
			TextureCubic5x5,
			TextureRed,
			TextureGreen,
			TextureBlue,
			TextureAlpha,
			TextureYOG,
			Gradient,
			NumModes,
		}
		public enum Align : uint {
			None = 0,
			Left = 1,
			Right = 2,
			Bottom = 4,
			Top = 8,
			CenterX = 16,
			CenterY = 32,
			LeftBottom = 5,
			LeftTop = 9,
			RightBottom = 6,
			RightTop = 10,
			Center = 48,
			NumAligns = 6,
		}
		public enum Stack : uint {
			None = 0,
			Push = 1,
			Pop = 2,
			Set = 4,
			Mul = 8,
			Get = 16,
		}
		public delegate bool DrawCallback(Command command, CanvasElement element, IntPtr data_);
		public delegate bool DrawCallback_(IntPtr command, IntPtr element, IntPtr data_);
		public CanvasElement() { self = new HandleRef(this, tsCanvasElement_new()); owner = true; }
		public CanvasElement(CanvasElement ptr) { self = new HandleRef(this, tsCanvasElement_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasElement(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasElement_isOwnerPtr(self); }
		public static CanvasElement Null() { return new CanvasElement(IntPtr.Zero); }
		~CanvasElement() { if(owner) tsCanvasElement_delete(self); }
		public bool equalPtr(CanvasElement ptr) { return tsCanvasElement_equalPtr(self, ptr.getSelf()); }
		public CanvasElement clonePtr() { return new CanvasElement(tsCanvasElement_clonePtr(self)); }
		public void clearPtr() { tsCanvasElement_clearPtr(self); }
		public void destroyPtr() { tsCanvasElement_destroyPtr(self); }
		public void acquirePtr() { tsCanvasElement_acquirePtr(self); }
		public void unacquirePtr() { tsCanvasElement_unacquirePtr(self); }
		public bool isValidPtr() { return tsCanvasElement_isValidPtr(self); }
		public bool isOwnerPtr() { return tsCanvasElement_isOwnerPtr(self); }
		public bool isConstPtr() { return tsCanvasElement_isConstPtr(self); }
		public uint getCountPtr() { return tsCanvasElement_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsCanvasElement_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Type getType() { return tsCanvasElement_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsCanvasElement_getTypeName_CET(type)); }
		public string getTypeName() { return Base.getCString(tsCanvasElement_getTypeName_c(self)); }
		public bool isText() { return tsCanvasElement_isText(self); }
		public bool isMesh() { return tsCanvasElement_isMesh(self); }
		public bool isRect() { return tsCanvasElement_isRect(self); }
		public bool isTriangle() { return tsCanvasElement_isTriangle(self); }
		public bool isEllipse() { return tsCanvasElement_isEllipse(self); }
		public bool isShape() { return tsCanvasElement_isShape(self); }
		public bool isStrip() { return tsCanvasElement_isStrip(self); }
		public void setCanvas(Canvas canvas) { tsCanvasElement_setCanvas(self, canvas.getSelf()); }
		public Canvas getCanvas() { return new Canvas(tsCanvasElement_getCanvas_c(self)); }
		public void setMode(Mode mode) { tsCanvasElement_setMode(self, mode); }
		public Mode getMode() { return tsCanvasElement_getMode(self); }
		public void setAlign(Align align) { tsCanvasElement_setAlign(self, align); }
		public Align getAlign() { return tsCanvasElement_getAlign(self); }
		public bool hasAlign(Align align) { return tsCanvasElement_hasAlign(self, align); }
		public bool hasAligns(Align aligns) { return tsCanvasElement_hasAligns(self, aligns); }
		public void setOrder(int order) { tsCanvasElement_setOrder(self, order); }
		public int getOrder() { return tsCanvasElement_getOrder(self); }
		public void setEnabled(bool enabled) { tsCanvasElement_setEnabled(self, enabled); }
		public bool isEnabled() { return tsCanvasElement_isEnabled(self); }
		public void clearColor() { tsCanvasElement_clearColor(self); }
		public void setColor(Stack op) { tsCanvasElement_setColor_CES(self, op); }
		public void setColor(in Color color, Stack op = Stack.None) { tsCanvasElement_setColor_cCCES(self, in color, op); }
		public void setColor(float r, float g, float b, float a, Stack op = Stack.None) { tsCanvasElement_setColor_ffffCES(self, r, g, b, a, op); }
		public Color getColor() { return tsCanvasElement_getColor(self); }
		public Stack getColorOp() { return tsCanvasElement_getColorOp(self); }
		public void clearTransform() { tsCanvasElement_clearTransform(self); }
		public void setTransform(Stack op) { tsCanvasElement_setTransform_CES(self, op); }
		public void setTransform(in Matrix4x4f transform, Stack op = Stack.None) { tsCanvasElement_setTransform_cM44CES(self, in transform, op); }
		public Matrix4x4f getTransform() { return tsCanvasElement_getTransform(self); }
		public Stack getTransformOp() { return tsCanvasElement_getTransformOp(self); }
		public void clearScissor() { tsCanvasElement_clearScissor(self); }
		public void setScissor(Stack op) { tsCanvasElement_setScissor_CES(self, op); }
		public void setScissor(in Rect scissor, Stack op = Stack.None) { tsCanvasElement_setScissor_cRCES(self, in scissor, op); }
		public Rect getScissor() { return tsCanvasElement_getScissor(self); }
		public Stack getScissorOp() { return tsCanvasElement_getScissorOp(self); }
		public void setMipmap(float mipmap) { tsCanvasElement_setMipmap(self, mipmap); }
		public float getMipmap() { return tsCanvasElement_getMipmap(self); }
		public void setSampler(Sampler sampler) { tsCanvasElement_setSampler(self, sampler.getSelf()); }
		public Sampler getSampler() { return new Sampler(tsCanvasElement_getSampler(self)); }
		public void setFilter(Sampler.Filter filter) { tsCanvasElement_setFilter(self, filter); }
		public Sampler.Filter getFilter() { return tsCanvasElement_getFilter(self); }
		public void setAnisotropy(uint anisotropy) { tsCanvasElement_setAnisotropy(self, anisotropy); }
		public uint getAnisotropy() { return tsCanvasElement_getAnisotropy(self); }
		public void setWrapMode(Sampler.WrapMode mode) { tsCanvasElement_setWrapMode(self, mode); }
		public Sampler.WrapMode getWrapMode() { return tsCanvasElement_getWrapMode(self); }
		public void setTexture(Texture texture, bool linear = false) { tsCanvasElement_setTexture(self, texture.getSelf(), linear); }
		public Texture getTexture() { return new Texture(tsCanvasElement_getTexture(self)); }
		public bool getTextureLinear() { return tsCanvasElement_getTextureLinear(self); }
		public void setPipeline(Pipeline pipeline) { tsCanvasElement_setPipeline(self, pipeline.getSelf()); }
		public Pipeline getPipeline() { return new Pipeline(tsCanvasElement_getPipeline(self)); }
		public void setPrimitive(Pipeline.Primitive primitive) { tsCanvasElement_setPrimitive(self, primitive); }
		public Pipeline.Primitive getPrimitive() { return tsCanvasElement_getPrimitive(self); }
		public void setCullMode(Pipeline.CullMode mode) { tsCanvasElement_setCullMode(self, mode); }
		public Pipeline.CullMode getCullMode() { return tsCanvasElement_getCullMode(self); }
		public void setFrontMode(Pipeline.FrontMode mode) { tsCanvasElement_setFrontMode(self, mode); }
		public Pipeline.FrontMode getFrontMode() { return tsCanvasElement_getFrontMode(self); }
		public void setBlend(Pipeline.BlendOp op, Pipeline.BlendFunc src, Pipeline.BlendFunc dest) { tsCanvasElement_setBlend(self, op, src, dest); }
		public Pipeline.BlendOp getBlendOp() { return tsCanvasElement_getBlendOp(self); }
		public Pipeline.BlendFunc getBlendSrcFunc() { return tsCanvasElement_getBlendSrcFunc(self); }
		public Pipeline.BlendFunc getBlendDestFunc() { return tsCanvasElement_getBlendDestFunc(self); }
		public void setColorMask(Pipeline.ColorMask mask) { tsCanvasElement_setColorMask(self, mask); }
		public Pipeline.ColorMask getColorMask() { return tsCanvasElement_getColorMask(self); }
		public void setDepthMask(Pipeline.DepthMask mask) { tsCanvasElement_setDepthMask(self, mask); }
		public Pipeline.DepthMask getDepthMask() { return tsCanvasElement_getDepthMask(self); }
		public void setDepthFunc(Pipeline.DepthFunc func) { tsCanvasElement_setDepthFunc(self, func); }
		public Pipeline.DepthFunc getDepthFunc() { return tsCanvasElement_getDepthFunc(self); }
		public void setStencilRef(uint ref_) { tsCanvasElement_setStencilRef(self, ref_); }
		public void setStencilFunc(Pipeline.StencilFunc func, Pipeline.StencilOp fail_op, Pipeline.StencilOp dfail_op, Pipeline.StencilOp dpass_op) { tsCanvasElement_setStencilFunc(self, func, fail_op, dfail_op, dpass_op); }
		public uint getStencilRef() { return tsCanvasElement_getStencilRef(self); }
		public Pipeline.StencilFunc getStencilFunc() { return tsCanvasElement_getStencilFunc(self); }
		public Pipeline.StencilOp getStencilFailOp() { return tsCanvasElement_getStencilFailOp(self); }
		public Pipeline.StencilOp getStencilDepthFailOp() { return tsCanvasElement_getStencilDepthFailOp(self); }
		public Pipeline.StencilOp getStencilDepthPassOp() { return tsCanvasElement_getStencilDepthPassOp(self); }
		public void setDrawCallback(DrawCallback func, IntPtr data = new IntPtr()) {
			CanvasElement.DrawCallback_ func_ = null;
			if(func != null) func_ = (IntPtr command_, IntPtr element_, IntPtr data_) => { return func(new Command(command_), new CanvasElement(element_), data_); };
			if(func_ != null) DrawCallback_78 = GCHandle.Alloc(func_);
			tsCanvasElement_setDrawCallback(self, Base.getFunc(func_), data);
		}
		public Rect getRect() { return tsCanvasElement_getRect(self); }
		private GCHandle DrawCallback_78;
		public override string ToString() { return "Tellusim.CanvasElement: Valid: " + tsCanvasElement_isValidPtr(self) + "; Owner: " + tsCanvasElement_isOwnerPtr(self) + "; Const: " + tsCanvasElement_isConstPtr(self) + "; Count: " + tsCanvasElement_getCountPtr(self) + "; Internal: 0x" + tsCanvasElement_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasElement ptr) { return (ptr != null && tsCanvasElement_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_new();
		[DllImport(Base.Import)] private static extern void tsCanvasElement_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasElement_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Type tsCanvasElement_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getTypeName_CET(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isText(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isMesh(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isRect(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isTriangle(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isEllipse(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isShape(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isStrip(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setCanvas(HandleRef self, HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getCanvas_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setMode(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern Mode tsCanvasElement_getMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern Align tsCanvasElement_getAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_hasAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_hasAligns(HandleRef self, Align aligns);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setOrder(HandleRef self, int order);
		[DllImport(Base.Import)] private static extern int tsCanvasElement_getOrder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setEnabled(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_isEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_clearColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setColor_CES(HandleRef self, Stack op);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setColor_cCCES(HandleRef self, in Color color, Stack op);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setColor_ffffCES(HandleRef self, float r, float g, float b, float a, Stack op);
		[DllImport(Base.Import)] private static extern Color tsCanvasElement_getColor(HandleRef self);
		[DllImport(Base.Import)] private static extern Stack tsCanvasElement_getColorOp(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_clearTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setTransform_CES(HandleRef self, Stack op);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setTransform_cM44CES(HandleRef self, in Matrix4x4f transform, Stack op);
		[DllImport(Base.Import)] private static extern Matrix4x4f tsCanvasElement_getTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern Stack tsCanvasElement_getTransformOp(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_clearScissor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setScissor_CES(HandleRef self, Stack op);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setScissor_cRCES(HandleRef self, in Rect scissor, Stack op);
		[DllImport(Base.Import)] private static extern Rect tsCanvasElement_getScissor(HandleRef self);
		[DllImport(Base.Import)] private static extern Stack tsCanvasElement_getScissorOp(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setMipmap(HandleRef self, float mipmap);
		[DllImport(Base.Import)] private static extern float tsCanvasElement_getMipmap(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setSampler(HandleRef self, HandleRef sampler);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getSampler(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setFilter(HandleRef self, Sampler.Filter filter);
		[DllImport(Base.Import)] private static extern Sampler.Filter tsCanvasElement_getFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setAnisotropy(HandleRef self, uint anisotropy);
		[DllImport(Base.Import)] private static extern uint tsCanvasElement_getAnisotropy(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setWrapMode(HandleRef self, Sampler.WrapMode mode);
		[DllImport(Base.Import)] private static extern Sampler.WrapMode tsCanvasElement_getWrapMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setTexture(HandleRef self, HandleRef texture, bool linear);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasElement_getTextureLinear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setPipeline(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasElement_getPipeline(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setPrimitive(HandleRef self, Pipeline.Primitive primitive);
		[DllImport(Base.Import)] private static extern Pipeline.Primitive tsCanvasElement_getPrimitive(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setCullMode(HandleRef self, Pipeline.CullMode mode);
		[DllImport(Base.Import)] private static extern Pipeline.CullMode tsCanvasElement_getCullMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setFrontMode(HandleRef self, Pipeline.FrontMode mode);
		[DllImport(Base.Import)] private static extern Pipeline.FrontMode tsCanvasElement_getFrontMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setBlend(HandleRef self, Pipeline.BlendOp op, Pipeline.BlendFunc src, Pipeline.BlendFunc dest);
		[DllImport(Base.Import)] private static extern Pipeline.BlendOp tsCanvasElement_getBlendOp(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.BlendFunc tsCanvasElement_getBlendSrcFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.BlendFunc tsCanvasElement_getBlendDestFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setColorMask(HandleRef self, Pipeline.ColorMask mask);
		[DllImport(Base.Import)] private static extern Pipeline.ColorMask tsCanvasElement_getColorMask(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setDepthMask(HandleRef self, Pipeline.DepthMask mask);
		[DllImport(Base.Import)] private static extern Pipeline.DepthMask tsCanvasElement_getDepthMask(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setDepthFunc(HandleRef self, Pipeline.DepthFunc func);
		[DllImport(Base.Import)] private static extern Pipeline.DepthFunc tsCanvasElement_getDepthFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setStencilRef(HandleRef self, uint ref_);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setStencilFunc(HandleRef self, Pipeline.StencilFunc func, Pipeline.StencilOp fail_op, Pipeline.StencilOp dfail_op, Pipeline.StencilOp dpass_op);
		[DllImport(Base.Import)] private static extern uint tsCanvasElement_getStencilRef(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.StencilFunc tsCanvasElement_getStencilFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.StencilOp tsCanvasElement_getStencilFailOp(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.StencilOp tsCanvasElement_getStencilDepthFailOp(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.StencilOp tsCanvasElement_getStencilDepthPassOp(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasElement_setDrawCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Rect tsCanvasElement_getRect(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::CanvasText
	public sealed class CanvasText : CanvasElement {
		public CanvasText() { self = new HandleRef(this, tsCanvasText_new()); owner = true; }
		public CanvasText(Canvas canvas) { self = new HandleRef(this, tsCanvasText_new_C(canvas.getSelf())); owner = true; }
		public CanvasText(Canvas canvas, string text) { self = new HandleRef(this, tsCanvasText_new_Cs(canvas.getSelf(), text)); owner = true; }
		public CanvasText(Canvas canvas, String text) { self = new HandleRef(this, tsCanvasText_new_CcS(canvas.getSelf(), text.getSelf())); owner = true; }
		public CanvasText(CanvasText ptr) { self = new HandleRef(this, tsCanvasText_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasText(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasText_isOwnerPtr(self); }
		public CanvasText(CanvasElement ptr) { self = new HandleRef(this, tsCanvasText_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasText_baseCanvasElementPtr(self)); }
		public static new CanvasText Null() { return new CanvasText(IntPtr.Zero); }
		public void setFontName(string name) { tsCanvasText_setFontName_s(self, name); }
		public void setFontName(String name) { tsCanvasText_setFontName_cS(self, name.getSelf()); }
		public string getFontName() { return Base.getString(tsCanvasText_getFontName(self)); }
		public void setFontColor(in Color color) { tsCanvasText_setFontColor(self, in color); }
		public Color getFontColor() { return tsCanvasText_getFontColor(self); }
		public bool setFontSize(uint scale) { return tsCanvasText_setFontSize(self, scale); }
		public uint getFontSize() { return tsCanvasText_getFontSize(self); }
		public bool setFontScale(uint scale) { return tsCanvasText_setFontScale(self, scale); }
		public uint getFontScale() { return tsCanvasText_getFontScale(self); }
		public bool setFontStyle(in FontStyle style) { return tsCanvasText_setFontStyle(self, in style); }
		public FontStyle getFontStyleConst() { return tsCanvasText_getFontStyleConst(self); }
		public FontStyle getFontStyle() { return tsCanvasText_getFontStyle_c(self); }
		public void setPosition(in Vector3f position) { tsCanvasText_setPosition_cV3(self, in position); }
		public void setPosition(float x, float y, float z = 0.0f) { tsCanvasText_setPosition_fff(self, x, y, z); }
		public Vector3f getPosition() { return tsCanvasText_getPosition(self); }
		public void setText(string text) { tsCanvasText_setText_s(self, text); }
		public void setText(String text) { tsCanvasText_setText_cS(self, text.getSelf()); }
		public string getText() { return Base.getString(tsCanvasText_getText(self)); }
		public void clearBatches() { tsCanvasText_clearBatches(self); }
		public override string ToString() { return "Tellusim.CanvasText: Valid: " + tsCanvasText_isValidPtr(self) + "; Owner: " + tsCanvasText_isOwnerPtr(self) + "; Const: " + tsCanvasText_isConstPtr(self) + "; Count: " + tsCanvasText_getCountPtr(self) + "; Internal: 0x" + tsCanvasText_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasText ptr) { return (ptr != null && tsCanvasText_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_new_Cs(HandleRef canvas, string text);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_new_CcS(HandleRef canvas, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsCanvasText_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasText_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setFontName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setFontName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_getFontName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setFontColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsCanvasText_getFontColor(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_setFontSize(HandleRef self, uint scale);
		[DllImport(Base.Import)] private static extern uint tsCanvasText_getFontSize(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_setFontScale(HandleRef self, uint scale);
		[DllImport(Base.Import)] private static extern uint tsCanvasText_getFontScale(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasText_setFontStyle(HandleRef self, in FontStyle style);
		[DllImport(Base.Import)] private static extern FontStyle tsCanvasText_getFontStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern FontStyle tsCanvasText_getFontStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setPosition_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setPosition_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasText_getPosition(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsCanvasText_setText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasText_getText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasText_clearBatches(HandleRef self);
	}
	
	// Tellusim::CanvasMesh
	public sealed class CanvasMesh : CanvasElement {
		public CanvasMesh() { self = new HandleRef(this, tsCanvasMesh_new()); owner = true; }
		public CanvasMesh(Canvas canvas) { self = new HandleRef(this, tsCanvasMesh_new_C(canvas.getSelf())); owner = true; }
		public CanvasMesh(Canvas canvas, Mode mode) { self = new HandleRef(this, tsCanvasMesh_new_CCEM(canvas.getSelf(), mode)); owner = true; }
		public CanvasMesh(CanvasMesh ptr) { self = new HandleRef(this, tsCanvasMesh_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasMesh(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasMesh_isOwnerPtr(self); }
		public CanvasMesh(CanvasElement ptr) { self = new HandleRef(this, tsCanvasMesh_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasMesh_baseCanvasElementPtr(self)); }
		public static new CanvasMesh Null() { return new CanvasMesh(IntPtr.Zero); }
		public void setTextureName(string name) { tsCanvasMesh_setTextureName_s(self, name); }
		public void setTextureName(String name) { tsCanvasMesh_setTextureName_cS(self, name.getSelf()); }
		public string getTextureName() { return Base.getString(tsCanvasMesh_getTextureName(self)); }
		public void setGradientStyle(in GradientStyle style) { tsCanvasMesh_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsCanvasMesh_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsCanvasMesh_getGradientStyle_c(self); }
		public void clearVertices() { tsCanvasMesh_clearVertices(self); }
		public void setNumVertices(uint num_vertices) { tsCanvasMesh_setNumVertices(self, num_vertices); }
		public void reserveVertices(uint num_vertices) { tsCanvasMesh_reserveVertices(self, num_vertices); }
		public uint getNumVertices() { return tsCanvasMesh_getNumVertices(self); }
		public void setVertices(CanvasVertex[] vertices) { tsCanvasMesh_setVertices(self, vertices, (uint)vertices.Length); }
		public void addVertices(CanvasVertex[] vertices) { tsCanvasMesh_addVertices(self, vertices, (uint)vertices.Length); }
		public CanvasVertex[] getVertices() { return tsCanvasMesh_getVertices_c(self); }
		public void setVertex(uint index, in CanvasVertex vertex) { tsCanvasMesh_setVertex(self, index, in vertex); }
		public CanvasVertex getVertex(uint index) { return tsCanvasMesh_getVertex_cu(self, index); }
		public void setVertexPosition(uint index, in Vector3f position) { tsCanvasMesh_setVertexPosition_ucV3(self, index, in position); }
		public void setVertexPosition(uint index, float x, float y, float z = 0.0f) { tsCanvasMesh_setVertexPosition_ufff(self, index, x, y, z); }
		public Vector3f getVertexPosition(uint index) { return tsCanvasMesh_getVertexPosition(self, index); }
		public void setVertexTexCoord(uint index, in Vector2f texcoord) { tsCanvasMesh_setVertexTexCoord_ucV2(self, index, in texcoord); }
		public void setVertexTexCoord(uint index, float s, float t) { tsCanvasMesh_setVertexTexCoord_uff(self, index, s, t); }
		public Vector2f getVertexTexCoord(uint index) { return tsCanvasMesh_getVertexTexCoord(self, index); }
		public void setVertexColor(uint index, in Color color) { tsCanvasMesh_setVertexColor_ucC(self, index, in color); }
		public void setVertexColor(uint index, uint color) { tsCanvasMesh_setVertexColor_uu(self, index, color); }
		public uint getVertexColor(uint index) { return tsCanvasMesh_getVertexColor(self, index); }
		public uint addVertex(in Vector3f position) { return tsCanvasMesh_addVertex_cV3(self, in position); }
		public uint addVertex(in Vector3f position, uint color) { return tsCanvasMesh_addVertex_cV3u(self, in position, color); }
		public uint addVertex(in Vector3f position, in Vector2f texcoord) { return tsCanvasMesh_addVertex_cV3cV2(self, in position, in texcoord); }
		public uint addVertex(in Vector3f position, in Vector2f texcoord, uint color) { return tsCanvasMesh_addVertex_cV3cV2u(self, in position, in texcoord, color); }
		public uint addVertex(float x, float y, float z, float s, float t, uint color = 0xffffffffu) { return tsCanvasMesh_addVertex_fffffu(self, x, y, z, s, t, color); }
		public uint addVertex(float x, float y, float z, uint color = 0xffffffffu) { return tsCanvasMesh_addVertex_fffu(self, x, y, z, color); }
		public uint addVertex(float x, float y, uint color = 0xffffffffu) { return tsCanvasMesh_addVertex_ffu(self, x, y, color); }
		public void clearIndices() { tsCanvasMesh_clearIndices(self); }
		public void setNumIndices(uint num_indices) { tsCanvasMesh_setNumIndices(self, num_indices); }
		public void reserveIndices(uint num_indices) { tsCanvasMesh_reserveIndices(self, num_indices); }
		public uint getNumIndices() { return tsCanvasMesh_getNumIndices(self); }
		public void setIndices(uint[] indices, uint num_indices) { tsCanvasMesh_setIndices(self, indices, num_indices); }
		public void addIndices(uint[] indices, uint num_indices) { tsCanvasMesh_addIndices_upu(self, indices, num_indices); }
		public uint[] getIndices() { return tsCanvasMesh_getIndices_c(self); }
		public void setIndex(uint index, uint value) { tsCanvasMesh_setIndex(self, index, value); }
		public uint getIndex(uint index) { return tsCanvasMesh_getIndex(self, index); }
		public void addIndex(uint i0) { tsCanvasMesh_addIndex(self, i0); }
		public void addIndices(uint i0, uint i1) { tsCanvasMesh_addIndices_uu(self, i0, i1); }
		public void addIndices(uint i0, uint i1, uint i2) { tsCanvasMesh_addIndices_uuu(self, i0, i1, i2); }
		public void addIndices(uint i0, uint i1, uint i2, uint i3) { tsCanvasMesh_addIndices_uuuu(self, i0, i1, i2, i3); }
		public void setRect(in Rect rect) { tsCanvasMesh_setRect(self, in rect); }
		public override string ToString() { return "Tellusim.CanvasMesh: Valid: " + tsCanvasMesh_isValidPtr(self) + "; Owner: " + tsCanvasMesh_isOwnerPtr(self) + "; Const: " + tsCanvasMesh_isConstPtr(self) + "; Count: " + tsCanvasMesh_getCountPtr(self) + "; Internal: 0x" + tsCanvasMesh_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasMesh ptr) { return (ptr != null && tsCanvasMesh_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_new_CCEM(HandleRef canvas, Mode mode);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasMesh_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasMesh_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasMesh_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasMesh_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasMesh_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setTextureName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setTextureName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasMesh_getTextureName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasMesh_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasMesh_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_clearVertices(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setNumVertices(HandleRef self, uint num_vertices);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_reserveVertices(HandleRef self, uint num_vertices);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_getNumVertices(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertices(HandleRef self, CanvasVertex[] vertices, uint num_vertices);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_addVertices(HandleRef self, CanvasVertex[] vertices, uint num_vertices);
		[DllImport(Base.Import)] private static extern CanvasVertex[] tsCanvasMesh_getVertices_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertex(HandleRef self, uint index, in CanvasVertex vertex);
		[DllImport(Base.Import)] private static extern CanvasVertex tsCanvasMesh_getVertex_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertexPosition_ucV3(HandleRef self, uint index, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertexPosition_ufff(HandleRef self, uint index, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasMesh_getVertexPosition(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertexTexCoord_ucV2(HandleRef self, uint index, in Vector2f texcoord);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertexTexCoord_uff(HandleRef self, uint index, float s, float t);
		[DllImport(Base.Import)] private static extern Vector2f tsCanvasMesh_getVertexTexCoord(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertexColor_ucC(HandleRef self, uint index, in Color color);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setVertexColor_uu(HandleRef self, uint index, uint color);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_getVertexColor(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_cV3u(HandleRef self, in Vector3f position, uint color);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_cV3cV2(HandleRef self, in Vector3f position, in Vector2f texcoord);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_cV3cV2u(HandleRef self, in Vector3f position, in Vector2f texcoord, uint color);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_fffffu(HandleRef self, float x, float y, float z, float s, float t, uint color);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_fffu(HandleRef self, float x, float y, float z, uint color);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_addVertex_ffu(HandleRef self, float x, float y, uint color);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_clearIndices(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setNumIndices(HandleRef self, uint num_indices);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_reserveIndices(HandleRef self, uint num_indices);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_getNumIndices(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setIndices(HandleRef self, uint[] indices, uint num_indices);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_addIndices_upu(HandleRef self, uint[] indices, uint num_indices);
		[DllImport(Base.Import)] private static extern uint[] tsCanvasMesh_getIndices_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setIndex(HandleRef self, uint index, uint value);
		[DllImport(Base.Import)] private static extern uint tsCanvasMesh_getIndex(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_addIndex(HandleRef self, uint i0);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_addIndices_uu(HandleRef self, uint i0, uint i1);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_addIndices_uuu(HandleRef self, uint i0, uint i1, uint i2);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_addIndices_uuuu(HandleRef self, uint i0, uint i1, uint i2, uint i3);
		[DllImport(Base.Import)] private static extern void tsCanvasMesh_setRect(HandleRef self, in Rect rect);
	}
	
	// Tellusim::CanvasRect
	public sealed class CanvasRect : CanvasElement {
		public CanvasRect() { self = new HandleRef(this, tsCanvasRect_new()); owner = true; }
		public CanvasRect(Canvas canvas) { self = new HandleRef(this, tsCanvasRect_new_C(canvas.getSelf())); owner = true; }
		public CanvasRect(Canvas canvas, float radius) { self = new HandleRef(this, tsCanvasRect_new_Cf(canvas.getSelf(), radius)); owner = true; }
		public CanvasRect(Canvas canvas, float radius, in Vector2f size) { self = new HandleRef(this, tsCanvasRect_new_CfcV2(canvas.getSelf(), radius, in size)); owner = true; }
		public CanvasRect(CanvasRect ptr) { self = new HandleRef(this, tsCanvasRect_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasRect(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasRect_isOwnerPtr(self); }
		public CanvasRect(CanvasElement ptr) { self = new HandleRef(this, tsCanvasRect_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasRect_baseCanvasElementPtr(self)); }
		public static new CanvasRect Null() { return new CanvasRect(IntPtr.Zero); }
		public void setRadius(float radius) { tsCanvasRect_setRadius(self, radius); }
		public float getRadius() { return tsCanvasRect_getRadius(self); }
		public void setTextureName(string name) { tsCanvasRect_setTextureName_s(self, name); }
		public void setTextureName(String name) { tsCanvasRect_setTextureName_cS(self, name.getSelf()); }
		public string getTextureName() { return Base.getString(tsCanvasRect_getTextureName(self)); }
		public void setStrokeColor(in Color color) { tsCanvasRect_setStrokeColor(self, in color); }
		public Color getStrokeColor() { return tsCanvasRect_getStrokeColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsCanvasRect_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsCanvasRect_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsCanvasRect_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsCanvasRect_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsCanvasRect_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsCanvasRect_getGradientStyle_c(self); }
		public void setSize(in Vector2f size) { tsCanvasRect_setSize_cV2(self, in size); }
		public void setSize(float width, float height) { tsCanvasRect_setSize_ff(self, width, height); }
		public Vector2f getSize() { return tsCanvasRect_getSize(self); }
		public float getWidth() { return tsCanvasRect_getWidth(self); }
		public float getHeight() { return tsCanvasRect_getHeight(self); }
		public void setPosition(in Vector3f position) { tsCanvasRect_setPosition_cV3(self, in position); }
		public void setPosition(float x, float y, float z = 0.0f) { tsCanvasRect_setPosition_fff(self, x, y, z); }
		public Vector3f getPosition() { return tsCanvasRect_getPosition(self); }
		public void setTexCoord(in Rect texcoord) { tsCanvasRect_setTexCoord_cR(self, in texcoord); }
		public void setTexCoord(float left, float right, float bottom, float top) { tsCanvasRect_setTexCoord_ffff(self, left, right, bottom, top); }
		public Rect getTexCoord() { return tsCanvasRect_getTexCoord(self); }
		public override string ToString() { return "Tellusim.CanvasRect: Valid: " + tsCanvasRect_isValidPtr(self) + "; Owner: " + tsCanvasRect_isOwnerPtr(self) + "; Const: " + tsCanvasRect_isConstPtr(self) + "; Count: " + tsCanvasRect_getCountPtr(self) + "; Internal: 0x" + tsCanvasRect_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasRect ptr) { return (ptr != null && tsCanvasRect_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_new_Cf(HandleRef canvas, float radius);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_new_CfcV2(HandleRef canvas, float radius, in Vector2f size);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasRect_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasRect_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasRect_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasRect_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasRect_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasRect_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern float tsCanvasRect_getRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setTextureName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setTextureName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasRect_getTextureName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setStrokeColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsCanvasRect_getStrokeColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasRect_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasRect_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasRect_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasRect_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setSize_cV2(HandleRef self, in Vector2f size);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setSize_ff(HandleRef self, float width, float height);
		[DllImport(Base.Import)] private static extern Vector2f tsCanvasRect_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsCanvasRect_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsCanvasRect_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setPosition_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setPosition_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasRect_getPosition(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setTexCoord_cR(HandleRef self, in Rect texcoord);
		[DllImport(Base.Import)] private static extern void tsCanvasRect_setTexCoord_ffff(HandleRef self, float left, float right, float bottom, float top);
		[DllImport(Base.Import)] private static extern Rect tsCanvasRect_getTexCoord(HandleRef self);
	}
	
	// Tellusim::CanvasTriangle
	public sealed class CanvasTriangle : CanvasElement {
		public CanvasTriangle() { self = new HandleRef(this, tsCanvasTriangle_new()); owner = true; }
		public CanvasTriangle(Canvas canvas) { self = new HandleRef(this, tsCanvasTriangle_new_C(canvas.getSelf())); owner = true; }
		public CanvasTriangle(Canvas canvas, float radius) { self = new HandleRef(this, tsCanvasTriangle_new_Cf(canvas.getSelf(), radius)); owner = true; }
		public CanvasTriangle(CanvasTriangle ptr) { self = new HandleRef(this, tsCanvasTriangle_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasTriangle(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasTriangle_isOwnerPtr(self); }
		public CanvasTriangle(CanvasElement ptr) { self = new HandleRef(this, tsCanvasTriangle_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasTriangle_baseCanvasElementPtr(self)); }
		public static new CanvasTriangle Null() { return new CanvasTriangle(IntPtr.Zero); }
		public void setRadius(float radius) { tsCanvasTriangle_setRadius(self, radius); }
		public float getRadius() { return tsCanvasTriangle_getRadius(self); }
		public void setStrokeColor(in Color color) { tsCanvasTriangle_setStrokeColor(self, in color); }
		public Color getStrokeColor() { return tsCanvasTriangle_getStrokeColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsCanvasTriangle_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsCanvasTriangle_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsCanvasTriangle_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsCanvasTriangle_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsCanvasTriangle_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsCanvasTriangle_getGradientStyle_c(self); }
		public void setPosition0(in Vector3f position) { tsCanvasTriangle_setPosition0_cV3(self, in position); }
		public void setPosition1(in Vector3f position) { tsCanvasTriangle_setPosition1_cV3(self, in position); }
		public void setPosition2(in Vector3f position) { tsCanvasTriangle_setPosition2_cV3(self, in position); }
		public void setPosition0(float x, float y, float z = 0.0f) { tsCanvasTriangle_setPosition0_fff(self, x, y, z); }
		public void setPosition1(float x, float y, float z = 0.0f) { tsCanvasTriangle_setPosition1_fff(self, x, y, z); }
		public void setPosition2(float x, float y, float z = 0.0f) { tsCanvasTriangle_setPosition2_fff(self, x, y, z); }
		public void setPosition(in Vector3f position_0, in Vector3f position_1, in Vector3f position_2) { tsCanvasTriangle_setPosition(self, in position_0, in position_1, in position_2); }
		public Vector3f getPosition0() { return tsCanvasTriangle_getPosition0(self); }
		public Vector3f getPosition1() { return tsCanvasTriangle_getPosition1(self); }
		public Vector3f getPosition2() { return tsCanvasTriangle_getPosition2(self); }
		public override string ToString() { return "Tellusim.CanvasTriangle: Valid: " + tsCanvasTriangle_isValidPtr(self) + "; Owner: " + tsCanvasTriangle_isOwnerPtr(self) + "; Const: " + tsCanvasTriangle_isConstPtr(self) + "; Count: " + tsCanvasTriangle_getCountPtr(self) + "; Internal: 0x" + tsCanvasTriangle_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasTriangle ptr) { return (ptr != null && tsCanvasTriangle_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_new_Cf(HandleRef canvas, float radius);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasTriangle_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasTriangle_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasTriangle_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasTriangle_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasTriangle_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasTriangle_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasTriangle_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern float tsCanvasTriangle_getRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setStrokeColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsCanvasTriangle_getStrokeColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasTriangle_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasTriangle_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasTriangle_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasTriangle_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition0_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition1_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition2_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition0_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition1_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition2_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasTriangle_setPosition(HandleRef self, in Vector3f position_0, in Vector3f position_1, in Vector3f position_2);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasTriangle_getPosition0(HandleRef self);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasTriangle_getPosition1(HandleRef self);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasTriangle_getPosition2(HandleRef self);
	}
	
	// Tellusim::CanvasEllipse
	public sealed class CanvasEllipse : CanvasElement {
		public CanvasEllipse() { self = new HandleRef(this, tsCanvasEllipse_new()); owner = true; }
		public CanvasEllipse(Canvas canvas) { self = new HandleRef(this, tsCanvasEllipse_new_C(canvas.getSelf())); owner = true; }
		public CanvasEllipse(Canvas canvas, float radius) { self = new HandleRef(this, tsCanvasEllipse_new_Cf(canvas.getSelf(), radius)); owner = true; }
		public CanvasEllipse(CanvasEllipse ptr) { self = new HandleRef(this, tsCanvasEllipse_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasEllipse(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasEllipse_isOwnerPtr(self); }
		public CanvasEllipse(CanvasElement ptr) { self = new HandleRef(this, tsCanvasEllipse_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasEllipse_baseCanvasElementPtr(self)); }
		public static new CanvasEllipse Null() { return new CanvasEllipse(IntPtr.Zero); }
		public void setRadius(float radius) { tsCanvasEllipse_setRadius(self, radius); }
		public float getRadius() { return tsCanvasEllipse_getRadius(self); }
		public void setTextureName(string name) { tsCanvasEllipse_setTextureName_s(self, name); }
		public void setTextureName(String name) { tsCanvasEllipse_setTextureName_cS(self, name.getSelf()); }
		public string getTextureName() { return Base.getString(tsCanvasEllipse_getTextureName(self)); }
		public void setStrokeColor(in Color color) { tsCanvasEllipse_setStrokeColor(self, in color); }
		public Color getStrokeColor() { return tsCanvasEllipse_getStrokeColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsCanvasEllipse_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsCanvasEllipse_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsCanvasEllipse_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsCanvasEllipse_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsCanvasEllipse_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsCanvasEllipse_getGradientStyle_c(self); }
		public void setPosition(in Vector3f position) { tsCanvasEllipse_setPosition_cV3(self, in position); }
		public void setPosition0(in Vector3f position) { tsCanvasEllipse_setPosition0_cV3(self, in position); }
		public void setPosition1(in Vector3f position) { tsCanvasEllipse_setPosition1_cV3(self, in position); }
		public void setPosition(float x, float y, float z = 0.0f) { tsCanvasEllipse_setPosition_fff(self, x, y, z); }
		public void setPosition0(float x, float y, float z = 0.0f) { tsCanvasEllipse_setPosition0_fff(self, x, y, z); }
		public void setPosition1(float x, float y, float z = 0.0f) { tsCanvasEllipse_setPosition1_fff(self, x, y, z); }
		public void setPosition(in Vector3f position_0, in Vector3f position_1) { tsCanvasEllipse_setPosition_cV3cV3(self, in position_0, in position_1); }
		public Vector3f getPosition0() { return tsCanvasEllipse_getPosition0(self); }
		public Vector3f getPosition1() { return tsCanvasEllipse_getPosition1(self); }
		public void setTexCoord(in Rect texcoord) { tsCanvasEllipse_setTexCoord_cR(self, in texcoord); }
		public void setTexCoord(float left, float right, float bottom, float top) { tsCanvasEllipse_setTexCoord_ffff(self, left, right, bottom, top); }
		public Rect getTexCoord() { return tsCanvasEllipse_getTexCoord(self); }
		public override string ToString() { return "Tellusim.CanvasEllipse: Valid: " + tsCanvasEllipse_isValidPtr(self) + "; Owner: " + tsCanvasEllipse_isOwnerPtr(self) + "; Const: " + tsCanvasEllipse_isConstPtr(self) + "; Count: " + tsCanvasEllipse_getCountPtr(self) + "; Internal: 0x" + tsCanvasEllipse_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasEllipse ptr) { return (ptr != null && tsCanvasEllipse_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_new_Cf(HandleRef canvas, float radius);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasEllipse_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasEllipse_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasEllipse_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasEllipse_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasEllipse_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasEllipse_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern float tsCanvasEllipse_getRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setTextureName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setTextureName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasEllipse_getTextureName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setStrokeColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsCanvasEllipse_getStrokeColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasEllipse_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasEllipse_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasEllipse_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasEllipse_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition0_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition1_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition0_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition1_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setPosition_cV3cV3(HandleRef self, in Vector3f position_0, in Vector3f position_1);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasEllipse_getPosition0(HandleRef self);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasEllipse_getPosition1(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setTexCoord_cR(HandleRef self, in Rect texcoord);
		[DllImport(Base.Import)] private static extern void tsCanvasEllipse_setTexCoord_ffff(HandleRef self, float left, float right, float bottom, float top);
		[DllImport(Base.Import)] private static extern Rect tsCanvasEllipse_getTexCoord(HandleRef self);
	}
	
	// Tellusim::CanvasShape
	public sealed class CanvasShape : CanvasElement {
		public CanvasShape() { self = new HandleRef(this, tsCanvasShape_new()); owner = true; }
		public CanvasShape(Canvas canvas) { self = new HandleRef(this, tsCanvasShape_new_C(canvas.getSelf())); owner = true; }
		public CanvasShape(Canvas canvas, bool cubic) { self = new HandleRef(this, tsCanvasShape_new_Cb(canvas.getSelf(), cubic)); owner = true; }
		public CanvasShape(CanvasShape ptr) { self = new HandleRef(this, tsCanvasShape_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasShape(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasShape_isOwnerPtr(self); }
		public CanvasShape(CanvasElement ptr) { self = new HandleRef(this, tsCanvasShape_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasShape_baseCanvasElementPtr(self)); }
		public static new CanvasShape Null() { return new CanvasShape(IntPtr.Zero); }
		public void setCubic(bool cubic) { tsCanvasShape_setCubic(self, cubic); }
		public bool isCubic() { return tsCanvasShape_isCubic(self); }
		public void setThreshold(float threshold) { tsCanvasShape_setThreshold(self, threshold); }
		public float getThreshold() { return tsCanvasShape_getThreshold(self); }
		public void setStrokeColor(in Color color) { tsCanvasShape_setStrokeColor(self, in color); }
		public Color getStrokeColor() { return tsCanvasShape_getStrokeColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsCanvasShape_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsCanvasShape_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsCanvasShape_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsCanvasShape_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsCanvasShape_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsCanvasShape_getGradientStyle_c(self); }
		public bool createSVG(string src, float scale = 1.0f) { return tsCanvasShape_createSVG(self, src, scale); }
		public void clearPositions() { tsCanvasShape_clearPositions(self); }
		public void setNumPositions(uint num_positions) { tsCanvasShape_setNumPositions(self, num_positions); }
		public void reservePositions(uint num_positions) { tsCanvasShape_reservePositions(self, num_positions); }
		public uint getNumPositions() { return tsCanvasShape_getNumPositions(self); }
		public void setPositions(Vector3f[] positions) { tsCanvasShape_setPositions(self, positions, (uint)positions.Length); }
		public void addPositions(Vector3f[] positions) { tsCanvasShape_addPositions(self, positions, (uint)positions.Length); }
		public Vector3f[] getPositions() { return tsCanvasShape_getPositions_c(self); }
		public void setPosition(uint index, in Vector3f position) { tsCanvasShape_setPosition_ucV3(self, index, in position); }
		public void setPosition(uint index, float x, float y, float z = 0.0f) { tsCanvasShape_setPosition_ufff(self, index, x, y, z); }
		public Vector3f getPosition(uint index) { return tsCanvasShape_getPosition_cu(self, index); }
		public uint addPosition(in Vector2f position) { return tsCanvasShape_addPosition_cV2(self, in position); }
		public uint addPosition(in Vector3f position) { return tsCanvasShape_addPosition_cV3(self, in position); }
		public uint addPosition(float x, float y, float z = 0.0f) { return tsCanvasShape_addPosition_fff(self, x, y, z); }
		public void setTexCoord(in Rect texcoord) { tsCanvasShape_setTexCoord_cR(self, in texcoord); }
		public void setTexCoord(float left, float right, float bottom, float top) { tsCanvasShape_setTexCoord_ffff(self, left, right, bottom, top); }
		public Rect getTexCoord() { return tsCanvasShape_getTexCoord(self); }
		public override string ToString() { return "Tellusim.CanvasShape: Valid: " + tsCanvasShape_isValidPtr(self) + "; Owner: " + tsCanvasShape_isOwnerPtr(self) + "; Const: " + tsCanvasShape_isConstPtr(self) + "; Count: " + tsCanvasShape_getCountPtr(self) + "; Internal: 0x" + tsCanvasShape_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasShape ptr) { return (ptr != null && tsCanvasShape_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_new_Cb(HandleRef canvas, bool cubic);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasShape_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasShape_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setCubic(HandleRef self, bool cubic);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_isCubic(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setThreshold(HandleRef self, float threshold);
		[DllImport(Base.Import)] private static extern float tsCanvasShape_getThreshold(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setStrokeColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsCanvasShape_getStrokeColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasShape_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasShape_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasShape_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsCanvasShape_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasShape_createSVG(HandleRef self, string src, float scale);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_clearPositions(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setNumPositions(HandleRef self, uint num_positions);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_reservePositions(HandleRef self, uint num_positions);
		[DllImport(Base.Import)] private static extern uint tsCanvasShape_getNumPositions(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setPositions(HandleRef self, Vector3f[] positions, uint num_positions);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_addPositions(HandleRef self, Vector3f[] positions, uint num_positions);
		[DllImport(Base.Import)] private static extern Vector3f[] tsCanvasShape_getPositions_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setPosition_ucV3(HandleRef self, uint index, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setPosition_ufff(HandleRef self, uint index, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasShape_getPosition_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsCanvasShape_addPosition_cV2(HandleRef self, in Vector2f position);
		[DllImport(Base.Import)] private static extern uint tsCanvasShape_addPosition_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern uint tsCanvasShape_addPosition_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setTexCoord_cR(HandleRef self, in Rect texcoord);
		[DllImport(Base.Import)] private static extern void tsCanvasShape_setTexCoord_ffff(HandleRef self, float left, float right, float bottom, float top);
		[DllImport(Base.Import)] private static extern Rect tsCanvasShape_getTexCoord(HandleRef self);
	}
	
	// Tellusim::CanvasStrip
	public sealed class CanvasStrip : CanvasElement {
		public CanvasStrip() { self = new HandleRef(this, tsCanvasStrip_new()); owner = true; }
		public CanvasStrip(Canvas canvas) { self = new HandleRef(this, tsCanvasStrip_new_C(canvas.getSelf())); owner = true; }
		public CanvasStrip(Canvas canvas, float width) { self = new HandleRef(this, tsCanvasStrip_new_Cf(canvas.getSelf(), width)); owner = true; }
		public CanvasStrip(CanvasStrip ptr) { self = new HandleRef(this, tsCanvasStrip_copyPtr(ptr.getSelf())); owner = true; }
		public CanvasStrip(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvasStrip_isOwnerPtr(self); }
		public CanvasStrip(CanvasElement ptr) { self = new HandleRef(this, tsCanvasStrip_castCanvasElementPtr(ptr.getSelf())); }
		public CanvasElement toCanvasElement() { return new CanvasElement(tsCanvasStrip_baseCanvasElementPtr(self)); }
		public static new CanvasStrip Null() { return new CanvasStrip(IntPtr.Zero); }
		public void setWidth(float width) { tsCanvasStrip_setWidth(self, width); }
		public float getWidth() { return tsCanvasStrip_getWidth(self); }
		public void setOffset(float offset) { tsCanvasStrip_setOffset(self, offset); }
		public float getOffset() { return tsCanvasStrip_getOffset(self); }
		public void setStrokeColor(in Color color) { tsCanvasStrip_setStrokeColor(self, in color); }
		public Color getStrokeColor() { return tsCanvasStrip_getStrokeColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsCanvasStrip_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsCanvasStrip_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsCanvasStrip_getStrokeStyle_c(self); }
		public void createQuadratic(in Vector2f p0, in Vector2f p1, in Vector2f p2, float threshold = 1.0f) { tsCanvasStrip_createQuadratic_cV2cV2cV2f(self, in p0, in p1, in p2, threshold); }
		public void createQuadratic(in Vector3f p0, in Vector3f p1, in Vector3f p2, float threshold = 1.0f) { tsCanvasStrip_createQuadratic_cV3cV3cV3f(self, in p0, in p1, in p2, threshold); }
		public void createCubic(in Vector2f p0, in Vector2f p1, in Vector2f p2, in Vector2f p3, float threshold = 1.0f) { tsCanvasStrip_createCubic_cV2cV2cV2cV2f(self, in p0, in p1, in p2, in p3, threshold); }
		public void createCubic(in Vector3f p0, in Vector3f p1, in Vector3f p2, in Vector3f p3, float threshold = 1.0f) { tsCanvasStrip_createCubic_cV3cV3cV3cV3f(self, in p0, in p1, in p2, in p3, threshold); }
		public void clearPositions() { tsCanvasStrip_clearPositions(self); }
		public void setNumPositions(uint num_positions) { tsCanvasStrip_setNumPositions(self, num_positions); }
		public void reservePositions(uint num_positions) { tsCanvasStrip_reservePositions(self, num_positions); }
		public uint getNumPositions() { return tsCanvasStrip_getNumPositions(self); }
		public void setPositions(Vector3f[] positions) { tsCanvasStrip_setPositions(self, positions, (uint)positions.Length); }
		public void addPositions(Vector3f[] positions) { tsCanvasStrip_addPositions(self, positions, (uint)positions.Length); }
		public Vector3f[] getPositions() { return tsCanvasStrip_getPositions_c(self); }
		public void setPosition(uint index, in Vector3f position) { tsCanvasStrip_setPosition_ucV3(self, index, in position); }
		public void setPosition(uint index, float x, float y, float z = 0.0f) { tsCanvasStrip_setPosition_ufff(self, index, x, y, z); }
		public Vector3f getPosition(uint index) { return tsCanvasStrip_getPosition_cu(self, index); }
		public uint addPosition(in Vector2f position) { return tsCanvasStrip_addPosition_cV2(self, in position); }
		public uint addPosition(in Vector3f position) { return tsCanvasStrip_addPosition_cV3(self, in position); }
		public uint addPosition(float x, float y, float z = 0.0f) { return tsCanvasStrip_addPosition_fff(self, x, y, z); }
		public override string ToString() { return "Tellusim.CanvasStrip: Valid: " + tsCanvasStrip_isValidPtr(self) + "; Owner: " + tsCanvasStrip_isOwnerPtr(self) + "; Const: " + tsCanvasStrip_isConstPtr(self) + "; Count: " + tsCanvasStrip_getCountPtr(self) + "; Internal: 0x" + tsCanvasStrip_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CanvasStrip ptr) { return (ptr != null && tsCanvasStrip_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_new_C(HandleRef canvas);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_new_Cf(HandleRef canvas, float width);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasStrip_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasStrip_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasStrip_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasStrip_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvasStrip_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvasStrip_equalCanvasElementPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_castCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvasStrip_baseCanvasElementPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setWidth(HandleRef self, float width);
		[DllImport(Base.Import)] private static extern float tsCanvasStrip_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setOffset(HandleRef self, float offset);
		[DllImport(Base.Import)] private static extern float tsCanvasStrip_getOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setStrokeColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsCanvasStrip_getStrokeColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasStrip_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsCanvasStrip_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_createQuadratic_cV2cV2cV2f(HandleRef self, in Vector2f p0, in Vector2f p1, in Vector2f p2, float threshold);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_createQuadratic_cV3cV3cV3f(HandleRef self, in Vector3f p0, in Vector3f p1, in Vector3f p2, float threshold);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_createCubic_cV2cV2cV2cV2f(HandleRef self, in Vector2f p0, in Vector2f p1, in Vector2f p2, in Vector2f p3, float threshold);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_createCubic_cV3cV3cV3cV3f(HandleRef self, in Vector3f p0, in Vector3f p1, in Vector3f p2, in Vector3f p3, float threshold);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_clearPositions(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setNumPositions(HandleRef self, uint num_positions);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_reservePositions(HandleRef self, uint num_positions);
		[DllImport(Base.Import)] private static extern uint tsCanvasStrip_getNumPositions(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setPositions(HandleRef self, Vector3f[] positions, uint num_positions);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_addPositions(HandleRef self, Vector3f[] positions, uint num_positions);
		[DllImport(Base.Import)] private static extern Vector3f[] tsCanvasStrip_getPositions_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setPosition_ucV3(HandleRef self, uint index, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsCanvasStrip_setPosition_ufff(HandleRef self, uint index, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsCanvasStrip_getPosition_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsCanvasStrip_addPosition_cV2(HandleRef self, in Vector2f position);
		[DllImport(Base.Import)] private static extern uint tsCanvasStrip_addPosition_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern uint tsCanvasStrip_addPosition_fff(HandleRef self, float x, float y, float z);
	}
	
	// Tellusim::Canvas
	public sealed class Canvas {
		public delegate bool CreateCallback(Device device, Canvas canvas, uint scale, IntPtr data_);
		public delegate bool CreateCallback_(IntPtr device, IntPtr canvas, uint scale, IntPtr data_);
		public delegate bool PipelineCallback(Pipeline pipeline, Canvas canvas, CanvasElement element, IntPtr data_);
		public delegate bool PipelineCallback_(IntPtr pipeline, IntPtr canvas, IntPtr element, IntPtr data_);
		public delegate bool BeginCallback(Command command, Canvas canvas, IntPtr data_);
		public delegate bool BeginCallback_(IntPtr command, IntPtr canvas, IntPtr data_);
		public delegate bool DrawCallback(Command command, Canvas canvas, IntPtr data_);
		public delegate bool DrawCallback_(IntPtr command, IntPtr canvas, IntPtr data_);
		public Canvas() { self = new HandleRef(this, tsCanvas_new()); owner = true; }
		public Canvas(in Canvas parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsCanvas_new_C(ref parent_)); owner = true;
		}
		public Canvas(Canvas ptr) { self = new HandleRef(this, tsCanvas_copyPtr(ptr.getSelf())); owner = true; }
		public Canvas(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCanvas_isOwnerPtr(self); }
		public static Canvas Null() { return new Canvas(IntPtr.Zero); }
		~Canvas() { if(owner) tsCanvas_delete(self); }
		public bool equalPtr(Canvas ptr) { return tsCanvas_equalPtr(self, ptr.getSelf()); }
		public Canvas clonePtr() { return new Canvas(tsCanvas_clonePtr(self)); }
		public void clearPtr() { tsCanvas_clearPtr(self); }
		public void destroyPtr() { tsCanvas_destroyPtr(self); }
		public void acquirePtr() { tsCanvas_acquirePtr(self); }
		public void unacquirePtr() { tsCanvas_unacquirePtr(self); }
		public bool isValidPtr() { return tsCanvas_isValidPtr(self); }
		public bool isOwnerPtr() { return tsCanvas_isOwnerPtr(self); }
		public bool isConstPtr() { return tsCanvas_isConstPtr(self); }
		public uint getCountPtr() { return tsCanvas_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsCanvas_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsCanvas_clear(self); }
		public bool isCreated() { return tsCanvas_isCreated(self); }
		public uint getScale(Target target, uint scale = 100) { return tsCanvas_getScale(self, target.getSelf(), scale); }
		public bool create(Device device, Format color, Format depth, uint multisample = 1, uint scale = 0) { return tsCanvas_create_cDFFuu(self, device.getSelf(), color, depth, multisample, scale); }
		public bool create(Device device, Target target, uint scale = 0) { return tsCanvas_create_cDcTu(self, device.getSelf(), target.getSelf(), scale); }
		public void setPipelineHash(uint hash) { tsCanvas_setPipelineHash(self, hash); }
		public uint getPipelineHash() { return tsCanvas_getPipelineHash(self); }
		public Format getColorFormat() { return tsCanvas_getColorFormat(self); }
		public Format getDepthFormat() { return tsCanvas_getDepthFormat(self); }
		public uint getMultisample() { return tsCanvas_getMultisample(self); }
		public void setOrder(int order) { tsCanvas_setOrder(self, order); }
		public int getOrder() { return tsCanvas_getOrder(self); }
		public void setEnabled(bool enabled) { tsCanvas_setEnabled(self, enabled); }
		public bool isEnabled() { return tsCanvas_isEnabled(self); }
		public void setViewport(in Viewport viewport) { tsCanvas_setViewport_cV(self, in viewport); }
		public void setViewport(uint width, uint height) { tsCanvas_setViewport_uu(self, width, height); }
		public void setViewport(float width, float height) { tsCanvas_setViewport_ff(self, width, height); }
		public Viewport getViewport() { return tsCanvas_getViewport(self); }
		public float getWidth() { return tsCanvas_getWidth(self); }
		public float getHeight() { return tsCanvas_getHeight(self); }
		public void clearColor() { tsCanvas_clearColor(self); }
		public void setColor(in Color color) { tsCanvas_setColor_cC(self, in color); }
		public void setColor(float r, float g, float b, float a) { tsCanvas_setColor_ffff(self, r, g, b, a); }
		public Color getColor() { return tsCanvas_getColor(self); }
		public void clearScissor() { tsCanvas_clearScissor(self); }
		public void setScissor(in Rect scissor) { tsCanvas_setScissor(self, in scissor); }
		public Rect getScissor() { return tsCanvas_getScissor(self); }
		public void clearTransform() { tsCanvas_clearTransform(self); }
		public void setTransform(in Matrix4x4f transform) { tsCanvas_setTransform(self, in transform); }
		public Matrix4x4f getTransform() { return tsCanvas_getTransform(self); }
		public uint setParent(Canvas parent) { return tsCanvas_setParent(self, parent.getSelf()); }
		public Canvas getParent() { return new Canvas(tsCanvas_getParent_c(self)); }
		public uint addChild(Canvas child) { return tsCanvas_addChild(self, child.getSelf()); }
		public bool removeChild(Canvas child) { return tsCanvas_removeChild(self, child.getSelf()); }
		public bool raiseChild(Canvas child) { return tsCanvas_raiseChild(self, child.getSelf()); }
		public bool lowerChild(Canvas child) { return tsCanvas_lowerChild(self, child.getSelf()); }
		public void releaseChildren() { tsCanvas_releaseChildren(self); }
		public uint findChild(Canvas child) { return tsCanvas_findChild(self, child.getSelf()); }
		public bool isChild(Canvas child) { return tsCanvas_isChild(self, child.getSelf()); }
		public uint getNumChildren() { return tsCanvas_getNumChildren(self); }
		public Canvas getChild(uint index) { return new Canvas(tsCanvas_getChild_cu(self, index)); }
		public uint addElement(CanvasElement element) { return tsCanvas_addElement(self, element.getSelf()); }
		public bool removeElement(CanvasElement element) { return tsCanvas_removeElement(self, element.getSelf()); }
		public bool raiseElement(CanvasElement element) { return tsCanvas_raiseElement(self, element.getSelf()); }
		public bool lowerElement(CanvasElement element) { return tsCanvas_lowerElement(self, element.getSelf()); }
		public uint findElement(CanvasElement element) { return tsCanvas_findElement(self, element.getSelf()); }
		public bool isElement(CanvasElement element) { return tsCanvas_isElement(self, element.getSelf()); }
		public uint getNumElements() { return tsCanvas_getNumElements(self); }
		public CanvasElement getElement(uint index) { return new CanvasElement(tsCanvas_getElement_cu(self, index)); }
		public bool isFont(string name) { return tsCanvas_isFont(self, name); }
		public bool addFont(string name, Stream stream) { return tsCanvas_addFont_sSt(self, name, stream.getSelf()); }
		public bool addFont(string name, byte[] blob) { return tsCanvas_addFont_sbl(self, name, blob); }
		public void removeFont(string name) { tsCanvas_removeFont(self, name); }
		public Font getFont(string name) { return new Font(tsCanvas_getFont(self, name)); }
		public bool isTexture(string name) { return tsCanvas_isTexture(self, name); }
		public bool addTexture(string name, Stream stream) { return tsCanvas_addTexture_sSt(self, name, stream.getSelf()); }
		public bool addTexture(string name, Texture texture) { return tsCanvas_addTexture_sT(self, name, texture.getSelf()); }
		public bool addTexture(string name, byte[] blob) { return tsCanvas_addTexture_sbl(self, name, blob); }
		public void removeTexture(string name) { tsCanvas_removeTexture(self, name); }
		public Texture getTexture(string name) { return new Texture(tsCanvas_getTexture(self, name)); }
		public void setDepthMask(Pipeline.DepthMask mask) { tsCanvas_setDepthMask(self, mask); }
		public Pipeline.DepthMask getDepthMask() { return tsCanvas_getDepthMask(self); }
		public void setDepthFunc(Pipeline.DepthFunc func) { tsCanvas_setDepthFunc(self, func); }
		public Pipeline.DepthFunc getDepthFunc() { return tsCanvas_getDepthFunc(self); }
		public void draw(Command command, Target target) { tsCanvas_draw_CcT(self, command.getSelf(), target.getSelf()); }
		public void draw(Command command) { tsCanvas_draw_C(self, command.getSelf()); }
		public void setCreateCallback(CreateCallback func, IntPtr data = new IntPtr()) {
			Canvas.CreateCallback_ func_ = null;
			if(func != null) func_ = (IntPtr device_, IntPtr canvas_, uint scale_, IntPtr data_) => { return func(new Device(device_), new Canvas(canvas_), scale_, data_); };
			if(func_ != null) CreateCallback_75 = GCHandle.Alloc(func_);
			tsCanvas_setCreateCallback(self, Base.getFunc(func_), data);
		}
		public void setPipelineCallback(PipelineCallback func, IntPtr data = new IntPtr()) {
			Canvas.PipelineCallback_ func_ = null;
			if(func != null) func_ = (IntPtr pipeline_, IntPtr canvas_, IntPtr element_, IntPtr data_) => { return func(new Pipeline(pipeline_), new Canvas(canvas_), new CanvasElement(element_), data_); };
			if(func_ != null) PipelineCallback_77 = GCHandle.Alloc(func_);
			tsCanvas_setPipelineCallback(self, Base.getFunc(func_), data);
		}
		public void setBeginCallback(BeginCallback func, IntPtr data = new IntPtr()) {
			Canvas.BeginCallback_ func_ = null;
			if(func != null) func_ = (IntPtr command_, IntPtr canvas_, IntPtr data_) => { return func(new Command(command_), new Canvas(canvas_), data_); };
			if(func_ != null) BeginCallback_79 = GCHandle.Alloc(func_);
			tsCanvas_setBeginCallback(self, Base.getFunc(func_), data);
		}
		public void setDrawCallback(DrawCallback func, IntPtr data = new IntPtr()) {
			Canvas.DrawCallback_ func_ = null;
			if(func != null) func_ = (IntPtr command_, IntPtr canvas_, IntPtr data_) => { return func(new Command(command_), new Canvas(canvas_), data_); };
			if(func_ != null) DrawCallback_81 = GCHandle.Alloc(func_);
			tsCanvas_setDrawCallback(self, Base.getFunc(func_), data);
		}
		public uint getNumDrawPipelines() { return tsCanvas_getNumDrawPipelines(self); }
		public uint getNumDrawElements() { return tsCanvas_getNumDrawElements(self); }
		public uint getNumDrawCommands() { return tsCanvas_getNumDrawCommands(self); }
		public Rect getRect() { return tsCanvas_getRect(self); }
		private GCHandle CreateCallback_75;
		private GCHandle PipelineCallback_77;
		private GCHandle BeginCallback_79;
		private GCHandle DrawCallback_81;
		public override string ToString() { return "Tellusim.Canvas: Valid: " + tsCanvas_isValidPtr(self) + "; Owner: " + tsCanvas_isOwnerPtr(self) + "; Const: " + tsCanvas_isConstPtr(self) + "; Count: " + tsCanvas_getCountPtr(self) + "; Internal: 0x" + tsCanvas_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Canvas ptr) { return (ptr != null && tsCanvas_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_new();
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern void tsCanvas_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvas_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getScale(HandleRef self, HandleRef target, uint scale);
		[DllImport(Base.Import)] private static extern bool tsCanvas_create_cDFFuu(HandleRef self, HandleRef device, Format color, Format depth, uint multisample, uint scale);
		[DllImport(Base.Import)] private static extern bool tsCanvas_create_cDcTu(HandleRef self, HandleRef device, HandleRef target, uint scale);
		[DllImport(Base.Import)] private static extern void tsCanvas_setPipelineHash(HandleRef self, uint hash);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getPipelineHash(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsCanvas_getColorFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsCanvas_getDepthFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getMultisample(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setOrder(HandleRef self, int order);
		[DllImport(Base.Import)] private static extern int tsCanvas_getOrder(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setEnabled(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setViewport_cV(HandleRef self, in Viewport viewport);
		[DllImport(Base.Import)] private static extern void tsCanvas_setViewport_uu(HandleRef self, uint width, uint height);
		[DllImport(Base.Import)] private static extern void tsCanvas_setViewport_ff(HandleRef self, float width, float height);
		[DllImport(Base.Import)] private static extern Viewport tsCanvas_getViewport(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsCanvas_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsCanvas_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_clearColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setColor_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern void tsCanvas_setColor_ffff(HandleRef self, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern Color tsCanvas_getColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_clearScissor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setScissor(HandleRef self, in Rect scissor);
		[DllImport(Base.Import)] private static extern Rect tsCanvas_getScissor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_clearTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setTransform(HandleRef self, in Matrix4x4f transform);
		[DllImport(Base.Import)] private static extern Matrix4x4f tsCanvas_getTransform(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_setParent(HandleRef self, HandleRef parent);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_getParent_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_addChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsCanvas_removeChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsCanvas_raiseChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsCanvas_lowerChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern void tsCanvas_releaseChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_findChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getNumChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_getChild_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsCanvas_addElement(HandleRef self, HandleRef element);
		[DllImport(Base.Import)] private static extern bool tsCanvas_removeElement(HandleRef self, HandleRef element);
		[DllImport(Base.Import)] private static extern bool tsCanvas_raiseElement(HandleRef self, HandleRef element);
		[DllImport(Base.Import)] private static extern bool tsCanvas_lowerElement(HandleRef self, HandleRef element);
		[DllImport(Base.Import)] private static extern uint tsCanvas_findElement(HandleRef self, HandleRef element);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isElement(HandleRef self, HandleRef element);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getNumElements(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_getElement_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isFont(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsCanvas_addFont_sSt(HandleRef self, string name, HandleRef stream);
		[DllImport(Base.Import)] private static extern bool tsCanvas_addFont_sbl(HandleRef self, string name, byte[] blob);
		[DllImport(Base.Import)] private static extern void tsCanvas_removeFont(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_getFont(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsCanvas_isTexture(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern bool tsCanvas_addTexture_sSt(HandleRef self, string name, HandleRef stream);
		[DllImport(Base.Import)] private static extern bool tsCanvas_addTexture_sT(HandleRef self, string name, HandleRef texture);
		[DllImport(Base.Import)] private static extern bool tsCanvas_addTexture_sbl(HandleRef self, string name, byte[] blob);
		[DllImport(Base.Import)] private static extern void tsCanvas_removeTexture(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsCanvas_getTexture(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsCanvas_setDepthMask(HandleRef self, Pipeline.DepthMask mask);
		[DllImport(Base.Import)] private static extern Pipeline.DepthMask tsCanvas_getDepthMask(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_setDepthFunc(HandleRef self, Pipeline.DepthFunc func);
		[DllImport(Base.Import)] private static extern Pipeline.DepthFunc tsCanvas_getDepthFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCanvas_draw_CcT(HandleRef self, HandleRef command, HandleRef target);
		[DllImport(Base.Import)] private static extern void tsCanvas_draw_C(HandleRef self, HandleRef command);
		[DllImport(Base.Import)] private static extern void tsCanvas_setCreateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsCanvas_setPipelineCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsCanvas_setBeginCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsCanvas_setDrawCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getNumDrawPipelines(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getNumDrawElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCanvas_getNumDrawCommands(HandleRef self);
		[DllImport(Base.Import)] private static extern Rect tsCanvas_getRect(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Control
	public class Control {
		public enum Type : uint {
			Unknown = 0,
			Root,
			Text,
			Rect,
			Grid,
			Group,
			Panel,
			Dialog,
			Window,
			Check,
			Combo,
			Button,
			Slider,
			Scroll,
			Split,
			Area,
			Tree,
			Edit,
			NumTypes,
		}
		public enum State : uint {
			Unknown = 0,
			Normal,
			Focused,
			Pressed,
			Disabled,
			NumStates,
		}
		public enum Mesh : uint {
			Check = 0,
			Button,
			SliderLine,
			HScrollLine,
			VScrollLine,
			SliderHandle,
			HScrollHandle,
			VScrollHandle,
			Background,
			Selection,
			Border,
			Frame,
			NumMeshes,
		}
		public enum Align : uint {
			None = 0,
			Left = 1,
			Right = 2,
			Bottom = 4,
			Top = 8,
			CenterX = 16,
			CenterY = 32,
			ExpandX = 64,
			ExpandY = 128,
			Overlap = 256,
			Spacer = 512,
			Aspect = 1024,
			LeftBottom = 5,
			LeftTop = 9,
			RightBottom = 6,
			RightTop = 10,
			Center = 48,
			Expand = 192,
			NumAligns = 11,
		}
		public enum Button : uint {
			None = 0,
			Left = 1,
			Left2 = 2,
			Right = 4,
			Right2 = 8,
			Middle = 16,
			Middle2 = 32,
			NumButtons = 6,
		}
		public enum Axis : uint {
			Unknown = 0,
			X,
			Y,
			Z,
			W,
			NumAxes,
		}
		public enum Key : uint {
			None = 128,
			Tab,
			Backspace,
			Delete,
			Insert,
			Return,
			Prior,
			Next,
			End,
			Home,
			Up,
			Down,
			Left,
			Right,
			Shift,
			Ctrl,
			Alt,
			Cmd,
			NumKeys,
		}
		public Control() { self = new HandleRef(this, tsControl_new()); owner = true; }
		public Control(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControl_new_C(ref parent_)); owner = true;
		}
		public Control(in Control parent, float width, float height = 0.0f) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControl_new_Cff(ref parent_, width, height)); owner = true;
		}
		public Control(Control ptr) { self = new HandleRef(this, tsControl_copyPtr(ptr.getSelf())); owner = true; }
		public Control(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControl_isOwnerPtr(self); }
		public static Control Null() { return new Control(IntPtr.Zero); }
		~Control() { if(owner) tsControl_delete(self); }
		public bool equalPtr(Control ptr) { return tsControl_equalPtr(self, ptr.getSelf()); }
		public Control clonePtr() { return new Control(tsControl_clonePtr(self)); }
		public void clearPtr() { tsControl_clearPtr(self); }
		public void destroyPtr() { tsControl_destroyPtr(self); }
		public void acquirePtr() { tsControl_acquirePtr(self); }
		public void unacquirePtr() { tsControl_unacquirePtr(self); }
		public bool isValidPtr() { return tsControl_isValidPtr(self); }
		public bool isOwnerPtr() { return tsControl_isOwnerPtr(self); }
		public bool isConstPtr() { return tsControl_isConstPtr(self); }
		public uint getCountPtr() { return tsControl_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsControl_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public Type getType() { return tsControl_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsControl_getTypeName_CT(type)); }
		public string getTypeName() { return Base.getCString(tsControl_getTypeName_c(self)); }
		public bool isUnknown() { return tsControl_isUnknown(self); }
		public bool isRoot() { return tsControl_isRoot(self); }
		public bool isText() { return tsControl_isText(self); }
		public bool isRect() { return tsControl_isRect(self); }
		public bool isGrid() { return tsControl_isGrid(self); }
		public bool isGroup() { return tsControl_isGroup(self); }
		public bool isPanel() { return tsControl_isPanel(self); }
		public bool isDialog() { return tsControl_isDialog(self); }
		public bool isWindow() { return tsControl_isWindow(self); }
		public bool isCheck() { return tsControl_isCheck(self); }
		public bool isCombo() { return tsControl_isCombo(self); }
		public bool isButton() { return tsControl_isButton(self); }
		public bool isSlider() { return tsControl_isSlider(self); }
		public bool isScroll() { return tsControl_isScroll(self); }
		public bool isSplit() { return tsControl_isSplit(self); }
		public bool isArea() { return tsControl_isArea(self); }
		public bool isTree() { return tsControl_isTree(self); }
		public bool isEdit() { return tsControl_isEdit(self); }
		public void setAlign(Align align) { tsControl_setAlign(self, align); }
		public Align getAlign() { return tsControl_getAlign(self); }
		public bool hasAlign(Align align) { return tsControl_hasAlign(self, align); }
		public bool hasAligns(Align aligns) { return tsControl_hasAligns(self, aligns); }
		public bool isSpacer() { return tsControl_isSpacer(self); }
		public void setCreated(bool created) { tsControl_setCreated(self, created); }
		public bool isCreated() { return tsControl_isCreated(self); }
		public void setEnabled(bool enabled) { tsControl_setEnabled(self, enabled); }
		public bool isEnabled() { return tsControl_isEnabled(self); }
		public bool wasEnabled() { return tsControl_wasEnabled(self); }
		public bool wasUpdated() { return tsControl_wasUpdated(self); }
		public void setDisabled(bool disabled) { tsControl_setDisabled(self, disabled); }
		public bool isDisabled() { return tsControl_isDisabled(self); }
		public Canvas getCanvas() { return new Canvas(tsControl_getCanvas(self)); }
		public ControlRoot getRoot() { return new ControlRoot(tsControl_getRoot_c(self)); }
		public ControlPanel getPanel() { return new ControlPanel(tsControl_getPanel_c(self)); }
		public uint setParent(Control parent) { return tsControl_setParent(self, parent.getSelf()); }
		public Control getParent() { return new Control(tsControl_getParent_c(self)); }
		public bool isParentEnabled() { return tsControl_isParentEnabled(self); }
		public bool isParentDisabled() { return tsControl_isParentDisabled(self); }
		public uint addChild(Control child) { return tsControl_addChild(self, child.getSelf()); }
		public Control setChild(uint index, Control child) { return new Control(tsControl_setChild(self, index, child.getSelf())); }
		public bool raiseChild(Control child) { return tsControl_raiseChild(self, child.getSelf()); }
		public bool lowerChild(Control child) { return tsControl_lowerChild(self, child.getSelf()); }
		public bool removeChild(Control child) { return tsControl_removeChild(self, child.getSelf()); }
		public void releaseChildren() { tsControl_releaseChildren(self); }
		public uint findChild(Control child) { return tsControl_findChild(self, child.getSelf()); }
		public bool isChild(Control child, bool hierarchy = false) { return tsControl_isChild(self, child.getSelf(), hierarchy); }
		public uint getNumChildren() { return tsControl_getNumChildren(self); }
		public Control getChild(uint index) { return new Control(tsControl_getChild_cu(self, index)); }
		public void setSize(in Vector2f size) { tsControl_setSize_cV2(self, in size); }
		public void setSize(float width, float height) { tsControl_setSize_ff(self, width, height); }
		public Vector2f getSize() { return tsControl_getSize(self); }
		public float getWidth() { return tsControl_getWidth(self); }
		public float getHeight() { return tsControl_getHeight(self); }
		public void setPosition(in Vector3f position) { tsControl_setPosition_cV3(self, in position); }
		public void setPosition(float x, float y, float z = 0.0f) { tsControl_setPosition_fff(self, x, y, z); }
		public Vector3f getPosition() { return tsControl_getPosition(self); }
		public float getPositionX() { return tsControl_getPositionX(self); }
		public float getPositionY() { return tsControl_getPositionY(self); }
		public void setOffset(in Vector3f offset) { tsControl_setOffset_cV3(self, in offset); }
		public void setOffset(float x, float y, float z = 0.0f) { tsControl_setOffset_fff(self, x, y, z); }
		public Vector3f getOffset() { return tsControl_getOffset(self); }
		public float getOffsetX() { return tsControl_getOffsetX(self); }
		public float getOffsetY() { return tsControl_getOffsetY(self); }
		public void setMargin(float value) { tsControl_setMargin_f(self, value); }
		public void setMargin(float horizontal, float vertical) { tsControl_setMargin_ff(self, horizontal, vertical); }
		public void setMargin(float left, float right, float bottom, float top) { tsControl_setMargin_ffff(self, left, right, bottom, top); }
		public void setMargin(in Rect margin) { tsControl_setMargin_cR(self, in margin); }
		public Rect getMargin() { return tsControl_getMargin(self); }
		public Rect getRect() { return tsControl_getRect(self); }
		public State getState() { return tsControl_getState(self); }
		public override string ToString() { return "Tellusim.Control: Valid: " + tsControl_isValidPtr(self) + "; Owner: " + tsControl_isOwnerPtr(self) + "; Const: " + tsControl_isConstPtr(self) + "; Count: " + tsControl_getCountPtr(self) + "; Internal: 0x" + tsControl_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Control ptr) { return (ptr != null && tsControl_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControl_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControl_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_new_Cff(ref IntPtr parent, float width, float height);
		[DllImport(Base.Import)] private static extern void tsControl_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControl_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern Type tsControl_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getTypeName_CT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isUnknown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isRoot(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isText(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isRect(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isGrid(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isGroup(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isPanel(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isDialog(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isWindow(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isCheck(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isCombo(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isButton(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isSlider(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isScroll(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isSplit(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isArea(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isTree(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isEdit(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern Align tsControl_getAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_hasAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern bool tsControl_hasAligns(HandleRef self, Align aligns);
		[DllImport(Base.Import)] private static extern bool tsControl_isSpacer(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setCreated(HandleRef self, bool created);
		[DllImport(Base.Import)] private static extern bool tsControl_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setEnabled(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsControl_isEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_wasEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_wasUpdated(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setDisabled(HandleRef self, bool disabled);
		[DllImport(Base.Import)] private static extern bool tsControl_isDisabled(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getCanvas(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getRoot_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getPanel_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControl_setParent(HandleRef self, HandleRef parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getParent_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isParentEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControl_isParentDisabled(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControl_addChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_setChild(HandleRef self, uint index, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsControl_raiseChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsControl_lowerChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsControl_removeChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern void tsControl_releaseChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControl_findChild(HandleRef self, HandleRef child);
		[DllImport(Base.Import)] private static extern bool tsControl_isChild(HandleRef self, HandleRef child, bool hierarchy);
		[DllImport(Base.Import)] private static extern uint tsControl_getNumChildren(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControl_getChild_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsControl_setSize_cV2(HandleRef self, in Vector2f size);
		[DllImport(Base.Import)] private static extern void tsControl_setSize_ff(HandleRef self, float width, float height);
		[DllImport(Base.Import)] private static extern Vector2f tsControl_getSize(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControl_getWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControl_getHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setPosition_cV3(HandleRef self, in Vector3f position);
		[DllImport(Base.Import)] private static extern void tsControl_setPosition_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsControl_getPosition(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControl_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControl_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setOffset_cV3(HandleRef self, in Vector3f offset);
		[DllImport(Base.Import)] private static extern void tsControl_setOffset_fff(HandleRef self, float x, float y, float z);
		[DllImport(Base.Import)] private static extern Vector3f tsControl_getOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControl_getOffsetX(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControl_getOffsetY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControl_setMargin_f(HandleRef self, float value);
		[DllImport(Base.Import)] private static extern void tsControl_setMargin_ff(HandleRef self, float horizontal, float vertical);
		[DllImport(Base.Import)] private static extern void tsControl_setMargin_ffff(HandleRef self, float left, float right, float bottom, float top);
		[DllImport(Base.Import)] private static extern void tsControl_setMargin_cR(HandleRef self, in Rect margin);
		[DllImport(Base.Import)] private static extern Rect tsControl_getMargin(HandleRef self);
		[DllImport(Base.Import)] private static extern Rect tsControl_getRect(HandleRef self);
		[DllImport(Base.Import)] private static extern State tsControl_getState(HandleRef self);
		protected HandleRef self;
		protected bool owner;
	}
	
	// Tellusim::ControlRoot
	public sealed class ControlRoot : Control {
		public delegate void CopyCallback(ControlRoot a0, string text, IntPtr data_);
		public delegate void CopyCallback_(IntPtr a0, string text, IntPtr data_);
		public delegate string PasteCallback(ControlRoot a0, IntPtr data_);
		public delegate string PasteCallback_(IntPtr a0, IntPtr data_);
		public ControlRoot() { self = new HandleRef(this, tsControlRoot_new()); owner = true; }
		public ControlRoot(Canvas canvas, bool blob = false) { self = new HandleRef(this, tsControlRoot_new_Cb(canvas.getSelf(), blob)); owner = true; }
		public ControlRoot(ControlRoot ptr) { self = new HandleRef(this, tsControlRoot_copyPtr(ptr.getSelf())); owner = true; }
		public ControlRoot(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlRoot_isOwnerPtr(self); }
		public ControlRoot(Control ptr) { self = new HandleRef(this, tsControlRoot_castControlPtr(ptr.getSelf())); }
		public Control toControl() { return new Control(tsControlRoot_baseControlPtr(self)); }
		public static new ControlRoot Null() { return new ControlRoot(IntPtr.Zero); }
		public void setViewport(in Viewport viewport) { tsControlRoot_setViewport_cV(self, in viewport); }
		public void setViewport(uint width, uint height) { tsControlRoot_setViewport_uu(self, width, height); }
		public void setViewport(float width, float height) { tsControlRoot_setViewport_ff(self, width, height); }
		public Viewport getViewport() { return tsControlRoot_getViewport(self); }
		public string getFontName() { return Base.getString(tsControlRoot_getFontName(self)); }
		public void setFontName(string name) { tsControlRoot_setFontName_s(self, name); }
		public void setFontName(String name) { tsControlRoot_setFontName_cS(self, name.getSelf()); }
		public bool setFontBlob(byte[] blob, string name = "") { return tsControlRoot_setFontBlob(self, blob, name); }
		public bool setFontSize(uint size, bool update = false) { return tsControlRoot_setFontSize(self, size, update); }
		public uint getFontSize() { return tsControlRoot_getFontSize(self); }
		public bool setFontScale(uint scale, bool update = false) { return tsControlRoot_setFontScale(self, scale, update); }
		public uint getFontScale() { return tsControlRoot_getFontScale(self); }
		public bool setFontStyle(in FontStyle style, bool update = false) { return tsControlRoot_setFontStyle(self, in style, update); }
		public FontStyle getFontStyle() { return tsControlRoot_getFontStyle_c(self); }
		public string getTextureName() { return Base.getString(tsControlRoot_getTextureName(self)); }
		public bool setTextureName(string name, uint width = 0, uint height = 0, float border = 0.0f) { return tsControlRoot_setTextureName_suuf(self, name, width, height, border); }
		public bool setTextureName(String name, uint width = 0, uint height = 0, float border = 0.0f) { return tsControlRoot_setTextureName_cSuuf(self, name.getSelf(), width, height, border); }
		public bool setTextureBlob(byte[] blob, string name = "", uint width = 0, uint height = 0, float border = 0.0f) { return tsControlRoot_setTextureBlob(self, blob, name, width, height, border); }
		public float getTextureWidth() { return tsControlRoot_getTextureWidth(self); }
		public float getTextureHeight() { return tsControlRoot_getTextureHeight(self); }
		public void setTextColor(Type type, State state, in Color color) { tsControlRoot_setTextColor(self, type, state, in color); }
		public void setTextOffset(Type type, State state, in Vector3f offset) { tsControlRoot_setTextOffset(self, type, state, in offset); }
		public Color getTextColor(Type type, State state) { return tsControlRoot_getTextColor(self, type, state); }
		public Vector3f getTextOffset(Type type, State state) { return tsControlRoot_getTextOffset(self, type, state); }
		public void setMeshColor(Mesh mesh, State state, in Color color) { tsControlRoot_setMeshColor(self, mesh, state, in color); }
		public void setMeshRegion(Mesh mesh, in Rect grid, in Rect region, in Vector2f border) { tsControlRoot_setMeshRegion(self, mesh, in grid, in region, in border); }
		public void setMeshRegions(Mesh mesh, in Rect grid, in Rect regions, in Vector2f border) { tsControlRoot_setMeshRegions(self, mesh, in grid, in regions, in border); }
		public uint getMeshColor(Mesh mesh, State state) { return tsControlRoot_getMeshColor(self, mesh, state); }
		public Rect getMeshGrid(Mesh mesh) { return tsControlRoot_getMeshGrid(self, mesh); }
		public Rect getMeshMargin(Mesh mesh) { return tsControlRoot_getMeshMargin(self, mesh); }
		public Rect getMeshRegion(Mesh mesh, State state) { return tsControlRoot_getMeshRegion(self, mesh, state); }
		public void setGroupRadius(float radius) { tsControlRoot_setGroupRadius(self, radius); }
		public void setGroupColor(in Color color) { tsControlRoot_setGroupColor(self, in color); }
		public float getGroupRadius() { return tsControlRoot_getGroupRadius(self); }
		public Color getGroupColor() { return tsControlRoot_getGroupColor(self); }
		public void setPanelRadius(float radius) { tsControlRoot_setPanelRadius(self, radius); }
		public void setPanelColor(in Color color) { tsControlRoot_setPanelColor(self, in color); }
		public float getPanelRadius() { return tsControlRoot_getPanelRadius(self); }
		public Color getPanelColor() { return tsControlRoot_getPanelColor(self); }
		public void setCheckedColor(in Color color) { tsControlRoot_setCheckedColor(self, in color); }
		public Color getCheckedColor() { return tsControlRoot_getCheckedColor(self); }
		public void setSplitSize(float size) { tsControlRoot_setSplitSize(self, size); }
		public float getSplitSize() { return tsControlRoot_getSplitSize(self); }
		public void setMouse(int x, int y, Button buttons) { tsControlRoot_setMouse_iiCB(self, x, y, buttons); }
		public void setMouse(float x, float y, Button buttons) { tsControlRoot_setMouse_ffCB(self, x, y, buttons); }
		public Vector2f getMouse() { return tsControlRoot_getMouse(self); }
		public Button getMouseButtons() { return tsControlRoot_getMouseButtons(self); }
		public float getMouseX() { return tsControlRoot_getMouseX(self); }
		public float getMouseY() { return tsControlRoot_getMouseY(self); }
		public void setMouseOffset(in Vector2f offset) { tsControlRoot_setMouseOffset(self, in offset); }
		public Vector2f getMouseOffset() { return tsControlRoot_getMouseOffset(self); }
		public void setMouseAxis(Axis axis, float delta) { tsControlRoot_setMouseAxis(self, axis, delta); }
		public void setMouseAlign(Align align, bool clear = true) { tsControlRoot_setMouseAlign(self, align, clear); }
		public Align getMouseAlign() { return tsControlRoot_getMouseAlign(self); }
		public bool hasMouseAlign(Align align) { return tsControlRoot_hasMouseAlign(self, align); }
		public bool hasMouseAligns(Align aligns) { return tsControlRoot_hasMouseAligns(self, aligns); }
		public bool setKeyboardKey(uint key, uint code, bool value) { return tsControlRoot_setKeyboardKey(self, key, code, value); }
		public bool getKeyboardKey(uint key, bool clear = false) { return tsControlRoot_getKeyboardKey(self, key, clear); }
		public void clearCurrentControl() { tsControlRoot_clearCurrentControl(self); }
		public void setCurrentControl(Control control, bool grab = false) { tsControlRoot_setCurrentControl(self, control.getSelf(), grab); }
		public Control getCurrentControl() { return new Control(tsControlRoot_getCurrentControl(self)); }
		public bool isCurrentControl() { return tsControlRoot_isCurrentControl(self); }
		public bool getControlGrab() { return tsControlRoot_getControlGrab(self); }
		public void clearFocusedControl() { tsControlRoot_clearFocusedControl(self); }
		public void setFocusedControl(Control control) { tsControlRoot_setFocusedControl(self, control.getSelf()); }
		public Control getFocusedControl() { return new Control(tsControlRoot_getFocusedControl(self)); }
		public bool isFocusedControl() { return tsControlRoot_isFocusedControl(self); }
		public void clearMouseControl() { tsControlRoot_clearMouseControl(self); }
		public void setMouseControl(Control control) { tsControlRoot_setMouseControl(self, control.getSelf()); }
		public Control getMouseControl() { return new Control(tsControlRoot_getMouseControl(self)); }
		public bool isMouseControl() { return tsControlRoot_isMouseControl(self); }
		public void clearInputControl() { tsControlRoot_clearInputControl(self); }
		public void setInputControl(Control control) { tsControlRoot_setInputControl(self, control.getSelf()); }
		public Control getInputControl() { return new Control(tsControlRoot_getInputControl(self)); }
		public bool isInputControl() { return tsControlRoot_isInputControl(self); }
		public void clearModalControl() { tsControlRoot_clearModalControl(self); }
		public void setModalControl(Control control, bool disabled = true) { tsControlRoot_setModalControl(self, control.getSelf(), disabled); }
		public Control getModalControl() { return new Control(tsControlRoot_getModalControl(self)); }
		public bool isModalDisabled() { return tsControlRoot_isModalDisabled(self); }
		public bool isModalControl() { return tsControlRoot_isModalControl(self); }
		public void setOverlayOrder(int order) { tsControlRoot_setOverlayOrder(self, order); }
		public int getOverlayOrder() { return tsControlRoot_getOverlayOrder(self); }
		public bool update(uint scale = 0, int order = 0) { return tsControlRoot_update(self, scale, order); }
		public void setCopyText(string text) { tsControlRoot_setCopyText_s(self, text); }
		public void setCopyText(String text) { tsControlRoot_setCopyText_cS(self, text.getSelf()); }
		public string getPasteText() { return Base.getString(tsControlRoot_getPasteText(self)); }
		public void setCopyCallback(CopyCallback func, IntPtr data = new IntPtr()) {
			ControlRoot.CopyCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, string text_, IntPtr data_) => { func(new ControlRoot(a0_), text_, data_); };
			if(func_ != null) CopyCallback_89 = GCHandle.Alloc(func_);
			tsControlRoot_setCopyCallback(self, Base.getFunc(func_), data);
		}
		public void setPasteCallback(PasteCallback func, IntPtr data = new IntPtr()) {
			ControlRoot.PasteCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { return func(new ControlRoot(a0_), data_); };
			if(func_ != null) PasteCallback_91 = GCHandle.Alloc(func_);
			tsControlRoot_setPasteCallback(self, Base.getFunc(func_), data);
		}
		private GCHandle CopyCallback_89;
		private GCHandle PasteCallback_91;
		public override string ToString() { return "Tellusim.ControlRoot: Valid: " + tsControlRoot_isValidPtr(self) + "; Owner: " + tsControlRoot_isOwnerPtr(self) + "; Const: " + tsControlRoot_isConstPtr(self) + "; Count: " + tsControlRoot_getCountPtr(self) + "; Internal: 0x" + tsControlRoot_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlRoot ptr) { return (ptr != null && tsControlRoot_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_new_Cb(HandleRef canvas, bool blob);
		[DllImport(Base.Import)] private static extern void tsControlRoot_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlRoot_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_equalControlPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_castControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_baseControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setViewport_cV(HandleRef self, in Viewport viewport);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setViewport_uu(HandleRef self, uint width, uint height);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setViewport_ff(HandleRef self, float width, float height);
		[DllImport(Base.Import)] private static extern Viewport tsControlRoot_getViewport(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getFontName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setFontName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setFontName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setFontBlob(HandleRef self, byte[] blob, string name);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setFontSize(HandleRef self, uint size, bool update);
		[DllImport(Base.Import)] private static extern uint tsControlRoot_getFontSize(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setFontScale(HandleRef self, uint scale, bool update);
		[DllImport(Base.Import)] private static extern uint tsControlRoot_getFontScale(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setFontStyle(HandleRef self, in FontStyle style, bool update);
		[DllImport(Base.Import)] private static extern FontStyle tsControlRoot_getFontStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getTextureName(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setTextureName_suuf(HandleRef self, string name, uint width, uint height, float border);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setTextureName_cSuuf(HandleRef self, HandleRef name, uint width, uint height, float border);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setTextureBlob(HandleRef self, byte[] blob, string name, uint width, uint height, float border);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getTextureWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getTextureHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setTextColor(HandleRef self, Type type, State state, in Color color);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setTextOffset(HandleRef self, Type type, State state, in Vector3f offset);
		[DllImport(Base.Import)] private static extern Color tsControlRoot_getTextColor(HandleRef self, Type type, State state);
		[DllImport(Base.Import)] private static extern Vector3f tsControlRoot_getTextOffset(HandleRef self, Type type, State state);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMeshColor(HandleRef self, Mesh mesh, State state, in Color color);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMeshRegion(HandleRef self, Mesh mesh, in Rect grid, in Rect region, in Vector2f border);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMeshRegions(HandleRef self, Mesh mesh, in Rect grid, in Rect regions, in Vector2f border);
		[DllImport(Base.Import)] private static extern uint tsControlRoot_getMeshColor(HandleRef self, Mesh mesh, State state);
		[DllImport(Base.Import)] private static extern Rect tsControlRoot_getMeshGrid(HandleRef self, Mesh mesh);
		[DllImport(Base.Import)] private static extern Rect tsControlRoot_getMeshMargin(HandleRef self, Mesh mesh);
		[DllImport(Base.Import)] private static extern Rect tsControlRoot_getMeshRegion(HandleRef self, Mesh mesh, State state);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setGroupRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setGroupColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getGroupRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern Color tsControlRoot_getGroupColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setPanelRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setPanelColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getPanelRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern Color tsControlRoot_getPanelColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setCheckedColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlRoot_getCheckedColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setSplitSize(HandleRef self, float size);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getSplitSize(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMouse_iiCB(HandleRef self, int x, int y, Button buttons);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMouse_ffCB(HandleRef self, float x, float y, Button buttons);
		[DllImport(Base.Import)] private static extern Vector2f tsControlRoot_getMouse(HandleRef self);
		[DllImport(Base.Import)] private static extern Button tsControlRoot_getMouseButtons(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getMouseX(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControlRoot_getMouseY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMouseOffset(HandleRef self, in Vector2f offset);
		[DllImport(Base.Import)] private static extern Vector2f tsControlRoot_getMouseOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMouseAxis(HandleRef self, Axis axis, float delta);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMouseAlign(HandleRef self, Align align, bool clear);
		[DllImport(Base.Import)] private static extern Align tsControlRoot_getMouseAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_hasMouseAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_hasMouseAligns(HandleRef self, Align aligns);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_setKeyboardKey(HandleRef self, uint key, uint code, bool value);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_getKeyboardKey(HandleRef self, uint key, bool clear);
		[DllImport(Base.Import)] private static extern void tsControlRoot_clearCurrentControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setCurrentControl(HandleRef self, HandleRef control, bool grab);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getCurrentControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isCurrentControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_getControlGrab(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_clearFocusedControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setFocusedControl(HandleRef self, HandleRef control);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getFocusedControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isFocusedControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_clearMouseControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setMouseControl(HandleRef self, HandleRef control);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getMouseControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isMouseControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_clearInputControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setInputControl(HandleRef self, HandleRef control);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getInputControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isInputControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_clearModalControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setModalControl(HandleRef self, HandleRef control, bool disabled);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getModalControl(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isModalDisabled(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_isModalControl(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setOverlayOrder(HandleRef self, int order);
		[DllImport(Base.Import)] private static extern int tsControlRoot_getOverlayOrder(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRoot_update(HandleRef self, uint scale, int order);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setCopyText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setCopyText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRoot_getPasteText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setCopyCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlRoot_setPasteCallback(HandleRef self, IntPtr func, IntPtr data_);
	}
	
	// Tellusim::ControlText
	public class ControlText : Control {
		public ControlText() { self = new HandleRef(this, tsControlText_new()); owner = true; }
		public ControlText(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlText_new_C(ref parent_)); owner = true;
		}
		public ControlText(in Control parent, string text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlText_new_Cs(ref parent_, text)); owner = true;
		}
		public ControlText(in Control parent, String text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlText_new_CcS(ref parent_, text.getSelf())); owner = true;
		}
		public ControlText(ControlText ptr) { self = new HandleRef(this, tsControlText_copyPtr(ptr.getSelf())); owner = true; }
		public ControlText(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlText_isOwnerPtr(self); }
		public ControlText(Control ptr) { self = new HandleRef(this, tsControlText_castControlPtr(ptr.getSelf())); }
		public Control toControl() { return new Control(tsControlText_baseControlPtr(self)); }
		public static new ControlText Null() { return new ControlText(IntPtr.Zero); }
		public void setMode(CanvasElement.Mode mode) { tsControlText_setMode(self, mode); }
		public CanvasElement.Mode getMode() { return tsControlText_getMode(self); }
		public void setPipeline(Pipeline pipeline) { tsControlText_setPipeline_P(self, pipeline.getSelf()); }
		public void setPipeline(Pipeline pipeline, CanvasElement.DrawCallback func, IntPtr data = new IntPtr()) {
			CanvasElement.DrawCallback_ func_ = null;
			if(func != null) func_ = (IntPtr command_, IntPtr element_, IntPtr data_) => { return func(new Command(command_), new CanvasElement(element_), data_); };
			if(func_ != null) DrawCallback_7 = GCHandle.Alloc(func_);
			tsControlText_setPipeline_PcCEDC(self, pipeline.getSelf(), Base.getFunc(func_), data);
		}
		public Pipeline getPipeline() { return new Pipeline(tsControlText_getPipeline(self)); }
		public void setColor(in Color color) { tsControlText_setColor_cC(self, in color); }
		public void setColor(float r, float g, float b, float a) { tsControlText_setColor_ffff(self, r, g, b, a); }
		public Color getColor() { return tsControlText_getColor(self); }
		public void setFilter(Sampler.Filter filter) { tsControlText_setFilter(self, filter); }
		public Sampler.Filter getFilter() { return tsControlText_getFilter(self); }
		public void setAnisotropy(uint anisotropy) { tsControlText_setAnisotropy(self, anisotropy); }
		public uint getAnisotropy() { return tsControlText_getAnisotropy(self); }
		public void setBlend(Pipeline.BlendOp op, Pipeline.BlendFunc src, Pipeline.BlendFunc dest) { tsControlText_setBlend(self, op, src, dest); }
		public Pipeline.BlendOp getBlendOp() { return tsControlText_getBlendOp(self); }
		public Pipeline.BlendFunc getBlendSrcFunc() { return tsControlText_getBlendSrcFunc(self); }
		public Pipeline.BlendFunc getBlendDestFunc() { return tsControlText_getBlendDestFunc(self); }
		public void setFontName(string name) { tsControlText_setFontName_s(self, name); }
		public void setFontName(String name) { tsControlText_setFontName_cS(self, name.getSelf()); }
		public string getFontName() { return Base.getString(tsControlText_getFontName(self)); }
		public void setFontColor(in Color color) { tsControlText_setFontColor(self, in color); }
		public Color getFontColor() { return tsControlText_getFontColor(self); }
		public bool setFontSize(uint size) { return tsControlText_setFontSize(self, size); }
		public uint getFontSize() { return tsControlText_getFontSize(self); }
		public bool setFontStyle(in FontStyle style) { return tsControlText_setFontStyle(self, in style); }
		public FontStyle getFontStyleConst() { return tsControlText_getFontStyleConst(self); }
		public FontStyle getFontStyle() { return tsControlText_getFontStyle_c(self); }
		public void setFontAlign(Align align) { tsControlText_setFontAlign(self, align); }
		public Align getFontAlign() { return tsControlText_getFontAlign(self); }
		public bool hasFontAlign(Align align) { return tsControlText_hasFontAlign(self, align); }
		public bool hasFontAligns(Align aligns) { return tsControlText_hasFontAligns(self, aligns); }
		public void setText(string text) { tsControlText_setText_s(self, text); }
		public void setText(String text) { tsControlText_setText_cS(self, text.getSelf()); }
		public string getText() { return Base.getString(tsControlText_getText(self)); }
		public CanvasText getCanvasText() { return new CanvasText(tsControlText_getCanvasText(self)); }
		private GCHandle DrawCallback_7;
		public override string ToString() { return "Tellusim.ControlText: Valid: " + tsControlText_isValidPtr(self) + "; Owner: " + tsControlText_isOwnerPtr(self) + "; Const: " + tsControlText_isConstPtr(self) + "; Count: " + tsControlText_getCountPtr(self) + "; Internal: 0x" + tsControlText_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlText ptr) { return (ptr != null && tsControlText_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_new_Cs(ref IntPtr parent, string text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_new_CcS(ref IntPtr parent, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlText_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlText_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_equalControlPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_castControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_baseControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setMode(HandleRef self, CanvasElement.Mode mode);
		[DllImport(Base.Import)] private static extern CanvasElement.Mode tsControlText_getMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setPipeline_P(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern void tsControlText_setPipeline_PcCEDC(HandleRef self, HandleRef pipeline, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_getPipeline(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setColor_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern void tsControlText_setColor_ffff(HandleRef self, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern Color tsControlText_getColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setFilter(HandleRef self, Sampler.Filter filter);
		[DllImport(Base.Import)] private static extern Sampler.Filter tsControlText_getFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setAnisotropy(HandleRef self, uint anisotropy);
		[DllImport(Base.Import)] private static extern uint tsControlText_getAnisotropy(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setBlend(HandleRef self, Pipeline.BlendOp op, Pipeline.BlendFunc src, Pipeline.BlendFunc dest);
		[DllImport(Base.Import)] private static extern Pipeline.BlendOp tsControlText_getBlendOp(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.BlendFunc tsControlText_getBlendSrcFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.BlendFunc tsControlText_getBlendDestFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setFontName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsControlText_setFontName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_getFontName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setFontColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlText_getFontColor(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_setFontSize(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern uint tsControlText_getFontSize(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_setFontStyle(HandleRef self, in FontStyle style);
		[DllImport(Base.Import)] private static extern FontStyle tsControlText_getFontStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern FontStyle tsControlText_getFontStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlText_setFontAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern Align tsControlText_getFontAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlText_hasFontAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern bool tsControlText_hasFontAligns(HandleRef self, Align aligns);
		[DllImport(Base.Import)] private static extern void tsControlText_setText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlText_setText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_getText(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlText_getCanvasText(HandleRef self);
	}
	
	// Tellusim::ControlRect
	public class ControlRect : Control {
		public delegate bool InsideCallback(ControlRect a0, float x, float y, IntPtr data_);
		public delegate bool InsideCallback_(IntPtr a0, float x, float y, IntPtr data_);
		public delegate void PressedCallback(ControlRect a0, float x, float y, IntPtr data_);
		public delegate void PressedCallback_(IntPtr a0, float x, float y, IntPtr data_);
		public delegate void ReleasedCallback(ControlRect a0, float x, float y, IntPtr data_);
		public delegate void ReleasedCallback_(IntPtr a0, float x, float y, IntPtr data_);
		public delegate void ClickedCallback(ControlRect a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public ControlRect() { self = new HandleRef(this, tsControlRect_new()); owner = true; }
		public ControlRect(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlRect_new_C(ref parent_)); owner = true;
		}
		public ControlRect(in Control parent, Texture texture) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlRect_new_CT(ref parent_, texture.getSelf())); owner = true;
		}
		public ControlRect(in Control parent, string name) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlRect_new_Cs(ref parent_, name)); owner = true;
		}
		public ControlRect(in Control parent, CanvasElement.Mode mode) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlRect_new_CCEM(ref parent_, mode)); owner = true;
		}
		public ControlRect(ControlRect ptr) { self = new HandleRef(this, tsControlRect_copyPtr(ptr.getSelf())); owner = true; }
		public ControlRect(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlRect_isOwnerPtr(self); }
		public ControlRect(Control ptr) { self = new HandleRef(this, tsControlRect_castControlPtr(ptr.getSelf())); }
		public Control toControl() { return new Control(tsControlRect_baseControlPtr(self)); }
		public static new ControlRect Null() { return new ControlRect(IntPtr.Zero); }
		public void setCallback(bool callback) { tsControlRect_setCallback(self, callback); }
		public bool getCallback() { return tsControlRect_getCallback(self); }
		public void setFullscreen(bool fullscreen) { tsControlRect_setFullscreen(self, fullscreen); }
		public bool isFullscreen() { return tsControlRect_isFullscreen(self); }
		public void setMode(CanvasElement.Mode mode) { tsControlRect_setMode(self, mode); }
		public CanvasElement.Mode getMode() { return tsControlRect_getMode(self); }
		public void setPipeline(Pipeline pipeline) { tsControlRect_setPipeline_P(self, pipeline.getSelf()); }
		public void setPipeline(Pipeline pipeline, CanvasElement.DrawCallback func, IntPtr data = new IntPtr()) {
			CanvasElement.DrawCallback_ func_ = null;
			if(func != null) func_ = (IntPtr command_, IntPtr element_, IntPtr data_) => { return func(new Command(command_), new CanvasElement(element_), data_); };
			if(func_ != null) DrawCallback_12 = GCHandle.Alloc(func_);
			tsControlRect_setPipeline_PcCEDC(self, pipeline.getSelf(), Base.getFunc(func_), data);
		}
		public Pipeline getPipeline() { return new Pipeline(tsControlRect_getPipeline(self)); }
		public void setRadius(float radius) { tsControlRect_setRadius(self, radius); }
		public float getRadius() { return tsControlRect_getRadius(self); }
		public void setColor(in Color color) { tsControlRect_setColor_cC(self, in color); }
		public void setColor(float r, float g, float b, float a) { tsControlRect_setColor_ffff(self, r, g, b, a); }
		public Color getColor() { return tsControlRect_getColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsControlRect_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsControlRect_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsControlRect_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsControlRect_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsControlRect_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsControlRect_getGradientStyle_c(self); }
		public void setMipmap(float mipmap) { tsControlRect_setMipmap(self, mipmap); }
		public float getMipmap() { return tsControlRect_getMipmap(self); }
		public void setFilter(Sampler.Filter filter) { tsControlRect_setFilter(self, filter); }
		public Sampler.Filter getFilter() { return tsControlRect_getFilter(self); }
		public void setAnisotropy(uint anisotropy) { tsControlRect_setAnisotropy(self, anisotropy); }
		public uint getAnisotropy() { return tsControlRect_getAnisotropy(self); }
		public void setWrapMode(Sampler.WrapMode mode) { tsControlRect_setWrapMode(self, mode); }
		public Sampler.WrapMode getWrapMode() { return tsControlRect_getWrapMode(self); }
		public void setBlend(Pipeline.BlendOp op, Pipeline.BlendFunc src, Pipeline.BlendFunc dest) { tsControlRect_setBlend(self, op, src, dest); }
		public Pipeline.BlendOp getBlendOp() { return tsControlRect_getBlendOp(self); }
		public Pipeline.BlendFunc getBlendSrcFunc() { return tsControlRect_getBlendSrcFunc(self); }
		public Pipeline.BlendFunc getBlendDestFunc() { return tsControlRect_getBlendDestFunc(self); }
		public void setTexture(Texture texture, bool linear = false) { tsControlRect_setTexture(self, texture.getSelf(), linear); }
		public Texture getTexture() { return new Texture(tsControlRect_getTexture(self)); }
		public bool getTextureLinear() { return tsControlRect_getTextureLinear(self); }
		public void setTextureName(string name) { tsControlRect_setTextureName_s(self, name); }
		public void setTextureName(String name) { tsControlRect_setTextureName_cS(self, name.getSelf()); }
		public string getTextureName() { return Base.getString(tsControlRect_getTextureName(self)); }
		public void setTextureScale(float scale_x, float scale_y) { tsControlRect_setTextureScale(self, scale_x, scale_y); }
		public float getTextureScaleX() { return tsControlRect_getTextureScaleX(self); }
		public float getTextureScaleY() { return tsControlRect_getTextureScaleY(self); }
		public void setTextureFlip(bool flip_x, bool flip_y) { tsControlRect_setTextureFlip(self, flip_x, flip_y); }
		public bool getTextureFlipX() { return tsControlRect_getTextureFlipX(self); }
		public bool getTextureFlipY() { return tsControlRect_getTextureFlipY(self); }
		public void setTextureProj(bool projection) { tsControlRect_setTextureProj(self, projection); }
		public bool getTextureProj() { return tsControlRect_getTextureProj(self); }
		public void setTexCoord(in Rect texcoord) { tsControlRect_setTexCoord_cR(self, in texcoord); }
		public void setTexCoord(float left, float right, float bottom, float top) { tsControlRect_setTexCoord_ffff(self, left, right, bottom, top); }
		public Rect getTexCoord() { return tsControlRect_getTexCoord(self); }
		public void setInsideCallback(InsideCallback func, IntPtr data = new IntPtr()) {
			ControlRect.InsideCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, float x_, float y_, IntPtr data_) => { return func(new ControlRect(a0_), x_, y_, data_); };
			if(func_ != null) InsideCallback_56 = GCHandle.Alloc(func_);
			tsControlRect_setInsideCallback(self, Base.getFunc(func_), data);
		}
		public void setPressedCallback(PressedCallback func, IntPtr data = new IntPtr()) {
			ControlRect.PressedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, float x_, float y_, IntPtr data_) => { func(new ControlRect(a0_), x_, y_, data_); };
			if(func_ != null) PressedCallback_58 = GCHandle.Alloc(func_);
			tsControlRect_setPressedCallback(self, Base.getFunc(func_), data);
		}
		public void setReleasedCallback(ReleasedCallback func, IntPtr data = new IntPtr()) {
			ControlRect.ReleasedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, float x_, float y_, IntPtr data_) => { func(new ControlRect(a0_), x_, y_, data_); };
			if(func_ != null) ReleasedCallback_60 = GCHandle.Alloc(func_);
			tsControlRect_setReleasedCallback(self, Base.getFunc(func_), data);
		}
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlRect.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlRect(a0_), data_); };
			if(func_ != null) ClickedCallback_62 = GCHandle.Alloc(func_);
			tsControlRect_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public void setClicked2Callback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlRect.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlRect(a0_), data_); };
			if(func_ != null) ClickedCallback_63 = GCHandle.Alloc(func_);
			tsControlRect_setClicked2Callback(self, Base.getFunc(func_), data);
		}
		public void setClickedRightCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlRect.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlRect(a0_), data_); };
			if(func_ != null) ClickedCallback_64 = GCHandle.Alloc(func_);
			tsControlRect_setClickedRightCallback(self, Base.getFunc(func_), data);
		}
		public CanvasRect getCanvasRect() { return new CanvasRect(tsControlRect_getCanvasRect(self)); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlRect_getCanvasMesh(self)); }
		private GCHandle DrawCallback_12;
		private GCHandle InsideCallback_56;
		private GCHandle PressedCallback_58;
		private GCHandle ReleasedCallback_60;
		private GCHandle ClickedCallback_62;
		private GCHandle ClickedCallback_63;
		private GCHandle ClickedCallback_64;
		public override string ToString() { return "Tellusim.ControlRect: Valid: " + tsControlRect_isValidPtr(self) + "; Owner: " + tsControlRect_isOwnerPtr(self) + "; Const: " + tsControlRect_isConstPtr(self) + "; Count: " + tsControlRect_getCountPtr(self) + "; Internal: 0x" + tsControlRect_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlRect ptr) { return (ptr != null && tsControlRect_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_new_CT(ref IntPtr parent, HandleRef texture);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_new_Cs(ref IntPtr parent, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_new_CCEM(ref IntPtr parent, CanvasElement.Mode mode);
		[DllImport(Base.Import)] private static extern void tsControlRect_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlRect_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_equalControlPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_castControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_baseControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setCallback(HandleRef self, bool callback);
		[DllImport(Base.Import)] private static extern bool tsControlRect_getCallback(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setFullscreen(HandleRef self, bool fullscreen);
		[DllImport(Base.Import)] private static extern bool tsControlRect_isFullscreen(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setMode(HandleRef self, CanvasElement.Mode mode);
		[DllImport(Base.Import)] private static extern CanvasElement.Mode tsControlRect_getMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setPipeline_P(HandleRef self, HandleRef pipeline);
		[DllImport(Base.Import)] private static extern void tsControlRect_setPipeline_PcCEDC(HandleRef self, HandleRef pipeline, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_getPipeline(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern float tsControlRect_getRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setColor_cC(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern void tsControlRect_setColor_ffff(HandleRef self, float r, float g, float b, float a);
		[DllImport(Base.Import)] private static extern Color tsControlRect_getColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsControlRect_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsControlRect_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsControlRect_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsControlRect_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setMipmap(HandleRef self, float mipmap);
		[DllImport(Base.Import)] private static extern float tsControlRect_getMipmap(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setFilter(HandleRef self, Sampler.Filter filter);
		[DllImport(Base.Import)] private static extern Sampler.Filter tsControlRect_getFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setAnisotropy(HandleRef self, uint anisotropy);
		[DllImport(Base.Import)] private static extern uint tsControlRect_getAnisotropy(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setWrapMode(HandleRef self, Sampler.WrapMode mode);
		[DllImport(Base.Import)] private static extern Sampler.WrapMode tsControlRect_getWrapMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setBlend(HandleRef self, Pipeline.BlendOp op, Pipeline.BlendFunc src, Pipeline.BlendFunc dest);
		[DllImport(Base.Import)] private static extern Pipeline.BlendOp tsControlRect_getBlendOp(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.BlendFunc tsControlRect_getBlendSrcFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern Pipeline.BlendFunc tsControlRect_getBlendDestFunc(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTexture(HandleRef self, HandleRef texture, bool linear);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_getTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_getTextureLinear(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTextureName_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTextureName_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_getTextureName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTextureScale(HandleRef self, float scale_x, float scale_y);
		[DllImport(Base.Import)] private static extern float tsControlRect_getTextureScaleX(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControlRect_getTextureScaleY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTextureFlip(HandleRef self, bool flip_x, bool flip_y);
		[DllImport(Base.Import)] private static extern bool tsControlRect_getTextureFlipX(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlRect_getTextureFlipY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTextureProj(HandleRef self, bool projection);
		[DllImport(Base.Import)] private static extern bool tsControlRect_getTextureProj(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTexCoord_cR(HandleRef self, in Rect texcoord);
		[DllImport(Base.Import)] private static extern void tsControlRect_setTexCoord_ffff(HandleRef self, float left, float right, float bottom, float top);
		[DllImport(Base.Import)] private static extern Rect tsControlRect_getTexCoord(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlRect_setInsideCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlRect_setPressedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlRect_setReleasedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlRect_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlRect_setClicked2Callback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlRect_setClickedRightCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_getCanvasRect(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlRect_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::ControlGrid
	public sealed class ControlGrid : Control {
		public ControlGrid() { self = new HandleRef(this, tsControlGrid_new()); owner = true; }
		public ControlGrid(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGrid_new_C(ref parent_)); owner = true;
		}
		public ControlGrid(in Control parent, uint columns) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGrid_new_Cu(ref parent_, columns)); owner = true;
		}
		public ControlGrid(in Control parent, uint columns, float x, float y = 0.0f) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGrid_new_Cuff(ref parent_, columns, x, y)); owner = true;
		}
		public ControlGrid(ControlGrid ptr) { self = new HandleRef(this, tsControlGrid_copyPtr(ptr.getSelf())); owner = true; }
		public ControlGrid(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlGrid_isOwnerPtr(self); }
		public ControlGrid(Control ptr) { self = new HandleRef(this, tsControlGrid_castControlPtr(ptr.getSelf())); }
		public Control toControl() { return new Control(tsControlGrid_baseControlPtr(self)); }
		public static new ControlGrid Null() { return new ControlGrid(IntPtr.Zero); }
		public void setColumns(uint columns) { tsControlGrid_setColumns(self, columns); }
		public uint getColumns() { return tsControlGrid_getColumns(self); }
		public void setSpacing(in Vector2f spacing) { tsControlGrid_setSpacing_cV2(self, in spacing); }
		public void setSpacing(float x, float y) { tsControlGrid_setSpacing_ff(self, x, y); }
		public Vector2f getSpacing() { return tsControlGrid_getSpacing(self); }
		public void setColumnRatio(uint index, float ratio) { tsControlGrid_setColumnRatio(self, index, ratio); }
		public float getColumnRatio(uint index) { return tsControlGrid_getColumnRatio(self, index); }
		public Vector2f getControlsSize() { return tsControlGrid_getControlsSize(self); }
		public override string ToString() { return "Tellusim.ControlGrid: Valid: " + tsControlGrid_isValidPtr(self) + "; Owner: " + tsControlGrid_isOwnerPtr(self) + "; Const: " + tsControlGrid_isConstPtr(self) + "; Count: " + tsControlGrid_getCountPtr(self) + "; Internal: 0x" + tsControlGrid_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlGrid ptr) { return (ptr != null && tsControlGrid_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_new_Cu(ref IntPtr parent, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_new_Cuff(ref IntPtr parent, uint columns, float x, float y);
		[DllImport(Base.Import)] private static extern void tsControlGrid_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGrid_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGrid_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGrid_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGrid_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlGrid_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGrid_equalControlPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_castControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGrid_baseControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_setColumns(HandleRef self, uint columns);
		[DllImport(Base.Import)] private static extern uint tsControlGrid_getColumns(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_setSpacing_cV2(HandleRef self, in Vector2f spacing);
		[DllImport(Base.Import)] private static extern void tsControlGrid_setSpacing_ff(HandleRef self, float x, float y);
		[DllImport(Base.Import)] private static extern Vector2f tsControlGrid_getSpacing(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGrid_setColumnRatio(HandleRef self, uint index, float ratio);
		[DllImport(Base.Import)] private static extern float tsControlGrid_getColumnRatio(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Vector2f tsControlGrid_getControlsSize(HandleRef self);
	}
	
	// Tellusim::ControlGroup
	public sealed class ControlGroup : ControlText {
		public delegate void ClickedCallback(ControlGroup a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public ControlGroup() { self = new HandleRef(this, tsControlGroup_new()); owner = true; }
		public ControlGroup(in Control parent, bool above = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGroup_new_Cb(ref parent_, above)); owner = true;
		}
		public ControlGroup(in Control parent, string text, bool above = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGroup_new_Csb(ref parent_, text, above)); owner = true;
		}
		public ControlGroup(in Control parent, String text, bool above = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGroup_new_CcSb(ref parent_, text.getSelf(), above)); owner = true;
		}
		public ControlGroup(in Control parent, string text, uint columns, bool above = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGroup_new_Csub(ref parent_, text, columns, above)); owner = true;
		}
		public ControlGroup(in Control parent, string text, uint columns, float x, float y, bool above = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlGroup_new_Csuffb(ref parent_, text, columns, x, y, above)); owner = true;
		}
		public ControlGroup(ControlGroup ptr) { self = new HandleRef(this, tsControlGroup_copyPtr(ptr.getSelf())); owner = true; }
		public ControlGroup(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlGroup_isOwnerPtr(self); }
		public ControlGroup(ControlText ptr) { self = new HandleRef(this, tsControlGroup_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlGroup_baseControlTextPtr(self)); }
		public static new ControlGroup Null() { return new ControlGroup(IntPtr.Zero); }
		public void setAbove(bool above, bool text = true) { tsControlGroup_setAbove(self, above, text); }
		public bool isAbove() { return tsControlGroup_isAbove(self); }
		public bool isBelow() { return tsControlGroup_isBelow(self); }
		public void setFoldable(bool foldable) { tsControlGroup_setFoldable(self, foldable); }
		public bool isFoldable() { return tsControlGroup_isFoldable(self); }
		public void setExpanded(bool expanded) { tsControlGroup_setExpanded(self, expanded); }
		public bool isExpanded() { return tsControlGroup_isExpanded(self); }
		public void setBackground(bool background) { tsControlGroup_setBackground(self, background); }
		public bool getBackground() { return tsControlGroup_getBackground(self); }
		public void setGroupRadius(float radius) { tsControlGroup_setGroupRadius(self, radius); }
		public float getGroupRadius() { return tsControlGroup_getGroupRadius(self); }
		public void setGroupColor(in Color color) { tsControlGroup_setGroupColor(self, in color); }
		public Color getGroupColor() { return tsControlGroup_getGroupColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsControlGroup_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsControlGroup_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsControlGroup_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsControlGroup_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsControlGroup_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsControlGroup_getGradientStyle_c(self); }
		public void setFoldedText(string text) { tsControlGroup_setFoldedText_s(self, text); }
		public void setFoldedText(String text) { tsControlGroup_setFoldedText_cS(self, text.getSelf()); }
		public string getFoldedText() { return Base.getString(tsControlGroup_getFoldedText(self)); }
		public void setExpandedText(string text) { tsControlGroup_setExpandedText_s(self, text); }
		public void setExpandedText(String text) { tsControlGroup_setExpandedText_cS(self, text.getSelf()); }
		public string getExpandedText() { return Base.getString(tsControlGroup_getExpandedText(self)); }
		public void setColumns(uint columns) { tsControlGroup_setColumns(self, columns); }
		public uint getColumns() { return tsControlGroup_getColumns(self); }
		public void setSpacing(in Vector2f spacing) { tsControlGroup_setSpacing_cV2(self, in spacing); }
		public void setSpacing(float x, float y) { tsControlGroup_setSpacing_ff(self, x, y); }
		public Vector2f getSpacing() { return tsControlGroup_getSpacing(self); }
		public void setColumnRatio(uint index, float ratio) { tsControlGroup_setColumnRatio(self, index, ratio); }
		public float getColumnRatio(uint index) { return tsControlGroup_getColumnRatio(self, index); }
		public Vector2f getControlsSize() { return tsControlGroup_getControlsSize(self); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlGroup.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlGroup(a0_), data_); };
			if(func_ != null) ClickedCallback_41 = GCHandle.Alloc(func_);
			tsControlGroup_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlGroup_isClicked(self); }
		public CanvasRect getCanvasRect() { return new CanvasRect(tsControlGroup_getCanvasRect(self)); }
		private GCHandle ClickedCallback_41;
		public override string ToString() { return "Tellusim.ControlGroup: Valid: " + tsControlGroup_isValidPtr(self) + "; Owner: " + tsControlGroup_isOwnerPtr(self) + "; Const: " + tsControlGroup_isConstPtr(self) + "; Count: " + tsControlGroup_getCountPtr(self) + "; Internal: 0x" + tsControlGroup_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlGroup ptr) { return (ptr != null && tsControlGroup_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_new_Cb(ref IntPtr parent, bool above);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_new_Csb(ref IntPtr parent, string text, bool above);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_new_CcSb(ref IntPtr parent, HandleRef text, bool above);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_new_Csub(ref IntPtr parent, string text, uint columns, bool above);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_new_Csuffb(ref IntPtr parent, string text, uint columns, float x, float y, bool above);
		[DllImport(Base.Import)] private static extern void tsControlGroup_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlGroup_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setAbove(HandleRef self, bool above, bool text);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isAbove(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isBelow(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setFoldable(HandleRef self, bool foldable);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isFoldable(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setExpanded(HandleRef self, bool expanded);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isExpanded(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setBackground(HandleRef self, bool background);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_getBackground(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setGroupRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern float tsControlGroup_getGroupRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setGroupColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlGroup_getGroupColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsControlGroup_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsControlGroup_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsControlGroup_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsControlGroup_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setFoldedText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setFoldedText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_getFoldedText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setExpandedText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setExpandedText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_getExpandedText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setColumns(HandleRef self, uint columns);
		[DllImport(Base.Import)] private static extern uint tsControlGroup_getColumns(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setSpacing_cV2(HandleRef self, in Vector2f spacing);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setSpacing_ff(HandleRef self, float x, float y);
		[DllImport(Base.Import)] private static extern Vector2f tsControlGroup_getSpacing(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setColumnRatio(HandleRef self, uint index, float ratio);
		[DllImport(Base.Import)] private static extern float tsControlGroup_getColumnRatio(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Vector2f tsControlGroup_getControlsSize(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlGroup_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlGroup_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlGroup_getCanvasRect(HandleRef self);
	}
	
	// Tellusim::ControlPanel
	public class ControlPanel : ControlRect {
		public ControlPanel() { self = new HandleRef(this, tsControlPanel_new()); owner = true; }
		public ControlPanel(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlPanel_new_C(ref parent_)); owner = true;
		}
		public ControlPanel(in Control parent, uint columns) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlPanel_new_Cu(ref parent_, columns)); owner = true;
		}
		public ControlPanel(in Control parent, uint columns, float x, float y) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlPanel_new_Cuff(ref parent_, columns, x, y)); owner = true;
		}
		public ControlPanel(ControlPanel ptr) { self = new HandleRef(this, tsControlPanel_copyPtr(ptr.getSelf())); owner = true; }
		public ControlPanel(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlPanel_isOwnerPtr(self); }
		public ControlPanel(ControlRect ptr) { self = new HandleRef(this, tsControlPanel_castControlRectPtr(ptr.getSelf())); }
		public ControlRect toControlRect() { return new ControlRect(tsControlPanel_baseControlRectPtr(self)); }
		public static new ControlPanel Null() { return new ControlPanel(IntPtr.Zero); }
		public void setColumns(uint columns) { tsControlPanel_setColumns(self, columns); }
		public uint getColumns() { return tsControlPanel_getColumns(self); }
		public void setSpacing(in Vector2f spacing) { tsControlPanel_setSpacing_cV2(self, in spacing); }
		public void setSpacing(float x, float y) { tsControlPanel_setSpacing_ff(self, x, y); }
		public Vector2f getSpacing() { return tsControlPanel_getSpacing(self); }
		public void setColumnRatio(uint index, float ratio) { tsControlPanel_setColumnRatio(self, index, ratio); }
		public float getColumnRatio(uint index) { return tsControlPanel_getColumnRatio(self, index); }
		public Vector2f getControlsSize() { return tsControlPanel_getControlsSize(self); }
		public override string ToString() { return "Tellusim.ControlPanel: Valid: " + tsControlPanel_isValidPtr(self) + "; Owner: " + tsControlPanel_isOwnerPtr(self) + "; Const: " + tsControlPanel_isConstPtr(self) + "; Count: " + tsControlPanel_getCountPtr(self) + "; Internal: 0x" + tsControlPanel_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlPanel ptr) { return (ptr != null && tsControlPanel_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_new_Cu(ref IntPtr parent, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_new_Cuff(ref IntPtr parent, uint columns, float x, float y);
		[DllImport(Base.Import)] private static extern void tsControlPanel_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlPanel_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlPanel_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlPanel_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlPanel_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlPanel_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlPanel_equalControlRectPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_castControlRectPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlPanel_baseControlRectPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_setColumns(HandleRef self, uint columns);
		[DllImport(Base.Import)] private static extern uint tsControlPanel_getColumns(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_setSpacing_cV2(HandleRef self, in Vector2f spacing);
		[DllImport(Base.Import)] private static extern void tsControlPanel_setSpacing_ff(HandleRef self, float x, float y);
		[DllImport(Base.Import)] private static extern Vector2f tsControlPanel_getSpacing(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlPanel_setColumnRatio(HandleRef self, uint index, float ratio);
		[DllImport(Base.Import)] private static extern float tsControlPanel_getColumnRatio(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Vector2f tsControlPanel_getControlsSize(HandleRef self);
	}
	
	// Tellusim::ControlDialog
	public class ControlDialog : ControlPanel {
		public delegate void UpdatedCallback(ControlDialog a0, IntPtr data_);
		public delegate void UpdatedCallback_(IntPtr a0, IntPtr data_);
		public ControlDialog() { self = new HandleRef(this, tsControlDialog_new()); owner = true; }
		public ControlDialog(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlDialog_new_C(ref parent_)); owner = true;
		}
		public ControlDialog(in Control parent, uint columns) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlDialog_new_Cu(ref parent_, columns)); owner = true;
		}
		public ControlDialog(in Control parent, uint columns, float x, float y) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlDialog_new_Cuff(ref parent_, columns, x, y)); owner = true;
		}
		public ControlDialog(ControlDialog ptr) { self = new HandleRef(this, tsControlDialog_copyPtr(ptr.getSelf())); owner = true; }
		public ControlDialog(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlDialog_isOwnerPtr(self); }
		public ControlDialog(ControlPanel ptr) { self = new HandleRef(this, tsControlDialog_castControlPanelPtr(ptr.getSelf())); }
		public ControlPanel toControlPanel() { return new ControlPanel(tsControlDialog_baseControlPanelPtr(self)); }
		public static new ControlDialog Null() { return new ControlDialog(IntPtr.Zero); }
		public void setConstrained(bool constrained) { tsControlDialog_setConstrained(self, constrained); }
		public bool isConstrained() { return tsControlDialog_isConstrained(self); }
		public void setResizable(bool resizable) { tsControlDialog_setResizable(self, resizable); }
		public bool isResizable() { return tsControlDialog_isResizable(self); }
		public void setMoveable(bool moveable) { tsControlDialog_setMoveable(self, moveable); }
		public bool isMoveable() { return tsControlDialog_isMoveable(self); }
		public void setResizeArea(float area) { tsControlDialog_setResizeArea(self, area); }
		public float getResizeArea() { return tsControlDialog_getResizeArea(self); }
		public Align getResizeAlign() { return tsControlDialog_getResizeAlign(self); }
		public bool hasResizeAlign(Align align) { return tsControlDialog_hasResizeAlign(self, align); }
		public bool hasResizeAligns(Align aligns) { return tsControlDialog_hasResizeAligns(self, aligns); }
		public void setMousePosition(in Vector2f position) { tsControlDialog_setMousePosition(self, in position); }
		public Vector2f getMousePosition() { return tsControlDialog_getMousePosition(self); }
		public void setUpdatedCallback(UpdatedCallback func, IntPtr data = new IntPtr()) {
			ControlDialog.UpdatedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlDialog(a0_), data_); };
			if(func_ != null) UpdatedCallback_17 = GCHandle.Alloc(func_);
			tsControlDialog_setUpdatedCallback(self, Base.getFunc(func_), data);
		}
		public bool isUpdated() { return tsControlDialog_isUpdated(self); }
		private GCHandle UpdatedCallback_17;
		public override string ToString() { return "Tellusim.ControlDialog: Valid: " + tsControlDialog_isValidPtr(self) + "; Owner: " + tsControlDialog_isOwnerPtr(self) + "; Const: " + tsControlDialog_isConstPtr(self) + "; Count: " + tsControlDialog_getCountPtr(self) + "; Internal: 0x" + tsControlDialog_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlDialog ptr) { return (ptr != null && tsControlDialog_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_new_Cu(ref IntPtr parent, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_new_Cuff(ref IntPtr parent, uint columns, float x, float y);
		[DllImport(Base.Import)] private static extern void tsControlDialog_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlDialog_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_equalControlPanelPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_castControlPanelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlDialog_baseControlPanelPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_setConstrained(HandleRef self, bool constrained);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isConstrained(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_setResizable(HandleRef self, bool resizable);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isResizable(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_setMoveable(HandleRef self, bool moveable);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isMoveable(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_setResizeArea(HandleRef self, float area);
		[DllImport(Base.Import)] private static extern float tsControlDialog_getResizeArea(HandleRef self);
		[DllImport(Base.Import)] private static extern Align tsControlDialog_getResizeAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_hasResizeAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_hasResizeAligns(HandleRef self, Align aligns);
		[DllImport(Base.Import)] private static extern void tsControlDialog_setMousePosition(HandleRef self, in Vector2f position);
		[DllImport(Base.Import)] private static extern Vector2f tsControlDialog_getMousePosition(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlDialog_setUpdatedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlDialog_isUpdated(HandleRef self);
	}
	
	// Tellusim::ControlWindow
	public sealed class ControlWindow : ControlDialog {
		public ControlWindow() { self = new HandleRef(this, tsControlWindow_new()); owner = true; }
		public ControlWindow(in ControlRoot root, Window parent, Window window) {
			IntPtr root_ = (root != null) ? root.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlWindow_new_CRWW(ref root_, parent.getSelf(), window.getSelf())); owner = true;
		}
		public ControlWindow(in ControlRoot root, Window parent, Window window, uint columns) {
			IntPtr root_ = (root != null) ? root.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlWindow_new_CRWWu(ref root_, parent.getSelf(), window.getSelf(), columns)); owner = true;
		}
		public ControlWindow(in ControlRoot root, Window parent, Window window, uint columns, float x, float y) {
			IntPtr root_ = (root != null) ? root.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlWindow_new_CRWWuff(ref root_, parent.getSelf(), window.getSelf(), columns, x, y)); owner = true;
		}
		public ControlWindow(ControlWindow ptr) { self = new HandleRef(this, tsControlWindow_copyPtr(ptr.getSelf())); owner = true; }
		public ControlWindow(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlWindow_isOwnerPtr(self); }
		public ControlWindow(ControlDialog ptr) { self = new HandleRef(this, tsControlWindow_castControlDialogPtr(ptr.getSelf())); }
		public ControlDialog toControlDialog() { return new ControlDialog(tsControlWindow_baseControlDialogPtr(self)); }
		public static new ControlWindow Null() { return new ControlWindow(IntPtr.Zero); }
		public Window getParentWindow() { return new Window(tsControlWindow_getParentWindow(self)); }
		public Window getDialogWindow() { return new Window(tsControlWindow_getDialogWindow(self)); }
		public override string ToString() { return "Tellusim.ControlWindow: Valid: " + tsControlWindow_isValidPtr(self) + "; Owner: " + tsControlWindow_isOwnerPtr(self) + "; Const: " + tsControlWindow_isConstPtr(self) + "; Count: " + tsControlWindow_getCountPtr(self) + "; Internal: 0x" + tsControlWindow_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlWindow ptr) { return (ptr != null && tsControlWindow_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_new_CRWW(ref IntPtr root, HandleRef parent, HandleRef window);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_new_CRWWu(ref IntPtr root, HandleRef parent, HandleRef window, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_new_CRWWuff(ref IntPtr root, HandleRef parent, HandleRef window, uint columns, float x, float y);
		[DllImport(Base.Import)] private static extern void tsControlWindow_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlWindow_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlWindow_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlWindow_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlWindow_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlWindow_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlWindow_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlWindow_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlWindow_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlWindow_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlWindow_equalControlDialogPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_castControlDialogPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_baseControlDialogPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_getParentWindow(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlWindow_getDialogWindow(HandleRef self);
	}
	
	// Tellusim::ControlCheck
	public sealed class ControlCheck : ControlText {
		public delegate void ClickedCallback(ControlCheck a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public ControlCheck() { self = new HandleRef(this, tsControlCheck_new()); owner = true; }
		public ControlCheck(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlCheck_new_C(ref parent_)); owner = true;
		}
		public ControlCheck(in Control parent, string text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlCheck_new_Cs(ref parent_, text)); owner = true;
		}
		public ControlCheck(in Control parent, String text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlCheck_new_CcS(ref parent_, text.getSelf())); owner = true;
		}
		public ControlCheck(in Control parent, string text, bool checked_) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlCheck_new_Csb(ref parent_, text, checked_)); owner = true;
		}
		public ControlCheck(in Control parent, String text, bool checked_) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlCheck_new_CcSb(ref parent_, text.getSelf(), checked_)); owner = true;
		}
		public ControlCheck(ControlCheck ptr) { self = new HandleRef(this, tsControlCheck_copyPtr(ptr.getSelf())); owner = true; }
		public ControlCheck(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlCheck_isOwnerPtr(self); }
		public ControlCheck(ControlText ptr) { self = new HandleRef(this, tsControlCheck_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlCheck_baseControlTextPtr(self)); }
		public static new ControlCheck Null() { return new ControlCheck(IntPtr.Zero); }
		public void setCheckText(string text) { tsControlCheck_setCheckText_s(self, text); }
		public void setCheckText(String text) { tsControlCheck_setCheckText_cS(self, text.getSelf()); }
		public string getCheckText() { return Base.getString(tsControlCheck_getCheckText(self)); }
		public void setCheckColor(in Color color) { tsControlCheck_setCheckColor(self, in color); }
		public Color getCheckColor() { return tsControlCheck_getCheckColor(self); }
		public void setCheckedColor(in Color color) { tsControlCheck_setCheckedColor(self, in color); }
		public Color getCheckedColor() { return tsControlCheck_getCheckedColor(self); }
		public bool switchChecked(bool callback = false) { return tsControlCheck_switchChecked(self, callback); }
		public void setChecked(bool checked_, bool callback = false) { tsControlCheck_setChecked(self, checked_, callback); }
		public bool isChecked() { return tsControlCheck_isChecked(self); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlCheck.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlCheck(a0_), data_); };
			if(func_ != null) ClickedCallback_16 = GCHandle.Alloc(func_);
			tsControlCheck_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlCheck_isClicked(self); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlCheck_getCanvasMesh(self)); }
		private GCHandle ClickedCallback_16;
		public override string ToString() { return "Tellusim.ControlCheck: Valid: " + tsControlCheck_isValidPtr(self) + "; Owner: " + tsControlCheck_isOwnerPtr(self) + "; Const: " + tsControlCheck_isConstPtr(self) + "; Count: " + tsControlCheck_getCountPtr(self) + "; Internal: 0x" + tsControlCheck_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlCheck ptr) { return (ptr != null && tsControlCheck_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_new_Cs(ref IntPtr parent, string text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_new_CcS(ref IntPtr parent, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_new_Csb(ref IntPtr parent, string text, bool checked_);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_new_CcSb(ref IntPtr parent, HandleRef text, bool checked_);
		[DllImport(Base.Import)] private static extern void tsControlCheck_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlCheck_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_setCheckText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlCheck_setCheckText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_getCheckText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_setCheckColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlCheck_getCheckColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_setCheckedColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlCheck_getCheckedColor(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_switchChecked(HandleRef self, bool callback);
		[DllImport(Base.Import)] private static extern void tsControlCheck_setChecked(HandleRef self, bool checked_, bool callback);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_isChecked(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCheck_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlCheck_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCheck_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::ControlCombo
	public sealed class ControlCombo : ControlText {
		public delegate void ClickedCallback(ControlCombo a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ChangedCallback(ControlCombo a0, IntPtr data_);
		public delegate void ChangedCallback_(IntPtr a0, IntPtr data_);
		public ControlCombo() { self = new HandleRef(this, tsControlCombo_new()); owner = true; }
		public ControlCombo(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlCombo_new_C(ref parent_)); owner = true;
		}
		public ControlCombo(ControlCombo ptr) { self = new HandleRef(this, tsControlCombo_copyPtr(ptr.getSelf())); owner = true; }
		public ControlCombo(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlCombo_isOwnerPtr(self); }
		public ControlCombo(ControlText ptr) { self = new HandleRef(this, tsControlCombo_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlCombo_baseControlTextPtr(self)); }
		public static new ControlCombo Null() { return new ControlCombo(IntPtr.Zero); }
		public void setTextEnabled(bool enabled) { tsControlCombo_setTextEnabled(self, enabled); }
		public bool isTextEnabled() { return tsControlCombo_isTextEnabled(self); }
		public void setMultiSelection(bool multi_selection) { tsControlCombo_setMultiSelection(self, multi_selection); }
		public bool isMultiSelection() { return tsControlCombo_isMultiSelection(self); }
		public void setComboText(string text) { tsControlCombo_setComboText_s(self, text); }
		public void setComboText(String text) { tsControlCombo_setComboText_cS(self, text.getSelf()); }
		public string getComboText() { return Base.getString(tsControlCombo_getComboText(self)); }
		public void setComboColor(in Color color) { tsControlCombo_setComboColor(self, in color); }
		public Color getComboColor() { return tsControlCombo_getComboColor(self); }
		public void setItemsSpacing(float spacing) { tsControlCombo_setItemsSpacing(self, spacing); }
		public float getItemsSpacing() { return tsControlCombo_getItemsSpacing(self); }
		public void clearItems() { tsControlCombo_clearItems(self); }
		public uint addItem(string text) { return tsControlCombo_addItem_s(self, text); }
		public uint addItem(String text) { return tsControlCombo_addItem_cS(self, text.getSelf()); }
		public void addItem(uint index, string text) { tsControlCombo_addItem_us(self, index, text); }
		public void addItem(uint index, String text) { tsControlCombo_addItem_ucS(self, index, text.getSelf()); }
		public void removeItem(uint index) { tsControlCombo_removeItem(self, index); }
		public uint getNumItems() { return tsControlCombo_getNumItems(self); }
		public bool switchItemSelected(uint index) { return tsControlCombo_switchItemSelected(self, index); }
		public void setItemSelected(uint index, bool selected) { tsControlCombo_setItemSelected(self, index, selected); }
		public bool isItemSelected(uint index) { return tsControlCombo_isItemSelected(self, index); }
		public void setItemText(uint index, string text) { tsControlCombo_setItemText_us(self, index, text); }
		public void setItemText(uint index, String text) { tsControlCombo_setItemText_ucS(self, index, text.getSelf()); }
		public string getItemText(uint index) { return Base.getString(tsControlCombo_getItemText(self, index)); }
		public uint findItemText(string text) { return tsControlCombo_findItemText_cs(self, text); }
		public uint findItemText(String text) { return tsControlCombo_findItemText_ccS(self, text.getSelf()); }
		public void setItemColor(uint index, in Color color) { tsControlCombo_setItemColor(self, index, in color); }
		public Color getItemColor(uint index) { return tsControlCombo_getItemColor(self, index); }
		public void setCurrentIndex(uint index, bool callback = false) { tsControlCombo_setCurrentIndex(self, index, callback); }
		public bool setCurrentText(string text, bool callback = false) { return tsControlCombo_setCurrentText_sb(self, text, callback); }
		public bool setCurrentText(String text, bool callback = false) { return tsControlCombo_setCurrentText_cSb(self, text.getSelf(), callback); }
		public uint getCurrentIndex() { return tsControlCombo_getCurrentIndex(self); }
		public string getCurrentText() { return Base.getString(tsControlCombo_getCurrentText(self)); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlCombo.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlCombo(a0_), data_); };
			if(func_ != null) ClickedCallback_38 = GCHandle.Alloc(func_);
			tsControlCombo_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlCombo_isClicked(self); }
		public void setChangedCallback(ChangedCallback func, IntPtr data = new IntPtr()) {
			ControlCombo.ChangedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlCombo(a0_), data_); };
			if(func_ != null) ChangedCallback_41 = GCHandle.Alloc(func_);
			tsControlCombo_setChangedCallback(self, Base.getFunc(func_), data);
		}
		public bool isChanged() { return tsControlCombo_isChanged(self); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlCombo_getCanvasMesh(self)); }
		private GCHandle ClickedCallback_38;
		private GCHandle ChangedCallback_41;
		public override string ToString() { return "Tellusim.ControlCombo: Valid: " + tsControlCombo_isValidPtr(self) + "; Owner: " + tsControlCombo_isOwnerPtr(self) + "; Const: " + tsControlCombo_isConstPtr(self) + "; Count: " + tsControlCombo_getCountPtr(self) + "; Internal: 0x" + tsControlCombo_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlCombo ptr) { return (ptr != null && tsControlCombo_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern void tsControlCombo_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setTextEnabled(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isTextEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setMultiSelection(HandleRef self, bool multi_selection);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isMultiSelection(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setComboText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setComboText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_getComboText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setComboColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlCombo_getComboColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setItemsSpacing(HandleRef self, float spacing);
		[DllImport(Base.Import)] private static extern float tsControlCombo_getItemsSpacing(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_clearItems(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_addItem_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_addItem_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlCombo_addItem_us(HandleRef self, uint index, string text);
		[DllImport(Base.Import)] private static extern void tsControlCombo_addItem_ucS(HandleRef self, uint index, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlCombo_removeItem(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_getNumItems(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_switchItemSelected(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setItemSelected(HandleRef self, uint index, bool selected);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isItemSelected(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setItemText_us(HandleRef self, uint index, string text);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setItemText_ucS(HandleRef self, uint index, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_getItemText(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_findItemText_cs(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_findItemText_ccS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setItemColor(HandleRef self, uint index, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlCombo_getItemColor(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setCurrentIndex(HandleRef self, uint index, bool callback);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_setCurrentText_sb(HandleRef self, string text, bool callback);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_setCurrentText_cSb(HandleRef self, HandleRef text, bool callback);
		[DllImport(Base.Import)] private static extern uint tsControlCombo_getCurrentIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_getCurrentText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlCombo_setChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlCombo_isChanged(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlCombo_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::ControlButton
	public sealed class ControlButton : ControlText {
		public delegate void PressedCallback(ControlButton a0, float x, float y, IntPtr data_);
		public delegate void PressedCallback_(IntPtr a0, float x, float y, IntPtr data_);
		public delegate void ReleasedCallback(ControlButton a0, float x, float y, IntPtr data_);
		public delegate void ReleasedCallback_(IntPtr a0, float x, float y, IntPtr data_);
		public delegate void ClickedCallback(ControlButton a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public ControlButton() { self = new HandleRef(this, tsControlButton_new()); owner = true; }
		public ControlButton(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlButton_new_C(ref parent_)); owner = true;
		}
		public ControlButton(in Control parent, string text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlButton_new_Cs(ref parent_, text)); owner = true;
		}
		public ControlButton(in Control parent, String text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlButton_new_CcS(ref parent_, text.getSelf())); owner = true;
		}
		public ControlButton(ControlButton ptr) { self = new HandleRef(this, tsControlButton_copyPtr(ptr.getSelf())); owner = true; }
		public ControlButton(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlButton_isOwnerPtr(self); }
		public ControlButton(ControlText ptr) { self = new HandleRef(this, tsControlButton_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlButton_baseControlTextPtr(self)); }
		public static new ControlButton Null() { return new ControlButton(IntPtr.Zero); }
		public void setBackground(bool background) { tsControlButton_setBackground(self, background); }
		public bool getBackground() { return tsControlButton_getBackground(self); }
		public void setButtonMode(CanvasElement.Mode mode) { tsControlButton_setButtonMode(self, mode); }
		public CanvasElement.Mode getButtonMode() { return tsControlButton_getButtonMode(self); }
		public void setButtonRadius(float radius) { tsControlButton_setButtonRadius(self, radius); }
		public float getButtonRadius() { return tsControlButton_getButtonRadius(self); }
		public void setButtonColor(in Color color) { tsControlButton_setButtonColor(self, in color); }
		public Color getButtonColor() { return tsControlButton_getButtonColor(self); }
		public void setStrokeStyle(in StrokeStyle style) { tsControlButton_setStrokeStyle(self, in style); }
		public StrokeStyle getStrokeStyleConst() { return tsControlButton_getStrokeStyleConst(self); }
		public StrokeStyle getStrokeStyle() { return tsControlButton_getStrokeStyle_c(self); }
		public void setGradientStyle(in GradientStyle style) { tsControlButton_setGradientStyle(self, in style); }
		public GradientStyle getGradientStyleConst() { return tsControlButton_getGradientStyleConst(self); }
		public GradientStyle getGradientStyle() { return tsControlButton_getGradientStyle_c(self); }
		public void setPressedCallback(PressedCallback func, IntPtr data = new IntPtr()) {
			ControlButton.PressedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, float x_, float y_, IntPtr data_) => { func(new ControlButton(a0_), x_, y_, data_); };
			if(func_ != null) PressedCallback_20 = GCHandle.Alloc(func_);
			tsControlButton_setPressedCallback(self, Base.getFunc(func_), data);
		}
		public bool isPressed() { return tsControlButton_isPressed(self); }
		public void setReleasedCallback(ReleasedCallback func, IntPtr data = new IntPtr()) {
			ControlButton.ReleasedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, float x_, float y_, IntPtr data_) => { func(new ControlButton(a0_), x_, y_, data_); };
			if(func_ != null) ReleasedCallback_23 = GCHandle.Alloc(func_);
			tsControlButton_setReleasedCallback(self, Base.getFunc(func_), data);
		}
		public bool isReleased() { return tsControlButton_isReleased(self); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlButton.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlButton(a0_), data_); };
			if(func_ != null) ClickedCallback_26 = GCHandle.Alloc(func_);
			tsControlButton_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlButton_isClicked(self); }
		public CanvasRect getCanvasRect() { return new CanvasRect(tsControlButton_getCanvasRect(self)); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlButton_getCanvasMesh(self)); }
		private GCHandle PressedCallback_20;
		private GCHandle ReleasedCallback_23;
		private GCHandle ClickedCallback_26;
		public override string ToString() { return "Tellusim.ControlButton: Valid: " + tsControlButton_isValidPtr(self) + "; Owner: " + tsControlButton_isOwnerPtr(self) + "; Const: " + tsControlButton_isConstPtr(self) + "; Count: " + tsControlButton_getCountPtr(self) + "; Internal: 0x" + tsControlButton_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlButton ptr) { return (ptr != null && tsControlButton_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_new_Cs(ref IntPtr parent, string text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_new_CcS(ref IntPtr parent, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlButton_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlButton_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlButton_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlButton_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlButton_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlButton_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlButton_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setBackground(HandleRef self, bool background);
		[DllImport(Base.Import)] private static extern bool tsControlButton_getBackground(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setButtonMode(HandleRef self, CanvasElement.Mode mode);
		[DllImport(Base.Import)] private static extern CanvasElement.Mode tsControlButton_getButtonMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setButtonRadius(HandleRef self, float radius);
		[DllImport(Base.Import)] private static extern float tsControlButton_getButtonRadius(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setButtonColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlButton_getButtonColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setStrokeStyle(HandleRef self, in StrokeStyle style);
		[DllImport(Base.Import)] private static extern StrokeStyle tsControlButton_getStrokeStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern StrokeStyle tsControlButton_getStrokeStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setGradientStyle(HandleRef self, in GradientStyle style);
		[DllImport(Base.Import)] private static extern GradientStyle tsControlButton_getGradientStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern GradientStyle tsControlButton_getGradientStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setPressedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlButton_isPressed(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setReleasedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlButton_isReleased(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlButton_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlButton_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_getCanvasRect(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlButton_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::ControlSlider
	public sealed class ControlSlider : ControlText {
		public delegate string FormatCallback(ControlSlider a0, IntPtr data_);
		public delegate string FormatCallback_(IntPtr a0, IntPtr data_);
		public delegate void PressedCallback(ControlSlider a0, IntPtr data_);
		public delegate void PressedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ReleasedCallback(ControlSlider a0, IntPtr data_);
		public delegate void ReleasedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ClickedCallback(ControlSlider a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ChangedCallback(ControlSlider a0, IntPtr data_);
		public delegate void ChangedCallback_(IntPtr a0, IntPtr data_);
		public ControlSlider() { self = new HandleRef(this, tsControlSlider_new()); owner = true; }
		public ControlSlider(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_C(ref parent_)); owner = true;
		}
		public ControlSlider(in Control parent, string text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Cs(ref parent_, text)); owner = true;
		}
		public ControlSlider(in Control parent, String text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_CcS(ref parent_, text.getSelf())); owner = true;
		}
		public ControlSlider(in Control parent, string text, uint digits) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Csu(ref parent_, text, digits)); owner = true;
		}
		public ControlSlider(in Control parent, string text, uint digits, double value) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Csuf64(ref parent_, text, digits, value)); owner = true;
		}
		public ControlSlider(in Control parent, string text, uint digits, double value, double min, double max) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Csuf64f64f64(ref parent_, text, digits, value, min, max)); owner = true;
		}
		public ControlSlider(in Control parent, string text, double value, double min, double max) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Csf64f64f64(ref parent_, text, value, min, max)); owner = true;
		}
		public ControlSlider(in Control parent, string text, uint value, uint min, uint max) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Csuuu(ref parent_, text, value, min, max)); owner = true;
		}
		public ControlSlider(in Control parent, string text, int value, int min, int max) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSlider_new_Csiii(ref parent_, text, value, min, max)); owner = true;
		}
		public ControlSlider(ControlSlider ptr) { self = new HandleRef(this, tsControlSlider_copyPtr(ptr.getSelf())); owner = true; }
		public ControlSlider(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlSlider_isOwnerPtr(self); }
		public ControlSlider(ControlText ptr) { self = new HandleRef(this, tsControlSlider_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlSlider_baseControlTextPtr(self)); }
		public static new ControlSlider Null() { return new ControlSlider(IntPtr.Zero); }
		public void setConstrained(bool constrained) { tsControlSlider_setConstrained(self, constrained); }
		public bool isConstrained() { return tsControlSlider_isConstrained(self); }
		public void setTextEnabled(bool enabled) { tsControlSlider_setTextEnabled(self, enabled); }
		public bool isTextEnabled() { return tsControlSlider_isTextEnabled(self); }
		public void setSliderColor(in Color color) { tsControlSlider_setSliderColor(self, in color); }
		public Color getSliderColor() { return tsControlSlider_getSliderColor(self); }
		public void setDigits(uint digits) { tsControlSlider_setDigits(self, digits); }
		public uint getDigits() { return tsControlSlider_getDigits(self); }
		public void setStep(double step) { tsControlSlider_setStep(self, step); }
		public double getStep() { return tsControlSlider_getStep(self); }
		public void setBase(double base_) { tsControlSlider_setBase(self, base_); }
		public double getBase() { return tsControlSlider_getBase(self); }
		public void setFormat(string format) { tsControlSlider_setFormat_s(self, format); }
		public void setFormat(String format) { tsControlSlider_setFormat_cS(self, format.getSelf()); }
		public string getFormat() { return Base.getString(tsControlSlider_getFormat(self)); }
		public void setValue(double value, bool callback = false, bool exponent = false) { tsControlSlider_setValue(self, value, callback, exponent); }
		public double getValue(bool exponent = false) { return tsControlSlider_getValue(self, exponent); }
		public float getValuef32(bool exponent = false) { return tsControlSlider_getValuef32(self, exponent); }
		public uint getValueu32(bool exponent = false) { return tsControlSlider_getValueu32(self, exponent); }
		public int getValuei32(bool exponent = false) { return tsControlSlider_getValuei32(self, exponent); }
		public void setRange(double min, double max, bool exponent = false) { tsControlSlider_setRange(self, min, max, exponent); }
		public double getMinRange(bool exponent = false) { return tsControlSlider_getMinRange(self, exponent); }
		public double getMaxRange(bool exponent = false) { return tsControlSlider_getMaxRange(self, exponent); }
		public void setHandleSize(float size) { tsControlSlider_setHandleSize(self, size); }
		public float getHandleSize() { return tsControlSlider_getHandleSize(self); }
		public void setFormatCallback(FormatCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.FormatCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { return func(new ControlSlider(a0_), data_); };
			if(func_ != null) FormatCallback_35 = GCHandle.Alloc(func_);
			tsControlSlider_setFormatCallback(self, Base.getFunc(func_), data);
		}
		public void setPressedCallback(PressedCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.PressedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlSlider(a0_), data_); };
			if(func_ != null) PressedCallback_37 = GCHandle.Alloc(func_);
			tsControlSlider_setPressedCallback(self, Base.getFunc(func_), data);
		}
		public bool isPressed() { return tsControlSlider_isPressed(self); }
		public void setReleasedCallback(ReleasedCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.ReleasedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlSlider(a0_), data_); };
			if(func_ != null) ReleasedCallback_40 = GCHandle.Alloc(func_);
			tsControlSlider_setReleasedCallback(self, Base.getFunc(func_), data);
		}
		public bool isReleased() { return tsControlSlider_isReleased(self); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlSlider(a0_), data_); };
			if(func_ != null) ClickedCallback_43 = GCHandle.Alloc(func_);
			tsControlSlider_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public void setClicked2Callback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlSlider(a0_), data_); };
			if(func_ != null) ClickedCallback_44 = GCHandle.Alloc(func_);
			tsControlSlider_setClicked2Callback(self, Base.getFunc(func_), data);
		}
		public void setClickedRightCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlSlider(a0_), data_); };
			if(func_ != null) ClickedCallback_45 = GCHandle.Alloc(func_);
			tsControlSlider_setClickedRightCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlSlider_isClicked(self); }
		public void setChangedCallback(ChangedCallback func, IntPtr data = new IntPtr()) {
			ControlSlider.ChangedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlSlider(a0_), data_); };
			if(func_ != null) ChangedCallback_50 = GCHandle.Alloc(func_);
			tsControlSlider_setChangedCallback(self, Base.getFunc(func_), data);
		}
		public bool isChanged(bool clear = true) { return tsControlSlider_isChanged(self, clear); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlSlider_getCanvasMesh(self)); }
		private GCHandle FormatCallback_35;
		private GCHandle PressedCallback_37;
		private GCHandle ReleasedCallback_40;
		private GCHandle ClickedCallback_43;
		private GCHandle ClickedCallback_44;
		private GCHandle ClickedCallback_45;
		private GCHandle ChangedCallback_50;
		public override string ToString() { return "Tellusim.ControlSlider: Valid: " + tsControlSlider_isValidPtr(self) + "; Owner: " + tsControlSlider_isOwnerPtr(self) + "; Const: " + tsControlSlider_isConstPtr(self) + "; Count: " + tsControlSlider_getCountPtr(self) + "; Internal: 0x" + tsControlSlider_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlSlider ptr) { return (ptr != null && tsControlSlider_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Cs(ref IntPtr parent, string text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_CcS(ref IntPtr parent, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Csu(ref IntPtr parent, string text, uint digits);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Csuf64(ref IntPtr parent, string text, uint digits, double value);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Csuf64f64f64(ref IntPtr parent, string text, uint digits, double value, double min, double max);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Csf64f64f64(ref IntPtr parent, string text, double value, double min, double max);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Csuuu(ref IntPtr parent, string text, uint value, uint min, uint max);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_new_Csiii(ref IntPtr parent, string text, int value, int min, int max);
		[DllImport(Base.Import)] private static extern void tsControlSlider_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlSlider_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setConstrained(HandleRef self, bool constrained);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isConstrained(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setTextEnabled(HandleRef self, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isTextEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setSliderColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlSlider_getSliderColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setDigits(HandleRef self, uint digits);
		[DllImport(Base.Import)] private static extern uint tsControlSlider_getDigits(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setStep(HandleRef self, double step);
		[DllImport(Base.Import)] private static extern double tsControlSlider_getStep(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setBase(HandleRef self, double base_);
		[DllImport(Base.Import)] private static extern double tsControlSlider_getBase(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setFormat_s(HandleRef self, string format);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setFormat_cS(HandleRef self, HandleRef format);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_getFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setValue(HandleRef self, double value, bool callback, bool exponent);
		[DllImport(Base.Import)] private static extern double tsControlSlider_getValue(HandleRef self, bool exponent);
		[DllImport(Base.Import)] private static extern float tsControlSlider_getValuef32(HandleRef self, bool exponent);
		[DllImport(Base.Import)] private static extern uint tsControlSlider_getValueu32(HandleRef self, bool exponent);
		[DllImport(Base.Import)] private static extern int tsControlSlider_getValuei32(HandleRef self, bool exponent);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setRange(HandleRef self, double min, double max, bool exponent);
		[DllImport(Base.Import)] private static extern double tsControlSlider_getMinRange(HandleRef self, bool exponent);
		[DllImport(Base.Import)] private static extern double tsControlSlider_getMaxRange(HandleRef self, bool exponent);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setHandleSize(HandleRef self, float size);
		[DllImport(Base.Import)] private static extern float tsControlSlider_getHandleSize(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setFormatCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setPressedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isPressed(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setReleasedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isReleased(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setClicked2Callback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setClickedRightCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSlider_setChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlSlider_isChanged(HandleRef self, bool clear);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSlider_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::ControlScroll
	public sealed class ControlScroll : ControlText {
		public delegate void ClickedCallback(ControlScroll a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ChangedCallback(ControlScroll a0, IntPtr data_);
		public delegate void ChangedCallback_(IntPtr a0, IntPtr data_);
		public ControlScroll() { self = new HandleRef(this, tsControlScroll_new()); owner = true; }
		public ControlScroll(in Control parent, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlScroll_new_Cb(ref parent_, vertical)); owner = true;
		}
		public ControlScroll(in Control parent, double value, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlScroll_new_Cf64b(ref parent_, value, vertical)); owner = true;
		}
		public ControlScroll(in Control parent, double value, double frame, double range, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlScroll_new_Cf64f64f64b(ref parent_, value, frame, range, vertical)); owner = true;
		}
		public ControlScroll(in Control parent, uint value, uint frame, uint range, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlScroll_new_Cuuub(ref parent_, value, frame, range, vertical)); owner = true;
		}
		public ControlScroll(in Control parent, int value, int frame, int range, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlScroll_new_Ciiib(ref parent_, value, frame, range, vertical)); owner = true;
		}
		public ControlScroll(ControlScroll ptr) { self = new HandleRef(this, tsControlScroll_copyPtr(ptr.getSelf())); owner = true; }
		public ControlScroll(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlScroll_isOwnerPtr(self); }
		public ControlScroll(ControlText ptr) { self = new HandleRef(this, tsControlScroll_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlScroll_baseControlTextPtr(self)); }
		public static new ControlScroll Null() { return new ControlScroll(IntPtr.Zero); }
		public void setVertical(bool vertical, bool text = true) { tsControlScroll_setVertical(self, vertical, text); }
		public bool isHorizontal() { return tsControlScroll_isHorizontal(self); }
		public bool isVertical() { return tsControlScroll_isVertical(self); }
		public void setPrevText(string text) { tsControlScroll_setPrevText_s(self, text); }
		public void setPrevText(String text) { tsControlScroll_setPrevText_cS(self, text.getSelf()); }
		public string getPrevText() { return Base.getString(tsControlScroll_getPrevText(self)); }
		public void setNextText(string text) { tsControlScroll_setNextText_s(self, text); }
		public void setNextText(String text) { tsControlScroll_setNextText_cS(self, text.getSelf()); }
		public string getNextText() { return Base.getString(tsControlScroll_getNextText(self)); }
		public void setScrollColor(in Color color) { tsControlScroll_setScrollColor(self, in color); }
		public Color getScrollColor() { return tsControlScroll_getScrollColor(self); }
		public void setStep(double step) { tsControlScroll_setStep(self, step); }
		public double getStep() { return tsControlScroll_getStep(self); }
		public void setValue(double value, bool callback = false) { tsControlScroll_setValue(self, value, callback); }
		public double getValue() { return tsControlScroll_getValue(self); }
		public void setFrame(double frame) { tsControlScroll_setFrame(self, frame); }
		public double getFrame() { return tsControlScroll_getFrame(self); }
		public void setRange(double range) { tsControlScroll_setRange(self, range); }
		public double getRange() { return tsControlScroll_getRange(self); }
		public void setFrameAlign(Align align) { tsControlScroll_setFrameAlign(self, align); }
		public Align getFrameAlign() { return tsControlScroll_getFrameAlign(self); }
		public bool hasFrameAlign(Align align) { return tsControlScroll_hasFrameAlign(self, align); }
		public bool hasFrameAligns(Align aligns) { return tsControlScroll_hasFrameAligns(self, aligns); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlScroll.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlScroll(a0_), data_); };
			if(func_ != null) ClickedCallback_29 = GCHandle.Alloc(func_);
			tsControlScroll_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlScroll_isClicked(self); }
		public void setChangedCallback(ChangedCallback func, IntPtr data = new IntPtr()) {
			ControlScroll.ChangedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlScroll(a0_), data_); };
			if(func_ != null) ChangedCallback_32 = GCHandle.Alloc(func_);
			tsControlScroll_setChangedCallback(self, Base.getFunc(func_), data);
		}
		public bool isChanged(bool clear = true) { return tsControlScroll_isChanged(self, clear); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlScroll_getCanvasMesh(self)); }
		private GCHandle ClickedCallback_29;
		private GCHandle ChangedCallback_32;
		public override string ToString() { return "Tellusim.ControlScroll: Valid: " + tsControlScroll_isValidPtr(self) + "; Owner: " + tsControlScroll_isOwnerPtr(self) + "; Const: " + tsControlScroll_isConstPtr(self) + "; Count: " + tsControlScroll_getCountPtr(self) + "; Internal: 0x" + tsControlScroll_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlScroll ptr) { return (ptr != null && tsControlScroll_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_new_Cb(ref IntPtr parent, bool vertical);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_new_Cf64b(ref IntPtr parent, double value, bool vertical);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_new_Cf64f64f64b(ref IntPtr parent, double value, double frame, double range, bool vertical);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_new_Cuuub(ref IntPtr parent, uint value, uint frame, uint range, bool vertical);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_new_Ciiib(ref IntPtr parent, int value, int frame, int range, bool vertical);
		[DllImport(Base.Import)] private static extern void tsControlScroll_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlScroll_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setVertical(HandleRef self, bool vertical, bool text);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isHorizontal(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isVertical(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setPrevText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setPrevText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_getPrevText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setNextText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setNextText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_getNextText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setScrollColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlScroll_getScrollColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setStep(HandleRef self, double step);
		[DllImport(Base.Import)] private static extern double tsControlScroll_getStep(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setValue(HandleRef self, double value, bool callback);
		[DllImport(Base.Import)] private static extern double tsControlScroll_getValue(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setFrame(HandleRef self, double frame);
		[DllImport(Base.Import)] private static extern double tsControlScroll_getFrame(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setRange(HandleRef self, double range);
		[DllImport(Base.Import)] private static extern double tsControlScroll_getRange(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setFrameAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern Align tsControlScroll_getFrameAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_hasFrameAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_hasFrameAligns(HandleRef self, Align aligns);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlScroll_setChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlScroll_isChanged(HandleRef self, bool clear);
		[DllImport(Base.Import)] private static extern IntPtr tsControlScroll_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::ControlSplit
	public sealed class ControlSplit : Control {
		public ControlSplit() { self = new HandleRef(this, tsControlSplit_new()); owner = true; }
		public ControlSplit(in Control parent, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSplit_new_Cb(ref parent_, vertical)); owner = true;
		}
		public ControlSplit(in Control parent, float value, bool vertical = false) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlSplit_new_Cfb(ref parent_, value, vertical)); owner = true;
		}
		public ControlSplit(ControlSplit ptr) { self = new HandleRef(this, tsControlSplit_copyPtr(ptr.getSelf())); owner = true; }
		public ControlSplit(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlSplit_isOwnerPtr(self); }
		public ControlSplit(Control ptr) { self = new HandleRef(this, tsControlSplit_castControlPtr(ptr.getSelf())); }
		public Control toControl() { return new Control(tsControlSplit_baseControlPtr(self)); }
		public static new ControlSplit Null() { return new ControlSplit(IntPtr.Zero); }
		public void setAbsolute(bool absolute) { tsControlSplit_setAbsolute(self, absolute); }
		public bool isAbsolute() { return tsControlSplit_isAbsolute(self); }
		public void setVertical(bool vertical) { tsControlSplit_setVertical(self, vertical); }
		public bool isHorizontal() { return tsControlSplit_isHorizontal(self); }
		public bool isVertical() { return tsControlSplit_isVertical(self); }
		public void setValue(float value) { tsControlSplit_setValue(self, value); }
		public float getValue() { return tsControlSplit_getValue(self); }
		public void setHandleSize(float size) { tsControlSplit_setHandleSize(self, size); }
		public float getHandleSize() { return tsControlSplit_getHandleSize(self); }
		public Vector2f getControlsSize() { return tsControlSplit_getControlsSize(self); }
		public override string ToString() { return "Tellusim.ControlSplit: Valid: " + tsControlSplit_isValidPtr(self) + "; Owner: " + tsControlSplit_isOwnerPtr(self) + "; Const: " + tsControlSplit_isConstPtr(self) + "; Count: " + tsControlSplit_getCountPtr(self) + "; Internal: 0x" + tsControlSplit_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlSplit ptr) { return (ptr != null && tsControlSplit_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_new_Cb(ref IntPtr parent, bool vertical);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_new_Cfb(ref IntPtr parent, float value, bool vertical);
		[DllImport(Base.Import)] private static extern void tsControlSplit_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlSplit_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_equalControlPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_castControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlSplit_baseControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_setAbsolute(HandleRef self, bool absolute);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_isAbsolute(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_setVertical(HandleRef self, bool vertical);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_isHorizontal(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlSplit_isVertical(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_setValue(HandleRef self, float value);
		[DllImport(Base.Import)] private static extern float tsControlSplit_getValue(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlSplit_setHandleSize(HandleRef self, float size);
		[DllImport(Base.Import)] private static extern float tsControlSplit_getHandleSize(HandleRef self);
		[DllImport(Base.Import)] private static extern Vector2f tsControlSplit_getControlsSize(HandleRef self);
	}
	
	// Tellusim::ControlArea
	public sealed class ControlArea : Control {
		public ControlArea() { self = new HandleRef(this, tsControlArea_new()); owner = true; }
		public ControlArea(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlArea_new_C(ref parent_)); owner = true;
		}
		public ControlArea(in Control parent, uint columns) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlArea_new_Cu(ref parent_, columns)); owner = true;
		}
		public ControlArea(in Control parent, bool horizontal, bool vertical) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlArea_new_Cbb(ref parent_, horizontal, vertical)); owner = true;
		}
		public ControlArea(in Control parent, uint columns, float x, float y) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlArea_new_Cuff(ref parent_, columns, x, y)); owner = true;
		}
		public ControlArea(ControlArea ptr) { self = new HandleRef(this, tsControlArea_copyPtr(ptr.getSelf())); owner = true; }
		public ControlArea(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlArea_isOwnerPtr(self); }
		public ControlArea(Control ptr) { self = new HandleRef(this, tsControlArea_castControlPtr(ptr.getSelf())); }
		public Control toControl() { return new Control(tsControlArea_baseControlPtr(self)); }
		public static new ControlArea Null() { return new ControlArea(IntPtr.Zero); }
		public void setAbsolute(bool absolute) { tsControlArea_setAbsolute(self, absolute); }
		public bool isAbsolute() { return tsControlArea_isAbsolute(self); }
		public void setScalable(bool scalable) { tsControlArea_setScalable(self, scalable); }
		public bool isScalable() { return tsControlArea_isScalable(self); }
		public void setScrollable(bool scrollable) { tsControlArea_setScrollable(self, scrollable); }
		public bool isScrollable() { return tsControlArea_isScrollable(self); }
		public void setScale(float scale) { tsControlArea_setScale(self, scale); }
		public float getScale() { return tsControlArea_getScale(self); }
		public void setScaleRange(float min, float max) { tsControlArea_setScaleRange(self, min, max); }
		public float getMinScale() { return tsControlArea_getMinScale(self); }
		public float getMaxScale() { return tsControlArea_getMaxScale(self); }
		public void setHorizontalStep(double step) { tsControlArea_setHorizontalStep(self, step); }
		public void setVerticalStep(double step) { tsControlArea_setVerticalStep(self, step); }
		public void setStep(double horizontal, double vertical) { tsControlArea_setStep(self, horizontal, vertical); }
		public double getHorizontalStep() { return tsControlArea_getHorizontalStep(self); }
		public double getVerticalStep() { return tsControlArea_getVerticalStep(self); }
		public void setHorizontalValue(double value) { tsControlArea_setHorizontalValue(self, value); }
		public void setVerticalValue(double value) { tsControlArea_setVerticalValue(self, value); }
		public void setValue(double horizontal, double vertical) { tsControlArea_setValue(self, horizontal, vertical); }
		public double getHorizontalValue() { return tsControlArea_getHorizontalValue(self); }
		public double getVerticalValue() { return tsControlArea_getVerticalValue(self); }
		public void setFrameAlign(Align align) { tsControlArea_setFrameAlign(self, align); }
		public Align getFrameAlign() { return tsControlArea_getFrameAlign(self); }
		public double getHorizontalFrame() { return tsControlArea_getHorizontalFrame(self); }
		public double getVerticalFrame() { return tsControlArea_getVerticalFrame(self); }
		public double getHorizontalRange() { return tsControlArea_getHorizontalRange(self); }
		public double getVerticalRange() { return tsControlArea_getVerticalRange(self); }
		public void setHorizontalEnabled(bool enabled, bool dynamic = false) { tsControlArea_setHorizontalEnabled(self, enabled, dynamic); }
		public bool isHorizontalEnabled() { return tsControlArea_isHorizontalEnabled(self); }
		public bool isHorizontalDynamic() { return tsControlArea_isHorizontalDynamic(self); }
		public bool isHorizontalHidden() { return tsControlArea_isHorizontalHidden(self); }
		public ControlScroll getHorizontalScroll() { return new ControlScroll(tsControlArea_getHorizontalScroll_c(self)); }
		public void setVerticalEnabled(bool enabled, bool dynamic = false) { tsControlArea_setVerticalEnabled(self, enabled, dynamic); }
		public bool isVerticalEnabled() { return tsControlArea_isVerticalEnabled(self); }
		public bool isVerticalDynamic() { return tsControlArea_isVerticalDynamic(self); }
		public bool isVerticalHidden() { return tsControlArea_isVerticalHidden(self); }
		public ControlScroll getVerticalScroll() { return new ControlScroll(tsControlArea_getVerticalScroll_c(self)); }
		public bool setFontSize(uint size) { return tsControlArea_setFontSize(self, size); }
		public uint getFontSize() { return tsControlArea_getFontSize(self); }
		public bool setFontStyle(in FontStyle style) { return tsControlArea_setFontStyle(self, in style); }
		public FontStyle getFontStyleConst() { return tsControlArea_getFontStyleConst(self); }
		public FontStyle getFontStyle() { return tsControlArea_getFontStyle_c(self); }
		public void setColumns(uint columns) { tsControlArea_setColumns(self, columns); }
		public uint getColumns() { return tsControlArea_getColumns(self); }
		public void setSpacing(in Vector2f spacing) { tsControlArea_setSpacing_cV2(self, in spacing); }
		public void setSpacing(float x, float y) { tsControlArea_setSpacing_ff(self, x, y); }
		public Vector2f getSpacing() { return tsControlArea_getSpacing(self); }
		public void setColumnRatio(uint index, float ratio) { tsControlArea_setColumnRatio(self, index, ratio); }
		public float getColumnRatio(uint index) { return tsControlArea_getColumnRatio(self, index); }
		public Vector2f getControlsSize() { return tsControlArea_getControlsSize(self); }
		public Vector2f getControlsOffset() { return tsControlArea_getControlsOffset(self); }
		public Rect getViewRect() { return tsControlArea_getViewRect(self); }
		public override string ToString() { return "Tellusim.ControlArea: Valid: " + tsControlArea_isValidPtr(self) + "; Owner: " + tsControlArea_isOwnerPtr(self) + "; Const: " + tsControlArea_isConstPtr(self) + "; Count: " + tsControlArea_getCountPtr(self) + "; Internal: 0x" + tsControlArea_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlArea ptr) { return (ptr != null && tsControlArea_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_new_Cu(ref IntPtr parent, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_new_Cbb(ref IntPtr parent, bool horizontal, bool vertical);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_new_Cuff(ref IntPtr parent, uint columns, float x, float y);
		[DllImport(Base.Import)] private static extern void tsControlArea_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlArea_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_equalControlPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_castControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_baseControlPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setAbsolute(HandleRef self, bool absolute);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isAbsolute(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setScalable(HandleRef self, bool scalable);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isScalable(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setScrollable(HandleRef self, bool scrollable);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isScrollable(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setScale(HandleRef self, float scale);
		[DllImport(Base.Import)] private static extern float tsControlArea_getScale(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setScaleRange(HandleRef self, float min, float max);
		[DllImport(Base.Import)] private static extern float tsControlArea_getMinScale(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsControlArea_getMaxScale(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setHorizontalStep(HandleRef self, double step);
		[DllImport(Base.Import)] private static extern void tsControlArea_setVerticalStep(HandleRef self, double step);
		[DllImport(Base.Import)] private static extern void tsControlArea_setStep(HandleRef self, double horizontal, double vertical);
		[DllImport(Base.Import)] private static extern double tsControlArea_getHorizontalStep(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsControlArea_getVerticalStep(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setHorizontalValue(HandleRef self, double value);
		[DllImport(Base.Import)] private static extern void tsControlArea_setVerticalValue(HandleRef self, double value);
		[DllImport(Base.Import)] private static extern void tsControlArea_setValue(HandleRef self, double horizontal, double vertical);
		[DllImport(Base.Import)] private static extern double tsControlArea_getHorizontalValue(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsControlArea_getVerticalValue(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setFrameAlign(HandleRef self, Align align);
		[DllImport(Base.Import)] private static extern Align tsControlArea_getFrameAlign(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsControlArea_getHorizontalFrame(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsControlArea_getVerticalFrame(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsControlArea_getHorizontalRange(HandleRef self);
		[DllImport(Base.Import)] private static extern double tsControlArea_getVerticalRange(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setHorizontalEnabled(HandleRef self, bool enabled, bool dynamic);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isHorizontalEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isHorizontalDynamic(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isHorizontalHidden(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_getHorizontalScroll_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setVerticalEnabled(HandleRef self, bool enabled, bool dynamic);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isVerticalEnabled(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isVerticalDynamic(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_isVerticalHidden(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlArea_getVerticalScroll_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_setFontSize(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern uint tsControlArea_getFontSize(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlArea_setFontStyle(HandleRef self, in FontStyle style);
		[DllImport(Base.Import)] private static extern FontStyle tsControlArea_getFontStyleConst(HandleRef self);
		[DllImport(Base.Import)] private static extern FontStyle tsControlArea_getFontStyle_c(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setColumns(HandleRef self, uint columns);
		[DllImport(Base.Import)] private static extern uint tsControlArea_getColumns(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setSpacing_cV2(HandleRef self, in Vector2f spacing);
		[DllImport(Base.Import)] private static extern void tsControlArea_setSpacing_ff(HandleRef self, float x, float y);
		[DllImport(Base.Import)] private static extern Vector2f tsControlArea_getSpacing(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlArea_setColumnRatio(HandleRef self, uint index, float ratio);
		[DllImport(Base.Import)] private static extern float tsControlArea_getColumnRatio(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern Vector2f tsControlArea_getControlsSize(HandleRef self);
		[DllImport(Base.Import)] private static extern Vector2f tsControlArea_getControlsOffset(HandleRef self);
		[DllImport(Base.Import)] private static extern Rect tsControlArea_getViewRect(HandleRef self);
	}
	
	// Tellusim::ControlTree
	public sealed class ControlTree : ControlText {
		public delegate void ChangedCallback(ControlTree a0, uint item, IntPtr data_);
		public delegate void ChangedCallback_(IntPtr a0, uint item, IntPtr data_);
		public delegate bool DraggedCallback(ControlTree a0, uint item, IntPtr data_);
		public delegate bool DraggedCallback_(IntPtr a0, uint item, IntPtr data_);
		public delegate void DroppedCallback(ControlTree a0, uint item, IntPtr data_);
		public delegate void DroppedCallback_(IntPtr a0, uint item, IntPtr data_);
		public delegate void ClickedCallback(ControlTree a0, uint item, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, uint item, IntPtr data_);
		public delegate void ExpandedCallback(ControlTree a0, uint item, IntPtr data_);
		public delegate void ExpandedCallback_(IntPtr a0, uint item, IntPtr data_);
		public delegate void SelectedCallback(ControlTree a0, IntPtr data_);
		public delegate void SelectedCallback_(IntPtr a0, IntPtr data_);
		public ControlTree() { self = new HandleRef(this, tsControlTree_new()); owner = true; }
		public ControlTree(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlTree_new_C(ref parent_)); owner = true;
		}
		public ControlTree(ControlTree ptr) { self = new HandleRef(this, tsControlTree_copyPtr(ptr.getSelf())); owner = true; }
		public ControlTree(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlTree_isOwnerPtr(self); }
		public ControlTree(ControlText ptr) { self = new HandleRef(this, tsControlTree_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlTree_baseControlTextPtr(self)); }
		public static new ControlTree Null() { return new ControlTree(IntPtr.Zero); }
		public void setSelectable(bool selectable) { tsControlTree_setSelectable(self, selectable); }
		public bool isSelectable() { return tsControlTree_isSelectable(self); }
		public void setMultiSelection(bool multi_selection) { tsControlTree_setMultiSelection(self, multi_selection); }
		public bool isMultiSelection() { return tsControlTree_isMultiSelection(self); }
		public void setFoldedText(string text) { tsControlTree_setFoldedText_s(self, text); }
		public void setFoldedText(String text) { tsControlTree_setFoldedText_cS(self, text.getSelf()); }
		public string getFoldedText() { return Base.getString(tsControlTree_getFoldedText(self)); }
		public void setExpandedText(string text) { tsControlTree_setExpandedText_s(self, text); }
		public void setExpandedText(String text) { tsControlTree_setExpandedText_cS(self, text.getSelf()); }
		public string getExpandedText() { return Base.getString(tsControlTree_getExpandedText(self)); }
		public void setTexture(Texture texture, uint rows = 1, uint columns = 1) { tsControlTree_setTexture(self, texture.getSelf(), rows, columns); }
		public Texture getTexture() { return new Texture(tsControlTree_getTexture(self)); }
		public void setTextureName(string name, uint rows = 1, uint columns = 1) { tsControlTree_setTextureName_suu(self, name, rows, columns); }
		public void setTextureName(String name, uint rows = 1, uint columns = 1) { tsControlTree_setTextureName_cSuu(self, name.getSelf(), rows, columns); }
		public string getTextureName() { return Base.getString(tsControlTree_getTextureName(self)); }
		public void setTextureGrid(uint rows, uint columns) { tsControlTree_setTextureGrid(self, rows, columns); }
		public uint getTextureRows() { return tsControlTree_getTextureRows(self); }
		public uint getTextureColumns() { return tsControlTree_getTextureColumns(self); }
		public void clearItems() { tsControlTree_clearItems(self); }
		public uint addItem(string text, uint parent = Base.Maxu32, bool expanded = true) { return tsControlTree_addItem_sub(self, text, parent, expanded); }
		public uint addItem(String text, uint parent = Base.Maxu32, bool expanded = true) { return tsControlTree_addItem_cSub(self, text.getSelf(), parent, expanded); }
		public void removeItem(uint item, bool children = false) { tsControlTree_removeItem(self, item, children); }
		public void viewItem(uint item) { tsControlTree_viewItem(self, item); }
		public uint getNumItems() { return tsControlTree_getNumItems(self); }
		public uint getItem(uint index) { return tsControlTree_getItem(self, index); }
		public bool switchItemHidden(uint item, bool children = false) { return tsControlTree_switchItemHidden(self, item, children); }
		public void setItemHidden(uint item, bool hidden, bool children = false) { tsControlTree_setItemHidden(self, item, hidden, children); }
		public bool isItemHidden(uint item) { return tsControlTree_isItemHidden(self, item); }
		public bool switchItemExpanded(uint item, bool children = false) { return tsControlTree_switchItemExpanded(self, item, children); }
		public void setItemExpanded(uint item, bool expanded, bool children = false) { tsControlTree_setItemExpanded(self, item, expanded, children); }
		public bool isItemExpanded(uint item) { return tsControlTree_isItemExpanded(self, item); }
		public bool switchItemSelected(uint item, bool children = false) { return tsControlTree_switchItemSelected(self, item, children); }
		public void setItemSelected(uint item, bool selected, bool children = false) { tsControlTree_setItemSelected(self, item, selected, children); }
		public bool isItemSelected(uint item) { return tsControlTree_isItemSelected(self, item); }
		public void setItemParent(uint item, uint parent) { tsControlTree_setItemParent(self, item, parent); }
		public uint getItemParent(uint item) { return tsControlTree_getItemParent(self, item); }
		public bool isItemParent(uint item, uint parent, bool hierarchy = false) { return tsControlTree_isItemParent(self, item, parent, hierarchy); }
		public void addItemChild(uint item, uint child) { tsControlTree_addItemChild(self, item, child); }
		public void removeItemChild(uint item, uint child) { tsControlTree_removeItemChild(self, item, child); }
		public void addItemChildren(uint item, uint[] children) { tsControlTree_addItemChildren(self, item, children, (uint)children.Length); }
		public void removeItemChildren(uint item, uint[] children) { tsControlTree_removeItemChildren(self, item, children, (uint)children.Length); }
		public uint findItemChild(uint item, uint child) { return tsControlTree_findItemChild(self, item, child); }
		public bool isItemChild(uint item, uint child) { return tsControlTree_isItemChild(self, item, child); }
		public uint getNumItemChildren(uint item) { return tsControlTree_getNumItemChildren(self, item); }
		public uint getItemChild(uint item, uint index) { return tsControlTree_getItemChild(self, item, index); }
		public void setItemText(uint item, string text) { tsControlTree_setItemText_us(self, item, text); }
		public void setItemText(uint item, String text) { tsControlTree_setItemText_ucS(self, item, text.getSelf()); }
		public string getItemText(uint item) { return Base.getString(tsControlTree_getItemText(self, item)); }
		public uint findItemText(string text) { return tsControlTree_findItemText_cs(self, text); }
		public uint findItemText(String text) { return tsControlTree_findItemText_ccS(self, text.getSelf()); }
		public void setItemColor(uint item, in Color color) { tsControlTree_setItemColor(self, item, in color); }
		public Color getItemColor(uint item) { return tsControlTree_getItemColor(self, item); }
		public void setItemTexture(uint item, uint row, uint column = 0) { tsControlTree_setItemTexture(self, item, row, column); }
		public uint getItemTextureRow(uint item) { return tsControlTree_getItemTextureRow(self, item); }
		public uint getItemTextureColumn(uint item) { return tsControlTree_getItemTextureColumn(self, item); }
		public void setItemData(uint item, IntPtr data) { tsControlTree_setItemData(self, item, data); }
		public IntPtr getItemData(uint item) { return tsControlTree_getItemData(self, item); }
		public uint getFocusedItem() { return tsControlTree_getFocusedItem(self); }
		public void setCurrentItem(uint item, bool select = false, bool view = false, bool callback = false) { tsControlTree_setCurrentItem(self, item, select, view, callback); }
		public uint getCurrentItem() { return tsControlTree_getCurrentItem(self); }
		public string getCurrentText() { return Base.getString(tsControlTree_getCurrentText(self)); }
		public void setSelection() { tsControlTree_setSelection(self); }
		public void clearSelection() { tsControlTree_clearSelection(self); }
		public void inverseSelection() { tsControlTree_inverseSelection(self); }
		public uint getNumSelectedItems() { return tsControlTree_getNumSelectedItems(self); }
		public uint getSelectedItem(uint index) { return tsControlTree_getSelectedItem(self, index); }
		public void setChangedCallback(ChangedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.ChangedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) ChangedCallback_71 = GCHandle.Alloc(func_);
			tsControlTree_setChangedCallback(self, Base.getFunc(func_), data);
		}
		public void setDraggedCallback(DraggedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.DraggedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { return func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) DraggedCallback_73 = GCHandle.Alloc(func_);
			tsControlTree_setDraggedCallback(self, Base.getFunc(func_), data);
		}
		public void setDroppedCallback(DroppedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.DroppedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) DroppedCallback_75 = GCHandle.Alloc(func_);
			tsControlTree_setDroppedCallback(self, Base.getFunc(func_), data);
		}
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) ClickedCallback_77 = GCHandle.Alloc(func_);
			tsControlTree_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public void setClicked2Callback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) ClickedCallback_78 = GCHandle.Alloc(func_);
			tsControlTree_setClicked2Callback(self, Base.getFunc(func_), data);
		}
		public void setClickedRightCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) ClickedCallback_79 = GCHandle.Alloc(func_);
			tsControlTree_setClickedRightCallback(self, Base.getFunc(func_), data);
		}
		public void setExpandedCallback(ExpandedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.ExpandedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, uint item_, IntPtr data_) => { func(new ControlTree(a0_), item_, data_); };
			if(func_ != null) ExpandedCallback_83 = GCHandle.Alloc(func_);
			tsControlTree_setExpandedCallback(self, Base.getFunc(func_), data);
		}
		public void setSelectedCallback(SelectedCallback func, IntPtr data = new IntPtr()) {
			ControlTree.SelectedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlTree(a0_), data_); };
			if(func_ != null) SelectedCallback_85 = GCHandle.Alloc(func_);
			tsControlTree_setSelectedCallback(self, Base.getFunc(func_), data);
		}
		private GCHandle ChangedCallback_71;
		private GCHandle DraggedCallback_73;
		private GCHandle DroppedCallback_75;
		private GCHandle ClickedCallback_77;
		private GCHandle ClickedCallback_78;
		private GCHandle ClickedCallback_79;
		private GCHandle ExpandedCallback_83;
		private GCHandle SelectedCallback_85;
		public override string ToString() { return "Tellusim.ControlTree: Valid: " + tsControlTree_isValidPtr(self) + "; Owner: " + tsControlTree_isOwnerPtr(self) + "; Const: " + tsControlTree_isConstPtr(self) + "; Count: " + tsControlTree_getCountPtr(self) + "; Internal: 0x" + tsControlTree_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlTree ptr) { return (ptr != null && tsControlTree_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern void tsControlTree_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlTree_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlTree_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setSelectable(HandleRef self, bool selectable);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isSelectable(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setMultiSelection(HandleRef self, bool multi_selection);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isMultiSelection(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setFoldedText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlTree_setFoldedText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getFoldedText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setExpandedText_s(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern void tsControlTree_setExpandedText_cS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getExpandedText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setTexture(HandleRef self, HandleRef texture, uint rows, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getTexture(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setTextureName_suu(HandleRef self, string name, uint rows, uint columns);
		[DllImport(Base.Import)] private static extern void tsControlTree_setTextureName_cSuu(HandleRef self, HandleRef name, uint rows, uint columns);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getTextureName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setTextureGrid(HandleRef self, uint rows, uint columns);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getTextureRows(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getTextureColumns(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_clearItems(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlTree_addItem_sub(HandleRef self, string text, uint parent, bool expanded);
		[DllImport(Base.Import)] private static extern uint tsControlTree_addItem_cSub(HandleRef self, HandleRef text, uint parent, bool expanded);
		[DllImport(Base.Import)] private static extern void tsControlTree_removeItem(HandleRef self, uint item, bool children);
		[DllImport(Base.Import)] private static extern void tsControlTree_viewItem(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getNumItems(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getItem(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern bool tsControlTree_switchItemHidden(HandleRef self, uint item, bool children);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemHidden(HandleRef self, uint item, bool hidden, bool children);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isItemHidden(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern bool tsControlTree_switchItemExpanded(HandleRef self, uint item, bool children);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemExpanded(HandleRef self, uint item, bool expanded, bool children);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isItemExpanded(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern bool tsControlTree_switchItemSelected(HandleRef self, uint item, bool children);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemSelected(HandleRef self, uint item, bool selected, bool children);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isItemSelected(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemParent(HandleRef self, uint item, uint parent);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getItemParent(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isItemParent(HandleRef self, uint item, uint parent, bool hierarchy);
		[DllImport(Base.Import)] private static extern void tsControlTree_addItemChild(HandleRef self, uint item, uint child);
		[DllImport(Base.Import)] private static extern void tsControlTree_removeItemChild(HandleRef self, uint item, uint child);
		[DllImport(Base.Import)] private static extern void tsControlTree_addItemChildren(HandleRef self, uint item, uint[] children, uint children_size);
		[DllImport(Base.Import)] private static extern void tsControlTree_removeItemChildren(HandleRef self, uint item, uint[] children, uint children_size);
		[DllImport(Base.Import)] private static extern uint tsControlTree_findItemChild(HandleRef self, uint item, uint child);
		[DllImport(Base.Import)] private static extern bool tsControlTree_isItemChild(HandleRef self, uint item, uint child);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getNumItemChildren(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getItemChild(HandleRef self, uint item, uint index);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemText_us(HandleRef self, uint item, string text);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemText_ucS(HandleRef self, uint item, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getItemText(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern uint tsControlTree_findItemText_cs(HandleRef self, string text);
		[DllImport(Base.Import)] private static extern uint tsControlTree_findItemText_ccS(HandleRef self, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemColor(HandleRef self, uint item, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlTree_getItemColor(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemTexture(HandleRef self, uint item, uint row, uint column);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getItemTextureRow(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getItemTextureColumn(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern void tsControlTree_setItemData(HandleRef self, uint item, IntPtr data);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getItemData(HandleRef self, uint item);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getFocusedItem(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setCurrentItem(HandleRef self, uint item, bool select, bool view, bool callback);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getCurrentItem(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlTree_getCurrentText(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_setSelection(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_clearSelection(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlTree_inverseSelection(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getNumSelectedItems(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlTree_getSelectedItem(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsControlTree_setChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setDraggedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setDroppedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setClicked2Callback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setClickedRightCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setExpandedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsControlTree_setSelectedCallback(HandleRef self, IntPtr func, IntPtr data_);
	}
	
	// Tellusim::ControlEdit
	public sealed class ControlEdit : ControlText {
		public enum EditMode : uint {
			Text,
			Password,
			Number,
			Signed,
			Unsigned,
			Hexadecimal,
		}
		public delegate void ClickedCallback(ControlEdit a0, IntPtr data_);
		public delegate void ClickedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ChangedCallback(ControlEdit a0, IntPtr data_);
		public delegate void ChangedCallback_(IntPtr a0, IntPtr data_);
		public delegate void ReturnedCallback(ControlEdit a0, IntPtr data_);
		public delegate void ReturnedCallback_(IntPtr a0, IntPtr data_);
		public ControlEdit() { self = new HandleRef(this, tsControlEdit_new()); owner = true; }
		public ControlEdit(in Control parent) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlEdit_new_C(ref parent_)); owner = true;
		}
		public ControlEdit(in Control parent, string text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlEdit_new_Cs(ref parent_, text)); owner = true;
		}
		public ControlEdit(in Control parent, String text) {
			IntPtr parent_ = (parent != null) ? parent.getSelfPtr() : IntPtr.Zero;
			self = new HandleRef(this, tsControlEdit_new_CcS(ref parent_, text.getSelf())); owner = true;
		}
		public ControlEdit(ControlEdit ptr) { self = new HandleRef(this, tsControlEdit_copyPtr(ptr.getSelf())); owner = true; }
		public ControlEdit(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsControlEdit_isOwnerPtr(self); }
		public ControlEdit(ControlText ptr) { self = new HandleRef(this, tsControlEdit_castControlTextPtr(ptr.getSelf())); }
		public ControlText toControlText() { return new ControlText(tsControlEdit_baseControlTextPtr(self)); }
		public static new ControlEdit Null() { return new ControlEdit(IntPtr.Zero); }
		public void setFrame(bool frame) { tsControlEdit_setFrame(self, frame); }
		public bool getFrame() { return tsControlEdit_getFrame(self); }
		public void setBackground(bool background) { tsControlEdit_setBackground(self, background); }
		public bool getBackground() { return tsControlEdit_getBackground(self); }
		public void setEditColor(in Color color) { tsControlEdit_setEditColor(self, in color); }
		public Color getEditColor() { return tsControlEdit_getEditColor(self); }
		public void setEditMode(EditMode mode) { tsControlEdit_setEditMode(self, mode); }
		public EditMode getEditMode() { return tsControlEdit_getEditMode(self); }
		public void setPasswordCode(uint code) { tsControlEdit_setPasswordCode(self, code); }
		public uint getPasswordCode() { return tsControlEdit_getPasswordCode(self); }
		public uint getNumCodes() { return tsControlEdit_getNumCodes(self); }
		public uint[] getCodes() { return tsControlEdit_getCodes(self); }
		public void setCurrentIndex(uint index, uint selection_index = Base.Maxu32) { tsControlEdit_setCurrentIndex(self, index, selection_index); }
		public uint getCurrentIndex() { return tsControlEdit_getCurrentIndex(self); }
		public uint getSelectionIndex() { return tsControlEdit_getSelectionIndex(self); }
		public void setSelection(bool current = false, bool changed = false) { tsControlEdit_setSelection(self, current, changed); }
		public void clearSelection() { tsControlEdit_clearSelection(self); }
		public string getSelectedText() { return Base.getString(tsControlEdit_getSelectedText(self)); }
		public bool updateKeyboard(ControlRoot root, uint key, uint code) { return tsControlEdit_updateKeyboard(self, root.getSelf(), key, code); }
		public void setClickedCallback(ClickedCallback func, IntPtr data = new IntPtr()) {
			ControlEdit.ClickedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlEdit(a0_), data_); };
			if(func_ != null) ClickedCallback_23 = GCHandle.Alloc(func_);
			tsControlEdit_setClickedCallback(self, Base.getFunc(func_), data);
		}
		public bool isClicked() { return tsControlEdit_isClicked(self); }
		public void setChangedCallback(ChangedCallback func, IntPtr data = new IntPtr()) {
			ControlEdit.ChangedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlEdit(a0_), data_); };
			if(func_ != null) ChangedCallback_26 = GCHandle.Alloc(func_);
			tsControlEdit_setChangedCallback(self, Base.getFunc(func_), data);
		}
		public bool isChanged() { return tsControlEdit_isChanged(self); }
		public void setReturnedCallback(ReturnedCallback func, IntPtr data = new IntPtr()) {
			ControlEdit.ReturnedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr a0_, IntPtr data_) => { func(new ControlEdit(a0_), data_); };
			if(func_ != null) ReturnedCallback_29 = GCHandle.Alloc(func_);
			tsControlEdit_setReturnedCallback(self, Base.getFunc(func_), data);
		}
		public bool isReturned() { return tsControlEdit_isReturned(self); }
		public CanvasMesh getCanvasMesh() { return new CanvasMesh(tsControlEdit_getCanvasMesh(self)); }
		private GCHandle ClickedCallback_23;
		private GCHandle ChangedCallback_26;
		private GCHandle ReturnedCallback_29;
		public override string ToString() { return "Tellusim.ControlEdit: Valid: " + tsControlEdit_isValidPtr(self) + "; Owner: " + tsControlEdit_isOwnerPtr(self) + "; Const: " + tsControlEdit_isConstPtr(self) + "; Count: " + tsControlEdit_getCountPtr(self) + "; Internal: 0x" + tsControlEdit_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(ControlEdit ptr) { return (ptr != null && tsControlEdit_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_new();
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_new_C(ref IntPtr parent);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_new_Cs(ref IntPtr parent, string text);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_new_CcS(ref IntPtr parent, HandleRef text);
		[DllImport(Base.Import)] private static extern void tsControlEdit_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlEdit_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_equalControlTextPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_castControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_baseControlTextPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setFrame(HandleRef self, bool frame);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_getFrame(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setBackground(HandleRef self, bool background);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_getBackground(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setEditColor(HandleRef self, in Color color);
		[DllImport(Base.Import)] private static extern Color tsControlEdit_getEditColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setEditMode(HandleRef self, EditMode mode);
		[DllImport(Base.Import)] private static extern EditMode tsControlEdit_getEditMode(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setPasswordCode(HandleRef self, uint code);
		[DllImport(Base.Import)] private static extern uint tsControlEdit_getPasswordCode(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlEdit_getNumCodes(HandleRef self);
		[DllImport(Base.Import)] private static extern uint[] tsControlEdit_getCodes(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setCurrentIndex(HandleRef self, uint index, uint selection_index);
		[DllImport(Base.Import)] private static extern uint tsControlEdit_getCurrentIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsControlEdit_getSelectionIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setSelection(HandleRef self, bool current, bool changed);
		[DllImport(Base.Import)] private static extern void tsControlEdit_clearSelection(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_getSelectedText(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_updateKeyboard(HandleRef self, HandleRef root, uint key, uint code);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setClickedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_isClicked(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_isChanged(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsControlEdit_setReturnedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsControlEdit_isReturned(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsControlEdit_getCanvasMesh(HandleRef self);
	}
	
	// Tellusim::DialogMessage
	public sealed class DialogMessage {
		public enum Flags : uint {
			None = 0,
			Yes = 1,
			No = 2,
			Ok = 4,
			Cancel = 8,
			Close = 16,
			Message = 32,
			Warning = 64,
			Question = 128,
			Error = 256,
			Mouse = 512,
			YesNo = 3,
			OkCancel = 12,
			Default = 4,
			Num = 10,
		}
		public enum Result : uint {
			Close = 0,
			Cancel,
			Ok,
			No,
			Yes,
			NumResults,
		}
		public delegate bool UpdateCallback(IntPtr data_);
		public DialogMessage(string title = "", string message = "") { self = new HandleRef(this, tsDialogMessage_new_ss(title, message)); owner = true; }
		public DialogMessage(String title, string message = "") { self = new HandleRef(this, tsDialogMessage_new_cSs(title.getSelf(), message)); owner = true; }
		public DialogMessage(string title, String message) { self = new HandleRef(this, tsDialogMessage_new_scS(title, message.getSelf())); owner = true; }
		public DialogMessage(String title, String message) { self = new HandleRef(this, tsDialogMessage_new_cScS(title.getSelf(), message.getSelf())); owner = true; }
		public DialogMessage(DialogMessage ptr) { self = new HandleRef(this, tsDialogMessage_copyPtr(ptr.getSelf())); owner = true; }
		public DialogMessage(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogMessage_isOwnerPtr(self); }
		public static DialogMessage Null() { return new DialogMessage(IntPtr.Zero); }
		~DialogMessage() { if(owner) tsDialogMessage_delete(self); }
		public bool equalPtr(DialogMessage ptr) { return tsDialogMessage_equalPtr(self, ptr.getSelf()); }
		public DialogMessage clonePtr() { return new DialogMessage(tsDialogMessage_clonePtr(self)); }
		public void clearPtr() { tsDialogMessage_clearPtr(self); }
		public void destroyPtr() { tsDialogMessage_destroyPtr(self); }
		public void acquirePtr() { tsDialogMessage_acquirePtr(self); }
		public void unacquirePtr() { tsDialogMessage_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogMessage_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogMessage_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogMessage_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogMessage_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogMessage_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogMessage_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogMessage_getPositionX(self); }
		public int getPositionY() { return tsDialogMessage_getPositionY(self); }
		public void setTitle(string title) { tsDialogMessage_setTitle_s(self, title); }
		public void setTitle(String title) { tsDialogMessage_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsDialogMessage_getTitle(self)); }
		public void setMessage(string message) { tsDialogMessage_setMessage_s(self, message); }
		public void setMessage(String message) { tsDialogMessage_setMessage_cS(self, message.getSelf()); }
		public string getMessage() { return Base.getString(tsDialogMessage_getMessage(self)); }
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_13 = GCHandle.Alloc(func);
			tsDialogMessage_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public Result run(Flags flags = Flags.Default) { return tsDialogMessage_run(self, flags); }
		private GCHandle UpdateCallback_13;
		public override string ToString() { return "Tellusim.DialogMessage: Valid: " + tsDialogMessage_isValidPtr(self) + "; Owner: " + tsDialogMessage_isOwnerPtr(self) + "; Const: " + tsDialogMessage_isConstPtr(self) + "; Count: " + tsDialogMessage_getCountPtr(self) + "; Internal: 0x" + tsDialogMessage_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogMessage ptr) { return (ptr != null && tsDialogMessage_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_new_ss(string title, string message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_new_cSs(HandleRef title, string message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_new_scS(string title, HandleRef message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_new_cScS(HandleRef title, HandleRef message);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMessage_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMessage_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMessage_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMessage_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogMessage_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogMessage_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogMessage_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_setMessage_s(HandleRef self, string message);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_setMessage_cS(HandleRef self, HandleRef message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMessage_getMessage(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMessage_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Result tsDialogMessage_run(HandleRef self, Flags flags);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DialogFileOpen
	public sealed class DialogFileOpen {
		public enum Flags : uint {
			None = 0,
			Hidden = 1,
			Mouse = 2,
			Default = 0,
			Num = 2,
		}
		public enum Result : uint {
			Cancel = 0,
			Ok,
			NumResults,
		}
		public delegate bool UpdateCallback(IntPtr data_);
		public DialogFileOpen(string title = "", string name = "") { self = new HandleRef(this, tsDialogFileOpen_new_ss(title, name)); owner = true; }
		public DialogFileOpen(String title, string name = "") { self = new HandleRef(this, tsDialogFileOpen_new_cSs(title.getSelf(), name)); owner = true; }
		public DialogFileOpen(string title, String name) { self = new HandleRef(this, tsDialogFileOpen_new_scS(title, name.getSelf())); owner = true; }
		public DialogFileOpen(String title, String name) { self = new HandleRef(this, tsDialogFileOpen_new_cScS(title.getSelf(), name.getSelf())); owner = true; }
		public DialogFileOpen(DialogFileOpen ptr) { self = new HandleRef(this, tsDialogFileOpen_copyPtr(ptr.getSelf())); owner = true; }
		public DialogFileOpen(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogFileOpen_isOwnerPtr(self); }
		public static DialogFileOpen Null() { return new DialogFileOpen(IntPtr.Zero); }
		~DialogFileOpen() { if(owner) tsDialogFileOpen_delete(self); }
		public bool equalPtr(DialogFileOpen ptr) { return tsDialogFileOpen_equalPtr(self, ptr.getSelf()); }
		public DialogFileOpen clonePtr() { return new DialogFileOpen(tsDialogFileOpen_clonePtr(self)); }
		public void clearPtr() { tsDialogFileOpen_clearPtr(self); }
		public void destroyPtr() { tsDialogFileOpen_destroyPtr(self); }
		public void acquirePtr() { tsDialogFileOpen_acquirePtr(self); }
		public void unacquirePtr() { tsDialogFileOpen_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogFileOpen_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogFileOpen_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogFileOpen_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogFileOpen_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogFileOpen_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogFileOpen_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogFileOpen_getPositionX(self); }
		public int getPositionY() { return tsDialogFileOpen_getPositionY(self); }
		public void setTitle(string title) { tsDialogFileOpen_setTitle_s(self, title); }
		public void setTitle(String title) { tsDialogFileOpen_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsDialogFileOpen_getTitle(self)); }
		public void setFilter(string filter) { tsDialogFileOpen_setFilter_s(self, filter); }
		public void setFilter(String filter) { tsDialogFileOpen_setFilter_cS(self, filter.getSelf()); }
		public string getFilter() { return Base.getString(tsDialogFileOpen_getFilter(self)); }
		public void setFile(string name) { tsDialogFileOpen_setFile_s(self, name); }
		public void setFile(String name) { tsDialogFileOpen_setFile_cS(self, name.getSelf()); }
		public string getFile() { return Base.getString(tsDialogFileOpen_getFile(self)); }
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_16 = GCHandle.Alloc(func);
			tsDialogFileOpen_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public Result run(Flags flags = Flags.Default) { return tsDialogFileOpen_run(self, flags); }
		private GCHandle UpdateCallback_16;
		public override string ToString() { return "Tellusim.DialogFileOpen: Valid: " + tsDialogFileOpen_isValidPtr(self) + "; Owner: " + tsDialogFileOpen_isOwnerPtr(self) + "; Const: " + tsDialogFileOpen_isConstPtr(self) + "; Count: " + tsDialogFileOpen_getCountPtr(self) + "; Internal: 0x" + tsDialogFileOpen_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogFileOpen ptr) { return (ptr != null && tsDialogFileOpen_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_new_ss(string title, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_new_cSs(HandleRef title, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_new_scS(string title, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_new_cScS(HandleRef title, HandleRef name);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileOpen_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileOpen_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileOpen_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileOpen_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogFileOpen_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogFileOpen_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogFileOpen_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setFilter_s(HandleRef self, string filter);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setFilter_cS(HandleRef self, HandleRef filter);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_getFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setFile_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setFile_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileOpen_getFile(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileOpen_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Result tsDialogFileOpen_run(HandleRef self, Flags flags);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DialogFileSave
	public sealed class DialogFileSave {
		public enum Flags : uint {
			None = 0,
			Hidden = 1,
			Overwrite = 2,
			Mouse = 4,
			Default = 2,
			Num = 3,
		}
		public enum Result : uint {
			Cancel = 0,
			Ok,
			NumResults,
		}
		public delegate bool UpdateCallback(IntPtr data_);
		public DialogFileSave(string title = "", string name = "") { self = new HandleRef(this, tsDialogFileSave_new_ss(title, name)); owner = true; }
		public DialogFileSave(String title, string name = "") { self = new HandleRef(this, tsDialogFileSave_new_cSs(title.getSelf(), name)); owner = true; }
		public DialogFileSave(string title, String name) { self = new HandleRef(this, tsDialogFileSave_new_scS(title, name.getSelf())); owner = true; }
		public DialogFileSave(String title, String name) { self = new HandleRef(this, tsDialogFileSave_new_cScS(title.getSelf(), name.getSelf())); owner = true; }
		public DialogFileSave(DialogFileSave ptr) { self = new HandleRef(this, tsDialogFileSave_copyPtr(ptr.getSelf())); owner = true; }
		public DialogFileSave(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogFileSave_isOwnerPtr(self); }
		public static DialogFileSave Null() { return new DialogFileSave(IntPtr.Zero); }
		~DialogFileSave() { if(owner) tsDialogFileSave_delete(self); }
		public bool equalPtr(DialogFileSave ptr) { return tsDialogFileSave_equalPtr(self, ptr.getSelf()); }
		public DialogFileSave clonePtr() { return new DialogFileSave(tsDialogFileSave_clonePtr(self)); }
		public void clearPtr() { tsDialogFileSave_clearPtr(self); }
		public void destroyPtr() { tsDialogFileSave_destroyPtr(self); }
		public void acquirePtr() { tsDialogFileSave_acquirePtr(self); }
		public void unacquirePtr() { tsDialogFileSave_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogFileSave_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogFileSave_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogFileSave_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogFileSave_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogFileSave_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogFileSave_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogFileSave_getPositionX(self); }
		public int getPositionY() { return tsDialogFileSave_getPositionY(self); }
		public void setTitle(string title) { tsDialogFileSave_setTitle_s(self, title); }
		public void setTitle(String title) { tsDialogFileSave_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsDialogFileSave_getTitle(self)); }
		public void setFilter(string filter) { tsDialogFileSave_setFilter_s(self, filter); }
		public void setFilter(String filter) { tsDialogFileSave_setFilter_cS(self, filter.getSelf()); }
		public string getFilter() { return Base.getString(tsDialogFileSave_getFilter(self)); }
		public void setFile(string name) { tsDialogFileSave_setFile_s(self, name); }
		public void setFile(String name) { tsDialogFileSave_setFile_cS(self, name.getSelf()); }
		public string getFile() { return Base.getString(tsDialogFileSave_getFile(self)); }
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_16 = GCHandle.Alloc(func);
			tsDialogFileSave_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public Result run(Flags flags = Flags.Default) { return tsDialogFileSave_run(self, flags); }
		private GCHandle UpdateCallback_16;
		public override string ToString() { return "Tellusim.DialogFileSave: Valid: " + tsDialogFileSave_isValidPtr(self) + "; Owner: " + tsDialogFileSave_isOwnerPtr(self) + "; Const: " + tsDialogFileSave_isConstPtr(self) + "; Count: " + tsDialogFileSave_getCountPtr(self) + "; Internal: 0x" + tsDialogFileSave_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogFileSave ptr) { return (ptr != null && tsDialogFileSave_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_new_ss(string title, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_new_cSs(HandleRef title, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_new_scS(string title, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_new_cScS(HandleRef title, HandleRef name);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileSave_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileSave_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileSave_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogFileSave_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogFileSave_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogFileSave_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogFileSave_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setFilter_s(HandleRef self, string filter);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setFilter_cS(HandleRef self, HandleRef filter);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_getFilter(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setFile_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setFile_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogFileSave_getFile(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogFileSave_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Result tsDialogFileSave_run(HandleRef self, Flags flags);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DialogDirectory
	public sealed class DialogDirectory {
		public enum Flags : uint {
			None = 0,
			Mouse = 1,
			Default = 0,
			Num = 1,
		}
		public enum Result : uint {
			Cancel = 0,
			Ok,
			NumResults,
		}
		public delegate bool UpdateCallback(IntPtr data_);
		public DialogDirectory(string title = "", string name = "") { self = new HandleRef(this, tsDialogDirectory_new_ss(title, name)); owner = true; }
		public DialogDirectory(String title, string name = "") { self = new HandleRef(this, tsDialogDirectory_new_cSs(title.getSelf(), name)); owner = true; }
		public DialogDirectory(string title, String name) { self = new HandleRef(this, tsDialogDirectory_new_scS(title, name.getSelf())); owner = true; }
		public DialogDirectory(String title, String name) { self = new HandleRef(this, tsDialogDirectory_new_cScS(title.getSelf(), name.getSelf())); owner = true; }
		public DialogDirectory(DialogDirectory ptr) { self = new HandleRef(this, tsDialogDirectory_copyPtr(ptr.getSelf())); owner = true; }
		public DialogDirectory(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogDirectory_isOwnerPtr(self); }
		public static DialogDirectory Null() { return new DialogDirectory(IntPtr.Zero); }
		~DialogDirectory() { if(owner) tsDialogDirectory_delete(self); }
		public bool equalPtr(DialogDirectory ptr) { return tsDialogDirectory_equalPtr(self, ptr.getSelf()); }
		public DialogDirectory clonePtr() { return new DialogDirectory(tsDialogDirectory_clonePtr(self)); }
		public void clearPtr() { tsDialogDirectory_clearPtr(self); }
		public void destroyPtr() { tsDialogDirectory_destroyPtr(self); }
		public void acquirePtr() { tsDialogDirectory_acquirePtr(self); }
		public void unacquirePtr() { tsDialogDirectory_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogDirectory_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogDirectory_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogDirectory_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogDirectory_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogDirectory_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogDirectory_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogDirectory_getPositionX(self); }
		public int getPositionY() { return tsDialogDirectory_getPositionY(self); }
		public void setTitle(string title) { tsDialogDirectory_setTitle_s(self, title); }
		public void setTitle(String title) { tsDialogDirectory_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsDialogDirectory_getTitle(self)); }
		public void setDirectory(string name) { tsDialogDirectory_setDirectory_s(self, name); }
		public void setDirectory(String name) { tsDialogDirectory_setDirectory_cS(self, name.getSelf()); }
		public string getDirectory() { return Base.getString(tsDialogDirectory_getDirectory(self)); }
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_13 = GCHandle.Alloc(func);
			tsDialogDirectory_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public Result run(Flags flags = Flags.Default) { return tsDialogDirectory_run(self, flags); }
		private GCHandle UpdateCallback_13;
		public override string ToString() { return "Tellusim.DialogDirectory: Valid: " + tsDialogDirectory_isValidPtr(self) + "; Owner: " + tsDialogDirectory_isOwnerPtr(self) + "; Const: " + tsDialogDirectory_isConstPtr(self) + "; Count: " + tsDialogDirectory_getCountPtr(self) + "; Internal: 0x" + tsDialogDirectory_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogDirectory ptr) { return (ptr != null && tsDialogDirectory_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_new_ss(string title, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_new_cSs(HandleRef title, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_new_scS(string title, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_new_cScS(HandleRef title, HandleRef name);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogDirectory_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogDirectory_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogDirectory_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogDirectory_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogDirectory_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogDirectory_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogDirectory_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_setDirectory_s(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_setDirectory_cS(HandleRef self, HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogDirectory_getDirectory(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogDirectory_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Result tsDialogDirectory_run(HandleRef self, Flags flags);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DialogProgress
	public sealed class DialogProgress {
		public enum Flags : uint {
			None = 0,
			Mouse = 1,
			Default = 0,
			Num = 1,
		}
		public enum Result : uint {
			Cancel = 0,
			Ok,
			NumResults,
		}
		public DialogProgress(string title = "", string message = "") { self = new HandleRef(this, tsDialogProgress_new_ss(title, message)); owner = true; }
		public DialogProgress(String title, string message = "") { self = new HandleRef(this, tsDialogProgress_new_cSs(title.getSelf(), message)); owner = true; }
		public DialogProgress(string title, String message) { self = new HandleRef(this, tsDialogProgress_new_scS(title, message.getSelf())); owner = true; }
		public DialogProgress(String title, String message) { self = new HandleRef(this, tsDialogProgress_new_cScS(title.getSelf(), message.getSelf())); owner = true; }
		public DialogProgress(DialogProgress ptr) { self = new HandleRef(this, tsDialogProgress_copyPtr(ptr.getSelf())); owner = true; }
		public DialogProgress(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogProgress_isOwnerPtr(self); }
		public static DialogProgress Null() { return new DialogProgress(IntPtr.Zero); }
		~DialogProgress() { if(owner) tsDialogProgress_delete(self); }
		public bool equalPtr(DialogProgress ptr) { return tsDialogProgress_equalPtr(self, ptr.getSelf()); }
		public DialogProgress clonePtr() { return new DialogProgress(tsDialogProgress_clonePtr(self)); }
		public void clearPtr() { tsDialogProgress_clearPtr(self); }
		public void destroyPtr() { tsDialogProgress_destroyPtr(self); }
		public void acquirePtr() { tsDialogProgress_acquirePtr(self); }
		public void unacquirePtr() { tsDialogProgress_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogProgress_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogProgress_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogProgress_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogProgress_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogProgress_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogProgress_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogProgress_getPositionX(self); }
		public int getPositionY() { return tsDialogProgress_getPositionY(self); }
		public void setTitle(string title) { tsDialogProgress_setTitle_s(self, title); }
		public void setTitle(String title) { tsDialogProgress_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsDialogProgress_getTitle(self)); }
		public void setMessage(string message) { tsDialogProgress_setMessage_s(self, message); }
		public void setMessage(String message) { tsDialogProgress_setMessage_cS(self, message.getSelf()); }
		public string getMessage() { return Base.getString(tsDialogProgress_getMessage(self)); }
		public void setProgress(uint progress) { tsDialogProgress_setProgress(self, progress); }
		public uint getProgress() { return tsDialogProgress_getProgress(self); }
		public Result run(Flags flags = Flags.Default) { return tsDialogProgress_run(self, flags); }
		public void close() { tsDialogProgress_close(self); }
		public override string ToString() { return "Tellusim.DialogProgress: Valid: " + tsDialogProgress_isValidPtr(self) + "; Owner: " + tsDialogProgress_isOwnerPtr(self) + "; Const: " + tsDialogProgress_isConstPtr(self) + "; Count: " + tsDialogProgress_getCountPtr(self) + "; Internal: 0x" + tsDialogProgress_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogProgress ptr) { return (ptr != null && tsDialogProgress_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_new_ss(string title, string message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_new_cSs(HandleRef title, string message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_new_scS(string title, HandleRef message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_new_cScS(HandleRef title, HandleRef message);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogProgress_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogProgress_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogProgress_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogProgress_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogProgress_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogProgress_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogProgress_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_setMessage_s(HandleRef self, string message);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_setMessage_cS(HandleRef self, HandleRef message);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogProgress_getMessage(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_setProgress(HandleRef self, uint progress);
		[DllImport(Base.Import)] private static extern uint tsDialogProgress_getProgress(HandleRef self);
		[DllImport(Base.Import)] private static extern Result tsDialogProgress_run(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern void tsDialogProgress_close(HandleRef self);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DialogColor
	public sealed class DialogColor {
		public enum Flags : uint {
			None = 0,
			Alpha = 1,
			Mouse = 2,
			Default = 0,
			Num = 2,
		}
		public enum Result : uint {
			Cancel = 0,
			Ok,
			NumResults,
		}
		public delegate void ChangedCallback(Color a0, IntPtr data_);
		public delegate bool UpdateCallback(IntPtr data_);
		public DialogColor(string title, in Color color) { self = new HandleRef(this, tsDialogColor_new_scC(title, in color)); owner = true; }
		public DialogColor(String title, in Color color) { self = new HandleRef(this, tsDialogColor_new_cScC(title.getSelf(), in color)); owner = true; }
		public DialogColor(DialogColor ptr) { self = new HandleRef(this, tsDialogColor_copyPtr(ptr.getSelf())); owner = true; }
		public DialogColor(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogColor_isOwnerPtr(self); }
		public static DialogColor Null() { return new DialogColor(IntPtr.Zero); }
		~DialogColor() { if(owner) tsDialogColor_delete(self); }
		public bool equalPtr(DialogColor ptr) { return tsDialogColor_equalPtr(self, ptr.getSelf()); }
		public DialogColor clonePtr() { return new DialogColor(tsDialogColor_clonePtr(self)); }
		public void clearPtr() { tsDialogColor_clearPtr(self); }
		public void destroyPtr() { tsDialogColor_destroyPtr(self); }
		public void acquirePtr() { tsDialogColor_acquirePtr(self); }
		public void unacquirePtr() { tsDialogColor_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogColor_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogColor_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogColor_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogColor_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogColor_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogColor_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogColor_getPositionX(self); }
		public int getPositionY() { return tsDialogColor_getPositionY(self); }
		public void setTitle(string title) { tsDialogColor_setTitle_s(self, title); }
		public void setTitle(String title) { tsDialogColor_setTitle_cS(self, title.getSelf()); }
		public string getTitle() { return Base.getString(tsDialogColor_getTitle(self)); }
		public void setColor(in Color color, bool callback = false) { tsDialogColor_setColor(self, in color, callback); }
		public Color getColor() { return tsDialogColor_getColor(self); }
		public void setChangedCallback(ChangedCallback func, IntPtr data = new IntPtr()) {
			if(func != null) ChangedCallback_10 = GCHandle.Alloc(func);
			tsDialogColor_setChangedCallback(self, Base.getFunc(func), data);
		}
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_12 = GCHandle.Alloc(func);
			tsDialogColor_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public Result run(Flags flags = Flags.Default) { return tsDialogColor_run(self, flags); }
		private GCHandle ChangedCallback_10;
		private GCHandle UpdateCallback_12;
		public override string ToString() { return "Tellusim.DialogColor: Valid: " + tsDialogColor_isValidPtr(self) + "; Owner: " + tsDialogColor_isOwnerPtr(self) + "; Const: " + tsDialogColor_isConstPtr(self) + "; Count: " + tsDialogColor_getCountPtr(self) + "; Internal: 0x" + tsDialogColor_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogColor ptr) { return (ptr != null && tsDialogColor_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogColor_new_scC(string title, in Color color);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogColor_new_cScC(HandleRef title, in Color color);
		[DllImport(Base.Import)] private static extern void tsDialogColor_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogColor_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogColor_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogColor_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogColor_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogColor_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogColor_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogColor_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogColor_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogColor_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogColor_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_setTitle_s(HandleRef self, string title);
		[DllImport(Base.Import)] private static extern void tsDialogColor_setTitle_cS(HandleRef self, HandleRef title);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogColor_getTitle(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_setColor(HandleRef self, in Color color, bool callback);
		[DllImport(Base.Import)] private static extern Color tsDialogColor_getColor(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogColor_setChangedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsDialogColor_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Result tsDialogColor_run(HandleRef self, Flags flags);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DialogMenu
	public sealed class DialogMenu {
		public enum Flags : uint {
			None = 0,
			Mouse = 1,
			Default = 0,
			Num = 1,
		}
		public enum Result : uint {
			Cancel = 0,
			Click,
			NumResults,
		}
		public delegate void ClickedCallback(IntPtr data_);
		public delegate void ChangedCallback(bool a0, IntPtr data_);
		public delegate bool UpdateCallback(IntPtr data_);
		public DialogMenu() { self = new HandleRef(this, tsDialogMenu_new()); owner = true; }
		public DialogMenu(DialogMenu ptr) { self = new HandleRef(this, tsDialogMenu_copyPtr(ptr.getSelf())); owner = true; }
		public DialogMenu(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDialogMenu_isOwnerPtr(self); }
		public static DialogMenu Null() { return new DialogMenu(IntPtr.Zero); }
		~DialogMenu() { if(owner) tsDialogMenu_delete(self); }
		public bool equalPtr(DialogMenu ptr) { return tsDialogMenu_equalPtr(self, ptr.getSelf()); }
		public DialogMenu clonePtr() { return new DialogMenu(tsDialogMenu_clonePtr(self)); }
		public void clearPtr() { tsDialogMenu_clearPtr(self); }
		public void destroyPtr() { tsDialogMenu_destroyPtr(self); }
		public void acquirePtr() { tsDialogMenu_acquirePtr(self); }
		public void unacquirePtr() { tsDialogMenu_unacquirePtr(self); }
		public bool isValidPtr() { return tsDialogMenu_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDialogMenu_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDialogMenu_isConstPtr(self); }
		public uint getCountPtr() { return tsDialogMenu_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDialogMenu_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void setPosition(int x, int y) { tsDialogMenu_setPosition(self, x, y); }
		public int getPositionX() { return tsDialogMenu_getPositionX(self); }
		public int getPositionY() { return tsDialogMenu_getPositionY(self); }
		public uint getNumItems() { return tsDialogMenu_getNumItems(self); }
		public void setItemText(uint index, string text) { tsDialogMenu_setItemText_us(self, index, text); }
		public void setItemText(uint index, String text) { tsDialogMenu_setItemText_ucS(self, index, text.getSelf()); }
		public string getItemText(uint index) { return Base.getString(tsDialogMenu_getItemText(self, index)); }
		public void setItemKey(uint index, string key) { tsDialogMenu_setItemKey(self, index, key); }
		public string getItemKey(uint index) { return Base.getString(tsDialogMenu_getItemKey(self, index)); }
		public void setItemImage(uint index, Image image) { tsDialogMenu_setItemImage(self, index, image.getSelf()); }
		public Image getItemImage(uint index) { return new Image(tsDialogMenu_getItemImage(self, index)); }
		public void setItemChecked(uint index, bool checked_, bool callback = false) { tsDialogMenu_setItemChecked(self, index, checked_, callback); }
		public bool isItemChecked(uint index) { return tsDialogMenu_isItemChecked(self, index); }
		public void setItemEnabled(uint index, bool enabled) { tsDialogMenu_setItemEnabled(self, index, enabled); }
		public bool isItemEnabled(uint index) { return tsDialogMenu_isItemEnabled(self, index); }
		public void setItemHidden(uint index, bool hidden) { tsDialogMenu_setItemHidden(self, index, hidden); }
		public bool isItemHidden(uint index) { return tsDialogMenu_isItemHidden(self, index); }
		public void setItemsGroup(uint index, uint size) { tsDialogMenu_setItemsGroup(self, index, size); }
		public uint getItemGroupIndex(uint index) { return tsDialogMenu_getItemGroupIndex(self, index); }
		public uint getItemGroupSize(uint index) { return tsDialogMenu_getItemGroupSize(self, index); }
		public uint addItem(string text, string key = "") { return tsDialogMenu_addItem_ss(self, text, key); }
		public uint addItem(String text, string key = "") { return tsDialogMenu_addItem_cSs(self, text.getSelf(), key); }
		public uint addItem(string text, Image image, string key = "") { return tsDialogMenu_addItem_scIs(self, text, image.getSelf(), key); }
		public uint addItem(String text, Image image, string key = "") { return tsDialogMenu_addItem_cScIs(self, text.getSelf(), image.getSelf(), key); }
		public uint addItem(string text, ClickedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ClickedCallback_25 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_scDMCCs(self, text, Base.getFunc(func), key, data);
		}
		public uint addItem(String text, ClickedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ClickedCallback_26 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_cScDMCCs(self, text.getSelf(), Base.getFunc(func), key, data);
		}
		public uint addItem(string text, Image image, ClickedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ClickedCallback_27 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_scIcDMCCs(self, text, image.getSelf(), Base.getFunc(func), key, data);
		}
		public uint addItem(String text, Image image, ClickedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ClickedCallback_28 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_cScIcDMCCs(self, text.getSelf(), image.getSelf(), Base.getFunc(func), key, data);
		}
		public uint addItem(string text, bool checked_, ChangedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ChangedCallback_30 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_sbcDMCCs(self, text, checked_, Base.getFunc(func), key, data);
		}
		public uint addItem(String text, bool checked_, ChangedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ChangedCallback_31 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_cSbcDMCCs(self, text.getSelf(), checked_, Base.getFunc(func), key, data);
		}
		public uint addItem(string text, Image image, bool checked_, ChangedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ChangedCallback_32 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_scIbcDMCCs(self, text, image.getSelf(), checked_, Base.getFunc(func), key, data);
		}
		public uint addItem(String text, Image image, bool checked_, ChangedCallback func, string key = "", IntPtr data = new IntPtr()) {
			if(func != null) ChangedCallback_33 = GCHandle.Alloc(func);
			return tsDialogMenu_addItem_cScIbcDMCCs(self, text.getSelf(), image.getSelf(), checked_, Base.getFunc(func), key, data);
		}
		public void setUpdateCallback(UpdateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) UpdateCallback_35 = GCHandle.Alloc(func);
			tsDialogMenu_setUpdateCallback(self, Base.getFunc(func), data);
		}
		public Result run(Flags flags = Flags.Default) { return tsDialogMenu_run(self, flags); }
		private GCHandle ClickedCallback_25;
		private GCHandle ClickedCallback_26;
		private GCHandle ClickedCallback_27;
		private GCHandle ClickedCallback_28;
		private GCHandle ChangedCallback_30;
		private GCHandle ChangedCallback_31;
		private GCHandle ChangedCallback_32;
		private GCHandle ChangedCallback_33;
		private GCHandle UpdateCallback_35;
		public override string ToString() { return "Tellusim.DialogMenu: Valid: " + tsDialogMenu_isValidPtr(self) + "; Owner: " + tsDialogMenu_isOwnerPtr(self) + "; Const: " + tsDialogMenu_isConstPtr(self) + "; Count: " + tsDialogMenu_getCountPtr(self) + "; Internal: 0x" + tsDialogMenu_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DialogMenu ptr) { return (ptr != null && tsDialogMenu_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_new();
		[DllImport(Base.Import)] private static extern void tsDialogMenu_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setPosition(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern int tsDialogMenu_getPositionX(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDialogMenu_getPositionY(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_getNumItems(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemText_us(HandleRef self, uint index, string text);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemText_ucS(HandleRef self, uint index, HandleRef text);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_getItemText(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemKey(HandleRef self, uint index, string key);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_getItemKey(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemImage(HandleRef self, uint index, HandleRef image);
		[DllImport(Base.Import)] private static extern IntPtr tsDialogMenu_getItemImage(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemChecked(HandleRef self, uint index, bool checked_, bool callback);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_isItemChecked(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemEnabled(HandleRef self, uint index, bool enabled);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_isItemEnabled(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemHidden(HandleRef self, uint index, bool hidden);
		[DllImport(Base.Import)] private static extern bool tsDialogMenu_isItemHidden(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setItemsGroup(HandleRef self, uint index, uint size);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_getItemGroupIndex(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_getItemGroupSize(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_ss(HandleRef self, string text, string key);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_cSs(HandleRef self, HandleRef text, string key);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_scIs(HandleRef self, string text, HandleRef image, string key);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_cScIs(HandleRef self, HandleRef text, HandleRef image, string key);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_scDMCCs(HandleRef self, string text, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_cScDMCCs(HandleRef self, HandleRef text, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_scIcDMCCs(HandleRef self, string text, HandleRef image, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_cScIcDMCCs(HandleRef self, HandleRef text, HandleRef image, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_sbcDMCCs(HandleRef self, string text, bool checked_, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_cSbcDMCCs(HandleRef self, HandleRef text, bool checked_, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_scIbcDMCCs(HandleRef self, string text, HandleRef image, bool checked_, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern uint tsDialogMenu_addItem_cScIbcDMCCs(HandleRef self, HandleRef text, HandleRef image, bool checked_, IntPtr func, string key, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsDialogMenu_setUpdateCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern Result tsDialogMenu_run(HandleRef self, Flags flags);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::CubeFilter
	public sealed class CubeFilter {
		public enum Mode : uint {
			Cube = 0,
			Panorama,
			NumModes,
		}
		public enum Flags : uint {
			Cube = 1,
			Panorama = 2,
			All = 3,
		}
		public CubeFilter() { self = new HandleRef(this, tsCubeFilter_new()); owner = true; }
		public CubeFilter(CubeFilter ptr) { self = new HandleRef(this, tsCubeFilter_copyPtr(ptr.getSelf())); owner = true; }
		public CubeFilter(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsCubeFilter_isOwnerPtr(self); }
		public static CubeFilter Null() { return new CubeFilter(IntPtr.Zero); }
		~CubeFilter() { if(owner) tsCubeFilter_delete(self); }
		public bool equalPtr(CubeFilter ptr) { return tsCubeFilter_equalPtr(self, ptr.getSelf()); }
		public CubeFilter clonePtr() { return new CubeFilter(tsCubeFilter_clonePtr(self)); }
		public void clearPtr() { tsCubeFilter_clearPtr(self); }
		public void destroyPtr() { tsCubeFilter_destroyPtr(self); }
		public void acquirePtr() { tsCubeFilter_acquirePtr(self); }
		public void unacquirePtr() { tsCubeFilter_unacquirePtr(self); }
		public bool isValidPtr() { return tsCubeFilter_isValidPtr(self); }
		public bool isOwnerPtr() { return tsCubeFilter_isOwnerPtr(self); }
		public bool isConstPtr() { return tsCubeFilter_isConstPtr(self); }
		public uint getCountPtr() { return tsCubeFilter_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsCubeFilter_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsCubeFilter_clear(self); }
		public bool isCreated(Mode mode) { return tsCubeFilter_isCreated(self, mode); }
		public uint getGroupSize() { return tsCubeFilter_getGroupSize(self); }
		public uint getMaxOrder() { return tsCubeFilter_getMaxOrder(self); }
		public uint getMaxSize() { return tsCubeFilter_getMaxSize(self); }
		public uint getHarmonics() { return tsCubeFilter_getHarmonics(self); }
		public bool create(Device device, Mode mode, uint order = 3, uint size = 1024, uint groups = 256) { return tsCubeFilter_create_cDCFMuuu(self, device.getSelf(), mode, order, size, groups); }
		public bool create(Device device, Flags flags, uint order = 3, uint size = 1024, uint groups = 256) { return tsCubeFilter_create_cDCFFuuu(self, device.getSelf(), flags, order, size, groups); }
		public bool dispatch(Compute compute, Buffer buffer, uint offset, Texture texture, in Slice slice) { return tsCubeFilter_dispatch_cCBuTcS(self, compute.getSelf(), buffer.getSelf(), offset, texture.getSelf(), in slice); }
		public bool dispatch(Compute compute, Buffer buffer, uint offset, Texture texture) { return tsCubeFilter_dispatch_cCBuT(self, compute.getSelf(), buffer.getSelf(), offset, texture.getSelf()); }
		public bool dispatch(Compute compute, Texture texture, in Slice slice, Buffer buffer, uint offset) { return tsCubeFilter_dispatch_cCTcSBu(self, compute.getSelf(), texture.getSelf(), in slice, buffer.getSelf(), offset); }
		public bool dispatch(Compute compute, Texture texture, Buffer buffer, uint offset) { return tsCubeFilter_dispatch_cCTBu(self, compute.getSelf(), texture.getSelf(), buffer.getSelf(), offset); }
		public override string ToString() { return "Tellusim.CubeFilter: Valid: " + tsCubeFilter_isValidPtr(self) + "; Owner: " + tsCubeFilter_isOwnerPtr(self) + "; Const: " + tsCubeFilter_isConstPtr(self) + "; Count: " + tsCubeFilter_getCountPtr(self) + "; Internal: 0x" + tsCubeFilter_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(CubeFilter ptr) { return (ptr != null && tsCubeFilter_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsCubeFilter_new();
		[DllImport(Base.Import)] private static extern void tsCubeFilter_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsCubeFilter_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCubeFilter_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCubeFilter_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCubeFilter_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCubeFilter_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCubeFilter_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCubeFilter_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsCubeFilter_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsCubeFilter_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_isCreated(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern uint tsCubeFilter_getGroupSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCubeFilter_getMaxOrder(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCubeFilter_getMaxSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsCubeFilter_getHarmonics(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_create_cDCFMuuu(HandleRef self, HandleRef device, Mode mode, uint order, uint size, uint groups);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_create_cDCFFuuu(HandleRef self, HandleRef device, Flags flags, uint order, uint size, uint groups);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_dispatch_cCBuTcS(HandleRef self, HandleRef compute, HandleRef buffer, uint offset, HandleRef texture, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_dispatch_cCBuT(HandleRef self, HandleRef compute, HandleRef buffer, uint offset, HandleRef texture);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_dispatch_cCTcSBu(HandleRef self, HandleRef compute, HandleRef texture, in Slice slice, HandleRef buffer, uint offset);
		[DllImport(Base.Import)] private static extern bool tsCubeFilter_dispatch_cCTBu(HandleRef self, HandleRef compute, HandleRef texture, HandleRef buffer, uint offset);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::DecoderJPEG
	public sealed class DecoderJPEG {
		public enum Mode : uint {
			R = 0,
			RG,
			RGBA,
			YUV444,
			YUV422H,
			YUV422V,
			YUV420,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			R = 1,
			RG = 2,
			RGBA = 4,
			YUV444 = 8,
			YUV422H = 16,
			YUV422V = 32,
			YUV420 = 64,
			All = 127,
		}
		public DecoderJPEG() { self = new HandleRef(this, tsDecoderJPEG_new()); owner = true; }
		public DecoderJPEG(DecoderJPEG ptr) { self = new HandleRef(this, tsDecoderJPEG_copyPtr(ptr.getSelf())); owner = true; }
		public DecoderJPEG(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDecoderJPEG_isOwnerPtr(self); }
		public static DecoderJPEG Null() { return new DecoderJPEG(IntPtr.Zero); }
		~DecoderJPEG() { if(owner) tsDecoderJPEG_delete(self); }
		public bool equalPtr(DecoderJPEG ptr) { return tsDecoderJPEG_equalPtr(self, ptr.getSelf()); }
		public DecoderJPEG clonePtr() { return new DecoderJPEG(tsDecoderJPEG_clonePtr(self)); }
		public void clearPtr() { tsDecoderJPEG_clearPtr(self); }
		public void destroyPtr() { tsDecoderJPEG_destroyPtr(self); }
		public void acquirePtr() { tsDecoderJPEG_acquirePtr(self); }
		public void unacquirePtr() { tsDecoderJPEG_unacquirePtr(self); }
		public bool isValidPtr() { return tsDecoderJPEG_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDecoderJPEG_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDecoderJPEG_isConstPtr(self); }
		public uint getCountPtr() { return tsDecoderJPEG_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDecoderJPEG_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsDecoderJPEG_clear(self); }
		public bool isCreated(Mode mode) { return tsDecoderJPEG_isCreated(self, mode); }
		public static bool isYUV(Mode mode) { return tsDecoderJPEG_isYUV(mode); }
		public bool create(Device device, Mode mode) { return tsDecoderJPEG_create_cDDJM(self, device.getSelf(), mode); }
		public bool create(Device device, Flags flags) { return tsDecoderJPEG_create_cDDJF(self, device.getSelf(), flags); }
		public static bool load(string name, Image image, Mode mode, ref Size size) { return tsDecoderJPEG_load_sIDJMS(name, image.getSelf(), mode, ref size); }
		public static bool load(Stream stream, Image image, Mode mode, ref Size size) { return tsDecoderJPEG_load_StIDJMS(stream.getSelf(), image.getSelf(), mode, ref size); }
		public Texture loadTexture(Device device, string name, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDecoderJPEG_loadTexture_ccDsTF(self, device.getSelf(), name, flags)); }
		public Texture loadTexture(Device device, Stream stream, Texture.Flags flags = Texture.Flags.Default) { return new Texture(tsDecoderJPEG_loadTexture_ccDStTF(self, device.getSelf(), stream.getSelf(), flags)); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice) { return tsDecoderJPEG_dispatch_cCDJMTTcScS(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice src_slice) { return tsDecoderJPEG_dispatch_cCDJMTTcS(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in src_slice); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src) { return tsDecoderJPEG_dispatch_cCDJMTT(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf()); }
		public bool dispatchYUV(Compute compute, Mode mode, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice) { return tsDecoderJPEG_dispatchYUV_cCDJMTTcScS(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice); }
		public bool dispatchYUV(Compute compute, Mode mode, Texture dest, Texture src, in Slice src_slice) { return tsDecoderJPEG_dispatchYUV_cCDJMTTcS(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in src_slice); }
		public bool dispatchYUV(Compute compute, Mode mode, Texture dest, Texture src) { return tsDecoderJPEG_dispatchYUV_cCDJMTT(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf()); }
		public override string ToString() { return "Tellusim.DecoderJPEG: Valid: " + tsDecoderJPEG_isValidPtr(self) + "; Owner: " + tsDecoderJPEG_isOwnerPtr(self) + "; Const: " + tsDecoderJPEG_isConstPtr(self) + "; Count: " + tsDecoderJPEG_getCountPtr(self) + "; Internal: 0x" + tsDecoderJPEG_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(DecoderJPEG ptr) { return (ptr != null && tsDecoderJPEG_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDecoderJPEG_new();
		[DllImport(Base.Import)] private static extern void tsDecoderJPEG_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDecoderJPEG_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDecoderJPEG_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDecoderJPEG_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDecoderJPEG_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDecoderJPEG_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDecoderJPEG_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDecoderJPEG_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDecoderJPEG_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDecoderJPEG_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_isCreated(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_isYUV(Mode mode);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_create_cDDJM(HandleRef self, HandleRef device, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_create_cDDJF(HandleRef self, HandleRef device, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_load_sIDJMS(string name, HandleRef image, Mode mode, ref Size size);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_load_StIDJMS(HandleRef stream, HandleRef image, Mode mode, ref Size size);
		[DllImport(Base.Import)] private static extern IntPtr tsDecoderJPEG_loadTexture_ccDsTF(HandleRef self, HandleRef device, string name, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern IntPtr tsDecoderJPEG_loadTexture_ccDStTF(HandleRef self, HandleRef device, HandleRef stream, Texture.Flags flags);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_dispatch_cCDJMTTcScS(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_dispatch_cCDJMTTcS(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_dispatch_cCDJMTT(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_dispatchYUV_cCDJMTTcScS(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_dispatchYUV_cCDJMTTcS(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsDecoderJPEG_dispatchYUV_cCDJMTT(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::EncoderBC15
	public sealed class EncoderBC15 {
		public enum Mode : uint {
			BC1RGBu8n = 0,
			BC2RGBAu8n,
			BC3RGBAu8n,
			BC4Ru8n,
			BC5RGu8n,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			BC1RGBu8n = 1,
			BC2RGBAu8n = 2,
			BC3RGBAu8n = 4,
			BC4Ru8n = 8,
			BC5RGu8n = 16,
			Cube = 64,
			BC13 = 7,
			BC45 = 24,
			All = 31,
		}
		public EncoderBC15() { self = new HandleRef(this, tsEncoderBC15_new()); owner = true; }
		public EncoderBC15(EncoderBC15 ptr) { self = new HandleRef(this, tsEncoderBC15_copyPtr(ptr.getSelf())); owner = true; }
		public EncoderBC15(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsEncoderBC15_isOwnerPtr(self); }
		public static EncoderBC15 Null() { return new EncoderBC15(IntPtr.Zero); }
		~EncoderBC15() { if(owner) tsEncoderBC15_delete(self); }
		public bool equalPtr(EncoderBC15 ptr) { return tsEncoderBC15_equalPtr(self, ptr.getSelf()); }
		public EncoderBC15 clonePtr() { return new EncoderBC15(tsEncoderBC15_clonePtr(self)); }
		public void clearPtr() { tsEncoderBC15_clearPtr(self); }
		public void destroyPtr() { tsEncoderBC15_destroyPtr(self); }
		public void acquirePtr() { tsEncoderBC15_acquirePtr(self); }
		public void unacquirePtr() { tsEncoderBC15_unacquirePtr(self); }
		public bool isValidPtr() { return tsEncoderBC15_isValidPtr(self); }
		public bool isOwnerPtr() { return tsEncoderBC15_isOwnerPtr(self); }
		public bool isConstPtr() { return tsEncoderBC15_isConstPtr(self); }
		public uint getCountPtr() { return tsEncoderBC15_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsEncoderBC15_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsEncoderBC15_clear(self); }
		public bool isCreated(Mode mode) { return tsEncoderBC15_isCreated(self, mode); }
		public bool create(Device device, Mode mode) { return tsEncoderBC15_create_cDEB15M(self, device.getSelf(), mode); }
		public bool create(Device device, Flags flags) { return tsEncoderBC15_create_cDEB15F(self, device.getSelf(), flags); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice) { return tsEncoderBC15_dispatch_cCEB15MTTcScS(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice src_slice) { return tsEncoderBC15_dispatch_cCEB15MTTcS(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in src_slice); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src) { return tsEncoderBC15_dispatch_cCEB15MTT(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf()); }
		public override string ToString() { return "Tellusim.EncoderBC15: Valid: " + tsEncoderBC15_isValidPtr(self) + "; Owner: " + tsEncoderBC15_isOwnerPtr(self) + "; Const: " + tsEncoderBC15_isConstPtr(self) + "; Count: " + tsEncoderBC15_getCountPtr(self) + "; Internal: 0x" + tsEncoderBC15_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(EncoderBC15 ptr) { return (ptr != null && tsEncoderBC15_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC15_new();
		[DllImport(Base.Import)] private static extern void tsEncoderBC15_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC15_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC15_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC15_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC15_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC15_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC15_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsEncoderBC15_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC15_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC15_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_isCreated(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_create_cDEB15M(HandleRef self, HandleRef device, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_create_cDEB15F(HandleRef self, HandleRef device, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_dispatch_cCEB15MTTcScS(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_dispatch_cCEB15MTTcS(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC15_dispatch_cCEB15MTT(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::EncoderBC67
	public sealed class EncoderBC67 {
		public enum Mode : uint {
			BC6RGBf16s = 0,
			BC6RGBf16u,
			BC7RGBAu8n,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			BC6RGBf16s = 1,
			BC6RGBf16u = 2,
			BC7RGBAu8n = 4,
			Cube = 16,
			All = 7,
		}
		public EncoderBC67() { self = new HandleRef(this, tsEncoderBC67_new()); owner = true; }
		public EncoderBC67(EncoderBC67 ptr) { self = new HandleRef(this, tsEncoderBC67_copyPtr(ptr.getSelf())); owner = true; }
		public EncoderBC67(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsEncoderBC67_isOwnerPtr(self); }
		public static EncoderBC67 Null() { return new EncoderBC67(IntPtr.Zero); }
		~EncoderBC67() { if(owner) tsEncoderBC67_delete(self); }
		public bool equalPtr(EncoderBC67 ptr) { return tsEncoderBC67_equalPtr(self, ptr.getSelf()); }
		public EncoderBC67 clonePtr() { return new EncoderBC67(tsEncoderBC67_clonePtr(self)); }
		public void clearPtr() { tsEncoderBC67_clearPtr(self); }
		public void destroyPtr() { tsEncoderBC67_destroyPtr(self); }
		public void acquirePtr() { tsEncoderBC67_acquirePtr(self); }
		public void unacquirePtr() { tsEncoderBC67_unacquirePtr(self); }
		public bool isValidPtr() { return tsEncoderBC67_isValidPtr(self); }
		public bool isOwnerPtr() { return tsEncoderBC67_isOwnerPtr(self); }
		public bool isConstPtr() { return tsEncoderBC67_isConstPtr(self); }
		public uint getCountPtr() { return tsEncoderBC67_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsEncoderBC67_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsEncoderBC67_clear(self); }
		public bool isCreated(Mode mode) { return tsEncoderBC67_isCreated(self, mode); }
		public bool create(Device device, Mode mode) { return tsEncoderBC67_create_cDEB67M(self, device.getSelf(), mode); }
		public bool create(Device device, Flags flags) { return tsEncoderBC67_create_cDEB67F(self, device.getSelf(), flags); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice, uint components = 4) { return tsEncoderBC67_dispatch_cCEB67MTTcScSu(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice, components); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice src_slice, uint components = 4) { return tsEncoderBC67_dispatch_cCEB67MTTcSu(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in src_slice, components); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, uint components = 4) { return tsEncoderBC67_dispatch_cCEB67MTTu(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), components); }
		public override string ToString() { return "Tellusim.EncoderBC67: Valid: " + tsEncoderBC67_isValidPtr(self) + "; Owner: " + tsEncoderBC67_isOwnerPtr(self) + "; Const: " + tsEncoderBC67_isConstPtr(self) + "; Count: " + tsEncoderBC67_getCountPtr(self) + "; Internal: 0x" + tsEncoderBC67_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(EncoderBC67 ptr) { return (ptr != null && tsEncoderBC67_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC67_new();
		[DllImport(Base.Import)] private static extern void tsEncoderBC67_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC67_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC67_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC67_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC67_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC67_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC67_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsEncoderBC67_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderBC67_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderBC67_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_isCreated(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_create_cDEB67M(HandleRef self, HandleRef device, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_create_cDEB67F(HandleRef self, HandleRef device, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_dispatch_cCEB67MTTcScSu(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice, uint components);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_dispatch_cCEB67MTTcSu(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice src_slice, uint components);
		[DllImport(Base.Import)] private static extern bool tsEncoderBC67_dispatch_cCEB67MTTu(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, uint components);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::EncoderASTC
	public sealed class EncoderASTC {
		public enum Mode : uint {
			ASTC44RGBAu8n = 0,
			ASTC54RGBAu8n,
			ASTC55RGBAu8n,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			ASTC44RGBAu8n = 1,
			ASTC54RGBAu8n = 2,
			ASTC55RGBAu8n = 4,
			Cube = 16,
			All = 7,
		}
		public EncoderASTC() { self = new HandleRef(this, tsEncoderASTC_new()); owner = true; }
		public EncoderASTC(EncoderASTC ptr) { self = new HandleRef(this, tsEncoderASTC_copyPtr(ptr.getSelf())); owner = true; }
		public EncoderASTC(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsEncoderASTC_isOwnerPtr(self); }
		public static EncoderASTC Null() { return new EncoderASTC(IntPtr.Zero); }
		~EncoderASTC() { if(owner) tsEncoderASTC_delete(self); }
		public bool equalPtr(EncoderASTC ptr) { return tsEncoderASTC_equalPtr(self, ptr.getSelf()); }
		public EncoderASTC clonePtr() { return new EncoderASTC(tsEncoderASTC_clonePtr(self)); }
		public void clearPtr() { tsEncoderASTC_clearPtr(self); }
		public void destroyPtr() { tsEncoderASTC_destroyPtr(self); }
		public void acquirePtr() { tsEncoderASTC_acquirePtr(self); }
		public void unacquirePtr() { tsEncoderASTC_unacquirePtr(self); }
		public bool isValidPtr() { return tsEncoderASTC_isValidPtr(self); }
		public bool isOwnerPtr() { return tsEncoderASTC_isOwnerPtr(self); }
		public bool isConstPtr() { return tsEncoderASTC_isConstPtr(self); }
		public uint getCountPtr() { return tsEncoderASTC_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsEncoderASTC_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsEncoderASTC_clear(self); }
		public bool isCreated(Mode mode) { return tsEncoderASTC_isCreated(self, mode); }
		public bool create(Device device, Mode mode) { return tsEncoderASTC_create_cDEAM(self, device.getSelf(), mode); }
		public bool create(Device device, Flags flags) { return tsEncoderASTC_create_cDEAF(self, device.getSelf(), flags); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice, uint components = 4) { return tsEncoderASTC_dispatch_cCEAMTTcScSu(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice, components); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, in Slice src_slice, uint components = 4) { return tsEncoderASTC_dispatch_cCEAMTTcSu(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), in src_slice, components); }
		public bool dispatch(Compute compute, Mode mode, Texture dest, Texture src, uint components = 4) { return tsEncoderASTC_dispatch_cCEAMTTu(self, compute.getSelf(), mode, dest.getSelf(), src.getSelf(), components); }
		public override string ToString() { return "Tellusim.EncoderASTC: Valid: " + tsEncoderASTC_isValidPtr(self) + "; Owner: " + tsEncoderASTC_isOwnerPtr(self) + "; Const: " + tsEncoderASTC_isConstPtr(self) + "; Count: " + tsEncoderASTC_getCountPtr(self) + "; Internal: 0x" + tsEncoderASTC_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(EncoderASTC ptr) { return (ptr != null && tsEncoderASTC_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderASTC_new();
		[DllImport(Base.Import)] private static extern void tsEncoderASTC_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderASTC_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderASTC_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderASTC_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderASTC_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderASTC_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderASTC_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsEncoderASTC_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsEncoderASTC_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsEncoderASTC_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_isCreated(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_create_cDEAM(HandleRef self, HandleRef device, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_create_cDEAF(HandleRef self, HandleRef device, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_dispatch_cCEAMTTcScSu(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice, uint components);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_dispatch_cCEAMTTcSu(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, in Slice src_slice, uint components);
		[DllImport(Base.Import)] private static extern bool tsEncoderASTC_dispatch_cCEAMTTu(HandleRef self, HandleRef compute, Mode mode, HandleRef dest, HandleRef src, uint components);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::MeshModel
	public sealed class MeshModel {
		public enum Flags : uint {
			None = 0,
			Direct = 1,
			Verbose = 2,
			Optimize = 4,
			Materials = 8,
			Indices10 = 16,
			Indices16 = 32,
			Indices32 = 64,
			Meshlet64x84 = 128,
			Meshlet64x126 = 256,
			Meshlet96x169 = 512,
			Meshlet128x212 = 1024,
			BufferWrite = 2048,
			BufferSource = 4096,
			BufferStorage = 8192,
			BufferTracing = 16384,
			BufferAddress = 32768,
			BufferTexel = 65536,
			Meshlets = 1920,
			Default = 10,
			Num = 17,
		}
		public delegate bool CreateCallback(IntPtr src, ulong size, bool owner, IntPtr data_);
		public MeshModel() { self = new HandleRef(this, tsMeshModel_new()); owner = true; }
		public MeshModel(MeshModel ptr) { self = new HandleRef(this, ptr.getSelfPtr()); }
		public MeshModel(IntPtr ptr) { self = new HandleRef(this, ptr); owner = true; }
		public static MeshModel Null() { return new MeshModel(IntPtr.Zero); }
		~MeshModel() { if(owner) tsMeshModel_delete(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsMeshModel_clear(self); }
		public bool isCreated() { return tsMeshModel_isCreated(self); }
		public Flags getFlags() { return tsMeshModel_getFlags(self); }
		public bool hasFlag(Flags flags) { return tsMeshModel_hasFlag(self, flags); }
		public bool hasFlags(Flags flags) { return tsMeshModel_hasFlags(self, flags); }
		public bool load(Device device, Pipeline pipeline, string name, Flags flags = Flags.Default, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMeshModel_load_cDcPsMMFA(self, device.getSelf(), pipeline.getSelf(), name, flags, ref async_);
		}
		public bool load(Device device, Pipeline pipeline, Stream stream, Flags flags = Flags.Default, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMeshModel_load_cDcPStMMFA(self, device.getSelf(), pipeline.getSelf(), stream.getSelf(), flags, ref async_);
		}
		public bool create(Device device, Pipeline pipeline, string name, Flags flags = Flags.Default) { return tsMeshModel_create_cDcPsMMF(self, device.getSelf(), pipeline.getSelf(), name, flags); }
		public bool create(Device device, Pipeline pipeline, Mesh mesh, Flags flags = Flags.Default) { return tsMeshModel_create_cDcPcMMMF(self, device.getSelf(), pipeline.getSelf(), mesh.getSelf(), flags); }
		public bool create(Device device, Pipeline pipeline, MeshGeometry geometry, Flags flags = Flags.Default) { return tsMeshModel_create_cDcPcMGMMF(self, device.getSelf(), pipeline.getSelf(), geometry.getSelf(), flags); }
		public bool create(Device device, Pipeline pipeline, MeshGeometry[] geometries, Flags flags = Flags.Default) {
			IntPtr[] geometries_ = new IntPtr[geometries.Length];
			for(int i = 0; i < geometries.Length; i++) geometries_[i] = geometries[i].getSelfPtr();
			return tsMeshModel_create_cDcPcAMGMMF(self, device.getSelf(), pipeline.getSelf(), geometries_, (uint)geometries.Length, flags);
		}
		public void setVertexBufferCallback(CreateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) CreateCallback_12 = GCHandle.Alloc(func);
			tsMeshModel_setVertexBufferCallback(self, Base.getFunc(func), data);
		}
		public void setIndexBufferCallback(CreateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) CreateCallback_13 = GCHandle.Alloc(func);
			tsMeshModel_setIndexBufferCallback(self, Base.getFunc(func), data);
		}
		public void setMeshBufferCallback(CreateCallback func, IntPtr data = new IntPtr()) {
			if(func != null) CreateCallback_14 = GCHandle.Alloc(func);
			tsMeshModel_setMeshBufferCallback(self, Base.getFunc(func), data);
		}
		public void setBuffers(Command command, uint index = 0, in Pipeline pipeline = null) {
			IntPtr pipeline_ = (pipeline != null) ? pipeline.getSelfPtr() : IntPtr.Zero;
			tsMeshModel_setBuffers(self, command.getSelf(), index, ref pipeline_);
		}
		public void draw(Command command) { tsMeshModel_draw_cC(self, command.getSelf()); }
		public void draw(Command command, uint geometry) { tsMeshModel_draw_cCu(self, command.getSelf(), geometry); }
		public void draw(Command command, uint geometry, uint material) { tsMeshModel_draw_cCuu(self, command.getSelf(), geometry, material); }
		public void drawInstanced(Command command, uint geometry, uint num_instances, uint base_instance = 0) { tsMeshModel_drawInstanced_cCuuu(self, command.getSelf(), geometry, num_instances, base_instance); }
		public void drawInstanced(Command command, uint geometry, uint material, uint num_instances, uint base_instance) { tsMeshModel_drawInstanced_cCuuuu(self, command.getSelf(), geometry, material, num_instances, base_instance); }
		public uint getNumVertices() { return tsMeshModel_getNumVertices(self); }
		public uint getNumVertexBuffers() { return tsMeshModel_getNumVertexBuffers(self); }
		public uint getVertexBufferStride(uint index) { return tsMeshModel_getVertexBufferStride(self, index); }
		public ulong getVertexBufferOffset(uint index) { return tsMeshModel_getVertexBufferOffset(self, index); }
		public Buffer getVertexBuffer() { return new Buffer(tsMeshModel_getVertexBuffer(self)); }
		public uint getNumIndices() { return tsMeshModel_getNumIndices(self); }
		public Format getIndexFormat() { return tsMeshModel_getIndexFormat(self); }
		public Buffer getIndexBuffer() { return new Buffer(tsMeshModel_getIndexBuffer(self)); }
		public uint getNumMeshlets() { return tsMeshModel_getNumMeshlets(self); }
		public Buffer getMeshletBuffer() { return new Buffer(tsMeshModel_getMeshletBuffer(self)); }
		public uint getNumGeometries() { return tsMeshModel_getNumGeometries(self); }
		public uint getNumGeometryIndices(uint geometry) { return tsMeshModel_getNumGeometryIndices(self, geometry); }
		public uint getNumGeometryVertices(uint geometry) { return tsMeshModel_getNumGeometryVertices(self, geometry); }
		public uint getNumGeometryMeshlets(uint geometry) { return tsMeshModel_getNumGeometryMeshlets(self, geometry); }
		public uint getGeometryBaseIndex(uint geometry) { return tsMeshModel_getGeometryBaseIndex(self, geometry); }
		public uint getGeometryBaseVertex(uint geometry) { return tsMeshModel_getGeometryBaseVertex(self, geometry); }
		public uint getGeometryBaseMeshlet(uint geometry) { return tsMeshModel_getGeometryBaseMeshlet(self, geometry); }
		public uint getNumMaterials(uint geometry) { return tsMeshModel_getNumMaterials(self, geometry); }
		public uint getNumMaterialIndices(uint geometry, uint material) { return tsMeshModel_getNumMaterialIndices(self, geometry, material); }
		public uint getNumMaterialVertices(uint geometry, uint material) { return tsMeshModel_getNumMaterialVertices(self, geometry, material); }
		public uint getNumMaterialMeshlets(uint geometry, uint material) { return tsMeshModel_getNumMaterialMeshlets(self, geometry, material); }
		public uint getMaterialBaseIndex(uint geometry, uint material) { return tsMeshModel_getMaterialBaseIndex(self, geometry, material); }
		public uint getMaterialBaseVertex(uint geometry, uint material) { return tsMeshModel_getMaterialBaseVertex(self, geometry, material); }
		public uint getMaterialBaseMeshlet(uint geometry, uint material) { return tsMeshModel_getMaterialBaseMeshlet(self, geometry, material); }
		public ulong getMemory() { return tsMeshModel_getMemory(self); }
		private GCHandle CreateCallback_12;
		private GCHandle CreateCallback_13;
		private GCHandle CreateCallback_14;
		public override string ToString() { return "Tellusim.MeshModel: Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(MeshModel ptr) { return (ptr != null && ptr.getSelfPtr() != IntPtr.Zero); }
		[DllImport(Base.Import)] private static extern IntPtr tsMeshModel_new();
		[DllImport(Base.Import)] private static extern void tsMeshModel_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsMeshModel_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern Flags tsMeshModel_getFlags(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_hasFlag(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_hasFlags(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_load_cDcPsMMFA(HandleRef self, HandleRef device, HandleRef pipeline, string name, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_load_cDcPStMMFA(HandleRef self, HandleRef device, HandleRef pipeline, HandleRef stream, Flags flags, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_create_cDcPsMMF(HandleRef self, HandleRef device, HandleRef pipeline, string name, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_create_cDcPcMMMF(HandleRef self, HandleRef device, HandleRef pipeline, HandleRef mesh, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_create_cDcPcMGMMF(HandleRef self, HandleRef device, HandleRef pipeline, HandleRef geometry, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsMeshModel_create_cDcPcAMGMMF(HandleRef self, HandleRef device, HandleRef pipeline, IntPtr[] geometries, uint geometries_size, Flags flags);
		[DllImport(Base.Import)] private static extern void tsMeshModel_setVertexBufferCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsMeshModel_setIndexBufferCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsMeshModel_setMeshBufferCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsMeshModel_setBuffers(HandleRef self, HandleRef command, uint index, ref IntPtr pipeline);
		[DllImport(Base.Import)] private static extern void tsMeshModel_draw_cC(HandleRef self, HandleRef command);
		[DllImport(Base.Import)] private static extern void tsMeshModel_draw_cCu(HandleRef self, HandleRef command, uint geometry);
		[DllImport(Base.Import)] private static extern void tsMeshModel_draw_cCuu(HandleRef self, HandleRef command, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern void tsMeshModel_drawInstanced_cCuuu(HandleRef self, HandleRef command, uint geometry, uint num_instances, uint base_instance);
		[DllImport(Base.Import)] private static extern void tsMeshModel_drawInstanced_cCuuuu(HandleRef self, HandleRef command, uint geometry, uint material, uint num_instances, uint base_instance);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumVertices(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumVertexBuffers(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getVertexBufferStride(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern ulong tsMeshModel_getVertexBufferOffset(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshModel_getVertexBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumIndices(HandleRef self);
		[DllImport(Base.Import)] private static extern Format tsMeshModel_getIndexFormat(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshModel_getIndexBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumMeshlets(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsMeshModel_getMeshletBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumGeometries(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumGeometryIndices(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumGeometryVertices(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumGeometryMeshlets(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getGeometryBaseIndex(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getGeometryBaseVertex(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getGeometryBaseMeshlet(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumMaterials(HandleRef self, uint geometry);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumMaterialIndices(HandleRef self, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumMaterialVertices(HandleRef self, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getNumMaterialMeshlets(HandleRef self, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getMaterialBaseIndex(HandleRef self, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getMaterialBaseVertex(HandleRef self, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern uint tsMeshModel_getMaterialBaseMeshlet(HandleRef self, uint geometry, uint material);
		[DllImport(Base.Import)] private static extern ulong tsMeshModel_getMemory(HandleRef self);
		[StructLayout(LayoutKind.Sequential)] public struct Meshlet {
			public uint num_primitives;
			public uint num_vertices;
			public uint base_index;
			public uint base_vertex;
			public Vector4f bound_sphere;
			public Vector4f normal_angle;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("num_primitives: {0}\n", num_primitives);
				ret += System.String.Format("num_vertices: {0}\n", num_vertices);
				ret += System.String.Format("base_index: {0}\n", base_index);
				ret += System.String.Format("base_vertex: {0}\n", base_vertex);
				ret += System.String.Format("bound_sphere: {0}\n", bound_sphere);
				ret += System.String.Format("normal_angle: {0}", normal_angle);
				return ret;
			}
		}
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::SeparableFilter
	public sealed class SeparableFilter {
		public enum Mode : uint {
			Horizontal = 0,
			Vertical,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			Repeat = 1,
			Zero = 2,
			Default = 0,
		}
		public SeparableFilter() { self = new HandleRef(this, tsSeparableFilter_new()); owner = true; }
		public SeparableFilter(SeparableFilter ptr) { self = new HandleRef(this, tsSeparableFilter_copyPtr(ptr.getSelf())); owner = true; }
		public SeparableFilter(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSeparableFilter_isOwnerPtr(self); }
		public static SeparableFilter Null() { return new SeparableFilter(IntPtr.Zero); }
		~SeparableFilter() { if(owner) tsSeparableFilter_delete(self); }
		public bool equalPtr(SeparableFilter ptr) { return tsSeparableFilter_equalPtr(self, ptr.getSelf()); }
		public SeparableFilter clonePtr() { return new SeparableFilter(tsSeparableFilter_clonePtr(self)); }
		public void clearPtr() { tsSeparableFilter_clearPtr(self); }
		public void destroyPtr() { tsSeparableFilter_destroyPtr(self); }
		public void acquirePtr() { tsSeparableFilter_acquirePtr(self); }
		public void unacquirePtr() { tsSeparableFilter_unacquirePtr(self); }
		public bool isValidPtr() { return tsSeparableFilter_isValidPtr(self); }
		public bool isOwnerPtr() { return tsSeparableFilter_isOwnerPtr(self); }
		public bool isConstPtr() { return tsSeparableFilter_isConstPtr(self); }
		public uint getCountPtr() { return tsSeparableFilter_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsSeparableFilter_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsSeparableFilter_clear(self); }
		public bool isCreated(Format format, uint size) { return tsSeparableFilter_isCreated(self, format, size); }
		public void setInputSource(Mode mode, string src) { tsSeparableFilter_setInputSource(self, mode, src); }
		public string getInputSource(Mode mode) { return Base.getString(tsSeparableFilter_getInputSource(self, mode)); }
		public void setOutputSource(Mode mode, string src) { tsSeparableFilter_setOutputSource(self, mode, src); }
		public string getOutputSource(Mode mode) { return Base.getString(tsSeparableFilter_getOutputSource(self, mode)); }
		public bool create(Device device, Format format, uint size, Flags flags = Flags.Default) { return tsSeparableFilter_create(self, device.getSelf(), format, size, flags); }
		public void setWeights(Mode mode, Vector4f[] weights, bool normalize = false) { tsSeparableFilter_setWeights_SFMcAV4b(self, mode, weights, (uint)weights.Length, normalize); }
		public void setWeights(Mode mode, float[] weights, bool normalize = false) { tsSeparableFilter_setWeights_SFMcA32b(self, mode, weights, (uint)weights.Length, normalize); }
		public void setGaussianWeights(uint size, in Vector4f sigma) { tsSeparableFilter_setGaussianWeights_ucV4(self, size, in sigma); }
		public void setGaussianWeights(uint size, float sigma) { tsSeparableFilter_setGaussianWeights_uf(self, size, sigma); }
		public void setSobelXWeights(uint size) { tsSeparableFilter_setSobelXWeights(self, size); }
		public void setSobelYWeights(uint size) { tsSeparableFilter_setSobelYWeights(self, size); }
		public void setBoxWeights(uint size) { tsSeparableFilter_setBoxWeights(self, size); }
		public bool dispatch(Compute compute, Mode mode, uint size, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice, in Vector4f parameters) { return tsSeparableFilter_dispatch_cCSFMuTTcScScV4(self, compute.getSelf(), mode, size, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice, in parameters); }
		public bool dispatch(Compute compute, Mode mode, uint size, Texture dest, Texture src, in Slice src_slice, in Vector4f parameters) { return tsSeparableFilter_dispatch_cCSFMuTTcScV4(self, compute.getSelf(), mode, size, dest.getSelf(), src.getSelf(), in src_slice, in parameters); }
		public bool dispatch(Compute compute, Mode mode, uint size, Texture dest, Texture src, in Vector4f parameters) { return tsSeparableFilter_dispatch_cCSFMuTTcV4(self, compute.getSelf(), mode, size, dest.getSelf(), src.getSelf(), in parameters); }
		public override string ToString() { return "Tellusim.SeparableFilter: Valid: " + tsSeparableFilter_isValidPtr(self) + "; Owner: " + tsSeparableFilter_isOwnerPtr(self) + "; Const: " + tsSeparableFilter_isConstPtr(self) + "; Count: " + tsSeparableFilter_getCountPtr(self) + "; Internal: 0x" + tsSeparableFilter_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(SeparableFilter ptr) { return (ptr != null && tsSeparableFilter_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSeparableFilter_new();
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSeparableFilter_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSeparableFilter_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSeparableFilter_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSeparableFilter_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_isCreated(HandleRef self, Format format, uint size);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setInputSource(HandleRef self, Mode mode, string src);
		[DllImport(Base.Import)] private static extern IntPtr tsSeparableFilter_getInputSource(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setOutputSource(HandleRef self, Mode mode, string src);
		[DllImport(Base.Import)] private static extern IntPtr tsSeparableFilter_getOutputSource(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_create(HandleRef self, HandleRef device, Format format, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setWeights_SFMcAV4b(HandleRef self, Mode mode, Vector4f[] weights, uint weights_size, bool normalize);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setWeights_SFMcA32b(HandleRef self, Mode mode, float[] weights, uint weights_size, bool normalize);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setGaussianWeights_ucV4(HandleRef self, uint size, in Vector4f sigma);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setGaussianWeights_uf(HandleRef self, uint size, float sigma);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setSobelXWeights(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setSobelYWeights(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern void tsSeparableFilter_setBoxWeights(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_dispatch_cCSFMuTTcScScV4(HandleRef self, HandleRef compute, Mode mode, uint size, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice, in Vector4f parameters);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_dispatch_cCSFMuTTcScV4(HandleRef self, HandleRef compute, Mode mode, uint size, HandleRef dest, HandleRef src, in Slice src_slice, in Vector4f parameters);
		[DllImport(Base.Import)] private static extern bool tsSeparableFilter_dispatch_cCSFMuTTcV4(HandleRef self, HandleRef compute, Mode mode, uint size, HandleRef dest, HandleRef src, in Vector4f parameters);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::PrefixScan
	public sealed class PrefixScan {
		public enum Mode : uint {
			Single = 0,
			Multiple,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			Single = 1,
			Multiple = 2,
			Indirect = 4,
			Repeat = 8,
			All = 7,
		}
		public PrefixScan() { self = new HandleRef(this, tsPrefixScan_new()); owner = true; }
		public PrefixScan(PrefixScan ptr) { self = new HandleRef(this, tsPrefixScan_copyPtr(ptr.getSelf())); owner = true; }
		public PrefixScan(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsPrefixScan_isOwnerPtr(self); }
		public static PrefixScan Null() { return new PrefixScan(IntPtr.Zero); }
		~PrefixScan() { if(owner) tsPrefixScan_delete(self); }
		public bool equalPtr(PrefixScan ptr) { return tsPrefixScan_equalPtr(self, ptr.getSelf()); }
		public PrefixScan clonePtr() { return new PrefixScan(tsPrefixScan_clonePtr(self)); }
		public void clearPtr() { tsPrefixScan_clearPtr(self); }
		public void destroyPtr() { tsPrefixScan_destroyPtr(self); }
		public void acquirePtr() { tsPrefixScan_acquirePtr(self); }
		public void unacquirePtr() { tsPrefixScan_unacquirePtr(self); }
		public bool isValidPtr() { return tsPrefixScan_isValidPtr(self); }
		public bool isOwnerPtr() { return tsPrefixScan_isOwnerPtr(self); }
		public bool isConstPtr() { return tsPrefixScan_isConstPtr(self); }
		public uint getCountPtr() { return tsPrefixScan_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsPrefixScan_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsPrefixScan_clear(self); }
		public bool isCreated(Flags flags) { return tsPrefixScan_isCreated(self, flags); }
		public uint getGroupSize() { return tsPrefixScan_getGroupSize(self); }
		public uint getScanElements() { return tsPrefixScan_getScanElements(self); }
		public uint getMaxElements() { return tsPrefixScan_getMaxElements(self); }
		public uint getMaxRegions() { return tsPrefixScan_getMaxRegions(self); }
		public bool create(Device device, Mode mode, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsPrefixScan_create_cDPSMuuA(self, device.getSelf(), mode, groups, regions, ref async_);
		}
		public bool create(Device device, Flags flags, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsPrefixScan_create_cDPSFuuA(self, device.getSelf(), flags, groups, regions, ref async_);
		}
		public bool dispatch(Compute compute, Buffer data, uint offset, uint size) { return tsPrefixScan_dispatch_CBuu(self, compute.getSelf(), data.getSelf(), offset, size); }
		public bool dispatch(Compute compute, Buffer data, uint count, uint[] offsets, uint[] sizes, Flags flags = Flags.None) { return tsPrefixScan_dispatch_CBuupupPSF(self, compute.getSelf(), data.getSelf(), count, offsets, sizes, flags); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer dispatch, uint offset, Flags flags = Flags.None, uint max_size = Base.Maxu32) { return tsPrefixScan_dispatchIndirect_CBBuPSFu(self, compute.getSelf(), data.getSelf(), dispatch.getSelf(), offset, flags, max_size); }
		public bool dispatchIndirect(Compute compute, Buffer data, uint count, Buffer dispatch, uint offset, Flags flags = Flags.None, uint max_size = Base.Maxu32) { return tsPrefixScan_dispatchIndirect_CBuBuPSFu(self, compute.getSelf(), data.getSelf(), count, dispatch.getSelf(), offset, flags, max_size); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer count, Buffer dispatch, uint count_offset, uint dispatch_offset, Flags flags = Flags.None, uint max_size = Base.Maxu32) { return tsPrefixScan_dispatchIndirect_CBBBuuPSFu(self, compute.getSelf(), data.getSelf(), count.getSelf(), dispatch.getSelf(), count_offset, dispatch_offset, flags, max_size); }
		public override string ToString() { return "Tellusim.PrefixScan: Valid: " + tsPrefixScan_isValidPtr(self) + "; Owner: " + tsPrefixScan_isOwnerPtr(self) + "; Const: " + tsPrefixScan_isConstPtr(self) + "; Count: " + tsPrefixScan_getCountPtr(self) + "; Internal: 0x" + tsPrefixScan_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(PrefixScan ptr) { return (ptr != null && tsPrefixScan_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsPrefixScan_new();
		[DllImport(Base.Import)] private static extern void tsPrefixScan_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsPrefixScan_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPrefixScan_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPrefixScan_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPrefixScan_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPrefixScan_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPrefixScan_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPrefixScan_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsPrefixScan_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsPrefixScan_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_isCreated(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern uint tsPrefixScan_getGroupSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPrefixScan_getScanElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPrefixScan_getMaxElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsPrefixScan_getMaxRegions(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_create_cDPSMuuA(HandleRef self, HandleRef device, Mode mode, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_create_cDPSFuuA(HandleRef self, HandleRef device, Flags flags, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_dispatch_CBuu(HandleRef self, HandleRef compute, HandleRef data, uint offset, uint size);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_dispatch_CBuupupPSF(HandleRef self, HandleRef compute, HandleRef data, uint count, uint[] offsets, uint[] sizes, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_dispatchIndirect_CBBuPSFu(HandleRef self, HandleRef compute, HandleRef data, HandleRef dispatch, uint offset, Flags flags, uint max_size);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_dispatchIndirect_CBuBuPSFu(HandleRef self, HandleRef compute, HandleRef data, uint count, HandleRef dispatch, uint offset, Flags flags, uint max_size);
		[DllImport(Base.Import)] private static extern bool tsPrefixScan_dispatchIndirect_CBBBuuPSFu(HandleRef self, HandleRef compute, HandleRef data, HandleRef count, HandleRef dispatch, uint count_offset, uint dispatch_offset, Flags flags, uint max_size);
		[StructLayout(LayoutKind.Sequential)] public struct DispatchParameters {
			public uint offset;
			public uint size;
			public uint padding_0;
			public uint padding_1;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("offset: {0}\n", offset);
				ret += System.String.Format("size: {0}\n", size);
				return ret;
			}
		}
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::RadixSort
	public sealed class RadixSort {
		public enum Mode : uint {
			Single = 0,
			Multiple,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			Single = 1,
			Multiple = 2,
			Indirect = 4,
			Order = 8,
			Tracing = 16,
			Scratch = 32,
			All = 15,
		}
		public RadixSort() { self = new HandleRef(this, tsRadixSort_new()); owner = true; }
		public RadixSort(RadixSort ptr) { self = new HandleRef(this, tsRadixSort_copyPtr(ptr.getSelf())); owner = true; }
		public RadixSort(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsRadixSort_isOwnerPtr(self); }
		public static RadixSort Null() { return new RadixSort(IntPtr.Zero); }
		~RadixSort() { if(owner) tsRadixSort_delete(self); }
		public bool equalPtr(RadixSort ptr) { return tsRadixSort_equalPtr(self, ptr.getSelf()); }
		public RadixSort clonePtr() { return new RadixSort(tsRadixSort_clonePtr(self)); }
		public void clearPtr() { tsRadixSort_clearPtr(self); }
		public void destroyPtr() { tsRadixSort_destroyPtr(self); }
		public void acquirePtr() { tsRadixSort_acquirePtr(self); }
		public void unacquirePtr() { tsRadixSort_unacquirePtr(self); }
		public bool isValidPtr() { return tsRadixSort_isValidPtr(self); }
		public bool isOwnerPtr() { return tsRadixSort_isOwnerPtr(self); }
		public bool isConstPtr() { return tsRadixSort_isConstPtr(self); }
		public uint getCountPtr() { return tsRadixSort_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsRadixSort_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsRadixSort_clear(self); }
		public bool isCreated(Flags flags) { return tsRadixSort_isCreated(self, flags); }
		public uint getDataSize() { return tsRadixSort_getDataSize(self); }
		public uint getGroupSize() { return tsRadixSort_getGroupSize(self); }
		public uint getSortElements() { return tsRadixSort_getSortElements(self); }
		public uint getUpdateElements() { return tsRadixSort_getUpdateElements(self); }
		public uint getMaxElements() { return tsRadixSort_getMaxElements(self); }
		public uint getMaxRegions() { return tsRadixSort_getMaxRegions(self); }
		public PrefixScan getPrefixScan() { return new PrefixScan(tsRadixSort_getPrefixScan(self)); }
		public Buffer getDataBuffer() { return new Buffer(tsRadixSort_getDataBuffer(self)); }
		public bool create(Device device, Mode mode, PrefixScan scan, uint size, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsRadixSort_create_cDRSMPSuuuA(self, device.getSelf(), mode, scan.getSelf(), size, groups, regions, ref async_);
		}
		public bool create(Device device, Flags flags, PrefixScan scan, uint size, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsRadixSort_create_cDRSFPSuuuA(self, device.getSelf(), flags, scan.getSelf(), size, groups, regions, ref async_);
		}
		public bool dispatch(Compute compute, Buffer data, uint keys_offset, uint data_offset, uint size, Flags flags = Flags.None, uint bits = 32) { return tsRadixSort_dispatch_CBuuuRSFu(self, compute.getSelf(), data.getSelf(), keys_offset, data_offset, size, flags, bits); }
		public bool dispatch(Compute compute, Buffer data, uint count, uint[] keys_offsets, uint[] data_offsets, uint[] sizes, Flags flags = Flags.None, uint bits = 32) { return tsRadixSort_dispatch_CBuupupupRSFu(self, compute.getSelf(), data.getSelf(), count, keys_offsets, data_offsets, sizes, flags, bits); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer dispatch, uint offset, Flags flags = Flags.None, uint bits = 32, uint max_size = Base.Maxu32) { return tsRadixSort_dispatchIndirect_CBBuRSFuu(self, compute.getSelf(), data.getSelf(), dispatch.getSelf(), offset, flags, bits, max_size); }
		public bool dispatchIndirect(Compute compute, Buffer data, uint count, Buffer dispatch, uint offset, Flags flags = Flags.None, uint bits = 32, uint max_size = Base.Maxu32) { return tsRadixSort_dispatchIndirect_CBuBuRSFuu(self, compute.getSelf(), data.getSelf(), count, dispatch.getSelf(), offset, flags, bits, max_size); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer count, Buffer dispatch, uint count_offset, uint dispatch_offset, Flags flags = Flags.None, uint bits = 32, uint max_size = Base.Maxu32) { return tsRadixSort_dispatchIndirect_CBBBuuRSFuu(self, compute.getSelf(), data.getSelf(), count.getSelf(), dispatch.getSelf(), count_offset, dispatch_offset, flags, bits, max_size); }
		public override string ToString() { return "Tellusim.RadixSort: Valid: " + tsRadixSort_isValidPtr(self) + "; Owner: " + tsRadixSort_isOwnerPtr(self) + "; Const: " + tsRadixSort_isConstPtr(self) + "; Count: " + tsRadixSort_getCountPtr(self) + "; Internal: 0x" + tsRadixSort_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(RadixSort ptr) { return (ptr != null && tsRadixSort_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsRadixSort_new();
		[DllImport(Base.Import)] private static extern void tsRadixSort_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsRadixSort_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsRadixSort_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsRadixSort_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsRadixSort_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsRadixSort_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsRadixSort_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsRadixSort_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsRadixSort_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_isCreated(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getDataSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getGroupSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getSortElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getUpdateElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getMaxElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsRadixSort_getMaxRegions(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsRadixSort_getPrefixScan(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsRadixSort_getDataBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_create_cDRSMPSuuuA(HandleRef self, HandleRef device, Mode mode, HandleRef scan, uint size, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_create_cDRSFPSuuuA(HandleRef self, HandleRef device, Flags flags, HandleRef scan, uint size, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_dispatch_CBuuuRSFu(HandleRef self, HandleRef compute, HandleRef data, uint keys_offset, uint data_offset, uint size, Flags flags, uint bits);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_dispatch_CBuupupupRSFu(HandleRef self, HandleRef compute, HandleRef data, uint count, uint[] keys_offsets, uint[] data_offsets, uint[] sizes, Flags flags, uint bits);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_dispatchIndirect_CBBuRSFuu(HandleRef self, HandleRef compute, HandleRef data, HandleRef dispatch, uint offset, Flags flags, uint bits, uint max_size);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_dispatchIndirect_CBuBuRSFuu(HandleRef self, HandleRef compute, HandleRef data, uint count, HandleRef dispatch, uint offset, Flags flags, uint bits, uint max_size);
		[DllImport(Base.Import)] private static extern bool tsRadixSort_dispatchIndirect_CBBBuuRSFuu(HandleRef self, HandleRef compute, HandleRef data, HandleRef count, HandleRef dispatch, uint count_offset, uint dispatch_offset, Flags flags, uint bits, uint max_size);
		[StructLayout(LayoutKind.Sequential)] public struct DispatchParameters {
			public uint keys_offset;
			public uint data_offset;
			public uint size;
			public uint padding;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("keys_offset: {0}\n", keys_offset);
				ret += System.String.Format("data_offset: {0}\n", data_offset);
				ret += System.String.Format("size: {0}\n", size);
				return ret;
			}
		}
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::BitonicSort
	public sealed class BitonicSort {
		public enum Mode : uint {
			Single = 0,
			Multiple,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			Single = 1,
			Multiple = 2,
			Indirect = 4,
			Order = 8,
			All = 15,
		}
		public BitonicSort() { self = new HandleRef(this, tsBitonicSort_new()); owner = true; }
		public BitonicSort(BitonicSort ptr) { self = new HandleRef(this, tsBitonicSort_copyPtr(ptr.getSelf())); owner = true; }
		public BitonicSort(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsBitonicSort_isOwnerPtr(self); }
		public static BitonicSort Null() { return new BitonicSort(IntPtr.Zero); }
		~BitonicSort() { if(owner) tsBitonicSort_delete(self); }
		public bool equalPtr(BitonicSort ptr) { return tsBitonicSort_equalPtr(self, ptr.getSelf()); }
		public BitonicSort clonePtr() { return new BitonicSort(tsBitonicSort_clonePtr(self)); }
		public void clearPtr() { tsBitonicSort_clearPtr(self); }
		public void destroyPtr() { tsBitonicSort_destroyPtr(self); }
		public void acquirePtr() { tsBitonicSort_acquirePtr(self); }
		public void unacquirePtr() { tsBitonicSort_unacquirePtr(self); }
		public bool isValidPtr() { return tsBitonicSort_isValidPtr(self); }
		public bool isOwnerPtr() { return tsBitonicSort_isOwnerPtr(self); }
		public bool isConstPtr() { return tsBitonicSort_isConstPtr(self); }
		public uint getCountPtr() { return tsBitonicSort_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsBitonicSort_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsBitonicSort_clear(self); }
		public bool isCreated(Flags flags) { return tsBitonicSort_isCreated(self, flags); }
		public uint getDataSize() { return tsBitonicSort_getDataSize(self); }
		public uint getGroupSize() { return tsBitonicSort_getGroupSize(self); }
		public uint getSortElements() { return tsBitonicSort_getSortElements(self); }
		public uint getMaxRegions() { return tsBitonicSort_getMaxRegions(self); }
		public bool create(Device device, Mode mode, uint size, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsBitonicSort_create_cDBSMuuuA(self, device.getSelf(), mode, size, groups, regions, ref async_);
		}
		public bool create(Device device, Flags flags, uint size, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsBitonicSort_create_cDBSFuuuA(self, device.getSelf(), flags, size, groups, regions, ref async_);
		}
		public bool dispatch(Compute compute, Buffer data, uint keys_offset, uint data_offset, uint size, Flags flags = Flags.None) { return tsBitonicSort_dispatch_CBuuuBSF(self, compute.getSelf(), data.getSelf(), keys_offset, data_offset, size, flags); }
		public bool dispatch(Compute compute, Buffer data, uint count, uint[] keys_offsets, uint[] data_offsets, uint[] sizes, Flags flags = Flags.None) { return tsBitonicSort_dispatch_CBuupupupBSF(self, compute.getSelf(), data.getSelf(), count, keys_offsets, data_offsets, sizes, flags); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer dispatch, uint offset, Flags flags = Flags.None) { return tsBitonicSort_dispatchIndirect_CBBuBSF(self, compute.getSelf(), data.getSelf(), dispatch.getSelf(), offset, flags); }
		public bool dispatchIndirect(Compute compute, Buffer data, uint count, Buffer dispatch, uint offset, Flags flags = Flags.None) { return tsBitonicSort_dispatchIndirect_CBuBuBSF(self, compute.getSelf(), data.getSelf(), count, dispatch.getSelf(), offset, flags); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer count, Buffer dispatch, uint count_offset, uint dispatch_offset, Flags flags = Flags.None) { return tsBitonicSort_dispatchIndirect_CBBBuuBSF(self, compute.getSelf(), data.getSelf(), count.getSelf(), dispatch.getSelf(), count_offset, dispatch_offset, flags); }
		public override string ToString() { return "Tellusim.BitonicSort: Valid: " + tsBitonicSort_isValidPtr(self) + "; Owner: " + tsBitonicSort_isOwnerPtr(self) + "; Const: " + tsBitonicSort_isConstPtr(self) + "; Count: " + tsBitonicSort_getCountPtr(self) + "; Internal: 0x" + tsBitonicSort_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(BitonicSort ptr) { return (ptr != null && tsBitonicSort_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsBitonicSort_new();
		[DllImport(Base.Import)] private static extern void tsBitonicSort_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsBitonicSort_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBitonicSort_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBitonicSort_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBitonicSort_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBitonicSort_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBitonicSort_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBitonicSort_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsBitonicSort_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsBitonicSort_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_isCreated(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern uint tsBitonicSort_getDataSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBitonicSort_getGroupSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBitonicSort_getSortElements(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsBitonicSort_getMaxRegions(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_create_cDBSMuuuA(HandleRef self, HandleRef device, Mode mode, uint size, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_create_cDBSFuuuA(HandleRef self, HandleRef device, Flags flags, uint size, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_dispatch_CBuuuBSF(HandleRef self, HandleRef compute, HandleRef data, uint keys_offset, uint data_offset, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_dispatch_CBuupupupBSF(HandleRef self, HandleRef compute, HandleRef data, uint count, uint[] keys_offsets, uint[] data_offsets, uint[] sizes, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_dispatchIndirect_CBBuBSF(HandleRef self, HandleRef compute, HandleRef data, HandleRef dispatch, uint offset, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_dispatchIndirect_CBuBuBSF(HandleRef self, HandleRef compute, HandleRef data, uint count, HandleRef dispatch, uint offset, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsBitonicSort_dispatchIndirect_CBBBuuBSF(HandleRef self, HandleRef compute, HandleRef data, HandleRef count, HandleRef dispatch, uint count_offset, uint dispatch_offset, Flags flags);
		[StructLayout(LayoutKind.Sequential)] public struct DispatchParameters {
			public uint keys_offset;
			public uint data_offset;
			public uint size;
			public uint padding;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("keys_offset: {0}\n", keys_offset);
				ret += System.String.Format("data_offset: {0}\n", data_offset);
				ret += System.String.Format("size: {0}\n", size);
				return ret;
			}
		}
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::SpatialGrid
	public sealed class SpatialGrid {
		public SpatialGrid() { self = new HandleRef(this, tsSpatialGrid_new()); owner = true; }
		public SpatialGrid(SpatialGrid ptr) { self = new HandleRef(this, tsSpatialGrid_copyPtr(ptr.getSelf())); owner = true; }
		public SpatialGrid(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSpatialGrid_isOwnerPtr(self); }
		public static SpatialGrid Null() { return new SpatialGrid(IntPtr.Zero); }
		~SpatialGrid() { if(owner) tsSpatialGrid_delete(self); }
		public bool equalPtr(SpatialGrid ptr) { return tsSpatialGrid_equalPtr(self, ptr.getSelf()); }
		public SpatialGrid clonePtr() { return new SpatialGrid(tsSpatialGrid_clonePtr(self)); }
		public void clearPtr() { tsSpatialGrid_clearPtr(self); }
		public void destroyPtr() { tsSpatialGrid_destroyPtr(self); }
		public void acquirePtr() { tsSpatialGrid_acquirePtr(self); }
		public void unacquirePtr() { tsSpatialGrid_unacquirePtr(self); }
		public bool isValidPtr() { return tsSpatialGrid_isValidPtr(self); }
		public bool isOwnerPtr() { return tsSpatialGrid_isOwnerPtr(self); }
		public bool isConstPtr() { return tsSpatialGrid_isConstPtr(self); }
		public uint getCountPtr() { return tsSpatialGrid_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsSpatialGrid_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsSpatialGrid_clear(self); }
		public bool isCreated() { return tsSpatialGrid_isCreated(self); }
		public uint getGroupSize() { return tsSpatialGrid_getGroupSize(self); }
		public RadixSort getRadixSort() { return new RadixSort(tsSpatialGrid_getRadixSort(self)); }
		public bool create(Device device, RadixSort sort, uint groups = 256) { return tsSpatialGrid_create(self, device.getSelf(), sort.getSelf(), groups); }
		public bool dispatch(Compute compute, Buffer data, uint offset, uint size, uint bits = 32) { return tsSpatialGrid_dispatch(self, compute.getSelf(), data.getSelf(), offset, size, bits); }
		public bool dispatchIndirect(Compute compute, Buffer data, Buffer dispatch, uint offset, uint max_size = Base.Maxu32) { return tsSpatialGrid_dispatchIndirect(self, compute.getSelf(), data.getSelf(), dispatch.getSelf(), offset, max_size); }
		public override string ToString() { return "Tellusim.SpatialGrid: Valid: " + tsSpatialGrid_isValidPtr(self) + "; Owner: " + tsSpatialGrid_isOwnerPtr(self) + "; Const: " + tsSpatialGrid_isConstPtr(self) + "; Count: " + tsSpatialGrid_getCountPtr(self) + "; Internal: 0x" + tsSpatialGrid_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(SpatialGrid ptr) { return (ptr != null && tsSpatialGrid_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialGrid_new();
		[DllImport(Base.Import)] private static extern void tsSpatialGrid_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialGrid_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialGrid_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialGrid_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialGrid_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialGrid_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialGrid_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSpatialGrid_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialGrid_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialGrid_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSpatialGrid_getGroupSize(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialGrid_getRadixSort(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_create(HandleRef self, HandleRef device, HandleRef sort, uint groups);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_dispatch(HandleRef self, HandleRef compute, HandleRef data, uint offset, uint size, uint bits);
		[DllImport(Base.Import)] private static extern bool tsSpatialGrid_dispatchIndirect(HandleRef self, HandleRef compute, HandleRef data, HandleRef dispatch, uint offset, uint max_size);
		[StructLayout(LayoutKind.Sequential)] public struct DispatchParameters {
			public uint offset;
			public uint size;
			public uint padding_0;
			public uint padding_1;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("offset: {0}\n", offset);
				ret += System.String.Format("size: {0}\n", size);
				return ret;
			}
		}
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::SpatialTree
	public sealed class SpatialTree {
		public enum Mode : uint {
			Single = 0,
			Multiple,
			NumModes,
		}
		public enum Hash : uint {
			XYZ10,
			XYZ9,
			XYZ8,
			XY15,
			XY14,
			XY12,
			XY10,
		}
		public enum Flags : uint {
			None = 0,
			Single = 1,
			Multiple = 2,
			Update = 4,
			Optimize = 8,
			Tracing = 16,
			Scratch = 32,
			Atomic = 64,
			LeafNodef16 = 128,
			SpatialData = 256,
			SingleUpdate = 5,
			MultipleUpdate = 6,
			SingleOptimize = 9,
			MultipleOptimize = 10,
			All = 3,
			AllOptimize = 11,
		}
		public SpatialTree() { self = new HandleRef(this, tsSpatialTree_new()); owner = true; }
		public SpatialTree(SpatialTree ptr) { self = new HandleRef(this, tsSpatialTree_copyPtr(ptr.getSelf())); owner = true; }
		public SpatialTree(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsSpatialTree_isOwnerPtr(self); }
		public static SpatialTree Null() { return new SpatialTree(IntPtr.Zero); }
		~SpatialTree() { if(owner) tsSpatialTree_delete(self); }
		public bool equalPtr(SpatialTree ptr) { return tsSpatialTree_equalPtr(self, ptr.getSelf()); }
		public SpatialTree clonePtr() { return new SpatialTree(tsSpatialTree_clonePtr(self)); }
		public void clearPtr() { tsSpatialTree_clearPtr(self); }
		public void destroyPtr() { tsSpatialTree_destroyPtr(self); }
		public void acquirePtr() { tsSpatialTree_acquirePtr(self); }
		public void unacquirePtr() { tsSpatialTree_unacquirePtr(self); }
		public bool isValidPtr() { return tsSpatialTree_isValidPtr(self); }
		public bool isOwnerPtr() { return tsSpatialTree_isOwnerPtr(self); }
		public bool isConstPtr() { return tsSpatialTree_isConstPtr(self); }
		public uint getCountPtr() { return tsSpatialTree_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsSpatialTree_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsSpatialTree_clear(self); }
		public bool isCreated(Flags flags) { return tsSpatialTree_isCreated(self, flags); }
		public uint getGroupSize() { return tsSpatialTree_getGroupSize(self); }
		public uint getBoundsNodes() { return tsSpatialTree_getBoundsNodes(self); }
		public uint getMaxNodes() { return tsSpatialTree_getMaxNodes(self); }
		public uint getMaxRegions() { return tsSpatialTree_getMaxRegions(self); }
		public RadixSort getRadixSort() { return new RadixSort(tsSpatialTree_getRadixSort(self)); }
		public Buffer getHashBuffer() { return new Buffer(tsSpatialTree_getHashBuffer(self)); }
		public Buffer getParentsBuffer() { return new Buffer(tsSpatialTree_getParentsBuffer(self)); }
		public Buffer getCounterBuffer() { return new Buffer(tsSpatialTree_getCounterBuffer(self)); }
		public bool create(Device device, Mode mode, RadixSort sort, uint size, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsSpatialTree_create_cDSTMRSuuuA(self, device.getSelf(), mode, sort.getSelf(), size, groups, regions, ref async_);
		}
		public bool create(Device device, Flags flags, RadixSort sort, uint size, uint groups = 256, uint regions = 1, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsSpatialTree_create_cDSTFRSuuuA(self, device.getSelf(), flags, sort.getSelf(), size, groups, regions, ref async_);
		}
		public bool dispatch(Compute compute, Hash hash, Buffer nodes, uint offset, uint size, Flags flags = Flags.None) { return tsSpatialTree_dispatch_CSTHBuuSTF(self, compute.getSelf(), hash, nodes.getSelf(), offset, size, flags); }
		public bool dispatch(Compute compute, Hash hash, Buffer nodes, uint count, uint[] offsets, uint[] sizes, Flags flags = Flags.None) { return tsSpatialTree_dispatch_CSTHBuupupSTF(self, compute.getSelf(), hash, nodes.getSelf(), count, offsets, sizes, flags); }
		public bool dispatchIndirect(Compute compute, Hash hash, Buffer nodes, Buffer dispatch, uint offset, uint max_size = Base.Maxu32, Flags flags = Flags.None) { return tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(self, compute.getSelf(), hash, nodes.getSelf(), dispatch.getSelf(), offset, max_size, flags); }
		public bool dispatchIndirect(Compute compute, Hash hash, Buffer nodes, uint count, Buffer dispatch, uint offset, uint max_size = Base.Maxu32, Flags flags = Flags.None) { return tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(self, compute.getSelf(), hash, nodes.getSelf(), count, dispatch.getSelf(), offset, max_size, flags); }
		public override string ToString() { return "Tellusim.SpatialTree: Valid: " + tsSpatialTree_isValidPtr(self) + "; Owner: " + tsSpatialTree_isOwnerPtr(self) + "; Const: " + tsSpatialTree_isConstPtr(self) + "; Count: " + tsSpatialTree_getCountPtr(self) + "; Internal: 0x" + tsSpatialTree_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(SpatialTree ptr) { return (ptr != null && tsSpatialTree_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_new();
		[DllImport(Base.Import)] private static extern void tsSpatialTree_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialTree_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialTree_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialTree_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialTree_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSpatialTree_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsSpatialTree_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_isCreated(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern uint tsSpatialTree_getGroupSize(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSpatialTree_getBoundsNodes(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSpatialTree_getMaxNodes(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsSpatialTree_getMaxRegions(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_getRadixSort(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_getHashBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_getParentsBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsSpatialTree_getCounterBuffer(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_create_cDSTMRSuuuA(HandleRef self, HandleRef device, Mode mode, HandleRef sort, uint size, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_create_cDSTFRSuuuA(HandleRef self, HandleRef device, Flags flags, HandleRef sort, uint size, uint groups, uint regions, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_dispatch_CSTHBuuSTF(HandleRef self, HandleRef compute, Hash hash, HandleRef nodes, uint offset, uint size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_dispatch_CSTHBuupupSTF(HandleRef self, HandleRef compute, Hash hash, HandleRef nodes, uint count, uint[] offsets, uint[] sizes, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(HandleRef self, HandleRef compute, Hash hash, HandleRef nodes, HandleRef dispatch, uint offset, uint max_size, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(HandleRef self, HandleRef compute, Hash hash, HandleRef nodes, uint count, HandleRef dispatch, uint offset, uint max_size, Flags flags);
		[StructLayout(LayoutKind.Sequential)] public struct Node {
			public Vector3f bound_min;
			public uint is_enabled;
			public Vector3f bound_max;
			public uint data;
			public uint left;
			public uint right;
			public uint parent;
			public uint spatial;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("bound_min: {0}\n", bound_min);
				ret += System.String.Format("is_enabled: {0}\n", is_enabled);
				ret += System.String.Format("bound_max: {0}\n", bound_max);
				ret += System.String.Format("data: {0}\n", data);
				ret += System.String.Format("left: {0}\n", left);
				ret += System.String.Format("right: {0}\n", right);
				ret += System.String.Format("parent: {0}\n", parent);
				ret += System.String.Format("spatial: {0}", spatial);
				return ret;
			}
		}
		[StructLayout(LayoutKind.Sequential)] public struct DispatchParameters {
			public uint offset;
			public uint size;
			public uint padding_0;
			public uint padding_1;
			public override string ToString() {
				string ret = "";
				ret += System.String.Format("offset: {0}\n", offset);
				ret += System.String.Format("size: {0}\n", size);
				return ret;
			}
		}
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::FourierTransform
	public sealed class FourierTransform {
		public enum Mode : uint {
			Rf16i = 0,
			Rf32i,
			RGf16i,
			RGf32i,
			RGBf16c,
			RGBf21c,
			RGBf16p,
			RGBf32p,
			NumModes,
		}
		public enum Flags : uint {
			None = 0,
			Rf16i = 1,
			Rf32i = 2,
			RGf16i = 4,
			RGf32i = 8,
			RGBf16c = 16,
			RGBf21c = 32,
			RGBf16p = 64,
			RGBf32p = 128,
			Npot = 256,
			Interleaved = 15,
			Complex = 48,
			Planar = 192,
			All = 511,
		}
		public enum Operation : uint {
			ForwardCtoC = 0,
			BackwardCtoC,
			ForwardRtoC,
			BackwardCtoR,
			NumOperations,
		}
		public FourierTransform() { self = new HandleRef(this, tsFourierTransform_new()); owner = true; }
		public FourierTransform(FourierTransform ptr) { self = new HandleRef(this, tsFourierTransform_copyPtr(ptr.getSelf())); owner = true; }
		public FourierTransform(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsFourierTransform_isOwnerPtr(self); }
		public static FourierTransform Null() { return new FourierTransform(IntPtr.Zero); }
		~FourierTransform() { if(owner) tsFourierTransform_delete(self); }
		public bool equalPtr(FourierTransform ptr) { return tsFourierTransform_equalPtr(self, ptr.getSelf()); }
		public FourierTransform clonePtr() { return new FourierTransform(tsFourierTransform_clonePtr(self)); }
		public void clearPtr() { tsFourierTransform_clearPtr(self); }
		public void destroyPtr() { tsFourierTransform_destroyPtr(self); }
		public void acquirePtr() { tsFourierTransform_acquirePtr(self); }
		public void unacquirePtr() { tsFourierTransform_unacquirePtr(self); }
		public bool isValidPtr() { return tsFourierTransform_isValidPtr(self); }
		public bool isOwnerPtr() { return tsFourierTransform_isOwnerPtr(self); }
		public bool isConstPtr() { return tsFourierTransform_isConstPtr(self); }
		public uint getCountPtr() { return tsFourierTransform_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsFourierTransform_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsFourierTransform_clear(self); }
		public bool isCreated(Mode mode) { return tsFourierTransform_isCreated_cFTM(self, mode); }
		public bool isCreated(Flags flags) { return tsFourierTransform_isCreated_cFTF(self, flags); }
		public uint getMaxWidth() { return tsFourierTransform_getMaxWidth(self); }
		public uint getMaxHeight() { return tsFourierTransform_getMaxHeight(self); }
		public uint getAlignedSize(uint size) { return tsFourierTransform_getAlignedSize(self, size); }
		public bool create(Device device, Mode mode, uint width, uint height, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsFourierTransform_create_cDFTMuuA(self, device.getSelf(), mode, width, height, ref async_);
		}
		public bool create(Device device, Flags flags, uint width, uint height, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsFourierTransform_create_cDFTFuuA(self, device.getSelf(), flags, width, height, ref async_);
		}
		public bool dispatch(Compute compute, Mode mode, Operation op, Texture dest, Texture src, in Slice dest_slice, in Slice src_slice) { return tsFourierTransform_dispatch_cCFTMFTOTTcScS(self, compute.getSelf(), mode, op, dest.getSelf(), src.getSelf(), in dest_slice, in src_slice); }
		public bool dispatch(Compute compute, Mode mode, Operation op, Texture dest, Texture src, in Slice src_slice) { return tsFourierTransform_dispatch_cCFTMFTOTTcS(self, compute.getSelf(), mode, op, dest.getSelf(), src.getSelf(), in src_slice); }
		public bool dispatch(Compute compute, Mode mode, Operation op, Texture dest, Texture src) { return tsFourierTransform_dispatch_cCFTMFTOTT(self, compute.getSelf(), mode, op, dest.getSelf(), src.getSelf()); }
		public override string ToString() { return "Tellusim.FourierTransform: Valid: " + tsFourierTransform_isValidPtr(self) + "; Owner: " + tsFourierTransform_isOwnerPtr(self) + "; Const: " + tsFourierTransform_isConstPtr(self) + "; Count: " + tsFourierTransform_getCountPtr(self) + "; Internal: 0x" + tsFourierTransform_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(FourierTransform ptr) { return (ptr != null && tsFourierTransform_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsFourierTransform_new();
		[DllImport(Base.Import)] private static extern void tsFourierTransform_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsFourierTransform_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFourierTransform_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFourierTransform_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFourierTransform_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFourierTransform_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFourierTransform_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFourierTransform_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsFourierTransform_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsFourierTransform_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_isCreated_cFTM(HandleRef self, Mode mode);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_isCreated_cFTF(HandleRef self, Flags flags);
		[DllImport(Base.Import)] private static extern uint tsFourierTransform_getMaxWidth(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFourierTransform_getMaxHeight(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsFourierTransform_getAlignedSize(HandleRef self, uint size);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_create_cDFTMuuA(HandleRef self, HandleRef device, Mode mode, uint width, uint height, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_create_cDFTFuuA(HandleRef self, HandleRef device, Flags flags, uint width, uint height, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_dispatch_cCFTMFTOTTcScS(HandleRef self, HandleRef compute, Mode mode, Operation op, HandleRef dest, HandleRef src, in Slice dest_slice, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_dispatch_cCFTMFTOTTcS(HandleRef self, HandleRef compute, Mode mode, Operation op, HandleRef dest, HandleRef src, in Slice src_slice);
		[DllImport(Base.Import)] private static extern bool tsFourierTransform_dispatch_cCFTMFTOTT(HandleRef self, HandleRef compute, Mode mode, Operation op, HandleRef dest, HandleRef src);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::TensorGraph
	public sealed class TensorGraph {
		public enum Operation : uint {
			Clear = 0,
			Range,
			Copy,
			Cat,
			Transpose,
			MatMul,
			Mul,
			Mad,
			Div,
			Add,
			Conv,
			DeConv,
			BatchNorm,
			BatchMad,
			SoftMin,
			SoftMax,
			MaxPool,
			AvgPool,
			GELU,
			ReLU,
			SiLU,
			Sigm,
			Tanh,
			Sin,
			Cos,
			Exp,
			NumOperations,
		}
		public enum Flags : uint {
			None = 0,
			SizeQuery = 1,
			FormatRf32 = 2,
			FormatRf16 = 4,
			Transpose = 8,
			WrapClamp = 16,
			WrapRepeat = 32,
			ReadScale = 64,
			ReadBias = 128,
			Convert = 256,
			Kernel = 512,
			GELU = 1024,
			ReLU = 2048,
			SiLU = 4096,
			Sigm = 8192,
			Tanh = 16384,
			Sin = 32768,
			Cos = 65536,
			Exp = 131072,
			Format = 6,
			Wrap = 48,
			Read = 192,
			Unit = 7168,
			Math = 253952,
			All = 262142,
		}
		public enum Masks : uint {
			MaskNone = 0,
			MaskClear = 1,
			MaskRange = 2,
			MaskCopy = 4,
			MaskCat = 8,
			MaskTranspose = 16,
			MaskMatMul = 32,
			MaskMul = 64,
			MaskMad = 128,
			MaskDiv = 256,
			MaskAdd = 512,
			MaskConv = 1024,
			MaskDeConv = 2048,
			MaskBatchNorm = 4096,
			MaskBatchMad = 8192,
			MaskSoftMin = 16384,
			MaskSoftMax = 32768,
			MaskMaxPool = 65536,
			MaskAvgPool = 131072,
			MaskGELU = 262144,
			MaskReLU = 524288,
			MaskSiLU = 1048576,
			MaskSigm = 2097152,
			MaskTanh = 4194304,
			MaskSin = 8388608,
			MaskCos = 16777216,
			MaskExp = 33554432,
			All = 67108863,
		}
		public TensorGraph() { self = new HandleRef(this, tsTensorGraph_new()); owner = true; }
		public TensorGraph(TensorGraph ptr) { self = new HandleRef(this, tsTensorGraph_copyPtr(ptr.getSelf())); owner = true; }
		public TensorGraph(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsTensorGraph_isOwnerPtr(self); }
		public static TensorGraph Null() { return new TensorGraph(IntPtr.Zero); }
		~TensorGraph() { if(owner) tsTensorGraph_delete(self); }
		public bool equalPtr(TensorGraph ptr) { return tsTensorGraph_equalPtr(self, ptr.getSelf()); }
		public TensorGraph clonePtr() { return new TensorGraph(tsTensorGraph_clonePtr(self)); }
		public void clearPtr() { tsTensorGraph_clearPtr(self); }
		public void destroyPtr() { tsTensorGraph_destroyPtr(self); }
		public void acquirePtr() { tsTensorGraph_acquirePtr(self); }
		public void unacquirePtr() { tsTensorGraph_unacquirePtr(self); }
		public bool isValidPtr() { return tsTensorGraph_isValidPtr(self); }
		public bool isOwnerPtr() { return tsTensorGraph_isOwnerPtr(self); }
		public bool isConstPtr() { return tsTensorGraph_isConstPtr(self); }
		public uint getCountPtr() { return tsTensorGraph_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsTensorGraph_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public void clear() { tsTensorGraph_clear(self); }
		public bool isCreated() { return tsTensorGraph_isCreated(self); }
		public bool create(Device device, Flags flags = Flags.All, Masks masks = Masks.All, in Async async = null) {
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsTensorGraph_create(self, device.getSelf(), flags, masks, ref async_);
		}
		public bool dispatch(Compute compute, Operation op, in Tensor dest, Flags flags = Flags.None) { return tsTensorGraph_dispatch_cCTGOcTTGF(self, compute.getSelf(), op, in dest, flags); }
		public bool dispatch(Compute compute, Operation op, ref Tensor dest, in Tensor src_0, Flags flags = Flags.None) { return tsTensorGraph_dispatch_cCTGOTcTTGF(self, compute.getSelf(), op, ref dest, in src_0, flags); }
		public bool dispatch(Compute compute, Operation op, ref Tensor dest, in Tensor src_0, in Tensor src_1, Flags flags = Flags.None) { return tsTensorGraph_dispatch_cCTGOTcTcTTGF(self, compute.getSelf(), op, ref dest, in src_0, in src_1, flags); }
		public bool dispatch(Compute compute, Operation op, ref Tensor dest, in Tensor src_0, in Tensor src_1, in Tensor src_2, Flags flags = Flags.None) { return tsTensorGraph_dispatch_cCTGOTcTcTcTTGF(self, compute.getSelf(), op, ref dest, in src_0, in src_1, in src_2, flags); }
		public bool dispatch(Compute compute, in Tensor dest, Texture src, in Region region, in Slice slice) { return tsTensorGraph_dispatch_cCcTTcRcS(self, compute.getSelf(), in dest, src.getSelf(), in region, in slice); }
		public bool dispatch(Compute compute, in Tensor dest, Texture src, in Slice slice) { return tsTensorGraph_dispatch_cCcTTcS(self, compute.getSelf(), in dest, src.getSelf(), in slice); }
		public bool dispatch(Compute compute, Texture dest, in Tensor src, in Region region, in Slice slice) { return tsTensorGraph_dispatch_cCTcTcRcS(self, compute.getSelf(), dest.getSelf(), in src, in region, in slice); }
		public bool dispatch(Compute compute, Texture dest, in Tensor src, in Slice slice) { return tsTensorGraph_dispatch_cCTcTcS(self, compute.getSelf(), dest.getSelf(), in src, in slice); }
		public override string ToString() { return "Tellusim.TensorGraph: Valid: " + tsTensorGraph_isValidPtr(self) + "; Owner: " + tsTensorGraph_isOwnerPtr(self) + "; Const: " + tsTensorGraph_isConstPtr(self) + "; Count: " + tsTensorGraph_getCountPtr(self) + "; Internal: 0x" + tsTensorGraph_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(TensorGraph ptr) { return (ptr != null && tsTensorGraph_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsTensorGraph_new();
		[DllImport(Base.Import)] private static extern void tsTensorGraph_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsTensorGraph_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTensorGraph_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTensorGraph_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTensorGraph_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTensorGraph_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTensorGraph_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsTensorGraph_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsTensorGraph_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsTensorGraph_clear(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_isCreated(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_create(HandleRef self, HandleRef device, Flags flags, Masks masks, ref IntPtr async);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCTGOcTTGF(HandleRef self, HandleRef compute, Operation op, in Tensor dest, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCTGOTcTTGF(HandleRef self, HandleRef compute, Operation op, ref Tensor dest, in Tensor src_0, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCTGOTcTcTTGF(HandleRef self, HandleRef compute, Operation op, ref Tensor dest, in Tensor src_0, in Tensor src_1, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCTGOTcTcTcTTGF(HandleRef self, HandleRef compute, Operation op, ref Tensor dest, in Tensor src_0, in Tensor src_1, in Tensor src_2, Flags flags);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCcTTcRcS(HandleRef self, HandleRef compute, in Tensor dest, HandleRef src, in Region region, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCcTTcS(HandleRef self, HandleRef compute, in Tensor dest, HandleRef src, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCTcTcRcS(HandleRef self, HandleRef compute, HandleRef dest, in Tensor src, in Region region, in Slice slice);
		[DllImport(Base.Import)] private static extern bool tsTensorGraph_dispatch_cCTcTcS(HandleRef self, HandleRef compute, HandleRef dest, in Tensor src, in Slice slice);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Controller
	public sealed class Controller {
		public enum Type : uint {
			Unknown = 0,
			Joystick,
			GamePad,
			Wheel,
			NumTypes,
		}
		public enum Stick : uint {
			Left = 0,
			Right,
			NumSticks,
		}
		public enum Axis : uint {
			X = 0,
			Y,
			Z,
			RX,
			RY,
			RZ,
			NumAxes = 16,
		}
		public enum Button : uint {
			Left = 0,
			Right,
			Down,
			Up,
			Home,
			ShoulderLeft,
			ShoulderRight,
			TriggerLeft,
			TriggerRight,
			StickLeft,
			StickRight,
			A,
			B,
			X,
			Y,
			View,
			Menu,
			L1 = 5,
			R1,
			L2,
			R2,
			L3,
			R3,
			Cross,
			Circle,
			Square,
			Triangle,
			Share,
			Options,
			NumButtons = 32,
		}
		public enum Motor : uint {
			Low = 0,
			High,
			NumMotors,
		}
		public delegate void ButtonPressedCallback(Controller controller, Button button, IntPtr data_);
		public delegate void ButtonPressedCallback_(IntPtr controller, Button button, IntPtr data_);
		public delegate void ButtonReleasedCallback(Controller controller, Button button, IntPtr data_);
		public delegate void ButtonReleasedCallback_(IntPtr controller, Button button, IntPtr data_);
		public delegate void ConnectedCallback(Controller controller, IntPtr data_);
		public delegate void ConnectedCallback_(IntPtr controller, IntPtr data_);
		public delegate void DisconnectedCallback(Controller controller, IntPtr data_);
		public delegate void DisconnectedCallback_(IntPtr controller, IntPtr data_);
		public Controller() { self = new HandleRef(this, tsController_new()); owner = true; }
		public Controller(uint index) { self = new HandleRef(this, tsController_new_u(index)); owner = true; }
		public Controller(Type type, uint index = Base.Maxu32) { self = new HandleRef(this, tsController_new_CTu(type, index)); owner = true; }
		public Controller(Controller ptr) { self = new HandleRef(this, tsController_copyPtr(ptr.getSelf())); owner = true; }
		public Controller(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsController_isOwnerPtr(self); }
		public static Controller Null() { return new Controller(IntPtr.Zero); }
		~Controller() { if(owner) tsController_delete(self); }
		public bool equalPtr(Controller ptr) { return tsController_equalPtr(self, ptr.getSelf()); }
		public Controller clonePtr() { return new Controller(tsController_clonePtr(self)); }
		public void clearPtr() { tsController_clearPtr(self); }
		public void destroyPtr() { tsController_destroyPtr(self); }
		public void acquirePtr() { tsController_acquirePtr(self); }
		public void unacquirePtr() { tsController_unacquirePtr(self); }
		public bool isValidPtr() { return tsController_isValidPtr(self); }
		public bool isOwnerPtr() { return tsController_isOwnerPtr(self); }
		public bool isConstPtr() { return tsController_isConstPtr(self); }
		public uint getCountPtr() { return tsController_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsController_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public static uint getNumControllers() { return tsController_getNumControllers(); }
		public static uint findController(string name) { return tsController_findController(name); }
		public static Controller getController(uint index) { return new Controller(tsController_getController(index)); }
		public static void update() { tsController_update(); }
		public void setType(Type type) { tsController_setType(self, type); }
		public Type getType() { return tsController_getType(self); }
		public static string getTypeName(Type type) { return Base.getCString(tsController_getTypeName_CT(type)); }
		public string getTypeName() { return Base.getCString(tsController_getTypeName_c(self)); }
		public bool isUnknown() { return tsController_isUnknown(self); }
		public bool isJoystick() { return tsController_isJoystick(self); }
		public bool isGamePad() { return tsController_isGamePad(self); }
		public bool isWheel() { return tsController_isWheel(self); }
		public void setIndex(uint index) { tsController_setIndex(self, index); }
		public uint getIndex() { return tsController_getIndex(self); }
		public void setName(string name) { tsController_setName(self, name); }
		public string getName() { return Base.getString(tsController_getName(self)); }
		public void setModel(string model) { tsController_setModel(self, model); }
		public string getModel() { return Base.getString(tsController_getModel(self)); }
		public bool isConnected() { return tsController_isConnected(self); }
		public bool wasConnected() { return tsController_wasConnected(self); }
		public bool connect(string name = "") { return tsController_connect(self, name); }
		public void release() { tsController_release(self); }
		public void setStickName(Stick stick, string name) { tsController_setStickName(self, stick, name); }
		public string getStickName(Stick stick) { return Base.getString(tsController_getStickName(self, stick)); }
		public Stick findStick(string name) { return tsController_findStick(self, name); }
		public void setStick(Stick stick, float x, float y) { tsController_setStick(self, stick, x, y); }
		public float getStickX(Stick stick) { return tsController_getStickX(self, stick); }
		public float getStickY(Stick stick) { return tsController_getStickY(self, stick); }
		public void setAxisName(Axis axis, string name) { tsController_setAxisName(self, axis, name); }
		public string getAxisName(Axis axis) { return Base.getString(tsController_getAxisName(self, axis)); }
		public Axis findAxis(string name) { return tsController_findAxis(self, name); }
		public void setAxis(Axis axis, float value) { tsController_setAxis(self, axis, value); }
		public float getAxis(Axis axis) { return tsController_getAxis(self, axis); }
		public void setButtonName(Button button, string name) { tsController_setButtonName(self, button, name); }
		public string getButtonName(Button button) { return Base.getString(tsController_getButtonName(self, button)); }
		public Button findButton(string name) { return tsController_findButton(self, name); }
		public void setButton(Button button, bool value) { tsController_setButton(self, button, value); }
		public bool getButton(Button button, bool clear = false) { return tsController_getButton(self, button, clear); }
		public bool wasButtonPressed(Button button) { return tsController_wasButtonPressed(self, button); }
		public bool wasButtonReleased(Button button) { return tsController_wasButtonReleased(self, button); }
		public void setButtonValue(Button button, float value) { tsController_setButtonValue(self, button, value); }
		public float getButtonValue(Button button) { return tsController_getButtonValue(self, button); }
		public void setMotorName(Motor motor, string name) { tsController_setMotorName(self, motor, name); }
		public string getMotorName(Motor motor) { return Base.getString(tsController_getMotorName(self, motor)); }
		public Motor findMotor(string name) { return tsController_findMotor(self, name); }
		public void setMotor(Motor motor, float value) { tsController_setMotor(self, motor, value); }
		public float getMotor(Motor motor) { return tsController_getMotor(self, motor); }
		public void setButtonPressedCallback(ButtonPressedCallback func, IntPtr data = new IntPtr()) {
			Controller.ButtonPressedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr controller_, Button button_, IntPtr data_) => { func(new Controller(controller_), button_, data_); };
			if(func_ != null) ButtonPressedCallback_50 = GCHandle.Alloc(func_);
			tsController_setButtonPressedCallback(self, Base.getFunc(func_), data);
		}
		public void setButtonReleasedCallback(ButtonReleasedCallback func, IntPtr data = new IntPtr()) {
			Controller.ButtonReleasedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr controller_, Button button_, IntPtr data_) => { func(new Controller(controller_), button_, data_); };
			if(func_ != null) ButtonReleasedCallback_52 = GCHandle.Alloc(func_);
			tsController_setButtonReleasedCallback(self, Base.getFunc(func_), data);
		}
		public void setConnectedCallback(ConnectedCallback func, IntPtr data = new IntPtr()) {
			Controller.ConnectedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr controller_, IntPtr data_) => { func(new Controller(controller_), data_); };
			if(func_ != null) ConnectedCallback_54 = GCHandle.Alloc(func_);
			tsController_setConnectedCallback(self, Base.getFunc(func_), data);
		}
		public void setDisconnectedCallback(DisconnectedCallback func, IntPtr data = new IntPtr()) {
			Controller.DisconnectedCallback_ func_ = null;
			if(func != null) func_ = (IntPtr controller_, IntPtr data_) => { func(new Controller(controller_), data_); };
			if(func_ != null) DisconnectedCallback_56 = GCHandle.Alloc(func_);
			tsController_setDisconnectedCallback(self, Base.getFunc(func_), data);
		}
		private GCHandle ButtonPressedCallback_50;
		private GCHandle ButtonReleasedCallback_52;
		private GCHandle ConnectedCallback_54;
		private GCHandle DisconnectedCallback_56;
		public override string ToString() { return "Tellusim.Controller: Valid: " + tsController_isValidPtr(self) + "; Owner: " + tsController_isOwnerPtr(self) + "; Const: " + tsController_isConstPtr(self) + "; Count: " + tsController_getCountPtr(self) + "; Internal: 0x" + tsController_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Controller ptr) { return (ptr != null && tsController_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsController_new();
		[DllImport(Base.Import)] private static extern IntPtr tsController_new_u(uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsController_new_CTu(Type type, uint index);
		[DllImport(Base.Import)] private static extern void tsController_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsController_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsController_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsController_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsController_getNumControllers();
		[DllImport(Base.Import)] private static extern uint tsController_findController(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getController(uint index);
		[DllImport(Base.Import)] private static extern void tsController_update();
		[DllImport(Base.Import)] private static extern void tsController_setType(HandleRef self, Type type);
		[DllImport(Base.Import)] private static extern Type tsController_getType(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getTypeName_CT(Type type);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getTypeName_c(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isUnknown(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isJoystick(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isGamePad(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isWheel(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_setIndex(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsController_getIndex(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_setName(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getName(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_setModel(HandleRef self, string model);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getModel(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_isConnected(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_wasConnected(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsController_connect(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsController_release(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsController_setStickName(HandleRef self, Stick stick, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getStickName(HandleRef self, Stick stick);
		[DllImport(Base.Import)] private static extern Stick tsController_findStick(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsController_setStick(HandleRef self, Stick stick, float x, float y);
		[DllImport(Base.Import)] private static extern float tsController_getStickX(HandleRef self, Stick stick);
		[DllImport(Base.Import)] private static extern float tsController_getStickY(HandleRef self, Stick stick);
		[DllImport(Base.Import)] private static extern void tsController_setAxisName(HandleRef self, Axis axis, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getAxisName(HandleRef self, Axis axis);
		[DllImport(Base.Import)] private static extern Axis tsController_findAxis(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsController_setAxis(HandleRef self, Axis axis, float value);
		[DllImport(Base.Import)] private static extern float tsController_getAxis(HandleRef self, Axis axis);
		[DllImport(Base.Import)] private static extern void tsController_setButtonName(HandleRef self, Button button, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getButtonName(HandleRef self, Button button);
		[DllImport(Base.Import)] private static extern Button tsController_findButton(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsController_setButton(HandleRef self, Button button, bool value);
		[DllImport(Base.Import)] private static extern bool tsController_getButton(HandleRef self, Button button, bool clear);
		[DllImport(Base.Import)] private static extern bool tsController_wasButtonPressed(HandleRef self, Button button);
		[DllImport(Base.Import)] private static extern bool tsController_wasButtonReleased(HandleRef self, Button button);
		[DllImport(Base.Import)] private static extern void tsController_setButtonValue(HandleRef self, Button button, float value);
		[DllImport(Base.Import)] private static extern float tsController_getButtonValue(HandleRef self, Button button);
		[DllImport(Base.Import)] private static extern void tsController_setMotorName(HandleRef self, Motor motor, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsController_getMotorName(HandleRef self, Motor motor);
		[DllImport(Base.Import)] private static extern Motor tsController_findMotor(HandleRef self, string name);
		[DllImport(Base.Import)] private static extern void tsController_setMotor(HandleRef self, Motor motor, float value);
		[DllImport(Base.Import)] private static extern float tsController_getMotor(HandleRef self, Motor motor);
		[DllImport(Base.Import)] private static extern void tsController_setButtonPressedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsController_setButtonReleasedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsController_setConnectedCallback(HandleRef self, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern void tsController_setDisconnectedCallback(HandleRef self, IntPtr func, IntPtr data_);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim::Desktop
	public sealed class Desktop {
		public Desktop() { self = new HandleRef(this, tsDesktop_new()); owner = true; }
		public Desktop(Desktop ptr) { self = new HandleRef(this, tsDesktop_copyPtr(ptr.getSelf())); owner = true; }
		public Desktop(IntPtr ptr) { self = new HandleRef(this, ptr); owner = tsDesktop_isOwnerPtr(self); }
		public static Desktop Null() { return new Desktop(IntPtr.Zero); }
		~Desktop() { if(owner) tsDesktop_delete(self); }
		public bool equalPtr(Desktop ptr) { return tsDesktop_equalPtr(self, ptr.getSelf()); }
		public Desktop clonePtr() { return new Desktop(tsDesktop_clonePtr(self)); }
		public void clearPtr() { tsDesktop_clearPtr(self); }
		public void destroyPtr() { tsDesktop_destroyPtr(self); }
		public void acquirePtr() { tsDesktop_acquirePtr(self); }
		public void unacquirePtr() { tsDesktop_unacquirePtr(self); }
		public bool isValidPtr() { return tsDesktop_isValidPtr(self); }
		public bool isOwnerPtr() { return tsDesktop_isOwnerPtr(self); }
		public bool isConstPtr() { return tsDesktop_isConstPtr(self); }
		public uint getCountPtr() { return tsDesktop_getCountPtr(self); }
		public IntPtr getInternalPtr() { return tsDesktop_getInternalPtr(self); }
		public HandleRef getSelf() { return self; }
		public IntPtr getSelfPtr() { return self.Handle; }
		public bool update() { return tsDesktop_update(self); }
		public uint getWidth() { return tsDesktop_getWidth_c(self); }
		public uint getHeight() { return tsDesktop_getHeight_c(self); }
		public int getPositionX() { return tsDesktop_getPositionX_c(self); }
		public int getPositionY() { return tsDesktop_getPositionY_c(self); }
		public float getScale() { return tsDesktop_getScale(self); }
		public uint getNumScreens() { return tsDesktop_getNumScreens(self); }
		public string getScreenName(uint index) { return Base.getString(tsDesktop_getScreenName(self, index)); }
		public string getScreenDevice(uint index) { return Base.getString(tsDesktop_getScreenDevice(self, index)); }
		public uint getScreenWidth(uint index) { return tsDesktop_getScreenWidth(self, index); }
		public uint getScreenHeight(uint index) { return tsDesktop_getScreenHeight(self, index); }
		public int getScreenPositionX(uint index) { return tsDesktop_getScreenPositionX(self, index); }
		public int getScreenPositionY(uint index) { return tsDesktop_getScreenPositionY(self, index); }
		public uint getScreenFrequency(uint index) { return tsDesktop_getScreenFrequency(self, index); }
		public uint getNumModes(uint index) { return tsDesktop_getNumModes(self, index); }
		public uint getModeWidth(uint index, uint mode) { return tsDesktop_getModeWidth(self, index, mode); }
		public uint getModeHeight(uint index, uint mode) { return tsDesktop_getModeHeight(self, index, mode); }
		public uint getModeIndex(uint index, uint width, uint height) { return tsDesktop_getModeIndex(self, index, width, height); }
		public bool setMode(uint index, uint width, uint height) { return tsDesktop_setMode(self, index, width, height); }
		public bool restoreMode(uint index) { return tsDesktop_restoreMode(self, index); }
		public uint getWidth(uint index) { return tsDesktop_getWidth_cu(self, index); }
		public uint getHeight(uint index) { return tsDesktop_getHeight_cu(self, index); }
		public int getPositionX(uint index) { return tsDesktop_getPositionX_cu(self, index); }
		public int getPositionY(uint index) { return tsDesktop_getPositionY_cu(self, index); }
		public uint getScreenIndex(int x, int y) { return tsDesktop_getScreenIndex(self, x, y); }
		public bool setMouse(int x, int y) { return tsDesktop_setMouse(self, x, y); }
		public bool getMouse(ref int x, ref int y) { return tsDesktop_getMouse(self, ref x, ref y); }
		public override string ToString() { return "Tellusim.Desktop: Valid: " + tsDesktop_isValidPtr(self) + "; Owner: " + tsDesktop_isOwnerPtr(self) + "; Const: " + tsDesktop_isConstPtr(self) + "; Count: " + tsDesktop_getCountPtr(self) + "; Internal: 0x" + tsDesktop_getInternalPtr(self).ToString("x8") + "; Self: 0x" + self.Handle.ToString("x8") + "; Owner: " + owner; }
		public static implicit operator bool(Desktop ptr) { return (ptr != null && tsDesktop_isValidPtr(ptr.getSelf())); }
		[DllImport(Base.Import)] private static extern IntPtr tsDesktop_new();
		[DllImport(Base.Import)] private static extern void tsDesktop_delete(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDesktop_equalPtr(HandleRef self, HandleRef ptr);
		[DllImport(Base.Import)] private static extern IntPtr tsDesktop_copyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDesktop_clonePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDesktop_clearPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDesktop_destroyPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDesktop_acquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern void tsDesktop_unacquirePtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDesktop_isValidPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDesktop_isOwnerPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDesktop_isConstPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getCountPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDesktop_getInternalPtr(HandleRef self);
		[DllImport(Base.Import)] private static extern bool tsDesktop_update(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getWidth_c(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getHeight_c(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDesktop_getPositionX_c(HandleRef self);
		[DllImport(Base.Import)] private static extern int tsDesktop_getPositionY_c(HandleRef self);
		[DllImport(Base.Import)] private static extern float tsDesktop_getScale(HandleRef self);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getNumScreens(HandleRef self);
		[DllImport(Base.Import)] private static extern IntPtr tsDesktop_getScreenName(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern IntPtr tsDesktop_getScreenDevice(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getScreenWidth(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getScreenHeight(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern int tsDesktop_getScreenPositionX(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern int tsDesktop_getScreenPositionY(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getScreenFrequency(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getNumModes(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getModeWidth(HandleRef self, uint index, uint mode);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getModeHeight(HandleRef self, uint index, uint mode);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getModeIndex(HandleRef self, uint index, uint width, uint height);
		[DllImport(Base.Import)] private static extern bool tsDesktop_setMode(HandleRef self, uint index, uint width, uint height);
		[DllImport(Base.Import)] private static extern bool tsDesktop_restoreMode(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getWidth_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getHeight_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern int tsDesktop_getPositionX_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern int tsDesktop_getPositionY_cu(HandleRef self, uint index);
		[DllImport(Base.Import)] private static extern uint tsDesktop_getScreenIndex(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern bool tsDesktop_setMouse(HandleRef self, int x, int y);
		[DllImport(Base.Import)] private static extern bool tsDesktop_getMouse(HandleRef self, ref int x, ref int y);
		private HandleRef self;
		private bool owner;
	}
	
	// Tellusim
	public static partial class Base {
		public static string getPlatformName(Platform platform) { return Base.getCString(ts_getPlatformName(platform)); }
		public static Platform findPlatformName(string name) { return ts_findPlatformName(name); }
		public static bool isPlatformAvailable(Platform platform) { return ts_isPlatformAvailable(platform); }
		public static string getFormatName(Format format) { return Base.getCString(ts_getFormatName(format)); }
		public static Format findFormatName(string name) { return ts_findFormatName(name); }
		public static string getGLSLFormatName(Format format) { return Base.getCString(ts_getGLSLFormatName(format)); }
		public static Format findGLSLFormatName(string name) { return ts_findGLSLFormatName(name); }
		public static bool isColorFormat(Format format) { return ts_isColorFormat(format); }
		public static bool isDepthFormat(Format format) { return ts_isDepthFormat(format); }
		public static bool isPixelFormat(Format format) { return ts_isPixelFormat(format); }
		public static bool isPlainFormat(Format format) { return ts_isPlainFormat(format); }
		public static bool isMixedFormat(Format format) { return ts_isMixedFormat(format); }
		public static bool isBlockFormat(Format format) { return ts_isBlockFormat(format); }
		public static bool isStencilFormat(Format format) { return ts_isStencilFormat(format); }
		public static Format toPixelFormat(Format format) { return ts_toPixelFormat(format); }
		public static bool isNormFormat(Format format) { return ts_isNormFormat(format); }
		public static bool isSRGBFormat(Format format) { return ts_isSRGBFormat(format); }
		public static bool isSignedFormat(Format format) { return ts_isSignedFormat(format); }
		public static bool isUnsignedFormat(Format format) { return ts_isUnsignedFormat(format); }
		public static bool isIntegerFormat(Format format) { return ts_isIntegerFormat(format); }
		public static bool isFloatFormat(Format format) { return ts_isFloatFormat(format); }
		public static Format toNormFormat(Format format) { return ts_toNormFormat(format); }
		public static Format toSRGBFormat(Format format) { return ts_toSRGBFormat(format); }
		public static Format toSignedFormat(Format format) { return ts_toSignedFormat(format); }
		public static Format toUnsignedFormat(Format format) { return ts_toUnsignedFormat(format); }
		public static Format toFloatFormat(Format format) { return ts_toFloatFormat(format); }
		public static bool isi8Format(Format format) { return ts_isi8Format(format); }
		public static bool isu8Format(Format format) { return ts_isu8Format(format); }
		public static bool is8BitFormat(Format format) { return ts_is8BitFormat(format); }
		public static Format to8BitFormat(Format format) { return ts_to8BitFormat(format); }
		public static bool isi16Format(Format format) { return ts_isi16Format(format); }
		public static bool isu16Format(Format format) { return ts_isu16Format(format); }
		public static bool isf16Format(Format format) { return ts_isf16Format(format); }
		public static bool is16BitFormat(Format format) { return ts_is16BitFormat(format); }
		public static Format to16BitFormat(Format format) { return ts_to16BitFormat(format); }
		public static bool isi32Format(Format format) { return ts_isi32Format(format); }
		public static bool isu32Format(Format format) { return ts_isu32Format(format); }
		public static bool isf32Format(Format format) { return ts_isf32Format(format); }
		public static bool is32BitFormat(Format format) { return ts_is32BitFormat(format); }
		public static Format to32BitFormat(Format format) { return ts_to32BitFormat(format); }
		public static bool isi64Format(Format format) { return ts_isi64Format(format); }
		public static bool isu64Format(Format format) { return ts_isu64Format(format); }
		public static bool isf64Format(Format format) { return ts_isf64Format(format); }
		public static bool is64BitFormat(Format format) { return ts_is64BitFormat(format); }
		public static bool isBC15Format(Format format) { return ts_isBC15Format(format); }
		public static bool isBC67Format(Format format) { return ts_isBC67Format(format); }
		public static bool isETC2Format(Format format) { return ts_isETC2Format(format); }
		public static bool isASTCFormat(Format format) { return ts_isASTCFormat(format); }
		public static uint getFormatComponents(Format format) { return ts_getFormatComponents(format); }
		public static Format toFormatComponents(Format format, uint components) { return ts_toFormatComponents(format, components); }
		public static uint getFormatPixelSize(Format format) { return ts_getFormatPixelSize(format); }
		public static uint getFormatBlockSize(Format format) { return ts_getFormatBlockSize(format); }
		public static uint getFormatBlockWidth(Format format) { return ts_getFormatBlockWidth(format); }
		public static uint getFormatBlockHeight(Format format) { return ts_getFormatBlockHeight(format); }
		public static uint getPixelFormatValue(Format format, float[] value, IntPtr src, uint stride = 0) { return ts_getPixelFormatValue(format, value, src, stride); }
		public static uint setPixelFormatValue(Format format, IntPtr dest, float[] value, uint stride = 0) { return ts_setPixelFormatValue(format, dest, value, stride); }
		[DllImport(Base.Import)] private static extern IntPtr ts_getPlatformName(Platform platform);
		[DllImport(Base.Import)] private static extern Platform ts_findPlatformName(string name);
		[DllImport(Base.Import)] private static extern bool ts_isPlatformAvailable(Platform platform);
		[DllImport(Base.Import)] private static extern IntPtr ts_getFormatName(Format format);
		[DllImport(Base.Import)] private static extern Format ts_findFormatName(string name);
		[DllImport(Base.Import)] private static extern IntPtr ts_getGLSLFormatName(Format format);
		[DllImport(Base.Import)] private static extern Format ts_findGLSLFormatName(string name);
		[DllImport(Base.Import)] private static extern bool ts_isColorFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isDepthFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isPixelFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isPlainFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isMixedFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isBlockFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isStencilFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toPixelFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isNormFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isSRGBFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isSignedFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isUnsignedFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isIntegerFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isFloatFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toNormFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toSRGBFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toSignedFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toUnsignedFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toFloatFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isi8Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isu8Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_is8BitFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_to8BitFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isi16Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isu16Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isf16Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_is16BitFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_to16BitFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isi32Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isu32Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isf32Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_is32BitFormat(Format format);
		[DllImport(Base.Import)] private static extern Format ts_to32BitFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isi64Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isu64Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isf64Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_is64BitFormat(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isBC15Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isBC67Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isETC2Format(Format format);
		[DllImport(Base.Import)] private static extern bool ts_isASTCFormat(Format format);
		[DllImport(Base.Import)] private static extern uint ts_getFormatComponents(Format format);
		[DllImport(Base.Import)] private static extern Format ts_toFormatComponents(Format format, uint components);
		[DllImport(Base.Import)] private static extern uint ts_getFormatPixelSize(Format format);
		[DllImport(Base.Import)] private static extern uint ts_getFormatBlockSize(Format format);
		[DllImport(Base.Import)] private static extern uint ts_getFormatBlockWidth(Format format);
		[DllImport(Base.Import)] private static extern uint ts_getFormatBlockHeight(Format format);
		[DllImport(Base.Import)] private static extern uint ts_getPixelFormatValue(Format format, float[] value, IntPtr src, uint stride);
		[DllImport(Base.Import)] private static extern uint ts_setPixelFormatValue(Format format, IntPtr dest, float[] value, uint stride);
	}
	
	// Tellusim::Allocator
	public static class Allocator {
		public static IntPtr allocate(ulong size) { return tsAllocator_allocate_z(size); }
		public static IntPtr reallocate(IntPtr ptr, ulong old_size, ulong new_size) { return tsAllocator_reallocate(ptr, old_size, new_size); }
		public static void free(IntPtr ptr, ulong size) { tsAllocator_free(ptr, size); }
		public static ulong getMemory() { return tsAllocator_getMemory(); }
		public static ulong getAllocations() { return tsAllocator_getAllocations(); }
		[DllImport(Base.Import)] private static extern IntPtr tsAllocator_allocate_z(ulong size);
		[DllImport(Base.Import)] private static extern IntPtr tsAllocator_reallocate(IntPtr ptr, ulong old_size, ulong new_size);
		[DllImport(Base.Import)] private static extern void tsAllocator_free(IntPtr ptr, ulong size);
		[DllImport(Base.Import)] private static extern ulong tsAllocator_getMemory();
		[DllImport(Base.Import)] private static extern ulong tsAllocator_getAllocations();
	}
	
	// Tellusim::Log
	public static class Log {
		public enum Level : uint {
			Fatal = 0,
			Error,
			Warning,
			Message,
			Verbose,
			Unknown,
			NumLevels,
		}
		public delegate bool Callback(Level a0, ulong time, string str, IntPtr data);
		public static void setLevel(Level level) { tsLog_setLevel(level); }
		public static Level getLevel() { return tsLog_getLevel(); }
		public static void setCallback(Callback callback, IntPtr data = new IntPtr()) {
			if(callback != null) Callback_2 = GCHandle.Alloc(callback);
			tsLog_setCallback(Base.getFunc(callback), data);
		}
		public static IntPtr getCallbackData() { return tsLog_getCallbackData(); }
		public static void unlockCallback() { tsLog_unlockCallback(); }
		public static void lockCallback() { tsLog_lockCallback(); }
		public static void print(string str) { tsLog_print_s(str); }
		public static void print(Level level, string str) { tsLog_print_LLs(level, str); }
		public static void printe(Level level, string str) { tsLog_printe(level, str); }
		private static GCHandle Callback_2;
		public static void printf(string format, params object[] args) { tsLog_print_s(System.String.Format(format, args)); }
		public static void printf(Level level, string format, params object[] args) { tsLog_print_LLs(level, System.String.Format(format, args)); }
		public static void printef(Level level, string format, params object[] args) { tsLog_printe(level, System.String.Format(format, args)); }
		[DllImport(Base.Import)] private static extern void tsLog_setLevel(Level level);
		[DllImport(Base.Import)] private static extern Level tsLog_getLevel();
		[DllImport(Base.Import)] private static extern void tsLog_setCallback(IntPtr callback, IntPtr data);
		[DllImport(Base.Import)] private static extern IntPtr tsLog_getCallbackData();
		[DllImport(Base.Import)] private static extern void tsLog_unlockCallback();
		[DllImport(Base.Import)] private static extern void tsLog_lockCallback();
		[DllImport(Base.Import)] private static extern void tsLog_print_s(string str);
		[DllImport(Base.Import)] private static extern void tsLog_print_LLs(Level level, string str);
		[DllImport(Base.Import)] private static extern void tsLog_printe(Level level, string str);
	}
	
	// Tellusim::Time
	public static class Time {
		public const uint Seconds = 1000000u;
		public const uint MSeconds = 1000u;
		public const uint USeconds = 1u;
		public static ulong current() { return tsTime_current(); }
		public static double seconds() { return tsTime_seconds(); }
		public static void sleep(uint usec) { tsTime_sleep(usec); }
		[DllImport(Base.Import)] private static extern ulong tsTime_current();
		[DllImport(Base.Import)] private static extern double tsTime_seconds();
		[DllImport(Base.Import)] private static extern void tsTime_sleep(uint usec);
	}
	
	// Tellusim::System
	public static class Sys {
		public static uint getThreadID() { return tsSystem_getThreadID(); }
		public static bool setEnvironment(string name, string value) { return tsSystem_setEnvironment_ss(name, value); }
		public static bool setEnvironment(String name, string value) { return tsSystem_setEnvironment_cSs(name.getSelf(), value); }
		public static string getEnvironment(string name) { return Base.getString(tsSystem_getEnvironment_s(name)); }
		public static string getEnvironment(String name) { return Base.getString(tsSystem_getEnvironment_cS(name.getSelf())); }
		public static IntPtr loadLibrary(string name) { return tsSystem_loadLibrary_s(name); }
		public static IntPtr loadLibrary(String name) { return tsSystem_loadLibrary_cS(name.getSelf()); }
		public static IntPtr getFunction(IntPtr handle, string name) { return tsSystem_getFunction_prs(handle, name); }
		public static IntPtr getFunction(IntPtr handle, String name) { return tsSystem_getFunction_prcS(handle, name.getSelf()); }
		public static void closeLibrary(IntPtr handle) { tsSystem_closeLibrary(handle); }
		public static bool exec(string command, bool wait = false, bool console = true) { return tsSystem_exec_sbb(command, wait, console); }
		public static bool exec(String command, bool wait = false, bool console = true) { return tsSystem_exec_cSbb(command.getSelf(), wait, console); }
		public static bool open(string command) { return tsSystem_open_s(command); }
		public static bool open(String command) { return tsSystem_open_cS(command.getSelf()); }
		[DllImport(Base.Import)] private static extern uint tsSystem_getThreadID();
		[DllImport(Base.Import)] private static extern bool tsSystem_setEnvironment_ss(string name, string value);
		[DllImport(Base.Import)] private static extern bool tsSystem_setEnvironment_cSs(HandleRef name, string value);
		[DllImport(Base.Import)] private static extern IntPtr tsSystem_getEnvironment_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsSystem_getEnvironment_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsSystem_loadLibrary_s(string name);
		[DllImport(Base.Import)] private static extern IntPtr tsSystem_loadLibrary_cS(HandleRef name);
		[DllImport(Base.Import)] private static extern IntPtr tsSystem_getFunction_prs(IntPtr handle, string name);
		[DllImport(Base.Import)] private static extern IntPtr tsSystem_getFunction_prcS(IntPtr handle, HandleRef name);
		[DllImport(Base.Import)] private static extern void tsSystem_closeLibrary(IntPtr handle);
		[DllImport(Base.Import)] private static extern bool tsSystem_exec_sbb(string command, bool wait, bool console);
		[DllImport(Base.Import)] private static extern bool tsSystem_exec_cSbb(HandleRef command, bool wait, bool console);
		[DllImport(Base.Import)] private static extern bool tsSystem_open_s(string command);
		[DllImport(Base.Import)] private static extern bool tsSystem_open_cS(HandleRef command);
	}
	
	// Tellusim::MeshGraph
	public static class MeshGraph {
		public delegate bool ProgressCallback(uint progress, IntPtr data_);
		public static bool create(Mesh dest, Mesh src, uint max_attributes, uint max_primitives, ProgressCallback func = null, in Async async = null, IntPtr data = new IntPtr()) {
			if(func != null) ProgressCallback_0 = GCHandle.Alloc(func);
			IntPtr async_ = (async != null) ? async.getSelfPtr() : IntPtr.Zero;
			return tsMeshGraph_create_MMuucMGPCA(dest.getSelf(), src.getSelf(), max_attributes, max_primitives, Base.getFunc(func), ref async_, data);
		}
		private static GCHandle ProgressCallback_0;
		[DllImport(Base.Import)] private static extern bool tsMeshGraph_create_MMuucMGPCA(HandleRef dest, HandleRef src, uint max_attributes, uint max_primitives, IntPtr func, ref IntPtr async, IntPtr data_);
	}
	
	// Tellusim::MeshReduce
	public static class MeshReduce {
		public delegate bool ProgressCallback(uint progress, IntPtr data_);
		public static bool collapse(Mesh dest, Mesh src, float ratio, float threshold = 0.0f, ProgressCallback func = null, IntPtr data = new IntPtr()) {
			if(func != null) ProgressCallback_0 = GCHandle.Alloc(func);
			return tsMeshReduce_collapse_McMffcMRPC(dest.getSelf(), src.getSelf(), ratio, threshold, Base.getFunc(func), data);
		}
		public static bool collapse(MeshGeometry dest, MeshGeometry src, float ratio, float threshold = 0.0f, ProgressCallback func = null, uint position = Base.Maxu32, IntPtr data = new IntPtr()) {
			if(func != null) ProgressCallback_1 = GCHandle.Alloc(func);
			return tsMeshReduce_collapse_MGcMGffcMRPCu(dest.getSelf(), src.getSelf(), ratio, threshold, Base.getFunc(func), position, data);
		}
		private static GCHandle ProgressCallback_0;
		private static GCHandle ProgressCallback_1;
		[DllImport(Base.Import)] private static extern bool tsMeshReduce_collapse_McMffcMRPC(HandleRef dest, HandleRef src, float ratio, float threshold, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsMeshReduce_collapse_MGcMGffcMRPCu(HandleRef dest, HandleRef src, float ratio, float threshold, IntPtr func, uint position, IntPtr data_);
	}
	
	// Tellusim::MeshRefine
	public static class MeshRefine {
		public static bool subdiv(Mesh dest, Mesh src, uint steps, float weight = 1.0f) { return tsMeshRefine_subdiv_McMuf(dest.getSelf(), src.getSelf(), steps, weight); }
		public static bool subdiv(MeshGeometry dest, MeshGeometry src, uint steps, float weight = 1.0f, uint position = Base.Maxu32) { return tsMeshRefine_subdiv_MGcMGufu(dest.getSelf(), src.getSelf(), steps, weight, position); }
		[DllImport(Base.Import)] private static extern bool tsMeshRefine_subdiv_McMuf(HandleRef dest, HandleRef src, uint steps, float weight);
		[DllImport(Base.Import)] private static extern bool tsMeshRefine_subdiv_MGcMGufu(HandleRef dest, HandleRef src, uint steps, float weight, uint position);
	}
	
	// Tellusim::MeshSolid
	public static class MeshSolid {
		public delegate bool ProgressCallback(uint progress, IntPtr data_);
		public static bool create(Mesh dest, Mesh src, float ratio = 1.0f, float threshold = 0.9f, ProgressCallback func = null, IntPtr data = new IntPtr()) {
			if(func != null) ProgressCallback_0 = GCHandle.Alloc(func);
			return tsMeshSolid_create_McMffcMSPC(dest.getSelf(), src.getSelf(), ratio, threshold, Base.getFunc(func), data);
		}
		public static bool create(MeshGeometry dest, MeshGeometry src, float ratio = 1.0f, float threshold = 0.9f, ProgressCallback func = null, uint position = Base.Maxu32, IntPtr data = new IntPtr()) {
			if(func != null) ProgressCallback_1 = GCHandle.Alloc(func);
			return tsMeshSolid_create_MGcMGffcMSPCu(dest.getSelf(), src.getSelf(), ratio, threshold, Base.getFunc(func), position, data);
		}
		private static GCHandle ProgressCallback_0;
		private static GCHandle ProgressCallback_1;
		[DllImport(Base.Import)] private static extern bool tsMeshSolid_create_McMffcMSPC(HandleRef dest, HandleRef src, float ratio, float threshold, IntPtr func, IntPtr data_);
		[DllImport(Base.Import)] private static extern bool tsMeshSolid_create_MGcMGffcMSPCu(HandleRef dest, HandleRef src, float ratio, float threshold, IntPtr func, uint position, IntPtr data_);
	}
	
} /* namespace Tellusim */
