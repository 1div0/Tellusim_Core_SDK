// Copyright (C) 2018-2025, Tellusim Technologies Inc. All rights reserved
// https://tellusim.com/

#include <TellusimApp.h>
#include <TellusimFormat.h>
#include <core/TellusimCore.h>
#include <core/TellusimSystem.h>
#include <core/TellusimDirectory.h>
#include <math/TellusimMath.h>
#include <format/TellusimFormats.h>
#include <platform/TellusimPlatforms.h>
#include <interface/TellusimFont.h>
#include <interface/TellusimControls.h>
#include <interface/TellusimDialogs.h>
#include <geometry/TellusimGeometry.h>
#include <graphics/TellusimGraphics.h>
#include <parallel/TellusimParallels.h>
#include <system/TellusimController.h>
#include <system/TellusimDesktop.h>

#include "../include/TellusimCAPI.h"

/*
 */
namespace Tellusim {
	
	// Tellusim::Vendor
	TS_STATIC_ASSERT(TS_VendorARM == (uint32_t)VendorARM);
	TS_STATIC_ASSERT(TS_VendorAMD == (uint32_t)VendorAMD);
	TS_STATIC_ASSERT(TS_VendorApple == (uint32_t)VendorApple);
	TS_STATIC_ASSERT(TS_VendorIntel == (uint32_t)VendorIntel);
	TS_STATIC_ASSERT(TS_VendorNvidia == (uint32_t)VendorNvidia);
	TS_STATIC_ASSERT(TS_VendorQualcomm == (uint32_t)VendorQualcomm);
	
	// Tellusim::Platform
	TS_STATIC_ASSERT(TS_PlatformUnknown == (uint32_t)PlatformUnknown);
	TS_STATIC_ASSERT(TS_PlatformFusion == (uint32_t)PlatformFusion);
	TS_STATIC_ASSERT(TS_PlatformD3D12 == (uint32_t)PlatformD3D12);
	TS_STATIC_ASSERT(TS_PlatformD3D11 == (uint32_t)PlatformD3D11);
	TS_STATIC_ASSERT(TS_PlatformMTL == (uint32_t)PlatformMTL);
	TS_STATIC_ASSERT(TS_PlatformVK == (uint32_t)PlatformVK);
	TS_STATIC_ASSERT(TS_PlatformGL == (uint32_t)PlatformGL);
	TS_STATIC_ASSERT(TS_PlatformGLES == (uint32_t)PlatformGLES);
	TS_STATIC_ASSERT(TS_PlatformWG == (uint32_t)PlatformWG);
	TS_STATIC_ASSERT(TS_PlatformCU == (uint32_t)PlatformCU);
	TS_STATIC_ASSERT(TS_PlatformHIP == (uint32_t)PlatformHIP);
	TS_STATIC_ASSERT(TS_PlatformAny == (uint32_t)PlatformAny);
	TS_STATIC_ASSERT(TS_PlatformNumPlatforms == (uint32_t)NumPlatforms);
	
	// Tellusim::BindFlags
	TS_STATIC_ASSERT(TS_BindBindFlagNone == (uint32_t)BindFlagNone);
	TS_STATIC_ASSERT(TS_BindBindFlagFixed == (uint32_t)BindFlagFixed);
	TS_STATIC_ASSERT(TS_BindBindFlagRead == (uint32_t)BindFlagRead);
	
	// Tellusim::TableType
	TS_STATIC_ASSERT(TS_TableTypeTexture == (uint32_t)TableTypeTexture);
	TS_STATIC_ASSERT(TS_TableTypeStorage == (uint32_t)TableTypeStorage);
	TS_STATIC_ASSERT(TS_TableTypeNumTableTypes == (uint32_t)NumTableTypes);
	
	// Tellusim::Format
	TS_STATIC_ASSERT(TS_FormatUnknown == (uint32_t)FormatUnknown);
	TS_STATIC_ASSERT(TS_FormatRi8 == (uint32_t)FormatRi8);
	TS_STATIC_ASSERT(TS_FormatRu8 == (uint32_t)FormatRu8);
	TS_STATIC_ASSERT(TS_FormatRi8n == (uint32_t)FormatRi8n);
	TS_STATIC_ASSERT(TS_FormatRu8n == (uint32_t)FormatRu8n);
	TS_STATIC_ASSERT(TS_FormatRGi8 == (uint32_t)FormatRGi8);
	TS_STATIC_ASSERT(TS_FormatRGu8 == (uint32_t)FormatRGu8);
	TS_STATIC_ASSERT(TS_FormatRGi8n == (uint32_t)FormatRGi8n);
	TS_STATIC_ASSERT(TS_FormatRGu8n == (uint32_t)FormatRGu8n);
	TS_STATIC_ASSERT(TS_FormatRGBi8 == (uint32_t)FormatRGBi8);
	TS_STATIC_ASSERT(TS_FormatRGBu8 == (uint32_t)FormatRGBu8);
	TS_STATIC_ASSERT(TS_FormatRGBi8n == (uint32_t)FormatRGBi8n);
	TS_STATIC_ASSERT(TS_FormatRGBu8n == (uint32_t)FormatRGBu8n);
	TS_STATIC_ASSERT(TS_FormatRGBu8ns == (uint32_t)FormatRGBu8ns);
	TS_STATIC_ASSERT(TS_FormatRGBAi8 == (uint32_t)FormatRGBAi8);
	TS_STATIC_ASSERT(TS_FormatRGBAu8 == (uint32_t)FormatRGBAu8);
	TS_STATIC_ASSERT(TS_FormatRGBAi8n == (uint32_t)FormatRGBAi8n);
	TS_STATIC_ASSERT(TS_FormatRGBAu8n == (uint32_t)FormatRGBAu8n);
	TS_STATIC_ASSERT(TS_FormatRGBAu8ns == (uint32_t)FormatRGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatBGRAu8n == (uint32_t)FormatBGRAu8n);
	TS_STATIC_ASSERT(TS_FormatBGRAu8ns == (uint32_t)FormatBGRAu8ns);
	TS_STATIC_ASSERT(TS_FormatRi16 == (uint32_t)FormatRi16);
	TS_STATIC_ASSERT(TS_FormatRu16 == (uint32_t)FormatRu16);
	TS_STATIC_ASSERT(TS_FormatRi16n == (uint32_t)FormatRi16n);
	TS_STATIC_ASSERT(TS_FormatRu16n == (uint32_t)FormatRu16n);
	TS_STATIC_ASSERT(TS_FormatRf16 == (uint32_t)FormatRf16);
	TS_STATIC_ASSERT(TS_FormatRGi16 == (uint32_t)FormatRGi16);
	TS_STATIC_ASSERT(TS_FormatRGu16 == (uint32_t)FormatRGu16);
	TS_STATIC_ASSERT(TS_FormatRGi16n == (uint32_t)FormatRGi16n);
	TS_STATIC_ASSERT(TS_FormatRGu16n == (uint32_t)FormatRGu16n);
	TS_STATIC_ASSERT(TS_FormatRGf16 == (uint32_t)FormatRGf16);
	TS_STATIC_ASSERT(TS_FormatRGBi16 == (uint32_t)FormatRGBi16);
	TS_STATIC_ASSERT(TS_FormatRGBu16 == (uint32_t)FormatRGBu16);
	TS_STATIC_ASSERT(TS_FormatRGBi16n == (uint32_t)FormatRGBi16n);
	TS_STATIC_ASSERT(TS_FormatRGBu16n == (uint32_t)FormatRGBu16n);
	TS_STATIC_ASSERT(TS_FormatRGBf16 == (uint32_t)FormatRGBf16);
	TS_STATIC_ASSERT(TS_FormatRGBAi16 == (uint32_t)FormatRGBAi16);
	TS_STATIC_ASSERT(TS_FormatRGBAu16 == (uint32_t)FormatRGBAu16);
	TS_STATIC_ASSERT(TS_FormatRGBAi16n == (uint32_t)FormatRGBAi16n);
	TS_STATIC_ASSERT(TS_FormatRGBAu16n == (uint32_t)FormatRGBAu16n);
	TS_STATIC_ASSERT(TS_FormatRGBAf16 == (uint32_t)FormatRGBAf16);
	TS_STATIC_ASSERT(TS_FormatRi32 == (uint32_t)FormatRi32);
	TS_STATIC_ASSERT(TS_FormatRu32 == (uint32_t)FormatRu32);
	TS_STATIC_ASSERT(TS_FormatRf32 == (uint32_t)FormatRf32);
	TS_STATIC_ASSERT(TS_FormatRGi32 == (uint32_t)FormatRGi32);
	TS_STATIC_ASSERT(TS_FormatRGu32 == (uint32_t)FormatRGu32);
	TS_STATIC_ASSERT(TS_FormatRGf32 == (uint32_t)FormatRGf32);
	TS_STATIC_ASSERT(TS_FormatRGBi32 == (uint32_t)FormatRGBi32);
	TS_STATIC_ASSERT(TS_FormatRGBu32 == (uint32_t)FormatRGBu32);
	TS_STATIC_ASSERT(TS_FormatRGBf32 == (uint32_t)FormatRGBf32);
	TS_STATIC_ASSERT(TS_FormatRGBAi32 == (uint32_t)FormatRGBAi32);
	TS_STATIC_ASSERT(TS_FormatRGBAu32 == (uint32_t)FormatRGBAu32);
	TS_STATIC_ASSERT(TS_FormatRGBAf32 == (uint32_t)FormatRGBAf32);
	TS_STATIC_ASSERT(TS_FormatRi64 == (uint32_t)FormatRi64);
	TS_STATIC_ASSERT(TS_FormatRu64 == (uint32_t)FormatRu64);
	TS_STATIC_ASSERT(TS_FormatRf64 == (uint32_t)FormatRf64);
	TS_STATIC_ASSERT(TS_FormatRGi64 == (uint32_t)FormatRGi64);
	TS_STATIC_ASSERT(TS_FormatRGu64 == (uint32_t)FormatRGu64);
	TS_STATIC_ASSERT(TS_FormatRGf64 == (uint32_t)FormatRGf64);
	TS_STATIC_ASSERT(TS_FormatRGBi64 == (uint32_t)FormatRGBi64);
	TS_STATIC_ASSERT(TS_FormatRGBu64 == (uint32_t)FormatRGBu64);
	TS_STATIC_ASSERT(TS_FormatRGBf64 == (uint32_t)FormatRGBf64);
	TS_STATIC_ASSERT(TS_FormatRGBAi64 == (uint32_t)FormatRGBAi64);
	TS_STATIC_ASSERT(TS_FormatRGBAu64 == (uint32_t)FormatRGBAu64);
	TS_STATIC_ASSERT(TS_FormatRGBAf64 == (uint32_t)FormatRGBAf64);
	TS_STATIC_ASSERT(TS_FormatRGBAu4n == (uint32_t)FormatRGBAu4n);
	TS_STATIC_ASSERT(TS_FormatRGBu5Au1n == (uint32_t)FormatRGBu5Au1n);
	TS_STATIC_ASSERT(TS_FormatRu5Gu6Bu5n == (uint32_t)FormatRu5Gu6Bu5n);
	TS_STATIC_ASSERT(TS_FormatRGBu10Au2 == (uint32_t)FormatRGBu10Au2);
	TS_STATIC_ASSERT(TS_FormatRGBu10Au2n == (uint32_t)FormatRGBu10Au2n);
	TS_STATIC_ASSERT(TS_FormatRGf11Bf10 == (uint32_t)FormatRGf11Bf10);
	TS_STATIC_ASSERT(TS_FormatRGBf9Eu5 == (uint32_t)FormatRGBf9Eu5);
	TS_STATIC_ASSERT(TS_FormatRGBf21 == (uint32_t)FormatRGBf21);
	TS_STATIC_ASSERT(TS_FormatBC1RGBu8n == (uint32_t)FormatBC1RGBu8n);
	TS_STATIC_ASSERT(TS_FormatBC1RGBu8ns == (uint32_t)FormatBC1RGBu8ns);
	TS_STATIC_ASSERT(TS_FormatBC1RGBAu8n == (uint32_t)FormatBC1RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatBC1RGBAu8ns == (uint32_t)FormatBC1RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatBC2RGBAu8n == (uint32_t)FormatBC2RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatBC2RGBAu8ns == (uint32_t)FormatBC2RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatBC3RGBAu8n == (uint32_t)FormatBC3RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatBC3RGBAu8ns == (uint32_t)FormatBC3RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatBC4Ri8n == (uint32_t)FormatBC4Ri8n);
	TS_STATIC_ASSERT(TS_FormatBC4Ru8n == (uint32_t)FormatBC4Ru8n);
	TS_STATIC_ASSERT(TS_FormatBC5RGi8n == (uint32_t)FormatBC5RGi8n);
	TS_STATIC_ASSERT(TS_FormatBC5RGu8n == (uint32_t)FormatBC5RGu8n);
	TS_STATIC_ASSERT(TS_FormatBC6RGBf16s == (uint32_t)FormatBC6RGBf16s);
	TS_STATIC_ASSERT(TS_FormatBC6RGBf16u == (uint32_t)FormatBC6RGBf16u);
	TS_STATIC_ASSERT(TS_FormatBC7RGBAu8n == (uint32_t)FormatBC7RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatBC7RGBAu8ns == (uint32_t)FormatBC7RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatEACRi8n == (uint32_t)FormatEACRi8n);
	TS_STATIC_ASSERT(TS_FormatEACRu8n == (uint32_t)FormatEACRu8n);
	TS_STATIC_ASSERT(TS_FormatEACRGi8n == (uint32_t)FormatEACRGi8n);
	TS_STATIC_ASSERT(TS_FormatEACRGu8n == (uint32_t)FormatEACRGu8n);
	TS_STATIC_ASSERT(TS_FormatETC2RGBu8n == (uint32_t)FormatETC2RGBu8n);
	TS_STATIC_ASSERT(TS_FormatETC2RGBu8ns == (uint32_t)FormatETC2RGBu8ns);
	TS_STATIC_ASSERT(TS_FormatETC2RGBAu8n == (uint32_t)FormatETC2RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatETC2RGBAu8ns == (uint32_t)FormatETC2RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatETC2RGBu8Au1n == (uint32_t)FormatETC2RGBu8Au1n);
	TS_STATIC_ASSERT(TS_FormatETC2RGBu8Au1ns == (uint32_t)FormatETC2RGBu8Au1ns);
	TS_STATIC_ASSERT(TS_FormatASTC44RGBAu8n == (uint32_t)FormatASTC44RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC44RGBAu8ns == (uint32_t)FormatASTC44RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC44RGBAf16 == (uint32_t)FormatASTC44RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC54RGBAu8n == (uint32_t)FormatASTC54RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC54RGBAu8ns == (uint32_t)FormatASTC54RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC54RGBAf16 == (uint32_t)FormatASTC54RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC55RGBAu8n == (uint32_t)FormatASTC55RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC55RGBAu8ns == (uint32_t)FormatASTC55RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC55RGBAf16 == (uint32_t)FormatASTC55RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC65RGBAu8n == (uint32_t)FormatASTC65RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC65RGBAu8ns == (uint32_t)FormatASTC65RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC65RGBAf16 == (uint32_t)FormatASTC65RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC66RGBAu8n == (uint32_t)FormatASTC66RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC66RGBAu8ns == (uint32_t)FormatASTC66RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC66RGBAf16 == (uint32_t)FormatASTC66RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC85RGBAu8n == (uint32_t)FormatASTC85RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC85RGBAu8ns == (uint32_t)FormatASTC85RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC85RGBAf16 == (uint32_t)FormatASTC85RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC86RGBAu8n == (uint32_t)FormatASTC86RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC86RGBAu8ns == (uint32_t)FormatASTC86RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC86RGBAf16 == (uint32_t)FormatASTC86RGBAf16);
	TS_STATIC_ASSERT(TS_FormatASTC88RGBAu8n == (uint32_t)FormatASTC88RGBAu8n);
	TS_STATIC_ASSERT(TS_FormatASTC88RGBAu8ns == (uint32_t)FormatASTC88RGBAu8ns);
	TS_STATIC_ASSERT(TS_FormatASTC88RGBAf16 == (uint32_t)FormatASTC88RGBAf16);
	TS_STATIC_ASSERT(TS_FormatDu16 == (uint32_t)FormatDu16);
	TS_STATIC_ASSERT(TS_FormatDu16Su8 == (uint32_t)FormatDu16Su8);
	TS_STATIC_ASSERT(TS_FormatDu24 == (uint32_t)FormatDu24);
	TS_STATIC_ASSERT(TS_FormatDu24Su8 == (uint32_t)FormatDu24Su8);
	TS_STATIC_ASSERT(TS_FormatDf32 == (uint32_t)FormatDf32);
	TS_STATIC_ASSERT(TS_FormatDf32Su8 == (uint32_t)FormatDf32Su8);
	TS_STATIC_ASSERT(TS_FormatNumFormats == (uint32_t)NumFormats);
	
	// Tellusim::App::
	TS_STATIC_ASSERT(TS_AppVersion_19 == (uint32_t)App::Version_19);
	TS_STATIC_ASSERT(TS_AppVersion_20 == (uint32_t)App::Version_20);
	TS_STATIC_ASSERT(TS_AppVersion_21 == (uint32_t)App::Version_21);
	TS_STATIC_ASSERT(TS_AppVersion_22 == (uint32_t)App::Version_22);
	TS_STATIC_ASSERT(TS_AppVersion_23 == (uint32_t)App::Version_23);
	TS_STATIC_ASSERT(TS_AppVersion_24 == (uint32_t)App::Version_24);
	TS_STATIC_ASSERT(TS_AppVersion_25 == (uint32_t)App::Version_25);
	TS_STATIC_ASSERT(TS_AppVersion_26 == (uint32_t)App::Version_26);
	TS_STATIC_ASSERT(TS_AppVersion_27 == (uint32_t)App::Version_27);
	TS_STATIC_ASSERT(TS_AppVersion_28 == (uint32_t)App::Version_28);
	TS_STATIC_ASSERT(TS_AppVersion_29 == (uint32_t)App::Version_29);
	TS_STATIC_ASSERT(TS_AppVersion_30 == (uint32_t)App::Version_30);
	TS_STATIC_ASSERT(TS_AppVersion_31 == (uint32_t)App::Version_31);
	TS_STATIC_ASSERT(TS_AppVersion_32 == (uint32_t)App::Version_32);
	TS_STATIC_ASSERT(TS_AppVersion_33 == (uint32_t)App::Version_33);
	TS_STATIC_ASSERT(TS_AppVersion_34 == (uint32_t)App::Version_34);
	TS_STATIC_ASSERT(TS_AppVersion_35 == (uint32_t)App::Version_35);
	TS_STATIC_ASSERT(TS_AppVersion_36 == (uint32_t)App::Version_36);
	TS_STATIC_ASSERT(TS_AppVersion_37 == (uint32_t)App::Version_37);
	TS_STATIC_ASSERT(TS_AppVersion_38 == (uint32_t)App::Version_38);
	TS_STATIC_ASSERT(TS_AppVersion_39 == (uint32_t)App::Version_39);
	TS_STATIC_ASSERT(TS_AppVersion_40 == (uint32_t)App::Version_40);
	TS_STATIC_ASSERT(TS_AppVersion_41 == (uint32_t)App::Version_41);
	TS_STATIC_ASSERT(TS_AppVersion == (uint32_t)App::Version);
	
	// Tellusim::Socket::Type
	TS_STATIC_ASSERT(TS_SocketTypeStream == (uint32_t)Socket::TypeStream);
	TS_STATIC_ASSERT(TS_SocketTypeDatagram == (uint32_t)Socket::TypeDatagram);
	TS_STATIC_ASSERT(TS_SocketTypeNumTypes == (uint32_t)Socket::NumTypes);
	
	// Tellusim::Directory::Attributes
	TS_STATIC_ASSERT(TS_DirectoryAttributeNone == (uint32_t)Directory::AttributeNone);
	TS_STATIC_ASSERT(TS_DirectoryAttributeRead == (uint32_t)Directory::AttributeRead);
	TS_STATIC_ASSERT(TS_DirectoryAttributeWrite == (uint32_t)Directory::AttributeWrite);
	TS_STATIC_ASSERT(TS_DirectoryAttributeHidden == (uint32_t)Directory::AttributeHidden);
	TS_STATIC_ASSERT(TS_DirectoryAttributeExecute == (uint32_t)Directory::AttributeExecute);
	TS_STATIC_ASSERT(TS_DirectoryAttributeTemporary == (uint32_t)Directory::AttributeTemporary);
	TS_STATIC_ASSERT(TS_DirectoryNumAttributes == (uint32_t)Directory::NumAttributes);
	
	// Tellusim::Image::Type
	TS_STATIC_ASSERT(TS_ImageTypeUnknown == (uint32_t)Image::TypeUnknown);
	TS_STATIC_ASSERT(TS_ImageType2D == (uint32_t)Image::Type2D);
	TS_STATIC_ASSERT(TS_ImageType3D == (uint32_t)Image::Type3D);
	TS_STATIC_ASSERT(TS_ImageTypeCube == (uint32_t)Image::TypeCube);
	TS_STATIC_ASSERT(TS_ImageTypeNumTypes == (uint32_t)Image::NumTypes);
	
	// Tellusim::Image::Flags
	TS_STATIC_ASSERT(TS_ImageFlagNone == (uint32_t)Image::FlagNone);
	TS_STATIC_ASSERT(TS_ImageFlagMipmaps == (uint32_t)Image::FlagMipmaps);
	TS_STATIC_ASSERT(TS_ImageFlagNoClear == (uint32_t)Image::FlagNoClear);
	TS_STATIC_ASSERT(TS_ImageFlagNoAllocate == (uint32_t)Image::FlagNoAllocate);
	TS_STATIC_ASSERT(TS_ImageFlagFast == (uint32_t)Image::FlagFast);
	TS_STATIC_ASSERT(TS_ImageFlagBest == (uint32_t)Image::FlagBest);
	TS_STATIC_ASSERT(TS_ImageFlagPerceptual == (uint32_t)Image::FlagPerceptual);
	TS_STATIC_ASSERT(TS_ImageFlagPanorama == (uint32_t)Image::FlagPanorama);
	TS_STATIC_ASSERT(TS_ImageFlagNormalize == (uint32_t)Image::FlagNormalize);
	TS_STATIC_ASSERT(TS_ImageFlagGamma == (uint32_t)Image::FlagGamma);
	TS_STATIC_ASSERT(TS_ImageFlagSRGB == (uint32_t)Image::FlagSRGB);
	TS_STATIC_ASSERT(TS_ImageNumFlags == (uint32_t)Image::NumFlags);
	
	// Tellusim::Image::Filter
	TS_STATIC_ASSERT(TS_ImageFilterUnknown == (uint32_t)Image::FilterUnknown);
	TS_STATIC_ASSERT(TS_ImageFilterPoint == (uint32_t)Image::FilterPoint);
	TS_STATIC_ASSERT(TS_ImageFilterLinear == (uint32_t)Image::FilterLinear);
	TS_STATIC_ASSERT(TS_ImageFilterCubic == (uint32_t)Image::FilterCubic);
	TS_STATIC_ASSERT(TS_ImageFilterSinc == (uint32_t)Image::FilterSinc);
	TS_STATIC_ASSERT(TS_ImageFilterBox == (uint32_t)Image::FilterBox);
	TS_STATIC_ASSERT(TS_ImageFilterMax == (uint32_t)Image::FilterMax);
	TS_STATIC_ASSERT(TS_ImageFilterMin == (uint32_t)Image::FilterMin);
	TS_STATIC_ASSERT(TS_ImageFilterMip == (uint32_t)Image::FilterMip);
	TS_STATIC_ASSERT(TS_ImageFilterCR == (uint32_t)Image::FilterCR);
	TS_STATIC_ASSERT(TS_ImageFilterNumFilters == (uint32_t)Image::NumFilters);
	
	// Tellusim::MeshIndices::Type
	TS_STATIC_ASSERT(TS_MeshIndicesTypeUnknown == (uint32_t)MeshIndices::TypeUnknown);
	TS_STATIC_ASSERT(TS_MeshIndicesTypePoint == (uint32_t)MeshIndices::TypePoint);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeLine == (uint32_t)MeshIndices::TypeLine);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeTriangle == (uint32_t)MeshIndices::TypeTriangle);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeQuadrilateral == (uint32_t)MeshIndices::TypeQuadrilateral);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeTetrahedron == (uint32_t)MeshIndices::TypeTetrahedron);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeMaterial == (uint32_t)MeshIndices::TypeMaterial);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeIsland == (uint32_t)MeshIndices::TypeIsland);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeGroup == (uint32_t)MeshIndices::TypeGroup);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeJoint == (uint32_t)MeshIndices::TypeJoint);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeEdge == (uint32_t)MeshIndices::TypeEdge);
	TS_STATIC_ASSERT(TS_MeshIndicesTypeNumTypes == (uint32_t)MeshIndices::NumTypes);
	
	// Tellusim::MeshAttribute::Type
	TS_STATIC_ASSERT(TS_MeshAttributeTypeUnknown == (uint32_t)MeshAttribute::TypeUnknown);
	TS_STATIC_ASSERT(TS_MeshAttributeTypePosition == (uint32_t)MeshAttribute::TypePosition);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeBasis == (uint32_t)MeshAttribute::TypeBasis);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeNormal == (uint32_t)MeshAttribute::TypeNormal);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeTangent == (uint32_t)MeshAttribute::TypeTangent);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeBinormal == (uint32_t)MeshAttribute::TypeBinormal);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeTexCoord == (uint32_t)MeshAttribute::TypeTexCoord);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeWeights == (uint32_t)MeshAttribute::TypeWeights);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeJoints == (uint32_t)MeshAttribute::TypeJoints);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeColor == (uint32_t)MeshAttribute::TypeColor);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeCrease == (uint32_t)MeshAttribute::TypeCrease);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeIndex == (uint32_t)MeshAttribute::TypeIndex);
	TS_STATIC_ASSERT(TS_MeshAttributeTypeNumTypes == (uint32_t)MeshAttribute::NumTypes);
	
	// Tellusim::MeshMaterial::Flags
	TS_STATIC_ASSERT(TS_MeshMaterialFlagNone == (uint32_t)MeshMaterial::FlagNone);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagBool == (uint32_t)MeshMaterial::FlagBool);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagScalarf32 == (uint32_t)MeshMaterial::FlagScalarf32);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagVector4f == (uint32_t)MeshMaterial::FlagVector4f);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagMatrix3x2f == (uint32_t)MeshMaterial::FlagMatrix3x2f);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagColor == (uint32_t)MeshMaterial::FlagColor);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagName == (uint32_t)MeshMaterial::FlagName);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagLayout == (uint32_t)MeshMaterial::FlagLayout);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagBlob == (uint32_t)MeshMaterial::FlagBlob);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagImage == (uint32_t)MeshMaterial::FlagImage);
	TS_STATIC_ASSERT(TS_MeshMaterialFlagTexture == (uint32_t)MeshMaterial::FlagTexture);
	
	// Tellusim::MeshAttachment::Type
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeUnknown == (uint32_t)MeshAttachment::TypeUnknown);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeLightGlobal == (uint32_t)MeshAttachment::TypeLightGlobal);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeLightPoint == (uint32_t)MeshAttachment::TypeLightPoint);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeLightSpot == (uint32_t)MeshAttachment::TypeLightSpot);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeLightImage == (uint32_t)MeshAttachment::TypeLightImage);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeCameraPerspective == (uint32_t)MeshAttachment::TypeCameraPerspective);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeCameraOrthographic == (uint32_t)MeshAttachment::TypeCameraOrthographic);
	TS_STATIC_ASSERT(TS_MeshAttachmentTypeNumTypes == (uint32_t)MeshAttachment::NumTypes);
	
	// Tellusim::MeshAttachment::Flags
	TS_STATIC_ASSERT(TS_MeshAttachmentFlagNone == (uint32_t)MeshAttachment::FlagNone);
	TS_STATIC_ASSERT(TS_MeshAttachmentFlagBool == (uint32_t)MeshAttachment::FlagBool);
	TS_STATIC_ASSERT(TS_MeshAttachmentFlagScalarf32 == (uint32_t)MeshAttachment::FlagScalarf32);
	TS_STATIC_ASSERT(TS_MeshAttachmentFlagVector4f == (uint32_t)MeshAttachment::FlagVector4f);
	TS_STATIC_ASSERT(TS_MeshAttachmentFlagColor == (uint32_t)MeshAttachment::FlagColor);
	TS_STATIC_ASSERT(TS_MeshAttachmentFlagName == (uint32_t)MeshAttachment::FlagName);
	
	// Tellusim::Mesh::Flags
	TS_STATIC_ASSERT(TS_MeshFlagNone == (uint32_t)Mesh::FlagNone);
	TS_STATIC_ASSERT(TS_MeshFlagEmbed == (uint32_t)Mesh::FlagEmbed);
	TS_STATIC_ASSERT(TS_MeshFlag32Bit == (uint32_t)Mesh::Flag32Bit);
	
	// Tellusim::Mesh::Basis
	TS_STATIC_ASSERT(TS_MeshBasisUnknown == (uint32_t)Mesh::BasisUnknown);
	TS_STATIC_ASSERT(TS_MeshBasisXUpRight == (uint32_t)Mesh::BasisXUpRight);
	TS_STATIC_ASSERT(TS_MeshBasisYUpRight == (uint32_t)Mesh::BasisYUpRight);
	TS_STATIC_ASSERT(TS_MeshBasisZUpRight == (uint32_t)Mesh::BasisZUpRight);
	TS_STATIC_ASSERT(TS_MeshBasisXUpLeft == (uint32_t)Mesh::BasisXUpLeft);
	TS_STATIC_ASSERT(TS_MeshBasisYUpLeft == (uint32_t)Mesh::BasisYUpLeft);
	TS_STATIC_ASSERT(TS_MeshBasisZUpLeft == (uint32_t)Mesh::BasisZUpLeft);
	TS_STATIC_ASSERT(TS_MeshBasisZUpMaya == (uint32_t)Mesh::BasisZUpMaya);
	TS_STATIC_ASSERT(TS_MeshBasisNumBases == (uint32_t)Mesh::NumBases);
	
	// Tellusim::Mesh::Axis
	TS_STATIC_ASSERT(TS_MeshAxisUnknown == (uint32_t)Mesh::AxisUnknown);
	TS_STATIC_ASSERT(TS_MeshAxisPX == (uint32_t)Mesh::AxisPX);
	TS_STATIC_ASSERT(TS_MeshAxisPY == (uint32_t)Mesh::AxisPY);
	TS_STATIC_ASSERT(TS_MeshAxisPZ == (uint32_t)Mesh::AxisPZ);
	TS_STATIC_ASSERT(TS_MeshAxisNX == (uint32_t)Mesh::AxisNX);
	TS_STATIC_ASSERT(TS_MeshAxisNY == (uint32_t)Mesh::AxisNY);
	TS_STATIC_ASSERT(TS_MeshAxisNZ == (uint32_t)Mesh::AxisNZ);
	TS_STATIC_ASSERT(TS_MeshAxisNumAxes == (uint32_t)Mesh::NumAxes);
	
	// Tellusim::Json::Type
	TS_STATIC_ASSERT(TS_JsonTypeUnknown == (uint32_t)Json::TypeUnknown);
	TS_STATIC_ASSERT(TS_JsonTypeNull == (uint32_t)Json::TypeNull);
	TS_STATIC_ASSERT(TS_JsonTypeBool == (uint32_t)Json::TypeBool);
	TS_STATIC_ASSERT(TS_JsonTypeNumber == (uint32_t)Json::TypeNumber);
	TS_STATIC_ASSERT(TS_JsonTypeString == (uint32_t)Json::TypeString);
	TS_STATIC_ASSERT(TS_JsonTypeObject == (uint32_t)Json::TypeObject);
	TS_STATIC_ASSERT(TS_JsonTypeArray == (uint32_t)Json::TypeArray);
	TS_STATIC_ASSERT(TS_JsonTypeNumTypes == (uint32_t)Json::NumTypes);
	
	// Tellusim::Buffer::Flags
	TS_STATIC_ASSERT(TS_BufferFlagNone == (uint32_t)Buffer::FlagNone);
	TS_STATIC_ASSERT(TS_BufferFlagRead == (uint32_t)Buffer::FlagRead);
	TS_STATIC_ASSERT(TS_BufferFlagWrite == (uint32_t)Buffer::FlagWrite);
	TS_STATIC_ASSERT(TS_BufferFlagSource == (uint32_t)Buffer::FlagSource);
	TS_STATIC_ASSERT(TS_BufferFlagSparse == (uint32_t)Buffer::FlagSparse);
	TS_STATIC_ASSERT(TS_BufferFlagShared == (uint32_t)Buffer::FlagShared);
	TS_STATIC_ASSERT(TS_BufferFlagMapped == (uint32_t)Buffer::FlagMapped);
	TS_STATIC_ASSERT(TS_BufferFlagExtern == (uint32_t)Buffer::FlagExtern);
	TS_STATIC_ASSERT(TS_BufferFlagInterop == (uint32_t)Buffer::FlagInterop);
	TS_STATIC_ASSERT(TS_BufferFlagDynamic == (uint32_t)Buffer::FlagDynamic);
	TS_STATIC_ASSERT(TS_BufferFlagUniform == (uint32_t)Buffer::FlagUniform);
	TS_STATIC_ASSERT(TS_BufferFlagStorage == (uint32_t)Buffer::FlagStorage);
	TS_STATIC_ASSERT(TS_BufferFlagAddress == (uint32_t)Buffer::FlagAddress);
	TS_STATIC_ASSERT(TS_BufferFlagTracing == (uint32_t)Buffer::FlagTracing);
	TS_STATIC_ASSERT(TS_BufferFlagScratch == (uint32_t)Buffer::FlagScratch);
	TS_STATIC_ASSERT(TS_BufferFlagBinding == (uint32_t)Buffer::FlagBinding);
	TS_STATIC_ASSERT(TS_BufferFlagIndirect == (uint32_t)Buffer::FlagIndirect);
	TS_STATIC_ASSERT(TS_BufferFlagConditional == (uint32_t)Buffer::FlagConditional);
	TS_STATIC_ASSERT(TS_BufferFlagVertex == (uint32_t)Buffer::FlagVertex);
	TS_STATIC_ASSERT(TS_BufferFlagIndex == (uint32_t)Buffer::FlagIndex);
	TS_STATIC_ASSERT(TS_BufferFlagTexel == (uint32_t)Buffer::FlagTexel);
	TS_STATIC_ASSERT(TS_BufferFlagAccel == (uint32_t)Buffer::FlagAccel);
	TS_STATIC_ASSERT(TS_BufferDefaultFlags == (uint32_t)Buffer::DefaultFlags);
	TS_STATIC_ASSERT(TS_BufferNumFlags == (uint32_t)Buffer::NumFlags);
	
	// Tellusim::Query::Type
	TS_STATIC_ASSERT(TS_QueryTypeUnknown == (uint32_t)Query::TypeUnknown);
	TS_STATIC_ASSERT(TS_QueryTypeTime == (uint32_t)Query::TypeTime);
	TS_STATIC_ASSERT(TS_QueryTypeClock == (uint32_t)Query::TypeClock);
	TS_STATIC_ASSERT(TS_QueryTypeSamples == (uint32_t)Query::TypeSamples);
	TS_STATIC_ASSERT(TS_QueryTypeSamples1 == (uint32_t)Query::TypeSamples1);
	TS_STATIC_ASSERT(TS_QueryTypeStatistics == (uint32_t)Query::TypeStatistics);
	TS_STATIC_ASSERT(TS_QueryTypeNumTypes == (uint32_t)Query::NumTypes);
	
	// Tellusim::Fence::Flags
	TS_STATIC_ASSERT(TS_FenceFlagNone == (uint32_t)Fence::FlagNone);
	TS_STATIC_ASSERT(TS_FenceFlagSemaphore == (uint32_t)Fence::FlagSemaphore);
	TS_STATIC_ASSERT(TS_FenceFlagSignaled == (uint32_t)Fence::FlagSignaled);
	TS_STATIC_ASSERT(TS_FenceFlagShared == (uint32_t)Fence::FlagShared);
	TS_STATIC_ASSERT(TS_FenceFlagExtern == (uint32_t)Fence::FlagExtern);
	TS_STATIC_ASSERT(TS_FenceDefaultFlags == (uint32_t)Fence::DefaultFlags);
	TS_STATIC_ASSERT(TS_FenceNumFlags == (uint32_t)Fence::NumFlags);
	
	// Tellusim::Shader::Type
	TS_STATIC_ASSERT(TS_ShaderTypeUnknown == (uint32_t)Shader::TypeUnknown);
	TS_STATIC_ASSERT(TS_ShaderTypeVertex == (uint32_t)Shader::TypeVertex);
	TS_STATIC_ASSERT(TS_ShaderTypeControl == (uint32_t)Shader::TypeControl);
	TS_STATIC_ASSERT(TS_ShaderTypeEvaluate == (uint32_t)Shader::TypeEvaluate);
	TS_STATIC_ASSERT(TS_ShaderTypeGeometry == (uint32_t)Shader::TypeGeometry);
	TS_STATIC_ASSERT(TS_ShaderTypeFragment == (uint32_t)Shader::TypeFragment);
	TS_STATIC_ASSERT(TS_ShaderTypeCompute == (uint32_t)Shader::TypeCompute);
	TS_STATIC_ASSERT(TS_ShaderTypeTask == (uint32_t)Shader::TypeTask);
	TS_STATIC_ASSERT(TS_ShaderTypeMesh == (uint32_t)Shader::TypeMesh);
	TS_STATIC_ASSERT(TS_ShaderTypeRayGen == (uint32_t)Shader::TypeRayGen);
	TS_STATIC_ASSERT(TS_ShaderTypeRayMiss == (uint32_t)Shader::TypeRayMiss);
	TS_STATIC_ASSERT(TS_ShaderTypeClosest == (uint32_t)Shader::TypeClosest);
	TS_STATIC_ASSERT(TS_ShaderTypeFirstHit == (uint32_t)Shader::TypeFirstHit);
	TS_STATIC_ASSERT(TS_ShaderTypeIntersection == (uint32_t)Shader::TypeIntersection);
	TS_STATIC_ASSERT(TS_ShaderTypeCallable == (uint32_t)Shader::TypeCallable);
	TS_STATIC_ASSERT(TS_ShaderTypeNumTypes == (uint32_t)Shader::NumTypes);
	
	// Tellusim::Shader::Mask
	TS_STATIC_ASSERT(TS_ShaderMaskNone == (uint32_t)Shader::MaskNone);
	TS_STATIC_ASSERT(TS_ShaderMaskVertex == (uint32_t)Shader::MaskVertex);
	TS_STATIC_ASSERT(TS_ShaderMaskControl == (uint32_t)Shader::MaskControl);
	TS_STATIC_ASSERT(TS_ShaderMaskEvaluate == (uint32_t)Shader::MaskEvaluate);
	TS_STATIC_ASSERT(TS_ShaderMaskGeometry == (uint32_t)Shader::MaskGeometry);
	TS_STATIC_ASSERT(TS_ShaderMaskFragment == (uint32_t)Shader::MaskFragment);
	TS_STATIC_ASSERT(TS_ShaderMaskCompute == (uint32_t)Shader::MaskCompute);
	TS_STATIC_ASSERT(TS_ShaderMaskTask == (uint32_t)Shader::MaskTask);
	TS_STATIC_ASSERT(TS_ShaderMaskMesh == (uint32_t)Shader::MaskMesh);
	TS_STATIC_ASSERT(TS_ShaderMaskRayGen == (uint32_t)Shader::MaskRayGen);
	TS_STATIC_ASSERT(TS_ShaderMaskRayMiss == (uint32_t)Shader::MaskRayMiss);
	TS_STATIC_ASSERT(TS_ShaderMaskClosest == (uint32_t)Shader::MaskClosest);
	TS_STATIC_ASSERT(TS_ShaderMaskFirstHit == (uint32_t)Shader::MaskFirstHit);
	TS_STATIC_ASSERT(TS_ShaderMaskIntersection == (uint32_t)Shader::MaskIntersection);
	TS_STATIC_ASSERT(TS_ShaderMaskCallable == (uint32_t)Shader::MaskCallable);
	TS_STATIC_ASSERT(TS_ShaderMaskVertexFragment == (uint32_t)Shader::MaskVertexFragment);
	TS_STATIC_ASSERT(TS_ShaderMaskGraphics == (uint32_t)Shader::MaskGraphics);
	TS_STATIC_ASSERT(TS_ShaderMaskTracing == (uint32_t)Shader::MaskTracing);
	TS_STATIC_ASSERT(TS_ShaderMaskAll == (uint32_t)Shader::MaskAll);
	
	// Tellusim::ShaderCompiler::Flags
	TS_STATIC_ASSERT(TS_ShaderCompilerFlagNone == (uint32_t)ShaderCompiler::FlagNone);
	TS_STATIC_ASSERT(TS_ShaderCompilerFlagMSLIndirect == (uint32_t)ShaderCompiler::FlagMSLIndirect);
	
	// Tellusim::Sampler::Filter
	TS_STATIC_ASSERT(TS_SamplerFilterPoint == (uint32_t)Sampler::FilterPoint);
	TS_STATIC_ASSERT(TS_SamplerFilterLinear == (uint32_t)Sampler::FilterLinear);
	TS_STATIC_ASSERT(TS_SamplerFilterBipoint == (uint32_t)Sampler::FilterBipoint);
	TS_STATIC_ASSERT(TS_SamplerFilterBilinear == (uint32_t)Sampler::FilterBilinear);
	TS_STATIC_ASSERT(TS_SamplerFilterTrilinear == (uint32_t)Sampler::FilterTrilinear);
	TS_STATIC_ASSERT(TS_SamplerFilterNumFilters == (uint32_t)Sampler::NumFilters);
	
	// Tellusim::Sampler::
	TS_STATIC_ASSERT(TS_SamplerMinAnisotropy == (uint32_t)Sampler::MinAnisotropy);
	TS_STATIC_ASSERT(TS_SamplerMaxAnisotropy == (uint32_t)Sampler::MaxAnisotropy);
	
	// Tellusim::Sampler::WrapMode
	TS_STATIC_ASSERT(TS_SamplerWrapModeClamp == (uint32_t)Sampler::WrapModeClamp);
	TS_STATIC_ASSERT(TS_SamplerWrapModeRepeat == (uint32_t)Sampler::WrapModeRepeat);
	TS_STATIC_ASSERT(TS_SamplerWrapModeMirror == (uint32_t)Sampler::WrapModeMirror);
	TS_STATIC_ASSERT(TS_SamplerWrapModeBorder == (uint32_t)Sampler::WrapModeBorder);
	TS_STATIC_ASSERT(TS_SamplerWrapModeNumWrapModes == (uint32_t)Sampler::NumWrapModes);
	
	// Tellusim::Sampler::CompareFunc
	TS_STATIC_ASSERT(TS_SamplerCompareFuncNone == (uint32_t)Sampler::CompareFuncNone);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncEqual == (uint32_t)Sampler::CompareFuncEqual);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncLess == (uint32_t)Sampler::CompareFuncLess);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncGreater == (uint32_t)Sampler::CompareFuncGreater);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncNotEqual == (uint32_t)Sampler::CompareFuncNotEqual);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncLessEqual == (uint32_t)Sampler::CompareFuncLessEqual);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncGreaterEqual == (uint32_t)Sampler::CompareFuncGreaterEqual);
	TS_STATIC_ASSERT(TS_SamplerCompareFuncNumCompareFunctions == (uint32_t)Sampler::NumCompareFunctions);
	
	// Tellusim::Sampler::ReductionMode
	TS_STATIC_ASSERT(TS_SamplerReductionModeAverage == (uint32_t)Sampler::ReductionModeAverage);
	TS_STATIC_ASSERT(TS_SamplerReductionModeMin == (uint32_t)Sampler::ReductionModeMin);
	TS_STATIC_ASSERT(TS_SamplerReductionModeMax == (uint32_t)Sampler::ReductionModeMax);
	TS_STATIC_ASSERT(TS_SamplerReductionModeNumReductionModes == (uint32_t)Sampler::NumReductionModes);
	
	// Tellusim::Texture::Type
	TS_STATIC_ASSERT(TS_TextureTypeUnknown == (uint32_t)Texture::TypeUnknown);
	TS_STATIC_ASSERT(TS_TextureType2D == (uint32_t)Texture::Type2D);
	TS_STATIC_ASSERT(TS_TextureType3D == (uint32_t)Texture::Type3D);
	TS_STATIC_ASSERT(TS_TextureTypeCube == (uint32_t)Texture::TypeCube);
	TS_STATIC_ASSERT(TS_TextureTypeNumTypes == (uint32_t)Texture::NumTypes);
	
	// Tellusim::Texture::Flags
	TS_STATIC_ASSERT(TS_TextureFlagNone == (uint32_t)Texture::FlagNone);
	TS_STATIC_ASSERT(TS_TextureFlagRead == (uint32_t)Texture::FlagRead);
	TS_STATIC_ASSERT(TS_TextureFlagWrite == (uint32_t)Texture::FlagWrite);
	TS_STATIC_ASSERT(TS_TextureFlagTarget == (uint32_t)Texture::FlagTarget);
	TS_STATIC_ASSERT(TS_TextureFlagBuffer == (uint32_t)Texture::FlagBuffer);
	TS_STATIC_ASSERT(TS_TextureFlagSource == (uint32_t)Texture::FlagSource);
	TS_STATIC_ASSERT(TS_TextureFlagSparse == (uint32_t)Texture::FlagSparse);
	TS_STATIC_ASSERT(TS_TextureFlagShared == (uint32_t)Texture::FlagShared);
	TS_STATIC_ASSERT(TS_TextureFlagExtern == (uint32_t)Texture::FlagExtern);
	TS_STATIC_ASSERT(TS_TextureFlagInterop == (uint32_t)Texture::FlagInterop);
	TS_STATIC_ASSERT(TS_TextureFlagSurface == (uint32_t)Texture::FlagSurface);
	TS_STATIC_ASSERT(TS_TextureFlagMutable == (uint32_t)Texture::FlagMutable);
	TS_STATIC_ASSERT(TS_TextureFlagMipmaps == (uint32_t)Texture::FlagMipmaps);
	TS_STATIC_ASSERT(TS_TextureFlagGenerate == (uint32_t)Texture::FlagGenerate);
	TS_STATIC_ASSERT(TS_TextureFlagFormatNorm == (uint32_t)Texture::FlagFormatNorm);
	TS_STATIC_ASSERT(TS_TextureFlagFormatSRGB == (uint32_t)Texture::FlagFormatSRGB);
	TS_STATIC_ASSERT(TS_TextureFlagFormatSigned == (uint32_t)Texture::FlagFormatSigned);
	TS_STATIC_ASSERT(TS_TextureFlagMultisample2 == (uint32_t)Texture::FlagMultisample2);
	TS_STATIC_ASSERT(TS_TextureFlagMultisample4 == (uint32_t)Texture::FlagMultisample4);
	TS_STATIC_ASSERT(TS_TextureFlagMultisample8 == (uint32_t)Texture::FlagMultisample8);
	TS_STATIC_ASSERT(TS_TextureFlagClearOne == (uint32_t)Texture::FlagClearOne);
	TS_STATIC_ASSERT(TS_TextureFlagClearZero == (uint32_t)Texture::FlagClearZero);
	TS_STATIC_ASSERT(TS_TextureFlagClearNormal == (uint32_t)Texture::FlagClearNormal);
	TS_STATIC_ASSERT(TS_TextureFlagMultisample == (uint32_t)Texture::FlagMultisample);
	TS_STATIC_ASSERT(TS_TextureDefaultFlags == (uint32_t)Texture::DefaultFlags);
	TS_STATIC_ASSERT(TS_TextureNumFlags == (uint32_t)Texture::NumFlags);
	
	// Tellusim::Tracing::Type
	TS_STATIC_ASSERT(TS_TracingTypeUnknown == (uint32_t)Tracing::TypeUnknown);
	TS_STATIC_ASSERT(TS_TracingTypeInstance == (uint32_t)Tracing::TypeInstance);
	TS_STATIC_ASSERT(TS_TracingTypeTriangle == (uint32_t)Tracing::TypeTriangle);
	TS_STATIC_ASSERT(TS_TracingTypeBound == (uint32_t)Tracing::TypeBound);
	TS_STATIC_ASSERT(TS_TracingTypeNumTypes == (uint32_t)Tracing::NumTypes);
	
	// Tellusim::Tracing::Flags
	TS_STATIC_ASSERT(TS_TracingFlagNone == (uint32_t)Tracing::FlagNone);
	TS_STATIC_ASSERT(TS_TracingFlagInfo == (uint32_t)Tracing::FlagInfo);
	TS_STATIC_ASSERT(TS_TracingFlagUpdate == (uint32_t)Tracing::FlagUpdate);
	TS_STATIC_ASSERT(TS_TracingFlagCompact == (uint32_t)Tracing::FlagCompact);
	TS_STATIC_ASSERT(TS_TracingFlagTransparent == (uint32_t)Tracing::FlagTransparent);
	TS_STATIC_ASSERT(TS_TracingFlagFastBuild == (uint32_t)Tracing::FlagFastBuild);
	TS_STATIC_ASSERT(TS_TracingFlagFastTrace == (uint32_t)Tracing::FlagFastTrace);
	TS_STATIC_ASSERT(TS_TracingDefaultFlags == (uint32_t)Tracing::DefaultFlags);
	TS_STATIC_ASSERT(TS_TracingNumFlags == (uint32_t)Tracing::NumFlags);
	
	// Tellusim::Tracing::
	TS_STATIC_ASSERT(TS_TracingInstanceSize == (uint32_t)Tracing::InstanceSize);
	
	// Tellusim::Target::Operation
	TS_STATIC_ASSERT(TS_TargetOperationBeginLoad == (uint32_t)Target::BeginLoad);
	TS_STATIC_ASSERT(TS_TargetOperationBeginClear == (uint32_t)Target::BeginClear);
	TS_STATIC_ASSERT(TS_TargetOperationBeginDiscard == (uint32_t)Target::BeginDiscard);
	TS_STATIC_ASSERT(TS_TargetOperationBeginMask == (uint32_t)Target::BeginMask);
	TS_STATIC_ASSERT(TS_TargetOperationEndStore == (uint32_t)Target::EndStore);
	TS_STATIC_ASSERT(TS_TargetOperationEndResolve == (uint32_t)Target::EndResolve);
	TS_STATIC_ASSERT(TS_TargetOperationEndDiscard == (uint32_t)Target::EndDiscard);
	TS_STATIC_ASSERT(TS_TargetOperationEndMask == (uint32_t)Target::EndMask);
	TS_STATIC_ASSERT(TS_TargetOperationOpNone == (uint32_t)Target::OpNone);
	TS_STATIC_ASSERT(TS_TargetOperationOpLoad == (uint32_t)Target::OpLoad);
	TS_STATIC_ASSERT(TS_TargetOperationOpLoadStore == (uint32_t)Target::OpLoadStore);
	TS_STATIC_ASSERT(TS_TargetOperationOpClearStore == (uint32_t)Target::OpClearStore);
	TS_STATIC_ASSERT(TS_TargetOperationOpClearDiscard == (uint32_t)Target::OpClearDiscard);
	TS_STATIC_ASSERT(TS_TargetOperationOpDefault == (uint32_t)Target::OpDefault);
	
	// Tellusim::Pipeline::Primitive
	TS_STATIC_ASSERT(TS_PipelinePrimitivePoint == (uint32_t)Pipeline::PrimitivePoint);
	TS_STATIC_ASSERT(TS_PipelinePrimitivePointPatch == (uint32_t)Pipeline::PrimitivePointPatch);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveLine == (uint32_t)Pipeline::PrimitiveLine);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveLineAdj == (uint32_t)Pipeline::PrimitiveLineAdj);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveLineStrip == (uint32_t)Pipeline::PrimitiveLineStrip);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveLinePatch == (uint32_t)Pipeline::PrimitiveLinePatch);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveTriangle == (uint32_t)Pipeline::PrimitiveTriangle);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveTriangleAdj == (uint32_t)Pipeline::PrimitiveTriangleAdj);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveTriangleStrip == (uint32_t)Pipeline::PrimitiveTriangleStrip);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveTrianglePatch == (uint32_t)Pipeline::PrimitiveTrianglePatch);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveQuadrilateralPatch == (uint32_t)Pipeline::PrimitiveQuadrilateralPatch);
	TS_STATIC_ASSERT(TS_PipelinePrimitiveNumPrimitiveTypes == (uint32_t)Pipeline::NumPrimitiveTypes);
	
	// Tellusim::Pipeline::Attribute
	TS_STATIC_ASSERT(TS_PipelineAttributePosition == (uint32_t)Pipeline::AttributePosition);
	TS_STATIC_ASSERT(TS_PipelineAttributeBasis == (uint32_t)Pipeline::AttributeBasis);
	TS_STATIC_ASSERT(TS_PipelineAttributeNormal == (uint32_t)Pipeline::AttributeNormal);
	TS_STATIC_ASSERT(TS_PipelineAttributeTangent == (uint32_t)Pipeline::AttributeTangent);
	TS_STATIC_ASSERT(TS_PipelineAttributeBinormal == (uint32_t)Pipeline::AttributeBinormal);
	TS_STATIC_ASSERT(TS_PipelineAttributeTexCoord == (uint32_t)Pipeline::AttributeTexCoord);
	TS_STATIC_ASSERT(TS_PipelineAttributeWeights == (uint32_t)Pipeline::AttributeWeights);
	TS_STATIC_ASSERT(TS_PipelineAttributeJoints == (uint32_t)Pipeline::AttributeJoints);
	TS_STATIC_ASSERT(TS_PipelineAttributeColor == (uint32_t)Pipeline::AttributeColor);
	TS_STATIC_ASSERT(TS_PipelineAttributeIndex == (uint32_t)Pipeline::AttributeIndex);
	TS_STATIC_ASSERT(TS_PipelineAttributeNumAttributeTypes == (uint32_t)Pipeline::NumAttributeTypes);
	
	// Tellusim::Pipeline::FillMode
	TS_STATIC_ASSERT(TS_PipelineFillModeLine == (uint32_t)Pipeline::FillModeLine);
	TS_STATIC_ASSERT(TS_PipelineFillModeSolid == (uint32_t)Pipeline::FillModeSolid);
	TS_STATIC_ASSERT(TS_PipelineFillModeNumFillModes == (uint32_t)Pipeline::NumFillModes);
	
	// Tellusim::Pipeline::CullMode
	TS_STATIC_ASSERT(TS_PipelineCullModeNone == (uint32_t)Pipeline::CullModeNone);
	TS_STATIC_ASSERT(TS_PipelineCullModeBack == (uint32_t)Pipeline::CullModeBack);
	TS_STATIC_ASSERT(TS_PipelineCullModeFront == (uint32_t)Pipeline::CullModeFront);
	TS_STATIC_ASSERT(TS_PipelineCullModeNumCullModes == (uint32_t)Pipeline::NumCullModes);
	
	// Tellusim::Pipeline::FrontMode
	TS_STATIC_ASSERT(TS_PipelineFrontModeCCW == (uint32_t)Pipeline::FrontModeCCW);
	TS_STATIC_ASSERT(TS_PipelineFrontModeCW == (uint32_t)Pipeline::FrontModeCW);
	TS_STATIC_ASSERT(TS_PipelineFrontModeNumFrontModes == (uint32_t)Pipeline::NumFrontModes);
	
	// Tellusim::Pipeline::BlendOp
	TS_STATIC_ASSERT(TS_PipelineBlendOpAdd == (uint32_t)Pipeline::BlendOpAdd);
	TS_STATIC_ASSERT(TS_PipelineBlendOpSub == (uint32_t)Pipeline::BlendOpSub);
	TS_STATIC_ASSERT(TS_PipelineBlendOpMin == (uint32_t)Pipeline::BlendOpMin);
	TS_STATIC_ASSERT(TS_PipelineBlendOpMax == (uint32_t)Pipeline::BlendOpMax);
	TS_STATIC_ASSERT(TS_PipelineBlendOpNumBlendOperations == (uint32_t)Pipeline::NumBlendOperations);
	
	// Tellusim::Pipeline::BlendFunc
	TS_STATIC_ASSERT(TS_PipelineBlendFuncNone == (uint32_t)Pipeline::BlendFuncNone);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncZero == (uint32_t)Pipeline::BlendFuncZero);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncOne == (uint32_t)Pipeline::BlendFuncOne);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncSrcColor == (uint32_t)Pipeline::BlendFuncSrcColor);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncSrcAlpha == (uint32_t)Pipeline::BlendFuncSrcAlpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncSrc1Color == (uint32_t)Pipeline::BlendFuncSrc1Color);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncSrc1Alpha == (uint32_t)Pipeline::BlendFuncSrc1Alpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncDestColor == (uint32_t)Pipeline::BlendFuncDestColor);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncDestAlpha == (uint32_t)Pipeline::BlendFuncDestAlpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncFactorColor == (uint32_t)Pipeline::BlendFuncFactorColor);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncFactorAlpha == (uint32_t)Pipeline::BlendFuncFactorAlpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvSrcColor == (uint32_t)Pipeline::BlendFuncInvSrcColor);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvSrcAlpha == (uint32_t)Pipeline::BlendFuncInvSrcAlpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvSrc1Color == (uint32_t)Pipeline::BlendFuncInvSrc1Color);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvSrc1Alpha == (uint32_t)Pipeline::BlendFuncInvSrc1Alpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvDestColor == (uint32_t)Pipeline::BlendFuncInvDestColor);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvDestAlpha == (uint32_t)Pipeline::BlendFuncInvDestAlpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvFactorColor == (uint32_t)Pipeline::BlendFuncInvFactorColor);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncInvFactorAlpha == (uint32_t)Pipeline::BlendFuncInvFactorAlpha);
	TS_STATIC_ASSERT(TS_PipelineBlendFuncNumBlendFunctions == (uint32_t)Pipeline::NumBlendFunctions);
	
	// Tellusim::Pipeline::ColorMask
	TS_STATIC_ASSERT(TS_PipelineColorMaskNone == (uint32_t)Pipeline::ColorMaskNone);
	TS_STATIC_ASSERT(TS_PipelineColorMaskR == (uint32_t)Pipeline::ColorMaskR);
	TS_STATIC_ASSERT(TS_PipelineColorMaskG == (uint32_t)Pipeline::ColorMaskG);
	TS_STATIC_ASSERT(TS_PipelineColorMaskB == (uint32_t)Pipeline::ColorMaskB);
	TS_STATIC_ASSERT(TS_PipelineColorMaskA == (uint32_t)Pipeline::ColorMaskA);
	TS_STATIC_ASSERT(TS_PipelineColorMaskUnknown == (uint32_t)Pipeline::ColorMaskUnknown);
	TS_STATIC_ASSERT(TS_PipelineColorMaskRGB == (uint32_t)Pipeline::ColorMaskRGB);
	TS_STATIC_ASSERT(TS_PipelineColorMaskAll == (uint32_t)Pipeline::ColorMaskAll);
	
	// Tellusim::Pipeline::DepthMask
	TS_STATIC_ASSERT(TS_PipelineDepthMaskNone == (uint32_t)Pipeline::DepthMaskNone);
	TS_STATIC_ASSERT(TS_PipelineDepthMaskRead == (uint32_t)Pipeline::DepthMaskRead);
	TS_STATIC_ASSERT(TS_PipelineDepthMaskWrite == (uint32_t)Pipeline::DepthMaskWrite);
	TS_STATIC_ASSERT(TS_PipelineDepthMaskNumDepthMasks == (uint32_t)Pipeline::NumDepthMasks);
	
	// Tellusim::Pipeline::DepthFunc
	TS_STATIC_ASSERT(TS_PipelineDepthFuncNone == (uint32_t)Pipeline::DepthFuncNone);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncNever == (uint32_t)Pipeline::DepthFuncNever);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncAlways == (uint32_t)Pipeline::DepthFuncAlways);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncEqual == (uint32_t)Pipeline::DepthFuncEqual);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncLess == (uint32_t)Pipeline::DepthFuncLess);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncGreater == (uint32_t)Pipeline::DepthFuncGreater);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncNotEqual == (uint32_t)Pipeline::DepthFuncNotEqual);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncLessEqual == (uint32_t)Pipeline::DepthFuncLessEqual);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncGreaterEqual == (uint32_t)Pipeline::DepthFuncGreaterEqual);
	TS_STATIC_ASSERT(TS_PipelineDepthFuncNumDepthFunctions == (uint32_t)Pipeline::NumDepthFunctions);
	
	// Tellusim::Pipeline::StencilOp
	TS_STATIC_ASSERT(TS_PipelineStencilOpKeep == (uint32_t)Pipeline::StencilOpKeep);
	TS_STATIC_ASSERT(TS_PipelineStencilOpInvert == (uint32_t)Pipeline::StencilOpInvert);
	TS_STATIC_ASSERT(TS_PipelineStencilOpReplace == (uint32_t)Pipeline::StencilOpReplace);
	TS_STATIC_ASSERT(TS_PipelineStencilOpIncrWrap == (uint32_t)Pipeline::StencilOpIncrWrap);
	TS_STATIC_ASSERT(TS_PipelineStencilOpDecrWrap == (uint32_t)Pipeline::StencilOpDecrWrap);
	TS_STATIC_ASSERT(TS_PipelineStencilOpIncrSat == (uint32_t)Pipeline::StencilOpIncrSat);
	TS_STATIC_ASSERT(TS_PipelineStencilOpDecrSat == (uint32_t)Pipeline::StencilOpDecrSat);
	TS_STATIC_ASSERT(TS_PipelineStencilOpNumStencilOperations == (uint32_t)Pipeline::NumStencilOperations);
	
	// Tellusim::Pipeline::StencilFunc
	TS_STATIC_ASSERT(TS_PipelineStencilFuncNone == (uint32_t)Pipeline::StencilFuncNone);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncNever == (uint32_t)Pipeline::StencilFuncNever);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncAlways == (uint32_t)Pipeline::StencilFuncAlways);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncEqual == (uint32_t)Pipeline::StencilFuncEqual);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncLess == (uint32_t)Pipeline::StencilFuncLess);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncGreater == (uint32_t)Pipeline::StencilFuncGreater);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncNotEqual == (uint32_t)Pipeline::StencilFuncNotEqual);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncLessEqual == (uint32_t)Pipeline::StencilFuncLessEqual);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncGreaterEqual == (uint32_t)Pipeline::StencilFuncGreaterEqual);
	TS_STATIC_ASSERT(TS_PipelineStencilFuncNumStencilFunctions == (uint32_t)Pipeline::NumStencilFunctions);
	
	// Tellusim::Window::Flags
	TS_STATIC_ASSERT(TS_WindowFlagNone == (uint32_t)Window::FlagNone);
	TS_STATIC_ASSERT(TS_WindowFlagTitle == (uint32_t)Window::FlagTitle);
	TS_STATIC_ASSERT(TS_WindowFlagClose == (uint32_t)Window::FlagClose);
	TS_STATIC_ASSERT(TS_WindowFlagFrame == (uint32_t)Window::FlagFrame);
	TS_STATIC_ASSERT(TS_WindowFlagResize == (uint32_t)Window::FlagResize);
	TS_STATIC_ASSERT(TS_WindowFlagMinimize == (uint32_t)Window::FlagMinimize);
	TS_STATIC_ASSERT(TS_WindowFlagMaximize == (uint32_t)Window::FlagMaximize);
	TS_STATIC_ASSERT(TS_WindowFlagTransient == (uint32_t)Window::FlagTransient);
	TS_STATIC_ASSERT(TS_WindowFlagFullscreen == (uint32_t)Window::FlagFullscreen);
	TS_STATIC_ASSERT(TS_WindowFlagTransparent == (uint32_t)Window::FlagTransparent);
	TS_STATIC_ASSERT(TS_WindowFlagFileDropped == (uint32_t)Window::FlagFileDropped);
	TS_STATIC_ASSERT(TS_WindowFlagMultisample2 == (uint32_t)Window::FlagMultisample2);
	TS_STATIC_ASSERT(TS_WindowFlagMultisample4 == (uint32_t)Window::FlagMultisample4);
	TS_STATIC_ASSERT(TS_WindowFlagMultisample8 == (uint32_t)Window::FlagMultisample8);
	TS_STATIC_ASSERT(TS_WindowFlagVerticalSync == (uint32_t)Window::FlagVerticalSync);
	TS_STATIC_ASSERT(TS_WindowFlagRefreshSync == (uint32_t)Window::FlagRefreshSync);
	TS_STATIC_ASSERT(TS_WindowFlagColorRGBAu8ns == (uint32_t)Window::FlagColorRGBAu8ns);
	TS_STATIC_ASSERT(TS_WindowFlagColorRGBu10Au2n == (uint32_t)Window::FlagColorRGBu10Au2n);
	TS_STATIC_ASSERT(TS_WindowFlagColorRGBAf16 == (uint32_t)Window::FlagColorRGBAf16);
	TS_STATIC_ASSERT(TS_WindowFlagMultisample == (uint32_t)Window::FlagMultisample);
	TS_STATIC_ASSERT(TS_WindowDefaultFlags == (uint32_t)Window::DefaultFlags);
	TS_STATIC_ASSERT(TS_WindowNumFlags == (uint32_t)Window::NumFlags);
	
	// Tellusim::Window::Cursor
	TS_STATIC_ASSERT(TS_WindowCursorArrow == (uint32_t)Window::CursorArrow);
	TS_STATIC_ASSERT(TS_WindowCursorInvalid == (uint32_t)Window::CursorInvalid);
	TS_STATIC_ASSERT(TS_WindowCursorLeft == (uint32_t)Window::CursorLeft);
	TS_STATIC_ASSERT(TS_WindowCursorRight == (uint32_t)Window::CursorRight);
	TS_STATIC_ASSERT(TS_WindowCursorBottom == (uint32_t)Window::CursorBottom);
	TS_STATIC_ASSERT(TS_WindowCursorTop == (uint32_t)Window::CursorTop);
	TS_STATIC_ASSERT(TS_WindowCursorWidth == (uint32_t)Window::CursorWidth);
	TS_STATIC_ASSERT(TS_WindowCursorHeight == (uint32_t)Window::CursorHeight);
	TS_STATIC_ASSERT(TS_WindowCursorMajor == (uint32_t)Window::CursorMajor);
	TS_STATIC_ASSERT(TS_WindowCursorMinor == (uint32_t)Window::CursorMinor);
	TS_STATIC_ASSERT(TS_WindowCursorAll == (uint32_t)Window::CursorAll);
	TS_STATIC_ASSERT(TS_WindowCursorNumCursors == (uint32_t)Window::NumCursors);
	
	// Tellusim::Window::Button
	TS_STATIC_ASSERT(TS_WindowButtonNone == (uint32_t)Window::ButtonNone);
	TS_STATIC_ASSERT(TS_WindowButtonLeft == (uint32_t)Window::ButtonLeft);
	TS_STATIC_ASSERT(TS_WindowButtonLeft2 == (uint32_t)Window::ButtonLeft2);
	TS_STATIC_ASSERT(TS_WindowButtonRight == (uint32_t)Window::ButtonRight);
	TS_STATIC_ASSERT(TS_WindowButtonRight2 == (uint32_t)Window::ButtonRight2);
	TS_STATIC_ASSERT(TS_WindowButtonMiddle == (uint32_t)Window::ButtonMiddle);
	TS_STATIC_ASSERT(TS_WindowButtonMiddle2 == (uint32_t)Window::ButtonMiddle2);
	TS_STATIC_ASSERT(TS_WindowButtonBack == (uint32_t)Window::ButtonBack);
	TS_STATIC_ASSERT(TS_WindowButtonBack2 == (uint32_t)Window::ButtonBack2);
	TS_STATIC_ASSERT(TS_WindowButtonForward == (uint32_t)Window::ButtonForward);
	TS_STATIC_ASSERT(TS_WindowButtonForward2 == (uint32_t)Window::ButtonForward2);
	TS_STATIC_ASSERT(TS_WindowButtonNumButtons == (uint32_t)Window::NumButtons);
	
	// Tellusim::Window::Axis
	TS_STATIC_ASSERT(TS_WindowAxisX == (uint32_t)Window::AxisX);
	TS_STATIC_ASSERT(TS_WindowAxisY == (uint32_t)Window::AxisY);
	TS_STATIC_ASSERT(TS_WindowAxisZ == (uint32_t)Window::AxisZ);
	TS_STATIC_ASSERT(TS_WindowAxisW == (uint32_t)Window::AxisW);
	TS_STATIC_ASSERT(TS_WindowAxisNumAxes == (uint32_t)Window::NumAxes);
	
	// Tellusim::Window::
	TS_STATIC_ASSERT(TS_WindowNumTouches == (uint32_t)Window::NumTouches);
	
	// Tellusim::Window::Key
	TS_STATIC_ASSERT(TS_WindowKeyNone == (uint32_t)Window::KeyNone);
	TS_STATIC_ASSERT(TS_WindowKeyEsc == (uint32_t)Window::KeyEsc);
	TS_STATIC_ASSERT(TS_WindowKeyTab == (uint32_t)Window::KeyTab);
	TS_STATIC_ASSERT(TS_WindowKeyBackspace == (uint32_t)Window::KeyBackspace);
	TS_STATIC_ASSERT(TS_WindowKeyDelete == (uint32_t)Window::KeyDelete);
	TS_STATIC_ASSERT(TS_WindowKeyInsert == (uint32_t)Window::KeyInsert);
	TS_STATIC_ASSERT(TS_WindowKeyReturn == (uint32_t)Window::KeyReturn);
	TS_STATIC_ASSERT(TS_WindowKeyPause == (uint32_t)Window::KeyPause);
	TS_STATIC_ASSERT(TS_WindowKeyPrior == (uint32_t)Window::KeyPrior);
	TS_STATIC_ASSERT(TS_WindowKeyNext == (uint32_t)Window::KeyNext);
	TS_STATIC_ASSERT(TS_WindowKeyEnd == (uint32_t)Window::KeyEnd);
	TS_STATIC_ASSERT(TS_WindowKeyHome == (uint32_t)Window::KeyHome);
	TS_STATIC_ASSERT(TS_WindowKeyUp == (uint32_t)Window::KeyUp);
	TS_STATIC_ASSERT(TS_WindowKeyDown == (uint32_t)Window::KeyDown);
	TS_STATIC_ASSERT(TS_WindowKeyLeft == (uint32_t)Window::KeyLeft);
	TS_STATIC_ASSERT(TS_WindowKeyRight == (uint32_t)Window::KeyRight);
	TS_STATIC_ASSERT(TS_WindowKeyNum == (uint32_t)Window::KeyNum);
	TS_STATIC_ASSERT(TS_WindowKeyCaps == (uint32_t)Window::KeyCaps);
	TS_STATIC_ASSERT(TS_WindowKeyScroll == (uint32_t)Window::KeyScroll);
	TS_STATIC_ASSERT(TS_WindowKeyShift == (uint32_t)Window::KeyShift);
	TS_STATIC_ASSERT(TS_WindowKeyCtrl == (uint32_t)Window::KeyCtrl);
	TS_STATIC_ASSERT(TS_WindowKeyAlt == (uint32_t)Window::KeyAlt);
	TS_STATIC_ASSERT(TS_WindowKeyWin == (uint32_t)Window::KeyWin);
	TS_STATIC_ASSERT(TS_WindowKeyCmd == (uint32_t)Window::KeyCmd);
	TS_STATIC_ASSERT(TS_WindowKeyMenu == (uint32_t)Window::KeyMenu);
	TS_STATIC_ASSERT(TS_WindowKeyF1 == (uint32_t)Window::KeyF1);
	TS_STATIC_ASSERT(TS_WindowKeyF2 == (uint32_t)Window::KeyF2);
	TS_STATIC_ASSERT(TS_WindowKeyF3 == (uint32_t)Window::KeyF3);
	TS_STATIC_ASSERT(TS_WindowKeyF4 == (uint32_t)Window::KeyF4);
	TS_STATIC_ASSERT(TS_WindowKeyF5 == (uint32_t)Window::KeyF5);
	TS_STATIC_ASSERT(TS_WindowKeyF6 == (uint32_t)Window::KeyF6);
	TS_STATIC_ASSERT(TS_WindowKeyF7 == (uint32_t)Window::KeyF7);
	TS_STATIC_ASSERT(TS_WindowKeyF8 == (uint32_t)Window::KeyF8);
	TS_STATIC_ASSERT(TS_WindowKeyF9 == (uint32_t)Window::KeyF9);
	TS_STATIC_ASSERT(TS_WindowKeyF10 == (uint32_t)Window::KeyF10);
	TS_STATIC_ASSERT(TS_WindowKeyF11 == (uint32_t)Window::KeyF11);
	TS_STATIC_ASSERT(TS_WindowKeyF12 == (uint32_t)Window::KeyF12);
	TS_STATIC_ASSERT(TS_WindowKeyNumKeys == (uint32_t)Window::NumKeys);
	
	// Tellusim::CanvasElement::Type
	TS_STATIC_ASSERT(TS_CanvasElementTypeUnknown == (uint32_t)CanvasElement::TypeUnknown);
	TS_STATIC_ASSERT(TS_CanvasElementTypeText == (uint32_t)CanvasElement::TypeText);
	TS_STATIC_ASSERT(TS_CanvasElementTypeMesh == (uint32_t)CanvasElement::TypeMesh);
	TS_STATIC_ASSERT(TS_CanvasElementTypeRect == (uint32_t)CanvasElement::TypeRect);
	TS_STATIC_ASSERT(TS_CanvasElementTypeTriangle == (uint32_t)CanvasElement::TypeTriangle);
	TS_STATIC_ASSERT(TS_CanvasElementTypeEllipse == (uint32_t)CanvasElement::TypeEllipse);
	TS_STATIC_ASSERT(TS_CanvasElementTypeShape == (uint32_t)CanvasElement::TypeShape);
	TS_STATIC_ASSERT(TS_CanvasElementTypeStrip == (uint32_t)CanvasElement::TypeStrip);
	TS_STATIC_ASSERT(TS_CanvasElementTypeNumTypes == (uint32_t)CanvasElement::NumTypes);
	
	// Tellusim::CanvasElement::Mode
	TS_STATIC_ASSERT(TS_CanvasElementModeSolid == (uint32_t)CanvasElement::ModeSolid);
	TS_STATIC_ASSERT(TS_CanvasElementModeTexture == (uint32_t)CanvasElement::ModeTexture);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureFetch == (uint32_t)CanvasElement::ModeTextureFetch);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureClamp == (uint32_t)CanvasElement::ModeTextureClamp);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureCubic == (uint32_t)CanvasElement::ModeTextureCubic);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureCubic3x3 == (uint32_t)CanvasElement::ModeTextureCubic3x3);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureCubic5x5 == (uint32_t)CanvasElement::ModeTextureCubic5x5);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureRed == (uint32_t)CanvasElement::ModeTextureRed);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureGreen == (uint32_t)CanvasElement::ModeTextureGreen);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureBlue == (uint32_t)CanvasElement::ModeTextureBlue);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureAlpha == (uint32_t)CanvasElement::ModeTextureAlpha);
	TS_STATIC_ASSERT(TS_CanvasElementModeTextureYOG == (uint32_t)CanvasElement::ModeTextureYOG);
	TS_STATIC_ASSERT(TS_CanvasElementModeGradient == (uint32_t)CanvasElement::ModeGradient);
	TS_STATIC_ASSERT(TS_CanvasElementModeNumModes == (uint32_t)CanvasElement::NumModes);
	
	// Tellusim::CanvasElement::Align
	TS_STATIC_ASSERT(TS_CanvasElementAlignNone == (uint32_t)CanvasElement::AlignNone);
	TS_STATIC_ASSERT(TS_CanvasElementAlignLeft == (uint32_t)CanvasElement::AlignLeft);
	TS_STATIC_ASSERT(TS_CanvasElementAlignRight == (uint32_t)CanvasElement::AlignRight);
	TS_STATIC_ASSERT(TS_CanvasElementAlignBottom == (uint32_t)CanvasElement::AlignBottom);
	TS_STATIC_ASSERT(TS_CanvasElementAlignTop == (uint32_t)CanvasElement::AlignTop);
	TS_STATIC_ASSERT(TS_CanvasElementAlignCenterX == (uint32_t)CanvasElement::AlignCenterX);
	TS_STATIC_ASSERT(TS_CanvasElementAlignCenterY == (uint32_t)CanvasElement::AlignCenterY);
	TS_STATIC_ASSERT(TS_CanvasElementAlignLeftBottom == (uint32_t)CanvasElement::AlignLeftBottom);
	TS_STATIC_ASSERT(TS_CanvasElementAlignLeftTop == (uint32_t)CanvasElement::AlignLeftTop);
	TS_STATIC_ASSERT(TS_CanvasElementAlignRightBottom == (uint32_t)CanvasElement::AlignRightBottom);
	TS_STATIC_ASSERT(TS_CanvasElementAlignRightTop == (uint32_t)CanvasElement::AlignRightTop);
	TS_STATIC_ASSERT(TS_CanvasElementAlignCenter == (uint32_t)CanvasElement::AlignCenter);
	TS_STATIC_ASSERT(TS_CanvasElementAlignNumAligns == (uint32_t)CanvasElement::NumAligns);
	
	// Tellusim::CanvasElement::Stack
	TS_STATIC_ASSERT(TS_CanvasElementStackNone == (uint32_t)CanvasElement::StackNone);
	TS_STATIC_ASSERT(TS_CanvasElementStackPush == (uint32_t)CanvasElement::StackPush);
	TS_STATIC_ASSERT(TS_CanvasElementStackPop == (uint32_t)CanvasElement::StackPop);
	TS_STATIC_ASSERT(TS_CanvasElementStackSet == (uint32_t)CanvasElement::StackSet);
	TS_STATIC_ASSERT(TS_CanvasElementStackMul == (uint32_t)CanvasElement::StackMul);
	TS_STATIC_ASSERT(TS_CanvasElementStackGet == (uint32_t)CanvasElement::StackGet);
	
	// Tellusim::Control::Type
	TS_STATIC_ASSERT(TS_ControlTypeUnknown == (uint32_t)Control::TypeUnknown);
	TS_STATIC_ASSERT(TS_ControlTypeRoot == (uint32_t)Control::TypeRoot);
	TS_STATIC_ASSERT(TS_ControlTypeText == (uint32_t)Control::TypeText);
	TS_STATIC_ASSERT(TS_ControlTypeRect == (uint32_t)Control::TypeRect);
	TS_STATIC_ASSERT(TS_ControlTypeGrid == (uint32_t)Control::TypeGrid);
	TS_STATIC_ASSERT(TS_ControlTypeGroup == (uint32_t)Control::TypeGroup);
	TS_STATIC_ASSERT(TS_ControlTypePanel == (uint32_t)Control::TypePanel);
	TS_STATIC_ASSERT(TS_ControlTypeDialog == (uint32_t)Control::TypeDialog);
	TS_STATIC_ASSERT(TS_ControlTypeWindow == (uint32_t)Control::TypeWindow);
	TS_STATIC_ASSERT(TS_ControlTypeCheck == (uint32_t)Control::TypeCheck);
	TS_STATIC_ASSERT(TS_ControlTypeCombo == (uint32_t)Control::TypeCombo);
	TS_STATIC_ASSERT(TS_ControlTypeButton == (uint32_t)Control::TypeButton);
	TS_STATIC_ASSERT(TS_ControlTypeSlider == (uint32_t)Control::TypeSlider);
	TS_STATIC_ASSERT(TS_ControlTypeScroll == (uint32_t)Control::TypeScroll);
	TS_STATIC_ASSERT(TS_ControlTypeSplit == (uint32_t)Control::TypeSplit);
	TS_STATIC_ASSERT(TS_ControlTypeArea == (uint32_t)Control::TypeArea);
	TS_STATIC_ASSERT(TS_ControlTypeTree == (uint32_t)Control::TypeTree);
	TS_STATIC_ASSERT(TS_ControlTypeEdit == (uint32_t)Control::TypeEdit);
	TS_STATIC_ASSERT(TS_ControlTypeNumTypes == (uint32_t)Control::NumTypes);
	
	// Tellusim::Control::State
	TS_STATIC_ASSERT(TS_ControlStateUnknown == (uint32_t)Control::StateUnknown);
	TS_STATIC_ASSERT(TS_ControlStateNormal == (uint32_t)Control::StateNormal);
	TS_STATIC_ASSERT(TS_ControlStateFocused == (uint32_t)Control::StateFocused);
	TS_STATIC_ASSERT(TS_ControlStatePressed == (uint32_t)Control::StatePressed);
	TS_STATIC_ASSERT(TS_ControlStateDisabled == (uint32_t)Control::StateDisabled);
	TS_STATIC_ASSERT(TS_ControlStateNumStates == (uint32_t)Control::NumStates);
	
	// Tellusim::Control::Mesh
	TS_STATIC_ASSERT(TS_ControlMeshCheck == (uint32_t)Control::MeshCheck);
	TS_STATIC_ASSERT(TS_ControlMeshButton == (uint32_t)Control::MeshButton);
	TS_STATIC_ASSERT(TS_ControlMeshSliderLine == (uint32_t)Control::MeshSliderLine);
	TS_STATIC_ASSERT(TS_ControlMeshHScrollLine == (uint32_t)Control::MeshHScrollLine);
	TS_STATIC_ASSERT(TS_ControlMeshVScrollLine == (uint32_t)Control::MeshVScrollLine);
	TS_STATIC_ASSERT(TS_ControlMeshSliderHandle == (uint32_t)Control::MeshSliderHandle);
	TS_STATIC_ASSERT(TS_ControlMeshHScrollHandle == (uint32_t)Control::MeshHScrollHandle);
	TS_STATIC_ASSERT(TS_ControlMeshVScrollHandle == (uint32_t)Control::MeshVScrollHandle);
	TS_STATIC_ASSERT(TS_ControlMeshBackground == (uint32_t)Control::MeshBackground);
	TS_STATIC_ASSERT(TS_ControlMeshSelection == (uint32_t)Control::MeshSelection);
	TS_STATIC_ASSERT(TS_ControlMeshBorder == (uint32_t)Control::MeshBorder);
	TS_STATIC_ASSERT(TS_ControlMeshFrame == (uint32_t)Control::MeshFrame);
	TS_STATIC_ASSERT(TS_ControlMeshNumMeshes == (uint32_t)Control::NumMeshes);
	
	// Tellusim::Control::Align
	TS_STATIC_ASSERT(TS_ControlAlignNone == (uint32_t)Control::AlignNone);
	TS_STATIC_ASSERT(TS_ControlAlignLeft == (uint32_t)Control::AlignLeft);
	TS_STATIC_ASSERT(TS_ControlAlignRight == (uint32_t)Control::AlignRight);
	TS_STATIC_ASSERT(TS_ControlAlignBottom == (uint32_t)Control::AlignBottom);
	TS_STATIC_ASSERT(TS_ControlAlignTop == (uint32_t)Control::AlignTop);
	TS_STATIC_ASSERT(TS_ControlAlignCenterX == (uint32_t)Control::AlignCenterX);
	TS_STATIC_ASSERT(TS_ControlAlignCenterY == (uint32_t)Control::AlignCenterY);
	TS_STATIC_ASSERT(TS_ControlAlignExpandX == (uint32_t)Control::AlignExpandX);
	TS_STATIC_ASSERT(TS_ControlAlignExpandY == (uint32_t)Control::AlignExpandY);
	TS_STATIC_ASSERT(TS_ControlAlignOverlap == (uint32_t)Control::AlignOverlap);
	TS_STATIC_ASSERT(TS_ControlAlignSpacer == (uint32_t)Control::AlignSpacer);
	TS_STATIC_ASSERT(TS_ControlAlignAspect == (uint32_t)Control::AlignAspect);
	TS_STATIC_ASSERT(TS_ControlAlignLeftBottom == (uint32_t)Control::AlignLeftBottom);
	TS_STATIC_ASSERT(TS_ControlAlignLeftTop == (uint32_t)Control::AlignLeftTop);
	TS_STATIC_ASSERT(TS_ControlAlignRightBottom == (uint32_t)Control::AlignRightBottom);
	TS_STATIC_ASSERT(TS_ControlAlignRightTop == (uint32_t)Control::AlignRightTop);
	TS_STATIC_ASSERT(TS_ControlAlignCenter == (uint32_t)Control::AlignCenter);
	TS_STATIC_ASSERT(TS_ControlAlignExpand == (uint32_t)Control::AlignExpand);
	TS_STATIC_ASSERT(TS_ControlAlignNumAligns == (uint32_t)Control::NumAligns);
	
	// Tellusim::Control::Button
	TS_STATIC_ASSERT(TS_ControlButtonNone == (uint32_t)Control::ButtonNone);
	TS_STATIC_ASSERT(TS_ControlButtonLeft == (uint32_t)Control::ButtonLeft);
	TS_STATIC_ASSERT(TS_ControlButtonLeft2 == (uint32_t)Control::ButtonLeft2);
	TS_STATIC_ASSERT(TS_ControlButtonRight == (uint32_t)Control::ButtonRight);
	TS_STATIC_ASSERT(TS_ControlButtonRight2 == (uint32_t)Control::ButtonRight2);
	TS_STATIC_ASSERT(TS_ControlButtonMiddle == (uint32_t)Control::ButtonMiddle);
	TS_STATIC_ASSERT(TS_ControlButtonMiddle2 == (uint32_t)Control::ButtonMiddle2);
	TS_STATIC_ASSERT(TS_ControlButtonNumButtons == (uint32_t)Control::NumButtons);
	
	// Tellusim::Control::Axis
	TS_STATIC_ASSERT(TS_ControlAxisUnknown == (uint32_t)Control::AxisUnknown);
	TS_STATIC_ASSERT(TS_ControlAxisX == (uint32_t)Control::AxisX);
	TS_STATIC_ASSERT(TS_ControlAxisY == (uint32_t)Control::AxisY);
	TS_STATIC_ASSERT(TS_ControlAxisZ == (uint32_t)Control::AxisZ);
	TS_STATIC_ASSERT(TS_ControlAxisW == (uint32_t)Control::AxisW);
	TS_STATIC_ASSERT(TS_ControlAxisNumAxes == (uint32_t)Control::NumAxes);
	
	// Tellusim::Control::Key
	TS_STATIC_ASSERT(TS_ControlKeyNone == (uint32_t)Control::KeyNone);
	TS_STATIC_ASSERT(TS_ControlKeyTab == (uint32_t)Control::KeyTab);
	TS_STATIC_ASSERT(TS_ControlKeyBackspace == (uint32_t)Control::KeyBackspace);
	TS_STATIC_ASSERT(TS_ControlKeyDelete == (uint32_t)Control::KeyDelete);
	TS_STATIC_ASSERT(TS_ControlKeyInsert == (uint32_t)Control::KeyInsert);
	TS_STATIC_ASSERT(TS_ControlKeyReturn == (uint32_t)Control::KeyReturn);
	TS_STATIC_ASSERT(TS_ControlKeyPrior == (uint32_t)Control::KeyPrior);
	TS_STATIC_ASSERT(TS_ControlKeyNext == (uint32_t)Control::KeyNext);
	TS_STATIC_ASSERT(TS_ControlKeyEnd == (uint32_t)Control::KeyEnd);
	TS_STATIC_ASSERT(TS_ControlKeyHome == (uint32_t)Control::KeyHome);
	TS_STATIC_ASSERT(TS_ControlKeyUp == (uint32_t)Control::KeyUp);
	TS_STATIC_ASSERT(TS_ControlKeyDown == (uint32_t)Control::KeyDown);
	TS_STATIC_ASSERT(TS_ControlKeyLeft == (uint32_t)Control::KeyLeft);
	TS_STATIC_ASSERT(TS_ControlKeyRight == (uint32_t)Control::KeyRight);
	TS_STATIC_ASSERT(TS_ControlKeyShift == (uint32_t)Control::KeyShift);
	TS_STATIC_ASSERT(TS_ControlKeyCtrl == (uint32_t)Control::KeyCtrl);
	TS_STATIC_ASSERT(TS_ControlKeyAlt == (uint32_t)Control::KeyAlt);
	TS_STATIC_ASSERT(TS_ControlKeyCmd == (uint32_t)Control::KeyCmd);
	TS_STATIC_ASSERT(TS_ControlKeyNumKeys == (uint32_t)Control::NumKeys);
	
	// Tellusim::ControlEdit::EditMode
	TS_STATIC_ASSERT(TS_ControlEditEditModeText == (uint32_t)ControlEdit::EditModeText);
	TS_STATIC_ASSERT(TS_ControlEditEditModePassword == (uint32_t)ControlEdit::EditModePassword);
	TS_STATIC_ASSERT(TS_ControlEditEditModeNumber == (uint32_t)ControlEdit::EditModeNumber);
	TS_STATIC_ASSERT(TS_ControlEditEditModeSigned == (uint32_t)ControlEdit::EditModeSigned);
	TS_STATIC_ASSERT(TS_ControlEditEditModeUnsigned == (uint32_t)ControlEdit::EditModeUnsigned);
	TS_STATIC_ASSERT(TS_ControlEditEditModeHexadecimal == (uint32_t)ControlEdit::EditModeHexadecimal);
	
	// Tellusim::DialogMessage::Flags
	TS_STATIC_ASSERT(TS_DialogMessageFlagNone == (uint32_t)DialogMessage::FlagNone);
	TS_STATIC_ASSERT(TS_DialogMessageFlagYes == (uint32_t)DialogMessage::FlagYes);
	TS_STATIC_ASSERT(TS_DialogMessageFlagNo == (uint32_t)DialogMessage::FlagNo);
	TS_STATIC_ASSERT(TS_DialogMessageFlagOk == (uint32_t)DialogMessage::FlagOk);
	TS_STATIC_ASSERT(TS_DialogMessageFlagCancel == (uint32_t)DialogMessage::FlagCancel);
	TS_STATIC_ASSERT(TS_DialogMessageFlagClose == (uint32_t)DialogMessage::FlagClose);
	TS_STATIC_ASSERT(TS_DialogMessageFlagMessage == (uint32_t)DialogMessage::FlagMessage);
	TS_STATIC_ASSERT(TS_DialogMessageFlagWarning == (uint32_t)DialogMessage::FlagWarning);
	TS_STATIC_ASSERT(TS_DialogMessageFlagQuestion == (uint32_t)DialogMessage::FlagQuestion);
	TS_STATIC_ASSERT(TS_DialogMessageFlagError == (uint32_t)DialogMessage::FlagError);
	TS_STATIC_ASSERT(TS_DialogMessageFlagMouse == (uint32_t)DialogMessage::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogMessageFlagYesNo == (uint32_t)DialogMessage::FlagYesNo);
	TS_STATIC_ASSERT(TS_DialogMessageFlagOkCancel == (uint32_t)DialogMessage::FlagOkCancel);
	TS_STATIC_ASSERT(TS_DialogMessageDefaultFlags == (uint32_t)DialogMessage::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogMessageNumFlags == (uint32_t)DialogMessage::NumFlags);
	
	// Tellusim::DialogMessage::Result
	TS_STATIC_ASSERT(TS_DialogMessageResultClose == (uint32_t)DialogMessage::ResultClose);
	TS_STATIC_ASSERT(TS_DialogMessageResultCancel == (uint32_t)DialogMessage::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogMessageResultOk == (uint32_t)DialogMessage::ResultOk);
	TS_STATIC_ASSERT(TS_DialogMessageResultNo == (uint32_t)DialogMessage::ResultNo);
	TS_STATIC_ASSERT(TS_DialogMessageResultYes == (uint32_t)DialogMessage::ResultYes);
	TS_STATIC_ASSERT(TS_DialogMessageResultNumResults == (uint32_t)DialogMessage::NumResults);
	
	// Tellusim::DialogFileOpen::Flags
	TS_STATIC_ASSERT(TS_DialogFileOpenFlagNone == (uint32_t)DialogFileOpen::FlagNone);
	TS_STATIC_ASSERT(TS_DialogFileOpenFlagHidden == (uint32_t)DialogFileOpen::FlagHidden);
	TS_STATIC_ASSERT(TS_DialogFileOpenFlagMouse == (uint32_t)DialogFileOpen::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogFileOpenDefaultFlags == (uint32_t)DialogFileOpen::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogFileOpenNumFlags == (uint32_t)DialogFileOpen::NumFlags);
	
	// Tellusim::DialogFileOpen::Result
	TS_STATIC_ASSERT(TS_DialogFileOpenResultCancel == (uint32_t)DialogFileOpen::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogFileOpenResultOk == (uint32_t)DialogFileOpen::ResultOk);
	TS_STATIC_ASSERT(TS_DialogFileOpenResultNumResults == (uint32_t)DialogFileOpen::NumResults);
	
	// Tellusim::DialogFileSave::Flags
	TS_STATIC_ASSERT(TS_DialogFileSaveFlagNone == (uint32_t)DialogFileSave::FlagNone);
	TS_STATIC_ASSERT(TS_DialogFileSaveFlagHidden == (uint32_t)DialogFileSave::FlagHidden);
	TS_STATIC_ASSERT(TS_DialogFileSaveFlagOverwrite == (uint32_t)DialogFileSave::FlagOverwrite);
	TS_STATIC_ASSERT(TS_DialogFileSaveFlagMouse == (uint32_t)DialogFileSave::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogFileSaveDefaultFlags == (uint32_t)DialogFileSave::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogFileSaveNumFlags == (uint32_t)DialogFileSave::NumFlags);
	
	// Tellusim::DialogFileSave::Result
	TS_STATIC_ASSERT(TS_DialogFileSaveResultCancel == (uint32_t)DialogFileSave::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogFileSaveResultOk == (uint32_t)DialogFileSave::ResultOk);
	TS_STATIC_ASSERT(TS_DialogFileSaveResultNumResults == (uint32_t)DialogFileSave::NumResults);
	
	// Tellusim::DialogDirectory::Flags
	TS_STATIC_ASSERT(TS_DialogDirectoryFlagNone == (uint32_t)DialogDirectory::FlagNone);
	TS_STATIC_ASSERT(TS_DialogDirectoryFlagMouse == (uint32_t)DialogDirectory::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogDirectoryDefaultFlags == (uint32_t)DialogDirectory::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogDirectoryNumFlags == (uint32_t)DialogDirectory::NumFlags);
	
	// Tellusim::DialogDirectory::Result
	TS_STATIC_ASSERT(TS_DialogDirectoryResultCancel == (uint32_t)DialogDirectory::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogDirectoryResultOk == (uint32_t)DialogDirectory::ResultOk);
	TS_STATIC_ASSERT(TS_DialogDirectoryResultNumResults == (uint32_t)DialogDirectory::NumResults);
	
	// Tellusim::DialogProgress::Flags
	TS_STATIC_ASSERT(TS_DialogProgressFlagNone == (uint32_t)DialogProgress::FlagNone);
	TS_STATIC_ASSERT(TS_DialogProgressFlagMouse == (uint32_t)DialogProgress::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogProgressDefaultFlags == (uint32_t)DialogProgress::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogProgressNumFlags == (uint32_t)DialogProgress::NumFlags);
	
	// Tellusim::DialogProgress::Result
	TS_STATIC_ASSERT(TS_DialogProgressResultCancel == (uint32_t)DialogProgress::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogProgressResultOk == (uint32_t)DialogProgress::ResultOk);
	TS_STATIC_ASSERT(TS_DialogProgressResultNumResults == (uint32_t)DialogProgress::NumResults);
	
	// Tellusim::DialogColor::Flags
	TS_STATIC_ASSERT(TS_DialogColorFlagNone == (uint32_t)DialogColor::FlagNone);
	TS_STATIC_ASSERT(TS_DialogColorFlagAlpha == (uint32_t)DialogColor::FlagAlpha);
	TS_STATIC_ASSERT(TS_DialogColorFlagMouse == (uint32_t)DialogColor::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogColorDefaultFlags == (uint32_t)DialogColor::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogColorNumFlags == (uint32_t)DialogColor::NumFlags);
	
	// Tellusim::DialogColor::Result
	TS_STATIC_ASSERT(TS_DialogColorResultCancel == (uint32_t)DialogColor::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogColorResultOk == (uint32_t)DialogColor::ResultOk);
	TS_STATIC_ASSERT(TS_DialogColorResultNumResults == (uint32_t)DialogColor::NumResults);
	
	// Tellusim::DialogMenu::Flags
	TS_STATIC_ASSERT(TS_DialogMenuFlagNone == (uint32_t)DialogMenu::FlagNone);
	TS_STATIC_ASSERT(TS_DialogMenuFlagMouse == (uint32_t)DialogMenu::FlagMouse);
	TS_STATIC_ASSERT(TS_DialogMenuDefaultFlags == (uint32_t)DialogMenu::DefaultFlags);
	TS_STATIC_ASSERT(TS_DialogMenuNumFlags == (uint32_t)DialogMenu::NumFlags);
	
	// Tellusim::DialogMenu::Result
	TS_STATIC_ASSERT(TS_DialogMenuResultCancel == (uint32_t)DialogMenu::ResultCancel);
	TS_STATIC_ASSERT(TS_DialogMenuResultClick == (uint32_t)DialogMenu::ResultClick);
	TS_STATIC_ASSERT(TS_DialogMenuResultNumResults == (uint32_t)DialogMenu::NumResults);
	
	// Tellusim::CubeFilter::Mode
	TS_STATIC_ASSERT(TS_CubeFilterModeCube == (uint32_t)CubeFilter::ModeCube);
	TS_STATIC_ASSERT(TS_CubeFilterModePanorama == (uint32_t)CubeFilter::ModePanorama);
	TS_STATIC_ASSERT(TS_CubeFilterModeNumModes == (uint32_t)CubeFilter::NumModes);
	
	// Tellusim::CubeFilter::Flags
	TS_STATIC_ASSERT(TS_CubeFilterFlagCube == (uint32_t)CubeFilter::FlagCube);
	TS_STATIC_ASSERT(TS_CubeFilterFlagPanorama == (uint32_t)CubeFilter::FlagPanorama);
	TS_STATIC_ASSERT(TS_CubeFilterAll == (uint32_t)CubeFilter::FlagsAll);
	
	// Tellusim::DecoderJPEG::Mode
	TS_STATIC_ASSERT(TS_DecoderJPEGModeR == (uint32_t)DecoderJPEG::ModeR);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeRG == (uint32_t)DecoderJPEG::ModeRG);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeRGBA == (uint32_t)DecoderJPEG::ModeRGBA);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeYUV444 == (uint32_t)DecoderJPEG::ModeYUV444);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeYUV422H == (uint32_t)DecoderJPEG::ModeYUV422H);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeYUV422V == (uint32_t)DecoderJPEG::ModeYUV422V);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeYUV420 == (uint32_t)DecoderJPEG::ModeYUV420);
	TS_STATIC_ASSERT(TS_DecoderJPEGModeNumModes == (uint32_t)DecoderJPEG::NumModes);
	
	// Tellusim::DecoderJPEG::Flags
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagNone == (uint32_t)DecoderJPEG::FlagNone);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagR == (uint32_t)DecoderJPEG::FlagR);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagRG == (uint32_t)DecoderJPEG::FlagRG);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagRGBA == (uint32_t)DecoderJPEG::FlagRGBA);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagYUV444 == (uint32_t)DecoderJPEG::FlagYUV444);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagYUV422H == (uint32_t)DecoderJPEG::FlagYUV422H);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagYUV422V == (uint32_t)DecoderJPEG::FlagYUV422V);
	TS_STATIC_ASSERT(TS_DecoderJPEGFlagYUV420 == (uint32_t)DecoderJPEG::FlagYUV420);
	TS_STATIC_ASSERT(TS_DecoderJPEGAll == (uint32_t)DecoderJPEG::FlagsAll);
	
	// Tellusim::EncoderBC15::Mode
	TS_STATIC_ASSERT(TS_EncoderBC15ModeBC1RGBu8n == (uint32_t)EncoderBC15::ModeBC1RGBu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15ModeBC2RGBAu8n == (uint32_t)EncoderBC15::ModeBC2RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15ModeBC3RGBAu8n == (uint32_t)EncoderBC15::ModeBC3RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15ModeBC4Ru8n == (uint32_t)EncoderBC15::ModeBC4Ru8n);
	TS_STATIC_ASSERT(TS_EncoderBC15ModeBC5RGu8n == (uint32_t)EncoderBC15::ModeBC5RGu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15ModeNumModes == (uint32_t)EncoderBC15::NumModes);
	
	// Tellusim::EncoderBC15::Flags
	TS_STATIC_ASSERT(TS_EncoderBC15FlagNone == (uint32_t)EncoderBC15::FlagNone);
	TS_STATIC_ASSERT(TS_EncoderBC15FlagBC1RGBu8n == (uint32_t)EncoderBC15::FlagBC1RGBu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15FlagBC2RGBAu8n == (uint32_t)EncoderBC15::FlagBC2RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15FlagBC3RGBAu8n == (uint32_t)EncoderBC15::FlagBC3RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15FlagBC4Ru8n == (uint32_t)EncoderBC15::FlagBC4Ru8n);
	TS_STATIC_ASSERT(TS_EncoderBC15FlagBC5RGu8n == (uint32_t)EncoderBC15::FlagBC5RGu8n);
	TS_STATIC_ASSERT(TS_EncoderBC15FlagCube == (uint32_t)EncoderBC15::FlagCube);
	TS_STATIC_ASSERT(TS_EncoderBC15BC13 == (uint32_t)EncoderBC15::FlagsBC13);
	TS_STATIC_ASSERT(TS_EncoderBC15BC45 == (uint32_t)EncoderBC15::FlagsBC45);
	TS_STATIC_ASSERT(TS_EncoderBC15All == (uint32_t)EncoderBC15::FlagsAll);
	
	// Tellusim::EncoderBC67::Mode
	TS_STATIC_ASSERT(TS_EncoderBC67ModeBC6RGBf16s == (uint32_t)EncoderBC67::ModeBC6RGBf16s);
	TS_STATIC_ASSERT(TS_EncoderBC67ModeBC6RGBf16u == (uint32_t)EncoderBC67::ModeBC6RGBf16u);
	TS_STATIC_ASSERT(TS_EncoderBC67ModeBC7RGBAu8n == (uint32_t)EncoderBC67::ModeBC7RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderBC67ModeNumModes == (uint32_t)EncoderBC67::NumModes);
	
	// Tellusim::EncoderBC67::Flags
	TS_STATIC_ASSERT(TS_EncoderBC67FlagNone == (uint32_t)EncoderBC67::FlagNone);
	TS_STATIC_ASSERT(TS_EncoderBC67FlagBC6RGBf16s == (uint32_t)EncoderBC67::FlagBC6RGBf16s);
	TS_STATIC_ASSERT(TS_EncoderBC67FlagBC6RGBf16u == (uint32_t)EncoderBC67::FlagBC6RGBf16u);
	TS_STATIC_ASSERT(TS_EncoderBC67FlagBC7RGBAu8n == (uint32_t)EncoderBC67::FlagBC7RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderBC67FlagCube == (uint32_t)EncoderBC67::FlagCube);
	TS_STATIC_ASSERT(TS_EncoderBC67All == (uint32_t)EncoderBC67::FlagsAll);
	
	// Tellusim::EncoderASTC::Mode
	TS_STATIC_ASSERT(TS_EncoderASTCModeASTC44RGBAu8n == (uint32_t)EncoderASTC::ModeASTC44RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderASTCModeASTC54RGBAu8n == (uint32_t)EncoderASTC::ModeASTC54RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderASTCModeASTC55RGBAu8n == (uint32_t)EncoderASTC::ModeASTC55RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderASTCModeNumModes == (uint32_t)EncoderASTC::NumModes);
	
	// Tellusim::EncoderASTC::Flags
	TS_STATIC_ASSERT(TS_EncoderASTCFlagNone == (uint32_t)EncoderASTC::FlagNone);
	TS_STATIC_ASSERT(TS_EncoderASTCFlagASTC44RGBAu8n == (uint32_t)EncoderASTC::FlagASTC44RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderASTCFlagASTC54RGBAu8n == (uint32_t)EncoderASTC::FlagASTC54RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderASTCFlagASTC55RGBAu8n == (uint32_t)EncoderASTC::FlagASTC55RGBAu8n);
	TS_STATIC_ASSERT(TS_EncoderASTCFlagCube == (uint32_t)EncoderASTC::FlagCube);
	TS_STATIC_ASSERT(TS_EncoderASTCAll == (uint32_t)EncoderASTC::FlagsAll);
	
	// Tellusim::MeshModel::Flags
	TS_STATIC_ASSERT(TS_MeshModelFlagNone == (uint32_t)MeshModel::FlagNone);
	TS_STATIC_ASSERT(TS_MeshModelFlagDirect == (uint32_t)MeshModel::FlagDirect);
	TS_STATIC_ASSERT(TS_MeshModelFlagVerbose == (uint32_t)MeshModel::FlagVerbose);
	TS_STATIC_ASSERT(TS_MeshModelFlagOptimize == (uint32_t)MeshModel::FlagOptimize);
	TS_STATIC_ASSERT(TS_MeshModelFlagMaterials == (uint32_t)MeshModel::FlagMaterials);
	TS_STATIC_ASSERT(TS_MeshModelFlagIndices10 == (uint32_t)MeshModel::FlagIndices10);
	TS_STATIC_ASSERT(TS_MeshModelFlagIndices16 == (uint32_t)MeshModel::FlagIndices16);
	TS_STATIC_ASSERT(TS_MeshModelFlagIndices32 == (uint32_t)MeshModel::FlagIndices32);
	TS_STATIC_ASSERT(TS_MeshModelFlagMeshlet64x84 == (uint32_t)MeshModel::FlagMeshlet64x84);
	TS_STATIC_ASSERT(TS_MeshModelFlagMeshlet64x126 == (uint32_t)MeshModel::FlagMeshlet64x126);
	TS_STATIC_ASSERT(TS_MeshModelFlagMeshlet96x169 == (uint32_t)MeshModel::FlagMeshlet96x169);
	TS_STATIC_ASSERT(TS_MeshModelFlagMeshlet128x212 == (uint32_t)MeshModel::FlagMeshlet128x212);
	TS_STATIC_ASSERT(TS_MeshModelFlagBufferWrite == (uint32_t)MeshModel::FlagBufferWrite);
	TS_STATIC_ASSERT(TS_MeshModelFlagBufferSource == (uint32_t)MeshModel::FlagBufferSource);
	TS_STATIC_ASSERT(TS_MeshModelFlagBufferStorage == (uint32_t)MeshModel::FlagBufferStorage);
	TS_STATIC_ASSERT(TS_MeshModelFlagBufferTracing == (uint32_t)MeshModel::FlagBufferTracing);
	TS_STATIC_ASSERT(TS_MeshModelFlagBufferAddress == (uint32_t)MeshModel::FlagBufferAddress);
	TS_STATIC_ASSERT(TS_MeshModelFlagBufferTexel == (uint32_t)MeshModel::FlagBufferTexel);
	TS_STATIC_ASSERT(TS_MeshModelFlagMeshlets == (uint32_t)MeshModel::FlagMeshlets);
	TS_STATIC_ASSERT(TS_MeshModelDefaultFlags == (uint32_t)MeshModel::DefaultFlags);
	TS_STATIC_ASSERT(TS_MeshModelNumFlags == (uint32_t)MeshModel::NumFlags);
	
	// Tellusim::SeparableFilter::Mode
	TS_STATIC_ASSERT(TS_SeparableFilterModeHorizontal == (uint32_t)SeparableFilter::ModeHorizontal);
	TS_STATIC_ASSERT(TS_SeparableFilterModeVertical == (uint32_t)SeparableFilter::ModeVertical);
	TS_STATIC_ASSERT(TS_SeparableFilterModeNumModes == (uint32_t)SeparableFilter::NumModes);
	
	// Tellusim::SeparableFilter::Flags
	TS_STATIC_ASSERT(TS_SeparableFilterFlagNone == (uint32_t)SeparableFilter::FlagNone);
	TS_STATIC_ASSERT(TS_SeparableFilterFlagRepeat == (uint32_t)SeparableFilter::FlagRepeat);
	TS_STATIC_ASSERT(TS_SeparableFilterFlagZero == (uint32_t)SeparableFilter::FlagZero);
	TS_STATIC_ASSERT(TS_SeparableFilterDefaultFlags == (uint32_t)SeparableFilter::DefaultFlags);
	
	// Tellusim::PrefixScan::Mode
	TS_STATIC_ASSERT(TS_PrefixScanModeSingle == (uint32_t)PrefixScan::ModeSingle);
	TS_STATIC_ASSERT(TS_PrefixScanModeMultiple == (uint32_t)PrefixScan::ModeMultiple);
	TS_STATIC_ASSERT(TS_PrefixScanModeNumModes == (uint32_t)PrefixScan::NumModes);
	
	// Tellusim::PrefixScan::Flags
	TS_STATIC_ASSERT(TS_PrefixScanFlagNone == (uint32_t)PrefixScan::FlagNone);
	TS_STATIC_ASSERT(TS_PrefixScanFlagSingle == (uint32_t)PrefixScan::FlagSingle);
	TS_STATIC_ASSERT(TS_PrefixScanFlagMultiple == (uint32_t)PrefixScan::FlagMultiple);
	TS_STATIC_ASSERT(TS_PrefixScanFlagIndirect == (uint32_t)PrefixScan::FlagIndirect);
	TS_STATIC_ASSERT(TS_PrefixScanFlagRepeat == (uint32_t)PrefixScan::FlagRepeat);
	TS_STATIC_ASSERT(TS_PrefixScanAll == (uint32_t)PrefixScan::FlagsAll);
	
	// Tellusim::RadixSort::Mode
	TS_STATIC_ASSERT(TS_RadixSortModeSingle == (uint32_t)RadixSort::ModeSingle);
	TS_STATIC_ASSERT(TS_RadixSortModeMultiple == (uint32_t)RadixSort::ModeMultiple);
	TS_STATIC_ASSERT(TS_RadixSortModeNumModes == (uint32_t)RadixSort::NumModes);
	
	// Tellusim::RadixSort::Flags
	TS_STATIC_ASSERT(TS_RadixSortFlagNone == (uint32_t)RadixSort::FlagNone);
	TS_STATIC_ASSERT(TS_RadixSortFlagSingle == (uint32_t)RadixSort::FlagSingle);
	TS_STATIC_ASSERT(TS_RadixSortFlagMultiple == (uint32_t)RadixSort::FlagMultiple);
	TS_STATIC_ASSERT(TS_RadixSortFlagIndirect == (uint32_t)RadixSort::FlagIndirect);
	TS_STATIC_ASSERT(TS_RadixSortFlagOrder == (uint32_t)RadixSort::FlagOrder);
	TS_STATIC_ASSERT(TS_RadixSortFlagTracing == (uint32_t)RadixSort::FlagTracing);
	TS_STATIC_ASSERT(TS_RadixSortFlagScratch == (uint32_t)RadixSort::FlagScratch);
	TS_STATIC_ASSERT(TS_RadixSortAll == (uint32_t)RadixSort::FlagsAll);
	
	// Tellusim::BitonicSort::Mode
	TS_STATIC_ASSERT(TS_BitonicSortModeSingle == (uint32_t)BitonicSort::ModeSingle);
	TS_STATIC_ASSERT(TS_BitonicSortModeMultiple == (uint32_t)BitonicSort::ModeMultiple);
	TS_STATIC_ASSERT(TS_BitonicSortModeNumModes == (uint32_t)BitonicSort::NumModes);
	
	// Tellusim::BitonicSort::Flags
	TS_STATIC_ASSERT(TS_BitonicSortFlagNone == (uint32_t)BitonicSort::FlagNone);
	TS_STATIC_ASSERT(TS_BitonicSortFlagSingle == (uint32_t)BitonicSort::FlagSingle);
	TS_STATIC_ASSERT(TS_BitonicSortFlagMultiple == (uint32_t)BitonicSort::FlagMultiple);
	TS_STATIC_ASSERT(TS_BitonicSortFlagIndirect == (uint32_t)BitonicSort::FlagIndirect);
	TS_STATIC_ASSERT(TS_BitonicSortFlagOrder == (uint32_t)BitonicSort::FlagOrder);
	TS_STATIC_ASSERT(TS_BitonicSortAll == (uint32_t)BitonicSort::FlagsAll);
	
	// Tellusim::SpatialTree::Mode
	TS_STATIC_ASSERT(TS_SpatialTreeModeSingle == (uint32_t)SpatialTree::ModeSingle);
	TS_STATIC_ASSERT(TS_SpatialTreeModeMultiple == (uint32_t)SpatialTree::ModeMultiple);
	TS_STATIC_ASSERT(TS_SpatialTreeModeNumModes == (uint32_t)SpatialTree::NumModes);
	
	// Tellusim::SpatialTree::Hash
	TS_STATIC_ASSERT(TS_SpatialTreeHashXYZ10 == (uint32_t)SpatialTree::HashXYZ10);
	TS_STATIC_ASSERT(TS_SpatialTreeHashXYZ9 == (uint32_t)SpatialTree::HashXYZ9);
	TS_STATIC_ASSERT(TS_SpatialTreeHashXYZ8 == (uint32_t)SpatialTree::HashXYZ8);
	TS_STATIC_ASSERT(TS_SpatialTreeHashXY15 == (uint32_t)SpatialTree::HashXY15);
	TS_STATIC_ASSERT(TS_SpatialTreeHashXY14 == (uint32_t)SpatialTree::HashXY14);
	TS_STATIC_ASSERT(TS_SpatialTreeHashXY12 == (uint32_t)SpatialTree::HashXY12);
	TS_STATIC_ASSERT(TS_SpatialTreeHashXY10 == (uint32_t)SpatialTree::HashXY10);
	
	// Tellusim::SpatialTree::Flags
	TS_STATIC_ASSERT(TS_SpatialTreeFlagNone == (uint32_t)SpatialTree::FlagNone);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagSingle == (uint32_t)SpatialTree::FlagSingle);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagMultiple == (uint32_t)SpatialTree::FlagMultiple);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagUpdate == (uint32_t)SpatialTree::FlagUpdate);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagOptimize == (uint32_t)SpatialTree::FlagOptimize);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagTracing == (uint32_t)SpatialTree::FlagTracing);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagScratch == (uint32_t)SpatialTree::FlagScratch);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagAtomic == (uint32_t)SpatialTree::FlagAtomic);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagLeafNodef16 == (uint32_t)SpatialTree::FlagLeafNodef16);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagSpatialData == (uint32_t)SpatialTree::FlagSpatialData);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagSingleUpdate == (uint32_t)SpatialTree::FlagSingleUpdate);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagMultipleUpdate == (uint32_t)SpatialTree::FlagMultipleUpdate);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagSingleOptimize == (uint32_t)SpatialTree::FlagSingleOptimize);
	TS_STATIC_ASSERT(TS_SpatialTreeFlagMultipleOptimize == (uint32_t)SpatialTree::FlagMultipleOptimize);
	TS_STATIC_ASSERT(TS_SpatialTreeAll == (uint32_t)SpatialTree::FlagsAll);
	TS_STATIC_ASSERT(TS_SpatialTreeAllOptimize == (uint32_t)SpatialTree::FlagsAllOptimize);
	
	// Tellusim::FourierTransform::Mode
	TS_STATIC_ASSERT(TS_FourierTransformModeRf16i == (uint32_t)FourierTransform::ModeRf16i);
	TS_STATIC_ASSERT(TS_FourierTransformModeRf32i == (uint32_t)FourierTransform::ModeRf32i);
	TS_STATIC_ASSERT(TS_FourierTransformModeRGf16i == (uint32_t)FourierTransform::ModeRGf16i);
	TS_STATIC_ASSERT(TS_FourierTransformModeRGf32i == (uint32_t)FourierTransform::ModeRGf32i);
	TS_STATIC_ASSERT(TS_FourierTransformModeRGBf16c == (uint32_t)FourierTransform::ModeRGBf16c);
	TS_STATIC_ASSERT(TS_FourierTransformModeRGBf21c == (uint32_t)FourierTransform::ModeRGBf21c);
	TS_STATIC_ASSERT(TS_FourierTransformModeRGBf16p == (uint32_t)FourierTransform::ModeRGBf16p);
	TS_STATIC_ASSERT(TS_FourierTransformModeRGBf32p == (uint32_t)FourierTransform::ModeRGBf32p);
	TS_STATIC_ASSERT(TS_FourierTransformModeNumModes == (uint32_t)FourierTransform::NumModes);
	
	// Tellusim::FourierTransform::Flags
	TS_STATIC_ASSERT(TS_FourierTransformFlagNone == (uint32_t)FourierTransform::FlagNone);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRf16i == (uint32_t)FourierTransform::FlagRf16i);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRf32i == (uint32_t)FourierTransform::FlagRf32i);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRGf16i == (uint32_t)FourierTransform::FlagRGf16i);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRGf32i == (uint32_t)FourierTransform::FlagRGf32i);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRGBf16c == (uint32_t)FourierTransform::FlagRGBf16c);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRGBf21c == (uint32_t)FourierTransform::FlagRGBf21c);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRGBf16p == (uint32_t)FourierTransform::FlagRGBf16p);
	TS_STATIC_ASSERT(TS_FourierTransformFlagRGBf32p == (uint32_t)FourierTransform::FlagRGBf32p);
	TS_STATIC_ASSERT(TS_FourierTransformFlagNpot == (uint32_t)FourierTransform::FlagNpot);
	TS_STATIC_ASSERT(TS_FourierTransformInterleaved == (uint32_t)FourierTransform::FlagsInterleaved);
	TS_STATIC_ASSERT(TS_FourierTransformComplex == (uint32_t)FourierTransform::FlagsComplex);
	TS_STATIC_ASSERT(TS_FourierTransformPlanar == (uint32_t)FourierTransform::FlagsPlanar);
	TS_STATIC_ASSERT(TS_FourierTransformAll == (uint32_t)FourierTransform::FlagsAll);
	
	// Tellusim::FourierTransform::Operation
	TS_STATIC_ASSERT(TS_FourierTransformOperationForwardCtoC == (uint32_t)FourierTransform::ForwardCtoC);
	TS_STATIC_ASSERT(TS_FourierTransformOperationBackwardCtoC == (uint32_t)FourierTransform::BackwardCtoC);
	TS_STATIC_ASSERT(TS_FourierTransformOperationForwardRtoC == (uint32_t)FourierTransform::ForwardRtoC);
	TS_STATIC_ASSERT(TS_FourierTransformOperationBackwardCtoR == (uint32_t)FourierTransform::BackwardCtoR);
	TS_STATIC_ASSERT(TS_FourierTransformOperationNumOperations == (uint32_t)FourierTransform::NumOperations);
	
	// Tellusim::TensorGraph::Operation
	TS_STATIC_ASSERT(TS_TensorGraphOperationClear == (uint32_t)TensorGraph::Clear);
	TS_STATIC_ASSERT(TS_TensorGraphOperationRange == (uint32_t)TensorGraph::Range);
	TS_STATIC_ASSERT(TS_TensorGraphOperationCopy == (uint32_t)TensorGraph::Copy);
	TS_STATIC_ASSERT(TS_TensorGraphOperationCat == (uint32_t)TensorGraph::Cat);
	TS_STATIC_ASSERT(TS_TensorGraphOperationTranspose == (uint32_t)TensorGraph::Transpose);
	TS_STATIC_ASSERT(TS_TensorGraphOperationMatMul == (uint32_t)TensorGraph::MatMul);
	TS_STATIC_ASSERT(TS_TensorGraphOperationMul == (uint32_t)TensorGraph::Mul);
	TS_STATIC_ASSERT(TS_TensorGraphOperationMad == (uint32_t)TensorGraph::Mad);
	TS_STATIC_ASSERT(TS_TensorGraphOperationDiv == (uint32_t)TensorGraph::Div);
	TS_STATIC_ASSERT(TS_TensorGraphOperationAdd == (uint32_t)TensorGraph::Add);
	TS_STATIC_ASSERT(TS_TensorGraphOperationConv == (uint32_t)TensorGraph::Conv);
	TS_STATIC_ASSERT(TS_TensorGraphOperationDeConv == (uint32_t)TensorGraph::DeConv);
	TS_STATIC_ASSERT(TS_TensorGraphOperationBatchNorm == (uint32_t)TensorGraph::BatchNorm);
	TS_STATIC_ASSERT(TS_TensorGraphOperationBatchMad == (uint32_t)TensorGraph::BatchMad);
	TS_STATIC_ASSERT(TS_TensorGraphOperationSoftMin == (uint32_t)TensorGraph::SoftMin);
	TS_STATIC_ASSERT(TS_TensorGraphOperationSoftMax == (uint32_t)TensorGraph::SoftMax);
	TS_STATIC_ASSERT(TS_TensorGraphOperationMaxPool == (uint32_t)TensorGraph::MaxPool);
	TS_STATIC_ASSERT(TS_TensorGraphOperationAvgPool == (uint32_t)TensorGraph::AvgPool);
	TS_STATIC_ASSERT(TS_TensorGraphOperationGELU == (uint32_t)TensorGraph::GELU);
	TS_STATIC_ASSERT(TS_TensorGraphOperationReLU == (uint32_t)TensorGraph::ReLU);
	TS_STATIC_ASSERT(TS_TensorGraphOperationSiLU == (uint32_t)TensorGraph::SiLU);
	TS_STATIC_ASSERT(TS_TensorGraphOperationSigm == (uint32_t)TensorGraph::Sigm);
	TS_STATIC_ASSERT(TS_TensorGraphOperationTanh == (uint32_t)TensorGraph::Tanh);
	TS_STATIC_ASSERT(TS_TensorGraphOperationSin == (uint32_t)TensorGraph::Sin);
	TS_STATIC_ASSERT(TS_TensorGraphOperationCos == (uint32_t)TensorGraph::Cos);
	TS_STATIC_ASSERT(TS_TensorGraphOperationExp == (uint32_t)TensorGraph::Exp);
	TS_STATIC_ASSERT(TS_TensorGraphOperationNumOperations == (uint32_t)TensorGraph::NumOperations);
	
	// Tellusim::TensorGraph::Flags
	TS_STATIC_ASSERT(TS_TensorGraphFlagNone == (uint32_t)TensorGraph::FlagNone);
	TS_STATIC_ASSERT(TS_TensorGraphFlagSizeQuery == (uint32_t)TensorGraph::FlagSizeQuery);
	TS_STATIC_ASSERT(TS_TensorGraphFlagFormatRf32 == (uint32_t)TensorGraph::FlagFormatRf32);
	TS_STATIC_ASSERT(TS_TensorGraphFlagFormatRf16 == (uint32_t)TensorGraph::FlagFormatRf16);
	TS_STATIC_ASSERT(TS_TensorGraphFlagTranspose == (uint32_t)TensorGraph::FlagTranspose);
	TS_STATIC_ASSERT(TS_TensorGraphFlagWrapClamp == (uint32_t)TensorGraph::FlagWrapClamp);
	TS_STATIC_ASSERT(TS_TensorGraphFlagWrapRepeat == (uint32_t)TensorGraph::FlagWrapRepeat);
	TS_STATIC_ASSERT(TS_TensorGraphFlagReadScale == (uint32_t)TensorGraph::FlagReadScale);
	TS_STATIC_ASSERT(TS_TensorGraphFlagReadBias == (uint32_t)TensorGraph::FlagReadBias);
	TS_STATIC_ASSERT(TS_TensorGraphFlagConvert == (uint32_t)TensorGraph::FlagConvert);
	TS_STATIC_ASSERT(TS_TensorGraphFlagKernel == (uint32_t)TensorGraph::FlagKernel);
	TS_STATIC_ASSERT(TS_TensorGraphFlagGELU == (uint32_t)TensorGraph::FlagGELU);
	TS_STATIC_ASSERT(TS_TensorGraphFlagReLU == (uint32_t)TensorGraph::FlagReLU);
	TS_STATIC_ASSERT(TS_TensorGraphFlagSiLU == (uint32_t)TensorGraph::FlagSiLU);
	TS_STATIC_ASSERT(TS_TensorGraphFlagSigm == (uint32_t)TensorGraph::FlagSigm);
	TS_STATIC_ASSERT(TS_TensorGraphFlagTanh == (uint32_t)TensorGraph::FlagTanh);
	TS_STATIC_ASSERT(TS_TensorGraphFlagSin == (uint32_t)TensorGraph::FlagSin);
	TS_STATIC_ASSERT(TS_TensorGraphFlagCos == (uint32_t)TensorGraph::FlagCos);
	TS_STATIC_ASSERT(TS_TensorGraphFlagExp == (uint32_t)TensorGraph::FlagExp);
	TS_STATIC_ASSERT(TS_TensorGraphFlagFormat == (uint32_t)TensorGraph::FlagFormat);
	TS_STATIC_ASSERT(TS_TensorGraphFlagWrap == (uint32_t)TensorGraph::FlagWrap);
	TS_STATIC_ASSERT(TS_TensorGraphFlagRead == (uint32_t)TensorGraph::FlagRead);
	TS_STATIC_ASSERT(TS_TensorGraphFlagUnit == (uint32_t)TensorGraph::FlagUnit);
	TS_STATIC_ASSERT(TS_TensorGraphFlagMath == (uint32_t)TensorGraph::FlagMath);
	TS_STATIC_ASSERT(TS_TensorGraphAll == (uint32_t)TensorGraph::FlagsAll);
	
	// Tellusim::TensorGraph::Masks
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskNone == (uint32_t)TensorGraph::MaskNone);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskClear == (uint32_t)TensorGraph::MaskClear);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskRange == (uint32_t)TensorGraph::MaskRange);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskCopy == (uint32_t)TensorGraph::MaskCopy);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskCat == (uint32_t)TensorGraph::MaskCat);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskTranspose == (uint32_t)TensorGraph::MaskTranspose);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskMatMul == (uint32_t)TensorGraph::MaskMatMul);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskMul == (uint32_t)TensorGraph::MaskMul);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskMad == (uint32_t)TensorGraph::MaskMad);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskDiv == (uint32_t)TensorGraph::MaskDiv);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskAdd == (uint32_t)TensorGraph::MaskAdd);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskConv == (uint32_t)TensorGraph::MaskConv);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskDeConv == (uint32_t)TensorGraph::MaskDeConv);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskBatchNorm == (uint32_t)TensorGraph::MaskBatchNorm);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskBatchMad == (uint32_t)TensorGraph::MaskBatchMad);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskSoftMin == (uint32_t)TensorGraph::MaskSoftMin);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskSoftMax == (uint32_t)TensorGraph::MaskSoftMax);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskMaxPool == (uint32_t)TensorGraph::MaskMaxPool);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskAvgPool == (uint32_t)TensorGraph::MaskAvgPool);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskGELU == (uint32_t)TensorGraph::MaskGELU);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskReLU == (uint32_t)TensorGraph::MaskReLU);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskSiLU == (uint32_t)TensorGraph::MaskSiLU);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskSigm == (uint32_t)TensorGraph::MaskSigm);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskTanh == (uint32_t)TensorGraph::MaskTanh);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskSin == (uint32_t)TensorGraph::MaskSin);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskCos == (uint32_t)TensorGraph::MaskCos);
	TS_STATIC_ASSERT(TS_TensorGraphMasksMaskExp == (uint32_t)TensorGraph::MaskExp);
	TS_STATIC_ASSERT(TS_TensorGraphMasksAll == (uint32_t)TensorGraph::MasksAll);
	
	// Tellusim::Controller::Type
	TS_STATIC_ASSERT(TS_ControllerTypeUnknown == (uint32_t)Controller::TypeUnknown);
	TS_STATIC_ASSERT(TS_ControllerTypeJoystick == (uint32_t)Controller::TypeJoystick);
	TS_STATIC_ASSERT(TS_ControllerTypeGamePad == (uint32_t)Controller::TypeGamePad);
	TS_STATIC_ASSERT(TS_ControllerTypeWheel == (uint32_t)Controller::TypeWheel);
	TS_STATIC_ASSERT(TS_ControllerTypeNumTypes == (uint32_t)Controller::NumTypes);
	
	// Tellusim::Controller::Stick
	TS_STATIC_ASSERT(TS_ControllerStickLeft == (uint32_t)Controller::StickLeft);
	TS_STATIC_ASSERT(TS_ControllerStickRight == (uint32_t)Controller::StickRight);
	TS_STATIC_ASSERT(TS_ControllerStickNumSticks == (uint32_t)Controller::NumSticks);
	
	// Tellusim::Controller::Axis
	TS_STATIC_ASSERT(TS_ControllerAxisX == (uint32_t)Controller::AxisX);
	TS_STATIC_ASSERT(TS_ControllerAxisY == (uint32_t)Controller::AxisY);
	TS_STATIC_ASSERT(TS_ControllerAxisZ == (uint32_t)Controller::AxisZ);
	TS_STATIC_ASSERT(TS_ControllerAxisRX == (uint32_t)Controller::AxisRX);
	TS_STATIC_ASSERT(TS_ControllerAxisRY == (uint32_t)Controller::AxisRY);
	TS_STATIC_ASSERT(TS_ControllerAxisRZ == (uint32_t)Controller::AxisRZ);
	TS_STATIC_ASSERT(TS_ControllerAxisNumAxes == (uint32_t)Controller::NumAxes);
	
	// Tellusim::Controller::Button
	TS_STATIC_ASSERT(TS_ControllerButtonLeft == (uint32_t)Controller::ButtonLeft);
	TS_STATIC_ASSERT(TS_ControllerButtonRight == (uint32_t)Controller::ButtonRight);
	TS_STATIC_ASSERT(TS_ControllerButtonDown == (uint32_t)Controller::ButtonDown);
	TS_STATIC_ASSERT(TS_ControllerButtonUp == (uint32_t)Controller::ButtonUp);
	TS_STATIC_ASSERT(TS_ControllerButtonHome == (uint32_t)Controller::ButtonHome);
	TS_STATIC_ASSERT(TS_ControllerButtonShoulderLeft == (uint32_t)Controller::ButtonShoulderLeft);
	TS_STATIC_ASSERT(TS_ControllerButtonShoulderRight == (uint32_t)Controller::ButtonShoulderRight);
	TS_STATIC_ASSERT(TS_ControllerButtonTriggerLeft == (uint32_t)Controller::ButtonTriggerLeft);
	TS_STATIC_ASSERT(TS_ControllerButtonTriggerRight == (uint32_t)Controller::ButtonTriggerRight);
	TS_STATIC_ASSERT(TS_ControllerButtonStickLeft == (uint32_t)Controller::ButtonStickLeft);
	TS_STATIC_ASSERT(TS_ControllerButtonStickRight == (uint32_t)Controller::ButtonStickRight);
	TS_STATIC_ASSERT(TS_ControllerButtonA == (uint32_t)Controller::ButtonA);
	TS_STATIC_ASSERT(TS_ControllerButtonB == (uint32_t)Controller::ButtonB);
	TS_STATIC_ASSERT(TS_ControllerButtonX == (uint32_t)Controller::ButtonX);
	TS_STATIC_ASSERT(TS_ControllerButtonY == (uint32_t)Controller::ButtonY);
	TS_STATIC_ASSERT(TS_ControllerButtonView == (uint32_t)Controller::ButtonView);
	TS_STATIC_ASSERT(TS_ControllerButtonMenu == (uint32_t)Controller::ButtonMenu);
	TS_STATIC_ASSERT(TS_ControllerButtonL1 == (uint32_t)Controller::ButtonL1);
	TS_STATIC_ASSERT(TS_ControllerButtonR1 == (uint32_t)Controller::ButtonR1);
	TS_STATIC_ASSERT(TS_ControllerButtonL2 == (uint32_t)Controller::ButtonL2);
	TS_STATIC_ASSERT(TS_ControllerButtonR2 == (uint32_t)Controller::ButtonR2);
	TS_STATIC_ASSERT(TS_ControllerButtonL3 == (uint32_t)Controller::ButtonL3);
	TS_STATIC_ASSERT(TS_ControllerButtonR3 == (uint32_t)Controller::ButtonR3);
	TS_STATIC_ASSERT(TS_ControllerButtonCross == (uint32_t)Controller::ButtonCross);
	TS_STATIC_ASSERT(TS_ControllerButtonCircle == (uint32_t)Controller::ButtonCircle);
	TS_STATIC_ASSERT(TS_ControllerButtonSquare == (uint32_t)Controller::ButtonSquare);
	TS_STATIC_ASSERT(TS_ControllerButtonTriangle == (uint32_t)Controller::ButtonTriangle);
	TS_STATIC_ASSERT(TS_ControllerButtonShare == (uint32_t)Controller::ButtonShare);
	TS_STATIC_ASSERT(TS_ControllerButtonOptions == (uint32_t)Controller::ButtonOptions);
	TS_STATIC_ASSERT(TS_ControllerButtonNumButtons == (uint32_t)Controller::NumButtons);
	
	// Tellusim::Controller::Motor
	TS_STATIC_ASSERT(TS_ControllerMotorLow == (uint32_t)Controller::MotorLow);
	TS_STATIC_ASSERT(TS_ControllerMotorHigh == (uint32_t)Controller::MotorHigh);
	TS_STATIC_ASSERT(TS_ControllerMotorNumMotors == (uint32_t)Controller::NumMotors);
	
	// Tellusim::Log::Level
	TS_STATIC_ASSERT(TS_LogLevelFatal == (uint32_t)Log::Fatal);
	TS_STATIC_ASSERT(TS_LogLevelError == (uint32_t)Log::Error);
	TS_STATIC_ASSERT(TS_LogLevelWarning == (uint32_t)Log::Warning);
	TS_STATIC_ASSERT(TS_LogLevelMessage == (uint32_t)Log::Message);
	TS_STATIC_ASSERT(TS_LogLevelVerbose == (uint32_t)Log::Verbose);
	TS_STATIC_ASSERT(TS_LogLevelUnknown == (uint32_t)Log::Unknown);
	TS_STATIC_ASSERT(TS_LogLevelNumLevels == (uint32_t)Log::NumLevels);
	
	// Tellusim::Time::
	TS_STATIC_ASSERT(TS_TimeSeconds == (uint32_t)Time::Seconds);
	TS_STATIC_ASSERT(TS_TimeMSeconds == (uint32_t)Time::MSeconds);
	TS_STATIC_ASSERT(TS_TimeUSeconds == (uint32_t)Time::USeconds);
	
	// Tellusim::Command
	TS_STATIC_ASSERT(sizeof(TSCommandDrawArraysIndirect) == sizeof(Command::DrawArraysIndirect));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawArraysIndirect, num_vertices) == offsetof(Command::DrawArraysIndirect, num_vertices));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawArraysIndirect, num_instances) == offsetof(Command::DrawArraysIndirect, num_instances));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawArraysIndirect, base_vertex) == offsetof(Command::DrawArraysIndirect, base_vertex));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawArraysIndirect, base_instance) == offsetof(Command::DrawArraysIndirect, base_instance));
	TS_STATIC_ASSERT(sizeof(TSCommandDrawElementsIndirect) == sizeof(Command::DrawElementsIndirect));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawElementsIndirect, num_indices) == offsetof(Command::DrawElementsIndirect, num_indices));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawElementsIndirect, num_instances) == offsetof(Command::DrawElementsIndirect, num_instances));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawElementsIndirect, base_index) == offsetof(Command::DrawElementsIndirect, base_index));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawElementsIndirect, base_vertex) == offsetof(Command::DrawElementsIndirect, base_vertex));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawElementsIndirect, base_instance) == offsetof(Command::DrawElementsIndirect, base_instance));
	TS_STATIC_ASSERT(sizeof(TSCommandDrawMeshIndirect) == sizeof(Command::DrawMeshIndirect));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawMeshIndirect, group_width) == offsetof(Command::DrawMeshIndirect, group_width));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawMeshIndirect, group_height) == offsetof(Command::DrawMeshIndirect, group_height));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawMeshIndirect, group_depth) == offsetof(Command::DrawMeshIndirect, group_depth));
	TS_STATIC_ASSERT(offsetof(TSCommandDrawMeshIndirect, padding) == offsetof(Command::DrawMeshIndirect, padding));
	
	// Tellusim::Compute
	TS_STATIC_ASSERT(sizeof(TSComputeDispatchIndirect) == sizeof(Compute::DispatchIndirect));
	TS_STATIC_ASSERT(offsetof(TSComputeDispatchIndirect, group_width) == offsetof(Compute::DispatchIndirect, group_width));
	TS_STATIC_ASSERT(offsetof(TSComputeDispatchIndirect, group_height) == offsetof(Compute::DispatchIndirect, group_height));
	TS_STATIC_ASSERT(offsetof(TSComputeDispatchIndirect, group_depth) == offsetof(Compute::DispatchIndirect, group_depth));
	TS_STATIC_ASSERT(offsetof(TSComputeDispatchIndirect, padding) == offsetof(Compute::DispatchIndirect, padding));
	
	// Tellusim::Query
	TS_STATIC_ASSERT(sizeof(TSQueryStatistics) == sizeof(Query::Statistics));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, num_vertices) == offsetof(Query::Statistics, num_vertices));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, num_primitives) == offsetof(Query::Statistics, num_primitives));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, vertex_invocations) == offsetof(Query::Statistics, vertex_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, control_invocations) == offsetof(Query::Statistics, control_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, evaluate_invocations) == offsetof(Query::Statistics, evaluate_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, geometry_invocations) == offsetof(Query::Statistics, geometry_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, geometry_primitives) == offsetof(Query::Statistics, geometry_primitives));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, fragment_invocations) == offsetof(Query::Statistics, fragment_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, compute_invocations) == offsetof(Query::Statistics, compute_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, clipping_invocations) == offsetof(Query::Statistics, clipping_invocations));
	TS_STATIC_ASSERT(offsetof(TSQueryStatistics, clipping_primitives) == offsetof(Query::Statistics, clipping_primitives));
	
	// Tellusim::Tracing
	TS_STATIC_ASSERT(sizeof(TSTracingInstance) == sizeof(Tracing::Instance));
	TS_STATIC_ASSERT(offsetof(TSTracingInstance, transform) == offsetof(Tracing::Instance, transform));
	TS_STATIC_ASSERT(offsetof(TSTracingInstance, data) == offsetof(Tracing::Instance, data));
	TS_STATIC_ASSERT(offsetof(TSTracingInstance, mask) == offsetof(Tracing::Instance, mask));
	TS_STATIC_ASSERT(offsetof(TSTracingInstance, flags) == offsetof(Tracing::Instance, flags));
	TS_STATIC_ASSERT(offsetof(TSTracingInstance, offset) == offsetof(Tracing::Instance, offset));
	TS_STATIC_ASSERT(offsetof(TSTracingInstance, tracing) == offsetof(Tracing::Instance, tracing));
	TS_STATIC_ASSERT(sizeof(TSTracingBuildIndirect) == sizeof(Tracing::BuildIndirect));
	TS_STATIC_ASSERT(offsetof(TSTracingBuildIndirect, num_primitives) == offsetof(Tracing::BuildIndirect, num_primitives));
	TS_STATIC_ASSERT(offsetof(TSTracingBuildIndirect, base_primitive) == offsetof(Tracing::BuildIndirect, base_primitive));
	TS_STATIC_ASSERT(offsetof(TSTracingBuildIndirect, base_vertex) == offsetof(Tracing::BuildIndirect, base_vertex));
	TS_STATIC_ASSERT(offsetof(TSTracingBuildIndirect, base_transform) == offsetof(Tracing::BuildIndirect, base_transform));
	
	// Tellusim::Device
	TS_STATIC_ASSERT(sizeof(TSDeviceFeatures) == sizeof(Device::Features));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, threadAccess) == offsetof(Device::Features, threadAccess));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, sparseBuffer) == offsetof(Device::Features, sparseBuffer));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, bufferTable) == offsetof(Device::Features, bufferTable));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, sparseTexture) == offsetof(Device::Features, sparseTexture));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, sparseArrayTexture) == offsetof(Device::Features, sparseArrayTexture));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, cubeArrayTexture) == offsetof(Device::Features, cubeArrayTexture));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, textureTable) == offsetof(Device::Features, textureTable));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, baseInstanceIndex) == offsetof(Device::Features, baseInstanceIndex));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, drawIndirectIndex) == offsetof(Device::Features, drawIndirectIndex));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, drawIndirectCount) == offsetof(Device::Features, drawIndirectCount));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, taskIndirectCount) == offsetof(Device::Features, taskIndirectCount));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, vertexStorage) == offsetof(Device::Features, vertexStorage));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, vertexIndexLayer) == offsetof(Device::Features, vertexIndexLayer));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, geometryPassthrough) == offsetof(Device::Features, geometryPassthrough));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, fragmentBarycentric) == offsetof(Device::Features, fragmentBarycentric));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, fragmentStencilExport) == offsetof(Device::Features, fragmentStencilExport));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, dualSourceBlending) == offsetof(Device::Features, dualSourceBlending));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, depthRangeOneToOne) == offsetof(Device::Features, depthRangeOneToOne));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, conservativeRaster) == offsetof(Device::Features, conservativeRaster));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, conditionalRendering) == offsetof(Device::Features, conditionalRendering));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, rayTracing) == offsetof(Device::Features, rayTracing));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, computeTracing) == offsetof(Device::Features, computeTracing));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, fragmentTracing) == offsetof(Device::Features, fragmentTracing));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, indirectTracing) == offsetof(Device::Features, indirectTracing));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, recursionDepth) == offsetof(Device::Features, recursionDepth));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, subgroupVote) == offsetof(Device::Features, subgroupVote));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, subgroupMath) == offsetof(Device::Features, subgroupMath));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, subgroupShuffle) == offsetof(Device::Features, subgroupShuffle));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, subgroupSize) == offsetof(Device::Features, subgroupSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, minSubgroupSize) == offsetof(Device::Features, minSubgroupSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxSubgroupSize) == offsetof(Device::Features, maxSubgroupSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, shaderu8) == offsetof(Device::Features, shaderu8));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, shaderf16) == offsetof(Device::Features, shaderf16));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, shaderu16) == offsetof(Device::Features, shaderu16));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, shaderf64) == offsetof(Device::Features, shaderf64));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, shaderu64) == offsetof(Device::Features, shaderu64));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicGroupf32) == offsetof(Device::Features, atomicGroupf32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicGroupu64) == offsetof(Device::Features, atomicGroupu64));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicBufferf32) == offsetof(Device::Features, atomicBufferf32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicBufferu64) == offsetof(Device::Features, atomicBufferu64));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicTexturef32) == offsetof(Device::Features, atomicTexturef32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicTextureu32) == offsetof(Device::Features, atomicTextureu32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, atomicTextureu64) == offsetof(Device::Features, atomicTextureu64));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, matrix16f16) == offsetof(Device::Features, matrix16f16));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, matrix16x8x8f16) == offsetof(Device::Features, matrix16x8x8f16));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, matrix16x8x16f16) == offsetof(Device::Features, matrix16x8x16f16));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, matrix16f16f32) == offsetof(Device::Features, matrix16f16f32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, matrix16x8x8f16f32) == offsetof(Device::Features, matrix16x8x8f16f32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, matrix16x8x16f16f32) == offsetof(Device::Features, matrix16x8x16f16f32));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, uniformAlignment) == offsetof(Device::Features, uniformAlignment));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, storageAlignment) == offsetof(Device::Features, storageAlignment));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTextureSamples) == offsetof(Device::Features, maxTextureSamples));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTexture2DSize) == offsetof(Device::Features, maxTexture2DSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTexture3DSize) == offsetof(Device::Features, maxTexture3DSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTextureLayers) == offsetof(Device::Features, maxTextureLayers));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxGroupSizeX) == offsetof(Device::Features, maxGroupSizeX));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxGroupSizeY) == offsetof(Device::Features, maxGroupSizeY));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxGroupSizeZ) == offsetof(Device::Features, maxGroupSizeZ));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxGroupCountX) == offsetof(Device::Features, maxGroupCountX));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxGroupCountY) == offsetof(Device::Features, maxGroupCountY));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxGroupCountZ) == offsetof(Device::Features, maxGroupCountZ));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTaskCount) == offsetof(Device::Features, maxTaskCount));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTaskMemory) == offsetof(Device::Features, maxTaskMemory));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxTaskMeshes) == offsetof(Device::Features, maxTaskMeshes));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxMeshMemory) == offsetof(Device::Features, maxMeshMemory));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxMeshVertices) == offsetof(Device::Features, maxMeshVertices));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxMeshPrimitives) == offsetof(Device::Features, maxMeshPrimitives));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxViewportCount) == offsetof(Device::Features, maxViewportCount));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxClipCullCount) == offsetof(Device::Features, maxClipCullCount));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxUniformSize) == offsetof(Device::Features, maxUniformSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, maxStorageSize) == offsetof(Device::Features, maxStorageSize));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, groupMemory) == offsetof(Device::Features, groupMemory));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, videoMemory) == offsetof(Device::Features, videoMemory));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, vendorID) == offsetof(Device::Features, vendorID));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, deviceID) == offsetof(Device::Features, deviceID));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, pciBusID) == offsetof(Device::Features, pciBusID));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, pciDomainID) == offsetof(Device::Features, pciDomainID));
	TS_STATIC_ASSERT(offsetof(TSDeviceFeatures, pciDeviceID) == offsetof(Device::Features, pciDeviceID));
	
	// Tellusim::MeshModel
	TS_STATIC_ASSERT(sizeof(TSMeshModelMeshlet) == sizeof(MeshModel::Meshlet));
	TS_STATIC_ASSERT(offsetof(TSMeshModelMeshlet, num_primitives) == offsetof(MeshModel::Meshlet, num_primitives));
	TS_STATIC_ASSERT(offsetof(TSMeshModelMeshlet, num_vertices) == offsetof(MeshModel::Meshlet, num_vertices));
	TS_STATIC_ASSERT(offsetof(TSMeshModelMeshlet, base_index) == offsetof(MeshModel::Meshlet, base_index));
	TS_STATIC_ASSERT(offsetof(TSMeshModelMeshlet, base_vertex) == offsetof(MeshModel::Meshlet, base_vertex));
	TS_STATIC_ASSERT(offsetof(TSMeshModelMeshlet, bound_sphere) == offsetof(MeshModel::Meshlet, bound_sphere));
	TS_STATIC_ASSERT(offsetof(TSMeshModelMeshlet, normal_angle) == offsetof(MeshModel::Meshlet, normal_angle));
	
	// Tellusim::PrefixScan
	TS_STATIC_ASSERT(sizeof(TSPrefixScanDispatchParameters) == sizeof(PrefixScan::DispatchParameters));
	TS_STATIC_ASSERT(offsetof(TSPrefixScanDispatchParameters, offset) == offsetof(PrefixScan::DispatchParameters, offset));
	TS_STATIC_ASSERT(offsetof(TSPrefixScanDispatchParameters, size) == offsetof(PrefixScan::DispatchParameters, size));
	TS_STATIC_ASSERT(offsetof(TSPrefixScanDispatchParameters, padding_0) == offsetof(PrefixScan::DispatchParameters, padding_0));
	TS_STATIC_ASSERT(offsetof(TSPrefixScanDispatchParameters, padding_1) == offsetof(PrefixScan::DispatchParameters, padding_1));
	
	// Tellusim::RadixSort
	TS_STATIC_ASSERT(sizeof(TSRadixSortDispatchParameters) == sizeof(RadixSort::DispatchParameters));
	TS_STATIC_ASSERT(offsetof(TSRadixSortDispatchParameters, keys_offset) == offsetof(RadixSort::DispatchParameters, keys_offset));
	TS_STATIC_ASSERT(offsetof(TSRadixSortDispatchParameters, data_offset) == offsetof(RadixSort::DispatchParameters, data_offset));
	TS_STATIC_ASSERT(offsetof(TSRadixSortDispatchParameters, size) == offsetof(RadixSort::DispatchParameters, size));
	TS_STATIC_ASSERT(offsetof(TSRadixSortDispatchParameters, padding) == offsetof(RadixSort::DispatchParameters, padding));
	
	// Tellusim::BitonicSort
	TS_STATIC_ASSERT(sizeof(TSBitonicSortDispatchParameters) == sizeof(BitonicSort::DispatchParameters));
	TS_STATIC_ASSERT(offsetof(TSBitonicSortDispatchParameters, keys_offset) == offsetof(BitonicSort::DispatchParameters, keys_offset));
	TS_STATIC_ASSERT(offsetof(TSBitonicSortDispatchParameters, data_offset) == offsetof(BitonicSort::DispatchParameters, data_offset));
	TS_STATIC_ASSERT(offsetof(TSBitonicSortDispatchParameters, size) == offsetof(BitonicSort::DispatchParameters, size));
	TS_STATIC_ASSERT(offsetof(TSBitonicSortDispatchParameters, padding) == offsetof(BitonicSort::DispatchParameters, padding));
	
	// Tellusim::SpatialGrid
	TS_STATIC_ASSERT(sizeof(TSSpatialGridDispatchParameters) == sizeof(SpatialGrid::DispatchParameters));
	TS_STATIC_ASSERT(offsetof(TSSpatialGridDispatchParameters, offset) == offsetof(SpatialGrid::DispatchParameters, offset));
	TS_STATIC_ASSERT(offsetof(TSSpatialGridDispatchParameters, size) == offsetof(SpatialGrid::DispatchParameters, size));
	TS_STATIC_ASSERT(offsetof(TSSpatialGridDispatchParameters, padding_0) == offsetof(SpatialGrid::DispatchParameters, padding_0));
	TS_STATIC_ASSERT(offsetof(TSSpatialGridDispatchParameters, padding_1) == offsetof(SpatialGrid::DispatchParameters, padding_1));
	
	// Tellusim::SpatialTree
	TS_STATIC_ASSERT(sizeof(TSSpatialTreeNode) == sizeof(SpatialTree::Node));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, bound_min) == offsetof(SpatialTree::Node, bound_min));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, is_enabled) == offsetof(SpatialTree::Node, is_enabled));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, bound_max) == offsetof(SpatialTree::Node, bound_max));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, data) == offsetof(SpatialTree::Node, data));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, left) == offsetof(SpatialTree::Node, left));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, right) == offsetof(SpatialTree::Node, right));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, parent) == offsetof(SpatialTree::Node, parent));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeNode, spatial) == offsetof(SpatialTree::Node, spatial));
	TS_STATIC_ASSERT(sizeof(TSSpatialTreeLeafNodef16) == sizeof(SpatialTree::LeafNodef16));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, center) == offsetof(SpatialTree::LeafNodef16, center));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, data) == offsetof(SpatialTree::LeafNodef16, data));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, size) == offsetof(SpatialTree::LeafNodef16, size));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, is_enabled) == offsetof(SpatialTree::LeafNodef16, is_enabled));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, data_1) == offsetof(SpatialTree::LeafNodef16, data_1));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, data_2) == offsetof(SpatialTree::LeafNodef16, data_2));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, left) == offsetof(SpatialTree::LeafNodef16, left));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, right) == offsetof(SpatialTree::LeafNodef16, right));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, parent) == offsetof(SpatialTree::LeafNodef16, parent));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeLeafNodef16, spatial) == offsetof(SpatialTree::LeafNodef16, spatial));
	TS_STATIC_ASSERT(sizeof(TSSpatialTreeDispatchParameters) == sizeof(SpatialTree::DispatchParameters));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeDispatchParameters, offset) == offsetof(SpatialTree::DispatchParameters, offset));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeDispatchParameters, size) == offsetof(SpatialTree::DispatchParameters, size));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeDispatchParameters, padding_0) == offsetof(SpatialTree::DispatchParameters, padding_0));
	TS_STATIC_ASSERT(offsetof(TSSpatialTreeDispatchParameters, padding_1) == offsetof(SpatialTree::DispatchParameters, padding_1));
	
	// Tellusim::Window
	static void TSWindowMousePressedCallback_func(Tellusim::Window::Button button, TSWindowMousePressedCallback func, void *data_) {
		func((TS_WindowButton)button, data_);
	}
	static Tellusim::Window::MousePressedCallback makeTSWindowMousePressedCallback(TSWindowMousePressedCallback func, void *data) {
		auto ret = makeFunction(TSWindowMousePressedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSWindowMouseReleasedCallback_func(Tellusim::Window::Button button, TSWindowMouseReleasedCallback func, void *data_) {
		func((TS_WindowButton)button, data_);
	}
	static Tellusim::Window::MouseReleasedCallback makeTSWindowMouseReleasedCallback(TSWindowMouseReleasedCallback func, void *data) {
		auto ret = makeFunction(TSWindowMouseReleasedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSWindowMouseChangedCallback_func(int32_t x, int32_t y, TSWindowMouseChangedCallback func, void *data_) {
		func(x, y, data_);
	}
	static Tellusim::Window::MouseChangedCallback makeTSWindowMouseChangedCallback(TSWindowMouseChangedCallback func, void *data) {
		auto ret = makeFunction(TSWindowMouseChangedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSWindowMouseRotatedCallback_func(Tellusim::Window::Axis axis, float32_t delta, TSWindowMouseRotatedCallback func, void *data_) {
		func((TS_WindowAxis)axis, delta, data_);
	}
	static Tellusim::Window::MouseRotatedCallback makeTSWindowMouseRotatedCallback(TSWindowMouseRotatedCallback func, void *data) {
		auto ret = makeFunction(TSWindowMouseRotatedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSWindowTouchChangedCallback_func(TSWindowTouchChangedCallback func, void *data_) {
		func(data_);
	}
	static Tellusim::Window::TouchChangedCallback makeTSWindowTouchChangedCallback(TSWindowTouchChangedCallback func, void *data) {
		auto ret = makeFunction(TSWindowTouchChangedCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	static void TSWindowKeyboardPressedCallback_func(uint32_t key, uint32_t code, TSWindowKeyboardPressedCallback func, void *data_) {
		func(key, code, data_);
	}
	static Tellusim::Window::KeyboardPressedCallback makeTSWindowKeyboardPressedCallback(TSWindowKeyboardPressedCallback func, void *data) {
		auto ret = makeFunction(TSWindowKeyboardPressedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSWindowKeyboardReleasedCallback_func(uint32_t key, TSWindowKeyboardReleasedCallback func, void *data_) {
		func(key, data_);
	}
	static Tellusim::Window::KeyboardReleasedCallback makeTSWindowKeyboardReleasedCallback(TSWindowKeyboardReleasedCallback func, void *data) {
		auto ret = makeFunction(TSWindowKeyboardReleasedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSWindowSizeChangedCallback_func(uint32_t width, uint32_t height, TSWindowSizeChangedCallback func, void *data_) {
		func(width, height, data_);
	}
	static Tellusim::Window::SizeChangedCallback makeTSWindowSizeChangedCallback(TSWindowSizeChangedCallback func, void *data) {
		auto ret = makeFunction(TSWindowSizeChangedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSWindowFocusChangedCallback_func(bool changed, TSWindowFocusChangedCallback func, void *data_) {
		func(changed, data_);
	}
	static Tellusim::Window::FocusChangedCallback makeTSWindowFocusChangedCallback(TSWindowFocusChangedCallback func, void *data) {
		auto ret = makeFunction(TSWindowFocusChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSWindowCloseClickedCallback_func(TSWindowCloseClickedCallback func, void *data_) {
		func(data_);
	}
	static Tellusim::Window::CloseClickedCallback makeTSWindowCloseClickedCallback(TSWindowCloseClickedCallback func, void *data) {
		auto ret = makeFunction(TSWindowCloseClickedCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	static void TSWindowPauseChangedCallback_func(bool paused, TSWindowPauseChangedCallback func, void *data_) {
		func(paused, data_);
	}
	static Tellusim::Window::PauseChangedCallback makeTSWindowPauseChangedCallback(TSWindowPauseChangedCallback func, void *data) {
		auto ret = makeFunction(TSWindowPauseChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSWindowFileDroppedCallback_func(const char *name, uint32_t remain, TSWindowFileDroppedCallback func, void *data_) {
		func(name, remain, data_);
	}
	static Tellusim::Window::FileDroppedCallback makeTSWindowFileDroppedCallback(TSWindowFileDroppedCallback func, void *data) {
		auto ret = makeFunction(TSWindowFileDroppedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSWindowUpdateCallback_func(TSWindowUpdateCallback func, void *data_) {
		func(data_);
	}
	static Tellusim::Window::UpdateCallback makeTSWindowUpdateCallback(TSWindowUpdateCallback func, void *data) {
		auto ret = makeFunction(TSWindowUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	static void TSWindowPresentCallback_func(TSWindowPresentCallback func, void *data_) {
		func(data_);
	}
	static Tellusim::Window::PresentCallback makeTSWindowPresentCallback(TSWindowPresentCallback func, void *data) {
		auto ret = makeFunction(TSWindowPresentCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	static bool TSWindowMainLoopCallback_func(TSWindowMainLoopCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::Window::MainLoopCallback makeTSWindowMainLoopCallback(TSWindowMainLoopCallback func, void *data) {
		auto ret = makeFunction(TSWindowMainLoopCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::CanvasElement
	static bool TSCanvasElementDrawCallback_func(Tellusim::Command command, Tellusim::CanvasElement element, TSCanvasElementDrawCallback func, void *data_) {
		return (bool)func((TSCommand)&command, (TSCanvasElement)&element, data_);
	}
	static Tellusim::CanvasElement::DrawCallback makeTSCanvasElementDrawCallback(TSCanvasElementDrawCallback func, void *data) {
		auto ret = makeFunction(TSCanvasElementDrawCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	
	// Tellusim::Canvas
	static bool TSCanvasCreateCallback_func(const Tellusim::Device device, Tellusim::Canvas canvas, uint32_t scale, TSCanvasCreateCallback func, void *data_) {
		return (bool)func((const TSDevice)&device, (TSCanvas)&canvas, scale, data_);
	}
	static Tellusim::Canvas::CreateCallback makeTSCanvasCreateCallback(TSCanvasCreateCallback func, void *data) {
		auto ret = makeFunction(TSCanvasCreateCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static bool TSCanvasPipelineCallback_func(Tellusim::Pipeline pipeline, Tellusim::Canvas canvas, Tellusim::CanvasElement element, TSCanvasPipelineCallback func, void *data_) {
		return (bool)func((TSPipeline)&pipeline, (TSCanvas)&canvas, (TSCanvasElement)&element, data_);
	}
	static Tellusim::Canvas::PipelineCallback makeTSCanvasPipelineCallback(TSCanvasPipelineCallback func, void *data) {
		auto ret = makeFunction(TSCanvasPipelineCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static bool TSCanvasBeginCallback_func(Tellusim::Command command, Tellusim::Canvas canvas, TSCanvasBeginCallback func, void *data_) {
		return (bool)func((TSCommand)&command, (TSCanvas)&canvas, data_);
	}
	static Tellusim::Canvas::BeginCallback makeTSCanvasBeginCallback(TSCanvasBeginCallback func, void *data) {
		auto ret = makeFunction(TSCanvasBeginCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static bool TSCanvasDrawCallback_func(Tellusim::Command command, Tellusim::Canvas canvas, TSCanvasDrawCallback func, void *data_) {
		return (bool)func((TSCommand)&command, (TSCanvas)&canvas, data_);
	}
	static Tellusim::Canvas::DrawCallback makeTSCanvasDrawCallback(TSCanvasDrawCallback func, void *data) {
		auto ret = makeFunction(TSCanvasDrawCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	
	// Tellusim::ControlRoot
	static void TSControlRootCopyCallback_func(Tellusim::ControlRoot a0, const char *text, TSControlRootCopyCallback func, void *data_) {
		func((TSControlRoot)&a0, text, data_);
	}
	static Tellusim::ControlRoot::CopyCallback makeTSControlRootCopyCallback(TSControlRootCopyCallback func, void *data) {
		auto ret = makeFunction(TSControlRootCopyCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static Tellusim::String TSControlRootPasteCallback_func(Tellusim::ControlRoot a0, TSControlRootPasteCallback func, void *data_) {
		return *(String*)func((TSControlRoot)&a0, data_);
	}
	static Tellusim::ControlRoot::PasteCallback makeTSControlRootPasteCallback(TSControlRootPasteCallback func, void *data) {
		auto ret = makeFunction(TSControlRootPasteCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlRect
	static bool TSControlRectInsideCallback_func(Tellusim::ControlRect a0, float32_t x, float32_t y, TSControlRectInsideCallback func, void *data_) {
		return (bool)func((TSControlRect)&a0, x, y, data_);
	}
	static Tellusim::ControlRect::InsideCallback makeTSControlRectInsideCallback(TSControlRectInsideCallback func, void *data) {
		auto ret = makeFunction(TSControlRectInsideCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static void TSControlRectPressedCallback_func(Tellusim::ControlRect a0, float32_t x, float32_t y, TSControlRectPressedCallback func, void *data_) {
		func((TSControlRect)&a0, x, y, data_);
	}
	static Tellusim::ControlRect::PressedCallback makeTSControlRectPressedCallback(TSControlRectPressedCallback func, void *data) {
		auto ret = makeFunction(TSControlRectPressedCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static void TSControlRectReleasedCallback_func(Tellusim::ControlRect a0, float32_t x, float32_t y, TSControlRectReleasedCallback func, void *data_) {
		func((TSControlRect)&a0, x, y, data_);
	}
	static Tellusim::ControlRect::ReleasedCallback makeTSControlRectReleasedCallback(TSControlRectReleasedCallback func, void *data) {
		auto ret = makeFunction(TSControlRectReleasedCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static void TSControlRectClickedCallback_func(Tellusim::ControlRect a0, TSControlRectClickedCallback func, void *data_) {
		func((TSControlRect)&a0, data_);
	}
	static Tellusim::ControlRect::ClickedCallback makeTSControlRectClickedCallback(TSControlRectClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlRectClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlGroup
	static void TSControlGroupClickedCallback_func(Tellusim::ControlGroup a0, TSControlGroupClickedCallback func, void *data_) {
		func((TSControlGroup)&a0, data_);
	}
	static Tellusim::ControlGroup::ClickedCallback makeTSControlGroupClickedCallback(TSControlGroupClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlGroupClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlDialog
	static void TSControlDialogUpdatedCallback_func(Tellusim::ControlDialog a0, TSControlDialogUpdatedCallback func, void *data_) {
		func((TSControlDialog)&a0, data_);
	}
	static Tellusim::ControlDialog::UpdatedCallback makeTSControlDialogUpdatedCallback(TSControlDialogUpdatedCallback func, void *data) {
		auto ret = makeFunction(TSControlDialogUpdatedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlCheck
	static void TSControlCheckClickedCallback_func(Tellusim::ControlCheck a0, TSControlCheckClickedCallback func, void *data_) {
		func((TSControlCheck)&a0, data_);
	}
	static Tellusim::ControlCheck::ClickedCallback makeTSControlCheckClickedCallback(TSControlCheckClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlCheckClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlCombo
	static void TSControlComboClickedCallback_func(Tellusim::ControlCombo a0, TSControlComboClickedCallback func, void *data_) {
		func((TSControlCombo)&a0, data_);
	}
	static Tellusim::ControlCombo::ClickedCallback makeTSControlComboClickedCallback(TSControlComboClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlComboClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlComboChangedCallback_func(Tellusim::ControlCombo a0, TSControlComboChangedCallback func, void *data_) {
		func((TSControlCombo)&a0, data_);
	}
	static Tellusim::ControlCombo::ChangedCallback makeTSControlComboChangedCallback(TSControlComboChangedCallback func, void *data) {
		auto ret = makeFunction(TSControlComboChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlButton
	static void TSControlButtonPressedCallback_func(Tellusim::ControlButton a0, float32_t x, float32_t y, TSControlButtonPressedCallback func, void *data_) {
		func((TSControlButton)&a0, x, y, data_);
	}
	static Tellusim::ControlButton::PressedCallback makeTSControlButtonPressedCallback(TSControlButtonPressedCallback func, void *data) {
		auto ret = makeFunction(TSControlButtonPressedCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static void TSControlButtonReleasedCallback_func(Tellusim::ControlButton a0, float32_t x, float32_t y, TSControlButtonReleasedCallback func, void *data_) {
		func((TSControlButton)&a0, x, y, data_);
	}
	static Tellusim::ControlButton::ReleasedCallback makeTSControlButtonReleasedCallback(TSControlButtonReleasedCallback func, void *data) {
		auto ret = makeFunction(TSControlButtonReleasedCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	static void TSControlButtonClickedCallback_func(Tellusim::ControlButton a0, TSControlButtonClickedCallback func, void *data_) {
		func((TSControlButton)&a0, data_);
	}
	static Tellusim::ControlButton::ClickedCallback makeTSControlButtonClickedCallback(TSControlButtonClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlButtonClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlSlider
	static Tellusim::String TSControlSliderFormatCallback_func(Tellusim::ControlSlider a0, TSControlSliderFormatCallback func, void *data_) {
		return *(String*)func((TSControlSlider)&a0, data_);
	}
	static Tellusim::ControlSlider::FormatCallback makeTSControlSliderFormatCallback(TSControlSliderFormatCallback func, void *data) {
		auto ret = makeFunction(TSControlSliderFormatCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlSliderPressedCallback_func(Tellusim::ControlSlider a0, TSControlSliderPressedCallback func, void *data_) {
		func((TSControlSlider)&a0, data_);
	}
	static Tellusim::ControlSlider::PressedCallback makeTSControlSliderPressedCallback(TSControlSliderPressedCallback func, void *data) {
		auto ret = makeFunction(TSControlSliderPressedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlSliderReleasedCallback_func(Tellusim::ControlSlider a0, TSControlSliderReleasedCallback func, void *data_) {
		func((TSControlSlider)&a0, data_);
	}
	static Tellusim::ControlSlider::ReleasedCallback makeTSControlSliderReleasedCallback(TSControlSliderReleasedCallback func, void *data) {
		auto ret = makeFunction(TSControlSliderReleasedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlSliderClickedCallback_func(Tellusim::ControlSlider a0, TSControlSliderClickedCallback func, void *data_) {
		func((TSControlSlider)&a0, data_);
	}
	static Tellusim::ControlSlider::ClickedCallback makeTSControlSliderClickedCallback(TSControlSliderClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlSliderClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlSliderChangedCallback_func(Tellusim::ControlSlider a0, TSControlSliderChangedCallback func, void *data_) {
		func((TSControlSlider)&a0, data_);
	}
	static Tellusim::ControlSlider::ChangedCallback makeTSControlSliderChangedCallback(TSControlSliderChangedCallback func, void *data) {
		auto ret = makeFunction(TSControlSliderChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlScroll
	static void TSControlScrollClickedCallback_func(Tellusim::ControlScroll a0, TSControlScrollClickedCallback func, void *data_) {
		func((TSControlScroll)&a0, data_);
	}
	static Tellusim::ControlScroll::ClickedCallback makeTSControlScrollClickedCallback(TSControlScrollClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlScrollClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlScrollChangedCallback_func(Tellusim::ControlScroll a0, TSControlScrollChangedCallback func, void *data_) {
		func((TSControlScroll)&a0, data_);
	}
	static Tellusim::ControlScroll::ChangedCallback makeTSControlScrollChangedCallback(TSControlScrollChangedCallback func, void *data) {
		auto ret = makeFunction(TSControlScrollChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlTree
	static void TSControlTreeChangedCallback_func(Tellusim::ControlTree a0, uint32_t item, TSControlTreeChangedCallback func, void *data_) {
		func((TSControlTree)&a0, item, data_);
	}
	static Tellusim::ControlTree::ChangedCallback makeTSControlTreeChangedCallback(TSControlTreeChangedCallback func, void *data) {
		auto ret = makeFunction(TSControlTreeChangedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static bool TSControlTreeDraggedCallback_func(Tellusim::ControlTree a0, uint32_t item, TSControlTreeDraggedCallback func, void *data_) {
		return (bool)func((TSControlTree)&a0, item, data_);
	}
	static Tellusim::ControlTree::DraggedCallback makeTSControlTreeDraggedCallback(TSControlTreeDraggedCallback func, void *data) {
		auto ret = makeFunction(TSControlTreeDraggedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSControlTreeDroppedCallback_func(Tellusim::ControlTree a0, uint32_t item, TSControlTreeDroppedCallback func, void *data_) {
		func((TSControlTree)&a0, item, data_);
	}
	static Tellusim::ControlTree::DroppedCallback makeTSControlTreeDroppedCallback(TSControlTreeDroppedCallback func, void *data) {
		auto ret = makeFunction(TSControlTreeDroppedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSControlTreeClickedCallback_func(Tellusim::ControlTree a0, uint32_t item, TSControlTreeClickedCallback func, void *data_) {
		func((TSControlTree)&a0, item, data_);
	}
	static Tellusim::ControlTree::ClickedCallback makeTSControlTreeClickedCallback(TSControlTreeClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlTreeClickedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSControlTreeExpandedCallback_func(Tellusim::ControlTree a0, uint32_t item, TSControlTreeExpandedCallback func, void *data_) {
		func((TSControlTree)&a0, item, data_);
	}
	static Tellusim::ControlTree::ExpandedCallback makeTSControlTreeExpandedCallback(TSControlTreeExpandedCallback func, void *data) {
		auto ret = makeFunction(TSControlTreeExpandedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSControlTreeSelectedCallback_func(Tellusim::ControlTree a0, TSControlTreeSelectedCallback func, void *data_) {
		func((TSControlTree)&a0, data_);
	}
	static Tellusim::ControlTree::SelectedCallback makeTSControlTreeSelectedCallback(TSControlTreeSelectedCallback func, void *data) {
		auto ret = makeFunction(TSControlTreeSelectedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::ControlEdit
	static void TSControlEditClickedCallback_func(Tellusim::ControlEdit a0, TSControlEditClickedCallback func, void *data_) {
		func((TSControlEdit)&a0, data_);
	}
	static Tellusim::ControlEdit::ClickedCallback makeTSControlEditClickedCallback(TSControlEditClickedCallback func, void *data) {
		auto ret = makeFunction(TSControlEditClickedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlEditChangedCallback_func(Tellusim::ControlEdit a0, TSControlEditChangedCallback func, void *data_) {
		func((TSControlEdit)&a0, data_);
	}
	static Tellusim::ControlEdit::ChangedCallback makeTSControlEditChangedCallback(TSControlEditChangedCallback func, void *data) {
		auto ret = makeFunction(TSControlEditChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControlEditReturnedCallback_func(Tellusim::ControlEdit a0, TSControlEditReturnedCallback func, void *data_) {
		func((TSControlEdit)&a0, data_);
	}
	static Tellusim::ControlEdit::ReturnedCallback makeTSControlEditReturnedCallback(TSControlEditReturnedCallback func, void *data) {
		auto ret = makeFunction(TSControlEditReturnedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::DialogMessage
	static bool TSDialogMessageUpdateCallback_func(TSDialogMessageUpdateCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::DialogMessage::UpdateCallback makeTSDialogMessageUpdateCallback(TSDialogMessageUpdateCallback func, void *data) {
		auto ret = makeFunction(TSDialogMessageUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::DialogFileOpen
	static bool TSDialogFileOpenUpdateCallback_func(TSDialogFileOpenUpdateCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::DialogFileOpen::UpdateCallback makeTSDialogFileOpenUpdateCallback(TSDialogFileOpenUpdateCallback func, void *data) {
		auto ret = makeFunction(TSDialogFileOpenUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::DialogFileSave
	static bool TSDialogFileSaveUpdateCallback_func(TSDialogFileSaveUpdateCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::DialogFileSave::UpdateCallback makeTSDialogFileSaveUpdateCallback(TSDialogFileSaveUpdateCallback func, void *data) {
		auto ret = makeFunction(TSDialogFileSaveUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::DialogDirectory
	static bool TSDialogDirectoryUpdateCallback_func(TSDialogDirectoryUpdateCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::DialogDirectory::UpdateCallback makeTSDialogDirectoryUpdateCallback(TSDialogDirectoryUpdateCallback func, void *data) {
		auto ret = makeFunction(TSDialogDirectoryUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::DialogColor
	static void TSDialogColorChangedCallback_func(Tellusim::Color a0, TSDialogColorChangedCallback func, void *data_) {
		func(*(TSColor*)&a0, data_);
	}
	static Tellusim::DialogColor::ChangedCallback makeTSDialogColorChangedCallback(TSDialogColorChangedCallback func, void *data) {
		auto ret = makeFunction(TSDialogColorChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static bool TSDialogColorUpdateCallback_func(TSDialogColorUpdateCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::DialogColor::UpdateCallback makeTSDialogColorUpdateCallback(TSDialogColorUpdateCallback func, void *data) {
		auto ret = makeFunction(TSDialogColorUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::DialogMenu
	static void TSDialogMenuClickedCallback_func(TSDialogMenuClickedCallback func, void *data_) {
		func(data_);
	}
	static Tellusim::DialogMenu::ClickedCallback makeTSDialogMenuClickedCallback(TSDialogMenuClickedCallback func, void *data) {
		auto ret = makeFunction(TSDialogMenuClickedCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	static void TSDialogMenuChangedCallback_func(bool a0, TSDialogMenuChangedCallback func, void *data_) {
		func(a0, data_);
	}
	static Tellusim::DialogMenu::ChangedCallback makeTSDialogMenuChangedCallback(TSDialogMenuChangedCallback func, void *data) {
		auto ret = makeFunction(TSDialogMenuChangedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static bool TSDialogMenuUpdateCallback_func(TSDialogMenuUpdateCallback func, void *data_) {
		return (bool)func(data_);
	}
	static Tellusim::DialogMenu::UpdateCallback makeTSDialogMenuUpdateCallback(TSDialogMenuUpdateCallback func, void *data) {
		auto ret = makeFunction(TSDialogMenuUpdateCallback_func);
		ret.setArg0(func);
		ret.setArg1(data);
		return ret;
	}
	
	// Tellusim::MeshModel
	static bool TSMeshModelCreateCallback_func(const void *src, size_t size, bool owner, TSMeshModelCreateCallback func, void *data_) {
		return (bool)func(src, size, owner, data_);
	}
	static Tellusim::MeshModel::CreateCallback makeTSMeshModelCreateCallback(TSMeshModelCreateCallback func, void *data) {
		auto ret = makeFunction(TSMeshModelCreateCallback_func);
		ret.setArg3(func);
		ret.setArg4(data);
		return ret;
	}
	
	// Tellusim::Controller
	static void TSControllerButtonPressedCallback_func(Tellusim::Controller controller, Tellusim::Controller::Button button, TSControllerButtonPressedCallback func, void *data_) {
		func((TSController)&controller, (TS_ControllerButton)button, data_);
	}
	static Tellusim::Controller::ButtonPressedCallback makeTSControllerButtonPressedCallback(TSControllerButtonPressedCallback func, void *data) {
		auto ret = makeFunction(TSControllerButtonPressedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSControllerButtonReleasedCallback_func(Tellusim::Controller controller, Tellusim::Controller::Button button, TSControllerButtonReleasedCallback func, void *data_) {
		func((TSController)&controller, (TS_ControllerButton)button, data_);
	}
	static Tellusim::Controller::ButtonReleasedCallback makeTSControllerButtonReleasedCallback(TSControllerButtonReleasedCallback func, void *data) {
		auto ret = makeFunction(TSControllerButtonReleasedCallback_func);
		ret.setArg2(func);
		ret.setArg3(data);
		return ret;
	}
	static void TSControllerConnectedCallback_func(Tellusim::Controller controller, TSControllerConnectedCallback func, void *data_) {
		func((TSController)&controller, data_);
	}
	static Tellusim::Controller::ConnectedCallback makeTSControllerConnectedCallback(TSControllerConnectedCallback func, void *data) {
		auto ret = makeFunction(TSControllerConnectedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	static void TSControllerDisconnectedCallback_func(Tellusim::Controller controller, TSControllerDisconnectedCallback func, void *data_) {
		func((TSController)&controller, data_);
	}
	static Tellusim::Controller::DisconnectedCallback makeTSControllerDisconnectedCallback(TSControllerDisconnectedCallback func, void *data) {
		auto ret = makeFunction(TSControllerDisconnectedCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::MeshGraph
	static bool TSMeshGraphProgressCallback_func(uint32_t progress, TSMeshGraphProgressCallback func, void *data_) {
		return (bool)func(progress, data_);
	}
	static Tellusim::MeshGraph::ProgressCallback makeTSMeshGraphProgressCallback(TSMeshGraphProgressCallback func, void *data) {
		auto ret = makeFunction(TSMeshGraphProgressCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::MeshReduce
	static bool TSMeshReduceProgressCallback_func(uint32_t progress, TSMeshReduceProgressCallback func, void *data_) {
		return (bool)func(progress, data_);
	}
	static Tellusim::MeshReduce::ProgressCallback makeTSMeshReduceProgressCallback(TSMeshReduceProgressCallback func, void *data) {
		auto ret = makeFunction(TSMeshReduceProgressCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	// Tellusim::MeshSolid
	static bool TSMeshSolidProgressCallback_func(uint32_t progress, TSMeshSolidProgressCallback func, void *data_) {
		return (bool)func(progress, data_);
	}
	static Tellusim::MeshSolid::ProgressCallback makeTSMeshSolidProgressCallback(TSMeshSolidProgressCallback func, void *data) {
		auto ret = makeFunction(TSMeshSolidProgressCallback_func);
		ret.setArg1(func);
		ret.setArg2(data);
		return ret;
	}
	
	/*
	 */
	extern "C" {
	
	// Tellusim::String
	TS_CAPI TSString TS_CCALL tsString_new(void) {
		return (TSString)(new String());
	}
	TS_CAPI TSString TS_CCALL tsString_new_uc(uint32_t size, char c) {
		return (TSString)(new String(size, c));
	}
	TS_CAPI TSString TS_CCALL tsString_new_su(const char *str, uint32_t length) {
		return (TSString)(new String(str, length));
	}
	TS_CAPI TSString TS_CCALL tsString_new_wu(const wchar_t *str, uint32_t length) {
		return (TSString)(new String(str, length));
	}
	TS_CAPI TSString TS_CCALL tsString_new_upu(const uint32_t *str, uint32_t length) {
		return (TSString)(new String(str, length));
	}
	TS_CAPI void TS_CCALL tsString_delete(TSString self) {
		if(self) delete (String*)self;
	}
	TS_CAPI void TS_CCALL tsString_reserve(TSString self, uint32_t size, bool_t discard) {
		TS_ASSERT(self);
		((String*)self)->reserve(size, (bool)discard);
	}
	TS_CAPI void TS_CCALL tsString_resize(TSString self, uint32_t size, char c, bool_t reserve) {
		TS_ASSERT(self);
		((String*)self)->resize(size, c, (bool)reserve);
	}
	TS_CAPI void TS_CCALL tsString_release(TSString self) {
		TS_ASSERT(self);
		((String*)self)->release();
	}
	TS_CAPI void TS_CCALL tsString_clear(TSString self) {
		TS_ASSERT(self);
		((String*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsString_copy_su(TSString self, const char *str, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->copy(str, length);
	}
	TS_CAPI void TS_CCALL tsString_copy_wu(TSString self, const wchar_t *str, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->copy(str, length);
	}
	TS_CAPI void TS_CCALL tsString_copy_upu(TSString self, const uint32_t *str, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->copy(str, length);
	}
	TS_CAPI void TS_CCALL tsString_copy_cSu(TSString self, const TSString string, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->copy((string) ? *(const String*)string : String::null, length);
	}
	TS_CAPI void TS_CCALL tsString_append_c(TSString self, char c) {
		TS_ASSERT(self);
		((String*)self)->append(c);
	}
	TS_CAPI void TS_CCALL tsString_append_su(TSString self, const char *str, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->append(str, length);
	}
	TS_CAPI void TS_CCALL tsString_append_cSu(TSString self, const TSString string, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->append((string) ? *(const String*)string : String::null, length);
	}
	TS_CAPI void TS_CCALL tsString_insert_usu(TSString self, uint32_t pos, const char *str, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->insert(pos, str, length);
	}
	TS_CAPI void TS_CCALL tsString_insert_ucSu(TSString self, uint32_t pos, const TSString string, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->insert(pos, (string) ? *(const String*)string : String::null, length);
	}
	TS_CAPI void TS_CCALL tsString_removeBack(TSString self, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->removeBack(length);
	}
	TS_CAPI void TS_CCALL tsString_remove(TSString self, uint32_t pos, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->remove(pos, length);
	}
	TS_CAPI void TS_CCALL tsString_reverse(TSString self, uint32_t pos, uint32_t length) {
		TS_ASSERT(self);
		((String*)self)->reverse(pos, length);
	}
	TS_CAPI uint32_t TS_CCALL tsString_size(TSString self) {
		TS_ASSERT(self);
		return ((String*)self)->size();
	}
	TS_CAPI bool_t TS_CCALL tsString_empty(TSString self) {
		TS_ASSERT(self);
		return ((String*)self)->empty();
	}
	TS_CAPI char* TS_CCALL tsString_get(TSString self) {
		TS_ASSERT(self);
		return ((String*)self)->get();
	}
	TS_CAPI const char* TS_CCALL tsString_get_c(TSString self) {
		TS_ASSERT(self);
		return ((String*)self)->get();
	}
	TS_CAPI char TS_CCALL tsString_get_u(TSString self, uint32_t index) {
		TS_ASSERT(self);
		return ((String*)self)->get(index);
	}
	TS_CAPI char TS_CCALL tsString_get_cu(TSString self, uint32_t index) {
		TS_ASSERT(self);
		return ((String*)self)->get(index);
	}
	TS_CAPI uint32_t TS_CCALL tsString_find_ccu(TSString self, char c, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->find(c, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_rfind_ccu(TSString self, char c, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->rfind(c, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_count_ccu(TSString self, char c, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->count(c, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_find_csu(TSString self, const char *str, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->find(str, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_rfind_csu(TSString self, const char *str, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->rfind(str, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_count_csu(TSString self, const char *str, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->count(str, pos);
	}
	TS_CAPI bool_t TS_CCALL tsString_begins(TSString self, const char *str, uint32_t length, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->begins(str, length, pos);
	}
	TS_CAPI bool_t TS_CCALL tsString_contains(TSString self, const char *str, uint32_t length, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->contains(str, length, pos);
	}
	TS_CAPI bool_t TS_CCALL tsString_match(TSString self, const char *str, uint32_t length, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->match(str, length, pos);
	}
	TS_CAPI int32_t TS_CCALL tsString_compare(TSString self, const char *str, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->compare(str, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_distance(TSString self, const char *str, bool_t scan, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->distance(str, (bool)scan, pos);
	}
	TS_CAPI const char* TS_CCALL tsString_begin(TSString self) {
		TS_ASSERT(self);
		return ((String*)self)->begin();
	}
	TS_CAPI const char* TS_CCALL tsString_end(TSString self) {
		TS_ASSERT(self);
		return ((String*)self)->end();
	}
	TS_CAPI char TS_CCALL tsString_front_cu(TSString self, uint32_t index) {
		TS_ASSERT(self);
		return ((String*)self)->front(index);
	}
	TS_CAPI char TS_CCALL tsString_back_cu(TSString self, uint32_t index) {
		TS_ASSERT(self);
		return ((String*)self)->back(index);
	}
	TS_CAPI char TS_CCALL tsString_front_u(TSString self, uint32_t index) {
		TS_ASSERT(self);
		return ((String*)self)->front(index);
	}
	TS_CAPI char TS_CCALL tsString_back_u(TSString self, uint32_t index) {
		TS_ASSERT(self);
		return ((String*)self)->back(index);
	}
	TS_CAPI TSString TS_CCALL tsString_substring(TSString self, uint32_t pos, uint32_t length) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->substring(pos, length)));
	}
	TS_CAPI TSString TS_CCALL tsString_replace_cccu(TSString self, char before, char after, uint32_t pos) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->replace(before, after, pos)));
	}
	TS_CAPI TSString TS_CCALL tsString_replace_cssu(TSString self, const char *before, const char *after, uint32_t pos) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->replace(before, after, pos)));
	}
	TS_CAPI TSString TS_CCALL tsString_replace_ccScSu(TSString self, const TSString before, const TSString after, uint32_t pos) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->replace((before) ? *(const String*)before : String::null, (after) ? *(const String*)after : String::null, pos)));
	}
	TS_CAPI TSString TS_CCALL tsString_extension_cs(TSString self, const char *extension) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->extension(extension)));
	}
	TS_CAPI TSString TS_CCALL tsString_extension_c(TSString self) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->extension()));
	}
	TS_CAPI TSString TS_CCALL tsString_pathname(TSString self) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->pathname()));
	}
	TS_CAPI TSString TS_CCALL tsString_basename(TSString self) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->basename()));
	}
	TS_CAPI TSString TS_CCALL tsString_dirname(TSString self) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->dirname()));
	}
	TS_CAPI TSString TS_CCALL tsString_relname_ss(const char *path, const char *str) {
		return (TSString)(new String(String::relname(path, str)));
	}
	TS_CAPI TSString TS_CCALL tsString_relname_cScS(const TSString path, const TSString str) {
		return (TSString)(new String(String::relname((path) ? *(const String*)path : String::null, (str) ? *(const String*)str : String::null)));
	}
	TS_CAPI TSString TS_CCALL tsString_capitalize(TSString self, const char *delimiters, const char *spaces) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->capitalize(delimiters, spaces)));
	}
	TS_CAPI TSString TS_CCALL tsString_lower(TSString self) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->lower()));
	}
	TS_CAPI TSString TS_CCALL tsString_upper(TSString self) {
		TS_ASSERT(self);
		return (TSString)(new String(((String*)self)->upper()));
	}
	TS_CAPI uint32_t TS_CCALL tsString_toUtf32_sur(const char *str, uint32_t *code) {
		TS_ASSERT(code);
		return String::toUtf32(str, *code);
	}
	TS_CAPI uint32_t TS_CCALL tsString_toUtf16(TSString self, wchar_t *d, uint32_t length) {
		TS_ASSERT(self);
		return ((String*)self)->toUtf16(d, length);
	}
	TS_CAPI uint32_t TS_CCALL tsString_toUtf32_curu(TSString self, uint32_t *d, uint32_t length) {
		TS_ASSERT(self);
		return ((String*)self)->toUtf32(d, length);
	}
	TS_CAPI uint32_t TS_CCALL tsString_fromUtf32_Su(TSString d, uint32_t code) {
		TS_ASSERT(d);
		return String::fromUtf32(*(String*)d, code);
	}
	TS_CAPI TSString TS_CCALL tsString_fromUtf16(const wchar_t *str, uint32_t length) {
		return (TSString)(new String(String::fromUtf16(str, length)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromUtf32_upu(const uint32_t *str, uint32_t length) {
		return (TSString)(new String(String::fromUtf32(str, length)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromUrl_su(const char *str, uint32_t length) {
		return (TSString)(new String(String::fromUrl(str, length)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromUrl_cSu(const TSString string, uint32_t length) {
		return (TSString)(new String(String::fromUrl((string) ? *(const String*)string : String::null, length)));
	}
	TS_CAPI uint32_t TS_CCALL tsString_vscanf(TSString self, const char *format, va_list args) {
		TS_ASSERT(self);
		return ((String*)self)->vscanf(format, args);
	}
	TS_CAPI void TS_CCALL tsString_vprintf(TSString self, const char *format, va_list args) {
		TS_ASSERT(self);
		((String*)self)->vprintf(format, args);
	}
	TS_CAPI TSString TS_CCALL tsString_vformat(const char *format, va_list args) {
		return (TSString)(new String(String::vformat(format, args)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromi32_Siu(TSString d, int32_t value, uint32_t radix) {
		TS_ASSERT(d);
		return (TSString)(new String(String::fromi32(*(String*)d, value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromi64_Si64u(TSString d, int64_t value, uint32_t radix) {
		TS_ASSERT(d);
		return (TSString)(new String(String::fromi64(*(String*)d, value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromu32_Suu(TSString d, uint32_t value, uint32_t radix) {
		TS_ASSERT(d);
		return (TSString)(new String(String::fromu32(*(String*)d, value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromu64_Su64u(TSString d, uint64_t value, uint32_t radix) {
		TS_ASSERT(d);
		return (TSString)(new String(String::fromu64(*(String*)d, value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromf32_Sfubb(TSString d, float32_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(d);
		return (TSString)(new String(String::fromf32(*(String*)d, value, digits, (bool)compact, (bool)exponent)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromf64_Sf64ubb(TSString d, float64_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(d);
		return (TSString)(new String(String::fromf64(*(String*)d, value, digits, (bool)compact, (bool)exponent)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromi32_iu(int32_t value, uint32_t radix) {
		return (TSString)(new String(String::fromi32(value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromi64_i64u(int64_t value, uint32_t radix) {
		return (TSString)(new String(String::fromi64(value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromu32_uu(uint32_t value, uint32_t radix) {
		return (TSString)(new String(String::fromu32(value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromu64_u64u(uint64_t value, uint32_t radix) {
		return (TSString)(new String(String::fromu64(value, radix)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromf32_fubb(float32_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		return (TSString)(new String(String::fromf32(value, digits, (bool)compact, (bool)exponent)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromf64_f64ubb(float64_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		return (TSString)(new String(String::fromf64(value, digits, (bool)compact, (bool)exponent)));
	}
	TS_CAPI int32_t TS_CCALL tsString_toi32_suur(const char *str, uint32_t radix, uint32_t *size) {
		return String::toi32(str, radix, size);
	}
	TS_CAPI int64_t TS_CCALL tsString_toi64_suur(const char *str, uint32_t radix, uint32_t *size) {
		return String::toi64(str, radix, size);
	}
	TS_CAPI uint32_t TS_CCALL tsString_tou32_suur(const char *str, uint32_t radix, uint32_t *size) {
		return String::tou32(str, radix, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_tou64_suur(const char *str, uint32_t radix, uint32_t *size) {
		return String::tou64(str, radix, size);
	}
	TS_CAPI int32_t TS_CCALL tsString_toi32_sur(const char *str, uint32_t *size) {
		return String::toi32(str, size);
	}
	TS_CAPI int64_t TS_CCALL tsString_toi64_sur(const char *str, uint32_t *size) {
		return String::toi64(str, size);
	}
	TS_CAPI uint32_t TS_CCALL tsString_tou32_sur(const char *str, uint32_t *size) {
		return String::tou32(str, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_tou64_sur(const char *str, uint32_t *size) {
		return String::tou64(str, size);
	}
	TS_CAPI float32_t TS_CCALL tsString_tof32_sur(const char *str, uint32_t *size) {
		return String::tof32(str, size);
	}
	TS_CAPI float64_t TS_CCALL tsString_tof64_sur(const char *str, uint32_t *size) {
		return String::tof64(str, size);
	}
	TS_CAPI int32_t TS_CCALL tsString_toi32_cuu(TSString self, uint32_t radix, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->toi32(radix, pos);
	}
	TS_CAPI int64_t TS_CCALL tsString_toi64_cuu(TSString self, uint32_t radix, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->toi64(radix, pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_tou32_cuu(TSString self, uint32_t radix, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->tou32(radix, pos);
	}
	TS_CAPI uint64_t TS_CCALL tsString_tou64_cuu(TSString self, uint32_t radix, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->tou64(radix, pos);
	}
	TS_CAPI float32_t TS_CCALL tsString_tof32_cu(TSString self, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->tof32(pos);
	}
	TS_CAPI float64_t TS_CCALL tsString_tof64_cu(TSString self, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->tof64(pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_toHashu32(TSString self, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->toHashu32(pos);
	}
	TS_CAPI uint64_t TS_CCALL tsString_toHashu64(TSString self, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->toHashu64(pos);
	}
	TS_CAPI uint32_t TS_CCALL tsString_toRGBAu8(TSString self, uint32_t pos) {
		TS_ASSERT(self);
		return ((String*)self)->toRGBAu8(pos);
	}
	TS_CAPI TSString TS_CCALL tsString_fromTime(uint64_t usec, uint32_t digits) {
		return (TSString)(new String(String::fromTime(usec, digits)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromBytes(uint64_t bytes, uint32_t digits) {
		return (TSString)(new String(String::fromBytes(bytes, digits)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromNumber(uint64_t value, uint32_t digits) {
		return (TSString)(new String(String::fromNumber(value, digits)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromFrequency(uint64_t hz, uint32_t digits) {
		return (TSString)(new String(String::fromFrequency(hz, digits)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromLength(float64_t distance, uint32_t digits) {
		return (TSString)(new String(String::fromLength(distance, digits)));
	}
	TS_CAPI TSString TS_CCALL tsString_fromAngle(float64_t angle, uint32_t digits) {
		return (TSString)(new String(String::fromAngle(angle, digits)));
	}
	TS_CAPI uint64_t TS_CCALL tsString_toBytes_sur(const char *str, uint32_t *size) {
		return String::toBytes(str, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_toNumber_sur(const char *str, uint32_t *size) {
		return String::toNumber(str, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_toFrequency_sur(const char *str, uint32_t *size) {
		return String::toFrequency(str, size);
	}
	TS_CAPI float64_t TS_CCALL tsString_toLength_sur(const char *str, uint32_t *size) {
		return String::toLength(str, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_toBytes_cuur(TSString self, uint32_t pos, uint32_t *size) {
		TS_ASSERT(self);
		return ((String*)self)->toBytes(pos, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_toNumber_cuur(TSString self, uint32_t pos, uint32_t *size) {
		TS_ASSERT(self);
		return ((String*)self)->toNumber(pos, size);
	}
	TS_CAPI uint64_t TS_CCALL tsString_toFrequency_cuur(TSString self, uint32_t pos, uint32_t *size) {
		TS_ASSERT(self);
		return ((String*)self)->toFrequency(pos, size);
	}
	TS_CAPI float64_t TS_CCALL tsString_toLength_cuur(TSString self, uint32_t pos, uint32_t *size) {
		TS_ASSERT(self);
		return ((String*)self)->toLength(pos, size);
	}
	
	// Tellusim::App
	TS_CAPI TSApp TS_CCALL tsApp_new(int32_t argc, char **argv) {
		return (TSApp)(new App(argc, argv));
	}
	TS_CAPI void TS_CCALL tsApp_delete(TSApp self) {
		if(self) delete (App*)self;
	}
	TS_CAPI void TS_CCALL tsApp_clear(TSApp self) {
		TS_ASSERT(self);
		((App*)self)->clear();
	}
	TS_CAPI TS_Platform TS_CCALL tsApp_getPlatform(TSApp self) {
		TS_ASSERT(self);
		return (TS_Platform)((App*)self)->getPlatform();
	}
	TS_CAPI uint32_t TS_CCALL tsApp_getDevice(TSApp self) {
		TS_ASSERT(self);
		return ((App*)self)->getDevice();
	}
	TS_CAPI uint32_t TS_CCALL tsApp_getWidth(TSApp self) {
		TS_ASSERT(self);
		return ((App*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsApp_getHeight(TSApp self) {
		TS_ASSERT(self);
		return ((App*)self)->getHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsApp_getMultisample(TSApp self) {
		TS_ASSERT(self);
		return ((App*)self)->getMultisample();
	}
	TS_CAPI uint32_t TS_CCALL tsApp_getNumArguments(TSApp self) {
		TS_ASSERT(self);
		return ((App*)self)->getNumArguments();
	}
	TS_CAPI TSString TS_CCALL tsApp_getArgument_cu(TSApp self, uint32_t num) {
		TS_ASSERT(self);
		return (TSString)(new String(((App*)self)->getArgument(num)));
	}
	TS_CAPI bool_t TS_CCALL tsApp_isArgument(TSApp self, const char *name) {
		TS_ASSERT(self);
		return ((App*)self)->isArgument(name);
	}
	TS_CAPI TSString TS_CCALL tsApp_getArgument_cs(TSApp self, const char *name) {
		TS_ASSERT(self);
		return (TSString)(new String(((App*)self)->getArgument(name)));
	}
	TS_CAPI bool_t TS_CCALL tsApp_create(TSApp self, TS_Platform platform, uint32_t version) {
		TS_ASSERT(self);
		return ((App*)self)->create((Platform)platform, version);
	}
	TS_CAPI void TS_CCALL tsApp_setPlatform(TS_Platform platform, uint32_t device) {
		App::setPlatform((Platform)platform, device);
	}
	TS_CAPI void TS_CCALL tsApp_setSize(uint32_t width, uint32_t height, uint32_t multisample) {
		App::setSize(width, height, multisample);
	}
	TS_CAPI bool_t TS_CCALL tsApp_isBuildCore(void) {
		return App::isBuildCore();
	}
	TS_CAPI bool_t TS_CCALL tsApp_isBuildDebug(void) {
		return App::isBuildDebug();
	}
	TS_CAPI bool_t TS_CCALL tsApp_isBuildFloat64(void) {
		return App::isBuildFloat64();
	}
	TS_CAPI TSString TS_CCALL tsApp_getBuildDate(void) {
		return (TSString)(new String(App::getBuildDate()));
	}
	TS_CAPI TSString TS_CCALL tsApp_getBuildInfo(void) {
		return (TSString)(new String(App::getBuildInfo()));
	}
	TS_CAPI uint32_t TS_CCALL tsApp_getVersion(void) {
		return App::getVersion();
	}
	TS_CAPI uint64_t TS_CCALL tsApp_getAPIHash(void) {
		return App::getAPIHash();
	}
	
	// Tellusim::Async
	TS_CAPI TSAsync TS_CCALL tsAsync_new(void) {
		Async *ret = new Async();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSAsync)ret;
	}
	TS_CAPI void TS_CCALL tsAsync_delete(TSAsync self) {
		if(self) delete (Async*)self;
	}
	TS_CAPI bool_t TS_CCALL tsAsync_equalPtr(const TSAsync self, const TSAsync ptr) {
		return (self && ptr && ((Async*)self)->operator==(*(Async*)ptr));
	}
	TS_CAPI TSAsync TS_CCALL tsAsync_copyPtr(TSAsync self) {
		Async *ret = nullptr;
		if(self) ret = new Async(*(Async*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSAsync)ret;
	}
	TS_CAPI TSAsync TS_CCALL tsAsync_clonePtr(const TSAsync self) {
		Async *ret = (self) ? new Async(((Async*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSAsync)ret;
	}
	TS_CAPI void TS_CCALL tsAsync_clearPtr(TSAsync self) {
		if(self) ((Async*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsAsync_destroyPtr(TSAsync self) {
		if(self) ((Async*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsAsync_acquirePtr(TSAsync self) {
		if(self) ((Async*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsAsync_unacquirePtr(TSAsync self) {
		if(self) ((Async*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsAsync_isValidPtr(const TSAsync self) {
		return (self && ((Async*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsAsync_isOwnerPtr(const TSAsync self) {
		return (self && ((Async*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsAsync_isConstPtr(const TSAsync self) {
		return (self && ((Async*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsAsync_getCountPtr(const TSAsync self) {
		return ((Async*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsAsync_getInternalPtr(const TSAsync self) {
		return ((Async*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsAsync_init(TSAsync self, uint32_t num) {
		TS_ASSERT(self);
		return ((Async*)self)->init(num);
	}
	TS_CAPI bool_t TS_CCALL tsAsync_shutdown(TSAsync self) {
		TS_ASSERT(self);
		return ((Async*)self)->shutdown();
	}
	TS_CAPI bool_t TS_CCALL tsAsync_isInitialized(TSAsync self) {
		TS_ASSERT(self);
		return ((Async*)self)->isInitialized();
	}
	TS_CAPI uint32_t TS_CCALL tsAsync_getNumCores(void) {
		return Async::getNumCores();
	}
	TS_CAPI uint32_t TS_CCALL tsAsync_getNumThreads(TSAsync self) {
		TS_ASSERT(self);
		return ((Async*)self)->getNumThreads();
	}
	TS_CAPI void TS_CCALL tsAsync_clear(TSAsync self) {
		TS_ASSERT(self);
		((Async*)self)->clear();
	}
	TS_CAPI uint32_t TS_CCALL tsAsync_getNumTasks(TSAsync self, bool_t check) {
		TS_ASSERT(self);
		return ((Async*)self)->getNumTasks((bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsAsync_check_c(TSAsync self) {
		TS_ASSERT(self);
		return ((Async*)self)->check();
	}
	TS_CAPI bool_t TS_CCALL tsAsync_wait_c(TSAsync self) {
		TS_ASSERT(self);
		return ((Async*)self)->wait();
	}
	
	// Tellusim::Stream
	TS_CAPI TSStream TS_CCALL tsStream_new(void) {
		Stream *ret = new Stream();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSStream)ret;
	}
	TS_CAPI void TS_CCALL tsStream_delete(TSStream self) {
		if(self) delete (Stream*)self;
	}
	TS_CAPI bool_t TS_CCALL tsStream_equalPtr(const TSStream self, const TSStream ptr) {
		return (self && ptr && ((Stream*)self)->operator==(*(Stream*)ptr));
	}
	TS_CAPI TSStream TS_CCALL tsStream_copyPtr(TSStream self) {
		Stream *ret = nullptr;
		if(self) ret = new Stream(*(Stream*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSStream)ret;
	}
	TS_CAPI TSStream TS_CCALL tsStream_clonePtr(const TSStream self) {
		Stream *ret = (self) ? new Stream(((Stream*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSStream)ret;
	}
	TS_CAPI void TS_CCALL tsStream_clearPtr(TSStream self) {
		if(self) ((Stream*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsStream_destroyPtr(TSStream self) {
		if(self) ((Stream*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsStream_acquirePtr(TSStream self) {
		if(self) ((Stream*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsStream_unacquirePtr(TSStream self) {
		if(self) ((Stream*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsStream_isValidPtr(const TSStream self) {
		return (self && ((Stream*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsStream_isOwnerPtr(const TSStream self) {
		return (self && ((Stream*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsStream_isConstPtr(const TSStream self) {
		return (self && ((Stream*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsStream_getCountPtr(const TSStream self) {
		return ((Stream*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsStream_getInternalPtr(const TSStream self) {
		return ((Stream*)self)->getInternalPtr();
	}
	TS_CAPI TSStream TS_CCALL tsStream_move(TSStream self) {
		TS_ASSERT(self);
		return (TSStream)(new Stream(((Stream*)self)->move()));
	}
	TS_CAPI bool_t TS_CCALL tsStream_isOpened(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->isOpened();
	}
	TS_CAPI bool_t TS_CCALL tsStream_isMapped(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->isMapped();
	}
	TS_CAPI bool_t TS_CCALL tsStream_isAvailable(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->isAvailable();
	}
	TS_CAPI size_t TS_CCALL tsStream_getSize(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->getSize();
	}
	TS_CAPI TSString TS_CCALL tsStream_getName(TSStream self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Stream*)self)->getName()));
	}
	TS_CAPI size_t TS_CCALL tsStream_tell(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->tell();
	}
	TS_CAPI bool_t TS_CCALL tsStream_seek(TSStream self, size_t offset) {
		TS_ASSERT(self);
		return ((Stream*)self)->seek(offset);
	}
	TS_CAPI bool_t TS_CCALL tsStream_seekBack(TSStream self, size_t offset) {
		TS_ASSERT(self);
		return ((Stream*)self)->seekBack(offset);
	}
	TS_CAPI bool_t TS_CCALL tsStream_seekCur(TSStream self, int64_t offset) {
		TS_ASSERT(self);
		return ((Stream*)self)->seekCur(offset);
	}
	TS_CAPI const uint8_t* TS_CCALL tsStream_getData(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->getData();
	}
	TS_CAPI size_t TS_CCALL tsStream_read(TSStream self, void *dest, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->read(dest, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_write(TSStream self, const void *src, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->write(src, size);
	}
	TS_CAPI bool_t TS_CCALL tsStream_flush(TSStream self) {
		TS_ASSERT(self);
		return ((Stream*)self)->flush();
	}
	TS_CAPI bool_t TS_CCALL tsStream_puts_s(TSStream self, const char *str) {
		TS_ASSERT(self);
		return ((Stream*)self)->puts(str);
	}
	TS_CAPI bool_t TS_CCALL tsStream_puts_cS(TSStream self, const TSString str) {
		TS_ASSERT(self);
		return ((Stream*)self)->puts((str) ? *(const String*)str : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsStream_vprintf(TSStream self, const char *format, va_list args) {
		TS_ASSERT(self);
		return ((Stream*)self)->vprintf(format, args);
	}
	TS_CAPI bool_t TS_CCALL tsStream_printf(TSStream self, const char *format) {
		TS_ASSERT(self);
		return ((Stream*)self)->printf("%s", format);
	}
	TS_CAPI TSString TS_CCALL tsStream_gets(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return (TSString)(new String(((Stream*)self)->gets((bool*)status)));
	}
	TS_CAPI int8_t TS_CCALL tsStream_readi8(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readi8((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writei8(TSStream self, int8_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writei8(value);
	}
	TS_CAPI uint8_t TS_CCALL tsStream_readu8(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readu8((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeu8(TSStream self, uint8_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeu8(value);
	}
	TS_CAPI int16_t TS_CCALL tsStream_readi16(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readi16((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writei16(TSStream self, int16_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writei16(value);
	}
	TS_CAPI uint16_t TS_CCALL tsStream_readu16(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readu16((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeu16(TSStream self, uint16_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeu16(value);
	}
	TS_CAPI int32_t TS_CCALL tsStream_readi32(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readi32((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writei32(TSStream self, int32_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writei32(value);
	}
	TS_CAPI uint32_t TS_CCALL tsStream_readu32(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readu32((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeu32(TSStream self, uint32_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeu32(value);
	}
	TS_CAPI int64_t TS_CCALL tsStream_readi64(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readi64((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writei64(TSStream self, int64_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writei64(value);
	}
	TS_CAPI uint64_t TS_CCALL tsStream_readu64(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readu64((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeu64(TSStream self, uint64_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeu64(value);
	}
	TS_CAPI float32_t TS_CCALL tsStream_readf32(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readf32((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writef32(TSStream self, float32_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writef32(value);
	}
	TS_CAPI float64_t TS_CCALL tsStream_readf64(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readf64((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writef64(TSStream self, float64_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writef64(value);
	}
	TS_CAPI int32_t TS_CCALL tsStream_readi32e(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readi32e((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writei32e(TSStream self, int32_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writei32e(value);
	}
	TS_CAPI uint32_t TS_CCALL tsStream_readu32e(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readu32e((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeu32e(TSStream self, uint32_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeu32e(value);
	}
	TS_CAPI int64_t TS_CCALL tsStream_readi64e(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readi64e((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writei64e(TSStream self, int64_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writei64e(value);
	}
	TS_CAPI uint64_t TS_CCALL tsStream_readu64e(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return ((Stream*)self)->readu64e((bool*)status);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeu64e(TSStream self, uint64_t value) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeu64e(value);
	}
	TS_CAPI TSString TS_CCALL tsStream_readString_br(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return (TSString)(new String(((Stream*)self)->readString((bool*)status)));
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeString_cS(TSStream self, const TSString str) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeString((str) ? *(const String*)str : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeString_s(TSStream self, const char *str) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeString(str);
	}
	TS_CAPI TSString TS_CCALL tsStream_readString_cbru(TSStream self, char term, uint8_t *status, uint32_t size) {
		TS_ASSERT(self);
		return (TSString)(new String(((Stream*)self)->readString(term, (bool*)status, size)));
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeString_cSc(TSStream self, const TSString str, char term) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeString((str) ? *(const String*)str : String::null, term);
	}
	TS_CAPI bool_t TS_CCALL tsStream_writeString_sc(TSStream self, const char *str, char term) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeString(str, term);
	}
	TS_CAPI TSString TS_CCALL tsStream_readToken_br(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return (TSString)(new String(((Stream*)self)->readToken((bool*)status)));
	}
	TS_CAPI bool_t TS_CCALL tsStream_readToken_Sb(TSStream self, TSString dest, bool_t clear) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->readToken(*(String*)dest, (bool)clear);
	}
	TS_CAPI TSString TS_CCALL tsStream_readLine_br(TSStream self, uint8_t *status) {
		TS_ASSERT(self);
		return (TSString)(new String(((Stream*)self)->readLine((bool*)status)));
	}
	TS_CAPI bool_t TS_CCALL tsStream_readLine_Sbb(TSStream self, TSString dest, bool_t empty, bool_t clear) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->readLine(*(String*)dest, (bool)empty, (bool)clear);
	}
	TS_CAPI size_t TS_CCALL tsStream_readStream(TSStream self, TSStream dest, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->readStream(*(Stream*)dest, size, (bool*)status);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeStream(TSStream self, TSStream src, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		return ((Stream*)self)->writeStream(*(Stream*)src, size, (bool*)status);
	}
	TS_CAPI size_t TS_CCALL tsStream_readZip(TSStream self, void *dest, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->readZip(dest, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeZip(TSStream self, const void *src, size_t size, int32_t level) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeZip(src, size, level);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeZipFast(TSStream self, const void *src, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeZipFast(src, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeZipBest(TSStream self, const void *src, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeZipBest(src, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_readLz4(TSStream self, void *dest, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->readLz4(dest, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeLz4(TSStream self, const void *src, size_t size, int32_t level) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeLz4(src, size, level);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeLz4Fast(TSStream self, const void *src, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeLz4Fast(src, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_writeLz4Best(TSStream self, const void *src, size_t size) {
		TS_ASSERT(self);
		return ((Stream*)self)->writeLz4Best(src, size);
	}
	TS_CAPI size_t TS_CCALL tsStream_decodeZip(TSStream self, TSStream src, size_t size, uint8_t *status, int32_t window) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		return ((Stream*)self)->decodeZip(*(Stream*)src, size, (bool*)status, window);
	}
	TS_CAPI size_t TS_CCALL tsStream_encodeZip(TSStream self, TSStream dest, size_t size, uint8_t *status, int32_t level) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->encodeZip(*(Stream*)dest, size, (bool*)status, level);
	}
	TS_CAPI size_t TS_CCALL tsStream_encodeZipFast(TSStream self, TSStream dest, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->encodeZipFast(*(Stream*)dest, size, (bool*)status);
	}
	TS_CAPI size_t TS_CCALL tsStream_encodeZipBest(TSStream self, TSStream dest, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->encodeZipBest(*(Stream*)dest, size, (bool*)status);
	}
	TS_CAPI size_t TS_CCALL tsStream_decodeLz4(TSStream self, TSStream src, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		return ((Stream*)self)->decodeLz4(*(Stream*)src, size, (bool*)status);
	}
	TS_CAPI size_t TS_CCALL tsStream_encodeLz4(TSStream self, TSStream dest, size_t size, uint8_t *status, int32_t level) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->encodeLz4(*(Stream*)dest, size, (bool*)status, level);
	}
	TS_CAPI size_t TS_CCALL tsStream_encodeLz4Fast(TSStream self, TSStream dest, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->encodeLz4Fast(*(Stream*)dest, size, (bool*)status);
	}
	TS_CAPI size_t TS_CCALL tsStream_encodeLz4Best(TSStream self, TSStream dest, size_t size, uint8_t *status) {
		TS_ASSERT(self);
		TS_ASSERT(dest);
		return ((Stream*)self)->encodeLz4Best(*(Stream*)dest, size, (bool*)status);
	}
	
	// Tellusim::Blob
	TS_CAPI TSBlob TS_CCALL tsBlob_new_s(const char *name) {
		Blob *ret = new Blob(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_new_cS(const TSString name) {
		Blob *ret = new Blob((name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_new_zs(size_t size, const char *name) {
		Blob *ret = new Blob(size, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_new_u8pzs(const uint8_t *data, size_t size, const char *name) {
		Blob *ret = new Blob(data, size, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_new_bls(const uint8_t (*blob)[256], const char *name) {
		Blob *ret = new Blob(blob, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_new_cBb(const TSBlob blob, bool_t move) {
		TS_ASSERT(blob);
		Blob *ret = new Blob(*(const Blob*)blob, (bool)move);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI void TS_CCALL tsBlob_delete(TSBlob self) {
		if(self) delete (Blob*)self;
	}
	TS_CAPI bool_t TS_CCALL tsBlob_equalPtr(const TSBlob self, const TSBlob ptr) {
		return (self && ptr && ((Blob*)self)->operator==(*(Blob*)ptr));
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_copyPtr(TSBlob self) {
		Blob *ret = nullptr;
		if(self) ret = new Blob(*(Blob*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI TSBlob TS_CCALL tsBlob_clonePtr(const TSBlob self) {
		Blob *ret = (self) ? new Blob(((Blob*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBlob)ret;
	}
	TS_CAPI void TS_CCALL tsBlob_clearPtr(TSBlob self) {
		if(self) ((Blob*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsBlob_destroyPtr(TSBlob self) {
		if(self) ((Blob*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsBlob_acquirePtr(TSBlob self) {
		if(self) ((Blob*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsBlob_unacquirePtr(TSBlob self) {
		if(self) ((Blob*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsBlob_isValidPtr(const TSBlob self) {
		return (self && ((Blob*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBlob_isOwnerPtr(const TSBlob self) {
		return (self && ((Blob*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBlob_isConstPtr(const TSBlob self) {
		return (self && ((Blob*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsBlob_getCountPtr(const TSBlob self) {
		return ((Blob*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsBlob_getInternalPtr(const TSBlob self) {
		return ((Blob*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsBlob_release(TSBlob self) {
		TS_ASSERT(self);
		((Blob*)self)->release();
	}
	TS_CAPI void TS_CCALL tsBlob_clear(TSBlob self) {
		TS_ASSERT(self);
		((Blob*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsBlob_setName_s(TSBlob self, const char *name) {
		TS_ASSERT(self);
		((Blob*)self)->setName(name);
	}
	TS_CAPI void TS_CCALL tsBlob_setName_cS(TSBlob self, const TSString name) {
		TS_ASSERT(self);
		((Blob*)self)->setName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI void TS_CCALL tsBlob_setSize(TSBlob self, size_t size) {
		TS_ASSERT(self);
		((Blob*)self)->setSize(size);
	}
	TS_CAPI void TS_CCALL tsBlob_setCapacity(TSBlob self, size_t size) {
		TS_ASSERT(self);
		((Blob*)self)->setCapacity(size);
	}
	TS_CAPI size_t TS_CCALL tsBlob_getCapacity(TSBlob self) {
		TS_ASSERT(self);
		return ((Blob*)self)->getCapacity();
	}
	TS_CAPI bool_t TS_CCALL tsBlob_setData_u8pz(TSBlob self, const uint8_t *data, size_t size) {
		TS_ASSERT(self);
		return ((Blob*)self)->setData(data, size);
	}
	TS_CAPI bool_t TS_CCALL tsBlob_setData_bl(TSBlob self, const uint8_t (*blob)[256]) {
		TS_ASSERT(self);
		return ((Blob*)self)->setData(blob);
	}
	TS_CAPI bool_t TS_CCALL tsBlob_setData_cB(TSBlob self, const TSBlob blob) {
		TS_ASSERT(self);
		TS_ASSERT(blob);
		return ((Blob*)self)->setData(*(const Blob*)blob);
	}
	TS_CAPI const uint8_t* TS_CCALL tsBlob_getData_c(TSBlob self) {
		TS_ASSERT(self);
		return ((Blob*)self)->getData();
	}
	TS_CAPI uint8_t* TS_CCALL tsBlob_getData(TSBlob self) {
		TS_ASSERT(self);
		return ((Blob*)self)->getData();
	}
	TS_CAPI TSString TS_CCALL tsBlob_encodeBase64(TSBlob self, size_t size) {
		TS_ASSERT(self);
		return (TSString)(new String(((Blob*)self)->encodeBase64(size)));
	}
	TS_CAPI bool_t TS_CCALL tsBlob_decodeBase64(TSBlob self, const char *src) {
		TS_ASSERT(self);
		return ((Blob*)self)->decodeBase64(src);
	}
	TS_CAPI void TS_CCALL tsBlob_getMD5_urz(TSBlob self, uint32_t hash[4], size_t size) {
		TS_ASSERT(self);
		((Blob*)self)->getMD5(hash, size);
	}
	TS_CAPI TSString TS_CCALL tsBlob_getMD5_z(TSBlob self, size_t size) {
		TS_ASSERT(self);
		return (TSString)(new String(((Blob*)self)->getMD5(size)));
	}
	TS_CAPI TSString TS_CCALL tsBlob_getMD5_cS(const TSString str) {
		return (TSString)(new String(Blob::getMD5((str) ? *(const String*)str : String::null)));
	}
	TS_CAPI TSString TS_CCALL tsBlob_getMD5_pz(const void *src, size_t size) {
		return (TSString)(new String(Blob::getMD5(src, size)));
	}
	TS_CAPI TSString TS_CCALL tsBlob_getMD5_Stz(TSStream src, size_t size) {
		TS_ASSERT(src);
		return (TSString)(new String(Blob::getMD5(*(Stream*)src, size)));
	}
	TS_CAPI void TS_CCALL tsBlob_getSHA1_urz(TSBlob self, uint32_t hash[5], size_t size) {
		TS_ASSERT(self);
		((Blob*)self)->getSHA1(hash, size);
	}
	TS_CAPI TSString TS_CCALL tsBlob_getSHA1_z(TSBlob self, size_t size) {
		TS_ASSERT(self);
		return (TSString)(new String(((Blob*)self)->getSHA1(size)));
	}
	TS_CAPI TSString TS_CCALL tsBlob_getSHA1_cS(const TSString str) {
		return (TSString)(new String(Blob::getSHA1((str) ? *(const String*)str : String::null)));
	}
	TS_CAPI TSString TS_CCALL tsBlob_getSHA1_pz(const void *src, size_t size) {
		return (TSString)(new String(Blob::getSHA1(src, size)));
	}
	TS_CAPI TSString TS_CCALL tsBlob_getSHA1_Stz(TSStream src, size_t size) {
		TS_ASSERT(src);
		return (TSString)(new String(Blob::getSHA1(*(Stream*)src, size)));
	}
	
	// Tellusim::File
	TS_CAPI TSFile TS_CCALL tsFile_new(void) {
		File *ret = new File();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFile)ret;
	}
	TS_CAPI void TS_CCALL tsFile_delete(TSFile self) {
		if(self) delete (File*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFile_equalPtr(const TSFile self, const TSFile ptr) {
		return (self && ptr && ((File*)self)->operator==(*(File*)ptr));
	}
	TS_CAPI TSFile TS_CCALL tsFile_copyPtr(TSFile self) {
		File *ret = nullptr;
		if(self) ret = new File(*(File*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFile)ret;
	}
	TS_CAPI TSFile TS_CCALL tsFile_clonePtr(const TSFile self) {
		File *ret = (self) ? new File(((File*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFile)ret;
	}
	TS_CAPI void TS_CCALL tsFile_clearPtr(TSFile self) {
		if(self) ((File*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFile_destroyPtr(TSFile self) {
		if(self) ((File*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFile_acquirePtr(TSFile self) {
		if(self) ((File*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFile_unacquirePtr(TSFile self) {
		if(self) ((File*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFile_isValidPtr(const TSFile self) {
		return (self && ((File*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFile_isOwnerPtr(const TSFile self) {
		return (self && ((File*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFile_isConstPtr(const TSFile self) {
		return (self && ((File*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFile_getCountPtr(const TSFile self) {
		return ((File*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFile_getInternalPtr(const TSFile self) {
		return ((File*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFile_open_ss(TSFile self, const char *name, const char *mode) {
		TS_ASSERT(self);
		return ((File*)self)->open(name, mode);
	}
	TS_CAPI bool_t TS_CCALL tsFile_open_cSs(TSFile self, const TSString name, const char *mode) {
		TS_ASSERT(self);
		return ((File*)self)->open((name) ? *(const String*)name : String::null, mode);
	}
	TS_CAPI bool_t TS_CCALL tsFile_open_iss(TSFile self, int32_t fd, const char *name, const char *mode) {
		TS_ASSERT(self);
		return ((File*)self)->open(fd, name, mode);
	}
	TS_CAPI bool_t TS_CCALL tsFile_popen_ss(TSFile self, const char *command, const char *mode) {
		TS_ASSERT(self);
		return ((File*)self)->popen(command, mode);
	}
	TS_CAPI bool_t TS_CCALL tsFile_popen_cSs(TSFile self, const TSString command, const char *mode) {
		TS_ASSERT(self);
		return ((File*)self)->popen((command) ? *(const String*)command : String::null, mode);
	}
	TS_CAPI void TS_CCALL tsFile_close(TSFile self) {
		TS_ASSERT(self);
		((File*)self)->close();
	}
	TS_CAPI bool_t TS_CCALL tsFile_isFile_s(const char *name) {
		return File::isFile(name);
	}
	TS_CAPI bool_t TS_CCALL tsFile_isFile_cS(const TSString name) {
		return File::isFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI uint64_t TS_CCALL tsFile_getMTime(const char *name) {
		return File::getMTime(name);
	}
	TS_CAPI size_t TS_CCALL tsFile_getSize(const char *name) {
		return File::getSize(name);
	}
	TS_CAPI bool_t TS_CCALL tsFile_remove(const char *name) {
		return File::remove(name);
	}
	
	// Tellusim::Socket
	TS_CAPI TSSocket TS_CCALL tsSocket_new(TS_SocketType type) {
		Socket *ret = new Socket((Socket::Type)type);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSocket)ret;
	}
	TS_CAPI void TS_CCALL tsSocket_delete(TSSocket self) {
		if(self) delete (Socket*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSocket_equalPtr(const TSSocket self, const TSSocket ptr) {
		return (self && ptr && ((Socket*)self)->operator==(*(Socket*)ptr));
	}
	TS_CAPI TSSocket TS_CCALL tsSocket_copyPtr(TSSocket self) {
		Socket *ret = nullptr;
		if(self) ret = new Socket(*(Socket*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSocket)ret;
	}
	TS_CAPI TSSocket TS_CCALL tsSocket_clonePtr(const TSSocket self) {
		Socket *ret = (self) ? new Socket(((Socket*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSocket)ret;
	}
	TS_CAPI void TS_CCALL tsSocket_clearPtr(TSSocket self) {
		if(self) ((Socket*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSocket_destroyPtr(TSSocket self) {
		if(self) ((Socket*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSocket_acquirePtr(TSSocket self) {
		if(self) ((Socket*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSocket_unacquirePtr(TSSocket self) {
		if(self) ((Socket*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSocket_isValidPtr(const TSSocket self) {
		return (self && ((Socket*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSocket_isOwnerPtr(const TSSocket self) {
		return (self && ((Socket*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSocket_isConstPtr(const TSSocket self) {
		return (self && ((Socket*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSocket_getCountPtr(const TSSocket self) {
		return ((Socket*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSocket_getInternalPtr(const TSSocket self) {
		return ((Socket*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsSocket_open_u16u16(TSSocket self, uint16_t port, uint16_t num) {
		TS_ASSERT(self);
		return ((Socket*)self)->open(port, num);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_open_su16(TSSocket self, const char *name, uint16_t port) {
		TS_ASSERT(self);
		return ((Socket*)self)->open(name, port);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_open_cSu16(TSSocket self, const TSString name, uint16_t port) {
		TS_ASSERT(self);
		return ((Socket*)self)->open((name) ? *(const String*)name : String::null, port);
	}
	TS_CAPI void TS_CCALL tsSocket_close(TSSocket self) {
		TS_ASSERT(self);
		((Socket*)self)->close();
	}
	TS_CAPI bool_t TS_CCALL tsSocket_connect(TSSocket self, uint32_t sec, uint32_t usec) {
		TS_ASSERT(self);
		return ((Socket*)self)->connect(sec, usec);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_accept(TSSocket self, TSSocket socket) {
		TS_ASSERT(self);
		TS_ASSERT(socket);
		return ((Socket*)self)->accept(*(Socket*)socket);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_select(TSSocket self, uint32_t sec, uint32_t usec) {
		TS_ASSERT(self);
		return ((Socket*)self)->select(sec, usec);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_setTimeout(TSSocket self, uint32_t sec) {
		TS_ASSERT(self);
		return ((Socket*)self)->setTimeout(sec);
	}
	TS_CAPI uint32_t TS_CCALL tsSocket_getTimeout(TSSocket self) {
		TS_ASSERT(self);
		return ((Socket*)self)->getTimeout();
	}
	TS_CAPI bool_t TS_CCALL tsSocket_setBlock(TSSocket self, bool_t block) {
		TS_ASSERT(self);
		return ((Socket*)self)->setBlock((bool)block);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_getBlock(TSSocket self) {
		TS_ASSERT(self);
		return ((Socket*)self)->getBlock();
	}
	TS_CAPI bool_t TS_CCALL tsSocket_setDelay(TSSocket self, bool_t delay) {
		TS_ASSERT(self);
		return ((Socket*)self)->setDelay((bool)delay);
	}
	TS_CAPI bool_t TS_CCALL tsSocket_getDelay(TSSocket self) {
		TS_ASSERT(self);
		return ((Socket*)self)->getDelay();
	}
	TS_CAPI void TS_CCALL tsSocket_setName_s(TSSocket self, const char *name) {
		TS_ASSERT(self);
		((Socket*)self)->setName(name);
	}
	TS_CAPI void TS_CCALL tsSocket_setName_cS(TSSocket self, const TSString name) {
		TS_ASSERT(self);
		((Socket*)self)->setName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI uint16_t TS_CCALL tsSocket_getPort(TSSocket self) {
		TS_ASSERT(self);
		return ((Socket*)self)->getPort();
	}
	TS_CAPI int32_t TS_CCALL tsSocket_getFD(TSSocket self) {
		TS_ASSERT(self);
		return ((Socket*)self)->getFD();
	}
	TS_CAPI TS_SocketType TS_CCALL tsSocket_getType(TSSocket self) {
		TS_ASSERT(self);
		return (TS_SocketType)((Socket*)self)->getType();
	}
	TS_CAPI TSString TS_CCALL tsSocket_getAddress(const char *delimiter) {
		return (TSString)(new String(Socket::getAddress(delimiter)));
	}
	
	// Tellusim::SocketSSL
	TS_CAPI TSSocketSSL TS_CCALL tsSocketSSL_new(void) {
		SocketSSL *ret = new SocketSSL();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSocketSSL)ret;
	}
	TS_CAPI void TS_CCALL tsSocketSSL_delete(TSSocketSSL self) {
		if(self) delete (SocketSSL*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_equalPtr(const TSSocketSSL self, const TSSocketSSL ptr) {
		return (self && ptr && ((SocketSSL*)self)->operator==(*(SocketSSL*)ptr));
	}
	TS_CAPI TSSocketSSL TS_CCALL tsSocketSSL_copyPtr(TSSocketSSL self) {
		SocketSSL *ret = nullptr;
		if(self) ret = new SocketSSL(*(SocketSSL*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSocketSSL)ret;
	}
	TS_CAPI TSSocketSSL TS_CCALL tsSocketSSL_clonePtr(const TSSocketSSL self) {
		SocketSSL *ret = (self) ? new SocketSSL(((SocketSSL*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSocketSSL)ret;
	}
	TS_CAPI void TS_CCALL tsSocketSSL_clearPtr(TSSocketSSL self) {
		if(self) ((SocketSSL*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSocketSSL_destroyPtr(TSSocketSSL self) {
		if(self) ((SocketSSL*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSocketSSL_acquirePtr(TSSocketSSL self) {
		if(self) ((SocketSSL*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSocketSSL_unacquirePtr(TSSocketSSL self) {
		if(self) ((SocketSSL*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_isValidPtr(const TSSocketSSL self) {
		return (self && ((SocketSSL*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_isOwnerPtr(const TSSocketSSL self) {
		return (self && ((SocketSSL*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_isConstPtr(const TSSocketSSL self) {
		return (self && ((SocketSSL*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSocketSSL_getCountPtr(const TSSocketSSL self) {
		return ((SocketSSL*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSocketSSL_getInternalPtr(const TSSocketSSL self) {
		return ((SocketSSL*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_equalSocketPtr(const TSSocketSSL self, const TSSocket base) {
		return (self && base && ((SocketSSL*)self)->operator==(*(Socket*)base));
	}
	TS_CAPI TSSocketSSL TS_CCALL tsSocketSSL_castSocketPtr(TSSocket base) {
		return (TSSocketSSL)(new SocketSSL(*(Socket*)base));
	}
	TS_CAPI TSSocket TS_CCALL tsSocketSSL_baseSocketPtr(TSSocketSSL self) {
		return (TSSocket)(new Socket(((SocketSSL*)self)->getSocket()));
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_handshake(TSSocketSSL self, const char *name) {
		TS_ASSERT(self);
		return ((SocketSSL*)self)->handshake(name);
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_accept_SS(TSSocketSSL self, TSSocketSSL socket) {
		TS_ASSERT(self);
		TS_ASSERT(socket);
		return ((SocketSSL*)self)->accept(*(SocketSSL*)socket);
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_accept_S(TSSocketSSL self, TSSocket socket) {
		TS_ASSERT(self);
		TS_ASSERT(socket);
		return ((SocketSSL*)self)->accept(*(Socket*)socket);
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_load_St(TSSocketSSL self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((SocketSSL*)self)->load(*(Stream*)stream);
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_load_s(TSSocketSSL self, const char *name) {
		TS_ASSERT(self);
		return ((SocketSSL*)self)->load(name);
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_load_cS(TSSocketSSL self, const TSString name) {
		TS_ASSERT(self);
		return ((SocketSSL*)self)->load((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsSocketSSL_isConnected(TSSocketSSL self) {
		TS_ASSERT(self);
		return ((SocketSSL*)self)->isConnected();
	}
	
	// Tellusim::Source
	TS_CAPI TSSource TS_CCALL tsSource_new(void) {
		Source *ret = new Source();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSource)ret;
	}
	TS_CAPI TSSource TS_CCALL tsSource_new_u8pzs(const uint8_t *data, size_t size, const char *name) {
		Source *ret = new Source(data, size, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSource)ret;
	}
	TS_CAPI void TS_CCALL tsSource_delete(TSSource self) {
		if(self) delete (Source*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSource_equalPtr(const TSSource self, const TSSource ptr) {
		return (self && ptr && ((Source*)self)->operator==(*(Source*)ptr));
	}
	TS_CAPI TSSource TS_CCALL tsSource_copyPtr(TSSource self) {
		Source *ret = nullptr;
		if(self) ret = new Source(*(Source*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSource)ret;
	}
	TS_CAPI TSSource TS_CCALL tsSource_clonePtr(const TSSource self) {
		Source *ret = (self) ? new Source(((Source*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSource)ret;
	}
	TS_CAPI void TS_CCALL tsSource_clearPtr(TSSource self) {
		if(self) ((Source*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSource_destroyPtr(TSSource self) {
		if(self) ((Source*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSource_acquirePtr(TSSource self) {
		if(self) ((Source*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSource_unacquirePtr(TSSource self) {
		if(self) ((Source*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSource_isValidPtr(const TSSource self) {
		return (self && ((Source*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSource_isOwnerPtr(const TSSource self) {
		return (self && ((Source*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSource_isConstPtr(const TSSource self) {
		return (self && ((Source*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSource_getCountPtr(const TSSource self) {
		return ((Source*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSource_getInternalPtr(const TSSource self) {
		return ((Source*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsSource_open_sbb(TSSource self, const char *name, bool_t callback, bool_t write) {
		TS_ASSERT(self);
		return ((Source*)self)->open(name, (bool)callback, (bool)write);
	}
	TS_CAPI bool_t TS_CCALL tsSource_open_cSbb(TSSource self, const TSString name, bool_t callback, bool_t write) {
		TS_ASSERT(self);
		return ((Source*)self)->open((name) ? *(const String*)name : String::null, (bool)callback, (bool)write);
	}
	TS_CAPI void TS_CCALL tsSource_close(TSSource self) {
		TS_ASSERT(self);
		((Source*)self)->close();
	}
	TS_CAPI void TS_CCALL tsSource_setName_szz(TSSource self, const char *name, size_t offset, size_t size) {
		TS_ASSERT(self);
		((Source*)self)->setName(name, offset, size);
	}
	TS_CAPI void TS_CCALL tsSource_setName_cSzz(TSSource self, const TSString name, size_t offset, size_t size) {
		TS_ASSERT(self);
		((Source*)self)->setName((name) ? *(const String*)name : String::null, offset, size);
	}
	TS_CAPI void TS_CCALL tsSource_setData(TSSource self, const uint8_t *data, size_t size, const char *name) {
		TS_ASSERT(self);
		((Source*)self)->setData(data, size, name);
	}
	TS_CAPI bool_t TS_CCALL tsSource_isSource_s(const char *name) {
		return Source::isSource(name);
	}
	TS_CAPI bool_t TS_CCALL tsSource_isSource_cS(const TSString name) {
		return Source::isSource((name) ? *(const String*)name : String::null);
	}
	TS_CAPI uint64_t TS_CCALL tsSource_getMTime(const char *name) {
		return Source::getMTime(name);
	}
	TS_CAPI size_t TS_CCALL tsSource_getSize(const char *name) {
		return Source::getSize(name);
	}
	TS_CAPI void* TS_CCALL tsSource_getCallbackData(void) {
		return Source::getCallbackData();
	}
	
	// Tellusim::Date
	TS_CAPI TSDate TS_CCALL tsDate_new(void) {
		Date *ret = new Date();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDate)ret;
	}
	TS_CAPI TSDate TS_CCALL tsDate_new_i64b(int64_t time, bool_t local) {
		Date *ret = new Date(time, (bool)local);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDate)ret;
	}
	TS_CAPI TSDate TS_CCALL tsDate_new_ss(const char *str, const char *format) {
		Date *ret = new Date(str, format);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDate)ret;
	}
	TS_CAPI void TS_CCALL tsDate_delete(TSDate self) {
		if(self) delete (Date*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDate_equalPtr(const TSDate self, const TSDate ptr) {
		return (self && ptr && ((Date*)self)->operator==(*(Date*)ptr));
	}
	TS_CAPI TSDate TS_CCALL tsDate_copyPtr(TSDate self) {
		Date *ret = nullptr;
		if(self) ret = new Date(*(Date*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDate)ret;
	}
	TS_CAPI TSDate TS_CCALL tsDate_clonePtr(const TSDate self) {
		Date *ret = (self) ? new Date(((Date*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDate)ret;
	}
	TS_CAPI void TS_CCALL tsDate_clearPtr(TSDate self) {
		if(self) ((Date*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDate_destroyPtr(TSDate self) {
		if(self) ((Date*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDate_acquirePtr(TSDate self) {
		if(self) ((Date*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDate_unacquirePtr(TSDate self) {
		if(self) ((Date*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDate_isValidPtr(const TSDate self) {
		return (self && ((Date*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDate_isOwnerPtr(const TSDate self) {
		return (self && ((Date*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDate_isConstPtr(const TSDate self) {
		return (self && ((Date*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getCountPtr(const TSDate self) {
		return ((Date*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDate_getInternalPtr(const TSDate self) {
		return ((Date*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDate_clear(TSDate self) {
		TS_ASSERT(self);
		((Date*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsDate_setTime(TSDate self, int64_t time, bool_t local) {
		TS_ASSERT(self);
		((Date*)self)->setTime(time, (bool)local);
	}
	TS_CAPI int64_t TS_CCALL tsDate_getTime(TSDate self, bool_t local) {
		TS_ASSERT(self);
		return ((Date*)self)->getTime((bool)local);
	}
	TS_CAPI bool_t TS_CCALL tsDate_setString(TSDate self, const char *str, const char *format) {
		TS_ASSERT(self);
		return ((Date*)self)->setString(str, format);
	}
	TS_CAPI TSString TS_CCALL tsDate_getString(TSDate self, const char *format) {
		TS_ASSERT(self);
		return (TSString)(new String(((Date*)self)->getString(format)));
	}
	TS_CAPI void TS_CCALL tsDate_setYear(TSDate self, uint32_t year) {
		TS_ASSERT(self);
		((Date*)self)->setYear(year);
	}
	TS_CAPI void TS_CCALL tsDate_setMonth(TSDate self, uint32_t month) {
		TS_ASSERT(self);
		((Date*)self)->setMonth(month);
	}
	TS_CAPI void TS_CCALL tsDate_setDate(TSDate self, uint32_t date) {
		TS_ASSERT(self);
		((Date*)self)->setDate(date);
	}
	TS_CAPI void TS_CCALL tsDate_setDay(TSDate self, uint32_t day) {
		TS_ASSERT(self);
		((Date*)self)->setDay(day);
	}
	TS_CAPI void TS_CCALL tsDate_setHours(TSDate self, uint32_t hours) {
		TS_ASSERT(self);
		((Date*)self)->setHours(hours);
	}
	TS_CAPI void TS_CCALL tsDate_setMinutes(TSDate self, uint32_t minutes) {
		TS_ASSERT(self);
		((Date*)self)->setMinutes(minutes);
	}
	TS_CAPI void TS_CCALL tsDate_setSeconds(TSDate self, uint32_t seconds) {
		TS_ASSERT(self);
		((Date*)self)->setSeconds(seconds);
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getYear(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getYear();
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getMonth(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getMonth();
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getDate(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getDate();
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getDay(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getDay();
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getHours(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getHours();
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getMinutes(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getMinutes();
	}
	TS_CAPI uint32_t TS_CCALL tsDate_getSeconds(TSDate self) {
		TS_ASSERT(self);
		return ((Date*)self)->getSeconds();
	}
	TS_CAPI int32_t TS_CCALL tsDate_getTimeZone(void) {
		return Date::getTimeZone();
	}
	
	// Tellusim::Info
	TS_CAPI TSInfo TS_CCALL tsInfo_new(void) {
		Info *ret = new Info();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSInfo)ret;
	}
	TS_CAPI void TS_CCALL tsInfo_delete(TSInfo self) {
		if(self) delete (Info*)self;
	}
	TS_CAPI bool_t TS_CCALL tsInfo_equalPtr(const TSInfo self, const TSInfo ptr) {
		return (self && ptr && ((Info*)self)->operator==(*(Info*)ptr));
	}
	TS_CAPI TSInfo TS_CCALL tsInfo_copyPtr(TSInfo self) {
		Info *ret = nullptr;
		if(self) ret = new Info(*(Info*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSInfo)ret;
	}
	TS_CAPI TSInfo TS_CCALL tsInfo_clonePtr(const TSInfo self) {
		Info *ret = (self) ? new Info(((Info*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSInfo)ret;
	}
	TS_CAPI void TS_CCALL tsInfo_clearPtr(TSInfo self) {
		if(self) ((Info*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsInfo_destroyPtr(TSInfo self) {
		if(self) ((Info*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsInfo_acquirePtr(TSInfo self) {
		if(self) ((Info*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsInfo_unacquirePtr(TSInfo self) {
		if(self) ((Info*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsInfo_isValidPtr(const TSInfo self) {
		return (self && ((Info*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsInfo_isOwnerPtr(const TSInfo self) {
		return (self && ((Info*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsInfo_isConstPtr(const TSInfo self) {
		return (self && ((Info*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCountPtr(const TSInfo self) {
		return ((Info*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsInfo_getInternalPtr(const TSInfo self) {
		return ((Info*)self)->getInternalPtr();
	}
	TS_CAPI size_t TS_CCALL tsInfo_getSystemMemory(TSInfo self) {
		TS_ASSERT(self);
		return ((Info*)self)->getSystemMemory();
	}
	TS_CAPI uint64_t TS_CCALL tsInfo_getSystemUptime(TSInfo self) {
		TS_ASSERT(self);
		return ((Info*)self)->getSystemUptime();
	}
	TS_CAPI TSString TS_CCALL tsInfo_getSystemName(TSInfo self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getSystemName()));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getSystemVersion(TSInfo self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getSystemVersion()));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getKernelVersion(TSInfo self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getKernelVersion()));
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUCount(TSInfo self) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUCount();
	}
	TS_CAPI TSString TS_CCALL tsInfo_getCPUName(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getCPUName(index)));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getCPUVendor(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getCPUVendor(index)));
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUCores(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUCores(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUThreads(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUThreads(index);
	}
	TS_CAPI uint64_t TS_CCALL tsInfo_getCPUFrequency(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUFrequency(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUTemperature(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUTemperature(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUUtilization(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUUtilization(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUFanSpeed(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUFanSpeed(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getCPUPower(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getCPUPower(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getGPUCount(TSInfo self) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUCount();
	}
	TS_CAPI TSString TS_CCALL tsInfo_getGPUName(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getGPUName(index)));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getGPUVendor(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getGPUVendor(index)));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getGPUSerial(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getGPUSerial(index)));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getGPUDevice(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getGPUDevice(index)));
	}
	TS_CAPI TSString TS_CCALL tsInfo_getGPUVersion(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Info*)self)->getGPUVersion(index)));
	}
	TS_CAPI size_t TS_CCALL tsInfo_getGPUMemory(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUMemory(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getGPUScreens(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUScreens(index);
	}
	TS_CAPI uint64_t TS_CCALL tsInfo_getGPUFrequency(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUFrequency(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getGPUTemperature(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUTemperature(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getGPUUtilization(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUUtilization(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getGPUFanSpeed(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUFanSpeed(index);
	}
	TS_CAPI uint32_t TS_CCALL tsInfo_getGPUPower(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->getGPUPower(index);
	}
	TS_CAPI bool_t TS_CCALL tsInfo_isGPUThrottling(TSInfo self, uint32_t index) {
		TS_ASSERT(self);
		return ((Info*)self)->isGPUThrottling(index);
	}
	
	// Tellusim::Directory
	TS_CAPI TSDirectory TS_CCALL tsDirectory_new(void) {
		Directory *ret = new Directory();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDirectory)ret;
	}
	TS_CAPI void TS_CCALL tsDirectory_delete(TSDirectory self) {
		if(self) delete (Directory*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_equalPtr(const TSDirectory self, const TSDirectory ptr) {
		return (self && ptr && ((Directory*)self)->operator==(*(Directory*)ptr));
	}
	TS_CAPI TSDirectory TS_CCALL tsDirectory_copyPtr(TSDirectory self) {
		Directory *ret = nullptr;
		if(self) ret = new Directory(*(Directory*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDirectory)ret;
	}
	TS_CAPI TSDirectory TS_CCALL tsDirectory_clonePtr(const TSDirectory self) {
		Directory *ret = (self) ? new Directory(((Directory*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDirectory)ret;
	}
	TS_CAPI void TS_CCALL tsDirectory_clearPtr(TSDirectory self) {
		if(self) ((Directory*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDirectory_destroyPtr(TSDirectory self) {
		if(self) ((Directory*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDirectory_acquirePtr(TSDirectory self) {
		if(self) ((Directory*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDirectory_unacquirePtr(TSDirectory self) {
		if(self) ((Directory*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isValidPtr(const TSDirectory self) {
		return (self && ((Directory*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isOwnerPtr(const TSDirectory self) {
		return (self && ((Directory*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isConstPtr(const TSDirectory self) {
		return (self && ((Directory*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDirectory_getCountPtr(const TSDirectory self) {
		return ((Directory*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDirectory_getInternalPtr(const TSDirectory self) {
		return ((Directory*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_open_sb(TSDirectory self, const char *name, bool_t children) {
		TS_ASSERT(self);
		return ((Directory*)self)->open(name, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_open_cSb(TSDirectory self, const TSString name, bool_t children) {
		TS_ASSERT(self);
		return ((Directory*)self)->open((name) ? *(const String*)name : String::null, (bool)children);
	}
	TS_CAPI void TS_CCALL tsDirectory_close(TSDirectory self) {
		TS_ASSERT(self);
		((Directory*)self)->close();
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isOpened(TSDirectory self) {
		TS_ASSERT(self);
		return ((Directory*)self)->isOpened();
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getName(TSDirectory self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Directory*)self)->getName()));
	}
	TS_CAPI uint32_t TS_CCALL tsDirectory_getNumFiles(TSDirectory self) {
		TS_ASSERT(self);
		return ((Directory*)self)->getNumFiles();
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getFileName(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Directory*)self)->getFileName(index)));
	}
	TS_CAPI TS_DirectoryAttributes TS_CCALL tsDirectory_getFileAttributes_cu(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_DirectoryAttributes)((Directory*)self)->getFileAttributes(index);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getFileMTime_cu(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return ((Directory*)self)->getFileMTime(index);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getFileATime_cu(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return ((Directory*)self)->getFileATime(index);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getFileCTime_cu(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return ((Directory*)self)->getFileCTime(index);
	}
	TS_CAPI size_t TS_CCALL tsDirectory_getFileSize_cu(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return ((Directory*)self)->getFileSize(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDirectory_getNumDirectories(TSDirectory self) {
		TS_ASSERT(self);
		return ((Directory*)self)->getNumDirectories();
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getDirectoryName(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Directory*)self)->getDirectoryName(index)));
	}
	TS_CAPI TS_DirectoryAttributes TS_CCALL tsDirectory_getDirectoryAttributes(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_DirectoryAttributes)((Directory*)self)->getDirectoryAttributes(index);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getDirectoryCTime(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return ((Directory*)self)->getDirectoryCTime(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDirectory_getDirectorySize(TSDirectory self, uint32_t index) {
		TS_ASSERT(self);
		return ((Directory*)self)->getDirectorySize(index);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isFile_s(const char *name) {
		return Directory::isFile(name);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isFile_cS(const TSString name) {
		return Directory::isFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_setFileAttributes(const char *name, TS_DirectoryAttributes attributes) {
		return Directory::setFileAttributes(name, (Directory::Attributes)attributes);
	}
	TS_CAPI TS_DirectoryAttributes TS_CCALL tsDirectory_getFileAttributes_s(const char *name) {
		return (TS_DirectoryAttributes)Directory::getFileAttributes(name);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_setFileMTime(const char *name, uint64_t time) {
		return Directory::setFileMTime(name, time);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getFileMTime_s(const char *name) {
		return Directory::getFileMTime(name);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getFileATime_s(const char *name) {
		return Directory::getFileATime(name);
	}
	TS_CAPI uint64_t TS_CCALL tsDirectory_getFileCTime_s(const char *name) {
		return Directory::getFileCTime(name);
	}
	TS_CAPI size_t TS_CCALL tsDirectory_getFileSize_s(const char *name) {
		return Directory::getFileSize(name);
	}
	TS_CAPI size_t TS_CCALL tsDirectory_getFileSize_cS(const TSString name) {
		return Directory::getFileSize((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_removeFile_s(const char *name) {
		return Directory::removeFile(name);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_removeFile_cS(const TSString name) {
		return Directory::removeFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_copyFile_ssb(const char *name, const char *new_name, bool_t attributes) {
		return Directory::copyFile(name, new_name, (bool)attributes);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_copyFile_cScSb(const TSString name, const TSString new_name, bool_t attributes) {
		return Directory::copyFile((name) ? *(const String*)name : String::null, (new_name) ? *(const String*)new_name : String::null, (bool)attributes);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isDirectory_s(const char *name) {
		return Directory::isDirectory(name);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_isDirectory_cS(const TSString name) {
		return Directory::isDirectory((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_changeDirectory_s(const char *name) {
		return Directory::changeDirectory(name);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_changeDirectory_cS(const TSString name) {
		return Directory::changeDirectory((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_createDirectory_sb(const char *name, bool_t children) {
		return Directory::createDirectory(name, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_createDirectory_cSb(const TSString name, bool_t children) {
		return Directory::createDirectory((name) ? *(const String*)name : String::null, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_removeDirectory_sb(const char *name, bool_t children) {
		return Directory::removeDirectory(name, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_removeDirectory_cSb(const TSString name, bool_t children) {
		return Directory::removeDirectory((name) ? *(const String*)name : String::null, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_copyDirectory_ssb(const char *name, const char *new_name, bool_t attributes) {
		return Directory::copyDirectory(name, new_name, (bool)attributes);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_copyDirectory_cScSb(const TSString name, const TSString new_name, bool_t attributes) {
		return Directory::copyDirectory((name) ? *(const String*)name : String::null, (new_name) ? *(const String*)new_name : String::null, (bool)attributes);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_rename_ss(const char *name, const char *new_name) {
		return Directory::rename(name, new_name);
	}
	TS_CAPI bool_t TS_CCALL tsDirectory_rename_cScS(const TSString name, const TSString new_name) {
		return Directory::rename((name) ? *(const String*)name : String::null, (new_name) ? *(const String*)new_name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getCurrentDirectory(void) {
		return (TSString)(new String(Directory::getCurrentDirectory()));
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getBinaryDirectory(void) {
		return (TSString)(new String(Directory::getBinaryDirectory()));
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getHomeDirectory(void) {
		return (TSString)(new String(Directory::getHomeDirectory()));
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getTempDirectory(void) {
		return (TSString)(new String(Directory::getTempDirectory()));
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getConfigDirectory(void) {
		return (TSString)(new String(Directory::getConfigDirectory()));
	}
	TS_CAPI TSString TS_CCALL tsDirectory_getDocumentsDirectory(void) {
		return (TSString)(new String(Directory::getDocumentsDirectory()));
	}
	
	// Tellusim::Archive
	TS_CAPI TSArchive TS_CCALL tsArchive_new(void) {
		return (TSArchive)(new Archive());
	}
	TS_CAPI void TS_CCALL tsArchive_delete(TSArchive self) {
		if(self) delete (Archive*)self;
	}
	TS_CAPI bool_t TS_CCALL tsArchive_open_ss(TSArchive self, const char *name, const char *type) {
		TS_ASSERT(self);
		return ((Archive*)self)->open(name, type);
	}
	TS_CAPI bool_t TS_CCALL tsArchive_open_cSs(TSArchive self, const TSString name, const char *type) {
		TS_ASSERT(self);
		return ((Archive*)self)->open((name) ? *(const String*)name : String::null, type);
	}
	TS_CAPI bool_t TS_CCALL tsArchive_open_Sts(TSArchive self, TSStream stream, const char *type) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Archive*)self)->open(*(Stream*)stream, type);
	}
	TS_CAPI void TS_CCALL tsArchive_close(TSArchive self) {
		TS_ASSERT(self);
		((Archive*)self)->close();
	}
	TS_CAPI bool_t TS_CCALL tsArchive_isOpened(TSArchive self) {
		TS_ASSERT(self);
		return ((Archive*)self)->isOpened();
	}
	TS_CAPI TSString TS_CCALL tsArchive_getName(TSArchive self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Archive*)self)->getName()));
	}
	TS_CAPI uint32_t TS_CCALL tsArchive_getNumFiles(TSArchive self) {
		TS_ASSERT(self);
		return ((Archive*)self)->getNumFiles();
	}
	TS_CAPI TSString TS_CCALL tsArchive_getFileName(TSArchive self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Archive*)self)->getFileName(index)));
	}
	TS_CAPI uint64_t TS_CCALL tsArchive_getFileMTime(TSArchive self, uint32_t index) {
		TS_ASSERT(self);
		return ((Archive*)self)->getFileMTime(index);
	}
	TS_CAPI size_t TS_CCALL tsArchive_getFileSize(TSArchive self, uint32_t index) {
		TS_ASSERT(self);
		return ((Archive*)self)->getFileSize(index);
	}
	TS_CAPI uint32_t TS_CCALL tsArchive_findFile_cs(TSArchive self, const char *name) {
		TS_ASSERT(self);
		return ((Archive*)self)->findFile(name);
	}
	TS_CAPI uint32_t TS_CCALL tsArchive_findFile_ccS(TSArchive self, const TSString name) {
		TS_ASSERT(self);
		return ((Archive*)self)->findFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsArchive_isFile_cs(TSArchive self, const char *name) {
		TS_ASSERT(self);
		return ((Archive*)self)->isFile(name);
	}
	TS_CAPI bool_t TS_CCALL tsArchive_isFile_ccS(TSArchive self, const TSString name) {
		TS_ASSERT(self);
		return ((Archive*)self)->isFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSStream TS_CCALL tsArchive_openFile_cs(TSArchive self, const char *name) {
		TS_ASSERT(self);
		return (TSStream)(new Stream(((Archive*)self)->openFile(name)));
	}
	TS_CAPI TSStream TS_CCALL tsArchive_openFile_ccS(TSArchive self, const TSString name) {
		TS_ASSERT(self);
		return (TSStream)(new Stream(((Archive*)self)->openFile((name) ? *(const String*)name : String::null)));
	}
	TS_CAPI TSStream TS_CCALL tsArchive_openFile_cu(TSArchive self, uint32_t index) {
		TS_ASSERT(self);
		return (TSStream)(new Stream(((Archive*)self)->openFile(index)));
	}
	
	// Tellusim::Image
	TS_CAPI TSImage TS_CCALL tsImage_new(void) {
		Image *ret = new Image();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI TSImage TS_CCALL tsImage_new_sIFu(const char *name, TS_ImageFlags flags, uint32_t offset) {
		Image *ret = new Image(name, (Image::Flags)flags, offset);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI TSImage TS_CCALL tsImage_new_StIFu(TSStream stream, TS_ImageFlags flags, uint32_t offset) {
		TS_ASSERT(stream);
		Image *ret = new Image(*(Stream*)stream, (Image::Flags)flags, offset);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI TSImage TS_CCALL tsImage_new_ITFcSIF(TS_ImageType type, TS_Format format, const TSSize *size, TS_ImageFlags flags) {
		TS_ASSERT(size);
		Image *ret = new Image((Image::Type)type, (Format)format, *(const Size*)size, (Image::Flags)flags);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI TSImage TS_CCALL tsImage_new_ITFcSuIF(TS_ImageType type, TS_Format format, const TSSize *size, uint32_t layers, TS_ImageFlags flags) {
		TS_ASSERT(size);
		Image *ret = new Image((Image::Type)type, (Format)format, *(const Size*)size, layers, (Image::Flags)flags);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI void TS_CCALL tsImage_delete(TSImage self) {
		if(self) delete (Image*)self;
	}
	TS_CAPI bool_t TS_CCALL tsImage_equalPtr(const TSImage self, const TSImage ptr) {
		return (self && ptr && ((Image*)self)->operator==(*(Image*)ptr));
	}
	TS_CAPI TSImage TS_CCALL tsImage_copyPtr(TSImage self) {
		Image *ret = nullptr;
		if(self) ret = new Image(*(Image*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI TSImage TS_CCALL tsImage_clonePtr(const TSImage self) {
		Image *ret = (self) ? new Image(((Image*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSImage)ret;
	}
	TS_CAPI void TS_CCALL tsImage_clearPtr(TSImage self) {
		if(self) ((Image*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsImage_destroyPtr(TSImage self) {
		if(self) ((Image*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsImage_acquirePtr(TSImage self) {
		if(self) ((Image*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsImage_unacquirePtr(TSImage self) {
		if(self) ((Image*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isValidPtr(const TSImage self) {
		return (self && ((Image*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsImage_isOwnerPtr(const TSImage self) {
		return (self && ((Image*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsImage_isConstPtr(const TSImage self) {
		return (self && ((Image*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getCountPtr(const TSImage self) {
		return ((Image*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsImage_getInternalPtr(const TSImage self) {
		return ((Image*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsImage_clear(TSImage self) {
		TS_ASSERT(self);
		((Image*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isLoaded(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isLoaded();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isAllocated(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isAllocated();
	}
	TS_CAPI TS_ImageType TS_CCALL tsImage_getType(TSImage self) {
		TS_ASSERT(self);
		return (TS_ImageType)((Image*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsImage_getTypeName_IT(TS_ImageType type) {
		return Image::getTypeName((Image::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsImage_getTypeName_c(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsImage_is2DType(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->is2DType();
	}
	TS_CAPI bool_t TS_CCALL tsImage_is3DType(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->is3DType();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isCubeType(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isCubeType();
	}
	TS_CAPI TS_Format TS_CCALL tsImage_getFormat(TSImage self) {
		TS_ASSERT(self);
		return (TS_Format)((Image*)self)->getFormat();
	}
	TS_CAPI const char* TS_CCALL tsImage_getFormatName(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getFormatName();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isColorFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isColorFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isDepthFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isDepthFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isPixelFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isPixelFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isPlainFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isPlainFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isMixedFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isMixedFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isBlockFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isBlockFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isStencilFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isStencilFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isNormFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isNormFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isSRGBFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isSRGBFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isFloatFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isFloatFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isSignedFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isSignedFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isUnsignedFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isUnsignedFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isIntegerFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isIntegerFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isi8Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isi8Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isu8Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isu8Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_is8BitFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->is8BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isi16Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isi16Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isu16Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isu16Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isf16Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isf16Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_is16BitFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->is16BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isi32Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isi32Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isu32Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isu32Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isf32Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isf32Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_is32BitFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->is32BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isi64Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isi64Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isu64Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isu64Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isf64Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isf64Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_is64BitFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->is64BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isBC15Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isBC15Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isBC67Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isBC67Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isETC2Format(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isETC2Format();
	}
	TS_CAPI bool_t TS_CCALL tsImage_isASTCFormat(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->isASTCFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getComponents(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getComponents();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getPixelSize(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getPixelSize();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getBlockSize(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getBlockSize();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getBlockWidth(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getBlockWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getBlockHeight(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getBlockHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getWidth_c(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getHeight_c(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getDepth_c(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getDepth();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getFaces(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getFaces();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getLayers(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getLayers();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getMipmaps(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getMipmaps();
	}
	TS_CAPI uint32_t TS_CCALL tsImage_findMipmap(TSImage self, const TSSize *size) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((Image*)self)->findMipmap(*(const Size*)size);
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getWidth_cu(TSImage self, uint32_t mipmap) {
		TS_ASSERT(self);
		return ((Image*)self)->getWidth(mipmap);
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getHeight_cu(TSImage self, uint32_t mipmap) {
		TS_ASSERT(self);
		return ((Image*)self)->getHeight(mipmap);
	}
	TS_CAPI uint32_t TS_CCALL tsImage_getDepth_cu(TSImage self, uint32_t mipmap) {
		TS_ASSERT(self);
		return ((Image*)self)->getDepth(mipmap);
	}
	TS_CAPI bool_t TS_CCALL tsImage_hasLayers(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->hasLayers();
	}
	TS_CAPI bool_t TS_CCALL tsImage_hasMipmaps(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->hasMipmaps();
	}
	TS_CAPI TSSize TS_CCALL tsImage_getSize_c(TSImage self) {
		TS_ASSERT(self);
		Size ret = ((Image*)self)->getSize();
		return *(TSSize*)&ret;
	}
	TS_CAPI TSRegion TS_CCALL tsImage_getRegion_c(TSImage self) {
		TS_ASSERT(self);
		Region ret = ((Image*)self)->getRegion();
		return *(TSRegion*)&ret;
	}
	TS_CAPI TSSlice TS_CCALL tsImage_getSlice_c(TSImage self) {
		TS_ASSERT(self);
		Slice ret = ((Image*)self)->getSlice();
		return *(TSSlice*)&ret;
	}
	TS_CAPI TSSize TS_CCALL tsImage_getSize_cu(TSImage self, uint32_t mipmap) {
		TS_ASSERT(self);
		Size ret = ((Image*)self)->getSize(mipmap);
		return *(TSSize*)&ret;
	}
	TS_CAPI TSRegion TS_CCALL tsImage_getRegion_cu(TSImage self, uint32_t mipmap) {
		TS_ASSERT(self);
		Region ret = ((Image*)self)->getRegion(mipmap);
		return *(TSRegion*)&ret;
	}
	TS_CAPI TSSlice TS_CCALL tsImage_getSlice_cu(TSImage self, uint32_t mipmap) {
		TS_ASSERT(self);
		Slice ret = ((Image*)self)->getSlice(mipmap);
		return *(TSSlice*)&ret;
	}
	TS_CAPI void TS_CCALL tsImage_setMetaInfo(TSImage self, const TSString str) {
		TS_ASSERT(self);
		((Image*)self)->setMetaInfo((str) ? *(const String*)str : String::null);
	}
	TS_CAPI TSString TS_CCALL tsImage_getMetaInfo(TSImage self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Image*)self)->getMetaInfo()));
	}
	TS_CAPI TSString TS_CCALL tsImage_getDescription(TSImage self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Image*)self)->getDescription()));
	}
	TS_CAPI size_t TS_CCALL tsImage_getOffset(TSImage self, const TSSlice *slice, uint32_t alignment) {
		TS_ASSERT(self);
		return ((Image*)self)->getOffset((slice) ? *(const Slice*)slice : Slice(), alignment);
	}
	TS_CAPI size_t TS_CCALL tsImage_getStride(TSImage self, uint32_t mipmap, uint32_t alignment) {
		TS_ASSERT(self);
		return ((Image*)self)->getStride(mipmap, alignment);
	}
	TS_CAPI size_t TS_CCALL tsImage_getMipmapSize(TSImage self, uint32_t mipmap, uint32_t alignment) {
		TS_ASSERT(self);
		return ((Image*)self)->getMipmapSize(mipmap, alignment);
	}
	TS_CAPI size_t TS_CCALL tsImage_getLayerSize(TSImage self, uint32_t alignment) {
		TS_ASSERT(self);
		return ((Image*)self)->getLayerSize(alignment);
	}
	TS_CAPI size_t TS_CCALL tsImage_getDataSize(TSImage self, uint32_t alignment) {
		TS_ASSERT(self);
		return ((Image*)self)->getDataSize(alignment);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create_ITFcSIF(TSImage self, TS_ImageType type, TS_Format format, const TSSize *size, TS_ImageFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((Image*)self)->create((Image::Type)type, (Format)format, *(const Size*)size, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create_ITFcSuIF(TSImage self, TS_ImageType type, TS_Format format, const TSSize *size, uint32_t layers, TS_ImageFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((Image*)self)->create((Image::Type)type, (Format)format, *(const Size*)size, layers, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create2D_FuIF(TSImage self, TS_Format format, uint32_t size, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->create2D((Format)format, size, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create3D_FuIF(TSImage self, TS_Format format, uint32_t size, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->create3D((Format)format, size, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_createCube_FuIF(TSImage self, TS_Format format, uint32_t size, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->createCube((Format)format, size, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create2D_FuuIF(TSImage self, TS_Format format, uint32_t width, uint32_t height, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->create2D((Format)format, width, height, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create3D_FuuuIF(TSImage self, TS_Format format, uint32_t width, uint32_t height, uint32_t depth, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->create3D((Format)format, width, height, depth, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_create2D_FuuuIF(TSImage self, TS_Format format, uint32_t width, uint32_t height, uint32_t layers, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->create2D((Format)format, width, height, layers, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_createCube_FuuIF(TSImage self, TS_Format format, uint32_t size, uint32_t layers, TS_ImageFlags flags) {
		TS_ASSERT(self);
		return ((Image*)self)->createCube((Format)format, size, layers, (Image::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsImage_info_sIFuA(TSImage self, const char *name, TS_ImageFlags flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->info(name, (Image::Flags)flags, offset, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_info_cSIFuA(TSImage self, const TSString name, TS_ImageFlags flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->info((name) ? *(const String*)name : String::null, (Image::Flags)flags, offset, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_info_StIFuA(TSImage self, TSStream stream, TS_ImageFlags flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Image*)self)->info(*(Stream*)stream, (Image::Flags)flags, offset, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_info_sA(TSImage self, const char *name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->info(name, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_info_cSA(TSImage self, const TSString name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->info((name) ? *(const String*)name : String::null, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_info_StA(TSImage self, TSStream stream, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Image*)self)->info(*(Stream*)stream, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_load_sIFuA(TSImage self, const char *name, TS_ImageFlags flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->load(name, (Image::Flags)flags, offset, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_load_cSIFuA(TSImage self, const TSString name, TS_ImageFlags flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->load((name) ? *(const String*)name : String::null, (Image::Flags)flags, offset, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_load_StIFuA(TSImage self, TSStream stream, TS_ImageFlags flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Image*)self)->load(*(Stream*)stream, (Image::Flags)flags, offset, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_load_sA(TSImage self, const char *name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->load(name, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_load_cSA(TSImage self, const TSString name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Image*)self)->load((name) ? *(const String*)name : String::null, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_load_StA(TSImage self, TSStream stream, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Image*)self)->load(*(Stream*)stream, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsImage_save_csIFu(TSImage self, const char *name, TS_ImageFlags flags, uint32_t quality) {
		TS_ASSERT(self);
		return ((Image*)self)->save(name, (Image::Flags)flags, quality);
	}
	TS_CAPI bool_t TS_CCALL tsImage_save_ccSIFu(TSImage self, const TSString name, TS_ImageFlags flags, uint32_t quality) {
		TS_ASSERT(self);
		return ((Image*)self)->save((name) ? *(const String*)name : String::null, (Image::Flags)flags, quality);
	}
	TS_CAPI bool_t TS_CCALL tsImage_save_cStIFu(TSImage self, TSStream stream, TS_ImageFlags flags, uint32_t quality) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Image*)self)->save(*(Stream*)stream, (Image::Flags)flags, quality);
	}
	TS_CAPI bool_t TS_CCALL tsImage_swap(TSImage self, uint32_t component_0, uint32_t component_1) {
		TS_ASSERT(self);
		return ((Image*)self)->swap(component_0, component_1);
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIuu(TSImage self, const TSImage src, uint32_t dest_component, uint32_t src_component) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		return ((Image*)self)->copy(*(const Image*)src, dest_component, src_component);
	}
	TS_CAPI bool_t TS_CCALL tsImage_flipX_cRcS(TSImage self, const TSRegion *region, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(region);
		return ((Image*)self)->flipX(*(const Region*)region, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImage_flipX_cR(TSImage self, const TSRegion *region) {
		TS_ASSERT(self);
		TS_ASSERT(region);
		return ((Image*)self)->flipX(*(const Region*)region);
	}
	TS_CAPI bool_t TS_CCALL tsImage_flipX(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->flipX();
	}
	TS_CAPI bool_t TS_CCALL tsImage_flipY_cRcS(TSImage self, const TSRegion *region, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(region);
		return ((Image*)self)->flipY(*(const Region*)region, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImage_flipY_cR(TSImage self, const TSRegion *region) {
		TS_ASSERT(self);
		TS_ASSERT(region);
		return ((Image*)self)->flipY(*(const Region*)region);
	}
	TS_CAPI bool_t TS_CCALL tsImage_flipY(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->flipY();
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIcOcRcScS(TSImage self, const TSImage src, const TSOrigin *dest_origin, const TSRegion *src_region, const TSSlice *dest_slice, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		TS_ASSERT(dest_origin);
		TS_ASSERT(src_region);
		return ((Image*)self)->copy(*(const Image*)src, *(const Origin*)dest_origin, *(const Region*)src_region, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIcOcR(TSImage self, const TSImage src, const TSOrigin *dest_origin, const TSRegion *src_region) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		TS_ASSERT(dest_origin);
		TS_ASSERT(src_region);
		return ((Image*)self)->copy(*(const Image*)src, *(const Origin*)dest_origin, *(const Region*)src_region);
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIcOcS(TSImage self, const TSImage src, const TSOrigin *dest_origin, const TSSlice *dest_slice) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		TS_ASSERT(dest_origin);
		return ((Image*)self)->copy(*(const Image*)src, *(const Origin*)dest_origin, (dest_slice) ? *(const Slice*)dest_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIcScS(TSImage self, const TSImage src, const TSSlice *dest_slice, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		return ((Image*)self)->copy(*(const Image*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIcO(TSImage self, const TSImage src, const TSOrigin *dest_origin) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		TS_ASSERT(dest_origin);
		return ((Image*)self)->copy(*(const Image*)src, *(const Origin*)dest_origin);
	}
	TS_CAPI bool_t TS_CCALL tsImage_copy_cIcS(TSImage self, const TSImage src, const TSSlice *dest_slice) {
		TS_ASSERT(self);
		TS_ASSERT(src);
		return ((Image*)self)->copy(*(const Image*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice());
	}
	TS_CAPI TSImage TS_CCALL tsImage_toType_cITIFA(TSImage self, TS_ImageType type, TS_ImageFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->toType((Image::Type)type, (Image::Flags)flags, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_toType_cITA(TSImage self, TS_ImageType type, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->toType((Image::Type)type, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_toFormat_cFIFA(TSImage self, TS_Format format, TS_ImageFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->toFormat((Format)format, (Image::Flags)flags, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_toFormat_cFA(TSImage self, TS_Format format, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->toFormat((Format)format, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getSlice_ccS(TSImage self, const TSSlice *slice) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getSlice((slice) ? *(const Slice*)slice : Slice())));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getComponent(TSImage self, uint32_t component) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getComponent(component)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getRegion_ccRcS(TSImage self, const TSRegion *region, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(region);
		return (TSImage)(new Image(((Image*)self)->getRegion(*(const Region*)region, (slice) ? *(const Slice*)slice : Slice())));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getRegion_ccR(TSImage self, const TSRegion *region) {
		TS_ASSERT(self);
		TS_ASSERT(region);
		return (TSImage)(new Image(((Image*)self)->getRegion(*(const Region*)region)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getRotated_cicS(TSImage self, int32_t angle, const TSSlice *slice) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getRotated(angle, (slice) ? *(const Slice*)slice : Slice())));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getRotated_ci(TSImage self, int32_t angle) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getRotated(angle)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getResized_ccSIFIFIFA(TSImage self, const TSSize *size, TS_ImageFilter min, TS_ImageFilter mag, TS_ImageFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return (TSImage)(new Image(((Image*)self)->getResized(*(const Size*)size, (Image::Filter)min, (Image::Filter)mag, (Image::Flags)flags, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getResized_ccSIFIFA(TSImage self, const TSSize *size, TS_ImageFilter min, TS_ImageFilter mag, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return (TSImage)(new Image(((Image*)self)->getResized(*(const Size*)size, (Image::Filter)min, (Image::Filter)mag, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getResized_ccSA(TSImage self, const TSSize *size, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return (TSImage)(new Image(((Image*)self)->getResized(*(const Size*)size, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getMipmapped_cIFIFA(TSImage self, TS_ImageFilter filter, TS_ImageFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getMipmapped((Image::Filter)filter, (Image::Flags)flags, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getMipmapped_cIFA(TSImage self, TS_ImageFilter filter, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getMipmapped((Image::Filter)filter, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSImage TS_CCALL tsImage_getMipmapped_cA(TSImage self, TSAsync *async) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Image*)self)->getMipmapped((async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI int32_t TS_CCALL tsImage_compare(TSImage self, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((Image*)self)->compare(*(const Image*)image);
	}
	TS_CAPI const uint8_t* TS_CCALL tsImage_getData_ccS(TSImage self, const TSSlice *slice) {
		TS_ASSERT(self);
		return ((Image*)self)->getData((slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI uint8_t* TS_CCALL tsImage_getData_cS(TSImage self, const TSSlice *slice) {
		TS_ASSERT(self);
		return ((Image*)self)->getData((slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI const uint8_t* TS_CCALL tsImage_getData_ccOcS(TSImage self, const TSOrigin *origin, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(origin);
		return ((Image*)self)->getData(*(const Origin*)origin, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI uint8_t* TS_CCALL tsImage_getData_cOcS(TSImage self, const TSOrigin *origin, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(origin);
		return ((Image*)self)->getData(*(const Origin*)origin, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImage_setData(TSImage self, const void *src, const TSSlice *slice, uint32_t alignment, size_t stride) {
		TS_ASSERT(self);
		return ((Image*)self)->setData(src, (slice) ? *(const Slice*)slice : Slice(), alignment, stride);
	}
	TS_CAPI bool_t TS_CCALL tsImage_getData_cprcSuz(TSImage self, void *dest, const TSSlice *slice, uint32_t alignment, size_t stride) {
		TS_ASSERT(self);
		return ((Image*)self)->getData(dest, (slice) ? *(const Slice*)slice : Slice(), alignment, stride);
	}
	TS_CAPI size_t TS_CCALL tsImage_getMemory(TSImage self) {
		TS_ASSERT(self);
		return ((Image*)self)->getMemory();
	}
	
	// Tellusim::ImageSampler
	TS_CAPI TSImageSampler TS_CCALL tsImageSampler_new(void) {
		return (TSImageSampler)(new ImageSampler());
	}
	TS_CAPI TSImageSampler TS_CCALL tsImageSampler_new_IcS(TSImage image, const TSSlice *slice) {
		TS_ASSERT(image);
		return (TSImageSampler)(new ImageSampler(*(Image*)image, (slice) ? *(const Slice*)slice : Slice()));
	}
	TS_CAPI TSImageSampler TS_CCALL tsImageSampler_new_cIcS(const TSImage image, const TSSlice *slice) {
		TS_ASSERT(image);
		return (TSImageSampler)(new ImageSampler(*(const Image*)image, (slice) ? *(const Slice*)slice : Slice()));
	}
	TS_CAPI void TS_CCALL tsImageSampler_delete(TSImageSampler self) {
		if(self) delete (ImageSampler*)self;
	}
	TS_CAPI void TS_CCALL tsImageSampler_clear(TSImageSampler self) {
		TS_ASSERT(self);
		((ImageSampler*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_isCreated(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->isCreated();
	}
	TS_CAPI TS_ImageType TS_CCALL tsImageSampler_getType(TSImageSampler self) {
		TS_ASSERT(self);
		return (TS_ImageType)((ImageSampler*)self)->getType();
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_is2DType(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->is2DType();
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_is3DType(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->is3DType();
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_isCubeType(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->isCubeType();
	}
	TS_CAPI TS_Format TS_CCALL tsImageSampler_getFormat(TSImageSampler self) {
		TS_ASSERT(self);
		return (TS_Format)((ImageSampler*)self)->getFormat();
	}
	TS_CAPI const char* TS_CCALL tsImageSampler_getFormatName(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getFormatName();
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getWidth(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getHeight(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getDepth(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getDepth();
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getFaces(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getFaces();
	}
	TS_CAPI size_t TS_CCALL tsImageSampler_getTexels(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getTexels();
	}
	TS_CAPI TSSize TS_CCALL tsImageSampler_getSize(TSImageSampler self) {
		TS_ASSERT(self);
		Size ret = ((ImageSampler*)self)->getSize();
		return *(TSSize*)&ret;
	}
	TS_CAPI TSRegion TS_CCALL tsImageSampler_getRegion(TSImageSampler self) {
		TS_ASSERT(self);
		Region ret = ((ImageSampler*)self)->getRegion();
		return *(TSRegion*)&ret;
	}
	TS_CAPI size_t TS_CCALL tsImageSampler_getStride(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getStride();
	}
	TS_CAPI size_t TS_CCALL tsImageSampler_getLayerSize(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getLayerSize();
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getPixelSize(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getPixelSize();
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getComponents(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getComponents();
	}
	TS_CAPI const uint8_t* TS_CCALL tsImageSampler_getData_c(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getData();
	}
	TS_CAPI uint8_t* TS_CCALL tsImageSampler_getData(TSImageSampler self) {
		TS_ASSERT(self);
		return ((ImageSampler*)self)->getData();
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_create_IcS(TSImageSampler self, TSImage image, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((ImageSampler*)self)->create(*(Image*)image, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_create_cIcS(TSImageSampler self, const TSImage image, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((ImageSampler*)self)->create(*(const Image*)image, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_create_ITFcSzpr(TSImageSampler self, TS_ImageType type, TS_Format format, const TSSize *size, size_t stride, void *data) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((ImageSampler*)self)->create((Image::Type)type, (Format)format, *(const Size*)size, stride, data);
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_create_ITFcSzp(TSImageSampler self, TS_ImageType type, TS_Format format, const TSSize *size, size_t stride, const void *data) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((ImageSampler*)self)->create((Image::Type)type, (Format)format, *(const Size*)size, stride, data);
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_create_ITFcSzzpr(TSImageSampler self, TS_ImageType type, TS_Format format, const TSSize *size, size_t stride, size_t layer_size, void *data) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((ImageSampler*)self)->create((Image::Type)type, (Format)format, *(const Size*)size, stride, layer_size, data);
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_create_ITFcSzzp(TSImageSampler self, TS_ImageType type, TS_Format format, const TSSize *size, size_t stride, size_t layer_size, const void *data) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((ImageSampler*)self)->create((Image::Type)type, (Format)format, *(const Size*)size, stride, layer_size, data);
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_clear_cC(TSImageSampler self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		return ((ImageSampler*)self)->clear(*(const Color*)color);
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_clear_cIC(TSImageSampler self, const TSImageColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		return ((ImageSampler*)self)->clear(*(const ImageColor*)color);
	}
	TS_CAPI bool_t TS_CCALL tsImageSampler_mad(TSImageSampler self, const TSColor *m, const TSColor *a) {
		TS_ASSERT(self);
		TS_ASSERT(m);
		TS_ASSERT(a);
		return ((ImageSampler*)self)->mad(*(const Color*)m, *(const Color*)a);
	}
	TS_CAPI void TS_CCALL tsImageSampler_set2D(TSImageSampler self, uint32_t x, uint32_t y, const TSImageColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ImageSampler*)self)->set2D(x, y, *(const ImageColor*)color);
	}
	TS_CAPI TSImageColor TS_CCALL tsImageSampler_get2D_cuub(TSImageSampler self, uint32_t x, uint32_t y, bool_t repeat) {
		TS_ASSERT(self);
		ImageColor ret = ((ImageSampler*)self)->get2D(x, y, (bool)repeat);
		return *(TSImageColor*)&ret;
	}
	TS_CAPI TSImageColor TS_CCALL tsImageSampler_get2D_cf64f64bIF(TSImageSampler self, float64_t x, float64_t y, bool_t repeat, TS_ImageFilter filter) {
		TS_ASSERT(self);
		ImageColor ret = ((ImageSampler*)self)->get2D(x, y, (bool)repeat, (Image::Filter)filter);
		return *(TSImageColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsImageSampler_set3D(TSImageSampler self, uint32_t x, uint32_t y, uint32_t z, const TSImageColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ImageSampler*)self)->set3D(x, y, z, *(const ImageColor*)color);
	}
	TS_CAPI TSImageColor TS_CCALL tsImageSampler_get3D_cuuub(TSImageSampler self, uint32_t x, uint32_t y, uint32_t z, bool_t repeat) {
		TS_ASSERT(self);
		ImageColor ret = ((ImageSampler*)self)->get3D(x, y, z, (bool)repeat);
		return *(TSImageColor*)&ret;
	}
	TS_CAPI TSImageColor TS_CCALL tsImageSampler_get3D_cfffbIF(TSImageSampler self, float32_t x, float32_t y, float32_t z, bool_t repeat, TS_ImageFilter filter) {
		TS_ASSERT(self);
		ImageColor ret = ((ImageSampler*)self)->get3D(x, y, z, (bool)repeat, (Image::Filter)filter);
		return *(TSImageColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsImageSampler_setCube(TSImageSampler self, float32_t x, float32_t y, float32_t z, const TSImageColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ImageSampler*)self)->setCube(x, y, z, *(const ImageColor*)color);
	}
	TS_CAPI TSImageColor TS_CCALL tsImageSampler_getCube(TSImageSampler self, float32_t x, float32_t y, float32_t z, TS_ImageFilter filter) {
		TS_ASSERT(self);
		ImageColor ret = ((ImageSampler*)self)->getCube(x, y, z, (Image::Filter)filter);
		return *(TSImageColor*)&ret;
	}
	TS_CAPI uint32_t TS_CCALL tsImageSampler_getCubeFace(TSImageSampler self, float32_t x, float32_t y, float32_t z, float32_t *tx, float32_t *ty) {
		TS_ASSERT(self);
		TS_ASSERT(tx);
		TS_ASSERT(ty);
		return ((ImageSampler*)self)->getCubeFace(x, y, z, *tx, *ty);
	}
	TS_CAPI void TS_CCALL tsImageSampler_setTexel(TSImageSampler self, size_t t, const TSImageColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ImageSampler*)self)->setTexel(t, *(const ImageColor*)color);
	}
	TS_CAPI TSImageColor TS_CCALL tsImageSampler_getTexel(TSImageSampler self, size_t t) {
		TS_ASSERT(self);
		ImageColor ret = ((ImageSampler*)self)->getTexel(t);
		return *(TSImageColor*)&ret;
	}
	
	// Tellusim::MeshNode
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_new_s(const char *name) {
		MeshNode *ret = new MeshNode(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshNode)ret;
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_new_Ms(TSMesh mesh, const char *name) {
		TS_ASSERT(mesh);
		MeshNode *ret = new MeshNode(*(Mesh*)mesh, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshNode)ret;
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_new_MNs(TSMeshNode *parent, const char *name) {
		MeshNode *ret = new MeshNode((parent) ? *(MeshNode**)parent : nullptr, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshNode)ret;
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_new_MMNs(TSMesh mesh, TSMeshNode *parent, const char *name) {
		TS_ASSERT(mesh);
		MeshNode *ret = new MeshNode(*(Mesh*)mesh, (parent) ? *(MeshNode**)parent : nullptr, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshNode)ret;
	}
	TS_CAPI void TS_CCALL tsMeshNode_delete(TSMeshNode self) {
		if(self) delete (MeshNode*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_equalPtr(const TSMeshNode self, const TSMeshNode ptr) {
		return (self && ptr && ((MeshNode*)self)->operator==(*(MeshNode*)ptr));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_copyPtr(TSMeshNode self) {
		MeshNode *ret = nullptr;
		if(self) ret = new MeshNode(*(MeshNode*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshNode)ret;
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_clonePtr(const TSMeshNode self) {
		MeshNode *ret = (self) ? new MeshNode(((MeshNode*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshNode)ret;
	}
	TS_CAPI void TS_CCALL tsMeshNode_clearPtr(TSMeshNode self) {
		if(self) ((MeshNode*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshNode_destroyPtr(TSMeshNode self) {
		if(self) ((MeshNode*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshNode_acquirePtr(TSMeshNode self) {
		if(self) ((MeshNode*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshNode_unacquirePtr(TSMeshNode self) {
		if(self) ((MeshNode*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_isValidPtr(const TSMeshNode self) {
		return (self && ((MeshNode*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_isOwnerPtr(const TSMeshNode self) {
		return (self && ((MeshNode*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_isConstPtr(const TSMeshNode self) {
		return (self && ((MeshNode*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_getCountPtr(const TSMeshNode self) {
		return ((MeshNode*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshNode_getInternalPtr(const TSMeshNode self) {
		return ((MeshNode*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshNode_clear(TSMeshNode self) {
		TS_ASSERT(self);
		((MeshNode*)self)->clear();
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_clone(TSMeshNode self, TSMesh mesh) {
		TS_ASSERT(self);
		TS_ASSERT(mesh);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->clone(*(Mesh*)mesh)));
	}
	TS_CAPI void TS_CCALL tsMeshNode_setName(TSMeshNode self, const char *name) {
		TS_ASSERT(self);
		((MeshNode*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshNode_getName(TSMeshNode self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshNode*)self)->getName()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_getIndex(TSMeshNode self) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsMeshNode_setMesh(TSMeshNode self, TSMesh mesh, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(mesh);
		((MeshNode*)self)->setMesh(*(Mesh*)mesh, (bool)check);
	}
	TS_CAPI TSMesh TS_CCALL tsMeshNode_getMesh_c(TSMeshNode self) {
		TS_ASSERT(self);
		return (TSMesh)(new Mesh(((MeshNode*)self)->getMesh()));
	}
	TS_CAPI TSMesh TS_CCALL tsMeshNode_getMesh(TSMeshNode self) {
		TS_ASSERT(self);
		return (TSMesh)(new Mesh(((MeshNode*)self)->getMesh()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_setParent(TSMeshNode self, TSMeshNode parent, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((MeshNode*)self)->setParent(*(MeshNode*)parent, (bool)check);
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_getParent_c(TSMeshNode self) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->getParent()));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_getParent(TSMeshNode self) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->getParent()));
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_isRoot(TSMeshNode self) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->isRoot();
	}
	TS_CAPI void TS_CCALL tsMeshNode_reserveChildren(TSMeshNode self, uint32_t num_children) {
		TS_ASSERT(self);
		((MeshNode*)self)->reserveChildren(num_children);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_addChild(TSMeshNode self, TSMeshNode child, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshNode*)self)->addChild(*(MeshNode*)child, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_removeChild(TSMeshNode self, TSMeshNode child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshNode*)self)->removeChild(*(MeshNode*)child);
	}
	TS_CAPI void TS_CCALL tsMeshNode_releaseChildren(TSMeshNode self) {
		TS_ASSERT(self);
		((MeshNode*)self)->releaseChildren();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_findChild_ccMN(TSMeshNode self, const TSMeshNode child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshNode*)self)->findChild(*(const MeshNode*)child);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_findChild_cs(TSMeshNode self, const char *name) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->findChild(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_getNumChildren(TSMeshNode self) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->getNumChildren();
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_getChild_cu(TSMeshNode self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->getChild(index)));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_getChild_cs(TSMeshNode self, const char *name) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->getChild(name)));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_getChild_u(TSMeshNode self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->getChild(index)));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshNode_getChild_s(TSMeshNode self, const char *name) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshNode*)self)->getChild(name)));
	}
	TS_CAPI void TS_CCALL tsMeshNode_clearGeometries(TSMeshNode self) {
		TS_ASSERT(self);
		((MeshNode*)self)->clearGeometries();
	}
	TS_CAPI void TS_CCALL tsMeshNode_reserveGeometries(TSMeshNode self, uint32_t num_geometries) {
		TS_ASSERT(self);
		((MeshNode*)self)->reserveGeometries(num_geometries);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_addGeometry(TSMeshNode self, TSMeshGeometry geometry, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		return ((MeshNode*)self)->addGeometry(*(MeshGeometry*)geometry, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_removeGeometry(TSMeshNode self, TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		return ((MeshNode*)self)->removeGeometry(*(MeshGeometry*)geometry);
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_replaceGeometry(TSMeshNode self, TSMeshGeometry old_geometry, TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(old_geometry);
		TS_ASSERT(geometry);
		return ((MeshNode*)self)->replaceGeometry(*(MeshGeometry*)old_geometry, *(MeshGeometry*)geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_findGeometry(TSMeshNode self, const TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		return ((MeshNode*)self)->findGeometry(*(const MeshGeometry*)geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_getNumGeometries(TSMeshNode self) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->getNumGeometries();
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshNode_getGeometry_cu(TSMeshNode self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshNode*)self)->getGeometry(index)));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshNode_getGeometry_u(TSMeshNode self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshNode*)self)->getGeometry(index)));
	}
	TS_CAPI void TS_CCALL tsMeshNode_clearAttachments(TSMeshNode self) {
		TS_ASSERT(self);
		((MeshNode*)self)->clearAttachments();
	}
	TS_CAPI void TS_CCALL tsMeshNode_reserveAttachments(TSMeshNode self, uint32_t num_attachments) {
		TS_ASSERT(self);
		((MeshNode*)self)->reserveAttachments(num_attachments);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_addAttachment(TSMeshNode self, TSMeshAttachment attachment, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(attachment);
		return ((MeshNode*)self)->addAttachment(*(MeshAttachment*)attachment, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_removeAttachment(TSMeshNode self, TSMeshAttachment attachment) {
		TS_ASSERT(self);
		TS_ASSERT(attachment);
		return ((MeshNode*)self)->removeAttachment(*(MeshAttachment*)attachment);
	}
	TS_CAPI bool_t TS_CCALL tsMeshNode_replaceAttachment(TSMeshNode self, TSMeshAttachment old_attachment, TSMeshAttachment attachment) {
		TS_ASSERT(self);
		TS_ASSERT(old_attachment);
		TS_ASSERT(attachment);
		return ((MeshNode*)self)->replaceAttachment(*(MeshAttachment*)old_attachment, *(MeshAttachment*)attachment);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_findAttachment_ccMA(TSMeshNode self, const TSMeshAttachment attachment) {
		TS_ASSERT(self);
		TS_ASSERT(attachment);
		return ((MeshNode*)self)->findAttachment(*(const MeshAttachment*)attachment);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_findAttachment_cs(TSMeshNode self, const char *name) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->findAttachment(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshNode_getNumAttachments(TSMeshNode self) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->getNumAttachments();
	}
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshNode_getAttachment_cu(TSMeshNode self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAttachment)(new MeshAttachment(((MeshNode*)self)->getAttachment(index)));
	}
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshNode_getAttachment_u(TSMeshNode self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAttachment)(new MeshAttachment(((MeshNode*)self)->getAttachment(index)));
	}
	TS_CAPI void TS_CCALL tsMeshNode_setLocalTransform(TSMeshNode self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshNode*)self)->setLocalTransform(*(const Matrix4x3d*)transform);
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshNode_getLocalTransform(TSMeshNode self) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshNode*)self)->getLocalTransform();
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshNode_setGlobalTransform(TSMeshNode self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshNode*)self)->setGlobalTransform(*(const Matrix4x3d*)transform);
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshNode_getGlobalTransform(TSMeshNode self) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshNode*)self)->getGlobalTransform();
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshNode_setPivotTransform(TSMeshNode self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshNode*)self)->setPivotTransform(*(const Matrix4x3d*)transform);
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshNode_getPivotTransform(TSMeshNode self) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshNode*)self)->getPivotTransform();
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshNode_setMorphTransform(TSMeshNode self, const TSVector4f *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshNode*)self)->setMorphTransform(*(const Vector4f*)transform);
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshNode_getMorphTransform(TSMeshNode self) {
		TS_ASSERT(self);
		const Vector4f ret = ((MeshNode*)self)->getMorphTransform();
		return *(TSVector4f*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshNode_createLocalTransforms(TSMeshNode self, const TSMatrix4x3d *itransform) {
		TS_ASSERT(self);
		TS_ASSERT(itransform);
		((MeshNode*)self)->createLocalTransforms(*(const Matrix4x3d*)itransform);
	}
	TS_CAPI void TS_CCALL tsMeshNode_createGlobalTransforms(TSMeshNode self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshNode*)self)->createGlobalTransforms(*(const Matrix4x3d*)transform);
	}
	TS_CAPI void TS_CCALL tsMeshNode_setTransform(TSMeshNode self, const TSVector3d *scale) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		((MeshNode*)self)->setTransform(*(const Vector3d*)scale);
	}
	TS_CAPI size_t TS_CCALL tsMeshNode_getMemory(TSMeshNode self) {
		TS_ASSERT(self);
		return ((MeshNode*)self)->getMemory();
	}
	
	// Tellusim::MeshIndices
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_new_s(const char *name) {
		MeshIndices *ret = new MeshIndices(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshIndices)ret;
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_new_MITFs(TS_MeshIndicesType type, TS_Format format, const char *name) {
		MeshIndices *ret = new MeshIndices((MeshIndices::Type)type, (Format)format, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshIndices)ret;
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_new_MITFus(TS_MeshIndicesType type, TS_Format format, uint32_t size, const char *name) {
		MeshIndices *ret = new MeshIndices((MeshIndices::Type)type, (Format)format, size, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshIndices)ret;
	}
	TS_CAPI void TS_CCALL tsMeshIndices_delete(TSMeshIndices self) {
		if(self) delete (MeshIndices*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_equalPtr(const TSMeshIndices self, const TSMeshIndices ptr) {
		return (self && ptr && ((MeshIndices*)self)->operator==(*(MeshIndices*)ptr));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_copyPtr(TSMeshIndices self) {
		MeshIndices *ret = nullptr;
		if(self) ret = new MeshIndices(*(MeshIndices*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshIndices)ret;
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_clonePtr(const TSMeshIndices self) {
		MeshIndices *ret = (self) ? new MeshIndices(((MeshIndices*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshIndices)ret;
	}
	TS_CAPI void TS_CCALL tsMeshIndices_clearPtr(TSMeshIndices self) {
		if(self) ((MeshIndices*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_destroyPtr(TSMeshIndices self) {
		if(self) ((MeshIndices*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_acquirePtr(TSMeshIndices self) {
		if(self) ((MeshIndices*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_unacquirePtr(TSMeshIndices self) {
		if(self) ((MeshIndices*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isValidPtr(const TSMeshIndices self) {
		return (self && ((MeshIndices*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isOwnerPtr(const TSMeshIndices self) {
		return (self && ((MeshIndices*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isConstPtr(const TSMeshIndices self) {
		return (self && ((MeshIndices*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_getCountPtr(const TSMeshIndices self) {
		return ((MeshIndices*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshIndices_getInternalPtr(const TSMeshIndices self) {
		return ((MeshIndices*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_clear(TSMeshIndices self) {
		TS_ASSERT(self);
		((MeshIndices*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_setName(TSMeshIndices self, const char *name) {
		TS_ASSERT(self);
		((MeshIndices*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshIndices_getName(TSMeshIndices self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshIndices*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsMeshIndices_create(TSMeshIndices self, TS_MeshIndicesType type, TS_Format format, uint32_t size) {
		TS_ASSERT(self);
		((MeshIndices*)self)->create((MeshIndices::Type)type, (Format)format, size);
	}
	TS_CAPI TS_MeshIndicesType TS_CCALL tsMeshIndices_getType(TSMeshIndices self) {
		TS_ASSERT(self);
		return (TS_MeshIndicesType)((MeshIndices*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsMeshIndices_getTypeName_MIT(TS_MeshIndicesType type) {
		return MeshIndices::getTypeName((MeshIndices::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsMeshIndices_getTypeName_c(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isUnknown(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isUnknown();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isPoint(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isPoint();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isLine(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isLine();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isTriangle(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isTriangle();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isQuadrilateral(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isQuadrilateral();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isTetrahedron(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isTetrahedron();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isPrimitive(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isPrimitive();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isSolid(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isSolid();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isVolume(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isVolume();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isMaterial(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isMaterial();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isGroup(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isGroup();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isJoint(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isJoint();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isEdge(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isEdge();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_getPrimitiveSize(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getPrimitiveSize();
	}
	TS_CAPI TS_Format TS_CCALL tsMeshIndices_getFormat(TSMeshIndices self) {
		TS_ASSERT(self);
		return (TS_Format)((MeshIndices*)self)->getFormat();
	}
	TS_CAPI const char* TS_CCALL tsMeshIndices_getFormatName(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getFormatName();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_setGeometry(TSMeshIndices self, TSMeshGeometry geometry, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		((MeshIndices*)self)->setGeometry(*(MeshGeometry*)geometry, (bool)check);
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshIndices_getGeometry_c(TSMeshIndices self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshIndices*)self)->getGeometry()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshIndices_getGeometry(TSMeshIndices self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshIndices*)self)->getGeometry()));
	}
	TS_CAPI void TS_CCALL tsMeshIndices_setSize(TSMeshIndices self, uint32_t size, bool_t discard, bool_t clear) {
		TS_ASSERT(self);
		((MeshIndices*)self)->setSize(size, (bool)discard, (bool)clear);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_getSize(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getSize();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_getStride(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getStride();
	}
	TS_CAPI size_t TS_CCALL tsMeshIndices_getBytes(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getBytes();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_setData_uuu(TSMeshIndices self, uint32_t value, uint32_t size, uint32_t offset) {
		TS_ASSERT(self);
		((MeshIndices*)self)->setData(value, size, offset);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_setData_pFuu(TSMeshIndices self, const void *src, TS_Format format, uint32_t size, uint32_t repeat) {
		TS_ASSERT(self);
		((MeshIndices*)self)->setData(src, (Format)format, size, repeat);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_getData_cprFuu(TSMeshIndices self, void *dest, TS_Format format, uint32_t size, uint32_t repeat) {
		TS_ASSERT(self);
		((MeshIndices*)self)->getData(dest, (Format)format, size, repeat);
	}
	TS_CAPI const void* TS_CCALL tsMeshIndices_getData_c(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getData();
	}
	TS_CAPI void* TS_CCALL tsMeshIndices_getData(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getData();
	}
	TS_CAPI void TS_CCALL tsMeshIndices_set_uu(TSMeshIndices self, uint32_t index, uint32_t value) {
		TS_ASSERT(self);
		((MeshIndices*)self)->set(index, value);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_set_uuu(TSMeshIndices self, uint32_t index, uint32_t value_0, uint32_t value_1) {
		TS_ASSERT(self);
		((MeshIndices*)self)->set(index, value_0, value_1);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_set_uuuu(TSMeshIndices self, uint32_t index, uint32_t value_0, uint32_t value_1, uint32_t value_2) {
		TS_ASSERT(self);
		((MeshIndices*)self)->set(index, value_0, value_1, value_2);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_set_uuuuu(TSMeshIndices self, uint32_t index, uint32_t value_0, uint32_t value_1, uint32_t value_2, uint32_t value_3) {
		TS_ASSERT(self);
		((MeshIndices*)self)->set(index, value_0, value_1, value_2, value_3);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_get_cu(TSMeshIndices self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->get(index);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_get_cuurur(TSMeshIndices self, uint32_t index, uint32_t *value_0, uint32_t *value_1) {
		TS_ASSERT(self);
		TS_ASSERT(value_0);
		TS_ASSERT(value_1);
		((MeshIndices*)self)->get(index, *value_0, *value_1);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_get_cuururur(TSMeshIndices self, uint32_t index, uint32_t *value_0, uint32_t *value_1, uint32_t *value_2) {
		TS_ASSERT(self);
		TS_ASSERT(value_0);
		TS_ASSERT(value_1);
		TS_ASSERT(value_2);
		((MeshIndices*)self)->get(index, *value_0, *value_1, *value_2);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_get_cuurururur(TSMeshIndices self, uint32_t index, uint32_t *value_0, uint32_t *value_1, uint32_t *value_2, uint32_t *value_3) {
		TS_ASSERT(self);
		TS_ASSERT(value_0);
		TS_ASSERT(value_1);
		TS_ASSERT(value_2);
		TS_ASSERT(value_3);
		((MeshIndices*)self)->get(index, *value_0, *value_1, *value_2, *value_3);
	}
	TS_CAPI const void* TS_CCALL tsMeshIndices_getPtr_cu(TSMeshIndices self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getPtr(index);
	}
	TS_CAPI void* TS_CCALL tsMeshIndices_getPtr_u(TSMeshIndices self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getPtr(index);
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isDirect(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isDirect();
	}
	TS_CAPI bool_t TS_CCALL tsMeshIndices_isUniform(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->isUniform();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_getMinIndex(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getMinIndex();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshIndices_getMaxIndex(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getMaxIndex();
	}
	TS_CAPI int32_t TS_CCALL tsMeshIndices_compare(TSMeshIndices self, const TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return ((MeshIndices*)self)->compare(*(const MeshIndices*)indices);
	}
	TS_CAPI void TS_CCALL tsMeshIndices_addIndices(TSMeshIndices self, const TSMeshIndices indices, uint32_t offset, bool_t expand) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		((MeshIndices*)self)->addIndices(*(const MeshIndices*)indices, offset, (bool)expand);
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_toFormat(TSMeshIndices self, TS_Format format) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshIndices*)self)->toFormat((Format)format)));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_toType_cMIT(TSMeshIndices self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshIndices*)self)->toType((MeshIndices::Type)type)));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshIndices_toType_cMITcMA(TSMeshIndices self, TS_MeshIndicesType type, const TSMeshAttribute position_attribute) {
		TS_ASSERT(self);
		TS_ASSERT(position_attribute);
		return (TSMeshIndices)(new MeshIndices(((MeshIndices*)self)->toType((MeshIndices::Type)type, *(const MeshAttribute*)position_attribute)));
	}
	TS_CAPI size_t TS_CCALL tsMeshIndices_getMemory(TSMeshIndices self) {
		TS_ASSERT(self);
		return ((MeshIndices*)self)->getMemory();
	}
	
	// Tellusim::MeshAttribute
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_new_su(const char *name, uint32_t index) {
		MeshAttribute *ret = new MeshAttribute(name, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttribute)ret;
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_new_MATFsu(TS_MeshAttributeType type, TS_Format format, const char *name, uint32_t index) {
		MeshAttribute *ret = new MeshAttribute((MeshAttribute::Type)type, (Format)format, name, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttribute)ret;
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_new_MATFusu(TS_MeshAttributeType type, TS_Format format, uint32_t size, const char *name, uint32_t index) {
		MeshAttribute *ret = new MeshAttribute((MeshAttribute::Type)type, (Format)format, size, name, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttribute)ret;
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_new_MATFuu(TS_MeshAttributeType type, TS_Format format, uint32_t size, uint32_t index) {
		MeshAttribute *ret = new MeshAttribute((MeshAttribute::Type)type, (Format)format, size, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttribute)ret;
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_delete(TSMeshAttribute self) {
		if(self) delete (MeshAttribute*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_equalPtr(const TSMeshAttribute self, const TSMeshAttribute ptr) {
		return (self && ptr && ((MeshAttribute*)self)->operator==(*(MeshAttribute*)ptr));
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_copyPtr(TSMeshAttribute self) {
		MeshAttribute *ret = nullptr;
		if(self) ret = new MeshAttribute(*(MeshAttribute*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttribute)ret;
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_clonePtr(const TSMeshAttribute self) {
		MeshAttribute *ret = (self) ? new MeshAttribute(((MeshAttribute*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttribute)ret;
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_clearPtr(TSMeshAttribute self) {
		if(self) ((MeshAttribute*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_destroyPtr(TSMeshAttribute self) {
		if(self) ((MeshAttribute*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_acquirePtr(TSMeshAttribute self) {
		if(self) ((MeshAttribute*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_unacquirePtr(TSMeshAttribute self) {
		if(self) ((MeshAttribute*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isValidPtr(const TSMeshAttribute self) {
		return (self && ((MeshAttribute*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isOwnerPtr(const TSMeshAttribute self) {
		return (self && ((MeshAttribute*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isConstPtr(const TSMeshAttribute self) {
		return (self && ((MeshAttribute*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttribute_getCountPtr(const TSMeshAttribute self) {
		return ((MeshAttribute*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshAttribute_getInternalPtr(const TSMeshAttribute self) {
		return ((MeshAttribute*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_clear(TSMeshAttribute self) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setName(TSMeshAttribute self, const char *name) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshAttribute_getName(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAttribute*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_create(TSMeshAttribute self, TS_MeshAttributeType type, TS_Format format, uint32_t size) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->create((MeshAttribute::Type)type, (Format)format, size);
	}
	TS_CAPI TS_MeshAttributeType TS_CCALL tsMeshAttribute_getType(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TS_MeshAttributeType)((MeshAttribute*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsMeshAttribute_getTypeName_MAT(TS_MeshAttributeType type) {
		return MeshAttribute::getTypeName((MeshAttribute::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsMeshAttribute_getTypeName_c(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isUnknown(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isUnknown();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isPosition(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isPosition();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isBasis(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isBasis();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isNormal(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isNormal();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isTangent(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isTangent();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isBinormal(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isBinormal();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isSpatial(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isSpatial();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isNormalized(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isNormalized();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isTexCoord(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isTexCoord();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isWeights(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isWeights();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isJoints(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isJoints();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isColor(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isColor();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isVertex(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isVertex();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isCrease(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isCrease();
	}
	TS_CAPI TS_Format TS_CCALL tsMeshAttribute_getFormat(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TS_Format)((MeshAttribute*)self)->getFormat();
	}
	TS_CAPI const char* TS_CCALL tsMeshAttribute_getFormatName(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getFormatName();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttribute_getComponents(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getComponents();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_isPacked(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->isPacked();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setIndex(TSMeshAttribute self, uint32_t index) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->setIndex(index);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttribute_getIndex(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setIndices(TSMeshAttribute self, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		((MeshAttribute*)self)->setIndices(*(MeshIndices*)indices);
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshAttribute_getIndices_c(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshAttribute*)self)->getIndices()));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshAttribute_getIndices(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshAttribute*)self)->getIndices()));
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setGeometry(TSMeshAttribute self, TSMeshGeometry geometry, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		((MeshAttribute*)self)->setGeometry(*(MeshGeometry*)geometry, (bool)check);
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshAttribute_getGeometry_c(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshAttribute*)self)->getGeometry()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshAttribute_getGeometry(TSMeshAttribute self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshAttribute*)self)->getGeometry()));
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setSize(TSMeshAttribute self, uint32_t size, bool_t discard, bool_t clear) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->setSize(size, (bool)discard, (bool)clear);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttribute_getSize(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getSize();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttribute_getStride(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getStride();
	}
	TS_CAPI size_t TS_CCALL tsMeshAttribute_getBytes(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getBytes();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setData_puu(TSMeshAttribute self, const void *src, uint32_t size, uint32_t stride) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->setData(src, size, stride);
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setData_pcA32u(TSMeshAttribute self, const void *src, const uint32_t *indices, uint32_t indices_size, uint32_t stride) {
		TS_ASSERT(self);
		Array<uint32_t> indices_(indices_size, indices);
		((MeshAttribute*)self)->setData(src, indices_, stride);
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_getData_cpruu(TSMeshAttribute self, void *dest, uint32_t size, uint32_t stride) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->getData(dest, size, stride);
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_getData_cprcMIu(TSMeshAttribute self, void *dest, const TSMeshIndices indices, uint32_t stride) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		((MeshAttribute*)self)->getData(dest, *(const MeshIndices*)indices, stride);
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_getData_cprcA32u(TSMeshAttribute self, void *dest, const uint32_t *indices, uint32_t indices_size, uint32_t stride) {
		TS_ASSERT(self);
		Array<uint32_t> indices_(indices_size, indices);
		((MeshAttribute*)self)->getData(dest, indices_, stride);
	}
	TS_CAPI const void* TS_CCALL tsMeshAttribute_getData_c(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getData();
	}
	TS_CAPI void* TS_CCALL tsMeshAttribute_getData(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getData();
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_setValue(TSMeshAttribute self, uint32_t index, const void *src, size_t size) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->setValue(index, src, size);
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_getValue(TSMeshAttribute self, uint32_t index, void *dest, size_t size) {
		TS_ASSERT(self);
		((MeshAttribute*)self)->getValue(index, dest, size);
	}
	TS_CAPI const void* TS_CCALL tsMeshAttribute_getPtr_cu(TSMeshAttribute self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getPtr(index);
	}
	TS_CAPI void* TS_CCALL tsMeshAttribute_getPtr_u(TSMeshAttribute self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getPtr(index);
	}
	TS_CAPI int32_t TS_CCALL tsMeshAttribute_compare(TSMeshAttribute self, const TSMeshAttribute attribute, const TSMatrix4x3f *transform, float32_t threshold, bool_t spatial) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		TS_ASSERT(transform);
		return ((MeshAttribute*)self)->compare(*(const MeshAttribute*)attribute, *(const Matrix4x3f*)transform, threshold, (bool)spatial);
	}
	TS_CAPI void TS_CCALL tsMeshAttribute_addAttribute(TSMeshAttribute self, const TSMeshAttribute attribute) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		((MeshAttribute*)self)->addAttribute(*(const MeshAttribute*)attribute);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_setTransform(TSMeshAttribute self, const TSMatrix4x3f *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		return ((MeshAttribute*)self)->setTransform(*(const Matrix4x3f*)transform);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_morphAttribute(TSMeshAttribute self, const TSMeshAttribute attribute, float32_t k) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		return ((MeshAttribute*)self)->morphAttribute(*(const MeshAttribute*)attribute, k);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_packAttributes(TSMeshAttribute self, const TSMeshAttribute attribute_0, const TSMeshAttribute attribute_1, TS_Format format) {
		TS_ASSERT(self);
		TS_ASSERT(attribute_0);
		TS_ASSERT(attribute_1);
		return ((MeshAttribute*)self)->packAttributes(*(const MeshAttribute*)attribute_0, *(const MeshAttribute*)attribute_1, (Format)format);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttribute_unpackAttributes(TSMeshAttribute self, TSMeshAttribute attribute_0, TSMeshAttribute attribute_1) {
		TS_ASSERT(self);
		TS_ASSERT(attribute_0);
		TS_ASSERT(attribute_1);
		return ((MeshAttribute*)self)->unpackAttributes(*(MeshAttribute*)attribute_0, *(MeshAttribute*)attribute_1);
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_optimizeAttribute(TSMeshAttribute self, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return (TSMeshAttribute)(new MeshAttribute(((MeshAttribute*)self)->optimizeAttribute(*(MeshIndices*)indices)));
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_toDirect(TSMeshAttribute self, const TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return (TSMeshAttribute)(new MeshAttribute(((MeshAttribute*)self)->toDirect(*(const MeshIndices*)indices)));
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_toFormat(TSMeshAttribute self, TS_Format format) {
		TS_ASSERT(self);
		return (TSMeshAttribute)(new MeshAttribute(((MeshAttribute*)self)->toFormat((Format)format)));
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshAttribute_toType(TSMeshAttribute self, TS_MeshAttributeType type) {
		TS_ASSERT(self);
		return (TSMeshAttribute)(new MeshAttribute(((MeshAttribute*)self)->toType((MeshAttribute::Type)type)));
	}
	TS_CAPI TSMatrix4x3f TS_CCALL tsMeshAttribute_getCovarianceMatrix(TSMeshAttribute self) {
		TS_ASSERT(self);
		Matrix4x3f ret = ((MeshAttribute*)self)->getCovarianceMatrix();
		return *(TSMatrix4x3f*)&ret;
	}
	TS_CAPI TSMatrix4x3f TS_CCALL tsMeshAttribute_getMinTransform(TSMeshAttribute self) {
		TS_ASSERT(self);
		Matrix4x3f ret = ((MeshAttribute*)self)->getMinTransform();
		return *(TSMatrix4x3f*)&ret;
	}
	TS_CAPI TSBoundBoxf TS_CCALL tsMeshAttribute_getBoundBox(TSMeshAttribute self) {
		TS_ASSERT(self);
		BoundBoxf ret = ((MeshAttribute*)self)->getBoundBox();
		return *(TSBoundBoxf*)&ret;
	}
	TS_CAPI TSBoundSpheref TS_CCALL tsMeshAttribute_getBoundSphere(TSMeshAttribute self) {
		TS_ASSERT(self);
		BoundSpheref ret = ((MeshAttribute*)self)->getBoundSphere();
		return *(TSBoundSpheref*)&ret;
	}
	TS_CAPI size_t TS_CCALL tsMeshAttribute_getMemory(TSMeshAttribute self) {
		TS_ASSERT(self);
		return ((MeshAttribute*)self)->getMemory();
	}
	
	// Tellusim::MeshJoint
	TS_CAPI TSMeshJoint TS_CCALL tsMeshJoint_new_s(const char *name) {
		MeshJoint *ret = new MeshJoint(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshJoint)ret;
	}
	TS_CAPI TSMeshJoint TS_CCALL tsMeshJoint_new_MGs(TSMeshGeometry geometry, const char *name) {
		TS_ASSERT(geometry);
		MeshJoint *ret = new MeshJoint(*(MeshGeometry*)geometry, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshJoint)ret;
	}
	TS_CAPI void TS_CCALL tsMeshJoint_delete(TSMeshJoint self) {
		if(self) delete (MeshJoint*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshJoint_equalPtr(const TSMeshJoint self, const TSMeshJoint ptr) {
		return (self && ptr && ((MeshJoint*)self)->operator==(*(MeshJoint*)ptr));
	}
	TS_CAPI TSMeshJoint TS_CCALL tsMeshJoint_copyPtr(TSMeshJoint self) {
		MeshJoint *ret = nullptr;
		if(self) ret = new MeshJoint(*(MeshJoint*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshJoint)ret;
	}
	TS_CAPI TSMeshJoint TS_CCALL tsMeshJoint_clonePtr(const TSMeshJoint self) {
		MeshJoint *ret = (self) ? new MeshJoint(((MeshJoint*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshJoint)ret;
	}
	TS_CAPI void TS_CCALL tsMeshJoint_clearPtr(TSMeshJoint self) {
		if(self) ((MeshJoint*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshJoint_destroyPtr(TSMeshJoint self) {
		if(self) ((MeshJoint*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshJoint_acquirePtr(TSMeshJoint self) {
		if(self) ((MeshJoint*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshJoint_unacquirePtr(TSMeshJoint self) {
		if(self) ((MeshJoint*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshJoint_isValidPtr(const TSMeshJoint self) {
		return (self && ((MeshJoint*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshJoint_isOwnerPtr(const TSMeshJoint self) {
		return (self && ((MeshJoint*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshJoint_isConstPtr(const TSMeshJoint self) {
		return (self && ((MeshJoint*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshJoint_getCountPtr(const TSMeshJoint self) {
		return ((MeshJoint*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshJoint_getInternalPtr(const TSMeshJoint self) {
		return ((MeshJoint*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshJoint_clear(TSMeshJoint self) {
		TS_ASSERT(self);
		((MeshJoint*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setName(TSMeshJoint self, const char *name) {
		TS_ASSERT(self);
		((MeshJoint*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshJoint_getName(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshJoint*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setNode(TSMeshJoint self, TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		((MeshJoint*)self)->setNode(*(MeshNode*)node);
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshJoint_getNode_c(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshJoint*)self)->getNode()));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshJoint_getNode(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshJoint*)self)->getNode()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshJoint_getNodeIndex(TSMeshJoint self) {
		TS_ASSERT(self);
		return ((MeshJoint*)self)->getNodeIndex();
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshJoint_getLocalTransform(TSMeshJoint self) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshJoint*)self)->getLocalTransform();
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshJoint_getGlobalTransform(TSMeshJoint self) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshJoint*)self)->getGlobalTransform();
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setIndices(TSMeshJoint self, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		((MeshJoint*)self)->setIndices(*(MeshIndices*)indices);
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshJoint_getIndices_c(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshJoint*)self)->getIndices()));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshJoint_getIndices(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshJoint*)self)->getIndices()));
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setGeometry(TSMeshJoint self, TSMeshGeometry geometry, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		((MeshJoint*)self)->setGeometry(*(MeshGeometry*)geometry, (bool)check);
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshJoint_getGeometry_c(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshJoint*)self)->getGeometry()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshJoint_getGeometry(TSMeshJoint self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshJoint*)self)->getGeometry()));
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setBoundBox(TSMeshJoint self, const TSBoundBoxf *box) {
		TS_ASSERT(self);
		TS_ASSERT(box);
		((MeshJoint*)self)->setBoundBox(*(const BoundBoxf*)box);
	}
	TS_CAPI TSBoundBoxf TS_CCALL tsMeshJoint_getBoundBox(TSMeshJoint self) {
		TS_ASSERT(self);
		const BoundBoxf ret = ((MeshJoint*)self)->getBoundBox();
		return *(TSBoundBoxf*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setBoundSphere(TSMeshJoint self, const TSBoundSpheref *sphere) {
		TS_ASSERT(self);
		TS_ASSERT(sphere);
		((MeshJoint*)self)->setBoundSphere(*(const BoundSpheref*)sphere);
	}
	TS_CAPI TSBoundSpheref TS_CCALL tsMeshJoint_getBoundSphere(TSMeshJoint self) {
		TS_ASSERT(self);
		const BoundSpheref ret = ((MeshJoint*)self)->getBoundSphere();
		return *(TSBoundSpheref*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshJoint_setITransform(TSMeshJoint self, const TSMatrix4x3f *itransform) {
		TS_ASSERT(self);
		TS_ASSERT(itransform);
		((MeshJoint*)self)->setITransform(*(const Matrix4x3f*)itransform);
	}
	TS_CAPI TSMatrix4x3f TS_CCALL tsMeshJoint_getITransform(TSMeshJoint self) {
		TS_ASSERT(self);
		const Matrix4x3f ret = ((MeshJoint*)self)->getITransform();
		return *(TSMatrix4x3f*)&ret;
	}
	TS_CAPI int32_t TS_CCALL tsMeshJoint_compare(TSMeshJoint self, const TSMeshJoint joint) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		return ((MeshJoint*)self)->compare(*(const MeshJoint*)joint);
	}
	TS_CAPI size_t TS_CCALL tsMeshJoint_getMemory(TSMeshJoint self) {
		TS_ASSERT(self);
		return ((MeshJoint*)self)->getMemory();
	}
	
	// Tellusim::MeshMaterial
	TS_CAPI TSMeshMaterial TS_CCALL tsMeshMaterial_new_s(const char *name) {
		MeshMaterial *ret = new MeshMaterial(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshMaterial)ret;
	}
	TS_CAPI TSMeshMaterial TS_CCALL tsMeshMaterial_new_MGs(TSMeshGeometry geometry, const char *name) {
		TS_ASSERT(geometry);
		MeshMaterial *ret = new MeshMaterial(*(MeshGeometry*)geometry, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshMaterial)ret;
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_delete(TSMeshMaterial self) {
		if(self) delete (MeshMaterial*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_equalPtr(const TSMeshMaterial self, const TSMeshMaterial ptr) {
		return (self && ptr && ((MeshMaterial*)self)->operator==(*(MeshMaterial*)ptr));
	}
	TS_CAPI TSMeshMaterial TS_CCALL tsMeshMaterial_copyPtr(TSMeshMaterial self) {
		MeshMaterial *ret = nullptr;
		if(self) ret = new MeshMaterial(*(MeshMaterial*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshMaterial)ret;
	}
	TS_CAPI TSMeshMaterial TS_CCALL tsMeshMaterial_clonePtr(const TSMeshMaterial self) {
		MeshMaterial *ret = (self) ? new MeshMaterial(((MeshMaterial*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshMaterial)ret;
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_clearPtr(TSMeshMaterial self) {
		if(self) ((MeshMaterial*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_destroyPtr(TSMeshMaterial self) {
		if(self) ((MeshMaterial*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_acquirePtr(TSMeshMaterial self) {
		if(self) ((MeshMaterial*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_unacquirePtr(TSMeshMaterial self) {
		if(self) ((MeshMaterial*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_isValidPtr(const TSMeshMaterial self) {
		return (self && ((MeshMaterial*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_isOwnerPtr(const TSMeshMaterial self) {
		return (self && ((MeshMaterial*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_isConstPtr(const TSMeshMaterial self) {
		return (self && ((MeshMaterial*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshMaterial_getCountPtr(const TSMeshMaterial self) {
		return ((MeshMaterial*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshMaterial_getInternalPtr(const TSMeshMaterial self) {
		return ((MeshMaterial*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_clear(TSMeshMaterial self) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_setName(TSMeshMaterial self, const char *name) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getName(TSMeshMaterial self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getName()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshMaterial_getIndex(TSMeshMaterial self) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_setIndices(TSMeshMaterial self, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		((MeshMaterial*)self)->setIndices(*(MeshIndices*)indices);
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshMaterial_getIndices_c(TSMeshMaterial self) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshMaterial*)self)->getIndices()));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshMaterial_getIndices(TSMeshMaterial self) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshMaterial*)self)->getIndices()));
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_setGeometry(TSMeshMaterial self, TSMeshGeometry geometry, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		((MeshMaterial*)self)->setGeometry(*(MeshGeometry*)geometry, (bool)check);
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshMaterial_getGeometry_c(TSMeshMaterial self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshMaterial*)self)->getGeometry()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshMaterial_getGeometry(TSMeshMaterial self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshMaterial*)self)->getGeometry()));
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_setData_s(TSMeshMaterial self, const char *data) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->setData(data);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_setData_cS(TSMeshMaterial self, const TSString data) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->setData((data) ? *(const String*)data : String::null);
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getData(TSMeshMaterial self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getData()));
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_clearParameters(TSMeshMaterial self) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->clearParameters();
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_removeParameter(TSMeshMaterial self, const char *type) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->removeParameter(type);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_copyParameters(TSMeshMaterial self, const TSMeshMaterial material) {
		TS_ASSERT(self);
		TS_ASSERT(material);
		((MeshMaterial*)self)->copyParameters(*(const MeshMaterial*)material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshMaterial_findParameter(TSMeshMaterial self, const char *type) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->findParameter(type);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_hasParameter(TSMeshMaterial self, const char *type) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->hasParameter(type);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshMaterial_getNumParameters(TSMeshMaterial self) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getNumParameters();
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getParameterType(TSMeshMaterial self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getParameterType(index)));
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_sb(TSMeshMaterial self, const char *type, bool_t value) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->addParameter(type, (bool)value);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_sf(TSMeshMaterial self, const char *type, float32_t value) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->addParameter(type, value);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_scV4(TSMeshMaterial self, const char *type, const TSVector4f *value) {
		TS_ASSERT(self);
		TS_ASSERT(value);
		((MeshMaterial*)self)->addParameter(type, *(const Vector4f*)value);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_scM32(TSMeshMaterial self, const char *type, const TSMatrix3x2f *value) {
		TS_ASSERT(self);
		TS_ASSERT(value);
		((MeshMaterial*)self)->addParameter(type, *(const Matrix3x2f*)value);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_scC(TSMeshMaterial self, const char *type, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((MeshMaterial*)self)->addParameter(type, *(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_sss(TSMeshMaterial self, const char *type, const char *name, const char *layout) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->addParameter(type, name, layout);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_scSs(TSMeshMaterial self, const char *type, const TSString name, const char *layout) {
		TS_ASSERT(self);
		((MeshMaterial*)self)->addParameter(type, (name) ? *(const String*)name : String::null, layout);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_scIs(TSMeshMaterial self, const char *type, const TSImage image, const char *layout) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		((MeshMaterial*)self)->addParameter(type, *(const Image*)image, layout);
	}
	TS_CAPI void TS_CCALL tsMeshMaterial_addParameter_sBs(TSMeshMaterial self, const char *type, TSBlob blob, const char *layout) {
		TS_ASSERT(self);
		TS_ASSERT(blob);
		((MeshMaterial*)self)->addParameter(type, *(Blob*)blob, layout);
	}
	TS_CAPI TS_MeshMaterialFlags TS_CCALL tsMeshMaterial_getParameterFlags_cu(TSMeshMaterial self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_MeshMaterialFlags)((MeshMaterial*)self)->getParameterFlags(index);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_hasParameterFlag_cuMMF(TSMeshMaterial self, uint32_t index, TS_MeshMaterialFlags flags) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->hasParameterFlag(index, (MeshMaterial::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_hasParameterFlags_cuMMF(TSMeshMaterial self, uint32_t index, TS_MeshMaterialFlags flags) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->hasParameterFlags(index, (MeshMaterial::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_getParameterBool_cub(TSMeshMaterial self, uint32_t index, bool_t value) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getParameterBool(index, (bool)value);
	}
	TS_CAPI float32_t TS_CCALL tsMeshMaterial_getParameterScalarf32_cuf(TSMeshMaterial self, uint32_t index, float32_t value) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getParameterScalarf32(index, value);
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshMaterial_getParameterVector4f_cucV4(TSMeshMaterial self, uint32_t index, const TSVector4f *vector) {
		TS_ASSERT(self);
		TS_ASSERT(vector);
		const Vector4f ret = ((MeshMaterial*)self)->getParameterVector4f(index, *(const Vector4f*)vector);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI TSMatrix3x2f TS_CCALL tsMeshMaterial_getParameterMatrix3x2f_cucM32(TSMeshMaterial self, uint32_t index, const TSMatrix3x2f *matrix) {
		TS_ASSERT(self);
		TS_ASSERT(matrix);
		const Matrix3x2f ret = ((MeshMaterial*)self)->getParameterMatrix3x2f(index, *(const Matrix3x2f*)matrix);
		return *(TSMatrix3x2f*)&ret;
	}
	TS_CAPI TSColor TS_CCALL tsMeshMaterial_getParameterColor_cucC(TSMeshMaterial self, uint32_t index, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		const Color ret = ((MeshMaterial*)self)->getParameterColor(index, *(const Color*)color);
		return *(TSColor*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getParameterName_cucS(TSMeshMaterial self, uint32_t index, const TSString name) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getParameterName(index, (name) ? *(const String*)name : String::null)));
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getParameterLayout_cucS(TSMeshMaterial self, uint32_t index, const TSString layout) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getParameterLayout(index, (layout) ? *(const String*)layout : String::null)));
	}
	TS_CAPI TSImage TS_CCALL tsMeshMaterial_getParameterImage_cu(TSMeshMaterial self, uint32_t index) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((MeshMaterial*)self)->getParameterImage(index)));
	}
	TS_CAPI TSBlob TS_CCALL tsMeshMaterial_getParameterBlob_cu(TSMeshMaterial self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBlob)(new Blob(((MeshMaterial*)self)->getParameterBlob(index)));
	}
	TS_CAPI TSImage TS_CCALL tsMeshMaterial_getParameterImage_u(TSMeshMaterial self, uint32_t index) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((MeshMaterial*)self)->getParameterImage(index)));
	}
	TS_CAPI TSBlob TS_CCALL tsMeshMaterial_getParameterBlob_u(TSMeshMaterial self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBlob)(new Blob(((MeshMaterial*)self)->getParameterBlob(index)));
	}
	TS_CAPI TS_MeshMaterialFlags TS_CCALL tsMeshMaterial_getParameterFlags_cs(TSMeshMaterial self, const char *type) {
		TS_ASSERT(self);
		return (TS_MeshMaterialFlags)((MeshMaterial*)self)->getParameterFlags(type);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_hasParameterFlag_csMMF(TSMeshMaterial self, const char *type, TS_MeshMaterialFlags flags) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->hasParameterFlag(type, (MeshMaterial::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_hasParameterFlags_csMMF(TSMeshMaterial self, const char *type, TS_MeshMaterialFlags flags) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->hasParameterFlags(type, (MeshMaterial::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshMaterial_getParameterBool_csb(TSMeshMaterial self, const char *type, bool_t value) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getParameterBool(type, (bool)value);
	}
	TS_CAPI float32_t TS_CCALL tsMeshMaterial_getParameterScalarf32_csf(TSMeshMaterial self, const char *type, float32_t value) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getParameterScalarf32(type, value);
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshMaterial_getParameterVector4f_cscV4(TSMeshMaterial self, const char *type, const TSVector4f *vector) {
		TS_ASSERT(self);
		TS_ASSERT(vector);
		const Vector4f ret = ((MeshMaterial*)self)->getParameterVector4f(type, *(const Vector4f*)vector);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI TSMatrix3x2f TS_CCALL tsMeshMaterial_getParameterMatrix3x2f_cscM32(TSMeshMaterial self, const char *type, const TSMatrix3x2f *matrix) {
		TS_ASSERT(self);
		TS_ASSERT(matrix);
		const Matrix3x2f ret = ((MeshMaterial*)self)->getParameterMatrix3x2f(type, *(const Matrix3x2f*)matrix);
		return *(TSMatrix3x2f*)&ret;
	}
	TS_CAPI TSColor TS_CCALL tsMeshMaterial_getParameterColor_cscC(TSMeshMaterial self, const char *type, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		const Color ret = ((MeshMaterial*)self)->getParameterColor(type, *(const Color*)color);
		return *(TSColor*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getParameterName_cscS(TSMeshMaterial self, const char *type, const TSString name) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getParameterName(type, (name) ? *(const String*)name : String::null)));
	}
	TS_CAPI TSString TS_CCALL tsMeshMaterial_getParameterLayout_cscS(TSMeshMaterial self, const char *type, const TSString layout) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshMaterial*)self)->getParameterLayout(type, (layout) ? *(const String*)layout : String::null)));
	}
	TS_CAPI int32_t TS_CCALL tsMeshMaterial_compare(TSMeshMaterial self, const TSMeshMaterial material) {
		TS_ASSERT(self);
		TS_ASSERT(material);
		return ((MeshMaterial*)self)->compare(*(const MeshMaterial*)material);
	}
	TS_CAPI size_t TS_CCALL tsMeshMaterial_getMemory(TSMeshMaterial self) {
		TS_ASSERT(self);
		return ((MeshMaterial*)self)->getMemory();
	}
	TS_CAPI const char* tsMeshMaterialTypeBump = MeshMaterial::TypeBump;
	TS_CAPI const char* tsMeshMaterialTypeHeight = MeshMaterial::TypeHeight;
	TS_CAPI const char* tsMeshMaterialTypeNormal = MeshMaterial::TypeNormal;
	TS_CAPI const char* tsMeshMaterialTypeEmission = MeshMaterial::TypeEmission;
	TS_CAPI const char* tsMeshMaterialTypeOcclusion = MeshMaterial::TypeOcclusion;
	TS_CAPI const char* tsMeshMaterialTypeOpacity = MeshMaterial::TypeOpacity;
	TS_CAPI const char* tsMeshMaterialTypeAmbient = MeshMaterial::TypeAmbient;
	TS_CAPI const char* tsMeshMaterialTypeDiffuse = MeshMaterial::TypeDiffuse;
	TS_CAPI const char* tsMeshMaterialTypeSpecular = MeshMaterial::TypeSpecular;
	TS_CAPI const char* tsMeshMaterialTypeMetallic = MeshMaterial::TypeMetallic;
	TS_CAPI const char* tsMeshMaterialTypeRoughness = MeshMaterial::TypeRoughness;
	TS_CAPI const char* tsMeshMaterialTypeShininess = MeshMaterial::TypeShininess;
	TS_CAPI const char* tsMeshMaterialTypeGlossiness = MeshMaterial::TypeGlossiness;
	TS_CAPI const char* tsMeshMaterialTypeTransparent = MeshMaterial::TypeTransparent;
	TS_CAPI const char* tsMeshMaterialTypeTransparency = MeshMaterial::TypeTransparency;
	TS_CAPI const char* tsMeshMaterialTypeTransmission = MeshMaterial::TypeTransmission;
	TS_CAPI const char* tsMeshMaterialTypeReflective = MeshMaterial::TypeReflective;
	TS_CAPI const char* tsMeshMaterialTypeReflectivity = MeshMaterial::TypeReflectivity;
	TS_CAPI const char* tsMeshMaterialTypeRefractiveIndex = MeshMaterial::TypeRefractiveIndex;
	TS_CAPI const char* tsMeshMaterialTypeClearcoat = MeshMaterial::TypeClearcoat;
	TS_CAPI const char* tsMeshMaterialTypeClearcoatNormal = MeshMaterial::TypeClearcoatNormal;
	TS_CAPI const char* tsMeshMaterialTypeClearcoatRoughness = MeshMaterial::TypeClearcoatRoughness;
	TS_CAPI const char* tsMeshMaterialTypeClearcoatGlossiness = MeshMaterial::TypeClearcoatGlossiness;
	TS_CAPI const char* tsMeshMaterialTypeIridescence = MeshMaterial::TypeIridescence;
	TS_CAPI const char* tsMeshMaterialTypeIridescenceThickness = MeshMaterial::TypeIridescenceThickness;
	TS_CAPI const char* tsMeshMaterialTypeIridescenceRefractiveIndex = MeshMaterial::TypeIridescenceRefractiveIndex;
	TS_CAPI const char* tsMeshMaterialTypeSheen = MeshMaterial::TypeSheen;
	TS_CAPI const char* tsMeshMaterialTypeSheenRoughness = MeshMaterial::TypeSheenRoughness;
	TS_CAPI const char* tsMeshMaterialTypeVolume = MeshMaterial::TypeVolume;
	TS_CAPI const char* tsMeshMaterialTypeVolumeThickness = MeshMaterial::TypeVolumeThickness;
	TS_CAPI const char* tsMeshMaterialTypeAnisotropy = MeshMaterial::TypeAnisotropy;
	TS_CAPI const char* tsMeshMaterialTypeAnisotropyAngle = MeshMaterial::TypeAnisotropyAngle;
	TS_CAPI const char* tsMeshMaterialTypeDoubleSided = MeshMaterial::TypeDoubleSided;
	TS_CAPI const char* tsMeshMaterialTypeAlphaBlend = MeshMaterial::TypeAlphaBlend;
	TS_CAPI const char* tsMeshMaterialTypeAlphaMask = MeshMaterial::TypeAlphaMask;
	TS_CAPI const char* tsMeshMaterialTypeTechnique = MeshMaterial::TypeTechnique;
	TS_CAPI const char* tsMeshMaterialTypeTexCoord = MeshMaterial::TypeTexCoord;
	
	// Tellusim::MeshGeometry
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_new_s(const char *name) {
		MeshGeometry *ret = new MeshGeometry(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshGeometry)ret;
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_new_Ms(TSMesh mesh, const char *name) {
		TS_ASSERT(mesh);
		MeshGeometry *ret = new MeshGeometry(*(Mesh*)mesh, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshGeometry)ret;
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_delete(TSMeshGeometry self) {
		if(self) delete (MeshGeometry*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_equalPtr(const TSMeshGeometry self, const TSMeshGeometry ptr) {
		return (self && ptr && ((MeshGeometry*)self)->operator==(*(MeshGeometry*)ptr));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_copyPtr(TSMeshGeometry self) {
		MeshGeometry *ret = nullptr;
		if(self) ret = new MeshGeometry(*(MeshGeometry*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshGeometry)ret;
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_clonePtr(const TSMeshGeometry self) {
		MeshGeometry *ret = (self) ? new MeshGeometry(((MeshGeometry*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshGeometry)ret;
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_clearPtr(TSMeshGeometry self) {
		if(self) ((MeshGeometry*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_destroyPtr(TSMeshGeometry self) {
		if(self) ((MeshGeometry*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_acquirePtr(TSMeshGeometry self) {
		if(self) ((MeshGeometry*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_unacquirePtr(TSMeshGeometry self) {
		if(self) ((MeshGeometry*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_isValidPtr(const TSMeshGeometry self) {
		return (self && ((MeshGeometry*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_isOwnerPtr(const TSMeshGeometry self) {
		return (self && ((MeshGeometry*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_isConstPtr(const TSMeshGeometry self) {
		return (self && ((MeshGeometry*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getCountPtr(const TSMeshGeometry self) {
		return ((MeshGeometry*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshGeometry_getInternalPtr(const TSMeshGeometry self) {
		return ((MeshGeometry*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_clear(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setName(TSMeshGeometry self, const char *name) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshGeometry_getName(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshGeometry*)self)->getName()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getIndex(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setMesh(TSMeshGeometry self, TSMesh mesh, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(mesh);
		((MeshGeometry*)self)->setMesh(*(Mesh*)mesh, (bool)check);
	}
	TS_CAPI TSMesh TS_CCALL tsMeshGeometry_getMesh_c(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSMesh)(new Mesh(((MeshGeometry*)self)->getMesh()));
	}
	TS_CAPI TSMesh TS_CCALL tsMeshGeometry_getMesh(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSMesh)(new Mesh(((MeshGeometry*)self)->getMesh()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_setParent0(TSMeshGeometry self, TSMeshGeometry parent, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((MeshGeometry*)self)->setParent0(*(MeshGeometry*)parent, (bool)check);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_setParent1(TSMeshGeometry self, TSMeshGeometry parent, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((MeshGeometry*)self)->setParent1(*(MeshGeometry*)parent, (bool)check);
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_getParent0_c(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshGeometry*)self)->getParent0()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_getParent1_c(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshGeometry*)self)->getParent1()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_getParent0(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshGeometry*)self)->getParent0()));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_getParent1(TSMeshGeometry self) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshGeometry*)self)->getParent1()));
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_isRoot(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->isRoot();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_reserveChildren(TSMeshGeometry self, uint32_t num_children) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->reserveChildren(num_children);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addChild0(TSMeshGeometry self, TSMeshGeometry child, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshGeometry*)self)->addChild0(*(MeshGeometry*)child, (bool)check);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addChild1(TSMeshGeometry self, TSMeshGeometry child, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshGeometry*)self)->addChild1(*(MeshGeometry*)child, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_removeChild(TSMeshGeometry self, TSMeshGeometry child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshGeometry*)self)->removeChild(*(MeshGeometry*)child);
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_releaseChildren(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->releaseChildren();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findChild(TSMeshGeometry self, const TSMeshGeometry child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((MeshGeometry*)self)->findChild(*(const MeshGeometry*)child);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumChildren(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumChildren();
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_getChild_cu(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshGeometry*)self)->getChild(index)));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMeshGeometry_getChild_u(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((MeshGeometry*)self)->getChild(index)));
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_clearIndices(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->clearIndices();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_reserveIndices(TSMeshGeometry self, uint32_t num_indices) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->reserveIndices(num_indices);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addIndices(TSMeshGeometry self, TSMeshIndices indices, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->addIndices(*(MeshIndices*)indices, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_removeIndices(TSMeshGeometry self, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->removeIndices(*(MeshIndices*)indices);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_replaceIndices(TSMeshGeometry self, TSMeshIndices old_indices, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(old_indices);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->replaceIndices(*(MeshIndices*)old_indices, *(MeshIndices*)indices);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findIndices_ccMI(TSMeshGeometry self, const TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->findIndices(*(const MeshIndices*)indices);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findIndices_cMIT(TSMeshGeometry self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->findIndices((MeshIndices::Type)type);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasIndices(TSMeshGeometry self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->hasIndices((MeshIndices::Type)type);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasSolidIndices(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->hasSolidIndices();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumIndices_cMIT(TSMeshGeometry self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumIndices((MeshIndices::Type)type);
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshGeometry_getIndices_cMIT(TSMeshGeometry self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshGeometry*)self)->getIndices((MeshIndices::Type)type)));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshGeometry_getIndices_MIT(TSMeshGeometry self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshGeometry*)self)->getIndices((MeshIndices::Type)type)));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumIndices_c(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumIndices();
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshGeometry_getIndices_cu(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshGeometry*)self)->getIndices(index)));
	}
	TS_CAPI TSMeshIndices TS_CCALL tsMeshGeometry_getIndices_u(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshIndices)(new MeshIndices(((MeshGeometry*)self)->getIndices(index)));
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_clearAttributes(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->clearAttributes();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_reserveAttributes(TSMeshGeometry self, uint32_t num_attributes) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->reserveAttributes(num_attributes);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addAttribute_MAb(TSMeshGeometry self, TSMeshAttribute attribute, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		return ((MeshGeometry*)self)->addAttribute(*(MeshAttribute*)attribute, (bool)check);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addAttribute_MAMIb(TSMeshGeometry self, TSMeshAttribute attribute, TSMeshIndices indices, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->addAttribute(*(MeshAttribute*)attribute, *(MeshIndices*)indices, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_removeAttribute(TSMeshGeometry self, TSMeshAttribute attribute) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		return ((MeshGeometry*)self)->removeAttribute(*(MeshAttribute*)attribute);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_replaceAttribute(TSMeshGeometry self, TSMeshAttribute old_attribute, TSMeshAttribute attribute) {
		TS_ASSERT(self);
		TS_ASSERT(old_attribute);
		TS_ASSERT(attribute);
		return ((MeshGeometry*)self)->replaceAttribute(*(MeshAttribute*)old_attribute, *(MeshAttribute*)attribute);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_replaceAttributeIndices(TSMeshGeometry self, const TSMeshIndices old_indices, TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(old_indices);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->replaceAttributeIndices(*(const MeshIndices*)old_indices, *(MeshIndices*)indices);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findAttribute_cMATFu(TSMeshGeometry self, TS_MeshAttributeType type, TS_Format format, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->findAttribute((MeshAttribute::Type)type, (Format)format, index);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findAttribute_cMATu(TSMeshGeometry self, TS_MeshAttributeType type, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->findAttribute((MeshAttribute::Type)type, index);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findAttribute_csu(TSMeshGeometry self, const char *name, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->findAttribute(name, index);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findAttribute_ccMA(TSMeshGeometry self, const TSMeshAttribute attribute) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		return ((MeshGeometry*)self)->findAttribute(*(const MeshAttribute*)attribute);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasAttribute_cMATFu(TSMeshGeometry self, TS_MeshAttributeType type, TS_Format format, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->hasAttribute((MeshAttribute::Type)type, (Format)format, index);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasAttribute_cMATu(TSMeshGeometry self, TS_MeshAttributeType type, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->hasAttribute((MeshAttribute::Type)type, index);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasAttribute_csu(TSMeshGeometry self, const char *name, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->hasAttribute(name, index);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasAttribute_ccMA(TSMeshGeometry self, const TSMeshAttribute attribute) {
		TS_ASSERT(self);
		TS_ASSERT(attribute);
		return ((MeshGeometry*)self)->hasAttribute(*(const MeshAttribute*)attribute);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumAttributes_cMAT(TSMeshGeometry self, TS_MeshAttributeType type) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumAttributes((MeshAttribute::Type)type);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumAttributes_ccMI(TSMeshGeometry self, const TSMeshIndices indices) {
		TS_ASSERT(self);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->getNumAttributes(*(const MeshIndices*)indices);
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshGeometry_getAttribute_cMATu(TSMeshGeometry self, TS_MeshAttributeType type, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAttribute)(new MeshAttribute(((MeshGeometry*)self)->getAttribute((MeshAttribute::Type)type, index)));
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshGeometry_getAttribute_MATu(TSMeshGeometry self, TS_MeshAttributeType type, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAttribute)(new MeshAttribute(((MeshGeometry*)self)->getAttribute((MeshAttribute::Type)type, index)));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumAttributes_c(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumAttributes();
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshGeometry_getAttribute_cu(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAttribute)(new MeshAttribute(((MeshGeometry*)self)->getAttribute(index)));
	}
	TS_CAPI TSMeshAttribute TS_CCALL tsMeshGeometry_getAttribute_u(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAttribute)(new MeshAttribute(((MeshGeometry*)self)->getAttribute(index)));
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_clearJoints(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->clearJoints();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_reserveJoints(TSMeshGeometry self, uint32_t num_joints) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->reserveJoints(num_joints);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addJoint_MJb(TSMeshGeometry self, TSMeshJoint joint, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		return ((MeshGeometry*)self)->addJoint(*(MeshJoint*)joint, (bool)check);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addJoint_MJMNb(TSMeshGeometry self, TSMeshJoint joint, TSMeshNode node, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		TS_ASSERT(node);
		return ((MeshGeometry*)self)->addJoint(*(MeshJoint*)joint, *(MeshNode*)node, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_removeJoint(TSMeshGeometry self, TSMeshJoint joint) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		return ((MeshGeometry*)self)->removeJoint(*(MeshJoint*)joint);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_replaceJoint(TSMeshGeometry self, TSMeshJoint old_joint, TSMeshJoint joint) {
		TS_ASSERT(self);
		TS_ASSERT(old_joint);
		TS_ASSERT(joint);
		return ((MeshGeometry*)self)->replaceJoint(*(MeshJoint*)old_joint, *(MeshJoint*)joint);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findJoint_ccMJ(TSMeshGeometry self, const TSMeshJoint joint) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		return ((MeshGeometry*)self)->findJoint(*(const MeshJoint*)joint);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findJoint_ccMN(TSMeshGeometry self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		return ((MeshGeometry*)self)->findJoint(*(const MeshNode*)node);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findJoint_cs(TSMeshGeometry self, const char *name) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->findJoint(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumJoints(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumJoints();
	}
	TS_CAPI TSMeshJoint TS_CCALL tsMeshGeometry_getJoint_cu(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshJoint)(new MeshJoint(((MeshGeometry*)self)->getJoint(index)));
	}
	TS_CAPI TSMeshJoint TS_CCALL tsMeshGeometry_getJoint_u(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshJoint)(new MeshJoint(((MeshGeometry*)self)->getJoint(index)));
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_clearMaterials(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->clearMaterials();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_reserveMaterials(TSMeshGeometry self, uint32_t num_materials) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->reserveMaterials(num_materials);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addMaterial_MMb(TSMeshGeometry self, TSMeshMaterial material, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(material);
		return ((MeshGeometry*)self)->addMaterial(*(MeshMaterial*)material, (bool)check);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_addMaterial_MMMIb(TSMeshGeometry self, TSMeshMaterial material, TSMeshIndices indices, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(material);
		TS_ASSERT(indices);
		return ((MeshGeometry*)self)->addMaterial(*(MeshMaterial*)material, *(MeshIndices*)indices, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_removeMaterial(TSMeshGeometry self, TSMeshMaterial material) {
		TS_ASSERT(self);
		TS_ASSERT(material);
		return ((MeshGeometry*)self)->removeMaterial(*(MeshMaterial*)material);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_replaceMaterial(TSMeshGeometry self, TSMeshMaterial old_material, TSMeshMaterial material) {
		TS_ASSERT(self);
		TS_ASSERT(old_material);
		TS_ASSERT(material);
		return ((MeshGeometry*)self)->replaceMaterial(*(MeshMaterial*)old_material, *(MeshMaterial*)material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findMaterial_ccMM(TSMeshGeometry self, const TSMeshMaterial material) {
		TS_ASSERT(self);
		TS_ASSERT(material);
		return ((MeshGeometry*)self)->findMaterial(*(const MeshMaterial*)material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_findMaterial_cs(TSMeshGeometry self, const char *name) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->findMaterial(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_getNumMaterials(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getNumMaterials();
	}
	TS_CAPI TSMeshMaterial TS_CCALL tsMeshGeometry_getMaterial_cu(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshMaterial)(new MeshMaterial(((MeshGeometry*)self)->getMaterial(index)));
	}
	TS_CAPI TSMeshMaterial TS_CCALL tsMeshGeometry_getMaterial_u(TSMeshGeometry self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshMaterial)(new MeshMaterial(((MeshGeometry*)self)->getMaterial(index)));
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setBoundBox(TSMeshGeometry self, const TSBoundBoxf *box) {
		TS_ASSERT(self);
		TS_ASSERT(box);
		((MeshGeometry*)self)->setBoundBox(*(const BoundBoxf*)box);
	}
	TS_CAPI TSBoundBoxf TS_CCALL tsMeshGeometry_getBoundBox(TSMeshGeometry self) {
		TS_ASSERT(self);
		const BoundBoxf ret = ((MeshGeometry*)self)->getBoundBox();
		return *(TSBoundBoxf*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setBoundSphere(TSMeshGeometry self, const TSBoundSpheref *sphere) {
		TS_ASSERT(self);
		TS_ASSERT(sphere);
		((MeshGeometry*)self)->setBoundSphere(*(const BoundSpheref*)sphere);
	}
	TS_CAPI TSBoundSpheref TS_CCALL tsMeshGeometry_getBoundSphere(TSMeshGeometry self) {
		TS_ASSERT(self);
		const BoundSpheref ret = ((MeshGeometry*)self)->getBoundSphere();
		return *(TSBoundSpheref*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_setTransform_cV3(TSMeshGeometry self, const TSVector3f *scale) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		return ((MeshGeometry*)self)->setTransform(*(const Vector3f*)scale);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_setTransform_cM43b(TSMeshGeometry self, const TSMatrix4x3f *transform, bool_t apply) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		return ((MeshGeometry*)self)->setTransform(*(const Matrix4x3f*)transform, (bool)apply);
	}
	TS_CAPI TSMatrix4x3f TS_CCALL tsMeshGeometry_getTransform(TSMeshGeometry self) {
		TS_ASSERT(self);
		const Matrix4x3f ret = ((MeshGeometry*)self)->getTransform();
		return *(TSMatrix4x3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setJointITransform(TSMeshGeometry self, const TSMatrix4x3f *itransform) {
		TS_ASSERT(self);
		TS_ASSERT(itransform);
		((MeshGeometry*)self)->setJointITransform(*(const Matrix4x3f*)itransform);
	}
	TS_CAPI TSMatrix4x3f TS_CCALL tsMeshGeometry_getJointITransform(TSMeshGeometry self) {
		TS_ASSERT(self);
		const Matrix4x3f ret = ((MeshGeometry*)self)->getJointITransform();
		return *(TSMatrix4x3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setMinVisibility(TSMeshGeometry self, float32_t distance) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->setMinVisibility(distance);
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setMaxVisibility(TSMeshGeometry self, float32_t distance) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->setMaxVisibility(distance);
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setVisibilityRange(TSMeshGeometry self, float32_t min, float32_t max) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->setVisibilityRange(min, max);
	}
	TS_CAPI float32_t TS_CCALL tsMeshGeometry_getMinVisibility(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getMinVisibility();
	}
	TS_CAPI float32_t TS_CCALL tsMeshGeometry_getMaxVisibility(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getMaxVisibility();
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_hasVisibilityRange(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->hasVisibilityRange();
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_setVisibilityError(TSMeshGeometry self, float32_t error) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->setVisibilityError(error);
	}
	TS_CAPI float32_t TS_CCALL tsMeshGeometry_getVisibilityError(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getVisibilityError();
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_createBounds(TSMeshGeometry self, bool_t force, uint32_t position) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createBounds((bool)force, position);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_createBasis_buuub(TSMeshGeometry self, bool_t force, uint32_t position, uint32_t normal, uint32_t tangent, bool_t append) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createBasis((bool)force, position, normal, tangent, (bool)append);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_createBasis_fbuuub(TSMeshGeometry self, float32_t angle, bool_t force, uint32_t position, uint32_t normal, uint32_t tangent, bool_t append) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createBasis(angle, (bool)force, position, normal, tangent, (bool)append);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_createNormals_bub(TSMeshGeometry self, bool_t force, uint32_t position, bool_t append) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createNormals((bool)force, position, (bool)append);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_createNormals_fbub(TSMeshGeometry self, float32_t angle, bool_t force, uint32_t position, bool_t append) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createNormals(angle, (bool)force, position, (bool)append);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_createTangents(TSMeshGeometry self, bool_t force, uint32_t position, uint32_t normal, uint32_t texcoord, bool_t append) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createTangents((bool)force, position, normal, texcoord, (bool)append);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshGeometry_createIslands(TSMeshGeometry self, uint32_t max_attributes, uint32_t max_primitives, bool_t force, uint32_t index, uint32_t position, bool_t append) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->createIslands(max_attributes, max_primitives, (bool)force, index, position, (bool)append);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_optimizeIndices(TSMeshGeometry self, uint32_t cache, bool_t transparent, uint32_t index, uint32_t position) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->optimizeIndices(cache, (bool)transparent, index, position);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_optimizeAttributes(TSMeshGeometry self, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->optimizeAttributes(material);
	}
	TS_CAPI void TS_CCALL tsMeshGeometry_optimizeMaterials(TSMeshGeometry self) {
		TS_ASSERT(self);
		((MeshGeometry*)self)->optimizeMaterials();
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_packAttributes(TSMeshGeometry self, bool_t remove) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->packAttributes((bool)remove);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_unpackAttributes(TSMeshGeometry self, bool_t remove) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->unpackAttributes((bool)remove);
	}
	TS_CAPI int32_t TS_CCALL tsMeshGeometry_compare(TSMeshGeometry self, const TSMeshGeometry geometry, const TSMatrix4x3f *transform, float32_t threshold, bool_t spatial) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		TS_ASSERT(transform);
		return ((MeshGeometry*)self)->compare(*(const MeshGeometry*)geometry, *(const Matrix4x3f*)transform, threshold, (bool)spatial);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_isOptimized(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->isOptimized();
	}
	TS_CAPI bool_t TS_CCALL tsMeshGeometry_validate(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->validate();
	}
	TS_CAPI size_t TS_CCALL tsMeshGeometry_getMemory(TSMeshGeometry self) {
		TS_ASSERT(self);
		return ((MeshGeometry*)self)->getMemory();
	}
	
	// Tellusim::MeshTransform
	TS_CAPI TSMeshTransform TS_CCALL tsMeshTransform_new(void) {
		MeshTransform *ret = new MeshTransform();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshTransform)ret;
	}
	TS_CAPI void TS_CCALL tsMeshTransform_delete(TSMeshTransform self) {
		if(self) delete (MeshTransform*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_equalPtr(const TSMeshTransform self, const TSMeshTransform ptr) {
		return (self && ptr && ((MeshTransform*)self)->operator==(*(MeshTransform*)ptr));
	}
	TS_CAPI TSMeshTransform TS_CCALL tsMeshTransform_copyPtr(TSMeshTransform self) {
		MeshTransform *ret = nullptr;
		if(self) ret = new MeshTransform(*(MeshTransform*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshTransform)ret;
	}
	TS_CAPI TSMeshTransform TS_CCALL tsMeshTransform_clonePtr(const TSMeshTransform self) {
		MeshTransform *ret = (self) ? new MeshTransform(((MeshTransform*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshTransform)ret;
	}
	TS_CAPI void TS_CCALL tsMeshTransform_clearPtr(TSMeshTransform self) {
		if(self) ((MeshTransform*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshTransform_destroyPtr(TSMeshTransform self) {
		if(self) ((MeshTransform*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshTransform_acquirePtr(TSMeshTransform self) {
		if(self) ((MeshTransform*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshTransform_unacquirePtr(TSMeshTransform self) {
		if(self) ((MeshTransform*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_isValidPtr(const TSMeshTransform self) {
		return (self && ((MeshTransform*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_isOwnerPtr(const TSMeshTransform self) {
		return (self && ((MeshTransform*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_isConstPtr(const TSMeshTransform self) {
		return (self && ((MeshTransform*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshTransform_getCountPtr(const TSMeshTransform self) {
		return ((MeshTransform*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshTransform_getInternalPtr(const TSMeshTransform self) {
		return ((MeshTransform*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshTransform_clear(TSMeshTransform self) {
		TS_ASSERT(self);
		((MeshTransform*)self)->clear();
	}
	TS_CAPI float64_t TS_CCALL tsMeshTransform_getMinTime(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->getMinTime();
	}
	TS_CAPI float64_t TS_CCALL tsMeshTransform_getMaxTime(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->getMaxTime();
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setTransform_f64cM43f(TSMeshTransform self, float64_t time, const TSMatrix4x3d *transform, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshTransform*)self)->setTransform(time, *(const Matrix4x3d*)transform, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setTranslate(TSMeshTransform self, float64_t time, const TSVector3d *translate, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(translate);
		((MeshTransform*)self)->setTranslate(time, *(const Vector3d*)translate, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setRotate(TSMeshTransform self, float64_t time, const TSQuaternionf *rotate, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(rotate);
		((MeshTransform*)self)->setRotate(time, *(const Quaternionf*)rotate, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setScale(TSMeshTransform self, float64_t time, const TSVector3f *scale, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		((MeshTransform*)self)->setScale(time, *(const Vector3f*)scale, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setMorph(TSMeshTransform self, float64_t time, const TSVector4f *morph, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(morph);
		((MeshTransform*)self)->setMorph(time, *(const Vector4f*)morph, threshold);
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshTransform_getTransform(TSMeshTransform self, float64_t time) {
		TS_ASSERT(self);
		Matrix4x3d ret = ((MeshTransform*)self)->getTransform(time);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSVector3d TS_CCALL tsMeshTransform_getTranslate(TSMeshTransform self, float64_t time) {
		TS_ASSERT(self);
		Vector3d ret = ((MeshTransform*)self)->getTranslate(time);
		return *(TSVector3d*)&ret;
	}
	TS_CAPI TSQuaternionf TS_CCALL tsMeshTransform_getRotate(TSMeshTransform self, float64_t time) {
		TS_ASSERT(self);
		Quaternionf ret = ((MeshTransform*)self)->getRotate(time);
		return *(TSQuaternionf*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsMeshTransform_getScale(TSMeshTransform self, float64_t time) {
		TS_ASSERT(self);
		Vector3f ret = ((MeshTransform*)self)->getScale(time);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshTransform_getMorph(TSMeshTransform self, float64_t time) {
		TS_ASSERT(self);
		Vector4f ret = ((MeshTransform*)self)->getMorph(time);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_hasTransformKeys(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->hasTransformKeys();
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_hasTranslateKeys(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->hasTranslateKeys();
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_hasRotateKeys(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->hasRotateKeys();
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_hasScaleKeys(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->hasScaleKeys();
	}
	TS_CAPI bool_t TS_CCALL tsMeshTransform_hasMorphKeys(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->hasMorphKeys();
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setTransform_cV3(TSMeshTransform self, const TSVector3d *scale) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		((MeshTransform*)self)->setTransform(*(const Vector3d*)scale);
	}
	TS_CAPI void TS_CCALL tsMeshTransform_setTransform_cM43(TSMeshTransform self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshTransform*)self)->setTransform(*(const Matrix4x3d*)transform);
	}
	TS_CAPI size_t TS_CCALL tsMeshTransform_getMemory(TSMeshTransform self) {
		TS_ASSERT(self);
		return ((MeshTransform*)self)->getMemory();
	}
	
	// Tellusim::MeshAnimation
	TS_CAPI TSMeshAnimation TS_CCALL tsMeshAnimation_new_s(const char *name) {
		MeshAnimation *ret = new MeshAnimation(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAnimation)ret;
	}
	TS_CAPI TSMeshAnimation TS_CCALL tsMeshAnimation_new_Ms(TSMesh mesh, const char *name) {
		TS_ASSERT(mesh);
		MeshAnimation *ret = new MeshAnimation(*(Mesh*)mesh, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAnimation)ret;
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_delete(TSMeshAnimation self) {
		if(self) delete (MeshAnimation*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshAnimation_equalPtr(const TSMeshAnimation self, const TSMeshAnimation ptr) {
		return (self && ptr && ((MeshAnimation*)self)->operator==(*(MeshAnimation*)ptr));
	}
	TS_CAPI TSMeshAnimation TS_CCALL tsMeshAnimation_copyPtr(TSMeshAnimation self) {
		MeshAnimation *ret = nullptr;
		if(self) ret = new MeshAnimation(*(MeshAnimation*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAnimation)ret;
	}
	TS_CAPI TSMeshAnimation TS_CCALL tsMeshAnimation_clonePtr(const TSMeshAnimation self) {
		MeshAnimation *ret = (self) ? new MeshAnimation(((MeshAnimation*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAnimation)ret;
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_clearPtr(TSMeshAnimation self) {
		if(self) ((MeshAnimation*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_destroyPtr(TSMeshAnimation self) {
		if(self) ((MeshAnimation*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_acquirePtr(TSMeshAnimation self) {
		if(self) ((MeshAnimation*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_unacquirePtr(TSMeshAnimation self) {
		if(self) ((MeshAnimation*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAnimation_isValidPtr(const TSMeshAnimation self) {
		return (self && ((MeshAnimation*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshAnimation_isOwnerPtr(const TSMeshAnimation self) {
		return (self && ((MeshAnimation*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshAnimation_isConstPtr(const TSMeshAnimation self) {
		return (self && ((MeshAnimation*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAnimation_getCountPtr(const TSMeshAnimation self) {
		return ((MeshAnimation*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshAnimation_getInternalPtr(const TSMeshAnimation self) {
		return ((MeshAnimation*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_clear(TSMeshAnimation self) {
		TS_ASSERT(self);
		((MeshAnimation*)self)->clear();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAnimation_getIndex(TSMeshAnimation self) {
		TS_ASSERT(self);
		return ((MeshAnimation*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setName(TSMeshAnimation self, const char *name) {
		TS_ASSERT(self);
		((MeshAnimation*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshAnimation_getName(TSMeshAnimation self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAnimation*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setMesh(TSMeshAnimation self, TSMesh mesh, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(mesh);
		((MeshAnimation*)self)->setMesh(*(Mesh*)mesh, (bool)check);
	}
	TS_CAPI TSMesh TS_CCALL tsMeshAnimation_getMesh_c(TSMeshAnimation self) {
		TS_ASSERT(self);
		return (TSMesh)(new Mesh(((MeshAnimation*)self)->getMesh()));
	}
	TS_CAPI TSMesh TS_CCALL tsMeshAnimation_getMesh(TSMeshAnimation self) {
		TS_ASSERT(self);
		return (TSMesh)(new Mesh(((MeshAnimation*)self)->getMesh()));
	}
	TS_CAPI float64_t TS_CCALL tsMeshAnimation_getMinTime(TSMeshAnimation self) {
		TS_ASSERT(self);
		return ((MeshAnimation*)self)->getMinTime();
	}
	TS_CAPI float64_t TS_CCALL tsMeshAnimation_getMaxTime(TSMeshAnimation self) {
		TS_ASSERT(self);
		return ((MeshAnimation*)self)->getMaxTime();
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setNumTransforms(TSMeshAnimation self, uint32_t num_transforms) {
		TS_ASSERT(self);
		((MeshAnimation*)self)->setNumTransforms(num_transforms);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAnimation_getNumTransforms(TSMeshAnimation self) {
		TS_ASSERT(self);
		return ((MeshAnimation*)self)->getNumTransforms();
	}
	TS_CAPI TSMeshTransform TS_CCALL tsMeshAnimation_getTransform_cu(TSMeshAnimation self, uint32_t node) {
		TS_ASSERT(self);
		return (TSMeshTransform)(new MeshTransform(((MeshAnimation*)self)->getTransform(node)));
	}
	TS_CAPI TSMeshTransform TS_CCALL tsMeshAnimation_getTransform_u(TSMeshAnimation self, uint32_t node) {
		TS_ASSERT(self);
		return (TSMeshTransform)(new MeshTransform(((MeshAnimation*)self)->getTransform(node)));
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setTransform_f64ucM43f(TSMeshAnimation self, float64_t time, uint32_t node, const TSMatrix4x3d *transform, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshAnimation*)self)->setTransform(time, node, *(const Matrix4x3d*)transform, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setTranslate(TSMeshAnimation self, float64_t time, uint32_t node, const TSVector3d *translate, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(translate);
		((MeshAnimation*)self)->setTranslate(time, node, *(const Vector3d*)translate, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setRotate(TSMeshAnimation self, float64_t time, uint32_t node, const TSQuaternionf *rotate, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(rotate);
		((MeshAnimation*)self)->setRotate(time, node, *(const Quaternionf*)rotate, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setScale(TSMeshAnimation self, float64_t time, uint32_t node, const TSVector3f *scale, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		((MeshAnimation*)self)->setScale(time, node, *(const Vector3f*)scale, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setMorph(TSMeshAnimation self, float64_t time, uint32_t node, const TSVector4f *morph, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(morph);
		((MeshAnimation*)self)->setMorph(time, node, *(const Vector4f*)morph, threshold);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setTime_f64cM43bf64f64(TSMeshAnimation self, float64_t time, const TSMatrix4x3d *transform, bool_t loop, float64_t from, float64_t to) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshAnimation*)self)->setTime(time, *(const Matrix4x3d*)transform, (bool)loop, from, to);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setTime_f64bf64f64(TSMeshAnimation self, float64_t time, bool_t loop, float64_t from, float64_t to) {
		TS_ASSERT(self);
		((MeshAnimation*)self)->setTime(time, (bool)loop, from, to);
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshAnimation_getLocalTransform_cu(TSMeshAnimation self, uint32_t node) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshAnimation*)self)->getLocalTransform(node);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshAnimation_getLocalTransform_ccMN(TSMeshAnimation self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		const Matrix4x3d ret = ((MeshAnimation*)self)->getLocalTransform(*(const MeshNode*)node);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshAnimation_getLocalTransform_ccMJ(TSMeshAnimation self, const TSMeshJoint joint) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		const Matrix4x3d ret = ((MeshAnimation*)self)->getLocalTransform(*(const MeshJoint*)joint);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshAnimation_getGlobalTransform_cu(TSMeshAnimation self, uint32_t node) {
		TS_ASSERT(self);
		const Matrix4x3d ret = ((MeshAnimation*)self)->getGlobalTransform(node);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshAnimation_getGlobalTransform_ccMN(TSMeshAnimation self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		const Matrix4x3d ret = ((MeshAnimation*)self)->getGlobalTransform(*(const MeshNode*)node);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSMatrix4x3d TS_CCALL tsMeshAnimation_getGlobalTransform_ccMJ(TSMeshAnimation self, const TSMeshJoint joint) {
		TS_ASSERT(self);
		TS_ASSERT(joint);
		const Matrix4x3d ret = ((MeshAnimation*)self)->getGlobalTransform(*(const MeshJoint*)joint);
		return *(TSMatrix4x3d*)&ret;
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshAnimation_getMorphTransform_cu(TSMeshAnimation self, uint32_t node) {
		TS_ASSERT(self);
		const Vector4f ret = ((MeshAnimation*)self)->getMorphTransform(node);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshAnimation_getMorphTransform_ccMN(TSMeshAnimation self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		const Vector4f ret = ((MeshAnimation*)self)->getMorphTransform(*(const MeshNode*)node);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMeshAnimation_getBoundBox_c(TSMeshAnimation self) {
		TS_ASSERT(self);
		BoundBoxd ret = ((MeshAnimation*)self)->getBoundBox();
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMeshAnimation_getBoundBox_ccMN(TSMeshAnimation self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		BoundBoxd ret = ((MeshAnimation*)self)->getBoundBox(*(const MeshNode*)node);
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMeshAnimation_getBoundBox_ccMG(TSMeshAnimation self, const TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		BoundBoxd ret = ((MeshAnimation*)self)->getBoundBox(*(const MeshGeometry*)geometry);
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMeshAnimation_getBoundBox_ccMGcV4(TSMeshAnimation self, const TSMeshGeometry geometry, const TSVector4f *morph) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		TS_ASSERT(morph);
		BoundBoxd ret = ((MeshAnimation*)self)->getBoundBox(*(const MeshGeometry*)geometry, *(const Vector4f*)morph);
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setTransform_cV3(TSMeshAnimation self, const TSVector3d *scale) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		((MeshAnimation*)self)->setTransform(*(const Vector3d*)scale);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_setTransform_cM43(TSMeshAnimation self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshAnimation*)self)->setTransform(*(const Matrix4x3d*)transform);
	}
	TS_CAPI void TS_CCALL tsMeshAnimation_optimizeTransforms(TSMeshAnimation self, float32_t threshold) {
		TS_ASSERT(self);
		((MeshAnimation*)self)->optimizeTransforms(threshold);
	}
	TS_CAPI size_t TS_CCALL tsMeshAnimation_getMemory(TSMeshAnimation self) {
		TS_ASSERT(self);
		return ((MeshAnimation*)self)->getMemory();
	}
	
	// Tellusim::MeshAttachment
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshAttachment_new_s(const char *name) {
		MeshAttachment *ret = new MeshAttachment(name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttachment)ret;
	}
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshAttachment_new_MATs(TS_MeshAttachmentType type, const char *name) {
		MeshAttachment *ret = new MeshAttachment((MeshAttachment::Type)type, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttachment)ret;
	}
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshAttachment_new_MNs(TSMeshNode node, const char *name) {
		TS_ASSERT(node);
		MeshAttachment *ret = new MeshAttachment(*(MeshNode*)node, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttachment)ret;
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_delete(TSMeshAttachment self) {
		if(self) delete (MeshAttachment*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_equalPtr(const TSMeshAttachment self, const TSMeshAttachment ptr) {
		return (self && ptr && ((MeshAttachment*)self)->operator==(*(MeshAttachment*)ptr));
	}
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshAttachment_copyPtr(TSMeshAttachment self) {
		MeshAttachment *ret = nullptr;
		if(self) ret = new MeshAttachment(*(MeshAttachment*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttachment)ret;
	}
	TS_CAPI TSMeshAttachment TS_CCALL tsMeshAttachment_clonePtr(const TSMeshAttachment self) {
		MeshAttachment *ret = (self) ? new MeshAttachment(((MeshAttachment*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMeshAttachment)ret;
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_clearPtr(TSMeshAttachment self) {
		if(self) ((MeshAttachment*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_destroyPtr(TSMeshAttachment self) {
		if(self) ((MeshAttachment*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_acquirePtr(TSMeshAttachment self) {
		if(self) ((MeshAttachment*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_unacquirePtr(TSMeshAttachment self) {
		if(self) ((MeshAttachment*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_isValidPtr(const TSMeshAttachment self) {
		return (self && ((MeshAttachment*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_isOwnerPtr(const TSMeshAttachment self) {
		return (self && ((MeshAttachment*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_isConstPtr(const TSMeshAttachment self) {
		return (self && ((MeshAttachment*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttachment_getCountPtr(const TSMeshAttachment self) {
		return ((MeshAttachment*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMeshAttachment_getInternalPtr(const TSMeshAttachment self) {
		return ((MeshAttachment*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_clear(TSMeshAttachment self) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->clear();
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setType(TSMeshAttachment self, TS_MeshAttachmentType type) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->setType((MeshAttachment::Type)type);
	}
	TS_CAPI TS_MeshAttachmentType TS_CCALL tsMeshAttachment_getType(TSMeshAttachment self) {
		TS_ASSERT(self);
		return (TS_MeshAttachmentType)((MeshAttachment*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsMeshAttachment_getTypeName_MAT(TS_MeshAttachmentType type) {
		return MeshAttachment::getTypeName((MeshAttachment::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsMeshAttachment_getTypeName_c(TSMeshAttachment self) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_isUnknown(TSMeshAttachment self) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->isUnknown();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_isLight(TSMeshAttachment self) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->isLight();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_isCamera(TSMeshAttachment self) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->isCamera();
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setName(TSMeshAttachment self, const char *name) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMeshAttachment_getName(TSMeshAttachment self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAttachment*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setNode(TSMeshAttachment self, TSMeshNode node, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		((MeshAttachment*)self)->setNode(*(MeshNode*)node, (bool)check);
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshAttachment_getNode_c(TSMeshAttachment self) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshAttachment*)self)->getNode()));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMeshAttachment_getNode(TSMeshAttachment self) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((MeshAttachment*)self)->getNode()));
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setData_s(TSMeshAttachment self, const char *data) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->setData(data);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setData_cS(TSMeshAttachment self, const TSString data) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->setData((data) ? *(const String*)data : String::null);
	}
	TS_CAPI TSString TS_CCALL tsMeshAttachment_getData(TSMeshAttachment self) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAttachment*)self)->getData()));
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_clearParameters(TSMeshAttachment self) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->clearParameters();
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_removeParameter(TSMeshAttachment self, const char *type) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->removeParameter(type);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_copyParameters(TSMeshAttachment self, const TSMeshAttachment attachment) {
		TS_ASSERT(self);
		TS_ASSERT(attachment);
		((MeshAttachment*)self)->copyParameters(*(const MeshAttachment*)attachment);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttachment_findParameter(TSMeshAttachment self, const char *type) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->findParameter(type);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_hasParameter(TSMeshAttachment self, const char *type) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->hasParameter(type);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshAttachment_getNumParameters(TSMeshAttachment self) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getNumParameters();
	}
	TS_CAPI TSString TS_CCALL tsMeshAttachment_getParameterType(TSMeshAttachment self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAttachment*)self)->getParameterType(index)));
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_addParameter_sb(TSMeshAttachment self, const char *type, bool_t value) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->addParameter(type, (bool)value);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_addParameter_sf(TSMeshAttachment self, const char *type, float32_t value) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->addParameter(type, value);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_addParameter_scV4(TSMeshAttachment self, const char *type, const TSVector4f *vector) {
		TS_ASSERT(self);
		TS_ASSERT(vector);
		((MeshAttachment*)self)->addParameter(type, *(const Vector4f*)vector);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_addParameter_scC(TSMeshAttachment self, const char *type, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((MeshAttachment*)self)->addParameter(type, *(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_addParameter_ss(TSMeshAttachment self, const char *type, const char *name) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->addParameter(type, name);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_addParameter_scS(TSMeshAttachment self, const char *type, const TSString name) {
		TS_ASSERT(self);
		((MeshAttachment*)self)->addParameter(type, (name) ? *(const String*)name : String::null);
	}
	TS_CAPI TS_MeshAttachmentFlags TS_CCALL tsMeshAttachment_getParameterFlags_cu(TSMeshAttachment self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_MeshAttachmentFlags)((MeshAttachment*)self)->getParameterFlags(index);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_hasParameterFlag_cuMAF(TSMeshAttachment self, uint32_t index, TS_MeshAttachmentFlags flags) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->hasParameterFlag(index, (MeshAttachment::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_hasParameterFlags_cuMAF(TSMeshAttachment self, uint32_t index, TS_MeshAttachmentFlags flags) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->hasParameterFlags(index, (MeshAttachment::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_getParameterBool_cub(TSMeshAttachment self, uint32_t index, bool_t value) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getParameterBool(index, (bool)value);
	}
	TS_CAPI float32_t TS_CCALL tsMeshAttachment_getParameterScalarf32_cuf(TSMeshAttachment self, uint32_t index, float32_t value) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getParameterScalarf32(index, value);
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshAttachment_getParameterVector4f_cucV4(TSMeshAttachment self, uint32_t index, const TSVector4f *vector) {
		TS_ASSERT(self);
		TS_ASSERT(vector);
		const Vector4f ret = ((MeshAttachment*)self)->getParameterVector4f(index, *(const Vector4f*)vector);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI TSColor TS_CCALL tsMeshAttachment_getParameterColor_cucC(TSMeshAttachment self, uint32_t index, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		const Color ret = ((MeshAttachment*)self)->getParameterColor(index, *(const Color*)color);
		return *(TSColor*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsMeshAttachment_getParameterName_cucS(TSMeshAttachment self, uint32_t index, const TSString name) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAttachment*)self)->getParameterName(index, (name) ? *(const String*)name : String::null)));
	}
	TS_CAPI TS_MeshAttachmentFlags TS_CCALL tsMeshAttachment_getParameterFlags_cs(TSMeshAttachment self, const char *type) {
		TS_ASSERT(self);
		return (TS_MeshAttachmentFlags)((MeshAttachment*)self)->getParameterFlags(type);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_hasParameterFlag_csMAF(TSMeshAttachment self, const char *type, TS_MeshAttachmentFlags flags) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->hasParameterFlag(type, (MeshAttachment::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_hasParameterFlags_csMAF(TSMeshAttachment self, const char *type, TS_MeshAttachmentFlags flags) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->hasParameterFlags(type, (MeshAttachment::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshAttachment_getParameterBool_csb(TSMeshAttachment self, const char *type, bool_t value) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getParameterBool(type, (bool)value);
	}
	TS_CAPI float32_t TS_CCALL tsMeshAttachment_getParameterScalarf32_csf(TSMeshAttachment self, const char *type, float32_t value) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getParameterScalarf32(type, value);
	}
	TS_CAPI TSVector4f TS_CCALL tsMeshAttachment_getParameterVector4f_cscV4(TSMeshAttachment self, const char *type, const TSVector4f *vector) {
		TS_ASSERT(self);
		TS_ASSERT(vector);
		const Vector4f ret = ((MeshAttachment*)self)->getParameterVector4f(type, *(const Vector4f*)vector);
		return *(TSVector4f*)&ret;
	}
	TS_CAPI TSColor TS_CCALL tsMeshAttachment_getParameterColor_cscC(TSMeshAttachment self, const char *type, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		const Color ret = ((MeshAttachment*)self)->getParameterColor(type, *(const Color*)color);
		return *(TSColor*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsMeshAttachment_getParameterName_cscS(TSMeshAttachment self, const char *type, const TSString name) {
		TS_ASSERT(self);
		return (TSString)(new String(((MeshAttachment*)self)->getParameterName(type, (name) ? *(const String*)name : String::null)));
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setTransform_cV3(TSMeshAttachment self, const TSVector3f *scale) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		((MeshAttachment*)self)->setTransform(*(const Vector3f*)scale);
	}
	TS_CAPI void TS_CCALL tsMeshAttachment_setTransform_cM43(TSMeshAttachment self, const TSMatrix4x3f *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((MeshAttachment*)self)->setTransform(*(const Matrix4x3f*)transform);
	}
	TS_CAPI TSMatrix4x3f TS_CCALL tsMeshAttachment_getTransform(TSMeshAttachment self) {
		TS_ASSERT(self);
		const Matrix4x3f ret = ((MeshAttachment*)self)->getTransform();
		return *(TSMatrix4x3f*)&ret;
	}
	TS_CAPI int32_t TS_CCALL tsMeshAttachment_compare(TSMeshAttachment self, const TSMeshAttachment attachment) {
		TS_ASSERT(self);
		TS_ASSERT(attachment);
		return ((MeshAttachment*)self)->compare(*(const MeshAttachment*)attachment);
	}
	TS_CAPI size_t TS_CCALL tsMeshAttachment_getMemory(TSMeshAttachment self) {
		TS_ASSERT(self);
		return ((MeshAttachment*)self)->getMemory();
	}
	TS_CAPI const char* tsMeshAttachmentTypeColor = MeshAttachment::TypeColor;
	TS_CAPI const char* tsMeshAttachmentTypeIntensity = MeshAttachment::TypeIntensity;
	TS_CAPI const char* tsMeshAttachmentTypeTemperature = MeshAttachment::TypeTemperature;
	TS_CAPI const char* tsMeshAttachmentTypeInnerAngle = MeshAttachment::TypeInnerAngle;
	TS_CAPI const char* tsMeshAttachmentTypeOuterAngle = MeshAttachment::TypeOuterAngle;
	TS_CAPI const char* tsMeshAttachmentTypeAttenuation = MeshAttachment::TypeAttenuation;
	TS_CAPI const char* tsMeshAttachmentTypeDiffuse = MeshAttachment::TypeDiffuse;
	TS_CAPI const char* tsMeshAttachmentTypeSpecular = MeshAttachment::TypeSpecular;
	TS_CAPI const char* tsMeshAttachmentTypeWidth = MeshAttachment::TypeWidth;
	TS_CAPI const char* tsMeshAttachmentTypeHeight = MeshAttachment::TypeHeight;
	TS_CAPI const char* tsMeshAttachmentTypeRadius = MeshAttachment::TypeRadius;
	TS_CAPI const char* tsMeshAttachmentTypeLength = MeshAttachment::TypeLength;
	TS_CAPI const char* tsMeshAttachmentTypeShadow = MeshAttachment::TypeShadow;
	TS_CAPI const char* tsMeshAttachmentTypeAspect = MeshAttachment::TypeAspect;
	TS_CAPI const char* tsMeshAttachmentTypeFovX = MeshAttachment::TypeFovX;
	TS_CAPI const char* tsMeshAttachmentTypeFovY = MeshAttachment::TypeFovY;
	TS_CAPI const char* tsMeshAttachmentTypeSizeX = MeshAttachment::TypeSizeX;
	TS_CAPI const char* tsMeshAttachmentTypeSizeY = MeshAttachment::TypeSizeY;
	TS_CAPI const char* tsMeshAttachmentTypeZNear = MeshAttachment::TypeZNear;
	TS_CAPI const char* tsMeshAttachmentTypeZFar = MeshAttachment::TypeZFar;
	TS_CAPI const char* tsMeshAttachmentTypeFStop = MeshAttachment::TypeFStop;
	TS_CAPI const char* tsMeshAttachmentTypeExposure = MeshAttachment::TypeExposure;
	TS_CAPI const char* tsMeshAttachmentTypeApertureX = MeshAttachment::TypeApertureX;
	TS_CAPI const char* tsMeshAttachmentTypeApertureY = MeshAttachment::TypeApertureY;
	TS_CAPI const char* tsMeshAttachmentTypeFocalLength = MeshAttachment::TypeFocalLength;
	TS_CAPI const char* tsMeshAttachmentTypeFocusDistance = MeshAttachment::TypeFocusDistance;
	
	// Tellusim::Mesh
	TS_CAPI TSMesh TS_CCALL tsMesh_new(void) {
		Mesh *ret = new Mesh();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMesh)ret;
	}
	TS_CAPI void TS_CCALL tsMesh_delete(TSMesh self) {
		if(self) delete (Mesh*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMesh_equalPtr(const TSMesh self, const TSMesh ptr) {
		return (self && ptr && ((Mesh*)self)->operator==(*(Mesh*)ptr));
	}
	TS_CAPI TSMesh TS_CCALL tsMesh_copyPtr(TSMesh self) {
		Mesh *ret = nullptr;
		if(self) ret = new Mesh(*(Mesh*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMesh)ret;
	}
	TS_CAPI TSMesh TS_CCALL tsMesh_clonePtr(const TSMesh self) {
		Mesh *ret = (self) ? new Mesh(((Mesh*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMesh)ret;
	}
	TS_CAPI void TS_CCALL tsMesh_clearPtr(TSMesh self) {
		if(self) ((Mesh*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMesh_destroyPtr(TSMesh self) {
		if(self) ((Mesh*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMesh_acquirePtr(TSMesh self) {
		if(self) ((Mesh*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMesh_unacquirePtr(TSMesh self) {
		if(self) ((Mesh*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMesh_isValidPtr(const TSMesh self) {
		return (self && ((Mesh*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMesh_isOwnerPtr(const TSMesh self) {
		return (self && ((Mesh*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMesh_isConstPtr(const TSMesh self) {
		return (self && ((Mesh*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_getCountPtr(const TSMesh self) {
		return ((Mesh*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMesh_getInternalPtr(const TSMesh self) {
		return ((Mesh*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsMesh_clear(TSMesh self) {
		TS_ASSERT(self);
		((Mesh*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsMesh_isLoaded(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->isLoaded();
	}
	TS_CAPI bool_t TS_CCALL tsMesh_info_sMFA(TSMesh self, const char *name, TS_MeshFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->info(name, (Mesh::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_info_cSMFA(TSMesh self, const TSString name, TS_MeshFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->info((name) ? *(const String*)name : String::null, (Mesh::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_info_StMFA(TSMesh self, TSStream stream, TS_MeshFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Mesh*)self)->info(*(Stream*)stream, (Mesh::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_info_sA(TSMesh self, const char *name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->info(name, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_info_cSA(TSMesh self, const TSString name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->info((name) ? *(const String*)name : String::null, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_info_StA(TSMesh self, TSStream stream, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Mesh*)self)->info(*(Stream*)stream, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_load_sMFA(TSMesh self, const char *name, TS_MeshFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->load(name, (Mesh::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_load_cSMFA(TSMesh self, const TSString name, TS_MeshFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->load((name) ? *(const String*)name : String::null, (Mesh::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_load_StMFA(TSMesh self, TSStream stream, TS_MeshFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Mesh*)self)->load(*(Stream*)stream, (Mesh::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_load_sA(TSMesh self, const char *name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->load(name, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_load_cSA(TSMesh self, const TSString name, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->load((name) ? *(const String*)name : String::null, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_load_StA(TSMesh self, TSStream stream, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Mesh*)self)->load(*(Stream*)stream, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_save_csMF(TSMesh self, const char *name, TS_MeshFlags flags) {
		TS_ASSERT(self);
		return ((Mesh*)self)->save(name, (Mesh::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_save_ccSMF(TSMesh self, const TSString name, TS_MeshFlags flags) {
		TS_ASSERT(self);
		return ((Mesh*)self)->save((name) ? *(const String*)name : String::null, (Mesh::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_save_cStMF(TSMesh self, TSStream stream, TS_MeshFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Mesh*)self)->save(*(Stream*)stream, (Mesh::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsMesh_setName(TSMesh self, const char *name) {
		TS_ASSERT(self);
		((Mesh*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsMesh_getName(TSMesh self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Mesh*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsMesh_setBasis_MAMAMA(TSMesh self, TS_MeshAxis front, TS_MeshAxis right, TS_MeshAxis up) {
		TS_ASSERT(self);
		return ((Mesh*)self)->setBasis((Mesh::Axis)front, (Mesh::Axis)right, (Mesh::Axis)up);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_setBasis_MB(TSMesh self, TS_MeshBasis basis) {
		TS_ASSERT(self);
		return ((Mesh*)self)->setBasis((Mesh::Basis)basis);
	}
	TS_CAPI TS_MeshAxis TS_CCALL tsMesh_getFrontAxis(TSMesh self) {
		TS_ASSERT(self);
		return (TS_MeshAxis)((Mesh*)self)->getFrontAxis();
	}
	TS_CAPI TS_MeshAxis TS_CCALL tsMesh_getRightAxis(TSMesh self) {
		TS_ASSERT(self);
		return (TS_MeshAxis)((Mesh*)self)->getRightAxis();
	}
	TS_CAPI TS_MeshAxis TS_CCALL tsMesh_getUpAxis(TSMesh self) {
		TS_ASSERT(self);
		return (TS_MeshAxis)((Mesh*)self)->getUpAxis();
	}
	TS_CAPI TS_MeshBasis TS_CCALL tsMesh_getBasis(TSMesh self) {
		TS_ASSERT(self);
		return (TS_MeshBasis)((Mesh*)self)->getBasis();
	}
	TS_CAPI const char* TS_CCALL tsMesh_getFrontAxisName(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getFrontAxisName();
	}
	TS_CAPI const char* TS_CCALL tsMesh_getRightAxisName(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getRightAxisName();
	}
	TS_CAPI const char* TS_CCALL tsMesh_getUpAxisName(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getUpAxisName();
	}
	TS_CAPI TSString TS_CCALL tsMesh_getBasisName(TSMesh self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Mesh*)self)->getBasisName()));
	}
	TS_CAPI void TS_CCALL tsMesh_clearNodes(TSMesh self) {
		TS_ASSERT(self);
		((Mesh*)self)->clearNodes();
	}
	TS_CAPI void TS_CCALL tsMesh_reserveNodes(TSMesh self, uint32_t num_nodes) {
		TS_ASSERT(self);
		((Mesh*)self)->reserveNodes(num_nodes);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_addNode(TSMesh self, TSMeshNode node, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		return ((Mesh*)self)->addNode(*(MeshNode*)node, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_removeNode(TSMesh self, TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		return ((Mesh*)self)->removeNode(*(MeshNode*)node);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_findNode_ccMN(TSMesh self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		return ((Mesh*)self)->findNode(*(const MeshNode*)node);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_findNode_cs(TSMesh self, const char *name) {
		TS_ASSERT(self);
		return ((Mesh*)self)->findNode(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_getNumNodes(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getNumNodes();
	}
	TS_CAPI TSMeshNode TS_CCALL tsMesh_getNode_cu(TSMesh self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((Mesh*)self)->getNode(index)));
	}
	TS_CAPI TSMeshNode TS_CCALL tsMesh_getNode_u(TSMesh self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshNode)(new MeshNode(((Mesh*)self)->getNode(index)));
	}
	TS_CAPI void TS_CCALL tsMesh_createLocalTransforms(TSMesh self, const TSMatrix4x3d *itransform) {
		TS_ASSERT(self);
		TS_ASSERT(itransform);
		((Mesh*)self)->createLocalTransforms(*(const Matrix4x3d*)itransform);
	}
	TS_CAPI void TS_CCALL tsMesh_createGlobalTransforms(TSMesh self, const TSMatrix4x3d *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((Mesh*)self)->createGlobalTransforms(*(const Matrix4x3d*)transform);
	}
	TS_CAPI void TS_CCALL tsMesh_clearGeometries(TSMesh self) {
		TS_ASSERT(self);
		((Mesh*)self)->clearGeometries();
	}
	TS_CAPI void TS_CCALL tsMesh_reserveGeometries(TSMesh self, uint32_t num_geometries) {
		TS_ASSERT(self);
		((Mesh*)self)->reserveGeometries(num_geometries);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_addGeometry_MGb(TSMesh self, TSMeshGeometry geometry, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		return ((Mesh*)self)->addGeometry(*(MeshGeometry*)geometry, (bool)check);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_addGeometry_MGMNb(TSMesh self, TSMeshGeometry geometry, TSMeshNode node, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		TS_ASSERT(node);
		return ((Mesh*)self)->addGeometry(*(MeshGeometry*)geometry, *(MeshNode*)node, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_removeGeometry(TSMesh self, TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		return ((Mesh*)self)->removeGeometry(*(MeshGeometry*)geometry);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_replaceGeometry(TSMesh self, TSMeshGeometry old_geometry, TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(old_geometry);
		TS_ASSERT(geometry);
		return ((Mesh*)self)->replaceGeometry(*(MeshGeometry*)old_geometry, *(MeshGeometry*)geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_findGeometry_ccMG(TSMesh self, const TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		return ((Mesh*)self)->findGeometry(*(const MeshGeometry*)geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_findGeometry_cs(TSMesh self, const char *name) {
		TS_ASSERT(self);
		return ((Mesh*)self)->findGeometry(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_getNumGeometries(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getNumGeometries();
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMesh_getGeometry_cu(TSMesh self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((Mesh*)self)->getGeometry(index)));
	}
	TS_CAPI TSMeshGeometry TS_CCALL tsMesh_getGeometry_u(TSMesh self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshGeometry)(new MeshGeometry(((Mesh*)self)->getGeometry(index)));
	}
	TS_CAPI bool_t TS_CCALL tsMesh_hasGeometryIndices(TSMesh self, TS_MeshIndicesType type) {
		TS_ASSERT(self);
		return ((Mesh*)self)->hasGeometryIndices((MeshIndices::Type)type);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_hasGeometryAttribute(TSMesh self, TS_MeshAttributeType type) {
		TS_ASSERT(self);
		return ((Mesh*)self)->hasGeometryAttribute((MeshAttribute::Type)type);
	}
	TS_CAPI size_t TS_CCALL tsMesh_getNumGeometryPositions(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getNumGeometryPositions();
	}
	TS_CAPI size_t TS_CCALL tsMesh_getNumGeometryPrimitives(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getNumGeometryPrimitives();
	}
	TS_CAPI void TS_CCALL tsMesh_clearAnimations(TSMesh self) {
		TS_ASSERT(self);
		((Mesh*)self)->clearAnimations();
	}
	TS_CAPI void TS_CCALL tsMesh_reserveAnimations(TSMesh self, uint32_t num_animations) {
		TS_ASSERT(self);
		((Mesh*)self)->reserveAnimations(num_animations);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_addAnimation(TSMesh self, TSMeshAnimation animation, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(animation);
		return ((Mesh*)self)->addAnimation(*(MeshAnimation*)animation, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_removeAnimation(TSMesh self, TSMeshAnimation animation) {
		TS_ASSERT(self);
		TS_ASSERT(animation);
		return ((Mesh*)self)->removeAnimation(*(MeshAnimation*)animation);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_replaceAnimation(TSMesh self, TSMeshAnimation old_animation, TSMeshAnimation animation) {
		TS_ASSERT(self);
		TS_ASSERT(old_animation);
		TS_ASSERT(animation);
		return ((Mesh*)self)->replaceAnimation(*(MeshAnimation*)old_animation, *(MeshAnimation*)animation);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_findAnimation_ccMA(TSMesh self, const TSMeshAnimation animation) {
		TS_ASSERT(self);
		TS_ASSERT(animation);
		return ((Mesh*)self)->findAnimation(*(const MeshAnimation*)animation);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_findAnimation_cs(TSMesh self, const char *name) {
		TS_ASSERT(self);
		return ((Mesh*)self)->findAnimation(name);
	}
	TS_CAPI uint32_t TS_CCALL tsMesh_getNumAnimations(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getNumAnimations();
	}
	TS_CAPI TSMeshAnimation TS_CCALL tsMesh_getAnimation_cu(TSMesh self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAnimation)(new MeshAnimation(((Mesh*)self)->getAnimation(index)));
	}
	TS_CAPI TSMeshAnimation TS_CCALL tsMesh_getAnimation_u(TSMesh self, uint32_t index) {
		TS_ASSERT(self);
		return (TSMeshAnimation)(new MeshAnimation(((Mesh*)self)->getAnimation(index)));
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMesh_getBoundBox_c(TSMesh self) {
		TS_ASSERT(self);
		BoundBoxd ret = ((Mesh*)self)->getBoundBox();
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMesh_getBoundBox_ccMN(TSMesh self, const TSMeshNode node) {
		TS_ASSERT(self);
		TS_ASSERT(node);
		BoundBoxd ret = ((Mesh*)self)->getBoundBox(*(const MeshNode*)node);
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI TSBoundBoxd TS_CCALL tsMesh_getBoundBox_ccMG(TSMesh self, const TSMeshGeometry geometry) {
		TS_ASSERT(self);
		TS_ASSERT(geometry);
		BoundBoxd ret = ((Mesh*)self)->getBoundBox(*(const MeshGeometry*)geometry);
		return *(TSBoundBoxd*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createBounds_bA(TSMesh self, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createBounds((bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createBounds_A(TSMesh self, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createBounds((async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createBasis_bA(TSMesh self, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createBasis((bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createBasis_fbA(TSMesh self, float32_t angle, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createBasis(angle, (bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createBasis_A(TSMesh self, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createBasis((async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createBasis_fA(TSMesh self, float32_t angle, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createBasis(angle, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createNormals_bA(TSMesh self, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createNormals((bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createNormals_fbA(TSMesh self, float32_t angle, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createNormals(angle, (bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createNormals_A(TSMesh self, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createNormals((async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createNormals_fA(TSMesh self, float32_t angle, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createNormals(angle, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createTangents_bA(TSMesh self, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createTangents((bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createTangents_A(TSMesh self, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createTangents((async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createIslands_uubA(TSMesh self, uint32_t max_attributes, uint32_t max_primitives, bool_t force, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createIslands(max_attributes, max_primitives, (bool)force, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_createIslands_uuA(TSMesh self, uint32_t max_attributes, uint32_t max_primitives, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->createIslands(max_attributes, max_primitives, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_optimizeIndices_ubA(TSMesh self, uint32_t cache, bool_t transparent, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->optimizeIndices(cache, (bool)transparent, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_optimizeIndices_A(TSMesh self, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->optimizeIndices((async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_optimizeIndices_uA(TSMesh self, uint32_t cache, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->optimizeIndices(cache, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_optimizeAttributes(TSMesh self, TSAsync *async) {
		TS_ASSERT(self);
		return ((Mesh*)self)->optimizeAttributes((async) ? *(Async**)async : nullptr);
	}
	TS_CAPI void TS_CCALL tsMesh_optimizeMaterials(TSMesh self) {
		TS_ASSERT(self);
		((Mesh*)self)->optimizeMaterials();
	}
	TS_CAPI bool_t TS_CCALL tsMesh_optimizeWinding(TSMesh self, bool_t clockwise) {
		TS_ASSERT(self);
		return ((Mesh*)self)->optimizeWinding((bool)clockwise);
	}
	TS_CAPI void TS_CCALL tsMesh_optimizeGeometries(TSMesh self, float32_t threshold, uint32_t depth) {
		TS_ASSERT(self);
		((Mesh*)self)->optimizeGeometries(threshold, depth);
	}
	TS_CAPI void TS_CCALL tsMesh_optimizeAnimations(TSMesh self, float32_t threshold) {
		TS_ASSERT(self);
		((Mesh*)self)->optimizeAnimations(threshold);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_optimizeOrder(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->optimizeOrder();
	}
	TS_CAPI void TS_CCALL tsMesh_mergeGeometries(TSMesh self) {
		TS_ASSERT(self);
		((Mesh*)self)->mergeGeometries();
	}
	TS_CAPI bool_t TS_CCALL tsMesh_packAttributes(TSMesh self, bool_t remove) {
		TS_ASSERT(self);
		return ((Mesh*)self)->packAttributes((bool)remove);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_unpackAttributes(TSMesh self, bool_t remove) {
		TS_ASSERT(self);
		return ((Mesh*)self)->unpackAttributes((bool)remove);
	}
	TS_CAPI bool_t TS_CCALL tsMesh_setTransform(TSMesh self, const TSVector3d *scale) {
		TS_ASSERT(self);
		TS_ASSERT(scale);
		return ((Mesh*)self)->setTransform(*(const Vector3d*)scale);
	}
	TS_CAPI size_t TS_CCALL tsMesh_getMemory(TSMesh self) {
		TS_ASSERT(self);
		return ((Mesh*)self)->getMemory();
	}
	
	// Tellusim::Json
	TS_CAPI TSJson TS_CCALL tsJson_new(void) {
		Json *ret = new Json();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI TSJson TS_CCALL tsJson_new_JT(TS_JsonType type) {
		Json *ret = new Json((Json::Type)type);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI TSJson TS_CCALL tsJson_new_sJT(const char *name, TS_JsonType type) {
		Json *ret = new Json(name, (Json::Type)type);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI TSJson TS_CCALL tsJson_new_cSJT(const TSString name, TS_JsonType type) {
		Json *ret = new Json((name) ? *(const String*)name : String::null, (Json::Type)type);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI TSJson TS_CCALL tsJson_new_JsJT(TSJson *parent, const char *name, TS_JsonType type) {
		Json *ret = new Json((parent) ? *(Json**)parent : nullptr, name, (Json::Type)type);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI TSJson TS_CCALL tsJson_new_JcSJT(TSJson *parent, const TSString name, TS_JsonType type) {
		Json *ret = new Json((parent) ? *(Json**)parent : nullptr, (name) ? *(const String*)name : String::null, (Json::Type)type);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI void TS_CCALL tsJson_delete(TSJson self) {
		if(self) delete (Json*)self;
	}
	TS_CAPI bool_t TS_CCALL tsJson_equalPtr(const TSJson self, const TSJson ptr) {
		return (self && ptr && ((Json*)self)->operator==(*(Json*)ptr));
	}
	TS_CAPI TSJson TS_CCALL tsJson_copyPtr(TSJson self) {
		Json *ret = nullptr;
		if(self) ret = new Json(*(Json*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI TSJson TS_CCALL tsJson_clonePtr(const TSJson self) {
		Json *ret = (self) ? new Json(((Json*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSJson)ret;
	}
	TS_CAPI void TS_CCALL tsJson_clearPtr(TSJson self) {
		if(self) ((Json*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsJson_destroyPtr(TSJson self) {
		if(self) ((Json*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsJson_acquirePtr(TSJson self) {
		if(self) ((Json*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsJson_unacquirePtr(TSJson self) {
		if(self) ((Json*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isValidPtr(const TSJson self) {
		return (self && ((Json*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsJson_isOwnerPtr(const TSJson self) {
		return (self && ((Json*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsJson_isConstPtr(const TSJson self) {
		return (self && ((Json*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getCountPtr(const TSJson self) {
		return ((Json*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsJson_getInternalPtr(const TSJson self) {
		return ((Json*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsJson_clear(TSJson self) {
		TS_ASSERT(self);
		((Json*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsJson_create_szb(TSJson self, const char *str, size_t size, bool_t owner) {
		TS_ASSERT(self);
		return ((Json*)self)->create(str, size, (bool)owner);
	}
	TS_CAPI bool_t TS_CCALL tsJson_create_cSzb(TSJson self, const TSString str, size_t size, bool_t owner) {
		TS_ASSERT(self);
		return ((Json*)self)->create((str) ? *(const String*)str : String::null, size, (bool)owner);
	}
	TS_CAPI bool_t TS_CCALL tsJson_load_s(TSJson self, const char *name) {
		TS_ASSERT(self);
		return ((Json*)self)->load(name);
	}
	TS_CAPI bool_t TS_CCALL tsJson_load_cS(TSJson self, const TSString name) {
		TS_ASSERT(self);
		return ((Json*)self)->load((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsJson_load_St(TSJson self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Json*)self)->load(*(Stream*)stream);
	}
	TS_CAPI bool_t TS_CCALL tsJson_save_csb(TSJson self, const char *name, bool_t compact) {
		TS_ASSERT(self);
		return ((Json*)self)->save(name, (bool)compact);
	}
	TS_CAPI bool_t TS_CCALL tsJson_save_ccSb(TSJson self, const TSString name, bool_t compact) {
		TS_ASSERT(self);
		return ((Json*)self)->save((name) ? *(const String*)name : String::null, (bool)compact);
	}
	TS_CAPI bool_t TS_CCALL tsJson_save_cStb(TSJson self, TSStream stream, bool_t compact) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Json*)self)->save(*(Stream*)stream, (bool)compact);
	}
	TS_CAPI TSJson TS_CCALL tsJson_getRoot_c(TSJson self) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getRoot()));
	}
	TS_CAPI TSJson TS_CCALL tsJson_getRoot(TSJson self) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getRoot()));
	}
	TS_CAPI uint32_t TS_CCALL tsJson_setParent(TSJson self, TSJson parent, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((Json*)self)->setParent(*(Json*)parent, (bool)check);
	}
	TS_CAPI TSJson TS_CCALL tsJson_getParent_c(TSJson self) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getParent()));
	}
	TS_CAPI TSJson TS_CCALL tsJson_getParent(TSJson self) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getParent()));
	}
	TS_CAPI TSJson TS_CCALL tsJson_addChild_sJTb(TSJson self, const char *name, TS_JsonType type, bool_t check) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->addChild(name, (Json::Type)type, (bool)check)));
	}
	TS_CAPI uint32_t TS_CCALL tsJson_addChild_Jb(TSJson self, TSJson child, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Json*)self)->addChild(*(Json*)child, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsJson_removeChild(TSJson self, TSJson child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Json*)self)->removeChild(*(Json*)child);
	}
	TS_CAPI void TS_CCALL tsJson_releaseChildren(TSJson self) {
		TS_ASSERT(self);
		((Json*)self)->releaseChildren();
	}
	TS_CAPI uint32_t TS_CCALL tsJson_findChild(TSJson self, const char *name) {
		TS_ASSERT(self);
		return ((Json*)self)->findChild(name);
	}
	TS_CAPI bool_t TS_CCALL tsJson_isChild(TSJson self, const char *name) {
		TS_ASSERT(self);
		return ((Json*)self)->isChild(name);
	}
	TS_CAPI TSJson TS_CCALL tsJson_getChild_cs(TSJson self, const char *name) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getChild(name)));
	}
	TS_CAPI TSJson TS_CCALL tsJson_getChild_s(TSJson self, const char *name) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getChild(name)));
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getNumChildren(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->getNumChildren();
	}
	TS_CAPI TSJson TS_CCALL tsJson_getChild_cu(TSJson self, uint32_t index) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getChild(index)));
	}
	TS_CAPI TSJson TS_CCALL tsJson_getChild_u(TSJson self, uint32_t index) {
		TS_ASSERT(self);
		return (TSJson)(new Json(((Json*)self)->getChild(index)));
	}
	TS_CAPI TSString TS_CCALL tsJson_getPathName(TSJson self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Json*)self)->getPathName()));
	}
	TS_CAPI void TS_CCALL tsJson_setName_s(TSJson self, const char *name) {
		TS_ASSERT(self);
		((Json*)self)->setName(name);
	}
	TS_CAPI void TS_CCALL tsJson_setName_cS(TSJson self, const TSString name) {
		TS_ASSERT(self);
		((Json*)self)->setName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsJson_getName(TSJson self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Json*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsJson_setType(TSJson self, TS_JsonType type) {
		TS_ASSERT(self);
		((Json*)self)->setType((Json::Type)type);
	}
	TS_CAPI TS_JsonType TS_CCALL tsJson_getType(TSJson self) {
		TS_ASSERT(self);
		return (TS_JsonType)((Json*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsJson_getTypeName_JT(TS_JsonType type) {
		return Json::getTypeName((Json::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsJson_getTypeName_c(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isUnknown(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isUnknown();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isNull(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isNull();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isBool(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isBool();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isNumber(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isNumber();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isString(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isString();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isObject(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isObject();
	}
	TS_CAPI bool_t TS_CCALL tsJson_isArray(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->isArray();
	}
	TS_CAPI void TS_CCALL tsJson_setData_b(TSJson self, bool_t value) {
		TS_ASSERT(self);
		((Json*)self)->setData((bool)value);
	}
	TS_CAPI void TS_CCALL tsJson_setData_iu(TSJson self, int32_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Json*)self)->setData(value, radix);
	}
	TS_CAPI void TS_CCALL tsJson_setData_uu(TSJson self, uint32_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Json*)self)->setData(value, radix);
	}
	TS_CAPI void TS_CCALL tsJson_setData_u64u(TSJson self, uint64_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Json*)self)->setData(value, radix);
	}
	TS_CAPI void TS_CCALL tsJson_setData_fubb(TSJson self, float32_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Json*)self)->setData(value, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI void TS_CCALL tsJson_setData_f64ubb(TSJson self, float64_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Json*)self)->setData(value, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI void TS_CCALL tsJson_setData_s(TSJson self, const char *value) {
		TS_ASSERT(self);
		((Json*)self)->setData(value);
	}
	TS_CAPI void TS_CCALL tsJson_setData_cS(TSJson self, const TSString value) {
		TS_ASSERT(self);
		((Json*)self)->setData((value) ? *(const String*)value : String::null);
	}
	TS_CAPI TSString TS_CCALL tsJson_getData_c(TSJson self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Json*)self)->getData()));
	}
	TS_CAPI bool_t TS_CCALL tsJson_getDataBool(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->getDataBool();
	}
	TS_CAPI int32_t TS_CCALL tsJson_getDatai32(TSJson self, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getDatai32(radix);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getDatau32(TSJson self, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getDatau32(radix);
	}
	TS_CAPI uint64_t TS_CCALL tsJson_getDatau64(TSJson self, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getDatau64(radix);
	}
	TS_CAPI float32_t TS_CCALL tsJson_getDataf32(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->getDataf32();
	}
	TS_CAPI float64_t TS_CCALL tsJson_getDataf64(TSJson self) {
		TS_ASSERT(self);
		return ((Json*)self)->getDataf64();
	}
	TS_CAPI TSString TS_CCALL tsJson_getNumber(TSJson self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Json*)self)->getNumber()));
	}
	TS_CAPI TSString TS_CCALL tsJson_getString(TSJson self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Json*)self)->getString()));
	}
	TS_CAPI bool_t TS_CCALL tsJson_getData_csb(TSJson self, const char *name, bool_t value) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(name, (bool)value);
	}
	TS_CAPI int32_t TS_CCALL tsJson_getData_csiu(TSJson self, const char *name, int32_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(name, value, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getData_csuu(TSJson self, const char *name, uint32_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(name, value, radix);
	}
	TS_CAPI uint64_t TS_CCALL tsJson_getData_csu64u(TSJson self, const char *name, uint64_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(name, value, radix);
	}
	TS_CAPI float32_t TS_CCALL tsJson_getData_csf(TSJson self, const char *name, float32_t value) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(name, value);
	}
	TS_CAPI float64_t TS_CCALL tsJson_getData_csf64(TSJson self, const char *name, float64_t value) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(name, value);
	}
	TS_CAPI TSString TS_CCALL tsJson_getData_cscS(TSJson self, const char *name, const TSString value) {
		TS_ASSERT(self);
		return (TSString)(new String(((Json*)self)->getData(name, (value) ? *(const String*)value : String::null)));
	}
	TS_CAPI void TS_CCALL tsJson_setData_spu(TSJson self, const char **values, uint32_t size) {
		TS_ASSERT(self);
		((Json*)self)->setData(values, size);
	}
	TS_CAPI void TS_CCALL tsJson_setData_cSu(TSJson self, const TSString *values, uint32_t size) {
		TS_ASSERT(self);
		((Json*)self)->setData((values) ? *(const String**)values : nullptr, size);
	}
	TS_CAPI void TS_CCALL tsJson_setData_ipuu(TSJson self, const int32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		((Json*)self)->setData(values, size, radix);
	}
	TS_CAPI void TS_CCALL tsJson_setData_upuu(TSJson self, const uint32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		((Json*)self)->setData(values, size, radix);
	}
	TS_CAPI void TS_CCALL tsJson_setData_fpuubb(TSJson self, const float32_t *values, uint32_t size, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Json*)self)->setData(values, size, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI void TS_CCALL tsJson_setData_f64puubb(TSJson self, const float64_t *values, uint32_t size, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Json*)self)->setData(values, size, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getData_cSu(TSJson self, TSString *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Json*)self)->getData((values) ? *(String**)values : nullptr, size);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getData_ciruu(TSJson self, int32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(values, size, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getData_curuu(TSJson self, uint32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(values, size, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getData_cfru(TSJson self, float32_t *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(values, size);
	}
	TS_CAPI uint32_t TS_CCALL tsJson_getData_cf64ru(TSJson self, float64_t *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Json*)self)->getData(values, size);
	}
	
	// Tellusim::Xml
	TS_CAPI TSXml TS_CCALL tsXml_new(void) {
		Xml *ret = new Xml();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI TSXml TS_CCALL tsXml_new_ss(const char *name, const char *attributes) {
		Xml *ret = new Xml(name, attributes);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI TSXml TS_CCALL tsXml_new_cSs(const TSString name, const char *attributes) {
		Xml *ret = new Xml((name) ? *(const String*)name : String::null, attributes);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI TSXml TS_CCALL tsXml_new_Xss(TSXml *parent, const char *name, const char *attributes) {
		Xml *ret = new Xml((parent) ? *(Xml**)parent : nullptr, name, attributes);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI TSXml TS_CCALL tsXml_new_XcSs(TSXml *parent, const TSString name, const char *attributes) {
		Xml *ret = new Xml((parent) ? *(Xml**)parent : nullptr, (name) ? *(const String*)name : String::null, attributes);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI void TS_CCALL tsXml_delete(TSXml self) {
		if(self) delete (Xml*)self;
	}
	TS_CAPI bool_t TS_CCALL tsXml_equalPtr(const TSXml self, const TSXml ptr) {
		return (self && ptr && ((Xml*)self)->operator==(*(Xml*)ptr));
	}
	TS_CAPI TSXml TS_CCALL tsXml_copyPtr(TSXml self) {
		Xml *ret = nullptr;
		if(self) ret = new Xml(*(Xml*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI TSXml TS_CCALL tsXml_clonePtr(const TSXml self) {
		Xml *ret = (self) ? new Xml(((Xml*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSXml)ret;
	}
	TS_CAPI void TS_CCALL tsXml_clearPtr(TSXml self) {
		if(self) ((Xml*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsXml_destroyPtr(TSXml self) {
		if(self) ((Xml*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsXml_acquirePtr(TSXml self) {
		if(self) ((Xml*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsXml_unacquirePtr(TSXml self) {
		if(self) ((Xml*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsXml_isValidPtr(const TSXml self) {
		return (self && ((Xml*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsXml_isOwnerPtr(const TSXml self) {
		return (self && ((Xml*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsXml_isConstPtr(const TSXml self) {
		return (self && ((Xml*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getCountPtr(const TSXml self) {
		return ((Xml*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsXml_getInternalPtr(const TSXml self) {
		return ((Xml*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsXml_clear(TSXml self) {
		TS_ASSERT(self);
		((Xml*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsXml_create_szb(TSXml self, const char *str, size_t size, bool_t owner) {
		TS_ASSERT(self);
		return ((Xml*)self)->create(str, size, (bool)owner);
	}
	TS_CAPI bool_t TS_CCALL tsXml_create_cSzb(TSXml self, const TSString str, size_t size, bool_t owner) {
		TS_ASSERT(self);
		return ((Xml*)self)->create((str) ? *(const String*)str : String::null, size, (bool)owner);
	}
	TS_CAPI bool_t TS_CCALL tsXml_load_s(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->load(name);
	}
	TS_CAPI bool_t TS_CCALL tsXml_load_cS(TSXml self, const TSString name) {
		TS_ASSERT(self);
		return ((Xml*)self)->load((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsXml_load_St(TSXml self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Xml*)self)->load(*(Stream*)stream);
	}
	TS_CAPI bool_t TS_CCALL tsXml_save_csb(TSXml self, const char *name, bool_t compact) {
		TS_ASSERT(self);
		return ((Xml*)self)->save(name, (bool)compact);
	}
	TS_CAPI bool_t TS_CCALL tsXml_save_ccSb(TSXml self, const TSString name, bool_t compact) {
		TS_ASSERT(self);
		return ((Xml*)self)->save((name) ? *(const String*)name : String::null, (bool)compact);
	}
	TS_CAPI bool_t TS_CCALL tsXml_save_cStb(TSXml self, TSStream stream, bool_t compact) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Xml*)self)->save(*(Stream*)stream, (bool)compact);
	}
	TS_CAPI TSXml TS_CCALL tsXml_getRoot_c(TSXml self) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getRoot()));
	}
	TS_CAPI TSXml TS_CCALL tsXml_getRoot(TSXml self) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getRoot()));
	}
	TS_CAPI uint32_t TS_CCALL tsXml_setParent(TSXml self, TSXml parent, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((Xml*)self)->setParent(*(Xml*)parent, (bool)check);
	}
	TS_CAPI TSXml TS_CCALL tsXml_getParent_c(TSXml self) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getParent()));
	}
	TS_CAPI TSXml TS_CCALL tsXml_getParent(TSXml self) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getParent()));
	}
	TS_CAPI TSXml TS_CCALL tsXml_addChild_sb(TSXml self, const char *name, bool_t check) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->addChild(name, (bool)check)));
	}
	TS_CAPI uint32_t TS_CCALL tsXml_addChild_Xb(TSXml self, TSXml child, bool_t check) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Xml*)self)->addChild(*(Xml*)child, (bool)check);
	}
	TS_CAPI bool_t TS_CCALL tsXml_removeChild(TSXml self, TSXml child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Xml*)self)->removeChild(*(Xml*)child);
	}
	TS_CAPI void TS_CCALL tsXml_releaseChildren(TSXml self) {
		TS_ASSERT(self);
		((Xml*)self)->releaseChildren();
	}
	TS_CAPI uint32_t TS_CCALL tsXml_findChild(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->findChild(name);
	}
	TS_CAPI bool_t TS_CCALL tsXml_isChild(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->isChild(name);
	}
	TS_CAPI TSXml TS_CCALL tsXml_getChild_cs(TSXml self, const char *name) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getChild(name)));
	}
	TS_CAPI TSXml TS_CCALL tsXml_getChild_s(TSXml self, const char *name) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getChild(name)));
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getNumChildren(TSXml self) {
		TS_ASSERT(self);
		return ((Xml*)self)->getNumChildren();
	}
	TS_CAPI TSXml TS_CCALL tsXml_getChild_cu(TSXml self, uint32_t index) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getChild(index)));
	}
	TS_CAPI TSXml TS_CCALL tsXml_getChild_u(TSXml self, uint32_t index) {
		TS_ASSERT(self);
		return (TSXml)(new Xml(((Xml*)self)->getChild(index)));
	}
	TS_CAPI TSString TS_CCALL tsXml_getPathName(TSXml self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getPathName()));
	}
	TS_CAPI void TS_CCALL tsXml_setName_s(TSXml self, const char *name) {
		TS_ASSERT(self);
		((Xml*)self)->setName(name);
	}
	TS_CAPI void TS_CCALL tsXml_setName_cS(TSXml self, const TSString name) {
		TS_ASSERT(self);
		((Xml*)self)->setName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsXml_getName(TSXml self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsXml_setData_b(TSXml self, bool_t value) {
		TS_ASSERT(self);
		((Xml*)self)->setData((bool)value);
	}
	TS_CAPI void TS_CCALL tsXml_setData_s(TSXml self, const char *value) {
		TS_ASSERT(self);
		((Xml*)self)->setData(value);
	}
	TS_CAPI void TS_CCALL tsXml_setData_cS(TSXml self, const TSString value) {
		TS_ASSERT(self);
		((Xml*)self)->setData((value) ? *(const String*)value : String::null);
	}
	TS_CAPI void TS_CCALL tsXml_setData_iu(TSXml self, int32_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setData(value, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setData_uu(TSXml self, uint32_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setData(value, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setData_u64u(TSXml self, uint64_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setData(value, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setData_fubb(TSXml self, float32_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Xml*)self)->setData(value, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI void TS_CCALL tsXml_setData_f64ubb(TSXml self, float64_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Xml*)self)->setData(value, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI TSString TS_CCALL tsXml_getData_c(TSXml self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getData()));
	}
	TS_CAPI bool_t TS_CCALL tsXml_getDataBool(TSXml self) {
		TS_ASSERT(self);
		return ((Xml*)self)->getDataBool();
	}
	TS_CAPI int32_t TS_CCALL tsXml_getDatai32(TSXml self, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getDatai32(radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getDatau32(TSXml self, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getDatau32(radix);
	}
	TS_CAPI uint64_t TS_CCALL tsXml_getDatau64(TSXml self, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getDatau64(radix);
	}
	TS_CAPI float32_t TS_CCALL tsXml_getDataf32(TSXml self) {
		TS_ASSERT(self);
		return ((Xml*)self)->getDataf32();
	}
	TS_CAPI float64_t TS_CCALL tsXml_getDataf64(TSXml self) {
		TS_ASSERT(self);
		return ((Xml*)self)->getDataf64();
	}
	TS_CAPI TSString TS_CCALL tsXml_getData_cscS(TSXml self, const char *name, const TSString value) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getData(name, (value) ? *(const String*)value : String::null)));
	}
	TS_CAPI bool_t TS_CCALL tsXml_getData_csb(TSXml self, const char *name, bool_t value) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(name, (bool)value);
	}
	TS_CAPI int32_t TS_CCALL tsXml_getData_csiu(TSXml self, const char *name, int32_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(name, value, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getData_csuu(TSXml self, const char *name, uint32_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(name, value, radix);
	}
	TS_CAPI uint64_t TS_CCALL tsXml_getData_csu64u(TSXml self, const char *name, uint64_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(name, value, radix);
	}
	TS_CAPI float32_t TS_CCALL tsXml_getData_csf(TSXml self, const char *name, float32_t value) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(name, value);
	}
	TS_CAPI float64_t TS_CCALL tsXml_getData_csf64(TSXml self, const char *name, float64_t value) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(name, value);
	}
	TS_CAPI void TS_CCALL tsXml_setData_spuu(TSXml self, const char **values, uint32_t size, uint32_t wrap) {
		TS_ASSERT(self);
		((Xml*)self)->setData(values, size, wrap);
	}
	TS_CAPI void TS_CCALL tsXml_setData_cSuu(TSXml self, const TSString *values, uint32_t size, uint32_t wrap) {
		TS_ASSERT(self);
		((Xml*)self)->setData((values) ? *(const String**)values : nullptr, size, wrap);
	}
	TS_CAPI void TS_CCALL tsXml_setData_ipuuu(TSXml self, const int32_t *values, uint32_t size, uint32_t radix, uint32_t wrap) {
		TS_ASSERT(self);
		((Xml*)self)->setData(values, size, radix, wrap);
	}
	TS_CAPI void TS_CCALL tsXml_setData_upuuu(TSXml self, const uint32_t *values, uint32_t size, uint32_t radix, uint32_t wrap) {
		TS_ASSERT(self);
		((Xml*)self)->setData(values, size, radix, wrap);
	}
	TS_CAPI void TS_CCALL tsXml_setData_fpuubbu(TSXml self, const float32_t *values, uint32_t size, uint32_t digits, bool_t compact, bool_t exponent, uint32_t wrap) {
		TS_ASSERT(self);
		((Xml*)self)->setData(values, size, digits, (bool)compact, (bool)exponent, wrap);
	}
	TS_CAPI void TS_CCALL tsXml_setData_f64puubbu(TSXml self, const float64_t *values, uint32_t size, uint32_t digits, bool_t compact, bool_t exponent, uint32_t wrap) {
		TS_ASSERT(self);
		((Xml*)self)->setData(values, size, digits, (bool)compact, (bool)exponent, wrap);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getData_cSu(TSXml self, TSString *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData((values) ? *(String**)values : nullptr, size);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getData_ciruu(TSXml self, int32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(values, size, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getData_curuu(TSXml self, uint32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(values, size, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getData_cfru(TSXml self, float32_t *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(values, size);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getData_cf64ru(TSXml self, float64_t *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Xml*)self)->getData(values, size);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_addAttribute(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->addAttribute(name);
	}
	TS_CAPI bool_t TS_CCALL tsXml_removeAttribute(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->removeAttribute(name);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_findAttribute(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->findAttribute(name);
	}
	TS_CAPI bool_t TS_CCALL tsXml_isAttribute(TSXml self, const char *name) {
		TS_ASSERT(self);
		return ((Xml*)self)->isAttribute(name);
	}
	TS_CAPI void TS_CCALL tsXml_removeAttributes(TSXml self) {
		TS_ASSERT(self);
		((Xml*)self)->removeAttributes();
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getNumAttributes(TSXml self) {
		TS_ASSERT(self);
		return ((Xml*)self)->getNumAttributes();
	}
	TS_CAPI TSString TS_CCALL tsXml_getAttributeName(TSXml self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getAttributeName(index)));
	}
	TS_CAPI bool_t TS_CCALL tsXml_setAttributes(TSXml self, const char *str) {
		TS_ASSERT(self);
		return ((Xml*)self)->setAttributes(str);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_ub(TSXml self, uint32_t index, bool_t value) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, (bool)value);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_us(TSXml self, uint32_t index, const char *value) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, value);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_ucS(TSXml self, uint32_t index, const TSString value) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, (value) ? *(const String*)value : String::null);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uiu(TSXml self, uint32_t index, int32_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, value, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uuu(TSXml self, uint32_t index, uint32_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, value, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uu64u(TSXml self, uint32_t index, uint64_t value, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, value, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_ufubb(TSXml self, uint32_t index, float32_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, value, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uf64ubb(TSXml self, uint32_t index, float64_t value, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, value, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI TSString TS_CCALL tsXml_getAttribute_cu(TSXml self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getAttribute(index)));
	}
	TS_CAPI int32_t TS_CCALL tsXml_getAttributei32(TSXml self, uint32_t index, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttributei32(index, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttributeu32(TSXml self, uint32_t index, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttributeu32(index, radix);
	}
	TS_CAPI uint64_t TS_CCALL tsXml_getAttributeu64(TSXml self, uint32_t index, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttributeu64(index, radix);
	}
	TS_CAPI float32_t TS_CCALL tsXml_getAttributef32(TSXml self, uint32_t index) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttributef32(index);
	}
	TS_CAPI float64_t TS_CCALL tsXml_getAttributef64(TSXml self, uint32_t index) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttributef64(index);
	}
	TS_CAPI TSString TS_CCALL tsXml_getAttribute_cscS(TSXml self, const char *name, const TSString value) {
		TS_ASSERT(self);
		return (TSString)(new String(((Xml*)self)->getAttribute(name, (value) ? *(const String*)value : String::null)));
	}
	TS_CAPI bool_t TS_CCALL tsXml_getAttribute_csb(TSXml self, const char *name, bool_t value) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(name, (bool)value);
	}
	TS_CAPI int32_t TS_CCALL tsXml_getAttribute_csiu(TSXml self, const char *name, int32_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(name, value, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttribute_csuu(TSXml self, const char *name, uint32_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(name, value, radix);
	}
	TS_CAPI uint64_t TS_CCALL tsXml_getAttribute_csu64u(TSXml self, const char *name, uint64_t value, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(name, value, radix);
	}
	TS_CAPI float32_t TS_CCALL tsXml_getAttribute_csf(TSXml self, const char *name, float32_t value) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(name, value);
	}
	TS_CAPI float64_t TS_CCALL tsXml_getAttribute_csf64(TSXml self, const char *name, float64_t value) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(name, value);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uspus(TSXml self, uint32_t index, const char **values, uint32_t size, const char *delimiter) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, values, size, delimiter);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_ucSus(TSXml self, uint32_t index, const TSString *values, uint32_t size, const char *delimiter) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, (values) ? *(const String**)values : nullptr, size, delimiter);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uipuu(TSXml self, uint32_t index, const int32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, values, size, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uupuu(TSXml self, uint32_t index, const uint32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, values, size, radix);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_ufpuubb(TSXml self, uint32_t index, const float32_t *values, uint32_t size, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, values, size, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI void TS_CCALL tsXml_setAttribute_uf64puubb(TSXml self, uint32_t index, const float64_t *values, uint32_t size, uint32_t digits, bool_t compact, bool_t exponent) {
		TS_ASSERT(self);
		((Xml*)self)->setAttribute(index, values, size, digits, (bool)compact, (bool)exponent);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttribute_cuSus(TSXml self, uint32_t index, TSString *values, uint32_t size, const char *delimiter) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(index, (values) ? *(String**)values : nullptr, size, delimiter);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttribute_cuiruu(TSXml self, uint32_t index, int32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(index, values, size, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttribute_cuuruu(TSXml self, uint32_t index, uint32_t *values, uint32_t size, uint32_t radix) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(index, values, size, radix);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttribute_cufru(TSXml self, uint32_t index, float32_t *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(index, values, size);
	}
	TS_CAPI uint32_t TS_CCALL tsXml_getAttribute_cuf64ru(TSXml self, uint32_t index, float64_t *values, uint32_t size) {
		TS_ASSERT(self);
		return ((Xml*)self)->getAttribute(index, values, size);
	}
	
	// Tellusim::Buffer
	TS_CAPI TSBuffer TS_CCALL tsBuffer_new(void) {
		Buffer *ret = new Buffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsBuffer_delete(TSBuffer self) {
		if(self) delete (Buffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_equalPtr(const TSBuffer self, const TSBuffer ptr) {
		return (self && ptr && ((Buffer*)self)->operator==(*(Buffer*)ptr));
	}
	TS_CAPI TSBuffer TS_CCALL tsBuffer_copyPtr(TSBuffer self) {
		Buffer *ret = nullptr;
		if(self) ret = new Buffer(*(Buffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBuffer)ret;
	}
	TS_CAPI TSBuffer TS_CCALL tsBuffer_clonePtr(const TSBuffer self) {
		Buffer *ret = (self) ? new Buffer(((Buffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsBuffer_clearPtr(TSBuffer self) {
		if(self) ((Buffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsBuffer_destroyPtr(TSBuffer self) {
		if(self) ((Buffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsBuffer_acquirePtr(TSBuffer self) {
		if(self) ((Buffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsBuffer_unacquirePtr(TSBuffer self) {
		if(self) ((Buffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_isValidPtr(const TSBuffer self) {
		return (self && ((Buffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_isOwnerPtr(const TSBuffer self) {
		return (self && ((Buffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_isConstPtr(const TSBuffer self) {
		return (self && ((Buffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsBuffer_getCountPtr(const TSBuffer self) {
		return ((Buffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsBuffer_getInternalPtr(const TSBuffer self) {
		return ((Buffer*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsBuffer_getPlatform(TSBuffer self) {
		TS_ASSERT(self);
		return (TS_Platform)((Buffer*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsBuffer_getPlatformName(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsBuffer_getIndex(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsBuffer_clear(TSBuffer self) {
		TS_ASSERT(self);
		((Buffer*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_isCreated(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsBuffer_setName(TSBuffer self, const char *name) {
		TS_ASSERT(self);
		((Buffer*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsBuffer_getName(TSBuffer self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Buffer*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_create(TSBuffer self, TS_BufferFlags flags, size_t size, TS_Format format) {
		TS_ASSERT(self);
		return ((Buffer*)self)->create((Buffer::Flags)flags, size, (Format)format);
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_isMapped(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->isMapped();
	}
	TS_CAPI TS_BufferFlags TS_CCALL tsBuffer_getFlags(TSBuffer self) {
		TS_ASSERT(self);
		return (TS_BufferFlags)((Buffer*)self)->getFlags();
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_hasFlag(TSBuffer self, TS_BufferFlags flags) {
		TS_ASSERT(self);
		return ((Buffer*)self)->hasFlag((Buffer::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsBuffer_hasFlags(TSBuffer self, TS_BufferFlags flags) {
		TS_ASSERT(self);
		return ((Buffer*)self)->hasFlags((Buffer::Flags)flags);
	}
	TS_CAPI TSString TS_CCALL tsBuffer_getFlagsName(TSBuffer self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Buffer*)self)->getFlagsName()));
	}
	TS_CAPI TS_Format TS_CCALL tsBuffer_getFormat(TSBuffer self) {
		TS_ASSERT(self);
		return (TS_Format)((Buffer*)self)->getFormat();
	}
	TS_CAPI const char* TS_CCALL tsBuffer_getFormatName(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getFormatName();
	}
	TS_CAPI uint32_t TS_CCALL tsBuffer_getComponents(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getComponents();
	}
	TS_CAPI uint32_t TS_CCALL tsBuffer_getPixelSize(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getPixelSize();
	}
	TS_CAPI size_t TS_CCALL tsBuffer_getSize(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getSize();
	}
	TS_CAPI size_t TS_CCALL tsBuffer_getPageSize(TSBuffer self) {
		TS_ASSERT(self);
		return ((Buffer*)self)->getPageSize();
	}
	TS_CAPI TSString TS_CCALL tsBuffer_getDescription(TSBuffer self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Buffer*)self)->getDescription()));
	}
	
	// Tellusim::BufferTable
	TS_CAPI TSBufferTable TS_CCALL tsBufferTable_new(void) {
		BufferTable *ret = new BufferTable();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBufferTable)ret;
	}
	TS_CAPI void TS_CCALL tsBufferTable_delete(TSBufferTable self) {
		if(self) delete (BufferTable*)self;
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_equalPtr(const TSBufferTable self, const TSBufferTable ptr) {
		return (self && ptr && ((BufferTable*)self)->operator==(*(BufferTable*)ptr));
	}
	TS_CAPI TSBufferTable TS_CCALL tsBufferTable_copyPtr(TSBufferTable self) {
		BufferTable *ret = nullptr;
		if(self) ret = new BufferTable(*(BufferTable*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBufferTable)ret;
	}
	TS_CAPI TSBufferTable TS_CCALL tsBufferTable_clonePtr(const TSBufferTable self) {
		BufferTable *ret = (self) ? new BufferTable(((BufferTable*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBufferTable)ret;
	}
	TS_CAPI void TS_CCALL tsBufferTable_clearPtr(TSBufferTable self) {
		if(self) ((BufferTable*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsBufferTable_destroyPtr(TSBufferTable self) {
		if(self) ((BufferTable*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsBufferTable_acquirePtr(TSBufferTable self) {
		if(self) ((BufferTable*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsBufferTable_unacquirePtr(TSBufferTable self) {
		if(self) ((BufferTable*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_isValidPtr(const TSBufferTable self) {
		return (self && ((BufferTable*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_isOwnerPtr(const TSBufferTable self) {
		return (self && ((BufferTable*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_isConstPtr(const TSBufferTable self) {
		return (self && ((BufferTable*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsBufferTable_getCountPtr(const TSBufferTable self) {
		return ((BufferTable*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsBufferTable_getInternalPtr(const TSBufferTable self) {
		return ((BufferTable*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsBufferTable_getPlatform(TSBufferTable self) {
		TS_ASSERT(self);
		return (TS_Platform)((BufferTable*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsBufferTable_getPlatformName(TSBufferTable self) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsBufferTable_getIndex(TSBufferTable self) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsBufferTable_clear(TSBufferTable self) {
		TS_ASSERT(self);
		((BufferTable*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_isCreated(TSBufferTable self) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsBufferTable_setName(TSBufferTable self, const char *name) {
		TS_ASSERT(self);
		((BufferTable*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsBufferTable_getName(TSBufferTable self) {
		TS_ASSERT(self);
		return (TSString)(new String(((BufferTable*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_create(TSBufferTable self, uint32_t size) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->create(size);
	}
	TS_CAPI uint32_t TS_CCALL tsBufferTable_getSize(TSBufferTable self) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->getSize();
	}
	TS_CAPI TSBuffer TS_CCALL tsBufferTable_get(TSBufferTable self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((BufferTable*)self)->get(index)));
	}
	TS_CAPI bool_t TS_CCALL tsBufferTable_isOwner(TSBufferTable self, uint32_t index) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->isOwner(index);
	}
	TS_CAPI size_t TS_CCALL tsBufferTable_getMemory(TSBufferTable self) {
		TS_ASSERT(self);
		return ((BufferTable*)self)->getMemory();
	}
	
	// Tellusim::D3D12Buffer
	TS_CAPI TSD3D12Buffer TS_CCALL tsD3D12Buffer_new(void) {
		D3D12Buffer *ret = new D3D12Buffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Buffer)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Buffer_delete(TSD3D12Buffer self) {
		if(self) delete (D3D12Buffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Buffer_equalPtr(const TSD3D12Buffer self, const TSD3D12Buffer ptr) {
		return (self && ptr && ((D3D12Buffer*)self)->operator==(*(D3D12Buffer*)ptr));
	}
	TS_CAPI TSD3D12Buffer TS_CCALL tsD3D12Buffer_copyPtr(TSD3D12Buffer self) {
		D3D12Buffer *ret = nullptr;
		if(self) ret = new D3D12Buffer(*(D3D12Buffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Buffer)ret;
	}
	TS_CAPI TSD3D12Buffer TS_CCALL tsD3D12Buffer_clonePtr(const TSD3D12Buffer self) {
		D3D12Buffer *ret = (self) ? new D3D12Buffer(((D3D12Buffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Buffer)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Buffer_clearPtr(TSD3D12Buffer self) {
		if(self) ((D3D12Buffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Buffer_destroyPtr(TSD3D12Buffer self) {
		if(self) ((D3D12Buffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Buffer_acquirePtr(TSD3D12Buffer self) {
		if(self) ((D3D12Buffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Buffer_unacquirePtr(TSD3D12Buffer self) {
		if(self) ((D3D12Buffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Buffer_isValidPtr(const TSD3D12Buffer self) {
		return (self && ((D3D12Buffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Buffer_isOwnerPtr(const TSD3D12Buffer self) {
		return (self && ((D3D12Buffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Buffer_isConstPtr(const TSD3D12Buffer self) {
		return (self && ((D3D12Buffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Buffer_getCountPtr(const TSD3D12Buffer self) {
		return ((D3D12Buffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Buffer_getInternalPtr(const TSD3D12Buffer self) {
		return ((D3D12Buffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Buffer_equalBufferPtr(const TSD3D12Buffer self, const TSBuffer base) {
		return (self && base && ((D3D12Buffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSD3D12Buffer TS_CCALL tsD3D12Buffer_castBufferPtr(TSBuffer base) {
		return (TSD3D12Buffer)(new D3D12Buffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsD3D12Buffer_baseBufferPtr(TSD3D12Buffer self) {
		return (TSBuffer)(new Buffer(((D3D12Buffer*)self)->getBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Buffer_create(TSD3D12Buffer self, TS_BufferFlags flags, ID3D12Resource *buffer, uint32_t state) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->create((Buffer::Flags)flags, buffer, state);
	}
	TS_CAPI ID3D12Resource* TS_CCALL tsD3D12Buffer_getD3D12Buffer(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getD3D12Buffer();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Buffer_getUnorderedAccessView(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getUnorderedAccessView();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Buffer_getShaderResourceView(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getShaderResourceView();
	}
	TS_CAPI uint64_t TS_CCALL tsD3D12Buffer_getBufferAddress(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getBufferAddress();
	}
	TS_CAPI void TS_CCALL tsD3D12Buffer_setBufferState(TSD3D12Buffer self, uint32_t state) {
		TS_ASSERT(self);
		((D3D12Buffer*)self)->setBufferState(state);
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Buffer_getBufferState(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getBufferState();
	}
	TS_CAPI void* TS_CCALL tsD3D12Buffer_getSharedHandle(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getSharedHandle();
	}
	TS_CAPI void* TS_CCALL tsD3D12Buffer_getInteropHandle(TSD3D12Buffer self) {
		TS_ASSERT(self);
		return ((D3D12Buffer*)self)->getInteropHandle();
	}
	
	// Tellusim::D3D11Buffer
	TS_CAPI TSD3D11Buffer TS_CCALL tsD3D11Buffer_new(void) {
		D3D11Buffer *ret = new D3D11Buffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Buffer)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Buffer_delete(TSD3D11Buffer self) {
		if(self) delete (D3D11Buffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Buffer_equalPtr(const TSD3D11Buffer self, const TSD3D11Buffer ptr) {
		return (self && ptr && ((D3D11Buffer*)self)->operator==(*(D3D11Buffer*)ptr));
	}
	TS_CAPI TSD3D11Buffer TS_CCALL tsD3D11Buffer_copyPtr(TSD3D11Buffer self) {
		D3D11Buffer *ret = nullptr;
		if(self) ret = new D3D11Buffer(*(D3D11Buffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Buffer)ret;
	}
	TS_CAPI TSD3D11Buffer TS_CCALL tsD3D11Buffer_clonePtr(const TSD3D11Buffer self) {
		D3D11Buffer *ret = (self) ? new D3D11Buffer(((D3D11Buffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Buffer)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Buffer_clearPtr(TSD3D11Buffer self) {
		if(self) ((D3D11Buffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Buffer_destroyPtr(TSD3D11Buffer self) {
		if(self) ((D3D11Buffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Buffer_acquirePtr(TSD3D11Buffer self) {
		if(self) ((D3D11Buffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Buffer_unacquirePtr(TSD3D11Buffer self) {
		if(self) ((D3D11Buffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Buffer_isValidPtr(const TSD3D11Buffer self) {
		return (self && ((D3D11Buffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Buffer_isOwnerPtr(const TSD3D11Buffer self) {
		return (self && ((D3D11Buffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Buffer_isConstPtr(const TSD3D11Buffer self) {
		return (self && ((D3D11Buffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Buffer_getCountPtr(const TSD3D11Buffer self) {
		return ((D3D11Buffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Buffer_getInternalPtr(const TSD3D11Buffer self) {
		return ((D3D11Buffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Buffer_equalBufferPtr(const TSD3D11Buffer self, const TSBuffer base) {
		return (self && base && ((D3D11Buffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSD3D11Buffer TS_CCALL tsD3D11Buffer_castBufferPtr(TSBuffer base) {
		return (TSD3D11Buffer)(new D3D11Buffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsD3D11Buffer_baseBufferPtr(TSD3D11Buffer self) {
		return (TSBuffer)(new Buffer(((D3D11Buffer*)self)->getBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Buffer_create(TSD3D11Buffer self, TS_BufferFlags flags, ID3D11Buffer *buffer) {
		TS_ASSERT(self);
		return ((D3D11Buffer*)self)->create((Buffer::Flags)flags, buffer);
	}
	TS_CAPI ID3D11Buffer* TS_CCALL tsD3D11Buffer_getD3D11Buffer(TSD3D11Buffer self) {
		TS_ASSERT(self);
		return ((D3D11Buffer*)self)->getD3D11Buffer();
	}
	TS_CAPI ID3D11UnorderedAccessView* TS_CCALL tsD3D11Buffer_getUnorderedAccessView(TSD3D11Buffer self) {
		TS_ASSERT(self);
		return ((D3D11Buffer*)self)->getUnorderedAccessView();
	}
	TS_CAPI ID3D11ShaderResourceView* TS_CCALL tsD3D11Buffer_getShaderResourceView(TSD3D11Buffer self) {
		TS_ASSERT(self);
		return ((D3D11Buffer*)self)->getShaderResourceView();
	}
	TS_CAPI void* TS_CCALL tsD3D11Buffer_getInteropHandle(TSD3D11Buffer self) {
		TS_ASSERT(self);
		return ((D3D11Buffer*)self)->getInteropHandle();
	}
	
	// Tellusim::MTLBuffer
	TS_CAPI TSMTLBuffer TS_CCALL tsMTLBuffer_new(void) {
		MTLBuffer *ret = new MTLBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsMTLBuffer_delete(TSMTLBuffer self) {
		if(self) delete (MTLBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLBuffer_equalPtr(const TSMTLBuffer self, const TSMTLBuffer ptr) {
		return (self && ptr && ((MTLBuffer*)self)->operator==(*(MTLBuffer*)ptr));
	}
	TS_CAPI TSMTLBuffer TS_CCALL tsMTLBuffer_copyPtr(TSMTLBuffer self) {
		MTLBuffer *ret = nullptr;
		if(self) ret = new MTLBuffer(*(MTLBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLBuffer)ret;
	}
	TS_CAPI TSMTLBuffer TS_CCALL tsMTLBuffer_clonePtr(const TSMTLBuffer self) {
		MTLBuffer *ret = (self) ? new MTLBuffer(((MTLBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsMTLBuffer_clearPtr(TSMTLBuffer self) {
		if(self) ((MTLBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLBuffer_destroyPtr(TSMTLBuffer self) {
		if(self) ((MTLBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLBuffer_acquirePtr(TSMTLBuffer self) {
		if(self) ((MTLBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLBuffer_unacquirePtr(TSMTLBuffer self) {
		if(self) ((MTLBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLBuffer_isValidPtr(const TSMTLBuffer self) {
		return (self && ((MTLBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLBuffer_isOwnerPtr(const TSMTLBuffer self) {
		return (self && ((MTLBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLBuffer_isConstPtr(const TSMTLBuffer self) {
		return (self && ((MTLBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLBuffer_getCountPtr(const TSMTLBuffer self) {
		return ((MTLBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLBuffer_getInternalPtr(const TSMTLBuffer self) {
		return ((MTLBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLBuffer_equalBufferPtr(const TSMTLBuffer self, const TSBuffer base) {
		return (self && base && ((MTLBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSMTLBuffer TS_CCALL tsMTLBuffer_castBufferPtr(TSBuffer base) {
		return (TSMTLBuffer)(new MTLBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsMTLBuffer_baseBufferPtr(TSMTLBuffer self) {
		return (TSBuffer)(new Buffer(((MTLBuffer*)self)->getBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsMTLBuffer_create(TSMTLBuffer self, TS_BufferFlags flags, void *buffer) {
		TS_ASSERT(self);
		return ((MTLBuffer*)self)->create((Buffer::Flags)flags, buffer);
	}
	TS_CAPI void* TS_CCALL tsMTLBuffer_getMTLBuffer(TSMTLBuffer self) {
		TS_ASSERT(self);
		return ((MTLBuffer*)self)->getMTLBuffer();
	}
	TS_CAPI void* TS_CCALL tsMTLBuffer_getSharedPtr(TSMTLBuffer self) {
		TS_ASSERT(self);
		return ((MTLBuffer*)self)->getSharedPtr();
	}
	
	// Tellusim::VKBuffer
	TS_CAPI TSVKBuffer TS_CCALL tsVKBuffer_new(void) {
		VKBuffer *ret = new VKBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsVKBuffer_delete(TSVKBuffer self) {
		if(self) delete (VKBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKBuffer_equalPtr(const TSVKBuffer self, const TSVKBuffer ptr) {
		return (self && ptr && ((VKBuffer*)self)->operator==(*(VKBuffer*)ptr));
	}
	TS_CAPI TSVKBuffer TS_CCALL tsVKBuffer_copyPtr(TSVKBuffer self) {
		VKBuffer *ret = nullptr;
		if(self) ret = new VKBuffer(*(VKBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKBuffer)ret;
	}
	TS_CAPI TSVKBuffer TS_CCALL tsVKBuffer_clonePtr(const TSVKBuffer self) {
		VKBuffer *ret = (self) ? new VKBuffer(((VKBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsVKBuffer_clearPtr(TSVKBuffer self) {
		if(self) ((VKBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKBuffer_destroyPtr(TSVKBuffer self) {
		if(self) ((VKBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKBuffer_acquirePtr(TSVKBuffer self) {
		if(self) ((VKBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKBuffer_unacquirePtr(TSVKBuffer self) {
		if(self) ((VKBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKBuffer_isValidPtr(const TSVKBuffer self) {
		return (self && ((VKBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKBuffer_isOwnerPtr(const TSVKBuffer self) {
		return (self && ((VKBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKBuffer_isConstPtr(const TSVKBuffer self) {
		return (self && ((VKBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKBuffer_getCountPtr(const TSVKBuffer self) {
		return ((VKBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKBuffer_getInternalPtr(const TSVKBuffer self) {
		return ((VKBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKBuffer_equalBufferPtr(const TSVKBuffer self, const TSBuffer base) {
		return (self && base && ((VKBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSVKBuffer TS_CCALL tsVKBuffer_castBufferPtr(TSBuffer base) {
		return (TSVKBuffer)(new VKBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsVKBuffer_baseBufferPtr(TSVKBuffer self) {
		return (TSBuffer)(new Buffer(((VKBuffer*)self)->getBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsVKBuffer_create(TSVKBuffer self, TS_BufferFlags flags, size_t size, VkBuffer buffer, uint32_t access) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->create((Buffer::Flags)flags, size, buffer, access);
	}
	TS_CAPI VkBuffer TS_CCALL tsVKBuffer_getVKBuffer(TSVKBuffer self) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->getVKBuffer();
	}
	TS_CAPI VkBufferView TS_CCALL tsVKBuffer_getBufferView(TSVKBuffer self) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->getBufferView();
	}
	TS_CAPI uint64_t TS_CCALL tsVKBuffer_getBufferAddress(TSVKBuffer self) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->getBufferAddress();
	}
	TS_CAPI void TS_CCALL tsVKBuffer_setBufferAccess(TSVKBuffer self, uint32_t access) {
		TS_ASSERT(self);
		((VKBuffer*)self)->setBufferAccess(access);
	}
	TS_CAPI uint32_t TS_CCALL tsVKBuffer_getBufferAccess(TSVKBuffer self) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->getBufferAccess();
	}
	TS_CAPI void* TS_CCALL tsVKBuffer_getSharedPtr(TSVKBuffer self) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->getSharedPtr();
	}
	TS_CAPI void* TS_CCALL tsVKBuffer_getInteropHandle(TSVKBuffer self) {
		TS_ASSERT(self);
		return ((VKBuffer*)self)->getInteropHandle();
	}
	
	// Tellusim::GLBuffer
	TS_CAPI TSGLBuffer TS_CCALL tsGLBuffer_new(void) {
		GLBuffer *ret = new GLBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsGLBuffer_delete(TSGLBuffer self) {
		if(self) delete (GLBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLBuffer_equalPtr(const TSGLBuffer self, const TSGLBuffer ptr) {
		return (self && ptr && ((GLBuffer*)self)->operator==(*(GLBuffer*)ptr));
	}
	TS_CAPI TSGLBuffer TS_CCALL tsGLBuffer_copyPtr(TSGLBuffer self) {
		GLBuffer *ret = nullptr;
		if(self) ret = new GLBuffer(*(GLBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLBuffer)ret;
	}
	TS_CAPI TSGLBuffer TS_CCALL tsGLBuffer_clonePtr(const TSGLBuffer self) {
		GLBuffer *ret = (self) ? new GLBuffer(((GLBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsGLBuffer_clearPtr(TSGLBuffer self) {
		if(self) ((GLBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLBuffer_destroyPtr(TSGLBuffer self) {
		if(self) ((GLBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLBuffer_acquirePtr(TSGLBuffer self) {
		if(self) ((GLBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLBuffer_unacquirePtr(TSGLBuffer self) {
		if(self) ((GLBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLBuffer_isValidPtr(const TSGLBuffer self) {
		return (self && ((GLBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLBuffer_isOwnerPtr(const TSGLBuffer self) {
		return (self && ((GLBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLBuffer_isConstPtr(const TSGLBuffer self) {
		return (self && ((GLBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLBuffer_getCountPtr(const TSGLBuffer self) {
		return ((GLBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLBuffer_getInternalPtr(const TSGLBuffer self) {
		return ((GLBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLBuffer_equalBufferPtr(const TSGLBuffer self, const TSBuffer base) {
		return (self && base && ((GLBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSGLBuffer TS_CCALL tsGLBuffer_castBufferPtr(TSBuffer base) {
		return (TSGLBuffer)(new GLBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsGLBuffer_baseBufferPtr(TSGLBuffer self) {
		return (TSBuffer)(new Buffer(((GLBuffer*)self)->getBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsGLBuffer_create(TSGLBuffer self, TS_BufferFlags flags, uint32_t target, uint32_t buffer_id) {
		TS_ASSERT(self);
		return ((GLBuffer*)self)->create((Buffer::Flags)flags, target, buffer_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLBuffer_getTarget(TSGLBuffer self) {
		TS_ASSERT(self);
		return ((GLBuffer*)self)->getTarget();
	}
	TS_CAPI uint32_t TS_CCALL tsGLBuffer_getBufferID(TSGLBuffer self) {
		TS_ASSERT(self);
		return ((GLBuffer*)self)->getBufferID();
	}
	
	// Tellusim::GLESBuffer
	TS_CAPI TSGLESBuffer TS_CCALL tsGLESBuffer_new(void) {
		GLESBuffer *ret = new GLESBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsGLESBuffer_delete(TSGLESBuffer self) {
		if(self) delete (GLESBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLESBuffer_equalPtr(const TSGLESBuffer self, const TSGLESBuffer ptr) {
		return (self && ptr && ((GLESBuffer*)self)->operator==(*(GLESBuffer*)ptr));
	}
	TS_CAPI TSGLESBuffer TS_CCALL tsGLESBuffer_copyPtr(TSGLESBuffer self) {
		GLESBuffer *ret = nullptr;
		if(self) ret = new GLESBuffer(*(GLESBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESBuffer)ret;
	}
	TS_CAPI TSGLESBuffer TS_CCALL tsGLESBuffer_clonePtr(const TSGLESBuffer self) {
		GLESBuffer *ret = (self) ? new GLESBuffer(((GLESBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsGLESBuffer_clearPtr(TSGLESBuffer self) {
		if(self) ((GLESBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLESBuffer_destroyPtr(TSGLESBuffer self) {
		if(self) ((GLESBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLESBuffer_acquirePtr(TSGLESBuffer self) {
		if(self) ((GLESBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLESBuffer_unacquirePtr(TSGLESBuffer self) {
		if(self) ((GLESBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESBuffer_isValidPtr(const TSGLESBuffer self) {
		return (self && ((GLESBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESBuffer_isOwnerPtr(const TSGLESBuffer self) {
		return (self && ((GLESBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESBuffer_isConstPtr(const TSGLESBuffer self) {
		return (self && ((GLESBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLESBuffer_getCountPtr(const TSGLESBuffer self) {
		return ((GLESBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLESBuffer_getInternalPtr(const TSGLESBuffer self) {
		return ((GLESBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESBuffer_equalBufferPtr(const TSGLESBuffer self, const TSBuffer base) {
		return (self && base && ((GLESBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSGLESBuffer TS_CCALL tsGLESBuffer_castBufferPtr(TSBuffer base) {
		return (TSGLESBuffer)(new GLESBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsGLESBuffer_baseBufferPtr(TSGLESBuffer self) {
		return (TSBuffer)(new Buffer(((GLESBuffer*)self)->getBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsGLESBuffer_create(TSGLESBuffer self, TS_BufferFlags flags, uint32_t target, uint32_t buffer_id) {
		TS_ASSERT(self);
		return ((GLESBuffer*)self)->create((Buffer::Flags)flags, target, buffer_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLESBuffer_getTarget(TSGLESBuffer self) {
		TS_ASSERT(self);
		return ((GLESBuffer*)self)->getTarget();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESBuffer_getBufferID(TSGLESBuffer self) {
		TS_ASSERT(self);
		return ((GLESBuffer*)self)->getBufferID();
	}
	
	// Tellusim::CUBuffer
	TS_CAPI TSCUBuffer TS_CCALL tsCUBuffer_new(void) {
		CUBuffer *ret = new CUBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsCUBuffer_delete(TSCUBuffer self) {
		if(self) delete (CUBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCUBuffer_equalPtr(const TSCUBuffer self, const TSCUBuffer ptr) {
		return (self && ptr && ((CUBuffer*)self)->operator==(*(CUBuffer*)ptr));
	}
	TS_CAPI TSCUBuffer TS_CCALL tsCUBuffer_copyPtr(TSCUBuffer self) {
		CUBuffer *ret = nullptr;
		if(self) ret = new CUBuffer(*(CUBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUBuffer)ret;
	}
	TS_CAPI TSCUBuffer TS_CCALL tsCUBuffer_clonePtr(const TSCUBuffer self) {
		CUBuffer *ret = (self) ? new CUBuffer(((CUBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsCUBuffer_clearPtr(TSCUBuffer self) {
		if(self) ((CUBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCUBuffer_destroyPtr(TSCUBuffer self) {
		if(self) ((CUBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCUBuffer_acquirePtr(TSCUBuffer self) {
		if(self) ((CUBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCUBuffer_unacquirePtr(TSCUBuffer self) {
		if(self) ((CUBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUBuffer_isValidPtr(const TSCUBuffer self) {
		return (self && ((CUBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUBuffer_isOwnerPtr(const TSCUBuffer self) {
		return (self && ((CUBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUBuffer_isConstPtr(const TSCUBuffer self) {
		return (self && ((CUBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCUBuffer_getCountPtr(const TSCUBuffer self) {
		return ((CUBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCUBuffer_getInternalPtr(const TSCUBuffer self) {
		return ((CUBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUBuffer_equalBufferPtr(const TSCUBuffer self, const TSBuffer base) {
		return (self && base && ((CUBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSCUBuffer TS_CCALL tsCUBuffer_castBufferPtr(TSBuffer base) {
		return (TSCUBuffer)(new CUBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsCUBuffer_baseBufferPtr(TSCUBuffer self) {
		return (TSBuffer)(new Buffer(((CUBuffer*)self)->getBuffer()));
	}
	TS_CAPI size_t TS_CCALL tsCUBuffer_getBufferPtr(TSCUBuffer self) {
		TS_ASSERT(self);
		return ((CUBuffer*)self)->getBufferPtr();
	}
	TS_CAPI uint8_t* TS_CCALL tsCUBuffer_getBufferData(TSCUBuffer self) {
		TS_ASSERT(self);
		return ((CUBuffer*)self)->getBufferData();
	}
	TS_CAPI CUevent TS_CCALL tsCUBuffer_getBufferEvent(TSCUBuffer self) {
		TS_ASSERT(self);
		return ((CUBuffer*)self)->getBufferEvent();
	}
	TS_CAPI uint32_t TS_CCALL tsCUBuffer_getArrayFormat(TSCUBuffer self) {
		TS_ASSERT(self);
		return ((CUBuffer*)self)->getArrayFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsCUBuffer_getArrayChannels(TSCUBuffer self) {
		TS_ASSERT(self);
		return ((CUBuffer*)self)->getArrayChannels();
	}
	TS_CAPI CUexternalMemory TS_CCALL tsCUBuffer_getSharedMemory(TSCUBuffer self) {
		TS_ASSERT(self);
		return ((CUBuffer*)self)->getSharedMemory();
	}
	
	// Tellusim::HIPBuffer
	TS_CAPI TSHIPBuffer TS_CCALL tsHIPBuffer_new(void) {
		HIPBuffer *ret = new HIPBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsHIPBuffer_delete(TSHIPBuffer self) {
		if(self) delete (HIPBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsHIPBuffer_equalPtr(const TSHIPBuffer self, const TSHIPBuffer ptr) {
		return (self && ptr && ((HIPBuffer*)self)->operator==(*(HIPBuffer*)ptr));
	}
	TS_CAPI TSHIPBuffer TS_CCALL tsHIPBuffer_copyPtr(TSHIPBuffer self) {
		HIPBuffer *ret = nullptr;
		if(self) ret = new HIPBuffer(*(HIPBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPBuffer)ret;
	}
	TS_CAPI TSHIPBuffer TS_CCALL tsHIPBuffer_clonePtr(const TSHIPBuffer self) {
		HIPBuffer *ret = (self) ? new HIPBuffer(((HIPBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsHIPBuffer_clearPtr(TSHIPBuffer self) {
		if(self) ((HIPBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsHIPBuffer_destroyPtr(TSHIPBuffer self) {
		if(self) ((HIPBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsHIPBuffer_acquirePtr(TSHIPBuffer self) {
		if(self) ((HIPBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsHIPBuffer_unacquirePtr(TSHIPBuffer self) {
		if(self) ((HIPBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPBuffer_isValidPtr(const TSHIPBuffer self) {
		return (self && ((HIPBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPBuffer_isOwnerPtr(const TSHIPBuffer self) {
		return (self && ((HIPBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPBuffer_isConstPtr(const TSHIPBuffer self) {
		return (self && ((HIPBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsHIPBuffer_getCountPtr(const TSHIPBuffer self) {
		return ((HIPBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsHIPBuffer_getInternalPtr(const TSHIPBuffer self) {
		return ((HIPBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPBuffer_equalBufferPtr(const TSHIPBuffer self, const TSBuffer base) {
		return (self && base && ((HIPBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSHIPBuffer TS_CCALL tsHIPBuffer_castBufferPtr(TSBuffer base) {
		return (TSHIPBuffer)(new HIPBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsHIPBuffer_baseBufferPtr(TSHIPBuffer self) {
		return (TSBuffer)(new Buffer(((HIPBuffer*)self)->getBuffer()));
	}
	TS_CAPI void* TS_CCALL tsHIPBuffer_getBufferPtr(TSHIPBuffer self) {
		TS_ASSERT(self);
		return ((HIPBuffer*)self)->getBufferPtr();
	}
	TS_CAPI uint8_t* TS_CCALL tsHIPBuffer_getBufferData(TSHIPBuffer self) {
		TS_ASSERT(self);
		return ((HIPBuffer*)self)->getBufferData();
	}
	TS_CAPI void* TS_CCALL tsHIPBuffer_getBufferEvent(TSHIPBuffer self) {
		TS_ASSERT(self);
		return ((HIPBuffer*)self)->getBufferEvent();
	}
	TS_CAPI uint32_t TS_CCALL tsHIPBuffer_getArrayFormat(TSHIPBuffer self) {
		TS_ASSERT(self);
		return ((HIPBuffer*)self)->getArrayFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsHIPBuffer_getArrayChannels(TSHIPBuffer self) {
		TS_ASSERT(self);
		return ((HIPBuffer*)self)->getArrayChannels();
	}
	TS_CAPI void* TS_CCALL tsHIPBuffer_getSharedMemory(TSHIPBuffer self) {
		TS_ASSERT(self);
		return ((HIPBuffer*)self)->getSharedMemory();
	}
	
	// Tellusim::FUBuffer
	TS_CAPI TSFUBuffer TS_CCALL tsFUBuffer_new(void) {
		FUBuffer *ret = new FUBuffer();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUBuffer)ret;
	}
	TS_CAPI TSFUBuffer TS_CCALL tsFUBuffer_new_cABb(const TSBuffer *buffers, uint32_t buffers_size, bool_t owner) {
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		FUBuffer *ret = new FUBuffer(buffers_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsFUBuffer_delete(TSFUBuffer self) {
		if(self) delete (FUBuffer*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUBuffer_equalPtr(const TSFUBuffer self, const TSFUBuffer ptr) {
		return (self && ptr && ((FUBuffer*)self)->operator==(*(FUBuffer*)ptr));
	}
	TS_CAPI TSFUBuffer TS_CCALL tsFUBuffer_copyPtr(TSFUBuffer self) {
		FUBuffer *ret = nullptr;
		if(self) ret = new FUBuffer(*(FUBuffer*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUBuffer)ret;
	}
	TS_CAPI TSFUBuffer TS_CCALL tsFUBuffer_clonePtr(const TSFUBuffer self) {
		FUBuffer *ret = (self) ? new FUBuffer(((FUBuffer*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUBuffer)ret;
	}
	TS_CAPI void TS_CCALL tsFUBuffer_clearPtr(TSFUBuffer self) {
		if(self) ((FUBuffer*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUBuffer_destroyPtr(TSFUBuffer self) {
		if(self) ((FUBuffer*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUBuffer_acquirePtr(TSFUBuffer self) {
		if(self) ((FUBuffer*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUBuffer_unacquirePtr(TSFUBuffer self) {
		if(self) ((FUBuffer*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUBuffer_isValidPtr(const TSFUBuffer self) {
		return (self && ((FUBuffer*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUBuffer_isOwnerPtr(const TSFUBuffer self) {
		return (self && ((FUBuffer*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUBuffer_isConstPtr(const TSFUBuffer self) {
		return (self && ((FUBuffer*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUBuffer_getCountPtr(const TSFUBuffer self) {
		return ((FUBuffer*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUBuffer_getInternalPtr(const TSFUBuffer self) {
		return ((FUBuffer*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUBuffer_equalBufferPtr(const TSFUBuffer self, const TSBuffer base) {
		return (self && base && ((FUBuffer*)self)->operator==(*(Buffer*)base));
	}
	TS_CAPI TSFUBuffer TS_CCALL tsFUBuffer_castBufferPtr(TSBuffer base) {
		return (TSFUBuffer)(new FUBuffer(*(Buffer*)base));
	}
	TS_CAPI TSBuffer TS_CCALL tsFUBuffer_baseBufferPtr(TSFUBuffer self) {
		return (TSBuffer)(new Buffer(((FUBuffer*)self)->getBuffer()));
	}
	TS_CAPI void TS_CCALL tsFUBuffer_setMask(TSFUBuffer self, uint32_t mask) {
		TS_ASSERT(self);
		((FUBuffer*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUBuffer_getMask(TSFUBuffer self) {
		TS_ASSERT(self);
		return ((FUBuffer*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUBuffer_getNumBuffers(TSFUBuffer self) {
		TS_ASSERT(self);
		return ((FUBuffer*)self)->getNumBuffers();
	}
	TS_CAPI TSBuffer TS_CCALL tsFUBuffer_getBuffer_cu(TSFUBuffer self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((FUBuffer*)self)->getBuffer(index)));
	}
	TS_CAPI TSBuffer TS_CCALL tsFUBuffer_getBuffer_u(TSFUBuffer self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((FUBuffer*)self)->getBuffer(index)));
	}
	
	// Tellusim::Command
	TS_CAPI TSCommand TS_CCALL tsCommand_new(void) {
		Command *ret = new Command();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCommand)ret;
	}
	TS_CAPI void TS_CCALL tsCommand_delete(TSCommand self) {
		if(self) delete (Command*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCommand_equalPtr(const TSCommand self, const TSCommand ptr) {
		return (self && ptr && ((Command*)self)->operator==(*(Command*)ptr));
	}
	TS_CAPI TSCommand TS_CCALL tsCommand_copyPtr(TSCommand self) {
		Command *ret = nullptr;
		if(self) ret = new Command(*(Command*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCommand)ret;
	}
	TS_CAPI TSCommand TS_CCALL tsCommand_clonePtr(const TSCommand self) {
		Command *ret = (self) ? new Command(((Command*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCommand)ret;
	}
	TS_CAPI void TS_CCALL tsCommand_clearPtr(TSCommand self) {
		if(self) ((Command*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCommand_destroyPtr(TSCommand self) {
		if(self) ((Command*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCommand_acquirePtr(TSCommand self) {
		if(self) ((Command*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCommand_unacquirePtr(TSCommand self) {
		if(self) ((Command*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCommand_isValidPtr(const TSCommand self) {
		return (self && ((Command*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCommand_isOwnerPtr(const TSCommand self) {
		return (self && ((Command*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCommand_isConstPtr(const TSCommand self) {
		return (self && ((Command*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCommand_getCountPtr(const TSCommand self) {
		return ((Command*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCommand_getInternalPtr(const TSCommand self) {
		return ((Command*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsCommand_getPlatform(TSCommand self) {
		TS_ASSERT(self);
		return (TS_Platform)((Command*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsCommand_getPlatformName(TSCommand self) {
		TS_ASSERT(self);
		return ((Command*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsCommand_getIndex(TSCommand self) {
		TS_ASSERT(self);
		return ((Command*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsCommand_setPipeline(TSCommand self, TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((Command*)self)->setPipeline(*(Pipeline*)pipeline);
	}
	TS_CAPI TSPipeline TS_CCALL tsCommand_getPipeline(TSCommand self) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Command*)self)->getPipeline()));
	}
	TS_CAPI void TS_CCALL tsCommand_setViewport(TSCommand self, uint32_t index, const TSViewport *viewport) {
		TS_ASSERT(self);
		TS_ASSERT(viewport);
		((Command*)self)->setViewport(index, *(const Viewport*)viewport);
	}
	TS_CAPI void TS_CCALL tsCommand_setViewports(TSCommand self, const TSViewport *viewports, uint32_t num_viewports) {
		TS_ASSERT(self);
		((Command*)self)->setViewports(*(const Viewport**)&viewports, num_viewports);
	}
	TS_CAPI void TS_CCALL tsCommand_setScissor(TSCommand self, uint32_t index, const TSScissor *scissor) {
		TS_ASSERT(self);
		TS_ASSERT(scissor);
		((Command*)self)->setScissor(index, *(const Scissor*)scissor);
	}
	TS_CAPI void TS_CCALL tsCommand_setScissors(TSCommand self, const TSScissor *scissors, uint32_t num_scissors) {
		TS_ASSERT(self);
		((Command*)self)->setScissors(*(const Scissor**)&scissors, num_scissors);
	}
	TS_CAPI void TS_CCALL tsCommand_setSampler(TSCommand self, uint32_t index, TSSampler sampler) {
		TS_ASSERT(self);
		TS_ASSERT(sampler);
		((Command*)self)->setSampler(index, *(Sampler*)sampler);
	}
	TS_CAPI void TS_CCALL tsCommand_setSamplers_ucAS(TSCommand self, uint32_t index, const TSSampler *samplers, uint32_t samplers_size) {
		TS_ASSERT(self);
		Array<Sampler> samplers_(samplers_size);
		for(uint32_t i = 0; i < samplers_size; i++) if(samplers[i]) samplers_[i] = *(Sampler*)samplers[i];
		((Command*)self)->setSamplers(index, samplers_);
	}
	TS_CAPI void TS_CCALL tsCommand_setTexture_uT(TSCommand self, uint32_t index, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Command*)self)->setTexture(index, *(Texture*)texture);
	}
	TS_CAPI void TS_CCALL tsCommand_setTexture_uTcS(TSCommand self, uint32_t index, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Command*)self)->setTexture(index, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void TS_CCALL tsCommand_setTextures_ucAT(TSCommand self, uint32_t index, const TSTexture *textures, uint32_t textures_size) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		((Command*)self)->setTextures(index, textures_);
	}
	TS_CAPI void TS_CCALL tsCommand_setSurfaceTexture_uT(TSCommand self, uint32_t index, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Command*)self)->setSurfaceTexture(index, *(Texture*)texture);
	}
	TS_CAPI void TS_CCALL tsCommand_setSurfaceTexture_uTcSF(TSCommand self, uint32_t index, TSTexture texture, const TSSlice *slice, TS_Format format) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Command*)self)->setSurfaceTexture(index, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice(), (Format)format);
	}
	TS_CAPI void TS_CCALL tsCommand_setSurfaceTextures_ucAT(TSCommand self, uint32_t index, const TSTexture *textures, uint32_t textures_size) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		((Command*)self)->setSurfaceTextures(index, textures_);
	}
	TS_CAPI void* TS_CCALL tsCommand_getUniformData(TSCommand self, uint32_t index, size_t size) {
		TS_ASSERT(self);
		return ((Command*)self)->getUniformData(index, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setUniformData(TSCommand self, uint32_t index, const void *src, size_t size) {
		TS_ASSERT(self);
		((Command*)self)->setUniformData(index, src, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setUniformBuffer(TSCommand self, uint32_t index, TSBuffer buffer, size_t offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->setUniformBuffer(index, *(Buffer*)buffer, offset, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setUniformOffset(TSCommand self, uint32_t index, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Command*)self)->setUniformOffset(index, offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCommand_setUniformBuffers_ucAB(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Command*)self)->setUniformBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCommand_setUniformBuffers_ucABcA(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size, const size_t *offsets, uint32_t offsets_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		Array<size_t> offsets_(offsets_size, offsets);
		((Command*)self)->setUniformBuffers(index, buffers_, offsets_);
	}
	TS_CAPI void* TS_CCALL tsCommand_getStorageData(TSCommand self, uint32_t index, size_t size) {
		TS_ASSERT(self);
		return ((Command*)self)->getStorageData(index, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageData(TSCommand self, uint32_t index, const void *src, size_t size) {
		TS_ASSERT(self);
		((Command*)self)->setStorageData(index, src, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageBuffer(TSCommand self, uint32_t index, TSBuffer buffer, size_t offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->setStorageBuffer(index, *(Buffer*)buffer, offset, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageOffset(TSCommand self, uint32_t index, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Command*)self)->setStorageOffset(index, offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageBuffers_ucAB(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Command*)self)->setStorageBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageBuffers_ucABcA(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size, const size_t *offsets, uint32_t offsets_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		Array<size_t> offsets_(offsets_size, offsets);
		((Command*)self)->setStorageBuffers(index, buffers_, offsets_);
	}
	TS_CAPI void TS_CCALL tsCommand_setTracing(TSCommand self, uint32_t index, TSTracing tracing) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		((Command*)self)->setTracing(index, *(Tracing*)tracing);
	}
	TS_CAPI void TS_CCALL tsCommand_setTracings_ucAT(TSCommand self, uint32_t index, const TSTracing *tracings, uint32_t tracings_size) {
		TS_ASSERT(self);
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		((Command*)self)->setTracings(index, tracings_);
	}
	TS_CAPI void TS_CCALL tsCommand_setTexelBuffer(TSCommand self, uint32_t index, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->setTexelBuffer(index, *(Buffer*)buffer);
	}
	TS_CAPI void TS_CCALL tsCommand_setTexelBuffers_ucAB(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Command*)self)->setTexelBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCommand_setTextureTable(TSCommand self, uint32_t index, TSTextureTable table) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		((Command*)self)->setTextureTable(index, *(TextureTable*)table);
	}
	TS_CAPI void TS_CCALL tsCommand_setTextureTables_ucATT(TSCommand self, uint32_t index, const TSTextureTable *tables, uint32_t tables_size) {
		TS_ASSERT(self);
		Array<TextureTable> tables_(tables_size);
		for(uint32_t i = 0; i < tables_size; i++) if(tables[i]) tables_[i] = *(TextureTable*)tables[i];
		((Command*)self)->setTextureTables(index, tables_);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageTable(TSCommand self, uint32_t index, TSBufferTable table) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		((Command*)self)->setStorageTable(index, *(BufferTable*)table);
	}
	TS_CAPI void TS_CCALL tsCommand_setStorageTables_ucABT(TSCommand self, uint32_t index, const TSBufferTable *tables, uint32_t tables_size) {
		TS_ASSERT(self);
		Array<BufferTable> tables_(tables_size);
		for(uint32_t i = 0; i < tables_size; i++) if(tables[i]) tables_[i] = *(BufferTable*)tables[i];
		((Command*)self)->setStorageTables(index, tables_);
	}
	TS_CAPI void* TS_CCALL tsCommand_getVertexData(TSCommand self, uint32_t index, size_t size) {
		TS_ASSERT(self);
		return ((Command*)self)->getVertexData(index, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setVertexData(TSCommand self, uint32_t index, const void *src, size_t size) {
		TS_ASSERT(self);
		((Command*)self)->setVertexData(index, src, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setVertexBuffer(TSCommand self, uint32_t index, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->setVertexBuffer(index, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsCommand_setVertexOffset(TSCommand self, uint32_t index, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Command*)self)->setVertexOffset(index, offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCommand_setVertexBuffers_ucAB(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Command*)self)->setVertexBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCommand_setVertexBuffers_ucABcA(TSCommand self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size, const size_t *offsets, uint32_t offsets_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		Array<size_t> offsets_(offsets_size, offsets);
		((Command*)self)->setVertexBuffers(index, buffers_, offsets_);
	}
	TS_CAPI void* TS_CCALL tsCommand_getIndexData(TSCommand self, TS_Format format, size_t size) {
		TS_ASSERT(self);
		return ((Command*)self)->getIndexData((Format)format, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setIndexData(TSCommand self, TS_Format format, const void *src, size_t size) {
		TS_ASSERT(self);
		((Command*)self)->setIndexData((Format)format, src, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setIndexBuffer(TSCommand self, TS_Format format, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->setIndexBuffer((Format)format, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsCommand_setIndexOffset(TSCommand self, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Command*)self)->setIndexOffset(offset, (bool)relative);
	}
	TS_CAPI void* TS_CCALL tsCommand_getIndirectData(TSCommand self, size_t size) {
		TS_ASSERT(self);
		return ((Command*)self)->getIndirectData(size);
	}
	TS_CAPI void TS_CCALL tsCommand_setIndirectData(TSCommand self, const void *src, size_t size) {
		TS_ASSERT(self);
		((Command*)self)->setIndirectData(src, size);
	}
	TS_CAPI void TS_CCALL tsCommand_setIndirectBuffer(TSCommand self, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->setIndirectBuffer(*(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsCommand_setIndirectOffset(TSCommand self, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Command*)self)->setIndirectOffset(offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCommand_setBlendColor_cC(TSCommand self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((Command*)self)->setBlendColor(*(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsCommand_setBlendColor_ffff(TSCommand self, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((Command*)self)->setBlendColor(r, g, b, a);
	}
	TS_CAPI void TS_CCALL tsCommand_setStencilRef(TSCommand self, uint32_t ref) {
		TS_ASSERT(self);
		((Command*)self)->setStencilRef(ref);
	}
	TS_CAPI void TS_CCALL tsCommand_drawArrays(TSCommand self, uint32_t num_vertices, uint32_t base_vertex) {
		TS_ASSERT(self);
		((Command*)self)->drawArrays(num_vertices, base_vertex);
	}
	TS_CAPI void TS_CCALL tsCommand_drawArraysInstanced(TSCommand self, uint32_t num_vertices, uint32_t base_vertex, uint32_t num_instances, uint32_t base_instance) {
		TS_ASSERT(self);
		((Command*)self)->drawArraysInstanced(num_vertices, base_vertex, num_instances, base_instance);
	}
	TS_CAPI void TS_CCALL tsCommand_drawArraysIndirect_uz(TSCommand self, uint32_t num_draws, size_t stride) {
		TS_ASSERT(self);
		((Command*)self)->drawArraysIndirect(num_draws, stride);
	}
	TS_CAPI void TS_CCALL tsCommand_drawArraysIndirect_Bzuz(TSCommand self, TSBuffer buffer, size_t offset, uint32_t num_draws, size_t stride) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->drawArraysIndirect(*(Buffer*)buffer, offset, num_draws, stride);
	}
	TS_CAPI void TS_CCALL tsCommand_drawElements(TSCommand self, uint32_t num_indices, uint32_t base_index, int32_t base_vertex) {
		TS_ASSERT(self);
		((Command*)self)->drawElements(num_indices, base_index, base_vertex);
	}
	TS_CAPI void TS_CCALL tsCommand_drawElementsInstanced_uuu(TSCommand self, uint32_t num_indices, uint32_t base_index, uint32_t num_instances) {
		TS_ASSERT(self);
		((Command*)self)->drawElementsInstanced(num_indices, base_index, num_instances);
	}
	TS_CAPI void TS_CCALL tsCommand_drawElementsInstanced_uuiuu(TSCommand self, uint32_t num_indices, uint32_t base_index, int32_t base_vertex, uint32_t num_instances, uint32_t base_instance) {
		TS_ASSERT(self);
		((Command*)self)->drawElementsInstanced(num_indices, base_index, base_vertex, num_instances, base_instance);
	}
	TS_CAPI void TS_CCALL tsCommand_drawElementsIndirect_uz(TSCommand self, uint32_t num_draws, size_t stride) {
		TS_ASSERT(self);
		((Command*)self)->drawElementsIndirect(num_draws, stride);
	}
	TS_CAPI void TS_CCALL tsCommand_drawElementsIndirect_Bzuz(TSCommand self, TSBuffer buffer, size_t offset, uint32_t num_draws, size_t stride) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->drawElementsIndirect(*(Buffer*)buffer, offset, num_draws, stride);
	}
	TS_CAPI void TS_CCALL tsCommand_drawMesh(TSCommand self, uint32_t width, uint32_t height, uint32_t depth) {
		TS_ASSERT(self);
		((Command*)self)->drawMesh(width, height, depth);
	}
	TS_CAPI void TS_CCALL tsCommand_drawMeshIndirect_uz(TSCommand self, uint32_t num_draws, size_t stride) {
		TS_ASSERT(self);
		((Command*)self)->drawMeshIndirect(num_draws, stride);
	}
	TS_CAPI void TS_CCALL tsCommand_drawMeshIndirect_Bzuz(TSCommand self, TSBuffer buffer, size_t offset, uint32_t num_draws, size_t stride) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->drawMeshIndirect(*(Buffer*)buffer, offset, num_draws, stride);
	}
	TS_CAPI void TS_CCALL tsCommand_beginConditional(TSCommand self, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Command*)self)->beginConditional(*(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsCommand_endConditional(TSCommand self) {
		TS_ASSERT(self);
		((Command*)self)->endConditional();
	}
	TS_CAPI bool_t TS_CCALL tsCommand_beginQuery(TSCommand self, TSQuery query) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		return ((Command*)self)->beginQuery(*(Query*)query);
	}
	TS_CAPI void TS_CCALL tsCommand_endQuery(TSCommand self, TSQuery query) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		((Command*)self)->endQuery(*(Query*)query);
	}
	
	// Tellusim::D3D12Command
	TS_CAPI TSD3D12Command TS_CCALL tsD3D12Command_new(void) {
		D3D12Command *ret = new D3D12Command();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Command)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Command_delete(TSD3D12Command self) {
		if(self) delete (D3D12Command*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Command_equalPtr(const TSD3D12Command self, const TSD3D12Command ptr) {
		return (self && ptr && ((D3D12Command*)self)->operator==(*(D3D12Command*)ptr));
	}
	TS_CAPI TSD3D12Command TS_CCALL tsD3D12Command_copyPtr(TSD3D12Command self) {
		D3D12Command *ret = nullptr;
		if(self) ret = new D3D12Command(*(D3D12Command*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Command)ret;
	}
	TS_CAPI TSD3D12Command TS_CCALL tsD3D12Command_clonePtr(const TSD3D12Command self) {
		D3D12Command *ret = (self) ? new D3D12Command(((D3D12Command*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Command)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Command_clearPtr(TSD3D12Command self) {
		if(self) ((D3D12Command*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Command_destroyPtr(TSD3D12Command self) {
		if(self) ((D3D12Command*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Command_acquirePtr(TSD3D12Command self) {
		if(self) ((D3D12Command*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Command_unacquirePtr(TSD3D12Command self) {
		if(self) ((D3D12Command*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Command_isValidPtr(const TSD3D12Command self) {
		return (self && ((D3D12Command*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Command_isOwnerPtr(const TSD3D12Command self) {
		return (self && ((D3D12Command*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Command_isConstPtr(const TSD3D12Command self) {
		return (self && ((D3D12Command*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Command_getCountPtr(const TSD3D12Command self) {
		return ((D3D12Command*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Command_getInternalPtr(const TSD3D12Command self) {
		return ((D3D12Command*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Command_equalCommandPtr(const TSD3D12Command self, const TSCommand base) {
		return (self && base && ((D3D12Command*)self)->operator==(*(Command*)base));
	}
	TS_CAPI TSD3D12Command TS_CCALL tsD3D12Command_castCommandPtr(TSCommand base) {
		return (TSD3D12Command)(new D3D12Command(*(Command*)base));
	}
	TS_CAPI TSCommand TS_CCALL tsD3D12Command_baseCommandPtr(TSD3D12Command self) {
		return (TSCommand)(new Command(((D3D12Command*)self)->getCommand()));
	}
	TS_CAPI ID3D12GraphicsCommandList* TS_CCALL tsD3D12Command_getD3D12Command(TSD3D12Command self) {
		TS_ASSERT(self);
		return ((D3D12Command*)self)->getD3D12Command();
	}
	TS_CAPI void TS_CCALL tsD3D12Command_update(TSD3D12Command self) {
		TS_ASSERT(self);
		((D3D12Command*)self)->update();
	}
	
	// Tellusim::MTLCommand
	TS_CAPI TSMTLCommand TS_CCALL tsMTLCommand_new(void) {
		MTLCommand *ret = new MTLCommand();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLCommand)ret;
	}
	TS_CAPI void TS_CCALL tsMTLCommand_delete(TSMTLCommand self) {
		if(self) delete (MTLCommand*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLCommand_equalPtr(const TSMTLCommand self, const TSMTLCommand ptr) {
		return (self && ptr && ((MTLCommand*)self)->operator==(*(MTLCommand*)ptr));
	}
	TS_CAPI TSMTLCommand TS_CCALL tsMTLCommand_copyPtr(TSMTLCommand self) {
		MTLCommand *ret = nullptr;
		if(self) ret = new MTLCommand(*(MTLCommand*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLCommand)ret;
	}
	TS_CAPI TSMTLCommand TS_CCALL tsMTLCommand_clonePtr(const TSMTLCommand self) {
		MTLCommand *ret = (self) ? new MTLCommand(((MTLCommand*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLCommand)ret;
	}
	TS_CAPI void TS_CCALL tsMTLCommand_clearPtr(TSMTLCommand self) {
		if(self) ((MTLCommand*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLCommand_destroyPtr(TSMTLCommand self) {
		if(self) ((MTLCommand*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLCommand_acquirePtr(TSMTLCommand self) {
		if(self) ((MTLCommand*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLCommand_unacquirePtr(TSMTLCommand self) {
		if(self) ((MTLCommand*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLCommand_isValidPtr(const TSMTLCommand self) {
		return (self && ((MTLCommand*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLCommand_isOwnerPtr(const TSMTLCommand self) {
		return (self && ((MTLCommand*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLCommand_isConstPtr(const TSMTLCommand self) {
		return (self && ((MTLCommand*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLCommand_getCountPtr(const TSMTLCommand self) {
		return ((MTLCommand*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLCommand_getInternalPtr(const TSMTLCommand self) {
		return ((MTLCommand*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLCommand_equalCommandPtr(const TSMTLCommand self, const TSCommand base) {
		return (self && base && ((MTLCommand*)self)->operator==(*(Command*)base));
	}
	TS_CAPI TSMTLCommand TS_CCALL tsMTLCommand_castCommandPtr(TSCommand base) {
		return (TSMTLCommand)(new MTLCommand(*(Command*)base));
	}
	TS_CAPI TSCommand TS_CCALL tsMTLCommand_baseCommandPtr(TSMTLCommand self) {
		return (TSCommand)(new Command(((MTLCommand*)self)->getCommand()));
	}
	TS_CAPI void* TS_CCALL tsMTLCommand_getEncoder(TSMTLCommand self) {
		TS_ASSERT(self);
		return ((MTLCommand*)self)->getEncoder();
	}
	TS_CAPI void TS_CCALL tsMTLCommand_flush_prb(TSMTLCommand self, void *encoder, bool_t enqueue) {
		TS_ASSERT(self);
		((MTLCommand*)self)->flush(encoder, (bool)enqueue);
	}
	TS_CAPI void TS_CCALL tsMTLCommand_flush_bb(TSMTLCommand self, bool_t create, bool_t enqueue) {
		TS_ASSERT(self);
		((MTLCommand*)self)->flush((bool)create, (bool)enqueue);
	}
	TS_CAPI void TS_CCALL tsMTLCommand_update(TSMTLCommand self) {
		TS_ASSERT(self);
		((MTLCommand*)self)->update();
	}
	
	// Tellusim::VKCommand
	TS_CAPI TSVKCommand TS_CCALL tsVKCommand_new(void) {
		VKCommand *ret = new VKCommand();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKCommand)ret;
	}
	TS_CAPI void TS_CCALL tsVKCommand_delete(TSVKCommand self) {
		if(self) delete (VKCommand*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKCommand_equalPtr(const TSVKCommand self, const TSVKCommand ptr) {
		return (self && ptr && ((VKCommand*)self)->operator==(*(VKCommand*)ptr));
	}
	TS_CAPI TSVKCommand TS_CCALL tsVKCommand_copyPtr(TSVKCommand self) {
		VKCommand *ret = nullptr;
		if(self) ret = new VKCommand(*(VKCommand*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKCommand)ret;
	}
	TS_CAPI TSVKCommand TS_CCALL tsVKCommand_clonePtr(const TSVKCommand self) {
		VKCommand *ret = (self) ? new VKCommand(((VKCommand*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKCommand)ret;
	}
	TS_CAPI void TS_CCALL tsVKCommand_clearPtr(TSVKCommand self) {
		if(self) ((VKCommand*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKCommand_destroyPtr(TSVKCommand self) {
		if(self) ((VKCommand*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKCommand_acquirePtr(TSVKCommand self) {
		if(self) ((VKCommand*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKCommand_unacquirePtr(TSVKCommand self) {
		if(self) ((VKCommand*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKCommand_isValidPtr(const TSVKCommand self) {
		return (self && ((VKCommand*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKCommand_isOwnerPtr(const TSVKCommand self) {
		return (self && ((VKCommand*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKCommand_isConstPtr(const TSVKCommand self) {
		return (self && ((VKCommand*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKCommand_getCountPtr(const TSVKCommand self) {
		return ((VKCommand*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKCommand_getInternalPtr(const TSVKCommand self) {
		return ((VKCommand*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKCommand_equalCommandPtr(const TSVKCommand self, const TSCommand base) {
		return (self && base && ((VKCommand*)self)->operator==(*(Command*)base));
	}
	TS_CAPI TSVKCommand TS_CCALL tsVKCommand_castCommandPtr(TSCommand base) {
		return (TSVKCommand)(new VKCommand(*(Command*)base));
	}
	TS_CAPI TSCommand TS_CCALL tsVKCommand_baseCommandPtr(TSVKCommand self) {
		return (TSCommand)(new Command(((VKCommand*)self)->getCommand()));
	}
	TS_CAPI VkCommandBuffer TS_CCALL tsVKCommand_getVKCommand(TSVKCommand self) {
		TS_ASSERT(self);
		return ((VKCommand*)self)->getVKCommand();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCommand_getSamplerDescriptor(TSVKCommand self) {
		TS_ASSERT(self);
		return ((VKCommand*)self)->getSamplerDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCommand_getImageDescriptor(TSVKCommand self) {
		TS_ASSERT(self);
		return ((VKCommand*)self)->getImageDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCommand_getBufferDescriptor(TSVKCommand self) {
		TS_ASSERT(self);
		return ((VKCommand*)self)->getBufferDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCommand_getTracingDescriptor(TSVKCommand self) {
		TS_ASSERT(self);
		return ((VKCommand*)self)->getTracingDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCommand_getTexelDescriptor(TSVKCommand self) {
		TS_ASSERT(self);
		return ((VKCommand*)self)->getTexelDescriptor();
	}
	TS_CAPI void TS_CCALL tsVKCommand_update(TSVKCommand self) {
		TS_ASSERT(self);
		((VKCommand*)self)->update();
	}
	
	// Tellusim::FUCommand
	TS_CAPI TSFUCommand TS_CCALL tsFUCommand_new(void) {
		FUCommand *ret = new FUCommand();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCommand)ret;
	}
	TS_CAPI TSFUCommand TS_CCALL tsFUCommand_new_cACb(const TSCommand *commands, uint32_t commands_size, bool_t owner) {
		Array<Command> commands_(commands_size);
		for(uint32_t i = 0; i < commands_size; i++) if(commands[i]) commands_[i] = *(Command*)commands[i];
		FUCommand *ret = new FUCommand(commands_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCommand)ret;
	}
	TS_CAPI void TS_CCALL tsFUCommand_delete(TSFUCommand self) {
		if(self) delete (FUCommand*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUCommand_equalPtr(const TSFUCommand self, const TSFUCommand ptr) {
		return (self && ptr && ((FUCommand*)self)->operator==(*(FUCommand*)ptr));
	}
	TS_CAPI TSFUCommand TS_CCALL tsFUCommand_copyPtr(TSFUCommand self) {
		FUCommand *ret = nullptr;
		if(self) ret = new FUCommand(*(FUCommand*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCommand)ret;
	}
	TS_CAPI TSFUCommand TS_CCALL tsFUCommand_clonePtr(const TSFUCommand self) {
		FUCommand *ret = (self) ? new FUCommand(((FUCommand*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCommand)ret;
	}
	TS_CAPI void TS_CCALL tsFUCommand_clearPtr(TSFUCommand self) {
		if(self) ((FUCommand*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUCommand_destroyPtr(TSFUCommand self) {
		if(self) ((FUCommand*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUCommand_acquirePtr(TSFUCommand self) {
		if(self) ((FUCommand*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUCommand_unacquirePtr(TSFUCommand self) {
		if(self) ((FUCommand*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUCommand_isValidPtr(const TSFUCommand self) {
		return (self && ((FUCommand*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUCommand_isOwnerPtr(const TSFUCommand self) {
		return (self && ((FUCommand*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUCommand_isConstPtr(const TSFUCommand self) {
		return (self && ((FUCommand*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUCommand_getCountPtr(const TSFUCommand self) {
		return ((FUCommand*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUCommand_getInternalPtr(const TSFUCommand self) {
		return ((FUCommand*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUCommand_equalCommandPtr(const TSFUCommand self, const TSCommand base) {
		return (self && base && ((FUCommand*)self)->operator==(*(Command*)base));
	}
	TS_CAPI TSFUCommand TS_CCALL tsFUCommand_castCommandPtr(TSCommand base) {
		return (TSFUCommand)(new FUCommand(*(Command*)base));
	}
	TS_CAPI TSCommand TS_CCALL tsFUCommand_baseCommandPtr(TSFUCommand self) {
		return (TSCommand)(new Command(((FUCommand*)self)->getCommand()));
	}
	TS_CAPI void TS_CCALL tsFUCommand_setMask(TSFUCommand self, uint32_t mask) {
		TS_ASSERT(self);
		((FUCommand*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUCommand_getMask(TSFUCommand self) {
		TS_ASSERT(self);
		return ((FUCommand*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUCommand_getNumCommands(TSFUCommand self) {
		TS_ASSERT(self);
		return ((FUCommand*)self)->getNumCommands();
	}
	TS_CAPI TSCommand TS_CCALL tsFUCommand_getCommand_cu(TSFUCommand self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCommand)(new Command(((FUCommand*)self)->getCommand(index)));
	}
	TS_CAPI TSCommand TS_CCALL tsFUCommand_getCommand_u(TSFUCommand self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCommand)(new Command(((FUCommand*)self)->getCommand(index)));
	}
	
	// Tellusim::Compute
	TS_CAPI TSCompute TS_CCALL tsCompute_new(void) {
		Compute *ret = new Compute();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCompute)ret;
	}
	TS_CAPI void TS_CCALL tsCompute_delete(TSCompute self) {
		if(self) delete (Compute*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCompute_equalPtr(const TSCompute self, const TSCompute ptr) {
		return (self && ptr && ((Compute*)self)->operator==(*(Compute*)ptr));
	}
	TS_CAPI TSCompute TS_CCALL tsCompute_copyPtr(TSCompute self) {
		Compute *ret = nullptr;
		if(self) ret = new Compute(*(Compute*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCompute)ret;
	}
	TS_CAPI TSCompute TS_CCALL tsCompute_clonePtr(const TSCompute self) {
		Compute *ret = (self) ? new Compute(((Compute*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCompute)ret;
	}
	TS_CAPI void TS_CCALL tsCompute_clearPtr(TSCompute self) {
		if(self) ((Compute*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCompute_destroyPtr(TSCompute self) {
		if(self) ((Compute*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCompute_acquirePtr(TSCompute self) {
		if(self) ((Compute*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCompute_unacquirePtr(TSCompute self) {
		if(self) ((Compute*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCompute_isValidPtr(const TSCompute self) {
		return (self && ((Compute*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCompute_isOwnerPtr(const TSCompute self) {
		return (self && ((Compute*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCompute_isConstPtr(const TSCompute self) {
		return (self && ((Compute*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCompute_getCountPtr(const TSCompute self) {
		return ((Compute*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCompute_getInternalPtr(const TSCompute self) {
		return ((Compute*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsCompute_getPlatform(TSCompute self) {
		TS_ASSERT(self);
		return (TS_Platform)((Compute*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsCompute_getPlatformName(TSCompute self) {
		TS_ASSERT(self);
		return ((Compute*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsCompute_getIndex(TSCompute self) {
		TS_ASSERT(self);
		return ((Compute*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsCompute_setKernel(TSCompute self, TSKernel kernel) {
		TS_ASSERT(self);
		TS_ASSERT(kernel);
		((Compute*)self)->setKernel(*(Kernel*)kernel);
	}
	TS_CAPI TSKernel TS_CCALL tsCompute_getKernel(TSCompute self) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Compute*)self)->getKernel()));
	}
	TS_CAPI void TS_CCALL tsCompute_setTraversal(TSCompute self, TSTraversal traversal) {
		TS_ASSERT(self);
		TS_ASSERT(traversal);
		((Compute*)self)->setTraversal(*(Traversal*)traversal);
	}
	TS_CAPI TSTraversal TS_CCALL tsCompute_getTraversal(TSCompute self) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Compute*)self)->getTraversal()));
	}
	TS_CAPI void TS_CCALL tsCompute_setSampler(TSCompute self, uint32_t index, TSSampler sampler) {
		TS_ASSERT(self);
		TS_ASSERT(sampler);
		((Compute*)self)->setSampler(index, *(Sampler*)sampler);
	}
	TS_CAPI void TS_CCALL tsCompute_setSamplers_ucAS(TSCompute self, uint32_t index, const TSSampler *samplers, uint32_t samplers_size) {
		TS_ASSERT(self);
		Array<Sampler> samplers_(samplers_size);
		for(uint32_t i = 0; i < samplers_size; i++) if(samplers[i]) samplers_[i] = *(Sampler*)samplers[i];
		((Compute*)self)->setSamplers(index, samplers_);
	}
	TS_CAPI void TS_CCALL tsCompute_setTexture_uT(TSCompute self, uint32_t index, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Compute*)self)->setTexture(index, *(Texture*)texture);
	}
	TS_CAPI void TS_CCALL tsCompute_setTexture_uTcS(TSCompute self, uint32_t index, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Compute*)self)->setTexture(index, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void TS_CCALL tsCompute_setTextures_ucAT(TSCompute self, uint32_t index, const TSTexture *textures, uint32_t textures_size) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		((Compute*)self)->setTextures(index, textures_);
	}
	TS_CAPI void TS_CCALL tsCompute_setSurfaceTexture_uT(TSCompute self, uint32_t index, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Compute*)self)->setSurfaceTexture(index, *(Texture*)texture);
	}
	TS_CAPI void TS_CCALL tsCompute_setSurfaceTexture_uTcSF(TSCompute self, uint32_t index, TSTexture texture, const TSSlice *slice, TS_Format format) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Compute*)self)->setSurfaceTexture(index, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice(), (Format)format);
	}
	TS_CAPI void TS_CCALL tsCompute_setSurfaceTextures_ucAT(TSCompute self, uint32_t index, const TSTexture *textures, uint32_t textures_size) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		((Compute*)self)->setSurfaceTextures(index, textures_);
	}
	TS_CAPI void* TS_CCALL tsCompute_getUniformData(TSCompute self, uint32_t index, size_t size) {
		TS_ASSERT(self);
		return ((Compute*)self)->getUniformData(index, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setUniformData(TSCompute self, uint32_t index, const void *src, size_t size) {
		TS_ASSERT(self);
		((Compute*)self)->setUniformData(index, src, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setUniformBuffer(TSCompute self, uint32_t index, TSBuffer buffer, size_t offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Compute*)self)->setUniformBuffer(index, *(Buffer*)buffer, offset, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setUniformOffset(TSCompute self, uint32_t index, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Compute*)self)->setUniformOffset(index, offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCompute_setUniformBuffers_ucAB(TSCompute self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Compute*)self)->setUniformBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCompute_setUniformBuffers_ucABcA(TSCompute self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size, const size_t *offsets, uint32_t offsets_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		Array<size_t> offsets_(offsets_size, offsets);
		((Compute*)self)->setUniformBuffers(index, buffers_, offsets_);
	}
	TS_CAPI void* TS_CCALL tsCompute_getStorageData(TSCompute self, uint32_t index, size_t size) {
		TS_ASSERT(self);
		return ((Compute*)self)->getStorageData(index, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageData(TSCompute self, uint32_t index, const void *src, size_t size) {
		TS_ASSERT(self);
		((Compute*)self)->setStorageData(index, src, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageBuffer(TSCompute self, uint32_t index, TSBuffer buffer, size_t offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Compute*)self)->setStorageBuffer(index, *(Buffer*)buffer, offset, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageOffset(TSCompute self, uint32_t index, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Compute*)self)->setStorageOffset(index, offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageBuffers_ucAB(TSCompute self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Compute*)self)->setStorageBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageBuffers_ucABcA(TSCompute self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size, const size_t *offsets, uint32_t offsets_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		Array<size_t> offsets_(offsets_size, offsets);
		((Compute*)self)->setStorageBuffers(index, buffers_, offsets_);
	}
	TS_CAPI void TS_CCALL tsCompute_setTracing(TSCompute self, uint32_t index, TSTracing tracing) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		((Compute*)self)->setTracing(index, *(Tracing*)tracing);
	}
	TS_CAPI void TS_CCALL tsCompute_setTracings_ucAT(TSCompute self, uint32_t index, const TSTracing *tracings, uint32_t tracings_size) {
		TS_ASSERT(self);
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		((Compute*)self)->setTracings(index, tracings_);
	}
	TS_CAPI void TS_CCALL tsCompute_setTexelBuffer(TSCompute self, uint32_t index, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Compute*)self)->setTexelBuffer(index, *(Buffer*)buffer);
	}
	TS_CAPI void TS_CCALL tsCompute_setTexelBuffers_ucAB(TSCompute self, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Compute*)self)->setTexelBuffers(index, buffers_);
	}
	TS_CAPI void TS_CCALL tsCompute_setTextureTable(TSCompute self, uint32_t index, TSTextureTable table) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		((Compute*)self)->setTextureTable(index, *(TextureTable*)table);
	}
	TS_CAPI void TS_CCALL tsCompute_setTextureTables_ucATT(TSCompute self, uint32_t index, const TSTextureTable *tables, uint32_t tables_size) {
		TS_ASSERT(self);
		Array<TextureTable> tables_(tables_size);
		for(uint32_t i = 0; i < tables_size; i++) if(tables[i]) tables_[i] = *(TextureTable*)tables[i];
		((Compute*)self)->setTextureTables(index, tables_);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageTable(TSCompute self, uint32_t index, TSBufferTable table) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		((Compute*)self)->setStorageTable(index, *(BufferTable*)table);
	}
	TS_CAPI void TS_CCALL tsCompute_setStorageTables_ucABT(TSCompute self, uint32_t index, const TSBufferTable *tables, uint32_t tables_size) {
		TS_ASSERT(self);
		Array<BufferTable> tables_(tables_size);
		for(uint32_t i = 0; i < tables_size; i++) if(tables[i]) tables_[i] = *(BufferTable*)tables[i];
		((Compute*)self)->setStorageTables(index, tables_);
	}
	TS_CAPI void* TS_CCALL tsCompute_getIndirectData(TSCompute self, size_t size) {
		TS_ASSERT(self);
		return ((Compute*)self)->getIndirectData(size);
	}
	TS_CAPI void TS_CCALL tsCompute_setIndirectData(TSCompute self, const void *src, size_t size) {
		TS_ASSERT(self);
		((Compute*)self)->setIndirectData(src, size);
	}
	TS_CAPI void TS_CCALL tsCompute_setIndirectBuffer(TSCompute self, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Compute*)self)->setIndirectBuffer(*(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsCompute_setIndirectOffset(TSCompute self, size_t offset, bool_t relative) {
		TS_ASSERT(self);
		((Compute*)self)->setIndirectOffset(offset, (bool)relative);
	}
	TS_CAPI void TS_CCALL tsCompute_dispatch_uuu(TSCompute self, uint32_t width, uint32_t height, uint32_t depth) {
		TS_ASSERT(self);
		((Compute*)self)->dispatch(width, height, depth);
	}
	TS_CAPI void TS_CCALL tsCompute_dispatch_cT(TSCompute self, const TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Compute*)self)->dispatch(*(const Texture*)texture);
	}
	TS_CAPI void TS_CCALL tsCompute_dispatch_cS(TSCompute self, const TSSize *size) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		((Compute*)self)->dispatch(*(const Size*)size);
	}
	TS_CAPI void TS_CCALL tsCompute_dispatchIndirect(TSCompute self) {
		TS_ASSERT(self);
		((Compute*)self)->dispatchIndirect();
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setBuffer_Bzpz(TSCompute self, TSBuffer buffer, size_t offset, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->setBuffer(*(Buffer*)buffer, offset, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setBuffer_Bpz(TSCompute self, TSBuffer buffer, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->setBuffer(*(Buffer*)buffer, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setBuffer_Bp(TSCompute self, TSBuffer buffer, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->setBuffer(*(Buffer*)buffer, src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyBuffer_BzBzz(TSCompute self, TSBuffer buffer, size_t dest_offset, TSBuffer src, size_t src_offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Compute*)self)->copyBuffer(*(Buffer*)buffer, dest_offset, *(Buffer*)src, src_offset, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyBuffer_BzBz(TSCompute self, TSBuffer buffer, size_t dest_offset, TSBuffer src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Compute*)self)->copyBuffer(*(Buffer*)buffer, dest_offset, *(Buffer*)src, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyBuffer_BBz(TSCompute self, TSBuffer buffer, TSBuffer src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Compute*)self)->copyBuffer(*(Buffer*)buffer, *(Buffer*)src, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyBuffer_BB(TSCompute self, TSBuffer buffer, TSBuffer src) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Compute*)self)->copyBuffer(*(Buffer*)buffer, *(Buffer*)src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearBuffer_BFzpz(TSCompute self, TSBuffer buffer, TS_Format format, size_t offset, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->clearBuffer(*(Buffer*)buffer, (Format)format, offset, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearBuffer_BFpz(TSCompute self, TSBuffer buffer, TS_Format format, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->clearBuffer(*(Buffer*)buffer, (Format)format, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearBuffer_BFp(TSCompute self, TSBuffer buffer, TS_Format format, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->clearBuffer(*(Buffer*)buffer, (Format)format, src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearBuffer_B(TSCompute self, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Compute*)self)->clearBuffer(*(Buffer*)buffer);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setTexture_TcOcScIcS(TSCompute self, TSTexture texture, const TSOrigin *dest_origin, const TSSlice *dest_slice, const TSImage image, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(image);
		return ((Compute*)self)->setTexture(*(Texture*)texture, *(const Origin*)dest_origin, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(const Image*)image, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setTexture_TcOcI(TSCompute self, TSTexture texture, const TSOrigin *dest_origin, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(image);
		return ((Compute*)self)->setTexture(*(Texture*)texture, *(const Origin*)dest_origin, *(const Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setTexture_TcScI(TSCompute self, TSTexture texture, const TSSlice *dest_slice, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Compute*)self)->setTexture(*(Texture*)texture, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(const Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_setTexture_TcI(TSCompute self, TSTexture texture, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Compute*)self)->setTexture(*(Texture*)texture, *(const Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyTexture_TcOcSTcRcS(TSCompute self, TSTexture texture, const TSOrigin *dest_origin, const TSSlice *dest_slice, TSTexture src, const TSRegion *src_region, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(src);
		TS_ASSERT(src_region);
		return ((Compute*)self)->copyTexture(*(Texture*)texture, *(const Origin*)dest_origin, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(Texture*)src, *(const Region*)src_region, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyTexture_TcOTcR(TSCompute self, TSTexture texture, const TSOrigin *dest_origin, TSTexture src, const TSRegion *src_region) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(src);
		TS_ASSERT(src_region);
		return ((Compute*)self)->copyTexture(*(Texture*)texture, *(const Origin*)dest_origin, *(Texture*)src, *(const Region*)src_region);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyTexture_TcSTcS(TSCompute self, TSTexture texture, const TSSlice *dest_slice, TSTexture src, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(src);
		return ((Compute*)self)->copyTexture(*(Texture*)texture, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsCompute_copyTexture_TT(TSCompute self, TSTexture texture, TSTexture src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(src);
		return ((Compute*)self)->copyTexture(*(Texture*)texture, *(Texture*)src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearTexture_TcRcSp(TSCompute self, TSTexture texture, const TSRegion *region, const TSSlice *slice, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(region);
		return ((Compute*)self)->clearTexture(*(Texture*)texture, *(const Region*)region, (slice) ? *(const Slice*)slice : Slice(), src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearTexture_TcRp(TSCompute self, TSTexture texture, const TSRegion *region, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(region);
		return ((Compute*)self)->clearTexture(*(Texture*)texture, *(const Region*)region, src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearTexture_TcSp(TSCompute self, TSTexture texture, const TSSlice *slice, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Compute*)self)->clearTexture(*(Texture*)texture, (slice) ? *(const Slice*)slice : Slice(), src);
	}
	TS_CAPI bool_t TS_CCALL tsCompute_clearTexture_Tp(TSCompute self, TSTexture texture, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Compute*)self)->clearTexture(*(Texture*)texture, src);
	}
	TS_CAPI void TS_CCALL tsCompute_barrier_T(TSCompute self, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Compute*)self)->barrier(*(Texture*)texture);
	}
	TS_CAPI void TS_CCALL tsCompute_barrier_B(TSCompute self, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Compute*)self)->barrier(*(Buffer*)buffer);
	}
	TS_CAPI void TS_CCALL tsCompute_barrier_cAT(TSCompute self, const TSTexture *textures, uint32_t textures_size) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		((Compute*)self)->barrier(textures_);
	}
	TS_CAPI void TS_CCALL tsCompute_barrier_cAB(TSCompute self, const TSBuffer *buffers, uint32_t buffers_size) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		((Compute*)self)->barrier(buffers_);
	}
	TS_CAPI void TS_CCALL tsCompute_beginConditional(TSCompute self, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Compute*)self)->beginConditional(*(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsCompute_endConditional(TSCompute self) {
		TS_ASSERT(self);
		((Compute*)self)->endConditional();
	}
	TS_CAPI bool_t TS_CCALL tsCompute_beginQuery(TSCompute self, TSQuery query) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		return ((Compute*)self)->beginQuery(*(Query*)query);
	}
	TS_CAPI void TS_CCALL tsCompute_endQuery(TSCompute self, TSQuery query) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		((Compute*)self)->endQuery(*(Query*)query);
	}
	
	// Tellusim::D3D12Compute
	TS_CAPI TSD3D12Compute TS_CCALL tsD3D12Compute_new(void) {
		D3D12Compute *ret = new D3D12Compute();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Compute)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Compute_delete(TSD3D12Compute self) {
		if(self) delete (D3D12Compute*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Compute_equalPtr(const TSD3D12Compute self, const TSD3D12Compute ptr) {
		return (self && ptr && ((D3D12Compute*)self)->operator==(*(D3D12Compute*)ptr));
	}
	TS_CAPI TSD3D12Compute TS_CCALL tsD3D12Compute_copyPtr(TSD3D12Compute self) {
		D3D12Compute *ret = nullptr;
		if(self) ret = new D3D12Compute(*(D3D12Compute*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Compute)ret;
	}
	TS_CAPI TSD3D12Compute TS_CCALL tsD3D12Compute_clonePtr(const TSD3D12Compute self) {
		D3D12Compute *ret = (self) ? new D3D12Compute(((D3D12Compute*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Compute)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Compute_clearPtr(TSD3D12Compute self) {
		if(self) ((D3D12Compute*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Compute_destroyPtr(TSD3D12Compute self) {
		if(self) ((D3D12Compute*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Compute_acquirePtr(TSD3D12Compute self) {
		if(self) ((D3D12Compute*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Compute_unacquirePtr(TSD3D12Compute self) {
		if(self) ((D3D12Compute*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Compute_isValidPtr(const TSD3D12Compute self) {
		return (self && ((D3D12Compute*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Compute_isOwnerPtr(const TSD3D12Compute self) {
		return (self && ((D3D12Compute*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Compute_isConstPtr(const TSD3D12Compute self) {
		return (self && ((D3D12Compute*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Compute_getCountPtr(const TSD3D12Compute self) {
		return ((D3D12Compute*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Compute_getInternalPtr(const TSD3D12Compute self) {
		return ((D3D12Compute*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Compute_equalComputePtr(const TSD3D12Compute self, const TSCompute base) {
		return (self && base && ((D3D12Compute*)self)->operator==(*(Compute*)base));
	}
	TS_CAPI TSD3D12Compute TS_CCALL tsD3D12Compute_castComputePtr(TSCompute base) {
		return (TSD3D12Compute)(new D3D12Compute(*(Compute*)base));
	}
	TS_CAPI TSCompute TS_CCALL tsD3D12Compute_baseComputePtr(TSD3D12Compute self) {
		return (TSCompute)(new Compute(((D3D12Compute*)self)->getCompute()));
	}
	TS_CAPI ID3D12GraphicsCommandList* TS_CCALL tsD3D12Compute_getCommand(TSD3D12Compute self) {
		TS_ASSERT(self);
		return ((D3D12Compute*)self)->getCommand();
	}
	TS_CAPI void TS_CCALL tsD3D12Compute_update(TSD3D12Compute self) {
		TS_ASSERT(self);
		((D3D12Compute*)self)->update();
	}
	
	// Tellusim::MTLCompute
	TS_CAPI TSMTLCompute TS_CCALL tsMTLCompute_new(void) {
		MTLCompute *ret = new MTLCompute();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLCompute)ret;
	}
	TS_CAPI void TS_CCALL tsMTLCompute_delete(TSMTLCompute self) {
		if(self) delete (MTLCompute*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLCompute_equalPtr(const TSMTLCompute self, const TSMTLCompute ptr) {
		return (self && ptr && ((MTLCompute*)self)->operator==(*(MTLCompute*)ptr));
	}
	TS_CAPI TSMTLCompute TS_CCALL tsMTLCompute_copyPtr(TSMTLCompute self) {
		MTLCompute *ret = nullptr;
		if(self) ret = new MTLCompute(*(MTLCompute*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLCompute)ret;
	}
	TS_CAPI TSMTLCompute TS_CCALL tsMTLCompute_clonePtr(const TSMTLCompute self) {
		MTLCompute *ret = (self) ? new MTLCompute(((MTLCompute*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLCompute)ret;
	}
	TS_CAPI void TS_CCALL tsMTLCompute_clearPtr(TSMTLCompute self) {
		if(self) ((MTLCompute*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLCompute_destroyPtr(TSMTLCompute self) {
		if(self) ((MTLCompute*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLCompute_acquirePtr(TSMTLCompute self) {
		if(self) ((MTLCompute*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLCompute_unacquirePtr(TSMTLCompute self) {
		if(self) ((MTLCompute*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLCompute_isValidPtr(const TSMTLCompute self) {
		return (self && ((MTLCompute*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLCompute_isOwnerPtr(const TSMTLCompute self) {
		return (self && ((MTLCompute*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLCompute_isConstPtr(const TSMTLCompute self) {
		return (self && ((MTLCompute*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLCompute_getCountPtr(const TSMTLCompute self) {
		return ((MTLCompute*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLCompute_getInternalPtr(const TSMTLCompute self) {
		return ((MTLCompute*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLCompute_equalComputePtr(const TSMTLCompute self, const TSCompute base) {
		return (self && base && ((MTLCompute*)self)->operator==(*(Compute*)base));
	}
	TS_CAPI TSMTLCompute TS_CCALL tsMTLCompute_castComputePtr(TSCompute base) {
		return (TSMTLCompute)(new MTLCompute(*(Compute*)base));
	}
	TS_CAPI TSCompute TS_CCALL tsMTLCompute_baseComputePtr(TSMTLCompute self) {
		return (TSCompute)(new Compute(((MTLCompute*)self)->getCompute()));
	}
	TS_CAPI void* TS_CCALL tsMTLCompute_getEncoder(TSMTLCompute self) {
		TS_ASSERT(self);
		return ((MTLCompute*)self)->getEncoder();
	}
	TS_CAPI void TS_CCALL tsMTLCompute_flush_prb(TSMTLCompute self, void *encoder, bool_t enqueue) {
		TS_ASSERT(self);
		((MTLCompute*)self)->flush(encoder, (bool)enqueue);
	}
	TS_CAPI void TS_CCALL tsMTLCompute_flush_bb(TSMTLCompute self, bool_t create, bool_t enqueue) {
		TS_ASSERT(self);
		((MTLCompute*)self)->flush((bool)create, (bool)enqueue);
	}
	TS_CAPI void TS_CCALL tsMTLCompute_update(TSMTLCompute self) {
		TS_ASSERT(self);
		((MTLCompute*)self)->update();
	}
	
	// Tellusim::VKCompute
	TS_CAPI TSVKCompute TS_CCALL tsVKCompute_new(void) {
		VKCompute *ret = new VKCompute();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKCompute)ret;
	}
	TS_CAPI void TS_CCALL tsVKCompute_delete(TSVKCompute self) {
		if(self) delete (VKCompute*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKCompute_equalPtr(const TSVKCompute self, const TSVKCompute ptr) {
		return (self && ptr && ((VKCompute*)self)->operator==(*(VKCompute*)ptr));
	}
	TS_CAPI TSVKCompute TS_CCALL tsVKCompute_copyPtr(TSVKCompute self) {
		VKCompute *ret = nullptr;
		if(self) ret = new VKCompute(*(VKCompute*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKCompute)ret;
	}
	TS_CAPI TSVKCompute TS_CCALL tsVKCompute_clonePtr(const TSVKCompute self) {
		VKCompute *ret = (self) ? new VKCompute(((VKCompute*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKCompute)ret;
	}
	TS_CAPI void TS_CCALL tsVKCompute_clearPtr(TSVKCompute self) {
		if(self) ((VKCompute*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKCompute_destroyPtr(TSVKCompute self) {
		if(self) ((VKCompute*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKCompute_acquirePtr(TSVKCompute self) {
		if(self) ((VKCompute*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKCompute_unacquirePtr(TSVKCompute self) {
		if(self) ((VKCompute*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKCompute_isValidPtr(const TSVKCompute self) {
		return (self && ((VKCompute*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKCompute_isOwnerPtr(const TSVKCompute self) {
		return (self && ((VKCompute*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKCompute_isConstPtr(const TSVKCompute self) {
		return (self && ((VKCompute*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKCompute_getCountPtr(const TSVKCompute self) {
		return ((VKCompute*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKCompute_getInternalPtr(const TSVKCompute self) {
		return ((VKCompute*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKCompute_equalComputePtr(const TSVKCompute self, const TSCompute base) {
		return (self && base && ((VKCompute*)self)->operator==(*(Compute*)base));
	}
	TS_CAPI TSVKCompute TS_CCALL tsVKCompute_castComputePtr(TSCompute base) {
		return (TSVKCompute)(new VKCompute(*(Compute*)base));
	}
	TS_CAPI TSCompute TS_CCALL tsVKCompute_baseComputePtr(TSVKCompute self) {
		return (TSCompute)(new Compute(((VKCompute*)self)->getCompute()));
	}
	TS_CAPI VkCommandBuffer TS_CCALL tsVKCompute_getCommand(TSVKCompute self) {
		TS_ASSERT(self);
		return ((VKCompute*)self)->getCommand();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCompute_getSamplerDescriptor(TSVKCompute self) {
		TS_ASSERT(self);
		return ((VKCompute*)self)->getSamplerDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCompute_getImageDescriptor(TSVKCompute self) {
		TS_ASSERT(self);
		return ((VKCompute*)self)->getImageDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCompute_getBufferDescriptor(TSVKCompute self) {
		TS_ASSERT(self);
		return ((VKCompute*)self)->getBufferDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCompute_getTracingDescriptor(TSVKCompute self) {
		TS_ASSERT(self);
		return ((VKCompute*)self)->getTracingDescriptor();
	}
	TS_CAPI VkDescriptorSet TS_CCALL tsVKCompute_getTexelDescriptor(TSVKCompute self) {
		TS_ASSERT(self);
		return ((VKCompute*)self)->getTexelDescriptor();
	}
	TS_CAPI void TS_CCALL tsVKCompute_update(TSVKCompute self) {
		TS_ASSERT(self);
		((VKCompute*)self)->update();
	}
	
	// Tellusim::FUCompute
	TS_CAPI TSFUCompute TS_CCALL tsFUCompute_new(void) {
		FUCompute *ret = new FUCompute();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCompute)ret;
	}
	TS_CAPI TSFUCompute TS_CCALL tsFUCompute_new_cACb(const TSCompute *computes, uint32_t computes_size, bool_t owner) {
		Array<Compute> computes_(computes_size);
		for(uint32_t i = 0; i < computes_size; i++) if(computes[i]) computes_[i] = *(Compute*)computes[i];
		FUCompute *ret = new FUCompute(computes_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCompute)ret;
	}
	TS_CAPI void TS_CCALL tsFUCompute_delete(TSFUCompute self) {
		if(self) delete (FUCompute*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUCompute_equalPtr(const TSFUCompute self, const TSFUCompute ptr) {
		return (self && ptr && ((FUCompute*)self)->operator==(*(FUCompute*)ptr));
	}
	TS_CAPI TSFUCompute TS_CCALL tsFUCompute_copyPtr(TSFUCompute self) {
		FUCompute *ret = nullptr;
		if(self) ret = new FUCompute(*(FUCompute*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCompute)ret;
	}
	TS_CAPI TSFUCompute TS_CCALL tsFUCompute_clonePtr(const TSFUCompute self) {
		FUCompute *ret = (self) ? new FUCompute(((FUCompute*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUCompute)ret;
	}
	TS_CAPI void TS_CCALL tsFUCompute_clearPtr(TSFUCompute self) {
		if(self) ((FUCompute*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUCompute_destroyPtr(TSFUCompute self) {
		if(self) ((FUCompute*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUCompute_acquirePtr(TSFUCompute self) {
		if(self) ((FUCompute*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUCompute_unacquirePtr(TSFUCompute self) {
		if(self) ((FUCompute*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUCompute_isValidPtr(const TSFUCompute self) {
		return (self && ((FUCompute*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUCompute_isOwnerPtr(const TSFUCompute self) {
		return (self && ((FUCompute*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUCompute_isConstPtr(const TSFUCompute self) {
		return (self && ((FUCompute*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUCompute_getCountPtr(const TSFUCompute self) {
		return ((FUCompute*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUCompute_getInternalPtr(const TSFUCompute self) {
		return ((FUCompute*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUCompute_equalComputePtr(const TSFUCompute self, const TSCompute base) {
		return (self && base && ((FUCompute*)self)->operator==(*(Compute*)base));
	}
	TS_CAPI TSFUCompute TS_CCALL tsFUCompute_castComputePtr(TSCompute base) {
		return (TSFUCompute)(new FUCompute(*(Compute*)base));
	}
	TS_CAPI TSCompute TS_CCALL tsFUCompute_baseComputePtr(TSFUCompute self) {
		return (TSCompute)(new Compute(((FUCompute*)self)->getCompute()));
	}
	TS_CAPI void TS_CCALL tsFUCompute_setMask(TSFUCompute self, uint32_t mask) {
		TS_ASSERT(self);
		((FUCompute*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUCompute_getMask(TSFUCompute self) {
		TS_ASSERT(self);
		return ((FUCompute*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUCompute_getNumComputes(TSFUCompute self) {
		TS_ASSERT(self);
		return ((FUCompute*)self)->getNumComputes();
	}
	TS_CAPI TSCompute TS_CCALL tsFUCompute_getCompute_cu(TSFUCompute self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCompute)(new Compute(((FUCompute*)self)->getCompute(index)));
	}
	TS_CAPI TSCompute TS_CCALL tsFUCompute_getCompute_u(TSFUCompute self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCompute)(new Compute(((FUCompute*)self)->getCompute(index)));
	}
	
	// Tellusim::Context
	TS_CAPI TSContext TS_CCALL tsContext_new(void) {
		Context *ret = new Context();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSContext)ret;
	}
	TS_CAPI TSContext TS_CCALL tsContext_new_Pu(TS_Platform platform, uint32_t index) {
		Context *ret = new Context((Platform)platform, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSContext)ret;
	}
	TS_CAPI void TS_CCALL tsContext_delete(TSContext self) {
		if(self) delete (Context*)self;
	}
	TS_CAPI bool_t TS_CCALL tsContext_equalPtr(const TSContext self, const TSContext ptr) {
		return (self && ptr && ((Context*)self)->operator==(*(Context*)ptr));
	}
	TS_CAPI TSContext TS_CCALL tsContext_copyPtr(TSContext self) {
		Context *ret = nullptr;
		if(self) ret = new Context(*(Context*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSContext)ret;
	}
	TS_CAPI TSContext TS_CCALL tsContext_clonePtr(const TSContext self) {
		Context *ret = (self) ? new Context(((Context*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSContext)ret;
	}
	TS_CAPI void TS_CCALL tsContext_clearPtr(TSContext self) {
		if(self) ((Context*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsContext_destroyPtr(TSContext self) {
		if(self) ((Context*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsContext_acquirePtr(TSContext self) {
		if(self) ((Context*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsContext_unacquirePtr(TSContext self) {
		if(self) ((Context*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsContext_isValidPtr(const TSContext self) {
		return (self && ((Context*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsContext_isOwnerPtr(const TSContext self) {
		return (self && ((Context*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsContext_isConstPtr(const TSContext self) {
		return (self && ((Context*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsContext_getCountPtr(const TSContext self) {
		return ((Context*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsContext_getInternalPtr(const TSContext self) {
		return ((Context*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsContext_getPlatform(TSContext self) {
		TS_ASSERT(self);
		return (TS_Platform)((Context*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsContext_getPlatformName(TSContext self) {
		TS_ASSERT(self);
		return ((Context*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsContext_getIndex(TSContext self) {
		TS_ASSERT(self);
		return ((Context*)self)->getIndex();
	}
	TS_CAPI bool_t TS_CCALL tsContext_isCreated(TSContext self) {
		TS_ASSERT(self);
		return ((Context*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsContext_create(TSContext self) {
		TS_ASSERT(self);
		return ((Context*)self)->create();
	}
	TS_CAPI bool_t TS_CCALL tsContext_flush(TSContext self) {
		TS_ASSERT(self);
		return ((Context*)self)->flush();
	}
	TS_CAPI bool_t TS_CCALL tsContext_finish(TSContext self) {
		TS_ASSERT(self);
		return ((Context*)self)->finish();
	}
	
	// Tellusim::D3D12Context
	TS_CAPI TSD3D12Context TS_CCALL tsD3D12Context_new(void) {
		D3D12Context *ret = new D3D12Context();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Context)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Context_delete(TSD3D12Context self) {
		if(self) delete (D3D12Context*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_equalPtr(const TSD3D12Context self, const TSD3D12Context ptr) {
		return (self && ptr && ((D3D12Context*)self)->operator==(*(D3D12Context*)ptr));
	}
	TS_CAPI TSD3D12Context TS_CCALL tsD3D12Context_copyPtr(TSD3D12Context self) {
		D3D12Context *ret = nullptr;
		if(self) ret = new D3D12Context(*(D3D12Context*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Context)ret;
	}
	TS_CAPI TSD3D12Context TS_CCALL tsD3D12Context_clonePtr(const TSD3D12Context self) {
		D3D12Context *ret = (self) ? new D3D12Context(((D3D12Context*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Context)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Context_clearPtr(TSD3D12Context self) {
		if(self) ((D3D12Context*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Context_destroyPtr(TSD3D12Context self) {
		if(self) ((D3D12Context*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Context_acquirePtr(TSD3D12Context self) {
		if(self) ((D3D12Context*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Context_unacquirePtr(TSD3D12Context self) {
		if(self) ((D3D12Context*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_isValidPtr(const TSD3D12Context self) {
		return (self && ((D3D12Context*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_isOwnerPtr(const TSD3D12Context self) {
		return (self && ((D3D12Context*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_isConstPtr(const TSD3D12Context self) {
		return (self && ((D3D12Context*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Context_getCountPtr(const TSD3D12Context self) {
		return ((D3D12Context*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Context_getInternalPtr(const TSD3D12Context self) {
		return ((D3D12Context*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_equalContextPtr(const TSD3D12Context self, const TSContext base) {
		return (self && base && ((D3D12Context*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSD3D12Context TS_CCALL tsD3D12Context_castContextPtr(TSContext base) {
		return (TSD3D12Context)(new D3D12Context(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsD3D12Context_baseContextPtr(TSD3D12Context self) {
		return (TSContext)(new Context(((D3D12Context*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_create(TSD3D12Context self, ID3D12Device *device, ID3D12CommandQueue *queue) {
		TS_ASSERT(self);
		return ((D3D12Context*)self)->create(device, queue);
	}
	TS_CAPI IDXGIFactory4* TS_CCALL tsD3D12Context_getFactory(TSD3D12Context self) {
		TS_ASSERT(self);
		return ((D3D12Context*)self)->getFactory();
	}
	TS_CAPI ID3D12Device* TS_CCALL tsD3D12Context_getDevice(TSD3D12Context self) {
		TS_ASSERT(self);
		return ((D3D12Context*)self)->getDevice();
	}
	TS_CAPI ID3D12CommandQueue* TS_CCALL tsD3D12Context_getQueue(TSD3D12Context self) {
		TS_ASSERT(self);
		return ((D3D12Context*)self)->getQueue();
	}
	TS_CAPI ID3D12GraphicsCommandList* TS_CCALL tsD3D12Context_getCommand(TSD3D12Context self) {
		TS_ASSERT(self);
		return ((D3D12Context*)self)->getCommand();
	}
	TS_CAPI void* TS_CCALL tsD3D12Context_getProcAddress(const char *name) {
		return D3D12Context::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Context_error(uint32_t result) {
		return D3D12Context::error(result);
	}
	
	// Tellusim::D3D11Context
	TS_CAPI TSD3D11Context TS_CCALL tsD3D11Context_new(void) {
		D3D11Context *ret = new D3D11Context();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Context)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Context_delete(TSD3D11Context self) {
		if(self) delete (D3D11Context*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_equalPtr(const TSD3D11Context self, const TSD3D11Context ptr) {
		return (self && ptr && ((D3D11Context*)self)->operator==(*(D3D11Context*)ptr));
	}
	TS_CAPI TSD3D11Context TS_CCALL tsD3D11Context_copyPtr(TSD3D11Context self) {
		D3D11Context *ret = nullptr;
		if(self) ret = new D3D11Context(*(D3D11Context*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Context)ret;
	}
	TS_CAPI TSD3D11Context TS_CCALL tsD3D11Context_clonePtr(const TSD3D11Context self) {
		D3D11Context *ret = (self) ? new D3D11Context(((D3D11Context*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Context)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Context_clearPtr(TSD3D11Context self) {
		if(self) ((D3D11Context*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Context_destroyPtr(TSD3D11Context self) {
		if(self) ((D3D11Context*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Context_acquirePtr(TSD3D11Context self) {
		if(self) ((D3D11Context*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Context_unacquirePtr(TSD3D11Context self) {
		if(self) ((D3D11Context*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_isValidPtr(const TSD3D11Context self) {
		return (self && ((D3D11Context*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_isOwnerPtr(const TSD3D11Context self) {
		return (self && ((D3D11Context*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_isConstPtr(const TSD3D11Context self) {
		return (self && ((D3D11Context*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Context_getCountPtr(const TSD3D11Context self) {
		return ((D3D11Context*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Context_getInternalPtr(const TSD3D11Context self) {
		return ((D3D11Context*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_equalContextPtr(const TSD3D11Context self, const TSContext base) {
		return (self && base && ((D3D11Context*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSD3D11Context TS_CCALL tsD3D11Context_castContextPtr(TSContext base) {
		return (TSD3D11Context)(new D3D11Context(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsD3D11Context_baseContextPtr(TSD3D11Context self) {
		return (TSContext)(new Context(((D3D11Context*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_create(TSD3D11Context self, ID3D11Device *device) {
		TS_ASSERT(self);
		return ((D3D11Context*)self)->create(device);
	}
	TS_CAPI IDXGIFactory* TS_CCALL tsD3D11Context_getFactory(TSD3D11Context self) {
		TS_ASSERT(self);
		return ((D3D11Context*)self)->getFactory();
	}
	TS_CAPI ID3D11Device* TS_CCALL tsD3D11Context_getDevice(TSD3D11Context self) {
		TS_ASSERT(self);
		return ((D3D11Context*)self)->getDevice();
	}
	TS_CAPI ID3D11DeviceContext* TS_CCALL tsD3D11Context_getD3D11Context(TSD3D11Context self) {
		TS_ASSERT(self);
		return ((D3D11Context*)self)->getD3D11Context();
	}
	TS_CAPI void* TS_CCALL tsD3D11Context_getProcAddress(const char *name) {
		return D3D11Context::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Context_error(uint32_t result) {
		return D3D11Context::error(result);
	}
	
	// Tellusim::MTLContext
	TS_CAPI TSMTLContext TS_CCALL tsMTLContext_new(void) {
		MTLContext *ret = new MTLContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLContext)ret;
	}
	TS_CAPI void TS_CCALL tsMTLContext_delete(TSMTLContext self) {
		if(self) delete (MTLContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLContext_equalPtr(const TSMTLContext self, const TSMTLContext ptr) {
		return (self && ptr && ((MTLContext*)self)->operator==(*(MTLContext*)ptr));
	}
	TS_CAPI TSMTLContext TS_CCALL tsMTLContext_copyPtr(TSMTLContext self) {
		MTLContext *ret = nullptr;
		if(self) ret = new MTLContext(*(MTLContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLContext)ret;
	}
	TS_CAPI TSMTLContext TS_CCALL tsMTLContext_clonePtr(const TSMTLContext self) {
		MTLContext *ret = (self) ? new MTLContext(((MTLContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLContext)ret;
	}
	TS_CAPI void TS_CCALL tsMTLContext_clearPtr(TSMTLContext self) {
		if(self) ((MTLContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLContext_destroyPtr(TSMTLContext self) {
		if(self) ((MTLContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLContext_acquirePtr(TSMTLContext self) {
		if(self) ((MTLContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLContext_unacquirePtr(TSMTLContext self) {
		if(self) ((MTLContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLContext_isValidPtr(const TSMTLContext self) {
		return (self && ((MTLContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLContext_isOwnerPtr(const TSMTLContext self) {
		return (self && ((MTLContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLContext_isConstPtr(const TSMTLContext self) {
		return (self && ((MTLContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLContext_getCountPtr(const TSMTLContext self) {
		return ((MTLContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLContext_getInternalPtr(const TSMTLContext self) {
		return ((MTLContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLContext_equalContextPtr(const TSMTLContext self, const TSContext base) {
		return (self && base && ((MTLContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSMTLContext TS_CCALL tsMTLContext_castContextPtr(TSContext base) {
		return (TSMTLContext)(new MTLContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsMTLContext_baseContextPtr(TSMTLContext self) {
		return (TSContext)(new Context(((MTLContext*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsMTLContext_create(TSMTLContext self, void *device, void *queue) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->create(device, queue);
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getDevice(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getDevice();
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getQueue(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getQueue();
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getCommand(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getCommand();
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getEncoder(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getEncoder();
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getRenderEncoder(TSMTLContext self, void *descriptor) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getRenderEncoder(descriptor);
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getComputeEncoder(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getComputeEncoder();
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getTracingEncoder(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getTracingEncoder();
	}
	TS_CAPI void* TS_CCALL tsMTLContext_getBlitEncoder(TSMTLContext self) {
		TS_ASSERT(self);
		return ((MTLContext*)self)->getBlitEncoder();
	}
	TS_CAPI void TS_CCALL tsMTLContext_endEncoder(TSMTLContext self) {
		TS_ASSERT(self);
		((MTLContext*)self)->endEncoder();
	}
	
	// Tellusim::VKContext
	TS_CAPI TSVKContext TS_CCALL tsVKContext_new(void) {
		VKContext *ret = new VKContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKContext)ret;
	}
	TS_CAPI void TS_CCALL tsVKContext_delete(TSVKContext self) {
		if(self) delete (VKContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_equalPtr(const TSVKContext self, const TSVKContext ptr) {
		return (self && ptr && ((VKContext*)self)->operator==(*(VKContext*)ptr));
	}
	TS_CAPI TSVKContext TS_CCALL tsVKContext_copyPtr(TSVKContext self) {
		VKContext *ret = nullptr;
		if(self) ret = new VKContext(*(VKContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKContext)ret;
	}
	TS_CAPI TSVKContext TS_CCALL tsVKContext_clonePtr(const TSVKContext self) {
		VKContext *ret = (self) ? new VKContext(((VKContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKContext)ret;
	}
	TS_CAPI void TS_CCALL tsVKContext_clearPtr(TSVKContext self) {
		if(self) ((VKContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKContext_destroyPtr(TSVKContext self) {
		if(self) ((VKContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKContext_acquirePtr(TSVKContext self) {
		if(self) ((VKContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKContext_unacquirePtr(TSVKContext self) {
		if(self) ((VKContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_isValidPtr(const TSVKContext self) {
		return (self && ((VKContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_isOwnerPtr(const TSVKContext self) {
		return (self && ((VKContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_isConstPtr(const TSVKContext self) {
		return (self && ((VKContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKContext_getCountPtr(const TSVKContext self) {
		return ((VKContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKContext_getInternalPtr(const TSVKContext self) {
		return ((VKContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_equalContextPtr(const TSVKContext self, const TSContext base) {
		return (self && base && ((VKContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSVKContext TS_CCALL tsVKContext_castContextPtr(TSContext base) {
		return (TSVKContext)(new VKContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsVKContext_baseContextPtr(TSVKContext self) {
		return (TSContext)(new Context(((VKContext*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_create(TSVKContext self, VkInstance instance, PFN_vkGetInstanceProcAddr func, VkPhysicalDevice adapter, VkDevice device, uint32_t family, uint32_t index) {
		TS_ASSERT(self);
		return ((VKContext*)self)->create(instance, func, adapter, device, family, index);
	}
	TS_CAPI VkInstance TS_CCALL tsVKContext_getInstance(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getInstance();
	}
	TS_CAPI VkPhysicalDevice TS_CCALL tsVKContext_getAdapter(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getAdapter();
	}
	TS_CAPI VkDevice TS_CCALL tsVKContext_getDevice(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getDevice();
	}
	TS_CAPI VkQueue TS_CCALL tsVKContext_getQueue(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getQueue();
	}
	TS_CAPI VkCommandBuffer TS_CCALL tsVKContext_getCommand(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getCommand();
	}
	TS_CAPI uint32_t TS_CCALL tsVKContext_getFamily(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getFamily();
	}
	TS_CAPI uint32_t TS_CCALL tsVKContext_getNumQueues(TSVKContext self) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getNumQueues();
	}
	TS_CAPI uint32_t TS_CCALL tsVKContext_getQueueFlags(TSVKContext self, uint32_t index) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getQueueFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsVKContext_getQueueFamily(TSVKContext self, uint32_t index) {
		TS_ASSERT(self);
		return ((VKContext*)self)->getQueueFamily(index);
	}
	TS_CAPI void TS_CCALL tsVKContext_addContextExtension(const char *name) {
		VKContext::addContextExtension(name);
	}
	TS_CAPI void TS_CCALL tsVKContext_addAdapterExtension(const char *name) {
		VKContext::addAdapterExtension(name);
	}
	TS_CAPI void TS_CCALL tsVKContext_addAdapterFeatures(void *features) {
		VKContext::addAdapterFeatures(features);
	}
	TS_CAPI PFN_vkGetInstanceProcAddr TS_CCALL tsVKContext_getInstanceProcAddress(void) {
		return VKContext::getInstanceProcAddress();
	}
	TS_CAPI PFN_vkGetDeviceProcAddr TS_CCALL tsVKContext_getDeviceProcAddress(void) {
		return VKContext::getDeviceProcAddress();
	}
	TS_CAPI void* TS_CCALL tsVKContext_getProcAddress(const char *name) {
		return VKContext::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsVKContext_error(uint32_t result) {
		return VKContext::error(result);
	}
	
	// Tellusim::GLContext
	TS_CAPI TSGLContext TS_CCALL tsGLContext_new(void) {
		GLContext *ret = new GLContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLContext)ret;
	}
	TS_CAPI void TS_CCALL tsGLContext_delete(TSGLContext self) {
		if(self) delete (GLContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_equalPtr(const TSGLContext self, const TSGLContext ptr) {
		return (self && ptr && ((GLContext*)self)->operator==(*(GLContext*)ptr));
	}
	TS_CAPI TSGLContext TS_CCALL tsGLContext_copyPtr(TSGLContext self) {
		GLContext *ret = nullptr;
		if(self) ret = new GLContext(*(GLContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLContext)ret;
	}
	TS_CAPI TSGLContext TS_CCALL tsGLContext_clonePtr(const TSGLContext self) {
		GLContext *ret = (self) ? new GLContext(((GLContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLContext)ret;
	}
	TS_CAPI void TS_CCALL tsGLContext_clearPtr(TSGLContext self) {
		if(self) ((GLContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLContext_destroyPtr(TSGLContext self) {
		if(self) ((GLContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLContext_acquirePtr(TSGLContext self) {
		if(self) ((GLContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLContext_unacquirePtr(TSGLContext self) {
		if(self) ((GLContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_isValidPtr(const TSGLContext self) {
		return (self && ((GLContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_isOwnerPtr(const TSGLContext self) {
		return (self && ((GLContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_isConstPtr(const TSGLContext self) {
		return (self && ((GLContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLContext_getCountPtr(const TSGLContext self) {
		return ((GLContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLContext_getInternalPtr(const TSGLContext self) {
		return ((GLContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_equalContextPtr(const TSGLContext self, const TSContext base) {
		return (self && base && ((GLContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSGLContext TS_CCALL tsGLContext_castContextPtr(TSContext base) {
		return (TSGLContext)(new GLContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsGLContext_baseContextPtr(TSGLContext self) {
		return (TSContext)(new Context(((GLContext*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_create(TSGLContext self, void *context) {
		TS_ASSERT(self);
		return ((GLContext*)self)->create(context);
	}
	TS_CAPI void* TS_CCALL tsGLContext_getGLDisplay(TSGLContext self) {
		TS_ASSERT(self);
		return ((GLContext*)self)->getGLDisplay();
	}
	TS_CAPI void* TS_CCALL tsGLContext_getGLVisual(TSGLContext self) {
		TS_ASSERT(self);
		return ((GLContext*)self)->getGLVisual();
	}
	TS_CAPI void* TS_CCALL tsGLContext_getGLConfig(TSGLContext self) {
		TS_ASSERT(self);
		return ((GLContext*)self)->getGLConfig();
	}
	TS_CAPI void* TS_CCALL tsGLContext_getGLSurface(TSGLContext self) {
		TS_ASSERT(self);
		return ((GLContext*)self)->getGLSurface();
	}
	TS_CAPI void* TS_CCALL tsGLContext_getGLContext(TSGLContext self) {
		TS_ASSERT(self);
		return ((GLContext*)self)->getGLContext();
	}
	TS_CAPI void* TS_CCALL tsGLContext_getProcAddress(const char *name) {
		return GLContext::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_error(uint32_t result) {
		return GLContext::error(result);
	}
	TS_CAPI bool_t TS_CCALL tsGLContext_check(void) {
		return GLContext::check();
	}
	
	// Tellusim::GLESContext
	TS_CAPI TSGLESContext TS_CCALL tsGLESContext_new(void) {
		GLESContext *ret = new GLESContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESContext)ret;
	}
	TS_CAPI void TS_CCALL tsGLESContext_delete(TSGLESContext self) {
		if(self) delete (GLESContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_equalPtr(const TSGLESContext self, const TSGLESContext ptr) {
		return (self && ptr && ((GLESContext*)self)->operator==(*(GLESContext*)ptr));
	}
	TS_CAPI TSGLESContext TS_CCALL tsGLESContext_copyPtr(TSGLESContext self) {
		GLESContext *ret = nullptr;
		if(self) ret = new GLESContext(*(GLESContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESContext)ret;
	}
	TS_CAPI TSGLESContext TS_CCALL tsGLESContext_clonePtr(const TSGLESContext self) {
		GLESContext *ret = (self) ? new GLESContext(((GLESContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESContext)ret;
	}
	TS_CAPI void TS_CCALL tsGLESContext_clearPtr(TSGLESContext self) {
		if(self) ((GLESContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLESContext_destroyPtr(TSGLESContext self) {
		if(self) ((GLESContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLESContext_acquirePtr(TSGLESContext self) {
		if(self) ((GLESContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLESContext_unacquirePtr(TSGLESContext self) {
		if(self) ((GLESContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_isValidPtr(const TSGLESContext self) {
		return (self && ((GLESContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_isOwnerPtr(const TSGLESContext self) {
		return (self && ((GLESContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_isConstPtr(const TSGLESContext self) {
		return (self && ((GLESContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLESContext_getCountPtr(const TSGLESContext self) {
		return ((GLESContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLESContext_getInternalPtr(const TSGLESContext self) {
		return ((GLESContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_equalContextPtr(const TSGLESContext self, const TSContext base) {
		return (self && base && ((GLESContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSGLESContext TS_CCALL tsGLESContext_castContextPtr(TSContext base) {
		return (TSGLESContext)(new GLESContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsGLESContext_baseContextPtr(TSGLESContext self) {
		return (TSContext)(new Context(((GLESContext*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_create(TSGLESContext self, void *context) {
		TS_ASSERT(self);
		return ((GLESContext*)self)->create(context);
	}
	TS_CAPI void* TS_CCALL tsGLESContext_getGLESDisplay(TSGLESContext self) {
		TS_ASSERT(self);
		return ((GLESContext*)self)->getGLESDisplay();
	}
	TS_CAPI void* TS_CCALL tsGLESContext_getGLESConfig(TSGLESContext self) {
		TS_ASSERT(self);
		return ((GLESContext*)self)->getGLESConfig();
	}
	TS_CAPI void* TS_CCALL tsGLESContext_getGLESContext(TSGLESContext self) {
		TS_ASSERT(self);
		return ((GLESContext*)self)->getGLESContext();
	}
	TS_CAPI void* TS_CCALL tsGLESContext_getProcAddress(const char *name) {
		return GLESContext::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_error(uint32_t result) {
		return GLESContext::error(result);
	}
	TS_CAPI bool_t TS_CCALL tsGLESContext_check(void) {
		return GLESContext::check();
	}
	
	// Tellusim::WGContext
	TS_CAPI TSWGContext TS_CCALL tsWGContext_new(void) {
		WGContext *ret = new WGContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWGContext)ret;
	}
	TS_CAPI void TS_CCALL tsWGContext_delete(TSWGContext self) {
		if(self) delete (WGContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_equalPtr(const TSWGContext self, const TSWGContext ptr) {
		return (self && ptr && ((WGContext*)self)->operator==(*(WGContext*)ptr));
	}
	TS_CAPI TSWGContext TS_CCALL tsWGContext_copyPtr(TSWGContext self) {
		WGContext *ret = nullptr;
		if(self) ret = new WGContext(*(WGContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWGContext)ret;
	}
	TS_CAPI TSWGContext TS_CCALL tsWGContext_clonePtr(const TSWGContext self) {
		WGContext *ret = (self) ? new WGContext(((WGContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWGContext)ret;
	}
	TS_CAPI void TS_CCALL tsWGContext_clearPtr(TSWGContext self) {
		if(self) ((WGContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsWGContext_destroyPtr(TSWGContext self) {
		if(self) ((WGContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsWGContext_acquirePtr(TSWGContext self) {
		if(self) ((WGContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsWGContext_unacquirePtr(TSWGContext self) {
		if(self) ((WGContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_isValidPtr(const TSWGContext self) {
		return (self && ((WGContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_isOwnerPtr(const TSWGContext self) {
		return (self && ((WGContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_isConstPtr(const TSWGContext self) {
		return (self && ((WGContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsWGContext_getCountPtr(const TSWGContext self) {
		return ((WGContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsWGContext_getInternalPtr(const TSWGContext self) {
		return ((WGContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_equalContextPtr(const TSWGContext self, const TSContext base) {
		return (self && base && ((WGContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSWGContext TS_CCALL tsWGContext_castContextPtr(TSContext base) {
		return (TSWGContext)(new WGContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsWGContext_baseContextPtr(TSWGContext self) {
		return (TSContext)(new Context(((WGContext*)self)->getContext()));
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_open(WGPUInstance instance, WGPUAdapter adapter, WGPUDevice device) {
		return WGContext::open(instance, adapter, device);
	}
	TS_CAPI bool_t TS_CCALL tsWGContext_create(TSWGContext self, WGPUInstance instance, WGPUAdapter adapter, WGPUDevice device) {
		TS_ASSERT(self);
		return ((WGContext*)self)->create(instance, adapter, device);
	}
	TS_CAPI WGPUInstance TS_CCALL tsWGContext_getInstance(TSWGContext self) {
		TS_ASSERT(self);
		return ((WGContext*)self)->getInstance();
	}
	TS_CAPI WGPUAdapter TS_CCALL tsWGContext_getAdapter(TSWGContext self) {
		TS_ASSERT(self);
		return ((WGContext*)self)->getAdapter();
	}
	TS_CAPI WGPUDevice TS_CCALL tsWGContext_getDevice(TSWGContext self) {
		TS_ASSERT(self);
		return ((WGContext*)self)->getDevice();
	}
	
	// Tellusim::CUContext
	TS_CAPI TSCUContext TS_CCALL tsCUContext_new(void) {
		CUContext *ret = new CUContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUContext)ret;
	}
	TS_CAPI void TS_CCALL tsCUContext_delete(TSCUContext self) {
		if(self) delete (CUContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCUContext_equalPtr(const TSCUContext self, const TSCUContext ptr) {
		return (self && ptr && ((CUContext*)self)->operator==(*(CUContext*)ptr));
	}
	TS_CAPI TSCUContext TS_CCALL tsCUContext_copyPtr(TSCUContext self) {
		CUContext *ret = nullptr;
		if(self) ret = new CUContext(*(CUContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUContext)ret;
	}
	TS_CAPI TSCUContext TS_CCALL tsCUContext_clonePtr(const TSCUContext self) {
		CUContext *ret = (self) ? new CUContext(((CUContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUContext)ret;
	}
	TS_CAPI void TS_CCALL tsCUContext_clearPtr(TSCUContext self) {
		if(self) ((CUContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCUContext_destroyPtr(TSCUContext self) {
		if(self) ((CUContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCUContext_acquirePtr(TSCUContext self) {
		if(self) ((CUContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCUContext_unacquirePtr(TSCUContext self) {
		if(self) ((CUContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUContext_isValidPtr(const TSCUContext self) {
		return (self && ((CUContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUContext_isOwnerPtr(const TSCUContext self) {
		return (self && ((CUContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUContext_isConstPtr(const TSCUContext self) {
		return (self && ((CUContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCUContext_getCountPtr(const TSCUContext self) {
		return ((CUContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCUContext_getInternalPtr(const TSCUContext self) {
		return ((CUContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUContext_equalContextPtr(const TSCUContext self, const TSContext base) {
		return (self && base && ((CUContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSCUContext TS_CCALL tsCUContext_castContextPtr(TSContext base) {
		return (TSCUContext)(new CUContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsCUContext_baseContextPtr(TSCUContext self) {
		return (TSContext)(new Context(((CUContext*)self)->getContext()));
	}
	TS_CAPI int32_t TS_CCALL tsCUContext_getDevice(TSCUContext self) {
		TS_ASSERT(self);
		return ((CUContext*)self)->getDevice();
	}
	TS_CAPI CUcontext TS_CCALL tsCUContext_getCUContext(TSCUContext self) {
		TS_ASSERT(self);
		return ((CUContext*)self)->getCUContext();
	}
	TS_CAPI CUstream TS_CCALL tsCUContext_getStream(TSCUContext self) {
		TS_ASSERT(self);
		return ((CUContext*)self)->getStream();
	}
	TS_CAPI void* TS_CCALL tsCUContext_getProcAddress(const char *name) {
		return CUContext::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsCUContext_error(uint32_t result) {
		return CUContext::error(result);
	}
	
	// Tellusim::HIPContext
	TS_CAPI TSHIPContext TS_CCALL tsHIPContext_new(void) {
		HIPContext *ret = new HIPContext();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPContext)ret;
	}
	TS_CAPI void TS_CCALL tsHIPContext_delete(TSHIPContext self) {
		if(self) delete (HIPContext*)self;
	}
	TS_CAPI bool_t TS_CCALL tsHIPContext_equalPtr(const TSHIPContext self, const TSHIPContext ptr) {
		return (self && ptr && ((HIPContext*)self)->operator==(*(HIPContext*)ptr));
	}
	TS_CAPI TSHIPContext TS_CCALL tsHIPContext_copyPtr(TSHIPContext self) {
		HIPContext *ret = nullptr;
		if(self) ret = new HIPContext(*(HIPContext*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPContext)ret;
	}
	TS_CAPI TSHIPContext TS_CCALL tsHIPContext_clonePtr(const TSHIPContext self) {
		HIPContext *ret = (self) ? new HIPContext(((HIPContext*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPContext)ret;
	}
	TS_CAPI void TS_CCALL tsHIPContext_clearPtr(TSHIPContext self) {
		if(self) ((HIPContext*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsHIPContext_destroyPtr(TSHIPContext self) {
		if(self) ((HIPContext*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsHIPContext_acquirePtr(TSHIPContext self) {
		if(self) ((HIPContext*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsHIPContext_unacquirePtr(TSHIPContext self) {
		if(self) ((HIPContext*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPContext_isValidPtr(const TSHIPContext self) {
		return (self && ((HIPContext*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPContext_isOwnerPtr(const TSHIPContext self) {
		return (self && ((HIPContext*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPContext_isConstPtr(const TSHIPContext self) {
		return (self && ((HIPContext*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsHIPContext_getCountPtr(const TSHIPContext self) {
		return ((HIPContext*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsHIPContext_getInternalPtr(const TSHIPContext self) {
		return ((HIPContext*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPContext_equalContextPtr(const TSHIPContext self, const TSContext base) {
		return (self && base && ((HIPContext*)self)->operator==(*(Context*)base));
	}
	TS_CAPI TSHIPContext TS_CCALL tsHIPContext_castContextPtr(TSContext base) {
		return (TSHIPContext)(new HIPContext(*(Context*)base));
	}
	TS_CAPI TSContext TS_CCALL tsHIPContext_baseContextPtr(TSHIPContext self) {
		return (TSContext)(new Context(((HIPContext*)self)->getContext()));
	}
	TS_CAPI int32_t TS_CCALL tsHIPContext_getDevice(TSHIPContext self) {
		TS_ASSERT(self);
		return ((HIPContext*)self)->getDevice();
	}
	TS_CAPI void* TS_CCALL tsHIPContext_getHIPContext(TSHIPContext self) {
		TS_ASSERT(self);
		return ((HIPContext*)self)->getHIPContext();
	}
	TS_CAPI void* TS_CCALL tsHIPContext_getStream(TSHIPContext self) {
		TS_ASSERT(self);
		return ((HIPContext*)self)->getStream();
	}
	TS_CAPI void* TS_CCALL tsHIPContext_getProcAddress(const char *name) {
		return HIPContext::getProcAddress(name);
	}
	TS_CAPI bool_t TS_CCALL tsHIPContext_error(uint32_t result) {
		return HIPContext::error(result);
	}
	
	// Tellusim::Query
	TS_CAPI TSQuery TS_CCALL tsQuery_new(void) {
		Query *ret = new Query();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSQuery)ret;
	}
	TS_CAPI void TS_CCALL tsQuery_delete(TSQuery self) {
		if(self) delete (Query*)self;
	}
	TS_CAPI bool_t TS_CCALL tsQuery_equalPtr(const TSQuery self, const TSQuery ptr) {
		return (self && ptr && ((Query*)self)->operator==(*(Query*)ptr));
	}
	TS_CAPI TSQuery TS_CCALL tsQuery_copyPtr(TSQuery self) {
		Query *ret = nullptr;
		if(self) ret = new Query(*(Query*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSQuery)ret;
	}
	TS_CAPI TSQuery TS_CCALL tsQuery_clonePtr(const TSQuery self) {
		Query *ret = (self) ? new Query(((Query*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSQuery)ret;
	}
	TS_CAPI void TS_CCALL tsQuery_clearPtr(TSQuery self) {
		if(self) ((Query*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsQuery_destroyPtr(TSQuery self) {
		if(self) ((Query*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsQuery_acquirePtr(TSQuery self) {
		if(self) ((Query*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsQuery_unacquirePtr(TSQuery self) {
		if(self) ((Query*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isValidPtr(const TSQuery self) {
		return (self && ((Query*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isOwnerPtr(const TSQuery self) {
		return (self && ((Query*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isConstPtr(const TSQuery self) {
		return (self && ((Query*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsQuery_getCountPtr(const TSQuery self) {
		return ((Query*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsQuery_getInternalPtr(const TSQuery self) {
		return ((Query*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsQuery_getPlatform(TSQuery self) {
		TS_ASSERT(self);
		return (TS_Platform)((Query*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsQuery_getPlatformName(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsQuery_getIndex(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsQuery_clear(TSQuery self) {
		TS_ASSERT(self);
		((Query*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isCreated(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isAvailable(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isAvailable();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isBegan(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isBegan();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isEnded(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isEnded();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_create(TSQuery self, TS_QueryType type) {
		TS_ASSERT(self);
		return ((Query*)self)->create((Query::Type)type);
	}
	TS_CAPI TS_QueryType TS_CCALL tsQuery_getType(TSQuery self) {
		TS_ASSERT(self);
		return (TS_QueryType)((Query*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsQuery_getTypeName_QT(TS_QueryType type) {
		return Query::getTypeName((Query::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsQuery_getTypeName_c(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->getTypeName();
	}
	TS_CAPI size_t TS_CCALL tsQuery_getTypeSize(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->getTypeSize();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isTime(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isTime();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isClock(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isClock();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isSamples(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isSamples();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isSamples1(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isSamples1();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isStatistics(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isStatistics();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isTimeType(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isTimeType();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_isSamplesType(TSQuery self) {
		TS_ASSERT(self);
		return ((Query*)self)->isSamplesType();
	}
	TS_CAPI bool_t TS_CCALL tsQuery_get(TSQuery self, void *dest, size_t size, bool_t wait) {
		TS_ASSERT(self);
		return ((Query*)self)->get(dest, size, (bool)wait);
	}
	TS_CAPI uint64_t TS_CCALL tsQuery_getTime(TSQuery self, bool_t wait, uint8_t *status) {
		TS_ASSERT(self);
		return ((Query*)self)->getTime((bool)wait, (bool*)status);
	}
	TS_CAPI uint32_t TS_CCALL tsQuery_getSamples(TSQuery self, bool_t wait, uint8_t *status) {
		TS_ASSERT(self);
		return ((Query*)self)->getSamples((bool)wait, (bool*)status);
	}
	TS_CAPI TSQueryStatistics TS_CCALL tsQuery_getStatistics(TSQuery self, bool_t wait, uint8_t *status) {
		TS_ASSERT(self);
		Query::Statistics ret = ((Query*)self)->getStatistics((bool)wait, (bool*)status);
		return *(TSQueryStatistics*)&ret;
	}
	
	// Tellusim::FUQuery
	TS_CAPI TSFUQuery TS_CCALL tsFUQuery_new(void) {
		FUQuery *ret = new FUQuery();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUQuery)ret;
	}
	TS_CAPI TSFUQuery TS_CCALL tsFUQuery_new_cAQb(const TSQuery *queries, uint32_t queries_size, bool_t owner) {
		Array<Query> queries_(queries_size);
		for(uint32_t i = 0; i < queries_size; i++) if(queries[i]) queries_[i] = *(Query*)queries[i];
		FUQuery *ret = new FUQuery(queries_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUQuery)ret;
	}
	TS_CAPI void TS_CCALL tsFUQuery_delete(TSFUQuery self) {
		if(self) delete (FUQuery*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUQuery_equalPtr(const TSFUQuery self, const TSFUQuery ptr) {
		return (self && ptr && ((FUQuery*)self)->operator==(*(FUQuery*)ptr));
	}
	TS_CAPI TSFUQuery TS_CCALL tsFUQuery_copyPtr(TSFUQuery self) {
		FUQuery *ret = nullptr;
		if(self) ret = new FUQuery(*(FUQuery*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUQuery)ret;
	}
	TS_CAPI TSFUQuery TS_CCALL tsFUQuery_clonePtr(const TSFUQuery self) {
		FUQuery *ret = (self) ? new FUQuery(((FUQuery*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUQuery)ret;
	}
	TS_CAPI void TS_CCALL tsFUQuery_clearPtr(TSFUQuery self) {
		if(self) ((FUQuery*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUQuery_destroyPtr(TSFUQuery self) {
		if(self) ((FUQuery*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUQuery_acquirePtr(TSFUQuery self) {
		if(self) ((FUQuery*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUQuery_unacquirePtr(TSFUQuery self) {
		if(self) ((FUQuery*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUQuery_isValidPtr(const TSFUQuery self) {
		return (self && ((FUQuery*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUQuery_isOwnerPtr(const TSFUQuery self) {
		return (self && ((FUQuery*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUQuery_isConstPtr(const TSFUQuery self) {
		return (self && ((FUQuery*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUQuery_getCountPtr(const TSFUQuery self) {
		return ((FUQuery*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUQuery_getInternalPtr(const TSFUQuery self) {
		return ((FUQuery*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUQuery_equalQueryPtr(const TSFUQuery self, const TSQuery base) {
		return (self && base && ((FUQuery*)self)->operator==(*(Query*)base));
	}
	TS_CAPI TSFUQuery TS_CCALL tsFUQuery_castQueryPtr(TSQuery base) {
		return (TSFUQuery)(new FUQuery(*(Query*)base));
	}
	TS_CAPI TSQuery TS_CCALL tsFUQuery_baseQueryPtr(TSFUQuery self) {
		return (TSQuery)(new Query(((FUQuery*)self)->getQuery()));
	}
	TS_CAPI void TS_CCALL tsFUQuery_setMask(TSFUQuery self, uint32_t mask) {
		TS_ASSERT(self);
		((FUQuery*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUQuery_getMask(TSFUQuery self) {
		TS_ASSERT(self);
		return ((FUQuery*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUQuery_getNumQueries(TSFUQuery self) {
		TS_ASSERT(self);
		return ((FUQuery*)self)->getNumQueries();
	}
	TS_CAPI TSQuery TS_CCALL tsFUQuery_getQuery_cu(TSFUQuery self, uint32_t index) {
		TS_ASSERT(self);
		return (TSQuery)(new Query(((FUQuery*)self)->getQuery(index)));
	}
	TS_CAPI TSQuery TS_CCALL tsFUQuery_getQuery_u(TSFUQuery self, uint32_t index) {
		TS_ASSERT(self);
		return (TSQuery)(new Query(((FUQuery*)self)->getQuery(index)));
	}
	
	// Tellusim::Fence
	TS_CAPI TSFence TS_CCALL tsFence_new(void) {
		Fence *ret = new Fence();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFence)ret;
	}
	TS_CAPI void TS_CCALL tsFence_delete(TSFence self) {
		if(self) delete (Fence*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFence_equalPtr(const TSFence self, const TSFence ptr) {
		return (self && ptr && ((Fence*)self)->operator==(*(Fence*)ptr));
	}
	TS_CAPI TSFence TS_CCALL tsFence_copyPtr(TSFence self) {
		Fence *ret = nullptr;
		if(self) ret = new Fence(*(Fence*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFence)ret;
	}
	TS_CAPI TSFence TS_CCALL tsFence_clonePtr(const TSFence self) {
		Fence *ret = (self) ? new Fence(((Fence*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFence)ret;
	}
	TS_CAPI void TS_CCALL tsFence_clearPtr(TSFence self) {
		if(self) ((Fence*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFence_destroyPtr(TSFence self) {
		if(self) ((Fence*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFence_acquirePtr(TSFence self) {
		if(self) ((Fence*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFence_unacquirePtr(TSFence self) {
		if(self) ((Fence*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFence_isValidPtr(const TSFence self) {
		return (self && ((Fence*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFence_isOwnerPtr(const TSFence self) {
		return (self && ((Fence*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFence_isConstPtr(const TSFence self) {
		return (self && ((Fence*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFence_getCountPtr(const TSFence self) {
		return ((Fence*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFence_getInternalPtr(const TSFence self) {
		return ((Fence*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsFence_getPlatform(TSFence self) {
		TS_ASSERT(self);
		return (TS_Platform)((Fence*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsFence_getPlatformName(TSFence self) {
		TS_ASSERT(self);
		return ((Fence*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsFence_getIndex(TSFence self) {
		TS_ASSERT(self);
		return ((Fence*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsFence_clear(TSFence self) {
		TS_ASSERT(self);
		((Fence*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsFence_isCreated(TSFence self) {
		TS_ASSERT(self);
		return ((Fence*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsFence_create(TSFence self, TS_FenceFlags flags) {
		TS_ASSERT(self);
		return ((Fence*)self)->create((Fence::Flags)flags);
	}
	TS_CAPI TS_FenceFlags TS_CCALL tsFence_getFlags(TSFence self) {
		TS_ASSERT(self);
		return (TS_FenceFlags)((Fence*)self)->getFlags();
	}
	TS_CAPI bool_t TS_CCALL tsFence_hasFlag(TSFence self, TS_FenceFlags flags) {
		TS_ASSERT(self);
		return ((Fence*)self)->hasFlag((Fence::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsFence_hasFlags(TSFence self, TS_FenceFlags flags) {
		TS_ASSERT(self);
		return ((Fence*)self)->hasFlags((Fence::Flags)flags);
	}
	TS_CAPI TSString TS_CCALL tsFence_getFlagsName(TSFence self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Fence*)self)->getFlagsName()));
	}
	TS_CAPI TSString TS_CCALL tsFence_getDescription(TSFence self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Fence*)self)->getDescription()));
	}
	
	// Tellusim::VKFence
	TS_CAPI TSVKFence TS_CCALL tsVKFence_new(void) {
		VKFence *ret = new VKFence();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKFence)ret;
	}
	TS_CAPI void TS_CCALL tsVKFence_delete(TSVKFence self) {
		if(self) delete (VKFence*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKFence_equalPtr(const TSVKFence self, const TSVKFence ptr) {
		return (self && ptr && ((VKFence*)self)->operator==(*(VKFence*)ptr));
	}
	TS_CAPI TSVKFence TS_CCALL tsVKFence_copyPtr(TSVKFence self) {
		VKFence *ret = nullptr;
		if(self) ret = new VKFence(*(VKFence*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKFence)ret;
	}
	TS_CAPI TSVKFence TS_CCALL tsVKFence_clonePtr(const TSVKFence self) {
		VKFence *ret = (self) ? new VKFence(((VKFence*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKFence)ret;
	}
	TS_CAPI void TS_CCALL tsVKFence_clearPtr(TSVKFence self) {
		if(self) ((VKFence*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKFence_destroyPtr(TSVKFence self) {
		if(self) ((VKFence*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKFence_acquirePtr(TSVKFence self) {
		if(self) ((VKFence*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKFence_unacquirePtr(TSVKFence self) {
		if(self) ((VKFence*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKFence_isValidPtr(const TSVKFence self) {
		return (self && ((VKFence*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKFence_isOwnerPtr(const TSVKFence self) {
		return (self && ((VKFence*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKFence_isConstPtr(const TSVKFence self) {
		return (self && ((VKFence*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKFence_getCountPtr(const TSVKFence self) {
		return ((VKFence*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKFence_getInternalPtr(const TSVKFence self) {
		return ((VKFence*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKFence_equalFencePtr(const TSVKFence self, const TSFence base) {
		return (self && base && ((VKFence*)self)->operator==(*(Fence*)base));
	}
	TS_CAPI TSVKFence TS_CCALL tsVKFence_castFencePtr(TSFence base) {
		return (TSVKFence)(new VKFence(*(Fence*)base));
	}
	TS_CAPI TSFence TS_CCALL tsVKFence_baseFencePtr(TSVKFence self) {
		return (TSFence)(new Fence(((VKFence*)self)->getFence()));
	}
	TS_CAPI VkFence TS_CCALL tsVKFence_getVKFence(TSVKFence self) {
		TS_ASSERT(self);
		return ((VKFence*)self)->getVKFence();
	}
	TS_CAPI VkSemaphore TS_CCALL tsVKFence_getSemaphore(TSVKFence self) {
		TS_ASSERT(self);
		return ((VKFence*)self)->getSemaphore();
	}
	TS_CAPI void* TS_CCALL tsVKFence_getSharedHandle(TSVKFence self) {
		TS_ASSERT(self);
		return ((VKFence*)self)->getSharedHandle();
	}
	
	// Tellusim::FUFence
	TS_CAPI TSFUFence TS_CCALL tsFUFence_new(void) {
		FUFence *ret = new FUFence();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUFence)ret;
	}
	TS_CAPI TSFUFence TS_CCALL tsFUFence_new_cAFb(const TSFence *fences, uint32_t fences_size, bool_t owner) {
		Array<Fence> fences_(fences_size);
		for(uint32_t i = 0; i < fences_size; i++) if(fences[i]) fences_[i] = *(Fence*)fences[i];
		FUFence *ret = new FUFence(fences_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUFence)ret;
	}
	TS_CAPI void TS_CCALL tsFUFence_delete(TSFUFence self) {
		if(self) delete (FUFence*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUFence_equalPtr(const TSFUFence self, const TSFUFence ptr) {
		return (self && ptr && ((FUFence*)self)->operator==(*(FUFence*)ptr));
	}
	TS_CAPI TSFUFence TS_CCALL tsFUFence_copyPtr(TSFUFence self) {
		FUFence *ret = nullptr;
		if(self) ret = new FUFence(*(FUFence*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUFence)ret;
	}
	TS_CAPI TSFUFence TS_CCALL tsFUFence_clonePtr(const TSFUFence self) {
		FUFence *ret = (self) ? new FUFence(((FUFence*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUFence)ret;
	}
	TS_CAPI void TS_CCALL tsFUFence_clearPtr(TSFUFence self) {
		if(self) ((FUFence*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUFence_destroyPtr(TSFUFence self) {
		if(self) ((FUFence*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUFence_acquirePtr(TSFUFence self) {
		if(self) ((FUFence*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUFence_unacquirePtr(TSFUFence self) {
		if(self) ((FUFence*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUFence_isValidPtr(const TSFUFence self) {
		return (self && ((FUFence*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUFence_isOwnerPtr(const TSFUFence self) {
		return (self && ((FUFence*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUFence_isConstPtr(const TSFUFence self) {
		return (self && ((FUFence*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUFence_getCountPtr(const TSFUFence self) {
		return ((FUFence*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUFence_getInternalPtr(const TSFUFence self) {
		return ((FUFence*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUFence_equalFencePtr(const TSFUFence self, const TSFence base) {
		return (self && base && ((FUFence*)self)->operator==(*(Fence*)base));
	}
	TS_CAPI TSFUFence TS_CCALL tsFUFence_castFencePtr(TSFence base) {
		return (TSFUFence)(new FUFence(*(Fence*)base));
	}
	TS_CAPI TSFence TS_CCALL tsFUFence_baseFencePtr(TSFUFence self) {
		return (TSFence)(new Fence(((FUFence*)self)->getFence()));
	}
	TS_CAPI void TS_CCALL tsFUFence_setMask(TSFUFence self, uint32_t mask) {
		TS_ASSERT(self);
		((FUFence*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUFence_getMask(TSFUFence self) {
		TS_ASSERT(self);
		return ((FUFence*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUFence_getNumFences(TSFUFence self) {
		TS_ASSERT(self);
		return ((FUFence*)self)->getNumFences();
	}
	TS_CAPI TSFence TS_CCALL tsFUFence_getFence_cu(TSFUFence self, uint32_t index) {
		TS_ASSERT(self);
		return (TSFence)(new Fence(((FUFence*)self)->getFence(index)));
	}
	TS_CAPI TSFence TS_CCALL tsFUFence_getFence_u(TSFUFence self, uint32_t index) {
		TS_ASSERT(self);
		return (TSFence)(new Fence(((FUFence*)self)->getFence(index)));
	}
	
	// Tellusim::Shader
	TS_CAPI TSShader TS_CCALL tsShader_new(void) {
		Shader *ret = new Shader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSShader)ret;
	}
	TS_CAPI void TS_CCALL tsShader_delete(TSShader self) {
		if(self) delete (Shader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsShader_equalPtr(const TSShader self, const TSShader ptr) {
		return (self && ptr && ((Shader*)self)->operator==(*(Shader*)ptr));
	}
	TS_CAPI TSShader TS_CCALL tsShader_copyPtr(TSShader self) {
		Shader *ret = nullptr;
		if(self) ret = new Shader(*(Shader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSShader)ret;
	}
	TS_CAPI TSShader TS_CCALL tsShader_clonePtr(const TSShader self) {
		Shader *ret = (self) ? new Shader(((Shader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSShader)ret;
	}
	TS_CAPI void TS_CCALL tsShader_clearPtr(TSShader self) {
		if(self) ((Shader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsShader_destroyPtr(TSShader self) {
		if(self) ((Shader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsShader_acquirePtr(TSShader self) {
		if(self) ((Shader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsShader_unacquirePtr(TSShader self) {
		if(self) ((Shader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isValidPtr(const TSShader self) {
		return (self && ((Shader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsShader_isOwnerPtr(const TSShader self) {
		return (self && ((Shader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsShader_isConstPtr(const TSShader self) {
		return (self && ((Shader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsShader_getCountPtr(const TSShader self) {
		return ((Shader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsShader_getInternalPtr(const TSShader self) {
		return ((Shader*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsShader_getPlatform(TSShader self) {
		TS_ASSERT(self);
		return (TS_Platform)((Shader*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsShader_getPlatformName(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsShader_getIndex(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsShader_clear(TSShader self) {
		TS_ASSERT(self);
		((Shader*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isCreated(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsShader_saveState(TSShader self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Shader*)self)->saveState(*(Stream*)stream);
	}
	TS_CAPI TS_ShaderType TS_CCALL tsShader_getType(TSShader self) {
		TS_ASSERT(self);
		return (TS_ShaderType)((Shader*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsShader_getTypeName_ST(TS_ShaderType type) {
		return Shader::getTypeName((Shader::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsShader_getTypeName_c(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isVertex(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isVertex();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isControl(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isControl();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isEvaluate(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isEvaluate();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isGeometry(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isGeometry();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isFragment(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isFragment();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isCompute(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isCompute();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isTask(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isTask();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isMesh(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isMesh();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isRayGen(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isRayGen();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isRayMiss(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isRayMiss();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isClosest(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isClosest();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isFirstHit(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isFirstHit();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isIntersection(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isIntersection();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isCallable(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isCallable();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isGraphicsType(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isGraphicsType();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isTessellationType(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isTessellationType();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isTracingType(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isTracingType();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isMeshType(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->isMeshType();
	}
	TS_CAPI TSString TS_CCALL tsShader_getName(TSShader self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Shader*)self)->getName()));
	}
	TS_CAPI TSString TS_CCALL tsShader_getMacros(TSShader self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Shader*)self)->getMacros()));
	}
	TS_CAPI void TS_CCALL tsShader_setSamplerOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setSamplerOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getSamplerOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getSamplerOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setTextureOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setTextureOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getTextureOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getTextureOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setSurfaceOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setSurfaceOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getSurfaceOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getSurfaceOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setUniformOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setUniformOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getUniformOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getUniformOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setStorageOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setStorageOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getStorageOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getStorageOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setTracingOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setTracingOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getTracingOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getTracingOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setTexelOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setTexelOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getTexelOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getTexelOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setTableOffset(TSShader self, int32_t offset) {
		TS_ASSERT(self);
		((Shader*)self)->setTableOffset(offset);
	}
	TS_CAPI int32_t TS_CCALL tsShader_getTableOffset(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getTableOffset();
	}
	TS_CAPI void TS_CCALL tsShader_setPatchSize(TSShader self, uint32_t size) {
		TS_ASSERT(self);
		((Shader*)self)->setPatchSize(size);
	}
	TS_CAPI uint32_t TS_CCALL tsShader_getPatchSize(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getPatchSize();
	}
	TS_CAPI void TS_CCALL tsShader_setInputSize(TSShader self, uint32_t size) {
		TS_ASSERT(self);
		((Shader*)self)->setInputSize(size);
	}
	TS_CAPI uint32_t TS_CCALL tsShader_getInputSize(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getInputSize();
	}
	TS_CAPI void TS_CCALL tsShader_setOutputSize(TSShader self, uint32_t size) {
		TS_ASSERT(self);
		((Shader*)self)->setOutputSize(size);
	}
	TS_CAPI uint32_t TS_CCALL tsShader_getOutputSize(TSShader self) {
		TS_ASSERT(self);
		return ((Shader*)self)->getOutputSize();
	}
	TS_CAPI bool_t TS_CCALL tsShader_load_STss(TSShader self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Shader*)self)->load((Shader::Type)type, name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsShader_create_STss(TSShader self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Shader*)self)->create((Shader::Type)type, src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsShader_load_STscSspu(TSShader self, TS_ShaderType type, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Shader*)self)->load((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsShader_create_STscSspu(TSShader self, TS_ShaderType type, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Shader*)self)->create((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsShader_loadGLSL_STss(TSShader self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Shader*)self)->loadGLSL((Shader::Type)type, name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsShader_createGLSL_STss(TSShader self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Shader*)self)->createGLSL((Shader::Type)type, src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsShader_loadGLSL_STscSspu(TSShader self, TS_ShaderType type, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Shader*)self)->loadGLSL((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsShader_createGLSL_STscSspu(TSShader self, TS_ShaderType type, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Shader*)self)->createGLSL((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsShader_loadSPIRV(TSShader self, TS_ShaderType type, const char *name) {
		TS_ASSERT(self);
		return ((Shader*)self)->loadSPIRV((Shader::Type)type, name);
	}
	TS_CAPI bool_t TS_CCALL tsShader_createSPIRV(TSShader self, TS_ShaderType type, const uint32_t *data, uint32_t data_size) {
		TS_ASSERT(self);
		Array<uint32_t> data_(data_size, data);
		return ((Shader*)self)->createSPIRV((Shader::Type)type, data_);
	}
	TS_CAPI bool_t TS_CCALL tsShader_hasCache(void) {
		return Shader::hasCache();
	}
	TS_CAPI bool_t TS_CCALL tsShader_setCache(const char *name) {
		return Shader::setCache(name);
	}
	TS_CAPI bool_t TS_CCALL tsShader_loadCache(const TSString hash, TSStream stream) {
		TS_ASSERT(stream);
		return Shader::loadCache((hash) ? *(const String*)hash : String::null, *(Stream*)stream);
	}
	TS_CAPI bool_t TS_CCALL tsShader_saveCache(const TSString hash, TSStream stream) {
		TS_ASSERT(stream);
		return Shader::saveCache((hash) ? *(const String*)hash : String::null, *(Stream*)stream);
	}
	TS_CAPI void TS_CCALL tsShader_clearCache(void) {
		Shader::clearCache();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isMacro(const char *name) {
		return Shader::isMacro(name);
	}
	TS_CAPI bool_t TS_CCALL tsShader_setMacro_si(const char *name, int32_t value) {
		return Shader::setMacro(name, value);
	}
	TS_CAPI bool_t TS_CCALL tsShader_setMacro_su(const char *name, uint32_t value) {
		return Shader::setMacro(name, value);
	}
	TS_CAPI bool_t TS_CCALL tsShader_setMacro_ss(const char *name, const char *value) {
		return Shader::setMacro(name, value);
	}
	TS_CAPI bool_t TS_CCALL tsShader_setMacros(const char *macros) {
		return Shader::setMacros(macros);
	}
	TS_CAPI bool_t TS_CCALL tsShader_removeMacro(const char *name) {
		return Shader::removeMacro(name);
	}
	TS_CAPI void TS_CCALL tsShader_clearMacros(void) {
		Shader::clearMacros();
	}
	TS_CAPI bool_t TS_CCALL tsShader_isInclude(const char *name) {
		return Shader::isInclude(name);
	}
	TS_CAPI bool_t TS_CCALL tsShader_setInclude(const char *name, const TSString src) {
		return Shader::setInclude(name, (src) ? *(const String*)src : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsShader_removeInclude(const char *name) {
		return Shader::removeInclude(name);
	}
	TS_CAPI void TS_CCALL tsShader_clearIncludes(void) {
		Shader::clearIncludes();
	}
	TS_CAPI TSString TS_CCALL tsShader_preprocessor_ss(const char *src, const char *format) {
		return (TSString)(new String(Shader::preprocessor(src, "%s", format)));
	}
	TS_CAPI TSString TS_CCALL tsShader_preprocessor_scSspu(const char *src, const TSString macros, const char **includes, uint32_t size) {
		return (TSString)(new String(Shader::preprocessor(src, (macros) ? *(const String*)macros : String::null, includes, size)));
	}
	
	// Tellusim::ShaderCompiler
	TS_CAPI TSShaderCompiler TS_CCALL tsShaderCompiler_new(void) {
		ShaderCompiler *ret = new ShaderCompiler();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSShaderCompiler)ret;
	}
	TS_CAPI void TS_CCALL tsShaderCompiler_delete(TSShaderCompiler self) {
		if(self) delete (ShaderCompiler*)self;
	}
	TS_CAPI bool_t TS_CCALL tsShaderCompiler_equalPtr(const TSShaderCompiler self, const TSShaderCompiler ptr) {
		return (self && ptr && ((ShaderCompiler*)self)->operator==(*(ShaderCompiler*)ptr));
	}
	TS_CAPI TSShaderCompiler TS_CCALL tsShaderCompiler_copyPtr(TSShaderCompiler self) {
		ShaderCompiler *ret = nullptr;
		if(self) ret = new ShaderCompiler(*(ShaderCompiler*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSShaderCompiler)ret;
	}
	TS_CAPI TSShaderCompiler TS_CCALL tsShaderCompiler_clonePtr(const TSShaderCompiler self) {
		ShaderCompiler *ret = (self) ? new ShaderCompiler(((ShaderCompiler*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSShaderCompiler)ret;
	}
	TS_CAPI void TS_CCALL tsShaderCompiler_clearPtr(TSShaderCompiler self) {
		if(self) ((ShaderCompiler*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsShaderCompiler_destroyPtr(TSShaderCompiler self) {
		if(self) ((ShaderCompiler*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsShaderCompiler_acquirePtr(TSShaderCompiler self) {
		if(self) ((ShaderCompiler*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsShaderCompiler_unacquirePtr(TSShaderCompiler self) {
		if(self) ((ShaderCompiler*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsShaderCompiler_isValidPtr(const TSShaderCompiler self) {
		return (self && ((ShaderCompiler*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsShaderCompiler_isOwnerPtr(const TSShaderCompiler self) {
		return (self && ((ShaderCompiler*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsShaderCompiler_isConstPtr(const TSShaderCompiler self) {
		return (self && ((ShaderCompiler*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsShaderCompiler_getCountPtr(const TSShaderCompiler self) {
		return ((ShaderCompiler*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsShaderCompiler_getInternalPtr(const TSShaderCompiler self) {
		return ((ShaderCompiler*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsShaderCompiler_equalShaderPtr(const TSShaderCompiler self, const TSShader base) {
		return (self && base && ((ShaderCompiler*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSShaderCompiler TS_CCALL tsShaderCompiler_castShaderPtr(TSShader base) {
		return (TSShaderCompiler)(new ShaderCompiler(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsShaderCompiler_baseShaderPtr(TSShaderCompiler self) {
		return (TSShader)(new Shader(((ShaderCompiler*)self)->getShader()));
	}
	TS_CAPI void TS_CCALL tsShaderCompiler_setFlags(TSShaderCompiler self, TS_ShaderCompilerFlags flags) {
		TS_ASSERT(self);
		((ShaderCompiler*)self)->setFlags((ShaderCompiler::Flags)flags);
	}
	TS_CAPI TS_ShaderCompilerFlags TS_CCALL tsShaderCompiler_getFlags(TSShaderCompiler self) {
		TS_ASSERT(self);
		return (TS_ShaderCompilerFlags)((ShaderCompiler*)self)->getFlags();
	}
	TS_CAPI bool_t TS_CCALL tsShaderCompiler_getBinary(TSShaderCompiler self, TSStream stream, TS_Platform platform) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((ShaderCompiler*)self)->getBinary(*(Stream*)stream, (Platform)platform);
	}
	TS_CAPI TSString TS_CCALL tsShaderCompiler_getSource(TSShaderCompiler self, TS_Platform platform) {
		TS_ASSERT(self);
		return (TSString)(new String(((ShaderCompiler*)self)->getSource((Platform)platform)));
	}
	
	// Tellusim::D3D12Shader
	TS_CAPI TSD3D12Shader TS_CCALL tsD3D12Shader_new(void) {
		D3D12Shader *ret = new D3D12Shader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Shader)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Shader_delete(TSD3D12Shader self) {
		if(self) delete (D3D12Shader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Shader_equalPtr(const TSD3D12Shader self, const TSD3D12Shader ptr) {
		return (self && ptr && ((D3D12Shader*)self)->operator==(*(D3D12Shader*)ptr));
	}
	TS_CAPI TSD3D12Shader TS_CCALL tsD3D12Shader_copyPtr(TSD3D12Shader self) {
		D3D12Shader *ret = nullptr;
		if(self) ret = new D3D12Shader(*(D3D12Shader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Shader)ret;
	}
	TS_CAPI TSD3D12Shader TS_CCALL tsD3D12Shader_clonePtr(const TSD3D12Shader self) {
		D3D12Shader *ret = (self) ? new D3D12Shader(((D3D12Shader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Shader)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Shader_clearPtr(TSD3D12Shader self) {
		if(self) ((D3D12Shader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Shader_destroyPtr(TSD3D12Shader self) {
		if(self) ((D3D12Shader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Shader_acquirePtr(TSD3D12Shader self) {
		if(self) ((D3D12Shader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Shader_unacquirePtr(TSD3D12Shader self) {
		if(self) ((D3D12Shader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Shader_isValidPtr(const TSD3D12Shader self) {
		return (self && ((D3D12Shader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Shader_isOwnerPtr(const TSD3D12Shader self) {
		return (self && ((D3D12Shader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Shader_isConstPtr(const TSD3D12Shader self) {
		return (self && ((D3D12Shader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Shader_getCountPtr(const TSD3D12Shader self) {
		return ((D3D12Shader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Shader_getInternalPtr(const TSD3D12Shader self) {
		return ((D3D12Shader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Shader_equalShaderPtr(const TSD3D12Shader self, const TSShader base) {
		return (self && base && ((D3D12Shader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSD3D12Shader TS_CCALL tsD3D12Shader_castShaderPtr(TSShader base) {
		return (TSD3D12Shader)(new D3D12Shader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsD3D12Shader_baseShaderPtr(TSD3D12Shader self) {
		return (TSShader)(new Shader(((D3D12Shader*)self)->getShader()));
	}
	TS_CAPI ID3DBlob* TS_CCALL tsD3D12Shader_getShaderBlob(TSD3D12Shader self) {
		TS_ASSERT(self);
		return ((D3D12Shader*)self)->getShaderBlob();
	}
	
	// Tellusim::D3D11Shader
	TS_CAPI TSD3D11Shader TS_CCALL tsD3D11Shader_new(void) {
		D3D11Shader *ret = new D3D11Shader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Shader)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Shader_delete(TSD3D11Shader self) {
		if(self) delete (D3D11Shader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Shader_equalPtr(const TSD3D11Shader self, const TSD3D11Shader ptr) {
		return (self && ptr && ((D3D11Shader*)self)->operator==(*(D3D11Shader*)ptr));
	}
	TS_CAPI TSD3D11Shader TS_CCALL tsD3D11Shader_copyPtr(TSD3D11Shader self) {
		D3D11Shader *ret = nullptr;
		if(self) ret = new D3D11Shader(*(D3D11Shader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Shader)ret;
	}
	TS_CAPI TSD3D11Shader TS_CCALL tsD3D11Shader_clonePtr(const TSD3D11Shader self) {
		D3D11Shader *ret = (self) ? new D3D11Shader(((D3D11Shader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Shader)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Shader_clearPtr(TSD3D11Shader self) {
		if(self) ((D3D11Shader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Shader_destroyPtr(TSD3D11Shader self) {
		if(self) ((D3D11Shader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Shader_acquirePtr(TSD3D11Shader self) {
		if(self) ((D3D11Shader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Shader_unacquirePtr(TSD3D11Shader self) {
		if(self) ((D3D11Shader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Shader_isValidPtr(const TSD3D11Shader self) {
		return (self && ((D3D11Shader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Shader_isOwnerPtr(const TSD3D11Shader self) {
		return (self && ((D3D11Shader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Shader_isConstPtr(const TSD3D11Shader self) {
		return (self && ((D3D11Shader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Shader_getCountPtr(const TSD3D11Shader self) {
		return ((D3D11Shader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Shader_getInternalPtr(const TSD3D11Shader self) {
		return ((D3D11Shader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Shader_equalShaderPtr(const TSD3D11Shader self, const TSShader base) {
		return (self && base && ((D3D11Shader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSD3D11Shader TS_CCALL tsD3D11Shader_castShaderPtr(TSShader base) {
		return (TSD3D11Shader)(new D3D11Shader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsD3D11Shader_baseShaderPtr(TSD3D11Shader self) {
		return (TSShader)(new Shader(((D3D11Shader*)self)->getShader()));
	}
	TS_CAPI void* TS_CCALL tsD3D11Shader_getD3D11Shader(TSD3D11Shader self) {
		TS_ASSERT(self);
		return ((D3D11Shader*)self)->getD3D11Shader();
	}
	TS_CAPI ID3DBlob* TS_CCALL tsD3D11Shader_getShaderBlob(TSD3D11Shader self) {
		TS_ASSERT(self);
		return ((D3D11Shader*)self)->getShaderBlob();
	}
	
	// Tellusim::MTLShader
	TS_CAPI TSMTLShader TS_CCALL tsMTLShader_new(void) {
		MTLShader *ret = new MTLShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLShader)ret;
	}
	TS_CAPI void TS_CCALL tsMTLShader_delete(TSMTLShader self) {
		if(self) delete (MTLShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLShader_equalPtr(const TSMTLShader self, const TSMTLShader ptr) {
		return (self && ptr && ((MTLShader*)self)->operator==(*(MTLShader*)ptr));
	}
	TS_CAPI TSMTLShader TS_CCALL tsMTLShader_copyPtr(TSMTLShader self) {
		MTLShader *ret = nullptr;
		if(self) ret = new MTLShader(*(MTLShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLShader)ret;
	}
	TS_CAPI TSMTLShader TS_CCALL tsMTLShader_clonePtr(const TSMTLShader self) {
		MTLShader *ret = (self) ? new MTLShader(((MTLShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLShader)ret;
	}
	TS_CAPI void TS_CCALL tsMTLShader_clearPtr(TSMTLShader self) {
		if(self) ((MTLShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLShader_destroyPtr(TSMTLShader self) {
		if(self) ((MTLShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLShader_acquirePtr(TSMTLShader self) {
		if(self) ((MTLShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLShader_unacquirePtr(TSMTLShader self) {
		if(self) ((MTLShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLShader_isValidPtr(const TSMTLShader self) {
		return (self && ((MTLShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLShader_isOwnerPtr(const TSMTLShader self) {
		return (self && ((MTLShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLShader_isConstPtr(const TSMTLShader self) {
		return (self && ((MTLShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLShader_getCountPtr(const TSMTLShader self) {
		return ((MTLShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLShader_getInternalPtr(const TSMTLShader self) {
		return ((MTLShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLShader_equalShaderPtr(const TSMTLShader self, const TSShader base) {
		return (self && base && ((MTLShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSMTLShader TS_CCALL tsMTLShader_castShaderPtr(TSShader base) {
		return (TSMTLShader)(new MTLShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsMTLShader_baseShaderPtr(TSMTLShader self) {
		return (TSShader)(new Shader(((MTLShader*)self)->getShader()));
	}
	TS_CAPI void TS_CCALL tsMTLShader_setIndirect(TSMTLShader self, bool_t enabled) {
		TS_ASSERT(self);
		((MTLShader*)self)->setIndirect((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsMTLShader_isIndirect(TSMTLShader self) {
		TS_ASSERT(self);
		return ((MTLShader*)self)->isIndirect();
	}
	TS_CAPI void* TS_CCALL tsMTLShader_getLibrary(TSMTLShader self) {
		TS_ASSERT(self);
		return ((MTLShader*)self)->getLibrary();
	}
	TS_CAPI void* TS_CCALL tsMTLShader_getFunction(TSMTLShader self) {
		TS_ASSERT(self);
		return ((MTLShader*)self)->getFunction();
	}
	
	// Tellusim::VKShader
	TS_CAPI TSVKShader TS_CCALL tsVKShader_new(void) {
		VKShader *ret = new VKShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKShader)ret;
	}
	TS_CAPI void TS_CCALL tsVKShader_delete(TSVKShader self) {
		if(self) delete (VKShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKShader_equalPtr(const TSVKShader self, const TSVKShader ptr) {
		return (self && ptr && ((VKShader*)self)->operator==(*(VKShader*)ptr));
	}
	TS_CAPI TSVKShader TS_CCALL tsVKShader_copyPtr(TSVKShader self) {
		VKShader *ret = nullptr;
		if(self) ret = new VKShader(*(VKShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKShader)ret;
	}
	TS_CAPI TSVKShader TS_CCALL tsVKShader_clonePtr(const TSVKShader self) {
		VKShader *ret = (self) ? new VKShader(((VKShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKShader)ret;
	}
	TS_CAPI void TS_CCALL tsVKShader_clearPtr(TSVKShader self) {
		if(self) ((VKShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKShader_destroyPtr(TSVKShader self) {
		if(self) ((VKShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKShader_acquirePtr(TSVKShader self) {
		if(self) ((VKShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKShader_unacquirePtr(TSVKShader self) {
		if(self) ((VKShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKShader_isValidPtr(const TSVKShader self) {
		return (self && ((VKShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKShader_isOwnerPtr(const TSVKShader self) {
		return (self && ((VKShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKShader_isConstPtr(const TSVKShader self) {
		return (self && ((VKShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKShader_getCountPtr(const TSVKShader self) {
		return ((VKShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKShader_getInternalPtr(const TSVKShader self) {
		return ((VKShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKShader_equalShaderPtr(const TSVKShader self, const TSShader base) {
		return (self && base && ((VKShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSVKShader TS_CCALL tsVKShader_castShaderPtr(TSShader base) {
		return (TSVKShader)(new VKShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsVKShader_baseShaderPtr(TSVKShader self) {
		return (TSShader)(new Shader(((VKShader*)self)->getShader()));
	}
	TS_CAPI VkShaderModule TS_CCALL tsVKShader_getModule(TSVKShader self) {
		TS_ASSERT(self);
		return ((VKShader*)self)->getModule();
	}
	
	// Tellusim::GLShader
	TS_CAPI TSGLShader TS_CCALL tsGLShader_new(void) {
		GLShader *ret = new GLShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLShader)ret;
	}
	TS_CAPI void TS_CCALL tsGLShader_delete(TSGLShader self) {
		if(self) delete (GLShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLShader_equalPtr(const TSGLShader self, const TSGLShader ptr) {
		return (self && ptr && ((GLShader*)self)->operator==(*(GLShader*)ptr));
	}
	TS_CAPI TSGLShader TS_CCALL tsGLShader_copyPtr(TSGLShader self) {
		GLShader *ret = nullptr;
		if(self) ret = new GLShader(*(GLShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLShader)ret;
	}
	TS_CAPI TSGLShader TS_CCALL tsGLShader_clonePtr(const TSGLShader self) {
		GLShader *ret = (self) ? new GLShader(((GLShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLShader)ret;
	}
	TS_CAPI void TS_CCALL tsGLShader_clearPtr(TSGLShader self) {
		if(self) ((GLShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLShader_destroyPtr(TSGLShader self) {
		if(self) ((GLShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLShader_acquirePtr(TSGLShader self) {
		if(self) ((GLShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLShader_unacquirePtr(TSGLShader self) {
		if(self) ((GLShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLShader_isValidPtr(const TSGLShader self) {
		return (self && ((GLShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLShader_isOwnerPtr(const TSGLShader self) {
		return (self && ((GLShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLShader_isConstPtr(const TSGLShader self) {
		return (self && ((GLShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLShader_getCountPtr(const TSGLShader self) {
		return ((GLShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLShader_getInternalPtr(const TSGLShader self) {
		return ((GLShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLShader_equalShaderPtr(const TSGLShader self, const TSShader base) {
		return (self && base && ((GLShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSGLShader TS_CCALL tsGLShader_castShaderPtr(TSShader base) {
		return (TSGLShader)(new GLShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsGLShader_baseShaderPtr(TSGLShader self) {
		return (TSShader)(new Shader(((GLShader*)self)->getShader()));
	}
	TS_CAPI bool_t TS_CCALL tsGLShader_attachShader(TSGLShader self, uint32_t program_id) {
		TS_ASSERT(self);
		return ((GLShader*)self)->attachShader(program_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLShader_getShaderType(TSGLShader self) {
		TS_ASSERT(self);
		return ((GLShader*)self)->getShaderType();
	}
	TS_CAPI uint32_t TS_CCALL tsGLShader_getShaderID(TSGLShader self) {
		TS_ASSERT(self);
		return ((GLShader*)self)->getShaderID();
	}
	
	// Tellusim::GLESShader
	TS_CAPI TSGLESShader TS_CCALL tsGLESShader_new(void) {
		GLESShader *ret = new GLESShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESShader)ret;
	}
	TS_CAPI void TS_CCALL tsGLESShader_delete(TSGLESShader self) {
		if(self) delete (GLESShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLESShader_equalPtr(const TSGLESShader self, const TSGLESShader ptr) {
		return (self && ptr && ((GLESShader*)self)->operator==(*(GLESShader*)ptr));
	}
	TS_CAPI TSGLESShader TS_CCALL tsGLESShader_copyPtr(TSGLESShader self) {
		GLESShader *ret = nullptr;
		if(self) ret = new GLESShader(*(GLESShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESShader)ret;
	}
	TS_CAPI TSGLESShader TS_CCALL tsGLESShader_clonePtr(const TSGLESShader self) {
		GLESShader *ret = (self) ? new GLESShader(((GLESShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESShader)ret;
	}
	TS_CAPI void TS_CCALL tsGLESShader_clearPtr(TSGLESShader self) {
		if(self) ((GLESShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLESShader_destroyPtr(TSGLESShader self) {
		if(self) ((GLESShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLESShader_acquirePtr(TSGLESShader self) {
		if(self) ((GLESShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLESShader_unacquirePtr(TSGLESShader self) {
		if(self) ((GLESShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESShader_isValidPtr(const TSGLESShader self) {
		return (self && ((GLESShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESShader_isOwnerPtr(const TSGLESShader self) {
		return (self && ((GLESShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESShader_isConstPtr(const TSGLESShader self) {
		return (self && ((GLESShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLESShader_getCountPtr(const TSGLESShader self) {
		return ((GLESShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLESShader_getInternalPtr(const TSGLESShader self) {
		return ((GLESShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESShader_equalShaderPtr(const TSGLESShader self, const TSShader base) {
		return (self && base && ((GLESShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSGLESShader TS_CCALL tsGLESShader_castShaderPtr(TSShader base) {
		return (TSGLESShader)(new GLESShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsGLESShader_baseShaderPtr(TSGLESShader self) {
		return (TSShader)(new Shader(((GLESShader*)self)->getShader()));
	}
	TS_CAPI bool_t TS_CCALL tsGLESShader_attachShader(TSGLESShader self, uint32_t program_id) {
		TS_ASSERT(self);
		return ((GLESShader*)self)->attachShader(program_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLESShader_getShaderType(TSGLESShader self) {
		TS_ASSERT(self);
		return ((GLESShader*)self)->getShaderType();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESShader_getShaderID(TSGLESShader self) {
		TS_ASSERT(self);
		return ((GLESShader*)self)->getShaderID();
	}
	
	// Tellusim::CUShader
	TS_CAPI TSCUShader TS_CCALL tsCUShader_new(void) {
		CUShader *ret = new CUShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUShader)ret;
	}
	TS_CAPI void TS_CCALL tsCUShader_delete(TSCUShader self) {
		if(self) delete (CUShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCUShader_equalPtr(const TSCUShader self, const TSCUShader ptr) {
		return (self && ptr && ((CUShader*)self)->operator==(*(CUShader*)ptr));
	}
	TS_CAPI TSCUShader TS_CCALL tsCUShader_copyPtr(TSCUShader self) {
		CUShader *ret = nullptr;
		if(self) ret = new CUShader(*(CUShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUShader)ret;
	}
	TS_CAPI TSCUShader TS_CCALL tsCUShader_clonePtr(const TSCUShader self) {
		CUShader *ret = (self) ? new CUShader(((CUShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUShader)ret;
	}
	TS_CAPI void TS_CCALL tsCUShader_clearPtr(TSCUShader self) {
		if(self) ((CUShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCUShader_destroyPtr(TSCUShader self) {
		if(self) ((CUShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCUShader_acquirePtr(TSCUShader self) {
		if(self) ((CUShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCUShader_unacquirePtr(TSCUShader self) {
		if(self) ((CUShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUShader_isValidPtr(const TSCUShader self) {
		return (self && ((CUShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUShader_isOwnerPtr(const TSCUShader self) {
		return (self && ((CUShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUShader_isConstPtr(const TSCUShader self) {
		return (self && ((CUShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCUShader_getCountPtr(const TSCUShader self) {
		return ((CUShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCUShader_getInternalPtr(const TSCUShader self) {
		return ((CUShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUShader_equalShaderPtr(const TSCUShader self, const TSShader base) {
		return (self && base && ((CUShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSCUShader TS_CCALL tsCUShader_castShaderPtr(TSShader base) {
		return (TSCUShader)(new CUShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsCUShader_baseShaderPtr(TSCUShader self) {
		return (TSShader)(new Shader(((CUShader*)self)->getShader()));
	}
	TS_CAPI CUmodule TS_CCALL tsCUShader_getModule(TSCUShader self) {
		TS_ASSERT(self);
		return ((CUShader*)self)->getModule();
	}
	TS_CAPI CUfunction TS_CCALL tsCUShader_getFunction(TSCUShader self) {
		TS_ASSERT(self);
		return ((CUShader*)self)->getFunction();
	}
	
	// Tellusim::HIPShader
	TS_CAPI TSHIPShader TS_CCALL tsHIPShader_new(void) {
		HIPShader *ret = new HIPShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPShader)ret;
	}
	TS_CAPI void TS_CCALL tsHIPShader_delete(TSHIPShader self) {
		if(self) delete (HIPShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsHIPShader_equalPtr(const TSHIPShader self, const TSHIPShader ptr) {
		return (self && ptr && ((HIPShader*)self)->operator==(*(HIPShader*)ptr));
	}
	TS_CAPI TSHIPShader TS_CCALL tsHIPShader_copyPtr(TSHIPShader self) {
		HIPShader *ret = nullptr;
		if(self) ret = new HIPShader(*(HIPShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPShader)ret;
	}
	TS_CAPI TSHIPShader TS_CCALL tsHIPShader_clonePtr(const TSHIPShader self) {
		HIPShader *ret = (self) ? new HIPShader(((HIPShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPShader)ret;
	}
	TS_CAPI void TS_CCALL tsHIPShader_clearPtr(TSHIPShader self) {
		if(self) ((HIPShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsHIPShader_destroyPtr(TSHIPShader self) {
		if(self) ((HIPShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsHIPShader_acquirePtr(TSHIPShader self) {
		if(self) ((HIPShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsHIPShader_unacquirePtr(TSHIPShader self) {
		if(self) ((HIPShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPShader_isValidPtr(const TSHIPShader self) {
		return (self && ((HIPShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPShader_isOwnerPtr(const TSHIPShader self) {
		return (self && ((HIPShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPShader_isConstPtr(const TSHIPShader self) {
		return (self && ((HIPShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsHIPShader_getCountPtr(const TSHIPShader self) {
		return ((HIPShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsHIPShader_getInternalPtr(const TSHIPShader self) {
		return ((HIPShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPShader_equalShaderPtr(const TSHIPShader self, const TSShader base) {
		return (self && base && ((HIPShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSHIPShader TS_CCALL tsHIPShader_castShaderPtr(TSShader base) {
		return (TSHIPShader)(new HIPShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsHIPShader_baseShaderPtr(TSHIPShader self) {
		return (TSShader)(new Shader(((HIPShader*)self)->getShader()));
	}
	TS_CAPI void* TS_CCALL tsHIPShader_getModule(TSHIPShader self) {
		TS_ASSERT(self);
		return ((HIPShader*)self)->getModule();
	}
	TS_CAPI void* TS_CCALL tsHIPShader_getFunction(TSHIPShader self) {
		TS_ASSERT(self);
		return ((HIPShader*)self)->getFunction();
	}
	
	// Tellusim::FUShader
	TS_CAPI TSFUShader TS_CCALL tsFUShader_new(void) {
		FUShader *ret = new FUShader();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUShader)ret;
	}
	TS_CAPI TSFUShader TS_CCALL tsFUShader_new_cASb(const TSShader *shaders, uint32_t shaders_size, bool_t owner) {
		Array<Shader> shaders_(shaders_size);
		for(uint32_t i = 0; i < shaders_size; i++) if(shaders[i]) shaders_[i] = *(Shader*)shaders[i];
		FUShader *ret = new FUShader(shaders_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUShader)ret;
	}
	TS_CAPI void TS_CCALL tsFUShader_delete(TSFUShader self) {
		if(self) delete (FUShader*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUShader_equalPtr(const TSFUShader self, const TSFUShader ptr) {
		return (self && ptr && ((FUShader*)self)->operator==(*(FUShader*)ptr));
	}
	TS_CAPI TSFUShader TS_CCALL tsFUShader_copyPtr(TSFUShader self) {
		FUShader *ret = nullptr;
		if(self) ret = new FUShader(*(FUShader*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUShader)ret;
	}
	TS_CAPI TSFUShader TS_CCALL tsFUShader_clonePtr(const TSFUShader self) {
		FUShader *ret = (self) ? new FUShader(((FUShader*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUShader)ret;
	}
	TS_CAPI void TS_CCALL tsFUShader_clearPtr(TSFUShader self) {
		if(self) ((FUShader*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUShader_destroyPtr(TSFUShader self) {
		if(self) ((FUShader*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUShader_acquirePtr(TSFUShader self) {
		if(self) ((FUShader*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUShader_unacquirePtr(TSFUShader self) {
		if(self) ((FUShader*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUShader_isValidPtr(const TSFUShader self) {
		return (self && ((FUShader*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUShader_isOwnerPtr(const TSFUShader self) {
		return (self && ((FUShader*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUShader_isConstPtr(const TSFUShader self) {
		return (self && ((FUShader*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUShader_getCountPtr(const TSFUShader self) {
		return ((FUShader*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUShader_getInternalPtr(const TSFUShader self) {
		return ((FUShader*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUShader_equalShaderPtr(const TSFUShader self, const TSShader base) {
		return (self && base && ((FUShader*)self)->operator==(*(Shader*)base));
	}
	TS_CAPI TSFUShader TS_CCALL tsFUShader_castShaderPtr(TSShader base) {
		return (TSFUShader)(new FUShader(*(Shader*)base));
	}
	TS_CAPI TSShader TS_CCALL tsFUShader_baseShaderPtr(TSFUShader self) {
		return (TSShader)(new Shader(((FUShader*)self)->getShader()));
	}
	TS_CAPI void TS_CCALL tsFUShader_setMask(TSFUShader self, uint32_t mask) {
		TS_ASSERT(self);
		((FUShader*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUShader_getMask(TSFUShader self) {
		TS_ASSERT(self);
		return ((FUShader*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUShader_getNumShaders(TSFUShader self) {
		TS_ASSERT(self);
		return ((FUShader*)self)->getNumShaders();
	}
	TS_CAPI TSShader TS_CCALL tsFUShader_getShader_cu(TSFUShader self, uint32_t index) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((FUShader*)self)->getShader(index)));
	}
	TS_CAPI TSShader TS_CCALL tsFUShader_getShader_u(TSFUShader self, uint32_t index) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((FUShader*)self)->getShader(index)));
	}
	
	// Tellusim::Sampler
	TS_CAPI TSSampler TS_CCALL tsSampler_new(void) {
		Sampler *ret = new Sampler();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSampler)ret;
	}
	TS_CAPI void TS_CCALL tsSampler_delete(TSSampler self) {
		if(self) delete (Sampler*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSampler_equalPtr(const TSSampler self, const TSSampler ptr) {
		return (self && ptr && ((Sampler*)self)->operator==(*(Sampler*)ptr));
	}
	TS_CAPI TSSampler TS_CCALL tsSampler_copyPtr(TSSampler self) {
		Sampler *ret = nullptr;
		if(self) ret = new Sampler(*(Sampler*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSampler)ret;
	}
	TS_CAPI TSSampler TS_CCALL tsSampler_clonePtr(const TSSampler self) {
		Sampler *ret = (self) ? new Sampler(((Sampler*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSampler)ret;
	}
	TS_CAPI void TS_CCALL tsSampler_clearPtr(TSSampler self) {
		if(self) ((Sampler*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSampler_destroyPtr(TSSampler self) {
		if(self) ((Sampler*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSampler_acquirePtr(TSSampler self) {
		if(self) ((Sampler*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSampler_unacquirePtr(TSSampler self) {
		if(self) ((Sampler*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSampler_isValidPtr(const TSSampler self) {
		return (self && ((Sampler*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSampler_isOwnerPtr(const TSSampler self) {
		return (self && ((Sampler*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSampler_isConstPtr(const TSSampler self) {
		return (self && ((Sampler*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSampler_getCountPtr(const TSSampler self) {
		return ((Sampler*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSampler_getInternalPtr(const TSSampler self) {
		return ((Sampler*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsSampler_getPlatform(TSSampler self) {
		TS_ASSERT(self);
		return (TS_Platform)((Sampler*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsSampler_getPlatformName(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsSampler_getIndex(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsSampler_clear(TSSampler self) {
		TS_ASSERT(self);
		((Sampler*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsSampler_isCreated(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsSampler_create(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->create();
	}
	TS_CAPI void TS_CCALL tsSampler_setParameters(TSSampler self, const TSSampler sampler) {
		TS_ASSERT(self);
		TS_ASSERT(sampler);
		((Sampler*)self)->setParameters(*(const Sampler*)sampler);
	}
	TS_CAPI void TS_CCALL tsSampler_setFilter(TSSampler self, TS_SamplerFilter filter) {
		TS_ASSERT(self);
		((Sampler*)self)->setFilter((Sampler::Filter)filter);
	}
	TS_CAPI TS_SamplerFilter TS_CCALL tsSampler_getFilter(TSSampler self) {
		TS_ASSERT(self);
		return (TS_SamplerFilter)((Sampler*)self)->getFilter();
	}
	TS_CAPI bool_t TS_CCALL tsSampler_isPointFilter(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->isPointFilter();
	}
	TS_CAPI void TS_CCALL tsSampler_setAnisotropy(TSSampler self, uint32_t anisotropy) {
		TS_ASSERT(self);
		((Sampler*)self)->setAnisotropy(anisotropy);
	}
	TS_CAPI uint32_t TS_CCALL tsSampler_getAnisotropy(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->getAnisotropy();
	}
	TS_CAPI bool_t TS_CCALL tsSampler_hasAnisotropy(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->hasAnisotropy();
	}
	TS_CAPI void TS_CCALL tsSampler_setWrapMode_SWM(TSSampler self, TS_SamplerWrapMode mode) {
		TS_ASSERT(self);
		((Sampler*)self)->setWrapMode((Sampler::WrapMode)mode);
	}
	TS_CAPI void TS_CCALL tsSampler_setWrapMode_SWMSWMSWM(TSSampler self, TS_SamplerWrapMode mode_s, TS_SamplerWrapMode mode_t, TS_SamplerWrapMode mode_r) {
		TS_ASSERT(self);
		((Sampler*)self)->setWrapMode((Sampler::WrapMode)mode_s, (Sampler::WrapMode)mode_t, (Sampler::WrapMode)mode_r);
	}
	TS_CAPI void TS_CCALL tsSampler_setWrapModeS(TSSampler self, TS_SamplerWrapMode mode) {
		TS_ASSERT(self);
		((Sampler*)self)->setWrapModeS((Sampler::WrapMode)mode);
	}
	TS_CAPI TS_SamplerWrapMode TS_CCALL tsSampler_getWrapModeS(TSSampler self) {
		TS_ASSERT(self);
		return (TS_SamplerWrapMode)((Sampler*)self)->getWrapModeS();
	}
	TS_CAPI void TS_CCALL tsSampler_setWrapModeT(TSSampler self, TS_SamplerWrapMode mode) {
		TS_ASSERT(self);
		((Sampler*)self)->setWrapModeT((Sampler::WrapMode)mode);
	}
	TS_CAPI TS_SamplerWrapMode TS_CCALL tsSampler_getWrapModeT(TSSampler self) {
		TS_ASSERT(self);
		return (TS_SamplerWrapMode)((Sampler*)self)->getWrapModeT();
	}
	TS_CAPI void TS_CCALL tsSampler_setWrapModeR(TSSampler self, TS_SamplerWrapMode mode) {
		TS_ASSERT(self);
		((Sampler*)self)->setWrapModeR((Sampler::WrapMode)mode);
	}
	TS_CAPI TS_SamplerWrapMode TS_CCALL tsSampler_getWrapModeR(TSSampler self) {
		TS_ASSERT(self);
		return (TS_SamplerWrapMode)((Sampler*)self)->getWrapModeR();
	}
	TS_CAPI void TS_CCALL tsSampler_setLod(TSSampler self, float32_t min, float32_t max, float32_t bias) {
		TS_ASSERT(self);
		((Sampler*)self)->setLod(min, max, bias);
	}
	TS_CAPI void TS_CCALL tsSampler_setLodMin(TSSampler self, float32_t min) {
		TS_ASSERT(self);
		((Sampler*)self)->setLodMin(min);
	}
	TS_CAPI float32_t TS_CCALL tsSampler_getLodMin(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->getLodMin();
	}
	TS_CAPI void TS_CCALL tsSampler_setLodMax(TSSampler self, float32_t max) {
		TS_ASSERT(self);
		((Sampler*)self)->setLodMax(max);
	}
	TS_CAPI float32_t TS_CCALL tsSampler_getLodMax(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->getLodMax();
	}
	TS_CAPI void TS_CCALL tsSampler_setLodBias(TSSampler self, float32_t bias) {
		TS_ASSERT(self);
		((Sampler*)self)->setLodBias(bias);
	}
	TS_CAPI float32_t TS_CCALL tsSampler_getLodBias(TSSampler self) {
		TS_ASSERT(self);
		return ((Sampler*)self)->getLodBias();
	}
	TS_CAPI void TS_CCALL tsSampler_setBorderColor_cC(TSSampler self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((Sampler*)self)->setBorderColor(*(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsSampler_setBorderColor_ffff(TSSampler self, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((Sampler*)self)->setBorderColor(r, g, b, a);
	}
	TS_CAPI TSColor TS_CCALL tsSampler_getBorderColor(TSSampler self) {
		TS_ASSERT(self);
		const Color ret = ((Sampler*)self)->getBorderColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsSampler_setCompareFunc(TSSampler self, TS_SamplerCompareFunc func) {
		TS_ASSERT(self);
		((Sampler*)self)->setCompareFunc((Sampler::CompareFunc)func);
	}
	TS_CAPI TS_SamplerCompareFunc TS_CCALL tsSampler_getCompareFunc(TSSampler self) {
		TS_ASSERT(self);
		return (TS_SamplerCompareFunc)((Sampler*)self)->getCompareFunc();
	}
	TS_CAPI void TS_CCALL tsSampler_setReductionMode(TSSampler self, TS_SamplerReductionMode mode) {
		TS_ASSERT(self);
		((Sampler*)self)->setReductionMode((Sampler::ReductionMode)mode);
	}
	TS_CAPI TS_SamplerReductionMode TS_CCALL tsSampler_getReductionMode(TSSampler self) {
		TS_ASSERT(self);
		return (TS_SamplerReductionMode)((Sampler*)self)->getReductionMode();
	}
	
	// Tellusim::MTLSampler
	TS_CAPI TSMTLSampler TS_CCALL tsMTLSampler_new(void) {
		MTLSampler *ret = new MTLSampler();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSampler)ret;
	}
	TS_CAPI void TS_CCALL tsMTLSampler_delete(TSMTLSampler self) {
		if(self) delete (MTLSampler*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLSampler_equalPtr(const TSMTLSampler self, const TSMTLSampler ptr) {
		return (self && ptr && ((MTLSampler*)self)->operator==(*(MTLSampler*)ptr));
	}
	TS_CAPI TSMTLSampler TS_CCALL tsMTLSampler_copyPtr(TSMTLSampler self) {
		MTLSampler *ret = nullptr;
		if(self) ret = new MTLSampler(*(MTLSampler*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSampler)ret;
	}
	TS_CAPI TSMTLSampler TS_CCALL tsMTLSampler_clonePtr(const TSMTLSampler self) {
		MTLSampler *ret = (self) ? new MTLSampler(((MTLSampler*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSampler)ret;
	}
	TS_CAPI void TS_CCALL tsMTLSampler_clearPtr(TSMTLSampler self) {
		if(self) ((MTLSampler*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLSampler_destroyPtr(TSMTLSampler self) {
		if(self) ((MTLSampler*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLSampler_acquirePtr(TSMTLSampler self) {
		if(self) ((MTLSampler*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLSampler_unacquirePtr(TSMTLSampler self) {
		if(self) ((MTLSampler*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLSampler_isValidPtr(const TSMTLSampler self) {
		return (self && ((MTLSampler*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLSampler_isOwnerPtr(const TSMTLSampler self) {
		return (self && ((MTLSampler*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLSampler_isConstPtr(const TSMTLSampler self) {
		return (self && ((MTLSampler*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLSampler_getCountPtr(const TSMTLSampler self) {
		return ((MTLSampler*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLSampler_getInternalPtr(const TSMTLSampler self) {
		return ((MTLSampler*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLSampler_equalSamplerPtr(const TSMTLSampler self, const TSSampler base) {
		return (self && base && ((MTLSampler*)self)->operator==(*(Sampler*)base));
	}
	TS_CAPI TSMTLSampler TS_CCALL tsMTLSampler_castSamplerPtr(TSSampler base) {
		return (TSMTLSampler)(new MTLSampler(*(Sampler*)base));
	}
	TS_CAPI TSSampler TS_CCALL tsMTLSampler_baseSamplerPtr(TSMTLSampler self) {
		return (TSSampler)(new Sampler(((MTLSampler*)self)->getSampler()));
	}
	TS_CAPI void TS_CCALL tsMTLSampler_setIndirect(TSMTLSampler self, bool_t enabled) {
		TS_ASSERT(self);
		((MTLSampler*)self)->setIndirect((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsMTLSampler_isIndirect(TSMTLSampler self) {
		TS_ASSERT(self);
		return ((MTLSampler*)self)->isIndirect();
	}
	
	// Tellusim::FUSampler
	TS_CAPI TSFUSampler TS_CCALL tsFUSampler_new(void) {
		FUSampler *ret = new FUSampler();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUSampler)ret;
	}
	TS_CAPI TSFUSampler TS_CCALL tsFUSampler_new_cASb(const TSSampler *samplers, uint32_t samplers_size, bool_t owner) {
		Array<Sampler> samplers_(samplers_size);
		for(uint32_t i = 0; i < samplers_size; i++) if(samplers[i]) samplers_[i] = *(Sampler*)samplers[i];
		FUSampler *ret = new FUSampler(samplers_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUSampler)ret;
	}
	TS_CAPI void TS_CCALL tsFUSampler_delete(TSFUSampler self) {
		if(self) delete (FUSampler*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUSampler_equalPtr(const TSFUSampler self, const TSFUSampler ptr) {
		return (self && ptr && ((FUSampler*)self)->operator==(*(FUSampler*)ptr));
	}
	TS_CAPI TSFUSampler TS_CCALL tsFUSampler_copyPtr(TSFUSampler self) {
		FUSampler *ret = nullptr;
		if(self) ret = new FUSampler(*(FUSampler*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUSampler)ret;
	}
	TS_CAPI TSFUSampler TS_CCALL tsFUSampler_clonePtr(const TSFUSampler self) {
		FUSampler *ret = (self) ? new FUSampler(((FUSampler*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUSampler)ret;
	}
	TS_CAPI void TS_CCALL tsFUSampler_clearPtr(TSFUSampler self) {
		if(self) ((FUSampler*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUSampler_destroyPtr(TSFUSampler self) {
		if(self) ((FUSampler*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUSampler_acquirePtr(TSFUSampler self) {
		if(self) ((FUSampler*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUSampler_unacquirePtr(TSFUSampler self) {
		if(self) ((FUSampler*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUSampler_isValidPtr(const TSFUSampler self) {
		return (self && ((FUSampler*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUSampler_isOwnerPtr(const TSFUSampler self) {
		return (self && ((FUSampler*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUSampler_isConstPtr(const TSFUSampler self) {
		return (self && ((FUSampler*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUSampler_getCountPtr(const TSFUSampler self) {
		return ((FUSampler*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUSampler_getInternalPtr(const TSFUSampler self) {
		return ((FUSampler*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUSampler_equalSamplerPtr(const TSFUSampler self, const TSSampler base) {
		return (self && base && ((FUSampler*)self)->operator==(*(Sampler*)base));
	}
	TS_CAPI TSFUSampler TS_CCALL tsFUSampler_castSamplerPtr(TSSampler base) {
		return (TSFUSampler)(new FUSampler(*(Sampler*)base));
	}
	TS_CAPI TSSampler TS_CCALL tsFUSampler_baseSamplerPtr(TSFUSampler self) {
		return (TSSampler)(new Sampler(((FUSampler*)self)->getSampler()));
	}
	TS_CAPI void TS_CCALL tsFUSampler_setMask(TSFUSampler self, uint32_t mask) {
		TS_ASSERT(self);
		((FUSampler*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUSampler_getMask(TSFUSampler self) {
		TS_ASSERT(self);
		return ((FUSampler*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUSampler_getNumSamplers(TSFUSampler self) {
		TS_ASSERT(self);
		return ((FUSampler*)self)->getNumSamplers();
	}
	TS_CAPI TSSampler TS_CCALL tsFUSampler_getSampler_cu(TSFUSampler self, uint32_t index) {
		TS_ASSERT(self);
		return (TSSampler)(new Sampler(((FUSampler*)self)->getSampler(index)));
	}
	TS_CAPI TSSampler TS_CCALL tsFUSampler_getSampler_u(TSFUSampler self, uint32_t index) {
		TS_ASSERT(self);
		return (TSSampler)(new Sampler(((FUSampler*)self)->getSampler(index)));
	}
	
	// Tellusim::Texture
	TS_CAPI TSTexture TS_CCALL tsTexture_new(void) {
		Texture *ret = new Texture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTexture)ret;
	}
	TS_CAPI void TS_CCALL tsTexture_delete(TSTexture self) {
		if(self) delete (Texture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsTexture_equalPtr(const TSTexture self, const TSTexture ptr) {
		return (self && ptr && ((Texture*)self)->operator==(*(Texture*)ptr));
	}
	TS_CAPI TSTexture TS_CCALL tsTexture_copyPtr(TSTexture self) {
		Texture *ret = nullptr;
		if(self) ret = new Texture(*(Texture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTexture)ret;
	}
	TS_CAPI TSTexture TS_CCALL tsTexture_clonePtr(const TSTexture self) {
		Texture *ret = (self) ? new Texture(((Texture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTexture)ret;
	}
	TS_CAPI void TS_CCALL tsTexture_clearPtr(TSTexture self) {
		if(self) ((Texture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsTexture_destroyPtr(TSTexture self) {
		if(self) ((Texture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsTexture_acquirePtr(TSTexture self) {
		if(self) ((Texture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsTexture_unacquirePtr(TSTexture self) {
		if(self) ((Texture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isValidPtr(const TSTexture self) {
		return (self && ((Texture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isOwnerPtr(const TSTexture self) {
		return (self && ((Texture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isConstPtr(const TSTexture self) {
		return (self && ((Texture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getCountPtr(const TSTexture self) {
		return ((Texture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsTexture_getInternalPtr(const TSTexture self) {
		return ((Texture*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsTexture_getPlatform(TSTexture self) {
		TS_ASSERT(self);
		return (TS_Platform)((Texture*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsTexture_getPlatformName(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getIndex(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsTexture_clear(TSTexture self) {
		TS_ASSERT(self);
		((Texture*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isCreated(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsTexture_setName(TSTexture self, const char *name) {
		TS_ASSERT(self);
		((Texture*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsTexture_getName(TSTexture self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Texture*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsTexture_create(TSTexture self, TS_TextureType type, TS_Format format, const TSSize *size, uint32_t layers, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((Texture*)self)->create((Texture::Type)type, (Format)format, *(const Size*)size, layers, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_create2D_FuTF(TSTexture self, TS_Format format, uint32_t size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->create2D((Format)format, size, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_create3D_FuTF(TSTexture self, TS_Format format, uint32_t size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->create3D((Format)format, size, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_createCube_FuTF(TSTexture self, TS_Format format, uint32_t size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->createCube((Format)format, size, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_create2D_FuuTF(TSTexture self, TS_Format format, uint32_t width, uint32_t height, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->create2D((Format)format, width, height, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_create3D_FuuuTF(TSTexture self, TS_Format format, uint32_t width, uint32_t height, uint32_t depth, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->create3D((Format)format, width, height, depth, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_create2D_FuuuTF(TSTexture self, TS_Format format, uint32_t width, uint32_t height, uint32_t layers, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->create2D((Format)format, width, height, layers, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_createCube_FuuTF(TSTexture self, TS_Format format, uint32_t size, uint32_t layers, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->createCube((Format)format, size, layers, (Texture::Flags)flags);
	}
	TS_CAPI TS_TextureType TS_CCALL tsTexture_getType(TSTexture self) {
		TS_ASSERT(self);
		return (TS_TextureType)((Texture*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsTexture_getTypeName_TT(TS_TextureType type) {
		return Texture::getTypeName((Texture::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsTexture_getTypeName_c(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_is2DType(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->is2DType();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_is3DType(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->is3DType();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isCubeType(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isCubeType();
	}
	TS_CAPI TS_Format TS_CCALL tsTexture_getFormat(TSTexture self) {
		TS_ASSERT(self);
		return (TS_Format)((Texture*)self)->getFormat();
	}
	TS_CAPI const char* TS_CCALL tsTexture_getFormatName(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getFormatName();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isColorFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isColorFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isDepthFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isDepthFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isPixelFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isPixelFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isPlainFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isPlainFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isMixedFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isMixedFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isBlockFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isBlockFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isStencilFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isStencilFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isNormFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isNormFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isSRGBFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isSRGBFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isFloatFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isFloatFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isSignedFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isSignedFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isUnsignedFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isUnsignedFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isIntegerFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isIntegerFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isi8Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isi8Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isu8Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isu8Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_is8BitFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->is8BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isi16Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isi16Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isu16Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isu16Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isf16Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isf16Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_is16BitFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->is16BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isi32Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isi32Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isu32Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isu32Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isf32Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isf32Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_is32BitFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->is32BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isi64Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isi64Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isu64Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isu64Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isf64Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isf64Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_is64BitFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->is64BitFormat();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isBC15Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isBC15Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isBC67Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isBC67Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isETC2Format(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isETC2Format();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_isASTCFormat(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->isASTCFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getComponents(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getComponents();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getPixelSize(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getPixelSize();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getBlockSize(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getBlockSize();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getBlockWidth(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getBlockWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getBlockHeight(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getBlockHeight();
	}
	TS_CAPI TS_TextureFlags TS_CCALL tsTexture_getFlags(TSTexture self) {
		TS_ASSERT(self);
		return (TS_TextureFlags)((Texture*)self)->getFlags();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_hasFlag(TSTexture self, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->hasFlag((Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_hasFlags(TSTexture self, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return ((Texture*)self)->hasFlags((Texture::Flags)flags);
	}
	TS_CAPI TSString TS_CCALL tsTexture_getFlagsName(TSTexture self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Texture*)self)->getFlagsName()));
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getMultisample(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getMultisample();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_hasMultisample(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->hasMultisample();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getWidth_c(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getHeight_c(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getDepth_c(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getDepth();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getFaces(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getFaces();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getLayers(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getLayers();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getMipmaps(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getMipmaps();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_findMipmap(TSTexture self, const TSSize *size) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return ((Texture*)self)->findMipmap(*(const Size*)size);
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getWidth_cu(TSTexture self, uint32_t mipmap) {
		TS_ASSERT(self);
		return ((Texture*)self)->getWidth(mipmap);
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getHeight_cu(TSTexture self, uint32_t mipmap) {
		TS_ASSERT(self);
		return ((Texture*)self)->getHeight(mipmap);
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getDepth_cu(TSTexture self, uint32_t mipmap) {
		TS_ASSERT(self);
		return ((Texture*)self)->getDepth(mipmap);
	}
	TS_CAPI bool_t TS_CCALL tsTexture_hasFaces(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->hasFaces();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_hasLayers(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->hasLayers();
	}
	TS_CAPI bool_t TS_CCALL tsTexture_hasMipmaps(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->hasMipmaps();
	}
	TS_CAPI TSSize TS_CCALL tsTexture_getSize_c(TSTexture self) {
		TS_ASSERT(self);
		Size ret = ((Texture*)self)->getSize();
		return *(TSSize*)&ret;
	}
	TS_CAPI TSRegion TS_CCALL tsTexture_getRegion_c(TSTexture self) {
		TS_ASSERT(self);
		Region ret = ((Texture*)self)->getRegion();
		return *(TSRegion*)&ret;
	}
	TS_CAPI TSSlice TS_CCALL tsTexture_getSlice_c(TSTexture self) {
		TS_ASSERT(self);
		Slice ret = ((Texture*)self)->getSlice();
		return *(TSSlice*)&ret;
	}
	TS_CAPI TSSize TS_CCALL tsTexture_getSize_cu(TSTexture self, uint32_t mipmap) {
		TS_ASSERT(self);
		Size ret = ((Texture*)self)->getSize(mipmap);
		return *(TSSize*)&ret;
	}
	TS_CAPI TSRegion TS_CCALL tsTexture_getRegion_cu(TSTexture self, uint32_t mipmap) {
		TS_ASSERT(self);
		Region ret = ((Texture*)self)->getRegion(mipmap);
		return *(TSRegion*)&ret;
	}
	TS_CAPI TSSlice TS_CCALL tsTexture_getSlice_cu(TSTexture self, uint32_t mipmap) {
		TS_ASSERT(self);
		Slice ret = ((Texture*)self)->getSlice(mipmap);
		return *(TSSlice*)&ret;
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getTileWidth(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getTileWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getTileHeight(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getTileHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getTileDepth(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getTileDepth();
	}
	TS_CAPI uint32_t TS_CCALL tsTexture_getTileMipmaps(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getTileMipmaps();
	}
	TS_CAPI TSSize TS_CCALL tsTexture_getTileSize(TSTexture self) {
		TS_ASSERT(self);
		Size ret = ((Texture*)self)->getTileSize();
		return *(TSSize*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsTexture_getDescription(TSTexture self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Texture*)self)->getDescription()));
	}
	TS_CAPI size_t TS_CCALL tsTexture_getMemory(TSTexture self) {
		TS_ASSERT(self);
		return ((Texture*)self)->getMemory();
	}
	
	// Tellusim::TextureTable
	TS_CAPI TSTextureTable TS_CCALL tsTextureTable_new(void) {
		TextureTable *ret = new TextureTable();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTextureTable)ret;
	}
	TS_CAPI void TS_CCALL tsTextureTable_delete(TSTextureTable self) {
		if(self) delete (TextureTable*)self;
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_equalPtr(const TSTextureTable self, const TSTextureTable ptr) {
		return (self && ptr && ((TextureTable*)self)->operator==(*(TextureTable*)ptr));
	}
	TS_CAPI TSTextureTable TS_CCALL tsTextureTable_copyPtr(TSTextureTable self) {
		TextureTable *ret = nullptr;
		if(self) ret = new TextureTable(*(TextureTable*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTextureTable)ret;
	}
	TS_CAPI TSTextureTable TS_CCALL tsTextureTable_clonePtr(const TSTextureTable self) {
		TextureTable *ret = (self) ? new TextureTable(((TextureTable*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTextureTable)ret;
	}
	TS_CAPI void TS_CCALL tsTextureTable_clearPtr(TSTextureTable self) {
		if(self) ((TextureTable*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsTextureTable_destroyPtr(TSTextureTable self) {
		if(self) ((TextureTable*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsTextureTable_acquirePtr(TSTextureTable self) {
		if(self) ((TextureTable*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsTextureTable_unacquirePtr(TSTextureTable self) {
		if(self) ((TextureTable*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_isValidPtr(const TSTextureTable self) {
		return (self && ((TextureTable*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_isOwnerPtr(const TSTextureTable self) {
		return (self && ((TextureTable*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_isConstPtr(const TSTextureTable self) {
		return (self && ((TextureTable*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsTextureTable_getCountPtr(const TSTextureTable self) {
		return ((TextureTable*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsTextureTable_getInternalPtr(const TSTextureTable self) {
		return ((TextureTable*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsTextureTable_getPlatform(TSTextureTable self) {
		TS_ASSERT(self);
		return (TS_Platform)((TextureTable*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsTextureTable_getPlatformName(TSTextureTable self) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsTextureTable_getIndex(TSTextureTable self) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsTextureTable_clear(TSTextureTable self) {
		TS_ASSERT(self);
		((TextureTable*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_isCreated(TSTextureTable self) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsTextureTable_setName(TSTextureTable self, const char *name) {
		TS_ASSERT(self);
		((TextureTable*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsTextureTable_getName(TSTextureTable self) {
		TS_ASSERT(self);
		return (TSString)(new String(((TextureTable*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_create(TSTextureTable self, TS_TextureType type, uint32_t size) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->create((Texture::Type)type, size);
	}
	TS_CAPI TS_TextureType TS_CCALL tsTextureTable_getType(TSTextureTable self) {
		TS_ASSERT(self);
		return (TS_TextureType)((TextureTable*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsTextureTable_getTypeName(TSTextureTable self) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->getTypeName();
	}
	TS_CAPI uint32_t TS_CCALL tsTextureTable_getSize(TSTextureTable self) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->getSize();
	}
	TS_CAPI TSTexture TS_CCALL tsTextureTable_get(TSTextureTable self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((TextureTable*)self)->get(index)));
	}
	TS_CAPI bool_t TS_CCALL tsTextureTable_isOwner(TSTextureTable self, uint32_t index) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->isOwner(index);
	}
	TS_CAPI size_t TS_CCALL tsTextureTable_getMemory(TSTextureTable self) {
		TS_ASSERT(self);
		return ((TextureTable*)self)->getMemory();
	}
	
	// Tellusim::D3D12Texture
	TS_CAPI TSD3D12Texture TS_CCALL tsD3D12Texture_new(void) {
		D3D12Texture *ret = new D3D12Texture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Texture)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Texture_delete(TSD3D12Texture self) {
		if(self) delete (D3D12Texture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Texture_equalPtr(const TSD3D12Texture self, const TSD3D12Texture ptr) {
		return (self && ptr && ((D3D12Texture*)self)->operator==(*(D3D12Texture*)ptr));
	}
	TS_CAPI TSD3D12Texture TS_CCALL tsD3D12Texture_copyPtr(TSD3D12Texture self) {
		D3D12Texture *ret = nullptr;
		if(self) ret = new D3D12Texture(*(D3D12Texture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Texture)ret;
	}
	TS_CAPI TSD3D12Texture TS_CCALL tsD3D12Texture_clonePtr(const TSD3D12Texture self) {
		D3D12Texture *ret = (self) ? new D3D12Texture(((D3D12Texture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Texture)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Texture_clearPtr(TSD3D12Texture self) {
		if(self) ((D3D12Texture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Texture_destroyPtr(TSD3D12Texture self) {
		if(self) ((D3D12Texture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Texture_acquirePtr(TSD3D12Texture self) {
		if(self) ((D3D12Texture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Texture_unacquirePtr(TSD3D12Texture self) {
		if(self) ((D3D12Texture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Texture_isValidPtr(const TSD3D12Texture self) {
		return (self && ((D3D12Texture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Texture_isOwnerPtr(const TSD3D12Texture self) {
		return (self && ((D3D12Texture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Texture_isConstPtr(const TSD3D12Texture self) {
		return (self && ((D3D12Texture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Texture_getCountPtr(const TSD3D12Texture self) {
		return ((D3D12Texture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Texture_getInternalPtr(const TSD3D12Texture self) {
		return ((D3D12Texture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Texture_equalTexturePtr(const TSD3D12Texture self, const TSTexture base) {
		return (self && base && ((D3D12Texture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSD3D12Texture TS_CCALL tsD3D12Texture_castTexturePtr(TSTexture base) {
		return (TSD3D12Texture)(new D3D12Texture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsD3D12Texture_baseTexturePtr(TSD3D12Texture self) {
		return (TSTexture)(new Texture(((D3D12Texture*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Texture_create(TSD3D12Texture self, TS_TextureType type, ID3D12Resource *texture, uint32_t state, TS_TextureFlags flags, TS_Format format) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->create((Texture::Type)type, texture, state, (Texture::Flags)flags, (Format)format);
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Texture_getDXGIFormat(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getDXGIFormat();
	}
	TS_CAPI ID3D12Resource* TS_CCALL tsD3D12Texture_getD3D12Texture(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getD3D12Texture();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Texture_getShaderResourceView(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getShaderResourceView();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Texture_getRenderTargetView(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getRenderTargetView();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Texture_getDepthStencilView(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getDepthStencilView();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Texture_getUnorderedAccessView(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getUnorderedAccessView();
	}
	TS_CAPI void TS_CCALL tsD3D12Texture_setTextureState(TSD3D12Texture self, uint32_t state) {
		TS_ASSERT(self);
		((D3D12Texture*)self)->setTextureState(state);
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Texture_getTextureState(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getTextureState();
	}
	TS_CAPI void* TS_CCALL tsD3D12Texture_getSharedHandle(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getSharedHandle();
	}
	TS_CAPI void* TS_CCALL tsD3D12Texture_getInteropHandle(TSD3D12Texture self) {
		TS_ASSERT(self);
		return ((D3D12Texture*)self)->getInteropHandle();
	}
	
	// Tellusim::D3D11Texture
	TS_CAPI TSD3D11Texture TS_CCALL tsD3D11Texture_new(void) {
		D3D11Texture *ret = new D3D11Texture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Texture)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Texture_delete(TSD3D11Texture self) {
		if(self) delete (D3D11Texture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Texture_equalPtr(const TSD3D11Texture self, const TSD3D11Texture ptr) {
		return (self && ptr && ((D3D11Texture*)self)->operator==(*(D3D11Texture*)ptr));
	}
	TS_CAPI TSD3D11Texture TS_CCALL tsD3D11Texture_copyPtr(TSD3D11Texture self) {
		D3D11Texture *ret = nullptr;
		if(self) ret = new D3D11Texture(*(D3D11Texture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Texture)ret;
	}
	TS_CAPI TSD3D11Texture TS_CCALL tsD3D11Texture_clonePtr(const TSD3D11Texture self) {
		D3D11Texture *ret = (self) ? new D3D11Texture(((D3D11Texture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Texture)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Texture_clearPtr(TSD3D11Texture self) {
		if(self) ((D3D11Texture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Texture_destroyPtr(TSD3D11Texture self) {
		if(self) ((D3D11Texture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Texture_acquirePtr(TSD3D11Texture self) {
		if(self) ((D3D11Texture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Texture_unacquirePtr(TSD3D11Texture self) {
		if(self) ((D3D11Texture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Texture_isValidPtr(const TSD3D11Texture self) {
		return (self && ((D3D11Texture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Texture_isOwnerPtr(const TSD3D11Texture self) {
		return (self && ((D3D11Texture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Texture_isConstPtr(const TSD3D11Texture self) {
		return (self && ((D3D11Texture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Texture_getCountPtr(const TSD3D11Texture self) {
		return ((D3D11Texture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Texture_getInternalPtr(const TSD3D11Texture self) {
		return ((D3D11Texture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Texture_equalTexturePtr(const TSD3D11Texture self, const TSTexture base) {
		return (self && base && ((D3D11Texture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSD3D11Texture TS_CCALL tsD3D11Texture_castTexturePtr(TSTexture base) {
		return (TSD3D11Texture)(new D3D11Texture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsD3D11Texture_baseTexturePtr(TSD3D11Texture self) {
		return (TSTexture)(new Texture(((D3D11Texture*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Texture_create(TSD3D11Texture self, TS_TextureType type, ID3D11Texture2D *texture, TS_TextureFlags flags, TS_Format format) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->create((Texture::Type)type, texture, (Texture::Flags)flags, (Format)format);
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Texture_getDXGIFormat(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getDXGIFormat();
	}
	TS_CAPI ID3D11Texture2D* TS_CCALL tsD3D11Texture_getD3D11Texture(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getD3D11Texture();
	}
	TS_CAPI ID3D11ShaderResourceView* TS_CCALL tsD3D11Texture_getShaderResourceView(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getShaderResourceView();
	}
	TS_CAPI ID3D11RenderTargetView* TS_CCALL tsD3D11Texture_getRenderTargetView(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getRenderTargetView();
	}
	TS_CAPI ID3D11DepthStencilView* TS_CCALL tsD3D11Texture_getDepthStencilView(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getDepthStencilView();
	}
	TS_CAPI ID3D11UnorderedAccessView* TS_CCALL tsD3D11Texture_getUnorderedAccessView(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getUnorderedAccessView();
	}
	TS_CAPI void* TS_CCALL tsD3D11Texture_getInteropHandle(TSD3D11Texture self) {
		TS_ASSERT(self);
		return ((D3D11Texture*)self)->getInteropHandle();
	}
	
	// Tellusim::MTLTexture
	TS_CAPI TSMTLTexture TS_CCALL tsMTLTexture_new(void) {
		MTLTexture *ret = new MTLTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTexture)ret;
	}
	TS_CAPI void TS_CCALL tsMTLTexture_delete(TSMTLTexture self) {
		if(self) delete (MTLTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLTexture_equalPtr(const TSMTLTexture self, const TSMTLTexture ptr) {
		return (self && ptr && ((MTLTexture*)self)->operator==(*(MTLTexture*)ptr));
	}
	TS_CAPI TSMTLTexture TS_CCALL tsMTLTexture_copyPtr(TSMTLTexture self) {
		MTLTexture *ret = nullptr;
		if(self) ret = new MTLTexture(*(MTLTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTexture)ret;
	}
	TS_CAPI TSMTLTexture TS_CCALL tsMTLTexture_clonePtr(const TSMTLTexture self) {
		MTLTexture *ret = (self) ? new MTLTexture(((MTLTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTexture)ret;
	}
	TS_CAPI void TS_CCALL tsMTLTexture_clearPtr(TSMTLTexture self) {
		if(self) ((MTLTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLTexture_destroyPtr(TSMTLTexture self) {
		if(self) ((MTLTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLTexture_acquirePtr(TSMTLTexture self) {
		if(self) ((MTLTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLTexture_unacquirePtr(TSMTLTexture self) {
		if(self) ((MTLTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLTexture_isValidPtr(const TSMTLTexture self) {
		return (self && ((MTLTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLTexture_isOwnerPtr(const TSMTLTexture self) {
		return (self && ((MTLTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLTexture_isConstPtr(const TSMTLTexture self) {
		return (self && ((MTLTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLTexture_getCountPtr(const TSMTLTexture self) {
		return ((MTLTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLTexture_getInternalPtr(const TSMTLTexture self) {
		return ((MTLTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLTexture_equalTexturePtr(const TSMTLTexture self, const TSTexture base) {
		return (self && base && ((MTLTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSMTLTexture TS_CCALL tsMTLTexture_castTexturePtr(TSTexture base) {
		return (TSMTLTexture)(new MTLTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsMTLTexture_baseTexturePtr(TSMTLTexture self) {
		return (TSTexture)(new Texture(((MTLTexture*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsMTLTexture_create(TSMTLTexture self, void *texture, TS_TextureFlags flags, TS_Format format) {
		TS_ASSERT(self);
		return ((MTLTexture*)self)->create(texture, (Texture::Flags)flags, (Format)format);
	}
	TS_CAPI uint32_t TS_CCALL tsMTLTexture_getPixelFormat(TSMTLTexture self) {
		TS_ASSERT(self);
		return ((MTLTexture*)self)->getPixelFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsMTLTexture_getTextureType(TSMTLTexture self) {
		TS_ASSERT(self);
		return ((MTLTexture*)self)->getTextureType();
	}
	TS_CAPI void* TS_CCALL tsMTLTexture_getMTLTexture(TSMTLTexture self) {
		TS_ASSERT(self);
		return ((MTLTexture*)self)->getMTLTexture();
	}
	TS_CAPI void* TS_CCALL tsMTLTexture_getMTLBuffer(TSMTLTexture self) {
		TS_ASSERT(self);
		return ((MTLTexture*)self)->getMTLBuffer();
	}
	TS_CAPI void* TS_CCALL tsMTLTexture_getSharedPtr(TSMTLTexture self) {
		TS_ASSERT(self);
		return ((MTLTexture*)self)->getSharedPtr();
	}
	
	// Tellusim::VKTexture
	TS_CAPI TSVKTexture TS_CCALL tsVKTexture_new(void) {
		VKTexture *ret = new VKTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTexture)ret;
	}
	TS_CAPI void TS_CCALL tsVKTexture_delete(TSVKTexture self) {
		if(self) delete (VKTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKTexture_equalPtr(const TSVKTexture self, const TSVKTexture ptr) {
		return (self && ptr && ((VKTexture*)self)->operator==(*(VKTexture*)ptr));
	}
	TS_CAPI TSVKTexture TS_CCALL tsVKTexture_copyPtr(TSVKTexture self) {
		VKTexture *ret = nullptr;
		if(self) ret = new VKTexture(*(VKTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTexture)ret;
	}
	TS_CAPI TSVKTexture TS_CCALL tsVKTexture_clonePtr(const TSVKTexture self) {
		VKTexture *ret = (self) ? new VKTexture(((VKTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTexture)ret;
	}
	TS_CAPI void TS_CCALL tsVKTexture_clearPtr(TSVKTexture self) {
		if(self) ((VKTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKTexture_destroyPtr(TSVKTexture self) {
		if(self) ((VKTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKTexture_acquirePtr(TSVKTexture self) {
		if(self) ((VKTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKTexture_unacquirePtr(TSVKTexture self) {
		if(self) ((VKTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKTexture_isValidPtr(const TSVKTexture self) {
		return (self && ((VKTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKTexture_isOwnerPtr(const TSVKTexture self) {
		return (self && ((VKTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKTexture_isConstPtr(const TSVKTexture self) {
		return (self && ((VKTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKTexture_getCountPtr(const TSVKTexture self) {
		return ((VKTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKTexture_getInternalPtr(const TSVKTexture self) {
		return ((VKTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKTexture_equalTexturePtr(const TSVKTexture self, const TSTexture base) {
		return (self && base && ((VKTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSVKTexture TS_CCALL tsVKTexture_castTexturePtr(TSTexture base) {
		return (TSVKTexture)(new VKTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsVKTexture_baseTexturePtr(TSVKTexture self) {
		return (TSTexture)(new Texture(((VKTexture*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsVKTexture_create(TSVKTexture self, TS_TextureType type, uint32_t format, VkImage texture, uint32_t layout, TS_TextureFlags flags, TS_Format texture_format) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->create((Texture::Type)type, format, texture, layout, (Texture::Flags)flags, (Format)texture_format);
	}
	TS_CAPI uint32_t TS_CCALL tsVKTexture_getPixelFormat(TSVKTexture self) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->getPixelFormat();
	}
	TS_CAPI VkImage TS_CCALL tsVKTexture_getVKTexture(TSVKTexture self) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->getVKTexture();
	}
	TS_CAPI VkImageView TS_CCALL tsVKTexture_getTextureView(TSVKTexture self) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->getTextureView();
	}
	TS_CAPI void TS_CCALL tsVKTexture_setTextureLayout(TSVKTexture self, uint32_t layout) {
		TS_ASSERT(self);
		((VKTexture*)self)->setTextureLayout(layout);
	}
	TS_CAPI uint32_t TS_CCALL tsVKTexture_getTextureLayout(TSVKTexture self) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->getTextureLayout();
	}
	TS_CAPI void TS_CCALL tsVKTexture_getTextureRange(TSVKTexture self, void *range, const TSSlice *slice) {
		TS_ASSERT(self);
		((VKTexture*)self)->getTextureRange(range, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void* TS_CCALL tsVKTexture_getSharedPtr(TSVKTexture self) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->getSharedPtr();
	}
	TS_CAPI void* TS_CCALL tsVKTexture_getInteropHandle(TSVKTexture self) {
		TS_ASSERT(self);
		return ((VKTexture*)self)->getInteropHandle();
	}
	
	// Tellusim::GLTexture
	TS_CAPI TSGLTexture TS_CCALL tsGLTexture_new(void) {
		GLTexture *ret = new GLTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLTexture)ret;
	}
	TS_CAPI void TS_CCALL tsGLTexture_delete(TSGLTexture self) {
		if(self) delete (GLTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLTexture_equalPtr(const TSGLTexture self, const TSGLTexture ptr) {
		return (self && ptr && ((GLTexture*)self)->operator==(*(GLTexture*)ptr));
	}
	TS_CAPI TSGLTexture TS_CCALL tsGLTexture_copyPtr(TSGLTexture self) {
		GLTexture *ret = nullptr;
		if(self) ret = new GLTexture(*(GLTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLTexture)ret;
	}
	TS_CAPI TSGLTexture TS_CCALL tsGLTexture_clonePtr(const TSGLTexture self) {
		GLTexture *ret = (self) ? new GLTexture(((GLTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLTexture)ret;
	}
	TS_CAPI void TS_CCALL tsGLTexture_clearPtr(TSGLTexture self) {
		if(self) ((GLTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLTexture_destroyPtr(TSGLTexture self) {
		if(self) ((GLTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLTexture_acquirePtr(TSGLTexture self) {
		if(self) ((GLTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLTexture_unacquirePtr(TSGLTexture self) {
		if(self) ((GLTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLTexture_isValidPtr(const TSGLTexture self) {
		return (self && ((GLTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLTexture_isOwnerPtr(const TSGLTexture self) {
		return (self && ((GLTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLTexture_isConstPtr(const TSGLTexture self) {
		return (self && ((GLTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLTexture_getCountPtr(const TSGLTexture self) {
		return ((GLTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLTexture_getInternalPtr(const TSGLTexture self) {
		return ((GLTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLTexture_equalTexturePtr(const TSGLTexture self, const TSTexture base) {
		return (self && base && ((GLTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSGLTexture TS_CCALL tsGLTexture_castTexturePtr(TSTexture base) {
		return (TSGLTexture)(new GLTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsGLTexture_baseTexturePtr(TSGLTexture self) {
		return (TSTexture)(new Texture(((GLTexture*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsGLTexture_create(TSGLTexture self, uint32_t target, uint32_t texture_id, TS_TextureFlags flags, TS_Format format) {
		TS_ASSERT(self);
		return ((GLTexture*)self)->create(target, texture_id, (Texture::Flags)flags, (Format)format);
	}
	TS_CAPI uint32_t TS_CCALL tsGLTexture_getTarget(TSGLTexture self) {
		TS_ASSERT(self);
		return ((GLTexture*)self)->getTarget();
	}
	TS_CAPI uint32_t TS_CCALL tsGLTexture_getInternalFormat(TSGLTexture self) {
		TS_ASSERT(self);
		return ((GLTexture*)self)->getInternalFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsGLTexture_getTextureID(TSGLTexture self) {
		TS_ASSERT(self);
		return ((GLTexture*)self)->getTextureID();
	}
	
	// Tellusim::GLESTexture
	TS_CAPI TSGLESTexture TS_CCALL tsGLESTexture_new(void) {
		GLESTexture *ret = new GLESTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESTexture)ret;
	}
	TS_CAPI void TS_CCALL tsGLESTexture_delete(TSGLESTexture self) {
		if(self) delete (GLESTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLESTexture_equalPtr(const TSGLESTexture self, const TSGLESTexture ptr) {
		return (self && ptr && ((GLESTexture*)self)->operator==(*(GLESTexture*)ptr));
	}
	TS_CAPI TSGLESTexture TS_CCALL tsGLESTexture_copyPtr(TSGLESTexture self) {
		GLESTexture *ret = nullptr;
		if(self) ret = new GLESTexture(*(GLESTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESTexture)ret;
	}
	TS_CAPI TSGLESTexture TS_CCALL tsGLESTexture_clonePtr(const TSGLESTexture self) {
		GLESTexture *ret = (self) ? new GLESTexture(((GLESTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESTexture)ret;
	}
	TS_CAPI void TS_CCALL tsGLESTexture_clearPtr(TSGLESTexture self) {
		if(self) ((GLESTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLESTexture_destroyPtr(TSGLESTexture self) {
		if(self) ((GLESTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLESTexture_acquirePtr(TSGLESTexture self) {
		if(self) ((GLESTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLESTexture_unacquirePtr(TSGLESTexture self) {
		if(self) ((GLESTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESTexture_isValidPtr(const TSGLESTexture self) {
		return (self && ((GLESTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESTexture_isOwnerPtr(const TSGLESTexture self) {
		return (self && ((GLESTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESTexture_isConstPtr(const TSGLESTexture self) {
		return (self && ((GLESTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLESTexture_getCountPtr(const TSGLESTexture self) {
		return ((GLESTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLESTexture_getInternalPtr(const TSGLESTexture self) {
		return ((GLESTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESTexture_equalTexturePtr(const TSGLESTexture self, const TSTexture base) {
		return (self && base && ((GLESTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSGLESTexture TS_CCALL tsGLESTexture_castTexturePtr(TSTexture base) {
		return (TSGLESTexture)(new GLESTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsGLESTexture_baseTexturePtr(TSGLESTexture self) {
		return (TSTexture)(new Texture(((GLESTexture*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsGLESTexture_create(TSGLESTexture self, uint32_t target, uint32_t texture_id, TS_TextureFlags flags, TS_Format format) {
		TS_ASSERT(self);
		return ((GLESTexture*)self)->create(target, texture_id, (Texture::Flags)flags, (Format)format);
	}
	TS_CAPI uint32_t TS_CCALL tsGLESTexture_getTarget(TSGLESTexture self) {
		TS_ASSERT(self);
		return ((GLESTexture*)self)->getTarget();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESTexture_getInternalFormat(TSGLESTexture self) {
		TS_ASSERT(self);
		return ((GLESTexture*)self)->getInternalFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESTexture_getTextureID(TSGLESTexture self) {
		TS_ASSERT(self);
		return ((GLESTexture*)self)->getTextureID();
	}
	
	// Tellusim::CUTexture
	TS_CAPI TSCUTexture TS_CCALL tsCUTexture_new(void) {
		CUTexture *ret = new CUTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUTexture)ret;
	}
	TS_CAPI void TS_CCALL tsCUTexture_delete(TSCUTexture self) {
		if(self) delete (CUTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCUTexture_equalPtr(const TSCUTexture self, const TSCUTexture ptr) {
		return (self && ptr && ((CUTexture*)self)->operator==(*(CUTexture*)ptr));
	}
	TS_CAPI TSCUTexture TS_CCALL tsCUTexture_copyPtr(TSCUTexture self) {
		CUTexture *ret = nullptr;
		if(self) ret = new CUTexture(*(CUTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUTexture)ret;
	}
	TS_CAPI TSCUTexture TS_CCALL tsCUTexture_clonePtr(const TSCUTexture self) {
		CUTexture *ret = (self) ? new CUTexture(((CUTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCUTexture)ret;
	}
	TS_CAPI void TS_CCALL tsCUTexture_clearPtr(TSCUTexture self) {
		if(self) ((CUTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCUTexture_destroyPtr(TSCUTexture self) {
		if(self) ((CUTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCUTexture_acquirePtr(TSCUTexture self) {
		if(self) ((CUTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCUTexture_unacquirePtr(TSCUTexture self) {
		if(self) ((CUTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUTexture_isValidPtr(const TSCUTexture self) {
		return (self && ((CUTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUTexture_isOwnerPtr(const TSCUTexture self) {
		return (self && ((CUTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCUTexture_isConstPtr(const TSCUTexture self) {
		return (self && ((CUTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCUTexture_getCountPtr(const TSCUTexture self) {
		return ((CUTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCUTexture_getInternalPtr(const TSCUTexture self) {
		return ((CUTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCUTexture_equalTexturePtr(const TSCUTexture self, const TSTexture base) {
		return (self && base && ((CUTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSCUTexture TS_CCALL tsCUTexture_castTexturePtr(TSTexture base) {
		return (TSCUTexture)(new CUTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsCUTexture_baseTexturePtr(TSCUTexture self) {
		return (TSTexture)(new Texture(((CUTexture*)self)->getTexture()));
	}
	TS_CAPI CUarray TS_CCALL tsCUTexture_getTextureLevel(TSCUTexture self, uint32_t index) {
		TS_ASSERT(self);
		return ((CUTexture*)self)->getTextureLevel(index);
	}
	TS_CAPI uint32_t TS_CCALL tsCUTexture_getArrayFormat(TSCUTexture self) {
		TS_ASSERT(self);
		return ((CUTexture*)self)->getArrayFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsCUTexture_getArrayChannels(TSCUTexture self) {
		TS_ASSERT(self);
		return ((CUTexture*)self)->getArrayChannels();
	}
	TS_CAPI CUexternalMemory TS_CCALL tsCUTexture_getSharedMemory(TSCUTexture self) {
		TS_ASSERT(self);
		return ((CUTexture*)self)->getSharedMemory();
	}
	
	// Tellusim::HIPTexture
	TS_CAPI TSHIPTexture TS_CCALL tsHIPTexture_new(void) {
		HIPTexture *ret = new HIPTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPTexture)ret;
	}
	TS_CAPI void TS_CCALL tsHIPTexture_delete(TSHIPTexture self) {
		if(self) delete (HIPTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsHIPTexture_equalPtr(const TSHIPTexture self, const TSHIPTexture ptr) {
		return (self && ptr && ((HIPTexture*)self)->operator==(*(HIPTexture*)ptr));
	}
	TS_CAPI TSHIPTexture TS_CCALL tsHIPTexture_copyPtr(TSHIPTexture self) {
		HIPTexture *ret = nullptr;
		if(self) ret = new HIPTexture(*(HIPTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPTexture)ret;
	}
	TS_CAPI TSHIPTexture TS_CCALL tsHIPTexture_clonePtr(const TSHIPTexture self) {
		HIPTexture *ret = (self) ? new HIPTexture(((HIPTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSHIPTexture)ret;
	}
	TS_CAPI void TS_CCALL tsHIPTexture_clearPtr(TSHIPTexture self) {
		if(self) ((HIPTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsHIPTexture_destroyPtr(TSHIPTexture self) {
		if(self) ((HIPTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsHIPTexture_acquirePtr(TSHIPTexture self) {
		if(self) ((HIPTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsHIPTexture_unacquirePtr(TSHIPTexture self) {
		if(self) ((HIPTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPTexture_isValidPtr(const TSHIPTexture self) {
		return (self && ((HIPTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPTexture_isOwnerPtr(const TSHIPTexture self) {
		return (self && ((HIPTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsHIPTexture_isConstPtr(const TSHIPTexture self) {
		return (self && ((HIPTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsHIPTexture_getCountPtr(const TSHIPTexture self) {
		return ((HIPTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsHIPTexture_getInternalPtr(const TSHIPTexture self) {
		return ((HIPTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsHIPTexture_equalTexturePtr(const TSHIPTexture self, const TSTexture base) {
		return (self && base && ((HIPTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSHIPTexture TS_CCALL tsHIPTexture_castTexturePtr(TSTexture base) {
		return (TSHIPTexture)(new HIPTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsHIPTexture_baseTexturePtr(TSHIPTexture self) {
		return (TSTexture)(new Texture(((HIPTexture*)self)->getTexture()));
	}
	TS_CAPI void* TS_CCALL tsHIPTexture_getTextureArray(TSHIPTexture self) {
		TS_ASSERT(self);
		return ((HIPTexture*)self)->getTextureArray();
	}
	TS_CAPI void* TS_CCALL tsHIPTexture_getTextureLevel(TSHIPTexture self, uint32_t index) {
		TS_ASSERT(self);
		return ((HIPTexture*)self)->getTextureLevel(index);
	}
	TS_CAPI uint32_t TS_CCALL tsHIPTexture_getArrayFormat(TSHIPTexture self) {
		TS_ASSERT(self);
		return ((HIPTexture*)self)->getArrayFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsHIPTexture_getArrayChannels(TSHIPTexture self) {
		TS_ASSERT(self);
		return ((HIPTexture*)self)->getArrayChannels();
	}
	TS_CAPI void* TS_CCALL tsHIPTexture_getSharedMemory(TSHIPTexture self) {
		TS_ASSERT(self);
		return ((HIPTexture*)self)->getSharedMemory();
	}
	
	// Tellusim::FUTexture
	TS_CAPI TSFUTexture TS_CCALL tsFUTexture_new(void) {
		FUTexture *ret = new FUTexture();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTexture)ret;
	}
	TS_CAPI TSFUTexture TS_CCALL tsFUTexture_new_cATb(const TSTexture *textures, uint32_t textures_size, bool_t owner) {
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		FUTexture *ret = new FUTexture(textures_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTexture)ret;
	}
	TS_CAPI void TS_CCALL tsFUTexture_delete(TSFUTexture self) {
		if(self) delete (FUTexture*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUTexture_equalPtr(const TSFUTexture self, const TSFUTexture ptr) {
		return (self && ptr && ((FUTexture*)self)->operator==(*(FUTexture*)ptr));
	}
	TS_CAPI TSFUTexture TS_CCALL tsFUTexture_copyPtr(TSFUTexture self) {
		FUTexture *ret = nullptr;
		if(self) ret = new FUTexture(*(FUTexture*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTexture)ret;
	}
	TS_CAPI TSFUTexture TS_CCALL tsFUTexture_clonePtr(const TSFUTexture self) {
		FUTexture *ret = (self) ? new FUTexture(((FUTexture*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTexture)ret;
	}
	TS_CAPI void TS_CCALL tsFUTexture_clearPtr(TSFUTexture self) {
		if(self) ((FUTexture*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUTexture_destroyPtr(TSFUTexture self) {
		if(self) ((FUTexture*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUTexture_acquirePtr(TSFUTexture self) {
		if(self) ((FUTexture*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUTexture_unacquirePtr(TSFUTexture self) {
		if(self) ((FUTexture*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTexture_isValidPtr(const TSFUTexture self) {
		return (self && ((FUTexture*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTexture_isOwnerPtr(const TSFUTexture self) {
		return (self && ((FUTexture*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTexture_isConstPtr(const TSFUTexture self) {
		return (self && ((FUTexture*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUTexture_getCountPtr(const TSFUTexture self) {
		return ((FUTexture*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUTexture_getInternalPtr(const TSFUTexture self) {
		return ((FUTexture*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTexture_equalTexturePtr(const TSFUTexture self, const TSTexture base) {
		return (self && base && ((FUTexture*)self)->operator==(*(Texture*)base));
	}
	TS_CAPI TSFUTexture TS_CCALL tsFUTexture_castTexturePtr(TSTexture base) {
		return (TSFUTexture)(new FUTexture(*(Texture*)base));
	}
	TS_CAPI TSTexture TS_CCALL tsFUTexture_baseTexturePtr(TSFUTexture self) {
		return (TSTexture)(new Texture(((FUTexture*)self)->getTexture()));
	}
	TS_CAPI void TS_CCALL tsFUTexture_setMask(TSFUTexture self, uint32_t mask) {
		TS_ASSERT(self);
		((FUTexture*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUTexture_getMask(TSFUTexture self) {
		TS_ASSERT(self);
		return ((FUTexture*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUTexture_getNumTextures(TSFUTexture self) {
		TS_ASSERT(self);
		return ((FUTexture*)self)->getNumTextures();
	}
	TS_CAPI TSTexture TS_CCALL tsFUTexture_getTexture_cu(TSFUTexture self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((FUTexture*)self)->getTexture(index)));
	}
	TS_CAPI TSTexture TS_CCALL tsFUTexture_getTexture_u(TSFUTexture self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((FUTexture*)self)->getTexture(index)));
	}
	
	// Tellusim::Tracing
	TS_CAPI TSTracing TS_CCALL tsTracing_new(void) {
		Tracing *ret = new Tracing();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTracing)ret;
	}
	TS_CAPI void TS_CCALL tsTracing_delete(TSTracing self) {
		if(self) delete (Tracing*)self;
	}
	TS_CAPI bool_t TS_CCALL tsTracing_equalPtr(const TSTracing self, const TSTracing ptr) {
		return (self && ptr && ((Tracing*)self)->operator==(*(Tracing*)ptr));
	}
	TS_CAPI TSTracing TS_CCALL tsTracing_copyPtr(TSTracing self) {
		Tracing *ret = nullptr;
		if(self) ret = new Tracing(*(Tracing*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTracing)ret;
	}
	TS_CAPI TSTracing TS_CCALL tsTracing_clonePtr(const TSTracing self) {
		Tracing *ret = (self) ? new Tracing(((Tracing*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTracing)ret;
	}
	TS_CAPI void TS_CCALL tsTracing_clearPtr(TSTracing self) {
		if(self) ((Tracing*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsTracing_destroyPtr(TSTracing self) {
		if(self) ((Tracing*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsTracing_acquirePtr(TSTracing self) {
		if(self) ((Tracing*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsTracing_unacquirePtr(TSTracing self) {
		if(self) ((Tracing*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isValidPtr(const TSTracing self) {
		return (self && ((Tracing*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isOwnerPtr(const TSTracing self) {
		return (self && ((Tracing*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isConstPtr(const TSTracing self) {
		return (self && ((Tracing*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getCountPtr(const TSTracing self) {
		return ((Tracing*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsTracing_getInternalPtr(const TSTracing self) {
		return ((Tracing*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsTracing_getPlatform(TSTracing self) {
		TS_ASSERT(self);
		return (TS_Platform)((Tracing*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsTracing_getPlatformName(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getIndex(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsTracing_clear(TSTracing self) {
		TS_ASSERT(self);
		((Tracing*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isCreated(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isBuilt(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->isBuilt();
	}
	TS_CAPI void TS_CCALL tsTracing_setName(TSTracing self, const char *name) {
		TS_ASSERT(self);
		((Tracing*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsTracing_getName(TSTracing self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Tracing*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsTracing_create(TSTracing self, TS_TracingType type, TS_TracingFlags flags) {
		TS_ASSERT(self);
		return ((Tracing*)self)->create((Tracing::Type)type, (Tracing::Flags)flags);
	}
	TS_CAPI TS_TracingType TS_CCALL tsTracing_getType(TSTracing self) {
		TS_ASSERT(self);
		return (TS_TracingType)((Tracing*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsTracing_getTypeName_TT(TS_TracingType type) {
		return Tracing::getTypeName((Tracing::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsTracing_getTypeName_c(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isInstanceType(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->isInstanceType();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isTriangleType(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->isTriangleType();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isBoundType(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->isBoundType();
	}
	TS_CAPI bool_t TS_CCALL tsTracing_isGeometryType(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->isGeometryType();
	}
	TS_CAPI void TS_CCALL tsTracing_setParameters(TSTracing self, const TSTracing tracing) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		((Tracing*)self)->setParameters(*(const Tracing*)tracing);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getNumGeometries(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getNumGeometries();
	}
	TS_CAPI void TS_CCALL tsTracing_setInstanceBuffer_uBz(TSTracing self, uint32_t num_instances, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setInstanceBuffer(num_instances, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setInstanceBuffer_Bz(TSTracing self, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setInstanceBuffer(*(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setNumInstances(TSTracing self, uint32_t num_instances) {
		TS_ASSERT(self);
		((Tracing*)self)->setNumInstances(num_instances);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getNumInstances(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getNumInstances();
	}
	TS_CAPI TSBuffer TS_CCALL tsTracing_getInstanceBuffer(TSTracing self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Tracing*)self)->getInstanceBuffer()));
	}
	TS_CAPI size_t TS_CCALL tsTracing_getInstanceOffset(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getInstanceOffset();
	}
	TS_CAPI void TS_CCALL tsTracing_setIndirectBuffer(TSTracing self, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setIndirectBuffer(*(Buffer*)buffer, offset);
	}
	TS_CAPI TSBuffer TS_CCALL tsTracing_getIndirectBuffer(TSTracing self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Tracing*)self)->getIndirectBuffer()));
	}
	TS_CAPI size_t TS_CCALL tsTracing_getIndirectOffset(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getIndirectOffset();
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_addVertexBuffer(TSTracing self, uint32_t num_vertices, TS_Format format, size_t stride, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Tracing*)self)->addVertexBuffer(num_vertices, (Format)format, stride, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setVertexBuffer_uuBz(TSTracing self, uint32_t index, uint32_t num_vertices, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setVertexBuffer(index, num_vertices, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setVertexBuffer_uBz(TSTracing self, uint32_t index, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setVertexBuffer(index, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setNumVertices(TSTracing self, uint32_t index, uint32_t num_vertices) {
		TS_ASSERT(self);
		((Tracing*)self)->setNumVertices(index, num_vertices);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getNumVertices(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getNumVertices(index);
	}
	TS_CAPI TS_Format TS_CCALL tsTracing_getVertexFormat(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_Format)((Tracing*)self)->getVertexFormat(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getVertexStride(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getVertexStride(index);
	}
	TS_CAPI TSBuffer TS_CCALL tsTracing_getVertexBuffer(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Tracing*)self)->getVertexBuffer(index)));
	}
	TS_CAPI size_t TS_CCALL tsTracing_getVertexOffset(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getVertexOffset(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_addIndexBuffer(TSTracing self, uint32_t num_indices, TS_Format format, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Tracing*)self)->addIndexBuffer(num_indices, (Format)format, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setIndexBuffer_uuBz(TSTracing self, uint32_t index, uint32_t num_indices, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setIndexBuffer(index, num_indices, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setIndexBuffer_uBz(TSTracing self, uint32_t index, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setIndexBuffer(index, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setNumIndices(TSTracing self, uint32_t index, uint32_t num_indices) {
		TS_ASSERT(self);
		((Tracing*)self)->setNumIndices(index, num_indices);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getNumIndices(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getNumIndices(index);
	}
	TS_CAPI TS_Format TS_CCALL tsTracing_getIndexFormat(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_Format)((Tracing*)self)->getIndexFormat(index);
	}
	TS_CAPI TSBuffer TS_CCALL tsTracing_getIndexBuffer(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Tracing*)self)->getIndexBuffer(index)));
	}
	TS_CAPI size_t TS_CCALL tsTracing_getIndexOffset(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getIndexOffset(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_addBoundBuffer(TSTracing self, uint32_t num_bounds, size_t stride, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Tracing*)self)->addBoundBuffer(num_bounds, stride, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setBoundBuffer_uuBz(TSTracing self, uint32_t index, uint32_t num_bounds, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setBoundBuffer(index, num_bounds, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setBoundBuffer_uBz(TSTracing self, uint32_t index, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Tracing*)self)->setBoundBuffer(index, *(Buffer*)buffer, offset);
	}
	TS_CAPI void TS_CCALL tsTracing_setNumBounds(TSTracing self, uint32_t index, uint32_t num_bounds) {
		TS_ASSERT(self);
		((Tracing*)self)->setNumBounds(index, num_bounds);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getNumBounds(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getNumBounds(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTracing_getBoundStride(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getBoundStride(index);
	}
	TS_CAPI TSBuffer TS_CCALL tsTracing_getBoundBuffer(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Tracing*)self)->getBoundBuffer(index)));
	}
	TS_CAPI size_t TS_CCALL tsTracing_getBoundOffset(TSTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getBoundOffset(index);
	}
	TS_CAPI TSString TS_CCALL tsTracing_getDescription(TSTracing self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Tracing*)self)->getDescription()));
	}
	TS_CAPI uint64_t TS_CCALL tsTracing_getTracingAddress(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getTracingAddress();
	}
	TS_CAPI size_t TS_CCALL tsTracing_getBuildSize(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getBuildSize();
	}
	TS_CAPI size_t TS_CCALL tsTracing_getUpdateSize(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getUpdateSize();
	}
	TS_CAPI size_t TS_CCALL tsTracing_getMemory(TSTracing self) {
		TS_ASSERT(self);
		return ((Tracing*)self)->getMemory();
	}
	
	// Tellusim::D3D12Tracing
	TS_CAPI TSD3D12Tracing TS_CCALL tsD3D12Tracing_new(void) {
		D3D12Tracing *ret = new D3D12Tracing();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Tracing)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Tracing_delete(TSD3D12Tracing self) {
		if(self) delete (D3D12Tracing*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Tracing_equalPtr(const TSD3D12Tracing self, const TSD3D12Tracing ptr) {
		return (self && ptr && ((D3D12Tracing*)self)->operator==(*(D3D12Tracing*)ptr));
	}
	TS_CAPI TSD3D12Tracing TS_CCALL tsD3D12Tracing_copyPtr(TSD3D12Tracing self) {
		D3D12Tracing *ret = nullptr;
		if(self) ret = new D3D12Tracing(*(D3D12Tracing*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Tracing)ret;
	}
	TS_CAPI TSD3D12Tracing TS_CCALL tsD3D12Tracing_clonePtr(const TSD3D12Tracing self) {
		D3D12Tracing *ret = (self) ? new D3D12Tracing(((D3D12Tracing*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Tracing)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Tracing_clearPtr(TSD3D12Tracing self) {
		if(self) ((D3D12Tracing*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Tracing_destroyPtr(TSD3D12Tracing self) {
		if(self) ((D3D12Tracing*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Tracing_acquirePtr(TSD3D12Tracing self) {
		if(self) ((D3D12Tracing*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Tracing_unacquirePtr(TSD3D12Tracing self) {
		if(self) ((D3D12Tracing*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Tracing_isValidPtr(const TSD3D12Tracing self) {
		return (self && ((D3D12Tracing*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Tracing_isOwnerPtr(const TSD3D12Tracing self) {
		return (self && ((D3D12Tracing*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Tracing_isConstPtr(const TSD3D12Tracing self) {
		return (self && ((D3D12Tracing*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Tracing_getCountPtr(const TSD3D12Tracing self) {
		return ((D3D12Tracing*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Tracing_getInternalPtr(const TSD3D12Tracing self) {
		return ((D3D12Tracing*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Tracing_equalTracingPtr(const TSD3D12Tracing self, const TSTracing base) {
		return (self && base && ((D3D12Tracing*)self)->operator==(*(Tracing*)base));
	}
	TS_CAPI TSD3D12Tracing TS_CCALL tsD3D12Tracing_castTracingPtr(TSTracing base) {
		return (TSD3D12Tracing)(new D3D12Tracing(*(Tracing*)base));
	}
	TS_CAPI TSTracing TS_CCALL tsD3D12Tracing_baseTracingPtr(TSD3D12Tracing self) {
		return (TSTracing)(new Tracing(((D3D12Tracing*)self)->getTracing()));
	}
	TS_CAPI void* TS_CCALL tsD3D12Tracing_getGeometryDesc(TSD3D12Tracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((D3D12Tracing*)self)->getGeometryDesc(index);
	}
	TS_CAPI void* TS_CCALL tsD3D12Tracing_getBuildInputs(TSD3D12Tracing self) {
		TS_ASSERT(self);
		return ((D3D12Tracing*)self)->getBuildInputs();
	}
	TS_CAPI void* TS_CCALL tsD3D12Tracing_getPrebuildInfo(TSD3D12Tracing self) {
		TS_ASSERT(self);
		return ((D3D12Tracing*)self)->getPrebuildInfo();
	}
	TS_CAPI void* TS_CCALL tsD3D12Tracing_getBuildDesc(TSD3D12Tracing self) {
		TS_ASSERT(self);
		return ((D3D12Tracing*)self)->getBuildDesc();
	}
	TS_CAPI TSBuffer TS_CCALL tsD3D12Tracing_getTracingBuffer(TSD3D12Tracing self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((D3D12Tracing*)self)->getTracingBuffer()));
	}
	TS_CAPI size_t TS_CCALL tsD3D12Tracing_getShaderResourceView(TSD3D12Tracing self) {
		TS_ASSERT(self);
		return ((D3D12Tracing*)self)->getShaderResourceView();
	}
	
	// Tellusim::MTLTracing
	TS_CAPI TSMTLTracing TS_CCALL tsMTLTracing_new(void) {
		MTLTracing *ret = new MTLTracing();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTracing)ret;
	}
	TS_CAPI void TS_CCALL tsMTLTracing_delete(TSMTLTracing self) {
		if(self) delete (MTLTracing*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLTracing_equalPtr(const TSMTLTracing self, const TSMTLTracing ptr) {
		return (self && ptr && ((MTLTracing*)self)->operator==(*(MTLTracing*)ptr));
	}
	TS_CAPI TSMTLTracing TS_CCALL tsMTLTracing_copyPtr(TSMTLTracing self) {
		MTLTracing *ret = nullptr;
		if(self) ret = new MTLTracing(*(MTLTracing*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTracing)ret;
	}
	TS_CAPI TSMTLTracing TS_CCALL tsMTLTracing_clonePtr(const TSMTLTracing self) {
		MTLTracing *ret = (self) ? new MTLTracing(((MTLTracing*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTracing)ret;
	}
	TS_CAPI void TS_CCALL tsMTLTracing_clearPtr(TSMTLTracing self) {
		if(self) ((MTLTracing*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLTracing_destroyPtr(TSMTLTracing self) {
		if(self) ((MTLTracing*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLTracing_acquirePtr(TSMTLTracing self) {
		if(self) ((MTLTracing*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLTracing_unacquirePtr(TSMTLTracing self) {
		if(self) ((MTLTracing*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLTracing_isValidPtr(const TSMTLTracing self) {
		return (self && ((MTLTracing*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLTracing_isOwnerPtr(const TSMTLTracing self) {
		return (self && ((MTLTracing*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLTracing_isConstPtr(const TSMTLTracing self) {
		return (self && ((MTLTracing*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLTracing_getCountPtr(const TSMTLTracing self) {
		return ((MTLTracing*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLTracing_getInternalPtr(const TSMTLTracing self) {
		return ((MTLTracing*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLTracing_equalTracingPtr(const TSMTLTracing self, const TSTracing base) {
		return (self && base && ((MTLTracing*)self)->operator==(*(Tracing*)base));
	}
	TS_CAPI TSMTLTracing TS_CCALL tsMTLTracing_castTracingPtr(TSTracing base) {
		return (TSMTLTracing)(new MTLTracing(*(Tracing*)base));
	}
	TS_CAPI TSTracing TS_CCALL tsMTLTracing_baseTracingPtr(TSMTLTracing self) {
		return (TSTracing)(new Tracing(((MTLTracing*)self)->getTracing()));
	}
	TS_CAPI void* TS_CCALL tsMTLTracing_getGeometryDesc(TSMTLTracing self, uint32_t index) {
		TS_ASSERT(self);
		return ((MTLTracing*)self)->getGeometryDesc(index);
	}
	TS_CAPI void* TS_CCALL tsMTLTracing_getPrimitiveDesc(TSMTLTracing self) {
		TS_ASSERT(self);
		return ((MTLTracing*)self)->getPrimitiveDesc();
	}
	TS_CAPI void* TS_CCALL tsMTLTracing_getInstanceDesc(TSMTLTracing self) {
		TS_ASSERT(self);
		return ((MTLTracing*)self)->getInstanceDesc();
	}
	TS_CAPI void* TS_CCALL tsMTLTracing_getAccelerationStructure(TSMTLTracing self) {
		TS_ASSERT(self);
		return ((MTLTracing*)self)->getAccelerationStructure();
	}
	
	// Tellusim::VKTracing
	TS_CAPI TSVKTracing TS_CCALL tsVKTracing_new(void) {
		VKTracing *ret = new VKTracing();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTracing)ret;
	}
	TS_CAPI void TS_CCALL tsVKTracing_delete(TSVKTracing self) {
		if(self) delete (VKTracing*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKTracing_equalPtr(const TSVKTracing self, const TSVKTracing ptr) {
		return (self && ptr && ((VKTracing*)self)->operator==(*(VKTracing*)ptr));
	}
	TS_CAPI TSVKTracing TS_CCALL tsVKTracing_copyPtr(TSVKTracing self) {
		VKTracing *ret = nullptr;
		if(self) ret = new VKTracing(*(VKTracing*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTracing)ret;
	}
	TS_CAPI TSVKTracing TS_CCALL tsVKTracing_clonePtr(const TSVKTracing self) {
		VKTracing *ret = (self) ? new VKTracing(((VKTracing*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTracing)ret;
	}
	TS_CAPI void TS_CCALL tsVKTracing_clearPtr(TSVKTracing self) {
		if(self) ((VKTracing*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKTracing_destroyPtr(TSVKTracing self) {
		if(self) ((VKTracing*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKTracing_acquirePtr(TSVKTracing self) {
		if(self) ((VKTracing*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKTracing_unacquirePtr(TSVKTracing self) {
		if(self) ((VKTracing*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKTracing_isValidPtr(const TSVKTracing self) {
		return (self && ((VKTracing*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKTracing_isOwnerPtr(const TSVKTracing self) {
		return (self && ((VKTracing*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKTracing_isConstPtr(const TSVKTracing self) {
		return (self && ((VKTracing*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKTracing_getCountPtr(const TSVKTracing self) {
		return ((VKTracing*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKTracing_getInternalPtr(const TSVKTracing self) {
		return ((VKTracing*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKTracing_equalTracingPtr(const TSVKTracing self, const TSTracing base) {
		return (self && base && ((VKTracing*)self)->operator==(*(Tracing*)base));
	}
	TS_CAPI TSVKTracing TS_CCALL tsVKTracing_castTracingPtr(TSTracing base) {
		return (TSVKTracing)(new VKTracing(*(Tracing*)base));
	}
	TS_CAPI TSTracing TS_CCALL tsVKTracing_baseTracingPtr(TSVKTracing self) {
		return (TSTracing)(new Tracing(((VKTracing*)self)->getTracing()));
	}
	TS_CAPI void* TS_CCALL tsVKTracing_getBuildGeometryInfo(TSVKTracing self) {
		TS_ASSERT(self);
		return ((VKTracing*)self)->getBuildGeometryInfo();
	}
	TS_CAPI void* TS_CCALL tsVKTracing_getBuildSizeInfo(TSVKTracing self) {
		TS_ASSERT(self);
		return ((VKTracing*)self)->getBuildSizeInfo();
	}
	TS_CAPI TSBuffer TS_CCALL tsVKTracing_getTracingBuffer(TSVKTracing self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((VKTracing*)self)->getTracingBuffer()));
	}
	TS_CAPI VkAccelerationStructureKHR TS_CCALL tsVKTracing_getAccelerationStructure(TSVKTracing self) {
		TS_ASSERT(self);
		return ((VKTracing*)self)->getAccelerationStructure();
	}
	
	// Tellusim::FUTracing
	TS_CAPI TSFUTracing TS_CCALL tsFUTracing_new(void) {
		FUTracing *ret = new FUTracing();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTracing)ret;
	}
	TS_CAPI TSFUTracing TS_CCALL tsFUTracing_new_cATb(const TSTracing *tracings, uint32_t tracings_size, bool_t owner) {
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		FUTracing *ret = new FUTracing(tracings_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTracing)ret;
	}
	TS_CAPI void TS_CCALL tsFUTracing_delete(TSFUTracing self) {
		if(self) delete (FUTracing*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUTracing_equalPtr(const TSFUTracing self, const TSFUTracing ptr) {
		return (self && ptr && ((FUTracing*)self)->operator==(*(FUTracing*)ptr));
	}
	TS_CAPI TSFUTracing TS_CCALL tsFUTracing_copyPtr(TSFUTracing self) {
		FUTracing *ret = nullptr;
		if(self) ret = new FUTracing(*(FUTracing*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTracing)ret;
	}
	TS_CAPI TSFUTracing TS_CCALL tsFUTracing_clonePtr(const TSFUTracing self) {
		FUTracing *ret = (self) ? new FUTracing(((FUTracing*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTracing)ret;
	}
	TS_CAPI void TS_CCALL tsFUTracing_clearPtr(TSFUTracing self) {
		if(self) ((FUTracing*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUTracing_destroyPtr(TSFUTracing self) {
		if(self) ((FUTracing*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUTracing_acquirePtr(TSFUTracing self) {
		if(self) ((FUTracing*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUTracing_unacquirePtr(TSFUTracing self) {
		if(self) ((FUTracing*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTracing_isValidPtr(const TSFUTracing self) {
		return (self && ((FUTracing*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTracing_isOwnerPtr(const TSFUTracing self) {
		return (self && ((FUTracing*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTracing_isConstPtr(const TSFUTracing self) {
		return (self && ((FUTracing*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUTracing_getCountPtr(const TSFUTracing self) {
		return ((FUTracing*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUTracing_getInternalPtr(const TSFUTracing self) {
		return ((FUTracing*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTracing_equalTracingPtr(const TSFUTracing self, const TSTracing base) {
		return (self && base && ((FUTracing*)self)->operator==(*(Tracing*)base));
	}
	TS_CAPI TSFUTracing TS_CCALL tsFUTracing_castTracingPtr(TSTracing base) {
		return (TSFUTracing)(new FUTracing(*(Tracing*)base));
	}
	TS_CAPI TSTracing TS_CCALL tsFUTracing_baseTracingPtr(TSFUTracing self) {
		return (TSTracing)(new Tracing(((FUTracing*)self)->getTracing()));
	}
	TS_CAPI void TS_CCALL tsFUTracing_setMask(TSFUTracing self, uint32_t mask) {
		TS_ASSERT(self);
		((FUTracing*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUTracing_getMask(TSFUTracing self) {
		TS_ASSERT(self);
		return ((FUTracing*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUTracing_getNumTracings(TSFUTracing self) {
		TS_ASSERT(self);
		return ((FUTracing*)self)->getNumTracings();
	}
	TS_CAPI TSTracing TS_CCALL tsFUTracing_getTracing_cu(TSFUTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTracing)(new Tracing(((FUTracing*)self)->getTracing(index)));
	}
	TS_CAPI TSTracing TS_CCALL tsFUTracing_getTracing_u(TSFUTracing self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTracing)(new Tracing(((FUTracing*)self)->getTracing(index)));
	}
	
	// Tellusim::Target
	TS_CAPI TSTarget TS_CCALL tsTarget_new(void) {
		Target *ret = new Target();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTarget)ret;
	}
	TS_CAPI void TS_CCALL tsTarget_delete(TSTarget self) {
		if(self) delete (Target*)self;
	}
	TS_CAPI bool_t TS_CCALL tsTarget_equalPtr(const TSTarget self, const TSTarget ptr) {
		return (self && ptr && ((Target*)self)->operator==(*(Target*)ptr));
	}
	TS_CAPI TSTarget TS_CCALL tsTarget_copyPtr(TSTarget self) {
		Target *ret = nullptr;
		if(self) ret = new Target(*(Target*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTarget)ret;
	}
	TS_CAPI TSTarget TS_CCALL tsTarget_clonePtr(const TSTarget self) {
		Target *ret = (self) ? new Target(((Target*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTarget)ret;
	}
	TS_CAPI void TS_CCALL tsTarget_clearPtr(TSTarget self) {
		if(self) ((Target*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsTarget_destroyPtr(TSTarget self) {
		if(self) ((Target*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsTarget_acquirePtr(TSTarget self) {
		if(self) ((Target*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsTarget_unacquirePtr(TSTarget self) {
		if(self) ((Target*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsTarget_isValidPtr(const TSTarget self) {
		return (self && ((Target*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTarget_isOwnerPtr(const TSTarget self) {
		return (self && ((Target*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTarget_isConstPtr(const TSTarget self) {
		return (self && ((Target*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getCountPtr(const TSTarget self) {
		return ((Target*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsTarget_getInternalPtr(const TSTarget self) {
		return ((Target*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsTarget_getPlatform(TSTarget self) {
		TS_ASSERT(self);
		return (TS_Platform)((Target*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsTarget_getPlatformName(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getIndex(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getIndex();
	}
	TS_CAPI bool_t TS_CCALL tsTarget_begin_F(TSTarget self, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(fence);
		return ((Target*)self)->begin(*(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsTarget_begin(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->begin();
	}
	TS_CAPI void TS_CCALL tsTarget_end_F(TSTarget self, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(fence);
		((Target*)self)->end(*(Fence*)fence);
	}
	TS_CAPI void TS_CCALL tsTarget_end(TSTarget self) {
		TS_ASSERT(self);
		((Target*)self)->end();
	}
	TS_CAPI void TS_CCALL tsTarget_swap(TSTarget self, TSSurface surface) {
		TS_ASSERT(self);
		TS_ASSERT(surface);
		((Target*)self)->swap(*(Surface*)surface);
	}
	TS_CAPI bool_t TS_CCALL tsTarget_isEnabled(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->isEnabled();
	}
	TS_CAPI TS_Format TS_CCALL tsTarget_getColorFormat(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_Format)((Target*)self)->getColorFormat(index);
	}
	TS_CAPI TS_Format TS_CCALL tsTarget_getDepthFormat(TSTarget self) {
		TS_ASSERT(self);
		return (TS_Format)((Target*)self)->getDepthFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getMultisample(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getMultisample();
	}
	TS_CAPI bool_t TS_CCALL tsTarget_hasMultisample(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->hasMultisample();
	}
	TS_CAPI bool_t TS_CCALL tsTarget_isFlipped(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->isFlipped();
	}
	TS_CAPI bool_t TS_CCALL tsTarget_isAtomic(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->isAtomic();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getWidth(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getHeight(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getDepth(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getDepth();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getFaces(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getFaces();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getLayers(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getLayers();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getMipmaps(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getMipmaps();
	}
	TS_CAPI void TS_CCALL tsTarget_setClearColor_cC(TSTarget self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((Target*)self)->setClearColor(*(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsTarget_setClearColor_ucC(TSTarget self, uint32_t index, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((Target*)self)->setClearColor(index, *(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsTarget_setClearColor_ffff(TSTarget self, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((Target*)self)->setClearColor(r, g, b, a);
	}
	TS_CAPI void TS_CCALL tsTarget_setClearColor_uffff(TSTarget self, uint32_t index, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((Target*)self)->setClearColor(index, r, g, b, a);
	}
	TS_CAPI void TS_CCALL tsTarget_setColorTexture_TTOcS(TSTarget self, TSTexture texture, TS_TargetOperation op, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Target*)self)->setColorTexture(*(Texture*)texture, (Target::Operation)op, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void TS_CCALL tsTarget_setColorTexture_uTTOcS(TSTarget self, uint32_t index, TSTexture texture, TS_TargetOperation op, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Target*)self)->setColorTexture(index, *(Texture*)texture, (Target::Operation)op, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void TS_CCALL tsTarget_setColorResolve_TcS(TSTarget self, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Target*)self)->setColorResolve(*(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void TS_CCALL tsTarget_setColorResolve_uTcS(TSTarget self, uint32_t index, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Target*)self)->setColorResolve(index, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getNumTargets(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getNumTargets();
	}
	TS_CAPI TSColor TS_CCALL tsTarget_getClearColor(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		const Color ret = ((Target*)self)->getClearColor(index);
		return *(TSColor*)&ret;
	}
	TS_CAPI TS_TargetOperation TS_CCALL tsTarget_getColorOp(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_TargetOperation)((Target*)self)->getColorOp(index);
	}
	TS_CAPI TSTexture TS_CCALL tsTarget_getColorTexture(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Target*)self)->getColorTexture(index)));
	}
	TS_CAPI TSTexture TS_CCALL tsTarget_getColorResolve(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Target*)self)->getColorResolve(index)));
	}
	TS_CAPI TSSlice TS_CCALL tsTarget_getColorTextureSlice(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		const Slice ret = ((Target*)self)->getColorTextureSlice(index);
		return *(TSSlice*)&ret;
	}
	TS_CAPI TSSlice TS_CCALL tsTarget_getColorResolveSlice(TSTarget self, uint32_t index) {
		TS_ASSERT(self);
		const Slice ret = ((Target*)self)->getColorResolveSlice(index);
		return *(TSSlice*)&ret;
	}
	TS_CAPI void TS_CCALL tsTarget_setClearDepth(TSTarget self, float32_t depth, uint32_t stencil) {
		TS_ASSERT(self);
		((Target*)self)->setClearDepth(depth, stencil);
	}
	TS_CAPI void TS_CCALL tsTarget_setDepthTexture(TSTarget self, TSTexture texture, TS_TargetOperation op, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Target*)self)->setDepthTexture(*(Texture*)texture, (Target::Operation)op, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI void TS_CCALL tsTarget_setDepthResolve(TSTarget self, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Target*)self)->setDepthResolve(*(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI float32_t TS_CCALL tsTarget_getClearDepth(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getClearDepth();
	}
	TS_CAPI uint32_t TS_CCALL tsTarget_getClearStencil(TSTarget self) {
		TS_ASSERT(self);
		return ((Target*)self)->getClearStencil();
	}
	TS_CAPI TS_TargetOperation TS_CCALL tsTarget_getDepthOp(TSTarget self) {
		TS_ASSERT(self);
		return (TS_TargetOperation)((Target*)self)->getDepthOp();
	}
	TS_CAPI TSTexture TS_CCALL tsTarget_getDepthTexture(TSTarget self) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Target*)self)->getDepthTexture()));
	}
	TS_CAPI TSTexture TS_CCALL tsTarget_getDepthResolve(TSTarget self) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Target*)self)->getDepthResolve()));
	}
	TS_CAPI TSSlice TS_CCALL tsTarget_getDepthTextureSlice(TSTarget self) {
		TS_ASSERT(self);
		const Slice ret = ((Target*)self)->getDepthTextureSlice();
		return *(TSSlice*)&ret;
	}
	TS_CAPI TSSlice TS_CCALL tsTarget_getDepthResolveSlice(TSTarget self) {
		TS_ASSERT(self);
		const Slice ret = ((Target*)self)->getDepthResolveSlice();
		return *(TSSlice*)&ret;
	}
	
	// Tellusim::D3D12Target
	TS_CAPI TSD3D12Target TS_CCALL tsD3D12Target_new(void) {
		D3D12Target *ret = new D3D12Target();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Target)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Target_delete(TSD3D12Target self) {
		if(self) delete (D3D12Target*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Target_equalPtr(const TSD3D12Target self, const TSD3D12Target ptr) {
		return (self && ptr && ((D3D12Target*)self)->operator==(*(D3D12Target*)ptr));
	}
	TS_CAPI TSD3D12Target TS_CCALL tsD3D12Target_copyPtr(TSD3D12Target self) {
		D3D12Target *ret = nullptr;
		if(self) ret = new D3D12Target(*(D3D12Target*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Target)ret;
	}
	TS_CAPI TSD3D12Target TS_CCALL tsD3D12Target_clonePtr(const TSD3D12Target self) {
		D3D12Target *ret = (self) ? new D3D12Target(((D3D12Target*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Target)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Target_clearPtr(TSD3D12Target self) {
		if(self) ((D3D12Target*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Target_destroyPtr(TSD3D12Target self) {
		if(self) ((D3D12Target*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Target_acquirePtr(TSD3D12Target self) {
		if(self) ((D3D12Target*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Target_unacquirePtr(TSD3D12Target self) {
		if(self) ((D3D12Target*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Target_isValidPtr(const TSD3D12Target self) {
		return (self && ((D3D12Target*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Target_isOwnerPtr(const TSD3D12Target self) {
		return (self && ((D3D12Target*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Target_isConstPtr(const TSD3D12Target self) {
		return (self && ((D3D12Target*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Target_getCountPtr(const TSD3D12Target self) {
		return ((D3D12Target*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Target_getInternalPtr(const TSD3D12Target self) {
		return ((D3D12Target*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Target_equalTargetPtr(const TSD3D12Target self, const TSTarget base) {
		return (self && base && ((D3D12Target*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSD3D12Target TS_CCALL tsD3D12Target_castTargetPtr(TSTarget base) {
		return (TSD3D12Target)(new D3D12Target(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsD3D12Target_baseTargetPtr(TSD3D12Target self) {
		return (TSTarget)(new Target(((D3D12Target*)self)->getTarget()));
	}
	TS_CAPI size_t* TS_CCALL tsD3D12Target_getRenderTargetViews(TSD3D12Target self) {
		TS_ASSERT(self);
		return ((D3D12Target*)self)->getRenderTargetViews();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Target_getDepthStencilView(TSD3D12Target self) {
		TS_ASSERT(self);
		return ((D3D12Target*)self)->getDepthStencilView();
	}
	
	// Tellusim::D3D11Target
	TS_CAPI TSD3D11Target TS_CCALL tsD3D11Target_new(void) {
		D3D11Target *ret = new D3D11Target();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Target)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Target_delete(TSD3D11Target self) {
		if(self) delete (D3D11Target*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Target_equalPtr(const TSD3D11Target self, const TSD3D11Target ptr) {
		return (self && ptr && ((D3D11Target*)self)->operator==(*(D3D11Target*)ptr));
	}
	TS_CAPI TSD3D11Target TS_CCALL tsD3D11Target_copyPtr(TSD3D11Target self) {
		D3D11Target *ret = nullptr;
		if(self) ret = new D3D11Target(*(D3D11Target*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Target)ret;
	}
	TS_CAPI TSD3D11Target TS_CCALL tsD3D11Target_clonePtr(const TSD3D11Target self) {
		D3D11Target *ret = (self) ? new D3D11Target(((D3D11Target*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Target)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Target_clearPtr(TSD3D11Target self) {
		if(self) ((D3D11Target*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Target_destroyPtr(TSD3D11Target self) {
		if(self) ((D3D11Target*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Target_acquirePtr(TSD3D11Target self) {
		if(self) ((D3D11Target*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Target_unacquirePtr(TSD3D11Target self) {
		if(self) ((D3D11Target*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Target_isValidPtr(const TSD3D11Target self) {
		return (self && ((D3D11Target*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Target_isOwnerPtr(const TSD3D11Target self) {
		return (self && ((D3D11Target*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Target_isConstPtr(const TSD3D11Target self) {
		return (self && ((D3D11Target*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Target_getCountPtr(const TSD3D11Target self) {
		return ((D3D11Target*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Target_getInternalPtr(const TSD3D11Target self) {
		return ((D3D11Target*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Target_equalTargetPtr(const TSD3D11Target self, const TSTarget base) {
		return (self && base && ((D3D11Target*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSD3D11Target TS_CCALL tsD3D11Target_castTargetPtr(TSTarget base) {
		return (TSD3D11Target)(new D3D11Target(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsD3D11Target_baseTargetPtr(TSD3D11Target self) {
		return (TSTarget)(new Target(((D3D11Target*)self)->getTarget()));
	}
	TS_CAPI ID3D11RenderTargetView** TS_CCALL tsD3D11Target_getRenderTargetViews(TSD3D11Target self) {
		TS_ASSERT(self);
		return ((D3D11Target*)self)->getRenderTargetViews();
	}
	TS_CAPI ID3D11DepthStencilView* TS_CCALL tsD3D11Target_getDepthStencilView(TSD3D11Target self) {
		TS_ASSERT(self);
		return ((D3D11Target*)self)->getDepthStencilView();
	}
	
	// Tellusim::MTLTarget
	TS_CAPI TSMTLTarget TS_CCALL tsMTLTarget_new(void) {
		MTLTarget *ret = new MTLTarget();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTarget)ret;
	}
	TS_CAPI void TS_CCALL tsMTLTarget_delete(TSMTLTarget self) {
		if(self) delete (MTLTarget*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLTarget_equalPtr(const TSMTLTarget self, const TSMTLTarget ptr) {
		return (self && ptr && ((MTLTarget*)self)->operator==(*(MTLTarget*)ptr));
	}
	TS_CAPI TSMTLTarget TS_CCALL tsMTLTarget_copyPtr(TSMTLTarget self) {
		MTLTarget *ret = nullptr;
		if(self) ret = new MTLTarget(*(MTLTarget*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTarget)ret;
	}
	TS_CAPI TSMTLTarget TS_CCALL tsMTLTarget_clonePtr(const TSMTLTarget self) {
		MTLTarget *ret = (self) ? new MTLTarget(((MTLTarget*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLTarget)ret;
	}
	TS_CAPI void TS_CCALL tsMTLTarget_clearPtr(TSMTLTarget self) {
		if(self) ((MTLTarget*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLTarget_destroyPtr(TSMTLTarget self) {
		if(self) ((MTLTarget*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLTarget_acquirePtr(TSMTLTarget self) {
		if(self) ((MTLTarget*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLTarget_unacquirePtr(TSMTLTarget self) {
		if(self) ((MTLTarget*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLTarget_isValidPtr(const TSMTLTarget self) {
		return (self && ((MTLTarget*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLTarget_isOwnerPtr(const TSMTLTarget self) {
		return (self && ((MTLTarget*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLTarget_isConstPtr(const TSMTLTarget self) {
		return (self && ((MTLTarget*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLTarget_getCountPtr(const TSMTLTarget self) {
		return ((MTLTarget*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLTarget_getInternalPtr(const TSMTLTarget self) {
		return ((MTLTarget*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLTarget_equalTargetPtr(const TSMTLTarget self, const TSTarget base) {
		return (self && base && ((MTLTarget*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSMTLTarget TS_CCALL tsMTLTarget_castTargetPtr(TSTarget base) {
		return (TSMTLTarget)(new MTLTarget(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsMTLTarget_baseTargetPtr(TSMTLTarget self) {
		return (TSTarget)(new Target(((MTLTarget*)self)->getTarget()));
	}
	TS_CAPI void* TS_CCALL tsMTLTarget_getDescriptor(TSMTLTarget self) {
		TS_ASSERT(self);
		return ((MTLTarget*)self)->getDescriptor();
	}
	
	// Tellusim::VKTarget
	TS_CAPI TSVKTarget TS_CCALL tsVKTarget_new(void) {
		VKTarget *ret = new VKTarget();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTarget)ret;
	}
	TS_CAPI void TS_CCALL tsVKTarget_delete(TSVKTarget self) {
		if(self) delete (VKTarget*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKTarget_equalPtr(const TSVKTarget self, const TSVKTarget ptr) {
		return (self && ptr && ((VKTarget*)self)->operator==(*(VKTarget*)ptr));
	}
	TS_CAPI TSVKTarget TS_CCALL tsVKTarget_copyPtr(TSVKTarget self) {
		VKTarget *ret = nullptr;
		if(self) ret = new VKTarget(*(VKTarget*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTarget)ret;
	}
	TS_CAPI TSVKTarget TS_CCALL tsVKTarget_clonePtr(const TSVKTarget self) {
		VKTarget *ret = (self) ? new VKTarget(((VKTarget*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKTarget)ret;
	}
	TS_CAPI void TS_CCALL tsVKTarget_clearPtr(TSVKTarget self) {
		if(self) ((VKTarget*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKTarget_destroyPtr(TSVKTarget self) {
		if(self) ((VKTarget*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKTarget_acquirePtr(TSVKTarget self) {
		if(self) ((VKTarget*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKTarget_unacquirePtr(TSVKTarget self) {
		if(self) ((VKTarget*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKTarget_isValidPtr(const TSVKTarget self) {
		return (self && ((VKTarget*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKTarget_isOwnerPtr(const TSVKTarget self) {
		return (self && ((VKTarget*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKTarget_isConstPtr(const TSVKTarget self) {
		return (self && ((VKTarget*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKTarget_getCountPtr(const TSVKTarget self) {
		return ((VKTarget*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKTarget_getInternalPtr(const TSVKTarget self) {
		return ((VKTarget*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKTarget_equalTargetPtr(const TSVKTarget self, const TSTarget base) {
		return (self && base && ((VKTarget*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSVKTarget TS_CCALL tsVKTarget_castTargetPtr(TSTarget base) {
		return (TSVKTarget)(new VKTarget(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsVKTarget_baseTargetPtr(TSVKTarget self) {
		return (TSTarget)(new Target(((VKTarget*)self)->getTarget()));
	}
	TS_CAPI VkRenderPass TS_CCALL tsVKTarget_getRenderPass(TSVKTarget self) {
		TS_ASSERT(self);
		return ((VKTarget*)self)->getRenderPass();
	}
	TS_CAPI VkFramebuffer TS_CCALL tsVKTarget_getFramebuffer(TSVKTarget self) {
		TS_ASSERT(self);
		return ((VKTarget*)self)->getFramebuffer();
	}
	
	// Tellusim::GLTarget
	TS_CAPI TSGLTarget TS_CCALL tsGLTarget_new(void) {
		GLTarget *ret = new GLTarget();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLTarget)ret;
	}
	TS_CAPI void TS_CCALL tsGLTarget_delete(TSGLTarget self) {
		if(self) delete (GLTarget*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLTarget_equalPtr(const TSGLTarget self, const TSGLTarget ptr) {
		return (self && ptr && ((GLTarget*)self)->operator==(*(GLTarget*)ptr));
	}
	TS_CAPI TSGLTarget TS_CCALL tsGLTarget_copyPtr(TSGLTarget self) {
		GLTarget *ret = nullptr;
		if(self) ret = new GLTarget(*(GLTarget*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLTarget)ret;
	}
	TS_CAPI TSGLTarget TS_CCALL tsGLTarget_clonePtr(const TSGLTarget self) {
		GLTarget *ret = (self) ? new GLTarget(((GLTarget*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLTarget)ret;
	}
	TS_CAPI void TS_CCALL tsGLTarget_clearPtr(TSGLTarget self) {
		if(self) ((GLTarget*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLTarget_destroyPtr(TSGLTarget self) {
		if(self) ((GLTarget*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLTarget_acquirePtr(TSGLTarget self) {
		if(self) ((GLTarget*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLTarget_unacquirePtr(TSGLTarget self) {
		if(self) ((GLTarget*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLTarget_isValidPtr(const TSGLTarget self) {
		return (self && ((GLTarget*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLTarget_isOwnerPtr(const TSGLTarget self) {
		return (self && ((GLTarget*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLTarget_isConstPtr(const TSGLTarget self) {
		return (self && ((GLTarget*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLTarget_getCountPtr(const TSGLTarget self) {
		return ((GLTarget*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLTarget_getInternalPtr(const TSGLTarget self) {
		return ((GLTarget*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLTarget_equalTargetPtr(const TSGLTarget self, const TSTarget base) {
		return (self && base && ((GLTarget*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSGLTarget TS_CCALL tsGLTarget_castTargetPtr(TSTarget base) {
		return (TSGLTarget)(new GLTarget(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsGLTarget_baseTargetPtr(TSGLTarget self) {
		return (TSTarget)(new Target(((GLTarget*)self)->getTarget()));
	}
	TS_CAPI uint32_t TS_CCALL tsGLTarget_getFramebufferID(TSGLTarget self) {
		TS_ASSERT(self);
		return ((GLTarget*)self)->getFramebufferID();
	}
	
	// Tellusim::GLESTarget
	TS_CAPI TSGLESTarget TS_CCALL tsGLESTarget_new(void) {
		GLESTarget *ret = new GLESTarget();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESTarget)ret;
	}
	TS_CAPI void TS_CCALL tsGLESTarget_delete(TSGLESTarget self) {
		if(self) delete (GLESTarget*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLESTarget_equalPtr(const TSGLESTarget self, const TSGLESTarget ptr) {
		return (self && ptr && ((GLESTarget*)self)->operator==(*(GLESTarget*)ptr));
	}
	TS_CAPI TSGLESTarget TS_CCALL tsGLESTarget_copyPtr(TSGLESTarget self) {
		GLESTarget *ret = nullptr;
		if(self) ret = new GLESTarget(*(GLESTarget*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESTarget)ret;
	}
	TS_CAPI TSGLESTarget TS_CCALL tsGLESTarget_clonePtr(const TSGLESTarget self) {
		GLESTarget *ret = (self) ? new GLESTarget(((GLESTarget*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESTarget)ret;
	}
	TS_CAPI void TS_CCALL tsGLESTarget_clearPtr(TSGLESTarget self) {
		if(self) ((GLESTarget*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLESTarget_destroyPtr(TSGLESTarget self) {
		if(self) ((GLESTarget*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLESTarget_acquirePtr(TSGLESTarget self) {
		if(self) ((GLESTarget*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLESTarget_unacquirePtr(TSGLESTarget self) {
		if(self) ((GLESTarget*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESTarget_isValidPtr(const TSGLESTarget self) {
		return (self && ((GLESTarget*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESTarget_isOwnerPtr(const TSGLESTarget self) {
		return (self && ((GLESTarget*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESTarget_isConstPtr(const TSGLESTarget self) {
		return (self && ((GLESTarget*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLESTarget_getCountPtr(const TSGLESTarget self) {
		return ((GLESTarget*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLESTarget_getInternalPtr(const TSGLESTarget self) {
		return ((GLESTarget*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESTarget_equalTargetPtr(const TSGLESTarget self, const TSTarget base) {
		return (self && base && ((GLESTarget*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSGLESTarget TS_CCALL tsGLESTarget_castTargetPtr(TSTarget base) {
		return (TSGLESTarget)(new GLESTarget(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsGLESTarget_baseTargetPtr(TSGLESTarget self) {
		return (TSTarget)(new Target(((GLESTarget*)self)->getTarget()));
	}
	TS_CAPI uint32_t TS_CCALL tsGLESTarget_getFramebufferID(TSGLESTarget self) {
		TS_ASSERT(self);
		return ((GLESTarget*)self)->getFramebufferID();
	}
	
	// Tellusim::FUTarget
	TS_CAPI TSFUTarget TS_CCALL tsFUTarget_new(void) {
		FUTarget *ret = new FUTarget();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTarget)ret;
	}
	TS_CAPI TSFUTarget TS_CCALL tsFUTarget_new_cATb(const TSTarget *targets, uint32_t targets_size, bool_t owner) {
		Array<Target> targets_(targets_size);
		for(uint32_t i = 0; i < targets_size; i++) if(targets[i]) targets_[i] = *(Target*)targets[i];
		FUTarget *ret = new FUTarget(targets_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTarget)ret;
	}
	TS_CAPI void TS_CCALL tsFUTarget_delete(TSFUTarget self) {
		if(self) delete (FUTarget*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUTarget_equalPtr(const TSFUTarget self, const TSFUTarget ptr) {
		return (self && ptr && ((FUTarget*)self)->operator==(*(FUTarget*)ptr));
	}
	TS_CAPI TSFUTarget TS_CCALL tsFUTarget_copyPtr(TSFUTarget self) {
		FUTarget *ret = nullptr;
		if(self) ret = new FUTarget(*(FUTarget*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTarget)ret;
	}
	TS_CAPI TSFUTarget TS_CCALL tsFUTarget_clonePtr(const TSFUTarget self) {
		FUTarget *ret = (self) ? new FUTarget(((FUTarget*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTarget)ret;
	}
	TS_CAPI void TS_CCALL tsFUTarget_clearPtr(TSFUTarget self) {
		if(self) ((FUTarget*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUTarget_destroyPtr(TSFUTarget self) {
		if(self) ((FUTarget*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUTarget_acquirePtr(TSFUTarget self) {
		if(self) ((FUTarget*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUTarget_unacquirePtr(TSFUTarget self) {
		if(self) ((FUTarget*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTarget_isValidPtr(const TSFUTarget self) {
		return (self && ((FUTarget*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTarget_isOwnerPtr(const TSFUTarget self) {
		return (self && ((FUTarget*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTarget_isConstPtr(const TSFUTarget self) {
		return (self && ((FUTarget*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUTarget_getCountPtr(const TSFUTarget self) {
		return ((FUTarget*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUTarget_getInternalPtr(const TSFUTarget self) {
		return ((FUTarget*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTarget_equalTargetPtr(const TSFUTarget self, const TSTarget base) {
		return (self && base && ((FUTarget*)self)->operator==(*(Target*)base));
	}
	TS_CAPI TSFUTarget TS_CCALL tsFUTarget_castTargetPtr(TSTarget base) {
		return (TSFUTarget)(new FUTarget(*(Target*)base));
	}
	TS_CAPI TSTarget TS_CCALL tsFUTarget_baseTargetPtr(TSFUTarget self) {
		return (TSTarget)(new Target(((FUTarget*)self)->getTarget()));
	}
	TS_CAPI void TS_CCALL tsFUTarget_setMask(TSFUTarget self, uint32_t mask) {
		TS_ASSERT(self);
		((FUTarget*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUTarget_getMask(TSFUTarget self) {
		TS_ASSERT(self);
		return ((FUTarget*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUTarget_getNumTargets(TSFUTarget self) {
		TS_ASSERT(self);
		return ((FUTarget*)self)->getNumTargets();
	}
	TS_CAPI TSTarget TS_CCALL tsFUTarget_getTarget_cu(TSFUTarget self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTarget)(new Target(((FUTarget*)self)->getTarget(index)));
	}
	TS_CAPI TSTarget TS_CCALL tsFUTarget_getTarget_u(TSFUTarget self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTarget)(new Target(((FUTarget*)self)->getTarget(index)));
	}
	
	// Tellusim::Device
	TS_CAPI TSDevice TS_CCALL tsDevice_new(void) {
		Device *ret = new Device();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDevice)ret;
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_new_C(TSContext context) {
		TS_ASSERT(context);
		Device *ret = new Device(*(Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDevice)ret;
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_new_S(TSSurface surface) {
		TS_ASSERT(surface);
		Device *ret = new Device(*(Surface*)surface);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDevice)ret;
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_new_W(TSWindow window) {
		TS_ASSERT(window);
		Device *ret = new Device(*(Window*)window);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDevice)ret;
	}
	TS_CAPI void TS_CCALL tsDevice_delete(TSDevice self) {
		if(self) delete (Device*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDevice_equalPtr(const TSDevice self, const TSDevice ptr) {
		return (self && ptr && ((Device*)self)->operator==(*(Device*)ptr));
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_copyPtr(TSDevice self) {
		Device *ret = nullptr;
		if(self) ret = new Device(*(Device*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDevice)ret;
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_clonePtr(const TSDevice self) {
		Device *ret = (self) ? new Device(((Device*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDevice)ret;
	}
	TS_CAPI void TS_CCALL tsDevice_clearPtr(TSDevice self) {
		if(self) ((Device*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDevice_destroyPtr(TSDevice self) {
		if(self) ((Device*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDevice_acquirePtr(TSDevice self) {
		if(self) ((Device*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDevice_unacquirePtr(TSDevice self) {
		if(self) ((Device*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDevice_isValidPtr(const TSDevice self) {
		return (self && ((Device*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_isOwnerPtr(const TSDevice self) {
		return (self && ((Device*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_isConstPtr(const TSDevice self) {
		return (self && ((Device*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDevice_getCountPtr(const TSDevice self) {
		return ((Device*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDevice_getInternalPtr(const TSDevice self) {
		return ((Device*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsDevice_getPlatform(TSDevice self) {
		TS_ASSERT(self);
		return (TS_Platform)((Device*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsDevice_getPlatformName(TSDevice self) {
		TS_ASSERT(self);
		return ((Device*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsDevice_getIndex(TSDevice self) {
		TS_ASSERT(self);
		return ((Device*)self)->getIndex();
	}
	TS_CAPI TSString TS_CCALL tsDevice_getName(TSDevice self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Device*)self)->getName()));
	}
	TS_CAPI TSString TS_CCALL tsDevice_getVendor(TSDevice self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Device*)self)->getVendor()));
	}
	TS_CAPI TSString TS_CCALL tsDevice_getVersion(TSDevice self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Device*)self)->getVersion()));
	}
	TS_CAPI TSDeviceFeatures TS_CCALL tsDevice_getFeatures(TSDevice self) {
		TS_ASSERT(self);
		const Device::Features ret = ((Device*)self)->getFeatures();
		return *(TSDeviceFeatures*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsDevice_hasQuery(TSDevice self, TS_QueryType type) {
		TS_ASSERT(self);
		return ((Device*)self)->hasQuery((Query::Type)type);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_hasShader(TSDevice self, TS_ShaderType type) {
		TS_ASSERT(self);
		return ((Device*)self)->hasShader((Shader::Type)type);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_hasTarget(TSDevice self, TS_Format format) {
		TS_ASSERT(self);
		return ((Device*)self)->hasTarget((Format)format);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_hasTexture(TSDevice self, TS_Format format) {
		TS_ASSERT(self);
		return ((Device*)self)->hasTexture((Format)format);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_hasSurface(TSDevice self, TS_Format format) {
		TS_ASSERT(self);
		return ((Device*)self)->hasSurface((Format)format);
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_createDevice(TSDevice self, uint32_t index, uint32_t frames) {
		TS_ASSERT(self);
		return (TSDevice)(new Device(((Device*)self)->createDevice(index, frames)));
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_createCommandDevice(TSDevice self, uint32_t frames) {
		TS_ASSERT(self);
		return (TSDevice)(new Device(((Device*)self)->createCommandDevice(frames)));
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_createComputeDevice(TSDevice self, uint32_t frames) {
		TS_ASSERT(self);
		return (TSDevice)(new Device(((Device*)self)->createComputeDevice(frames)));
	}
	TS_CAPI TSDevice TS_CCALL tsDevice_createCopyDevice(TSDevice self, uint32_t frames) {
		TS_ASSERT(self);
		return (TSDevice)(new Device(((Device*)self)->createCopyDevice(frames)));
	}
	TS_CAPI TSQuery TS_CCALL tsDevice_createQuery_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSQuery)(new Query(((Device*)self)->createQuery()));
	}
	TS_CAPI TSQuery TS_CCALL tsDevice_createQuery_cQT(TSDevice self, TS_QueryType type) {
		TS_ASSERT(self);
		return (TSQuery)(new Query(((Device*)self)->createQuery((Query::Type)type)));
	}
	TS_CAPI TSFence TS_CCALL tsDevice_createFence_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSFence)(new Fence(((Device*)self)->createFence()));
	}
	TS_CAPI TSFence TS_CCALL tsDevice_createFence_cF(TSDevice self, TSFence shared) {
		TS_ASSERT(self);
		TS_ASSERT(shared);
		return (TSFence)(new Fence(((Device*)self)->createFence(*(Fence*)shared)));
	}
	TS_CAPI TSFence TS_CCALL tsDevice_createFence_cFF(TSDevice self, TS_FenceFlags flags) {
		TS_ASSERT(self);
		return (TSFence)(new Fence(((Device*)self)->createFence((Fence::Flags)flags)));
	}
	TS_CAPI TSBuffer TS_CCALL tsDevice_createBuffer_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Device*)self)->createBuffer()));
	}
	TS_CAPI TSBuffer TS_CCALL tsDevice_createBuffer_cB(TSDevice self, TSBuffer shared) {
		TS_ASSERT(self);
		TS_ASSERT(shared);
		return (TSBuffer)(new Buffer(((Device*)self)->createBuffer(*(Buffer*)shared)));
	}
	TS_CAPI TSBuffer TS_CCALL tsDevice_createBuffer_cBFzF(TSDevice self, TS_BufferFlags flags, size_t size, TS_Format format) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Device*)self)->createBuffer((Buffer::Flags)flags, size, (Format)format)));
	}
	TS_CAPI TSBuffer TS_CCALL tsDevice_createBuffer_cBFpzF(TSDevice self, TS_BufferFlags flags, const void *src, size_t size, TS_Format format) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((Device*)self)->createBuffer((Buffer::Flags)flags, src, size, (Format)format)));
	}
	TS_CAPI TSSampler TS_CCALL tsDevice_createSampler_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSSampler)(new Sampler(((Device*)self)->createSampler()));
	}
	TS_CAPI TSSampler TS_CCALL tsDevice_createSampler_ccS(TSDevice self, const TSSampler sampler) {
		TS_ASSERT(self);
		TS_ASSERT(sampler);
		return (TSSampler)(new Sampler(((Device*)self)->createSampler(*(const Sampler*)sampler)));
	}
	TS_CAPI TSSampler TS_CCALL tsDevice_createSampler_cSFSWMu(TSDevice self, TS_SamplerFilter filter, TS_SamplerWrapMode mode, uint32_t anisotropy) {
		TS_ASSERT(self);
		return (TSSampler)(new Sampler(((Device*)self)->createSampler((Sampler::Filter)filter, (Sampler::WrapMode)mode, anisotropy)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTexture()));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture_cT(TSDevice self, TSTexture shared) {
		TS_ASSERT(self);
		TS_ASSERT(shared);
		return (TSTexture)(new Texture(((Device*)self)->createTexture(*(Texture*)shared)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture_cTTFcSuTF(TSDevice self, TS_TextureType type, TS_Format format, const TSSize *size, uint32_t layers, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return (TSTexture)(new Texture(((Device*)self)->createTexture((Texture::Type)type, (Format)format, *(const Size*)size, layers, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture_cTTFcSTF(TSDevice self, TS_TextureType type, TS_Format format, const TSSize *size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		return (TSTexture)(new Texture(((Device*)self)->createTexture((Texture::Type)type, (Format)format, *(const Size*)size, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture_ccITFA(TSDevice self, const TSImage image, TS_TextureFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return (TSTexture)(new Texture(((Device*)self)->createTexture(*(const Image*)image, (Texture::Flags)flags, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture2D_cFuTF(TSDevice self, TS_Format format, uint32_t size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTexture2D((Format)format, size, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture3D_cFuTF(TSDevice self, TS_Format format, uint32_t size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTexture3D((Format)format, size, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTextureCube_cFuTF(TSDevice self, TS_Format format, uint32_t size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTextureCube((Format)format, size, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture2D_cFuuTF(TSDevice self, TS_Format format, uint32_t width, uint32_t height, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTexture2D((Format)format, width, height, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture3D_cFuuuTF(TSDevice self, TS_Format format, uint32_t width, uint32_t height, uint32_t depth, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTexture3D((Format)format, width, height, depth, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTexture2D_cFuuuTF(TSDevice self, TS_Format format, uint32_t width, uint32_t height, uint32_t layers, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTexture2D((Format)format, width, height, layers, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_createTextureCube_cFuuTF(TSDevice self, TS_Format format, uint32_t size, uint32_t layers, TS_TextureFlags flags) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->createTextureCube((Format)format, size, layers, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_loadTexture_csTFIFuA(TSDevice self, const char *name, TS_TextureFlags flags, TS_ImageFlags image_flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->loadTexture(name, (Texture::Flags)flags, (Image::Flags)image_flags, offset, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_loadTexture_ccSTFIFuA(TSDevice self, const TSString name, TS_TextureFlags flags, TS_ImageFlags image_flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Device*)self)->loadTexture((name) ? *(const String*)name : String::null, (Texture::Flags)flags, (Image::Flags)image_flags, offset, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSTexture TS_CCALL tsDevice_loadTexture_cStTFIFuA(TSDevice self, TSStream stream, TS_TextureFlags flags, TS_ImageFlags image_flags, uint32_t offset, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return (TSTexture)(new Texture(((Device*)self)->loadTexture(*(Stream*)stream, (Texture::Flags)flags, (Image::Flags)image_flags, offset, (async) ? *(Async**)async : nullptr)));
	}
	TS_CAPI TSTracing TS_CCALL tsDevice_createTracing_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSTracing)(new Tracing(((Device*)self)->createTracing()));
	}
	TS_CAPI TSTracing TS_CCALL tsDevice_createTracing_ccT(TSDevice self, const TSTracing tracing) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		return (TSTracing)(new Tracing(((Device*)self)->createTracing(*(const Tracing*)tracing)));
	}
	TS_CAPI TSTracing TS_CCALL tsDevice_createTracing_cuBzTF(TSDevice self, uint32_t num_instances, TSBuffer instance_buffer, size_t instance_offset, TS_TracingFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(instance_buffer);
		return (TSTracing)(new Tracing(((Device*)self)->createTracing(num_instances, *(Buffer*)instance_buffer, instance_offset, (Tracing::Flags)flags)));
	}
	TS_CAPI TSTracing TS_CCALL tsDevice_createTracing_cuFzuFTF(TSDevice self, uint32_t num_vertices, TS_Format vertex_format, size_t vertex_stride, uint32_t num_indices, TS_Format index_format, TS_TracingFlags flags) {
		TS_ASSERT(self);
		return (TSTracing)(new Tracing(((Device*)self)->createTracing(num_vertices, (Format)vertex_format, vertex_stride, num_indices, (Format)index_format, (Tracing::Flags)flags)));
	}
	TS_CAPI TSTracing TS_CCALL tsDevice_createTracing_cuzBzTF(TSDevice self, uint32_t num_bounds, size_t bound_stride, TSBuffer bound_buffer, size_t bound_offset, TS_TracingFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(bound_buffer);
		return (TSTracing)(new Tracing(((Device*)self)->createTracing(num_bounds, bound_stride, *(Buffer*)bound_buffer, bound_offset, (Tracing::Flags)flags)));
	}
	TS_CAPI TSBufferTable TS_CCALL tsDevice_createBufferTable_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSBufferTable)(new BufferTable(((Device*)self)->createBufferTable()));
	}
	TS_CAPI TSBufferTable TS_CCALL tsDevice_createBufferTable_cu(TSDevice self, uint32_t size) {
		TS_ASSERT(self);
		return (TSBufferTable)(new BufferTable(((Device*)self)->createBufferTable(size)));
	}
	TS_CAPI TSBufferTable TS_CCALL tsDevice_createBufferTable_ccABb(TSDevice self, const TSBuffer *buffers, uint32_t buffers_size, bool_t owner) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		return (TSBufferTable)(new BufferTable(((Device*)self)->createBufferTable(buffers_, (bool)owner)));
	}
	TS_CAPI TSTextureTable TS_CCALL tsDevice_createTextureTable_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSTextureTable)(new TextureTable(((Device*)self)->createTextureTable()));
	}
	TS_CAPI TSTextureTable TS_CCALL tsDevice_createTextureTable_cTTu(TSDevice self, TS_TextureType type, uint32_t size) {
		TS_ASSERT(self);
		return (TSTextureTable)(new TextureTable(((Device*)self)->createTextureTable((Texture::Type)type, size)));
	}
	TS_CAPI TSTextureTable TS_CCALL tsDevice_createTextureTable_ccATb(TSDevice self, const TSTexture *textures, uint32_t textures_size, bool_t owner) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		return (TSTextureTable)(new TextureTable(((Device*)self)->createTextureTable(textures_, (bool)owner)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_createShader_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->createShader()));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_loadShader_cSTss(TSDevice self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->loadShader((Shader::Type)type, name, "%s", format)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_loadShaderGLSL_cSTss(TSDevice self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->loadShaderGLSL((Shader::Type)type, name, "%s", format)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_loadShader_cSTscS(TSDevice self, TS_ShaderType type, const char *name, const TSString macros) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->loadShader((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_loadShaderGLSL_cSTscS(TSDevice self, TS_ShaderType type, const char *name, const TSString macros) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->loadShaderGLSL((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_loadShaderSPIRV(TSDevice self, TS_ShaderType type, const char *name) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->loadShaderSPIRV((Shader::Type)type, name)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_createShader_cSTss(TSDevice self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->createShader((Shader::Type)type, src, "%s", format)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_createShaderGLSL_cSTss(TSDevice self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->createShaderGLSL((Shader::Type)type, src, "%s", format)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_createShader_cSTscS(TSDevice self, TS_ShaderType type, const char *src, const TSString macros) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->createShader((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_createShaderGLSL_cSTscS(TSDevice self, TS_ShaderType type, const char *src, const TSString macros) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Device*)self)->createShaderGLSL((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null)));
	}
	TS_CAPI TSShader TS_CCALL tsDevice_createShaderSPIRV(TSDevice self, TS_ShaderType type, const uint32_t *data, uint32_t data_size) {
		TS_ASSERT(self);
		Array<uint32_t> data_(data_size, data);
		return (TSShader)(new Shader(((Device*)self)->createShaderSPIRV((Shader::Type)type, data_)));
	}
	TS_CAPI TSKernel TS_CCALL tsDevice_createKernel_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Device*)self)->createKernel()));
	}
	TS_CAPI TSKernel TS_CCALL tsDevice_createKernel_ccK(TSDevice self, const TSKernel kernel) {
		TS_ASSERT(self);
		TS_ASSERT(kernel);
		return (TSKernel)(new Kernel(((Device*)self)->createKernel(*(const Kernel*)kernel)));
	}
	TS_CAPI void TS_CCALL tsDevice_releaseKernel(TSDevice self, TSKernel kernel) {
		TS_ASSERT(self);
		TS_ASSERT(kernel);
		((Device*)self)->releaseKernel(*(Kernel*)kernel);
	}
	TS_CAPI TSPipeline TS_CCALL tsDevice_createPipeline_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Device*)self)->createPipeline()));
	}
	TS_CAPI TSPipeline TS_CCALL tsDevice_createPipeline_ccP(TSDevice self, const TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		return (TSPipeline)(new Pipeline(((Device*)self)->createPipeline(*(const Pipeline*)pipeline)));
	}
	TS_CAPI void TS_CCALL tsDevice_releasePipeline(TSDevice self, TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((Device*)self)->releasePipeline(*(Pipeline*)pipeline);
	}
	TS_CAPI TSTraversal TS_CCALL tsDevice_createTraversal_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Device*)self)->createTraversal()));
	}
	TS_CAPI TSTraversal TS_CCALL tsDevice_createTraversal_ccT(TSDevice self, const TSTraversal traversal) {
		TS_ASSERT(self);
		TS_ASSERT(traversal);
		return (TSTraversal)(new Traversal(((Device*)self)->createTraversal(*(const Traversal*)traversal)));
	}
	TS_CAPI void TS_CCALL tsDevice_releaseTraversal(TSDevice self, TSTraversal traversal) {
		TS_ASSERT(self);
		TS_ASSERT(traversal);
		((Device*)self)->releaseTraversal(*(Traversal*)traversal);
	}
	TS_CAPI TSTarget TS_CCALL tsDevice_createTarget_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSTarget)(new Target(((Device*)self)->createTarget()));
	}
	TS_CAPI TSTarget TS_CCALL tsDevice_createTarget_cS(TSDevice self, TSSurface surface) {
		TS_ASSERT(self);
		TS_ASSERT(surface);
		return (TSTarget)(new Target(((Device*)self)->createTarget(*(Surface*)surface)));
	}
	TS_CAPI TSTarget TS_CCALL tsDevice_createTarget_cW(TSDevice self, TSWindow window) {
		TS_ASSERT(self);
		TS_ASSERT(window);
		return (TSTarget)(new Target(((Device*)self)->createTarget(*(Window*)window)));
	}
	TS_CAPI TSCompute TS_CCALL tsDevice_createCompute(TSDevice self) {
		TS_ASSERT(self);
		return (TSCompute)(new Compute(((Device*)self)->createCompute()));
	}
	TS_CAPI TSCommand TS_CCALL tsDevice_createCommand_c(TSDevice self) {
		TS_ASSERT(self);
		return (TSCommand)(new Command(((Device*)self)->createCommand()));
	}
	TS_CAPI TSCommand TS_CCALL tsDevice_createCommand_cT(TSDevice self, TSTarget target) {
		TS_ASSERT(self);
		TS_ASSERT(target);
		return (TSCommand)(new Command(((Device*)self)->createCommand(*(Target*)target)));
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setBuffer_cBzpz(TSDevice self, TSBuffer buffer, size_t offset, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->setBuffer(*(Buffer*)buffer, offset, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setBuffer_cBpz(TSDevice self, TSBuffer buffer, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->setBuffer(*(Buffer*)buffer, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setBuffer_cBp(TSDevice self, TSBuffer buffer, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->setBuffer(*(Buffer*)buffer, src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_getBuffer_cBzprz(TSDevice self, TSBuffer buffer, size_t offset, void *dest, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->getBuffer(*(Buffer*)buffer, offset, dest, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_getBuffer_cBprz(TSDevice self, TSBuffer buffer, void *dest, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->getBuffer(*(Buffer*)buffer, dest, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_getBuffer_cBpr(TSDevice self, TSBuffer buffer, void *dest) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->getBuffer(*(Buffer*)buffer, dest);
	}
	TS_CAPI void* TS_CCALL tsDevice_mapBuffer_cBzz(TSDevice self, TSBuffer buffer, size_t offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->mapBuffer(*(Buffer*)buffer, offset, size);
	}
	TS_CAPI void* TS_CCALL tsDevice_mapBuffer_cBz(TSDevice self, TSBuffer buffer, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->mapBuffer(*(Buffer*)buffer, size);
	}
	TS_CAPI void* TS_CCALL tsDevice_mapBuffer_cB(TSDevice self, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->mapBuffer(*(Buffer*)buffer);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_unmapBuffer(TSDevice self, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->unmapBuffer(*(Buffer*)buffer);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyBuffer_cBzBzz(TSDevice self, TSBuffer buffer, size_t dest_offset, TSBuffer src, size_t src_offset, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Device*)self)->copyBuffer(*(Buffer*)buffer, dest_offset, *(Buffer*)src, src_offset, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyBuffer_cBzBz(TSDevice self, TSBuffer buffer, size_t dest_offset, TSBuffer src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Device*)self)->copyBuffer(*(Buffer*)buffer, dest_offset, *(Buffer*)src, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyBuffer_cBBz(TSDevice self, TSBuffer buffer, TSBuffer src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Device*)self)->copyBuffer(*(Buffer*)buffer, *(Buffer*)src, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyBuffer_cBB(TSDevice self, TSBuffer buffer, TSBuffer src) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(src);
		return ((Device*)self)->copyBuffer(*(Buffer*)buffer, *(Buffer*)src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearBuffer_cBFzpz(TSDevice self, TSBuffer buffer, TS_Format format, size_t offset, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->clearBuffer(*(Buffer*)buffer, (Format)format, offset, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearBuffer_cBFpz(TSDevice self, TSBuffer buffer, TS_Format format, const void *src, size_t size) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->clearBuffer(*(Buffer*)buffer, (Format)format, src, size);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearBuffer_cBFp(TSDevice self, TSBuffer buffer, TS_Format format, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->clearBuffer(*(Buffer*)buffer, (Format)format, src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearBuffer_cB(TSDevice self, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->clearBuffer(*(Buffer*)buffer);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindBuffer_cBcAcAbF(TSDevice self, TSBuffer buffer, const size_t *offsets, uint32_t offsets_size, const size_t *sizes, uint32_t sizes_size, bool_t commit, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		Array<size_t> offsets_(offsets_size, offsets);
		Array<size_t> sizes_(sizes_size, sizes);
		TS_ASSERT(fence);
		return ((Device*)self)->bindBuffer(*(Buffer*)buffer, offsets_, sizes_, (bool)commit, *(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindBuffer_cBcAcAb(TSDevice self, TSBuffer buffer, const size_t *offsets, uint32_t offsets_size, const size_t *sizes, uint32_t sizes_size, bool_t commit) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		Array<size_t> offsets_(offsets_size, offsets);
		Array<size_t> sizes_(sizes_size, sizes);
		return ((Device*)self)->bindBuffer(*(Buffer*)buffer, offsets_, sizes_, (bool)commit);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindBuffer_cBzzbF(TSDevice self, TSBuffer buffer, size_t offset, size_t size, bool_t commit, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		TS_ASSERT(fence);
		return ((Device*)self)->bindBuffer(*(Buffer*)buffer, offset, size, (bool)commit, *(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindBuffer_cBzzb(TSDevice self, TSBuffer buffer, size_t offset, size_t size, bool_t commit) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->bindBuffer(*(Buffer*)buffer, offset, size, (bool)commit);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushBuffer(TSDevice self, TSBuffer buffer, TS_BufferFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		return ((Device*)self)->flushBuffer(*(Buffer*)buffer, (Buffer::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushBuffers_ccABBF(TSDevice self, const TSBuffer *buffers, uint32_t buffers_size, TS_BufferFlags flags) {
		TS_ASSERT(self);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		return ((Device*)self)->flushBuffers(buffers_, (Buffer::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsDevice_releaseBuffer(TSDevice self, TSBuffer buffer) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((Device*)self)->releaseBuffer(*(Buffer*)buffer);
	}
	TS_CAPI void TS_CCALL tsDevice_releaseSampler(TSDevice self, TSSampler sampler) {
		TS_ASSERT(self);
		TS_ASSERT(sampler);
		((Device*)self)->releaseSampler(*(Sampler*)sampler);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTexture_cTcOcScIcS(TSDevice self, TSTexture texture, const TSOrigin *dest_origin, const TSSlice *dest_slice, const TSImage image, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(image);
		return ((Device*)self)->setTexture(*(Texture*)texture, *(const Origin*)dest_origin, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(const Image*)image, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTexture_cTcOcI(TSDevice self, TSTexture texture, const TSOrigin *dest_origin, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(image);
		return ((Device*)self)->setTexture(*(Texture*)texture, *(const Origin*)dest_origin, *(const Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTexture_cTcScI(TSDevice self, TSTexture texture, const TSSlice *dest_slice, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Device*)self)->setTexture(*(Texture*)texture, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(const Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTexture_cTcI(TSDevice self, TSTexture texture, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Device*)self)->setTexture(*(Texture*)texture, *(const Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_getTexture_cTcSIcS(TSDevice self, TSTexture texture, const TSSlice *src_slice, TSImage image, const TSSlice *dest_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Device*)self)->getTexture(*(Texture*)texture, (src_slice) ? *(const Slice*)src_slice : Slice(), *(Image*)image, (dest_slice) ? *(const Slice*)dest_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_getTexture_cTIcS(TSDevice self, TSTexture texture, TSImage image, const TSSlice *dest_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Device*)self)->getTexture(*(Texture*)texture, *(Image*)image, (dest_slice) ? *(const Slice*)dest_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_getTexture_cTI(TSDevice self, TSTexture texture, TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(image);
		return ((Device*)self)->getTexture(*(Texture*)texture, *(Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyTexture_cTcOcSTcRcS(TSDevice self, TSTexture texture, const TSOrigin *dest_origin, const TSSlice *dest_slice, TSTexture src, const TSRegion *src_region, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(src);
		TS_ASSERT(src_region);
		return ((Device*)self)->copyTexture(*(Texture*)texture, *(const Origin*)dest_origin, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(Texture*)src, *(const Region*)src_region, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyTexture_cTcOTcR(TSDevice self, TSTexture texture, const TSOrigin *dest_origin, TSTexture src, const TSRegion *src_region) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(dest_origin);
		TS_ASSERT(src);
		TS_ASSERT(src_region);
		return ((Device*)self)->copyTexture(*(Texture*)texture, *(const Origin*)dest_origin, *(Texture*)src, *(const Region*)src_region);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyTexture_cTcSTcS(TSDevice self, TSTexture texture, const TSSlice *dest_slice, TSTexture src, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(src);
		return ((Device*)self)->copyTexture(*(Texture*)texture, (dest_slice) ? *(const Slice*)dest_slice : Slice(), *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyTexture_cTT(TSDevice self, TSTexture texture, TSTexture src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(src);
		return ((Device*)self)->copyTexture(*(Texture*)texture, *(Texture*)src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearTexture_cTcRcSp(TSDevice self, TSTexture texture, const TSRegion *region, const TSSlice *slice, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(region);
		return ((Device*)self)->clearTexture(*(Texture*)texture, *(const Region*)region, (slice) ? *(const Slice*)slice : Slice(), src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearTexture_cTcRp(TSDevice self, TSTexture texture, const TSRegion *region, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(region);
		return ((Device*)self)->clearTexture(*(Texture*)texture, *(const Region*)region, src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearTexture_cTcSp(TSDevice self, TSTexture texture, const TSSlice *slice, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->clearTexture(*(Texture*)texture, (slice) ? *(const Slice*)slice : Slice(), src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_clearTexture_cTp(TSDevice self, TSTexture texture, const void *src) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->clearTexture(*(Texture*)texture, src);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindTexture_cTcRucSubF(TSDevice self, TSTexture texture, const TSRegion *regions, uint32_t num_regions, const TSSlice *slices, uint32_t num_slices, bool_t commit, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(fence);
		return ((Device*)self)->bindTexture(*(Texture*)texture, *(const Region**)&regions, num_regions, *(const Slice**)&slices, num_slices, (bool)commit, *(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindTexture_cTcRucSub(TSDevice self, TSTexture texture, const TSRegion *regions, uint32_t num_regions, const TSSlice *slices, uint32_t num_slices, bool_t commit) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->bindTexture(*(Texture*)texture, *(const Region**)&regions, num_regions, *(const Slice**)&slices, num_slices, (bool)commit);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindTexture_cTcRcSbF(TSDevice self, TSTexture texture, const TSRegion *region, const TSSlice *slice, bool_t commit, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(region);
		TS_ASSERT(fence);
		return ((Device*)self)->bindTexture(*(Texture*)texture, *(const Region*)region, (slice) ? *(const Slice*)slice : Slice(), (bool)commit, *(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_bindTexture_cTcRcSb(TSDevice self, TSTexture texture, const TSRegion *region, const TSSlice *slice, bool_t commit) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		TS_ASSERT(region);
		return ((Device*)self)->bindTexture(*(Texture*)texture, *(const Region*)region, (slice) ? *(const Slice*)slice : Slice(), (bool)commit);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_createMipmaps_cTcS(TSDevice self, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->createMipmaps(*(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDevice_createMipmaps_cT(TSDevice self, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->createMipmaps(*(Texture*)texture);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushTexture_cTTF(TSDevice self, TSTexture texture, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->flushTexture(*(Texture*)texture, (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushTexture_cTcSTF(TSDevice self, TSTexture texture, const TSSlice *slice, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Device*)self)->flushTexture(*(Texture*)texture, (slice) ? *(const Slice*)slice : Slice(), (Texture::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushTextures_ccATTF(TSDevice self, const TSTexture *textures, uint32_t textures_size, TS_TextureFlags flags) {
		TS_ASSERT(self);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		return ((Device*)self)->flushTextures(textures_, (Texture::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsDevice_releaseTexture(TSDevice self, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((Device*)self)->releaseTexture(*(Texture*)texture);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTracing(TSDevice self, TSTracing tracing, const TSTracingInstance *instances, uint32_t num_instances) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		return ((Device*)self)->setTracing(*(Tracing*)tracing, *(const Tracing::Instance**)&instances, num_instances);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_buildTracing_cTBTF(TSDevice self, TSTracing tracing, TSBuffer buffer, TS_TracingFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		TS_ASSERT(buffer);
		return ((Device*)self)->buildTracing(*(Tracing*)tracing, *(Buffer*)buffer, (Tracing::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_buildTracing_cTBzTF(TSDevice self, TSTracing tracing, TSBuffer buffer, size_t offset, TS_TracingFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		TS_ASSERT(buffer);
		return ((Device*)self)->buildTracing(*(Tracing*)tracing, *(Buffer*)buffer, offset, (Tracing::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_buildTracings_ccATBTF(TSDevice self, const TSTracing *tracings, uint32_t tracings_size, TSBuffer buffer, TS_TracingFlags flags) {
		TS_ASSERT(self);
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		TS_ASSERT(buffer);
		return ((Device*)self)->buildTracings(tracings_, *(Buffer*)buffer, (Tracing::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_buildTracings_ccATBzTF(TSDevice self, const TSTracing *tracings, uint32_t tracings_size, TSBuffer buffer, size_t offset, TS_TracingFlags flags) {
		TS_ASSERT(self);
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		TS_ASSERT(buffer);
		return ((Device*)self)->buildTracings(tracings_, *(Buffer*)buffer, offset, (Tracing::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyTracing(TSDevice self, TSTracing tracing, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		TS_ASSERT(buffer);
		return ((Device*)self)->copyTracing(*(Tracing*)tracing, *(Buffer*)buffer, offset);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyTracings(TSDevice self, const TSTracing *tracings, uint32_t tracings_size, TSBuffer buffer, size_t offset, size_t stride) {
		TS_ASSERT(self);
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		TS_ASSERT(buffer);
		return ((Device*)self)->copyTracings(tracings_, *(Buffer*)buffer, offset, stride);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushTracing(TSDevice self, TSTracing tracing) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		return ((Device*)self)->flushTracing(*(Tracing*)tracing);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flushTracings(TSDevice self, const TSTracing *tracings, uint32_t tracings_size) {
		TS_ASSERT(self);
		Array<Tracing> tracings_(tracings_size);
		for(uint32_t i = 0; i < tracings_size; i++) if(tracings[i]) tracings_[i] = *(Tracing*)tracings[i];
		return ((Device*)self)->flushTracings(tracings_);
	}
	TS_CAPI void TS_CCALL tsDevice_releaseTracing(TSDevice self, TSTracing tracing) {
		TS_ASSERT(self);
		TS_ASSERT(tracing);
		((Device*)self)->releaseTracing(*(Tracing*)tracing);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setBufferTable_cBTuBb(TSDevice self, TSBufferTable table, uint32_t index, TSBuffer buffer, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		TS_ASSERT(buffer);
		return ((Device*)self)->setBufferTable(*(BufferTable*)table, index, *(Buffer*)buffer, (bool)owner);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setBufferTable_cBTucABb(TSDevice self, TSBufferTable table, uint32_t index, const TSBuffer *buffers, uint32_t buffers_size, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		Array<Buffer> buffers_(buffers_size);
		for(uint32_t i = 0; i < buffers_size; i++) if(buffers[i]) buffers_[i] = *(Buffer*)buffers[i];
		return ((Device*)self)->setBufferTable(*(BufferTable*)table, index, buffers_, (bool)owner);
	}
	TS_CAPI void TS_CCALL tsDevice_releaseBufferTable(TSDevice self, TSBufferTable table) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		((Device*)self)->releaseBufferTable(*(BufferTable*)table);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTextureTable_cTTuTb(TSDevice self, TSTextureTable table, uint32_t index, TSTexture texture, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		TS_ASSERT(texture);
		return ((Device*)self)->setTextureTable(*(TextureTable*)table, index, *(Texture*)texture, (bool)owner);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_setTextureTable_cTTucATb(TSDevice self, TSTextureTable table, uint32_t index, const TSTexture *textures, uint32_t textures_size, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		Array<Texture> textures_(textures_size);
		for(uint32_t i = 0; i < textures_size; i++) if(textures[i]) textures_[i] = *(Texture*)textures[i];
		return ((Device*)self)->setTextureTable(*(TextureTable*)table, index, textures_, (bool)owner);
	}
	TS_CAPI void TS_CCALL tsDevice_releaseTextureTable(TSDevice self, TSTextureTable table) {
		TS_ASSERT(self);
		TS_ASSERT(table);
		((Device*)self)->releaseTextureTable(*(TextureTable*)table);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_beginQuery(TSDevice self, TSQuery query) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		return ((Device*)self)->beginQuery(*(Query*)query);
	}
	TS_CAPI void TS_CCALL tsDevice_endQuery(TSDevice self, TSQuery query) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		((Device*)self)->endQuery(*(Query*)query);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyQuery(TSDevice self, TSQuery query, TSBuffer buffer, size_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(query);
		TS_ASSERT(buffer);
		return ((Device*)self)->copyQuery(*(Query*)query, *(Buffer*)buffer, offset);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_copyQueries_ccAQBzz(TSDevice self, const TSQuery *queries, uint32_t queries_size, TSBuffer buffer, size_t offset, size_t stride) {
		TS_ASSERT(self);
		Array<Query> queries_(queries_size);
		for(uint32_t i = 0; i < queries_size; i++) if(queries[i]) queries_[i] = *(Query*)queries[i];
		TS_ASSERT(buffer);
		return ((Device*)self)->copyQueries(queries_, *(Buffer*)buffer, offset, stride);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_waitFence(TSDevice self, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(fence);
		return ((Device*)self)->waitFence(*(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_signalFence(TSDevice self, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(fence);
		return ((Device*)self)->signalFence(*(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_execute(TSDevice self, TSDevice device) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((Device*)self)->execute(*(Device*)device);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flip_cF(TSDevice self, TSFence fence) {
		TS_ASSERT(self);
		TS_ASSERT(fence);
		return ((Device*)self)->flip(*(Fence*)fence);
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flip_c(TSDevice self) {
		TS_ASSERT(self);
		return ((Device*)self)->flip();
	}
	TS_CAPI bool_t TS_CCALL tsDevice_flush(TSDevice self) {
		TS_ASSERT(self);
		return ((Device*)self)->flush();
	}
	TS_CAPI bool_t TS_CCALL tsDevice_finish(TSDevice self) {
		TS_ASSERT(self);
		return ((Device*)self)->finish();
	}
	TS_CAPI bool_t TS_CCALL tsDevice_check(TSDevice self) {
		TS_ASSERT(self);
		return ((Device*)self)->check();
	}
	
	// Tellusim::D3D12Device
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_new(void) {
		D3D12Device *ret = new D3D12Device();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Device)ret;
	}
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_new_C(TSContext context) {
		TS_ASSERT(context);
		D3D12Device *ret = new D3D12Device(*(Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Device)ret;
	}
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_new_S(TSSurface surface) {
		TS_ASSERT(surface);
		D3D12Device *ret = new D3D12Device(*(Surface*)surface);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Device)ret;
	}
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_new_W(TSWindow window) {
		TS_ASSERT(window);
		D3D12Device *ret = new D3D12Device(*(Window*)window);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Device)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Device_delete(TSD3D12Device self) {
		if(self) delete (D3D12Device*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Device_equalPtr(const TSD3D12Device self, const TSD3D12Device ptr) {
		return (self && ptr && ((D3D12Device*)self)->operator==(*(D3D12Device*)ptr));
	}
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_copyPtr(TSD3D12Device self) {
		D3D12Device *ret = nullptr;
		if(self) ret = new D3D12Device(*(D3D12Device*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Device)ret;
	}
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_clonePtr(const TSD3D12Device self) {
		D3D12Device *ret = (self) ? new D3D12Device(((D3D12Device*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Device)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Device_clearPtr(TSD3D12Device self) {
		if(self) ((D3D12Device*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Device_destroyPtr(TSD3D12Device self) {
		if(self) ((D3D12Device*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Device_acquirePtr(TSD3D12Device self) {
		if(self) ((D3D12Device*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Device_unacquirePtr(TSD3D12Device self) {
		if(self) ((D3D12Device*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Device_isValidPtr(const TSD3D12Device self) {
		return (self && ((D3D12Device*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Device_isOwnerPtr(const TSD3D12Device self) {
		return (self && ((D3D12Device*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Device_isConstPtr(const TSD3D12Device self) {
		return (self && ((D3D12Device*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Device_getCountPtr(const TSD3D12Device self) {
		return ((D3D12Device*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Device_getInternalPtr(const TSD3D12Device self) {
		return ((D3D12Device*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Device_equalDevicePtr(const TSD3D12Device self, const TSDevice base) {
		return (self && base && ((D3D12Device*)self)->operator==(*(Device*)base));
	}
	TS_CAPI TSD3D12Device TS_CCALL tsD3D12Device_castDevicePtr(TSDevice base) {
		return (TSD3D12Device)(new D3D12Device(*(Device*)base));
	}
	TS_CAPI TSDevice TS_CCALL tsD3D12Device_baseDevicePtr(TSD3D12Device self) {
		return (TSDevice)(new Device(((D3D12Device*)self)->getDevice()));
	}
	TS_CAPI void TS_CCALL tsD3D12Device_setBufferState(TSD3D12Device self, TSBuffer buffer, uint32_t state) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((D3D12Device*)self)->setBufferState(*(Buffer*)buffer, state);
	}
	TS_CAPI void TS_CCALL tsD3D12Device_setTextureState(TSD3D12Device self, TSTexture texture, uint32_t state) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((D3D12Device*)self)->setTextureState(*(Texture*)texture, state);
	}
	TS_CAPI ID3D12Device* TS_CCALL tsD3D12Device_getD3D12Device(TSD3D12Device self) {
		TS_ASSERT(self);
		return ((D3D12Device*)self)->getD3D12Device();
	}
	TS_CAPI ID3D12CommandQueue* TS_CCALL tsD3D12Device_getQueue(TSD3D12Device self) {
		TS_ASSERT(self);
		return ((D3D12Device*)self)->getQueue();
	}
	TS_CAPI ID3D12GraphicsCommandList* TS_CCALL tsD3D12Device_getCommand(TSD3D12Device self) {
		TS_ASSERT(self);
		return ((D3D12Device*)self)->getCommand();
	}
	
	// Tellusim::D3D11Device
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_new(void) {
		D3D11Device *ret = new D3D11Device();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Device)ret;
	}
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_new_C(TSContext context) {
		TS_ASSERT(context);
		D3D11Device *ret = new D3D11Device(*(Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Device)ret;
	}
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_new_S(TSSurface surface) {
		TS_ASSERT(surface);
		D3D11Device *ret = new D3D11Device(*(Surface*)surface);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Device)ret;
	}
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_new_W(TSWindow window) {
		TS_ASSERT(window);
		D3D11Device *ret = new D3D11Device(*(Window*)window);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Device)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Device_delete(TSD3D11Device self) {
		if(self) delete (D3D11Device*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Device_equalPtr(const TSD3D11Device self, const TSD3D11Device ptr) {
		return (self && ptr && ((D3D11Device*)self)->operator==(*(D3D11Device*)ptr));
	}
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_copyPtr(TSD3D11Device self) {
		D3D11Device *ret = nullptr;
		if(self) ret = new D3D11Device(*(D3D11Device*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Device)ret;
	}
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_clonePtr(const TSD3D11Device self) {
		D3D11Device *ret = (self) ? new D3D11Device(((D3D11Device*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Device)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Device_clearPtr(TSD3D11Device self) {
		if(self) ((D3D11Device*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Device_destroyPtr(TSD3D11Device self) {
		if(self) ((D3D11Device*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Device_acquirePtr(TSD3D11Device self) {
		if(self) ((D3D11Device*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Device_unacquirePtr(TSD3D11Device self) {
		if(self) ((D3D11Device*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Device_isValidPtr(const TSD3D11Device self) {
		return (self && ((D3D11Device*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Device_isOwnerPtr(const TSD3D11Device self) {
		return (self && ((D3D11Device*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Device_isConstPtr(const TSD3D11Device self) {
		return (self && ((D3D11Device*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Device_getCountPtr(const TSD3D11Device self) {
		return ((D3D11Device*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Device_getInternalPtr(const TSD3D11Device self) {
		return ((D3D11Device*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Device_equalDevicePtr(const TSD3D11Device self, const TSDevice base) {
		return (self && base && ((D3D11Device*)self)->operator==(*(Device*)base));
	}
	TS_CAPI TSD3D11Device TS_CCALL tsD3D11Device_castDevicePtr(TSDevice base) {
		return (TSD3D11Device)(new D3D11Device(*(Device*)base));
	}
	TS_CAPI TSDevice TS_CCALL tsD3D11Device_baseDevicePtr(TSD3D11Device self) {
		return (TSDevice)(new Device(((D3D11Device*)self)->getDevice()));
	}
	TS_CAPI ID3D11Device* TS_CCALL tsD3D11Device_getD3D11Device(TSD3D11Device self) {
		TS_ASSERT(self);
		return ((D3D11Device*)self)->getD3D11Device();
	}
	TS_CAPI ID3D11DeviceContext* TS_CCALL tsD3D11Device_getCommand(TSD3D11Device self) {
		TS_ASSERT(self);
		return ((D3D11Device*)self)->getCommand();
	}
	
	// Tellusim::MTLDevice
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_new(void) {
		MTLDevice *ret = new MTLDevice();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLDevice)ret;
	}
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_new_C(TSContext context) {
		TS_ASSERT(context);
		MTLDevice *ret = new MTLDevice(*(Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLDevice)ret;
	}
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_new_S(TSSurface surface) {
		TS_ASSERT(surface);
		MTLDevice *ret = new MTLDevice(*(Surface*)surface);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLDevice)ret;
	}
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_new_W(TSWindow window) {
		TS_ASSERT(window);
		MTLDevice *ret = new MTLDevice(*(Window*)window);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLDevice)ret;
	}
	TS_CAPI void TS_CCALL tsMTLDevice_delete(TSMTLDevice self) {
		if(self) delete (MTLDevice*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLDevice_equalPtr(const TSMTLDevice self, const TSMTLDevice ptr) {
		return (self && ptr && ((MTLDevice*)self)->operator==(*(MTLDevice*)ptr));
	}
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_copyPtr(TSMTLDevice self) {
		MTLDevice *ret = nullptr;
		if(self) ret = new MTLDevice(*(MTLDevice*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLDevice)ret;
	}
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_clonePtr(const TSMTLDevice self) {
		MTLDevice *ret = (self) ? new MTLDevice(((MTLDevice*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLDevice)ret;
	}
	TS_CAPI void TS_CCALL tsMTLDevice_clearPtr(TSMTLDevice self) {
		if(self) ((MTLDevice*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLDevice_destroyPtr(TSMTLDevice self) {
		if(self) ((MTLDevice*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLDevice_acquirePtr(TSMTLDevice self) {
		if(self) ((MTLDevice*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLDevice_unacquirePtr(TSMTLDevice self) {
		if(self) ((MTLDevice*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLDevice_isValidPtr(const TSMTLDevice self) {
		return (self && ((MTLDevice*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLDevice_isOwnerPtr(const TSMTLDevice self) {
		return (self && ((MTLDevice*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLDevice_isConstPtr(const TSMTLDevice self) {
		return (self && ((MTLDevice*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLDevice_getCountPtr(const TSMTLDevice self) {
		return ((MTLDevice*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLDevice_getInternalPtr(const TSMTLDevice self) {
		return ((MTLDevice*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLDevice_equalDevicePtr(const TSMTLDevice self, const TSDevice base) {
		return (self && base && ((MTLDevice*)self)->operator==(*(Device*)base));
	}
	TS_CAPI TSMTLDevice TS_CCALL tsMTLDevice_castDevicePtr(TSDevice base) {
		return (TSMTLDevice)(new MTLDevice(*(Device*)base));
	}
	TS_CAPI TSDevice TS_CCALL tsMTLDevice_baseDevicePtr(TSMTLDevice self) {
		return (TSDevice)(new Device(((MTLDevice*)self)->getDevice()));
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getMTLDevice(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getMTLDevice();
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getQueue(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getQueue();
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getCommand(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getCommand();
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getEncoder(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getEncoder();
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getRenderEncoder(TSMTLDevice self, void *descriptor) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getRenderEncoder(descriptor);
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getComputeEncoder(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getComputeEncoder();
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getTracingEncoder(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getTracingEncoder();
	}
	TS_CAPI void* TS_CCALL tsMTLDevice_getBlitEncoder(TSMTLDevice self) {
		TS_ASSERT(self);
		return ((MTLDevice*)self)->getBlitEncoder();
	}
	TS_CAPI void TS_CCALL tsMTLDevice_endEncoder(TSMTLDevice self) {
		TS_ASSERT(self);
		((MTLDevice*)self)->endEncoder();
	}
	
	// Tellusim::VKDevice
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_new(void) {
		VKDevice *ret = new VKDevice();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKDevice)ret;
	}
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_new_C(TSContext context) {
		TS_ASSERT(context);
		VKDevice *ret = new VKDevice(*(Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKDevice)ret;
	}
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_new_S(TSSurface surface) {
		TS_ASSERT(surface);
		VKDevice *ret = new VKDevice(*(Surface*)surface);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKDevice)ret;
	}
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_new_W(TSWindow window) {
		TS_ASSERT(window);
		VKDevice *ret = new VKDevice(*(Window*)window);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKDevice)ret;
	}
	TS_CAPI void TS_CCALL tsVKDevice_delete(TSVKDevice self) {
		if(self) delete (VKDevice*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_equalPtr(const TSVKDevice self, const TSVKDevice ptr) {
		return (self && ptr && ((VKDevice*)self)->operator==(*(VKDevice*)ptr));
	}
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_copyPtr(TSVKDevice self) {
		VKDevice *ret = nullptr;
		if(self) ret = new VKDevice(*(VKDevice*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKDevice)ret;
	}
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_clonePtr(const TSVKDevice self) {
		VKDevice *ret = (self) ? new VKDevice(((VKDevice*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKDevice)ret;
	}
	TS_CAPI void TS_CCALL tsVKDevice_clearPtr(TSVKDevice self) {
		if(self) ((VKDevice*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKDevice_destroyPtr(TSVKDevice self) {
		if(self) ((VKDevice*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKDevice_acquirePtr(TSVKDevice self) {
		if(self) ((VKDevice*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKDevice_unacquirePtr(TSVKDevice self) {
		if(self) ((VKDevice*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_isValidPtr(const TSVKDevice self) {
		return (self && ((VKDevice*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_isOwnerPtr(const TSVKDevice self) {
		return (self && ((VKDevice*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_isConstPtr(const TSVKDevice self) {
		return (self && ((VKDevice*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKDevice_getCountPtr(const TSVKDevice self) {
		return ((VKDevice*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKDevice_getInternalPtr(const TSVKDevice self) {
		return ((VKDevice*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_equalDevicePtr(const TSVKDevice self, const TSDevice base) {
		return (self && base && ((VKDevice*)self)->operator==(*(Device*)base));
	}
	TS_CAPI TSVKDevice TS_CCALL tsVKDevice_castDevicePtr(TSDevice base) {
		return (TSVKDevice)(new VKDevice(*(Device*)base));
	}
	TS_CAPI TSDevice TS_CCALL tsVKDevice_baseDevicePtr(TSVKDevice self) {
		return (TSDevice)(new Device(((VKDevice*)self)->getDevice()));
	}
	TS_CAPI void TS_CCALL tsVKDevice_setBufferAccess(TSVKDevice self, TSBuffer buffer, uint32_t access) {
		TS_ASSERT(self);
		TS_ASSERT(buffer);
		((VKDevice*)self)->setBufferAccess(*(Buffer*)buffer, access);
	}
	TS_CAPI void TS_CCALL tsVKDevice_setTextureLayout(TSVKDevice self, TSTexture texture, uint32_t layout) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((VKDevice*)self)->setTextureLayout(*(Texture*)texture, layout);
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_waitVKFence(TSVKDevice self, void *fence, uint64_t timeout, bool_t reset) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->waitVKFence(fence, timeout, (bool)reset);
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_signalVKFence(TSVKDevice self, void *fence) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->signalVKFence(fence);
	}
	TS_CAPI void TS_CCALL tsVKDevice_waitSemaphore(TSVKDevice self, void *semaphore, uint32_t mask) {
		TS_ASSERT(self);
		((VKDevice*)self)->waitSemaphore(semaphore, mask);
	}
	TS_CAPI void TS_CCALL tsVKDevice_signalSemaphore(TSVKDevice self, void *semaphore) {
		TS_ASSERT(self);
		((VKDevice*)self)->signalSemaphore(semaphore);
	}
	TS_CAPI bool_t TS_CCALL tsVKDevice_hasMemoryType(TSVKDevice self, uint32_t flags) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->hasMemoryType(flags);
	}
	TS_CAPI uint32_t TS_CCALL tsVKDevice_getMemoryIndex(TSVKDevice self, uint32_t types, uint32_t flags) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getMemoryIndex(types, flags);
	}
	TS_CAPI VkInstance TS_CCALL tsVKDevice_getInstance(TSVKDevice self) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getInstance();
	}
	TS_CAPI VkPhysicalDevice TS_CCALL tsVKDevice_getAdapter(TSVKDevice self) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getAdapter();
	}
	TS_CAPI VkDevice TS_CCALL tsVKDevice_getVKDevice(TSVKDevice self) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getVKDevice();
	}
	TS_CAPI VkQueue TS_CCALL tsVKDevice_getQueue(TSVKDevice self) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getQueue();
	}
	TS_CAPI VkCommandBuffer TS_CCALL tsVKDevice_getCommand(TSVKDevice self) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getCommand();
	}
	TS_CAPI uint32_t TS_CCALL tsVKDevice_getFamily(TSVKDevice self) {
		TS_ASSERT(self);
		return ((VKDevice*)self)->getFamily();
	}
	
	// Tellusim::FUDevice
	TS_CAPI TSFUDevice TS_CCALL tsFUDevice_new(void) {
		FUDevice *ret = new FUDevice();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUDevice)ret;
	}
	TS_CAPI TSFUDevice TS_CCALL tsFUDevice_new_cADb(const TSDevice *devices, uint32_t devices_size, bool_t owner) {
		Array<Device> devices_(devices_size);
		for(uint32_t i = 0; i < devices_size; i++) if(devices[i]) devices_[i] = *(Device*)devices[i];
		FUDevice *ret = new FUDevice(devices_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUDevice)ret;
	}
	TS_CAPI void TS_CCALL tsFUDevice_delete(TSFUDevice self) {
		if(self) delete (FUDevice*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUDevice_equalPtr(const TSFUDevice self, const TSFUDevice ptr) {
		return (self && ptr && ((FUDevice*)self)->operator==(*(FUDevice*)ptr));
	}
	TS_CAPI TSFUDevice TS_CCALL tsFUDevice_copyPtr(TSFUDevice self) {
		FUDevice *ret = nullptr;
		if(self) ret = new FUDevice(*(FUDevice*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUDevice)ret;
	}
	TS_CAPI TSFUDevice TS_CCALL tsFUDevice_clonePtr(const TSFUDevice self) {
		FUDevice *ret = (self) ? new FUDevice(((FUDevice*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUDevice)ret;
	}
	TS_CAPI void TS_CCALL tsFUDevice_clearPtr(TSFUDevice self) {
		if(self) ((FUDevice*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUDevice_destroyPtr(TSFUDevice self) {
		if(self) ((FUDevice*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUDevice_acquirePtr(TSFUDevice self) {
		if(self) ((FUDevice*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUDevice_unacquirePtr(TSFUDevice self) {
		if(self) ((FUDevice*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUDevice_isValidPtr(const TSFUDevice self) {
		return (self && ((FUDevice*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUDevice_isOwnerPtr(const TSFUDevice self) {
		return (self && ((FUDevice*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUDevice_isConstPtr(const TSFUDevice self) {
		return (self && ((FUDevice*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUDevice_getCountPtr(const TSFUDevice self) {
		return ((FUDevice*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUDevice_getInternalPtr(const TSFUDevice self) {
		return ((FUDevice*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUDevice_equalDevicePtr(const TSFUDevice self, const TSDevice base) {
		return (self && base && ((FUDevice*)self)->operator==(*(Device*)base));
	}
	TS_CAPI TSFUDevice TS_CCALL tsFUDevice_castDevicePtr(TSDevice base) {
		return (TSFUDevice)(new FUDevice(*(Device*)base));
	}
	TS_CAPI TSDevice TS_CCALL tsFUDevice_baseDevicePtr(TSFUDevice self) {
		return (TSDevice)(new Device(((FUDevice*)self)->getDevice()));
	}
	TS_CAPI void TS_CCALL tsFUDevice_setMask(TSFUDevice self, uint32_t mask) {
		TS_ASSERT(self);
		((FUDevice*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUDevice_getMask(TSFUDevice self) {
		TS_ASSERT(self);
		return ((FUDevice*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUDevice_getNumDevices(TSFUDevice self) {
		TS_ASSERT(self);
		return ((FUDevice*)self)->getNumDevices();
	}
	TS_CAPI TSDevice TS_CCALL tsFUDevice_getDevice_cu(TSFUDevice self, uint32_t index) {
		TS_ASSERT(self);
		return (TSDevice)(new Device(((FUDevice*)self)->getDevice(index)));
	}
	TS_CAPI TSDevice TS_CCALL tsFUDevice_getDevice_u(TSFUDevice self, uint32_t index) {
		TS_ASSERT(self);
		return (TSDevice)(new Device(((FUDevice*)self)->getDevice(index)));
	}
	
	// Tellusim::Kernel
	TS_CAPI TSKernel TS_CCALL tsKernel_new(void) {
		Kernel *ret = new Kernel();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSKernel)ret;
	}
	TS_CAPI void TS_CCALL tsKernel_delete(TSKernel self) {
		if(self) delete (Kernel*)self;
	}
	TS_CAPI bool_t TS_CCALL tsKernel_equalPtr(const TSKernel self, const TSKernel ptr) {
		return (self && ptr && ((Kernel*)self)->operator==(*(Kernel*)ptr));
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_copyPtr(TSKernel self) {
		Kernel *ret = nullptr;
		if(self) ret = new Kernel(*(Kernel*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSKernel)ret;
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_clonePtr(const TSKernel self) {
		Kernel *ret = (self) ? new Kernel(((Kernel*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSKernel)ret;
	}
	TS_CAPI void TS_CCALL tsKernel_clearPtr(TSKernel self) {
		if(self) ((Kernel*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsKernel_destroyPtr(TSKernel self) {
		if(self) ((Kernel*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsKernel_acquirePtr(TSKernel self) {
		if(self) ((Kernel*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsKernel_unacquirePtr(TSKernel self) {
		if(self) ((Kernel*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsKernel_isValidPtr(const TSKernel self) {
		return (self && ((Kernel*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsKernel_isOwnerPtr(const TSKernel self) {
		return (self && ((Kernel*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsKernel_isConstPtr(const TSKernel self) {
		return (self && ((Kernel*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getCountPtr(const TSKernel self) {
		return ((Kernel*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsKernel_getInternalPtr(const TSKernel self) {
		return ((Kernel*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsKernel_getPlatform(TSKernel self) {
		TS_ASSERT(self);
		return (TS_Platform)((Kernel*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsKernel_getPlatformName(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getIndex(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsKernel_clear(TSKernel self) {
		TS_ASSERT(self);
		((Kernel*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsKernel_isCreated(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsKernel_setName(TSKernel self, const char *name) {
		TS_ASSERT(self);
		((Kernel*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsKernel_getName(TSKernel self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Kernel*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsKernel_create(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->create();
	}
	TS_CAPI void TS_CCALL tsKernel_setParameters(TSKernel self, const TSKernel kernel) {
		TS_ASSERT(self);
		TS_ASSERT(kernel);
		((Kernel*)self)->setParameters(*(const Kernel*)kernel);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_saveState(TSKernel self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Kernel*)self)->saveState(*(Stream*)stream);
	}
	TS_CAPI void TS_CCALL tsKernel_setShader(TSKernel self, TSShader shader, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(shader);
		((Kernel*)self)->setShader(*(Shader*)shader, (bool)owner);
	}
	TS_CAPI TSShader TS_CCALL tsKernel_getComputeShader(TSKernel self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Kernel*)self)->getComputeShader()));
	}
	TS_CAPI bool_t TS_CCALL tsKernel_loadShader_ss(TSKernel self, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Kernel*)self)->loadShader(name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_loadShaderGLSL_ss(TSKernel self, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Kernel*)self)->loadShaderGLSL(name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_loadShader_scSspu(TSKernel self, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Kernel*)self)->loadShader(name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_loadShaderGLSL_scSspu(TSKernel self, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Kernel*)self)->loadShaderGLSL(name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_loadShaderSPIRV(TSKernel self, const char *name) {
		TS_ASSERT(self);
		return ((Kernel*)self)->loadShaderSPIRV(name);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_createShader_ss(TSKernel self, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Kernel*)self)->createShader(src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_createShaderGLSL_ss(TSKernel self, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Kernel*)self)->createShaderGLSL(src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_createShader_scSspu(TSKernel self, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Kernel*)self)->createShader(src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_createShaderGLSL_scSspu(TSKernel self, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Kernel*)self)->createShaderGLSL(src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsKernel_createShaderSPIRV(TSKernel self, const uint32_t *data, uint32_t data_size) {
		TS_ASSERT(self);
		Array<uint32_t> data_(data_size, data);
		return ((Kernel*)self)->createShaderSPIRV(data_);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addSampler(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addSampler();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setSamplers(TSKernel self, uint32_t num) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setSamplers(num)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumSamplers(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumSamplers();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setSamplerOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setSamplerOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getSamplerOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getSamplerOffset();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setSamplerArray(TSKernel self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setSamplerArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getSamplerArray(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getSamplerArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addTexture(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addTexture();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTextures(TSKernel self, uint32_t num) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTextures(num)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumTextures(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumTextures();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTextureOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTextureOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getTextureOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getTextureOffset();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTextureArray(TSKernel self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTextureArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getTextureArray(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getTextureArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addSurface(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addSurface();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setSurfaces(TSKernel self, uint32_t num) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setSurfaces(num)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumSurfaces(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumSurfaces();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setSurfaceOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setSurfaceOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getSurfaceOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getSurfaceOffset();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setSurfaceArray(TSKernel self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setSurfaceArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getSurfaceArray(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getSurfaceArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addUniform(TSKernel self, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addUniform((BindFlags)flags);
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setUniforms(TSKernel self, uint32_t num, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setUniforms(num, (BindFlags)flags)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumUniforms(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumUniforms();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setUniformOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setUniformOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getUniformOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getUniformOffset();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setUniformFlags(TSKernel self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setUniformFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsKernel_getUniformFlags(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Kernel*)self)->getUniformFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addStorage(TSKernel self, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addStorage((BindFlags)flags);
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setStorages(TSKernel self, uint32_t num, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setStorages(num, (BindFlags)flags)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumStorages(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumStorages();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setStorageOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setStorageOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getStorageOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getStorageOffset();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setStorageFlags(TSKernel self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setStorageFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsKernel_getStorageFlags(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Kernel*)self)->getStorageFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addTracing(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addTracing();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTracings(TSKernel self, uint32_t num) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTracings(num)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumTracings(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumTracings();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTracingOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTracingOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getTracingOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getTracingOffset();
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addTexel(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addTexel();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTexels(TSKernel self, uint32_t num) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTexels(num)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumTexels(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumTexels();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTexelOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTexelOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getTexelOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getTexelOffset();
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_addTable(TSKernel self, TS_TableType type, uint32_t size) {
		TS_ASSERT(self);
		return ((Kernel*)self)->addTable((TableType)type, size);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getNumTables(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getNumTables();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTableOffset(TSKernel self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTableOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getTableOffset(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getTableOffset();
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTableType(TSKernel self, uint32_t index, TS_TableType type, uint32_t size, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTableType(index, (TableType)type, size, (BindFlags)flags)));
	}
	TS_CAPI TS_TableType TS_CCALL tsKernel_getTableType(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_TableType)((Kernel*)self)->getTableType(index);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getTableSize(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getTableSize(index);
	}
	TS_CAPI TSKernel TS_CCALL tsKernel_setTableFlags(TSKernel self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((Kernel*)self)->setTableFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsKernel_getTableFlags(TSKernel self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Kernel*)self)->getTableFlags(index);
	}
	TS_CAPI void TS_CCALL tsKernel_setGroupSize(TSKernel self, uint32_t width, uint32_t height, uint32_t depth) {
		TS_ASSERT(self);
		((Kernel*)self)->setGroupSize(width, height, depth);
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getGroupSizeX(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getGroupSizeX();
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getGroupSizeY(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getGroupSizeY();
	}
	TS_CAPI uint32_t TS_CCALL tsKernel_getGroupSizeZ(TSKernel self) {
		TS_ASSERT(self);
		return ((Kernel*)self)->getGroupSizeZ();
	}
	
	// Tellusim::D3D12Kernel
	TS_CAPI TSD3D12Kernel TS_CCALL tsD3D12Kernel_new(void) {
		D3D12Kernel *ret = new D3D12Kernel();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Kernel)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Kernel_delete(TSD3D12Kernel self) {
		if(self) delete (D3D12Kernel*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Kernel_equalPtr(const TSD3D12Kernel self, const TSD3D12Kernel ptr) {
		return (self && ptr && ((D3D12Kernel*)self)->operator==(*(D3D12Kernel*)ptr));
	}
	TS_CAPI TSD3D12Kernel TS_CCALL tsD3D12Kernel_copyPtr(TSD3D12Kernel self) {
		D3D12Kernel *ret = nullptr;
		if(self) ret = new D3D12Kernel(*(D3D12Kernel*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Kernel)ret;
	}
	TS_CAPI TSD3D12Kernel TS_CCALL tsD3D12Kernel_clonePtr(const TSD3D12Kernel self) {
		D3D12Kernel *ret = (self) ? new D3D12Kernel(((D3D12Kernel*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Kernel)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Kernel_clearPtr(TSD3D12Kernel self) {
		if(self) ((D3D12Kernel*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Kernel_destroyPtr(TSD3D12Kernel self) {
		if(self) ((D3D12Kernel*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Kernel_acquirePtr(TSD3D12Kernel self) {
		if(self) ((D3D12Kernel*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Kernel_unacquirePtr(TSD3D12Kernel self) {
		if(self) ((D3D12Kernel*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Kernel_isValidPtr(const TSD3D12Kernel self) {
		return (self && ((D3D12Kernel*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Kernel_isOwnerPtr(const TSD3D12Kernel self) {
		return (self && ((D3D12Kernel*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Kernel_isConstPtr(const TSD3D12Kernel self) {
		return (self && ((D3D12Kernel*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Kernel_getCountPtr(const TSD3D12Kernel self) {
		return ((D3D12Kernel*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Kernel_getInternalPtr(const TSD3D12Kernel self) {
		return ((D3D12Kernel*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Kernel_equalKernelPtr(const TSD3D12Kernel self, const TSKernel base) {
		return (self && base && ((D3D12Kernel*)self)->operator==(*(Kernel*)base));
	}
	TS_CAPI TSD3D12Kernel TS_CCALL tsD3D12Kernel_castKernelPtr(TSKernel base) {
		return (TSD3D12Kernel)(new D3D12Kernel(*(Kernel*)base));
	}
	TS_CAPI TSKernel TS_CCALL tsD3D12Kernel_baseKernelPtr(TSD3D12Kernel self) {
		return (TSKernel)(new Kernel(((D3D12Kernel*)self)->getKernel()));
	}
	TS_CAPI ID3D12RootSignature* TS_CCALL tsD3D12Kernel_getRootSignature(TSD3D12Kernel self) {
		TS_ASSERT(self);
		return ((D3D12Kernel*)self)->getRootSignature();
	}
	
	// Tellusim::MTLKernel
	TS_CAPI TSMTLKernel TS_CCALL tsMTLKernel_new(void) {
		MTLKernel *ret = new MTLKernel();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLKernel)ret;
	}
	TS_CAPI void TS_CCALL tsMTLKernel_delete(TSMTLKernel self) {
		if(self) delete (MTLKernel*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLKernel_equalPtr(const TSMTLKernel self, const TSMTLKernel ptr) {
		return (self && ptr && ((MTLKernel*)self)->operator==(*(MTLKernel*)ptr));
	}
	TS_CAPI TSMTLKernel TS_CCALL tsMTLKernel_copyPtr(TSMTLKernel self) {
		MTLKernel *ret = nullptr;
		if(self) ret = new MTLKernel(*(MTLKernel*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLKernel)ret;
	}
	TS_CAPI TSMTLKernel TS_CCALL tsMTLKernel_clonePtr(const TSMTLKernel self) {
		MTLKernel *ret = (self) ? new MTLKernel(((MTLKernel*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLKernel)ret;
	}
	TS_CAPI void TS_CCALL tsMTLKernel_clearPtr(TSMTLKernel self) {
		if(self) ((MTLKernel*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLKernel_destroyPtr(TSMTLKernel self) {
		if(self) ((MTLKernel*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLKernel_acquirePtr(TSMTLKernel self) {
		if(self) ((MTLKernel*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLKernel_unacquirePtr(TSMTLKernel self) {
		if(self) ((MTLKernel*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLKernel_isValidPtr(const TSMTLKernel self) {
		return (self && ((MTLKernel*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLKernel_isOwnerPtr(const TSMTLKernel self) {
		return (self && ((MTLKernel*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLKernel_isConstPtr(const TSMTLKernel self) {
		return (self && ((MTLKernel*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLKernel_getCountPtr(const TSMTLKernel self) {
		return ((MTLKernel*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLKernel_getInternalPtr(const TSMTLKernel self) {
		return ((MTLKernel*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLKernel_equalKernelPtr(const TSMTLKernel self, const TSKernel base) {
		return (self && base && ((MTLKernel*)self)->operator==(*(Kernel*)base));
	}
	TS_CAPI TSMTLKernel TS_CCALL tsMTLKernel_castKernelPtr(TSKernel base) {
		return (TSMTLKernel)(new MTLKernel(*(Kernel*)base));
	}
	TS_CAPI TSKernel TS_CCALL tsMTLKernel_baseKernelPtr(TSMTLKernel self) {
		return (TSKernel)(new Kernel(((MTLKernel*)self)->getKernel()));
	}
	TS_CAPI void TS_CCALL tsMTLKernel_setIndirect(TSMTLKernel self, bool_t enabled) {
		TS_ASSERT(self);
		((MTLKernel*)self)->setIndirect((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsMTLKernel_isIndirect(TSMTLKernel self) {
		TS_ASSERT(self);
		return ((MTLKernel*)self)->isIndirect();
	}
	TS_CAPI void* TS_CCALL tsMTLKernel_getComputeFunction(TSMTLKernel self) {
		TS_ASSERT(self);
		return ((MTLKernel*)self)->getComputeFunction();
	}
	
	// Tellusim::FUKernel
	TS_CAPI TSFUKernel TS_CCALL tsFUKernel_new(void) {
		FUKernel *ret = new FUKernel();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUKernel)ret;
	}
	TS_CAPI TSFUKernel TS_CCALL tsFUKernel_new_cAKb(const TSKernel *kernels, uint32_t kernels_size, bool_t owner) {
		Array<Kernel> kernels_(kernels_size);
		for(uint32_t i = 0; i < kernels_size; i++) if(kernels[i]) kernels_[i] = *(Kernel*)kernels[i];
		FUKernel *ret = new FUKernel(kernels_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUKernel)ret;
	}
	TS_CAPI void TS_CCALL tsFUKernel_delete(TSFUKernel self) {
		if(self) delete (FUKernel*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUKernel_equalPtr(const TSFUKernel self, const TSFUKernel ptr) {
		return (self && ptr && ((FUKernel*)self)->operator==(*(FUKernel*)ptr));
	}
	TS_CAPI TSFUKernel TS_CCALL tsFUKernel_copyPtr(TSFUKernel self) {
		FUKernel *ret = nullptr;
		if(self) ret = new FUKernel(*(FUKernel*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUKernel)ret;
	}
	TS_CAPI TSFUKernel TS_CCALL tsFUKernel_clonePtr(const TSFUKernel self) {
		FUKernel *ret = (self) ? new FUKernel(((FUKernel*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUKernel)ret;
	}
	TS_CAPI void TS_CCALL tsFUKernel_clearPtr(TSFUKernel self) {
		if(self) ((FUKernel*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUKernel_destroyPtr(TSFUKernel self) {
		if(self) ((FUKernel*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUKernel_acquirePtr(TSFUKernel self) {
		if(self) ((FUKernel*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUKernel_unacquirePtr(TSFUKernel self) {
		if(self) ((FUKernel*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUKernel_isValidPtr(const TSFUKernel self) {
		return (self && ((FUKernel*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUKernel_isOwnerPtr(const TSFUKernel self) {
		return (self && ((FUKernel*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUKernel_isConstPtr(const TSFUKernel self) {
		return (self && ((FUKernel*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUKernel_getCountPtr(const TSFUKernel self) {
		return ((FUKernel*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUKernel_getInternalPtr(const TSFUKernel self) {
		return ((FUKernel*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUKernel_equalKernelPtr(const TSFUKernel self, const TSKernel base) {
		return (self && base && ((FUKernel*)self)->operator==(*(Kernel*)base));
	}
	TS_CAPI TSFUKernel TS_CCALL tsFUKernel_castKernelPtr(TSKernel base) {
		return (TSFUKernel)(new FUKernel(*(Kernel*)base));
	}
	TS_CAPI TSKernel TS_CCALL tsFUKernel_baseKernelPtr(TSFUKernel self) {
		return (TSKernel)(new Kernel(((FUKernel*)self)->getKernel()));
	}
	TS_CAPI void TS_CCALL tsFUKernel_setMask(TSFUKernel self, uint32_t mask) {
		TS_ASSERT(self);
		((FUKernel*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUKernel_getMask(TSFUKernel self) {
		TS_ASSERT(self);
		return ((FUKernel*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUKernel_getNumKernels(TSFUKernel self) {
		TS_ASSERT(self);
		return ((FUKernel*)self)->getNumKernels();
	}
	TS_CAPI TSKernel TS_CCALL tsFUKernel_getKernel_cu(TSFUKernel self, uint32_t index) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((FUKernel*)self)->getKernel(index)));
	}
	TS_CAPI TSKernel TS_CCALL tsFUKernel_getKernel_u(TSFUKernel self, uint32_t index) {
		TS_ASSERT(self);
		return (TSKernel)(new Kernel(((FUKernel*)self)->getKernel(index)));
	}
	
	// Tellusim::Pipeline
	TS_CAPI TSPipeline TS_CCALL tsPipeline_new(void) {
		Pipeline *ret = new Pipeline();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSPipeline)ret;
	}
	TS_CAPI void TS_CCALL tsPipeline_delete(TSPipeline self) {
		if(self) delete (Pipeline*)self;
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_equalPtr(const TSPipeline self, const TSPipeline ptr) {
		return (self && ptr && ((Pipeline*)self)->operator==(*(Pipeline*)ptr));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_copyPtr(TSPipeline self) {
		Pipeline *ret = nullptr;
		if(self) ret = new Pipeline(*(Pipeline*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSPipeline)ret;
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_clonePtr(const TSPipeline self) {
		Pipeline *ret = (self) ? new Pipeline(((Pipeline*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSPipeline)ret;
	}
	TS_CAPI void TS_CCALL tsPipeline_clearPtr(TSPipeline self) {
		if(self) ((Pipeline*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsPipeline_destroyPtr(TSPipeline self) {
		if(self) ((Pipeline*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsPipeline_acquirePtr(TSPipeline self) {
		if(self) ((Pipeline*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsPipeline_unacquirePtr(TSPipeline self) {
		if(self) ((Pipeline*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_isValidPtr(const TSPipeline self) {
		return (self && ((Pipeline*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_isOwnerPtr(const TSPipeline self) {
		return (self && ((Pipeline*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_isConstPtr(const TSPipeline self) {
		return (self && ((Pipeline*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getCountPtr(const TSPipeline self) {
		return ((Pipeline*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsPipeline_getInternalPtr(const TSPipeline self) {
		return ((Pipeline*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsPipeline_getPlatform(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_Platform)((Pipeline*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsPipeline_getPlatformName(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getIndex(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsPipeline_clear(TSPipeline self) {
		TS_ASSERT(self);
		((Pipeline*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_isCreated(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsPipeline_setName(TSPipeline self, const char *name) {
		TS_ASSERT(self);
		((Pipeline*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsPipeline_getName(TSPipeline self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Pipeline*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_create(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->create();
	}
	TS_CAPI void TS_CCALL tsPipeline_setParameters(TSPipeline self, const TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((Pipeline*)self)->setParameters(*(const Pipeline*)pipeline);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_saveState(TSPipeline self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Pipeline*)self)->saveState(*(Stream*)stream);
	}
	TS_CAPI void TS_CCALL tsPipeline_addShader(TSPipeline self, TSShader shader, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(shader);
		((Pipeline*)self)->addShader(*(Shader*)shader, (bool)owner);
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getVertexShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getVertexShader()));
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getControlShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getControlShader()));
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getEvaluateShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getEvaluateShader()));
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getGeometryShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getGeometryShader()));
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getFragmentShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getFragmentShader()));
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getTaskShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getTaskShader()));
	}
	TS_CAPI TSShader TS_CCALL tsPipeline_getMeshShader(TSPipeline self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Pipeline*)self)->getMeshShader()));
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_loadShader_STss(TSPipeline self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->loadShader((Shader::Type)type, name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_loadShaderGLSL_STss(TSPipeline self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->loadShaderGLSL((Shader::Type)type, name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_loadShader_STscSspu(TSPipeline self, TS_ShaderType type, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->loadShader((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_loadShaderGLSL_STscSspu(TSPipeline self, TS_ShaderType type, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->loadShaderGLSL((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_loadShaderSPIRV(TSPipeline self, TS_ShaderType type, const char *name) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->loadShaderSPIRV((Shader::Type)type, name);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_createShader_STss(TSPipeline self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->createShader((Shader::Type)type, src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_createShaderGLSL_STss(TSPipeline self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->createShaderGLSL((Shader::Type)type, src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_createShader_STscSspu(TSPipeline self, TS_ShaderType type, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->createShader((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_createShaderGLSL_STscSspu(TSPipeline self, TS_ShaderType type, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->createShaderGLSL((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_createShaderSPIRV(TSPipeline self, TS_ShaderType type, const uint32_t *data, uint32_t data_size) {
		TS_ASSERT(self);
		Array<uint32_t> data_(data_size, data);
		return ((Pipeline*)self)->createShaderSPIRV((Shader::Type)type, data_);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addSampler(TSPipeline self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addSampler((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumSamplers(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumSamplers();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSamplerOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSamplerOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getSamplerOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getSamplerOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSamplerMask(TSPipeline self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSamplerMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getSamplerMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getSamplerMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSamplerMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask, bool_t array) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSamplerMasks(index, num, (Shader::Mask)mask, (bool)array)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getSamplerMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getSamplerMasks(index, num);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSamplerArray(TSPipeline self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSamplerArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getSamplerArray(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getSamplerArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addTexture(TSPipeline self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addTexture((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumTextures(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumTextures();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTextureOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTextureOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getTextureOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getTextureOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTextureMask(TSPipeline self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTextureMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTextureMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTextureMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTextureMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask, bool_t array) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTextureMasks(index, num, (Shader::Mask)mask, (bool)array)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTextureMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTextureMasks(index, num);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTextureArray(TSPipeline self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTextureArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getTextureArray(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getTextureArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addSurface(TSPipeline self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addSurface((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumSurfaces(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumSurfaces();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSurfaceOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSurfaceOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getSurfaceOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getSurfaceOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSurfaceMask(TSPipeline self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSurfaceMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getSurfaceMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getSurfaceMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSurfaceMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask, bool_t array) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSurfaceMasks(index, num, (Shader::Mask)mask, (bool)array)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getSurfaceMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getSurfaceMasks(index, num);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setSurfaceArray(TSPipeline self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setSurfaceArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getSurfaceArray(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getSurfaceArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addUniform(TSPipeline self, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addUniform((Shader::Mask)mask, (BindFlags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumUniforms(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumUniforms();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setUniformOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setUniformOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getUniformOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getUniformOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setUniformMask(TSPipeline self, uint32_t index, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setUniformMask(index, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getUniformMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getUniformMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setUniformMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setUniformMasks(index, num, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getUniformMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getUniformMasks(index, num);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setUniformFlags(TSPipeline self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setUniformFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsPipeline_getUniformFlags(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Pipeline*)self)->getUniformFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addStorage(TSPipeline self, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addStorage((Shader::Mask)mask, (BindFlags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumStorages(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumStorages();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setStorageOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setStorageOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getStorageOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getStorageOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setStorageMask(TSPipeline self, uint32_t index, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setStorageMask(index, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getStorageMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getStorageMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setStorageMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setStorageMasks(index, num, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getStorageMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getStorageMasks(index, num);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setStorageFlags(TSPipeline self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setStorageFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsPipeline_getStorageFlags(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Pipeline*)self)->getStorageFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addTracing(TSPipeline self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addTracing((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumTracings(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumTracings();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTracingOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTracingOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getTracingOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getTracingOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTracingMask(TSPipeline self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTracingMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTracingMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTracingMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTracingMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTracingMasks(index, num, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTracingMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTracingMasks(index, num);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addTexel(TSPipeline self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addTexel((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumTexels(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumTexels();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTexelOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTexelOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getTexelOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getTexelOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTexelMask(TSPipeline self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTexelMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTexelMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTexelMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTexelMasks(TSPipeline self, uint32_t index, uint32_t num, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTexelMasks(index, num, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTexelMasks(TSPipeline self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTexelMasks(index, num);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addTable(TSPipeline self, TS_TableType type, uint32_t size, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addTable((TableType)type, size, (Shader::Mask)mask, (BindFlags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumTables(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumTables();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTableOffset(TSPipeline self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTableOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getTableOffset(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getTableOffset();
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTableType(TSPipeline self, uint32_t index, TS_TableType type, uint32_t size, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTableType(index, (TableType)type, size, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_TableType TS_CCALL tsPipeline_getTableType(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_TableType)((Pipeline*)self)->getTableType(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getTableSize(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getTableSize(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTableMask(TSPipeline self, uint32_t index, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTableMask(index, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsPipeline_getTableMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Pipeline*)self)->getTableMask(index);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setTableFlags(TSPipeline self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setTableFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsPipeline_getTableFlags(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Pipeline*)self)->getTableFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumVertices(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumVertices();
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getVertexStride(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getVertexStride(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getVertexRate(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getVertexRate(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_addAttribute(TSPipeline self, TS_PipelineAttribute attribute, TS_Format format, uint32_t vertex, size_t offset, size_t stride, uint32_t rate) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->addAttribute((Pipeline::Attribute)attribute, (Format)format, vertex, offset, stride, rate);
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttribute(TSPipeline self, uint32_t index, TS_PipelineAttribute attribute, TS_Format format, uint32_t vertex, size_t offset, size_t stride, uint32_t rate) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttribute(index, (Pipeline::Attribute)attribute, (Format)format, vertex, offset, stride, rate)));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttributeType(TSPipeline self, uint32_t index, TS_PipelineAttribute attribute) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttributeType(index, (Pipeline::Attribute)attribute)));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttributeFormat(TSPipeline self, uint32_t index, TS_Format format) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttributeFormat(index, (Format)format)));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttributeVertex(TSPipeline self, uint32_t index, uint32_t vertex) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttributeVertex(index, vertex)));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttributeOffset(TSPipeline self, uint32_t index, size_t offset) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttributeOffset(index, offset)));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttributeStride(TSPipeline self, uint32_t index, size_t stride) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttributeStride(index, stride)));
	}
	TS_CAPI TSPipeline TS_CCALL tsPipeline_setAttributeRate(TSPipeline self, uint32_t index, uint32_t rate) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((Pipeline*)self)->setAttributeRate(index, rate)));
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumAttributes(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumAttributes();
	}
	TS_CAPI TS_PipelineAttribute TS_CCALL tsPipeline_getAttributeType(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineAttribute)((Pipeline*)self)->getAttributeType(index);
	}
	TS_CAPI TS_Format TS_CCALL tsPipeline_getAttributeFormat(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_Format)((Pipeline*)self)->getAttributeFormat(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getAttributeVertex(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getAttributeVertex(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getAttributeOffset(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getAttributeOffset(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getAttributeStride(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getAttributeStride(index);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getAttributeRate(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getAttributeRate(index);
	}
	TS_CAPI void TS_CCALL tsPipeline_setPrimitive(TSPipeline self, TS_PipelinePrimitive primitive) {
		TS_ASSERT(self);
		((Pipeline*)self)->setPrimitive((Pipeline::Primitive)primitive);
	}
	TS_CAPI TS_PipelinePrimitive TS_CCALL tsPipeline_getPrimitive(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelinePrimitive)((Pipeline*)self)->getPrimitive();
	}
	TS_CAPI void TS_CCALL tsPipeline_setFillMode(TSPipeline self, TS_PipelineFillMode mode) {
		TS_ASSERT(self);
		((Pipeline*)self)->setFillMode((Pipeline::FillMode)mode);
	}
	TS_CAPI TS_PipelineFillMode TS_CCALL tsPipeline_getFillMode(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineFillMode)((Pipeline*)self)->getFillMode();
	}
	TS_CAPI void TS_CCALL tsPipeline_setCullMode(TSPipeline self, TS_PipelineCullMode mode) {
		TS_ASSERT(self);
		((Pipeline*)self)->setCullMode((Pipeline::CullMode)mode);
	}
	TS_CAPI TS_PipelineCullMode TS_CCALL tsPipeline_getCullMode(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineCullMode)((Pipeline*)self)->getCullMode();
	}
	TS_CAPI void TS_CCALL tsPipeline_setFrontMode(TSPipeline self, TS_PipelineFrontMode mode) {
		TS_ASSERT(self);
		((Pipeline*)self)->setFrontMode((Pipeline::FrontMode)mode);
	}
	TS_CAPI TS_PipelineFrontMode TS_CCALL tsPipeline_getFrontMode(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineFrontMode)((Pipeline*)self)->getFrontMode();
	}
	TS_CAPI void TS_CCALL tsPipeline_setDepthBias(TSPipeline self, float32_t bias, float32_t slope, float32_t clamp) {
		TS_ASSERT(self);
		((Pipeline*)self)->setDepthBias(bias, slope, clamp);
	}
	TS_CAPI float32_t TS_CCALL tsPipeline_getDepthBias(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getDepthBias();
	}
	TS_CAPI float32_t TS_CCALL tsPipeline_getDepthSlope(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getDepthSlope();
	}
	TS_CAPI float32_t TS_CCALL tsPipeline_getDepthClamp(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getDepthClamp();
	}
	TS_CAPI void TS_CCALL tsPipeline_setMultisample(TSPipeline self, uint32_t multisample) {
		TS_ASSERT(self);
		((Pipeline*)self)->setMultisample(multisample);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getMultisample(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getMultisample();
	}
	TS_CAPI void TS_CCALL tsPipeline_setSampleMask(TSPipeline self, uint32_t sample_mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setSampleMask(sample_mask);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getSampleMask(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getSampleMask();
	}
	TS_CAPI void TS_CCALL tsPipeline_setDepthClip(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setDepthClip((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getDepthClip(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getDepthClip();
	}
	TS_CAPI void TS_CCALL tsPipeline_setDepthReplace(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setDepthReplace((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getDepthReplace(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getDepthReplace();
	}
	TS_CAPI void TS_CCALL tsPipeline_setScissorTest(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setScissorTest((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getScissorTest(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getScissorTest();
	}
	TS_CAPI void TS_CCALL tsPipeline_setRasterDiscard(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setRasterDiscard((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getRasterDiscard(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getRasterDiscard();
	}
	TS_CAPI void TS_CCALL tsPipeline_setSampleShading(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setSampleShading((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getSampleShading(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getSampleShading();
	}
	TS_CAPI void TS_CCALL tsPipeline_setAlphaToCoverage(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setAlphaToCoverage((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getAlphaToCoverage(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getAlphaToCoverage();
	}
	TS_CAPI void TS_CCALL tsPipeline_setMultisampleRaster(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setMultisampleRaster((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getMultisampleRaster(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getMultisampleRaster();
	}
	TS_CAPI void TS_CCALL tsPipeline_setConservativeRaster(TSPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((Pipeline*)self)->setConservativeRaster((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsPipeline_getConservativeRaster(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getConservativeRaster();
	}
	TS_CAPI void TS_CCALL tsPipeline_setNumViewports(TSPipeline self, uint32_t num_viewports) {
		TS_ASSERT(self);
		((Pipeline*)self)->setNumViewports(num_viewports);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumTargets(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumTargets();
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumViewports(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumViewports();
	}
	TS_CAPI void TS_CCALL tsPipeline_setNumClipDistances(TSPipeline self, uint32_t num_distances) {
		TS_ASSERT(self);
		((Pipeline*)self)->setNumClipDistances(num_distances);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getNumClipDistances(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getNumClipDistances();
	}
	TS_CAPI void TS_CCALL tsPipeline_setBlend_PBOPBFPBF(TSPipeline self, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((Pipeline*)self)->setBlend((Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI void TS_CCALL tsPipeline_setBlendColor_PBOPBFPBF(TSPipeline self, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((Pipeline*)self)->setBlendColor((Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI void TS_CCALL tsPipeline_setBlendAlpha_PBOPBFPBF(TSPipeline self, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((Pipeline*)self)->setBlendAlpha((Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI void TS_CCALL tsPipeline_setBlend_uPBOPBFPBF(TSPipeline self, uint32_t index, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((Pipeline*)self)->setBlend(index, (Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI void TS_CCALL tsPipeline_setBlendColor_uPBOPBFPBF(TSPipeline self, uint32_t index, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((Pipeline*)self)->setBlendColor(index, (Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI void TS_CCALL tsPipeline_setBlendAlpha_uPBOPBFPBF(TSPipeline self, uint32_t index, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((Pipeline*)self)->setBlendAlpha(index, (Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI TS_PipelineBlendOp TS_CCALL tsPipeline_getBlendColorOp(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineBlendOp)((Pipeline*)self)->getBlendColorOp(index);
	}
	TS_CAPI TS_PipelineBlendOp TS_CCALL tsPipeline_getBlendAlphaOp(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineBlendOp)((Pipeline*)self)->getBlendAlphaOp(index);
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsPipeline_getBlendSrcColorFunc(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((Pipeline*)self)->getBlendSrcColorFunc(index);
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsPipeline_getBlendSrcAlphaFunc(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((Pipeline*)self)->getBlendSrcAlphaFunc(index);
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsPipeline_getBlendDestColorFunc(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((Pipeline*)self)->getBlendDestColorFunc(index);
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsPipeline_getBlendDestAlphaFunc(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((Pipeline*)self)->getBlendDestAlphaFunc(index);
	}
	TS_CAPI void TS_CCALL tsPipeline_setColorMask_PCM(TSPipeline self, TS_PipelineColorMask mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setColorMask((Pipeline::ColorMask)mask);
	}
	TS_CAPI void TS_CCALL tsPipeline_setColorMask_uPCM(TSPipeline self, uint32_t index, TS_PipelineColorMask mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setColorMask(index, (Pipeline::ColorMask)mask);
	}
	TS_CAPI void TS_CCALL tsPipeline_setColorFormat_uF(TSPipeline self, uint32_t index, TS_Format format) {
		TS_ASSERT(self);
		((Pipeline*)self)->setColorFormat(index, (Format)format);
	}
	TS_CAPI void TS_CCALL tsPipeline_setColorFormat_Fu(TSPipeline self, TS_Format format, uint32_t num) {
		TS_ASSERT(self);
		((Pipeline*)self)->setColorFormat((Format)format, num);
	}
	TS_CAPI TS_PipelineColorMask TS_CCALL tsPipeline_getColorMask(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_PipelineColorMask)((Pipeline*)self)->getColorMask(index);
	}
	TS_CAPI TS_Format TS_CCALL tsPipeline_getColorFormat(TSPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_Format)((Pipeline*)self)->getColorFormat(index);
	}
	TS_CAPI void TS_CCALL tsPipeline_setDepthMask(TSPipeline self, TS_PipelineDepthMask mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setDepthMask((Pipeline::DepthMask)mask);
	}
	TS_CAPI void TS_CCALL tsPipeline_setDepthFunc(TSPipeline self, TS_PipelineDepthFunc func) {
		TS_ASSERT(self);
		((Pipeline*)self)->setDepthFunc((Pipeline::DepthFunc)func);
	}
	TS_CAPI void TS_CCALL tsPipeline_setDepthFormat(TSPipeline self, TS_Format format) {
		TS_ASSERT(self);
		((Pipeline*)self)->setDepthFormat((Format)format);
	}
	TS_CAPI TS_PipelineDepthMask TS_CCALL tsPipeline_getDepthMask(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineDepthMask)((Pipeline*)self)->getDepthMask();
	}
	TS_CAPI TS_PipelineDepthFunc TS_CCALL tsPipeline_getDepthFunc(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineDepthFunc)((Pipeline*)self)->getDepthFunc();
	}
	TS_CAPI TS_Format TS_CCALL tsPipeline_getDepthFormat(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_Format)((Pipeline*)self)->getDepthFormat();
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilMask(TSPipeline self, uint32_t mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilMask(mask);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilBackMask(TSPipeline self, uint32_t mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilBackMask(mask);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilFrontMask(TSPipeline self, uint32_t mask) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilFrontMask(mask);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilFunc_PSFPSO(TSPipeline self, TS_PipelineStencilFunc func, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilBackFunc_PSFPSO(TSPipeline self, TS_PipelineStencilFunc func, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilBackFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilFrontFunc_PSFPSO(TSPipeline self, TS_PipelineStencilFunc func, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilFrontFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilFunc_PSFPSOPSOPSO(TSPipeline self, TS_PipelineStencilFunc func, TS_PipelineStencilOp fail_op, TS_PipelineStencilOp dfail_op, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)fail_op, (Pipeline::StencilOp)dfail_op, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilBackFunc_PSFPSOPSOPSO(TSPipeline self, TS_PipelineStencilFunc func, TS_PipelineStencilOp fail_op, TS_PipelineStencilOp dfail_op, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilBackFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)fail_op, (Pipeline::StencilOp)dfail_op, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI void TS_CCALL tsPipeline_setStencilFrontFunc_PSFPSOPSOPSO(TSPipeline self, TS_PipelineStencilFunc func, TS_PipelineStencilOp fail_op, TS_PipelineStencilOp dfail_op, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((Pipeline*)self)->setStencilFrontFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)fail_op, (Pipeline::StencilOp)dfail_op, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getStencilBackMask(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getStencilBackMask();
	}
	TS_CAPI TS_PipelineStencilFunc TS_CCALL tsPipeline_getStencilBackFunc(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilFunc)((Pipeline*)self)->getStencilBackFunc();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsPipeline_getStencilBackFailOp(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((Pipeline*)self)->getStencilBackFailOp();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsPipeline_getStencilBackDepthFailOp(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((Pipeline*)self)->getStencilBackDepthFailOp();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsPipeline_getStencilBackDepthPassOp(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((Pipeline*)self)->getStencilBackDepthPassOp();
	}
	TS_CAPI uint32_t TS_CCALL tsPipeline_getStencilFrontMask(TSPipeline self) {
		TS_ASSERT(self);
		return ((Pipeline*)self)->getStencilFrontMask();
	}
	TS_CAPI TS_PipelineStencilFunc TS_CCALL tsPipeline_getStencilFrontFunc(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilFunc)((Pipeline*)self)->getStencilFrontFunc();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsPipeline_getStencilFrontFailOp(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((Pipeline*)self)->getStencilFrontFailOp();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsPipeline_getStencilFrontDepthFailOp(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((Pipeline*)self)->getStencilFrontDepthFailOp();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsPipeline_getStencilFrontDepthPassOp(TSPipeline self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((Pipeline*)self)->getStencilFrontDepthPassOp();
	}
	
	// Tellusim::D3D12Pipeline
	TS_CAPI TSD3D12Pipeline TS_CCALL tsD3D12Pipeline_new(void) {
		D3D12Pipeline *ret = new D3D12Pipeline();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Pipeline)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Pipeline_delete(TSD3D12Pipeline self) {
		if(self) delete (D3D12Pipeline*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Pipeline_equalPtr(const TSD3D12Pipeline self, const TSD3D12Pipeline ptr) {
		return (self && ptr && ((D3D12Pipeline*)self)->operator==(*(D3D12Pipeline*)ptr));
	}
	TS_CAPI TSD3D12Pipeline TS_CCALL tsD3D12Pipeline_copyPtr(TSD3D12Pipeline self) {
		D3D12Pipeline *ret = nullptr;
		if(self) ret = new D3D12Pipeline(*(D3D12Pipeline*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Pipeline)ret;
	}
	TS_CAPI TSD3D12Pipeline TS_CCALL tsD3D12Pipeline_clonePtr(const TSD3D12Pipeline self) {
		D3D12Pipeline *ret = (self) ? new D3D12Pipeline(((D3D12Pipeline*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Pipeline)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Pipeline_clearPtr(TSD3D12Pipeline self) {
		if(self) ((D3D12Pipeline*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Pipeline_destroyPtr(TSD3D12Pipeline self) {
		if(self) ((D3D12Pipeline*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Pipeline_acquirePtr(TSD3D12Pipeline self) {
		if(self) ((D3D12Pipeline*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Pipeline_unacquirePtr(TSD3D12Pipeline self) {
		if(self) ((D3D12Pipeline*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Pipeline_isValidPtr(const TSD3D12Pipeline self) {
		return (self && ((D3D12Pipeline*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Pipeline_isOwnerPtr(const TSD3D12Pipeline self) {
		return (self && ((D3D12Pipeline*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Pipeline_isConstPtr(const TSD3D12Pipeline self) {
		return (self && ((D3D12Pipeline*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Pipeline_getCountPtr(const TSD3D12Pipeline self) {
		return ((D3D12Pipeline*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Pipeline_getInternalPtr(const TSD3D12Pipeline self) {
		return ((D3D12Pipeline*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Pipeline_equalPipelinePtr(const TSD3D12Pipeline self, const TSPipeline base) {
		return (self && base && ((D3D12Pipeline*)self)->operator==(*(Pipeline*)base));
	}
	TS_CAPI TSD3D12Pipeline TS_CCALL tsD3D12Pipeline_castPipelinePtr(TSPipeline base) {
		return (TSD3D12Pipeline)(new D3D12Pipeline(*(Pipeline*)base));
	}
	TS_CAPI TSPipeline TS_CCALL tsD3D12Pipeline_basePipelinePtr(TSD3D12Pipeline self) {
		return (TSPipeline)(new Pipeline(((D3D12Pipeline*)self)->getPipeline()));
	}
	TS_CAPI ID3D12RootSignature* TS_CCALL tsD3D12Pipeline_getRootSignature(TSD3D12Pipeline self) {
		TS_ASSERT(self);
		return ((D3D12Pipeline*)self)->getRootSignature();
	}
	
	// Tellusim::MTLPipeline
	TS_CAPI TSMTLPipeline TS_CCALL tsMTLPipeline_new(void) {
		MTLPipeline *ret = new MTLPipeline();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLPipeline)ret;
	}
	TS_CAPI void TS_CCALL tsMTLPipeline_delete(TSMTLPipeline self) {
		if(self) delete (MTLPipeline*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLPipeline_equalPtr(const TSMTLPipeline self, const TSMTLPipeline ptr) {
		return (self && ptr && ((MTLPipeline*)self)->operator==(*(MTLPipeline*)ptr));
	}
	TS_CAPI TSMTLPipeline TS_CCALL tsMTLPipeline_copyPtr(TSMTLPipeline self) {
		MTLPipeline *ret = nullptr;
		if(self) ret = new MTLPipeline(*(MTLPipeline*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLPipeline)ret;
	}
	TS_CAPI TSMTLPipeline TS_CCALL tsMTLPipeline_clonePtr(const TSMTLPipeline self) {
		MTLPipeline *ret = (self) ? new MTLPipeline(((MTLPipeline*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLPipeline)ret;
	}
	TS_CAPI void TS_CCALL tsMTLPipeline_clearPtr(TSMTLPipeline self) {
		if(self) ((MTLPipeline*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLPipeline_destroyPtr(TSMTLPipeline self) {
		if(self) ((MTLPipeline*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLPipeline_acquirePtr(TSMTLPipeline self) {
		if(self) ((MTLPipeline*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLPipeline_unacquirePtr(TSMTLPipeline self) {
		if(self) ((MTLPipeline*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLPipeline_isValidPtr(const TSMTLPipeline self) {
		return (self && ((MTLPipeline*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLPipeline_isOwnerPtr(const TSMTLPipeline self) {
		return (self && ((MTLPipeline*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLPipeline_isConstPtr(const TSMTLPipeline self) {
		return (self && ((MTLPipeline*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLPipeline_getCountPtr(const TSMTLPipeline self) {
		return ((MTLPipeline*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLPipeline_getInternalPtr(const TSMTLPipeline self) {
		return ((MTLPipeline*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLPipeline_equalPipelinePtr(const TSMTLPipeline self, const TSPipeline base) {
		return (self && base && ((MTLPipeline*)self)->operator==(*(Pipeline*)base));
	}
	TS_CAPI TSMTLPipeline TS_CCALL tsMTLPipeline_castPipelinePtr(TSPipeline base) {
		return (TSMTLPipeline)(new MTLPipeline(*(Pipeline*)base));
	}
	TS_CAPI TSPipeline TS_CCALL tsMTLPipeline_basePipelinePtr(TSMTLPipeline self) {
		return (TSPipeline)(new Pipeline(((MTLPipeline*)self)->getPipeline()));
	}
	TS_CAPI void TS_CCALL tsMTLPipeline_setIndirect(TSMTLPipeline self, bool_t enabled) {
		TS_ASSERT(self);
		((MTLPipeline*)self)->setIndirect((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsMTLPipeline_isIndirect(TSMTLPipeline self) {
		TS_ASSERT(self);
		return ((MTLPipeline*)self)->isIndirect();
	}
	TS_CAPI void* TS_CCALL tsMTLPipeline_getVertexFunction(TSMTLPipeline self) {
		TS_ASSERT(self);
		return ((MTLPipeline*)self)->getVertexFunction();
	}
	TS_CAPI void* TS_CCALL tsMTLPipeline_getFragmentFunction(TSMTLPipeline self) {
		TS_ASSERT(self);
		return ((MTLPipeline*)self)->getFragmentFunction();
	}
	
	// Tellusim::FUPipeline
	TS_CAPI TSFUPipeline TS_CCALL tsFUPipeline_new(void) {
		FUPipeline *ret = new FUPipeline();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUPipeline)ret;
	}
	TS_CAPI TSFUPipeline TS_CCALL tsFUPipeline_new_cAPb(const TSPipeline *pipelines, uint32_t pipelines_size, bool_t owner) {
		Array<Pipeline> pipelines_(pipelines_size);
		for(uint32_t i = 0; i < pipelines_size; i++) if(pipelines[i]) pipelines_[i] = *(Pipeline*)pipelines[i];
		FUPipeline *ret = new FUPipeline(pipelines_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUPipeline)ret;
	}
	TS_CAPI void TS_CCALL tsFUPipeline_delete(TSFUPipeline self) {
		if(self) delete (FUPipeline*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUPipeline_equalPtr(const TSFUPipeline self, const TSFUPipeline ptr) {
		return (self && ptr && ((FUPipeline*)self)->operator==(*(FUPipeline*)ptr));
	}
	TS_CAPI TSFUPipeline TS_CCALL tsFUPipeline_copyPtr(TSFUPipeline self) {
		FUPipeline *ret = nullptr;
		if(self) ret = new FUPipeline(*(FUPipeline*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUPipeline)ret;
	}
	TS_CAPI TSFUPipeline TS_CCALL tsFUPipeline_clonePtr(const TSFUPipeline self) {
		FUPipeline *ret = (self) ? new FUPipeline(((FUPipeline*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUPipeline)ret;
	}
	TS_CAPI void TS_CCALL tsFUPipeline_clearPtr(TSFUPipeline self) {
		if(self) ((FUPipeline*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUPipeline_destroyPtr(TSFUPipeline self) {
		if(self) ((FUPipeline*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUPipeline_acquirePtr(TSFUPipeline self) {
		if(self) ((FUPipeline*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUPipeline_unacquirePtr(TSFUPipeline self) {
		if(self) ((FUPipeline*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUPipeline_isValidPtr(const TSFUPipeline self) {
		return (self && ((FUPipeline*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUPipeline_isOwnerPtr(const TSFUPipeline self) {
		return (self && ((FUPipeline*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUPipeline_isConstPtr(const TSFUPipeline self) {
		return (self && ((FUPipeline*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUPipeline_getCountPtr(const TSFUPipeline self) {
		return ((FUPipeline*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUPipeline_getInternalPtr(const TSFUPipeline self) {
		return ((FUPipeline*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUPipeline_equalPipelinePtr(const TSFUPipeline self, const TSPipeline base) {
		return (self && base && ((FUPipeline*)self)->operator==(*(Pipeline*)base));
	}
	TS_CAPI TSFUPipeline TS_CCALL tsFUPipeline_castPipelinePtr(TSPipeline base) {
		return (TSFUPipeline)(new FUPipeline(*(Pipeline*)base));
	}
	TS_CAPI TSPipeline TS_CCALL tsFUPipeline_basePipelinePtr(TSFUPipeline self) {
		return (TSPipeline)(new Pipeline(((FUPipeline*)self)->getPipeline()));
	}
	TS_CAPI void TS_CCALL tsFUPipeline_setMask(TSFUPipeline self, uint32_t mask) {
		TS_ASSERT(self);
		((FUPipeline*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUPipeline_getMask(TSFUPipeline self) {
		TS_ASSERT(self);
		return ((FUPipeline*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUPipeline_getNumPipelines(TSFUPipeline self) {
		TS_ASSERT(self);
		return ((FUPipeline*)self)->getNumPipelines();
	}
	TS_CAPI TSPipeline TS_CCALL tsFUPipeline_getPipeline_cu(TSFUPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((FUPipeline*)self)->getPipeline(index)));
	}
	TS_CAPI TSPipeline TS_CCALL tsFUPipeline_getPipeline_u(TSFUPipeline self, uint32_t index) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((FUPipeline*)self)->getPipeline(index)));
	}
	
	// Tellusim::Traversal
	TS_CAPI TSTraversal TS_CCALL tsTraversal_new(void) {
		Traversal *ret = new Traversal();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTraversal)ret;
	}
	TS_CAPI void TS_CCALL tsTraversal_delete(TSTraversal self) {
		if(self) delete (Traversal*)self;
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_equalPtr(const TSTraversal self, const TSTraversal ptr) {
		return (self && ptr && ((Traversal*)self)->operator==(*(Traversal*)ptr));
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_copyPtr(TSTraversal self) {
		Traversal *ret = nullptr;
		if(self) ret = new Traversal(*(Traversal*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTraversal)ret;
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_clonePtr(const TSTraversal self) {
		Traversal *ret = (self) ? new Traversal(((Traversal*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTraversal)ret;
	}
	TS_CAPI void TS_CCALL tsTraversal_clearPtr(TSTraversal self) {
		if(self) ((Traversal*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsTraversal_destroyPtr(TSTraversal self) {
		if(self) ((Traversal*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsTraversal_acquirePtr(TSTraversal self) {
		if(self) ((Traversal*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsTraversal_unacquirePtr(TSTraversal self) {
		if(self) ((Traversal*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_isValidPtr(const TSTraversal self) {
		return (self && ((Traversal*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_isOwnerPtr(const TSTraversal self) {
		return (self && ((Traversal*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_isConstPtr(const TSTraversal self) {
		return (self && ((Traversal*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getCountPtr(const TSTraversal self) {
		return ((Traversal*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsTraversal_getInternalPtr(const TSTraversal self) {
		return ((Traversal*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsTraversal_getPlatform(TSTraversal self) {
		TS_ASSERT(self);
		return (TS_Platform)((Traversal*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsTraversal_getPlatformName(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getIndex(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsTraversal_clear(TSTraversal self) {
		TS_ASSERT(self);
		((Traversal*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_isCreated(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsTraversal_setName(TSTraversal self, const char *name) {
		TS_ASSERT(self);
		((Traversal*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsTraversal_getName(TSTraversal self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Traversal*)self)->getName()));
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_create(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->create();
	}
	TS_CAPI void TS_CCALL tsTraversal_setParameters(TSTraversal self, const TSTraversal traversal) {
		TS_ASSERT(self);
		TS_ASSERT(traversal);
		((Traversal*)self)->setParameters(*(const Traversal*)traversal);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_saveState(TSTraversal self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Traversal*)self)->saveState(*(Stream*)stream);
	}
	TS_CAPI void TS_CCALL tsTraversal_addShader(TSTraversal self, TSShader shader, bool_t owner) {
		TS_ASSERT(self);
		TS_ASSERT(shader);
		((Traversal*)self)->addShader(*(Shader*)shader, (bool)owner);
	}
	TS_CAPI TSShader TS_CCALL tsTraversal_getRayGenShader(TSTraversal self) {
		TS_ASSERT(self);
		return (TSShader)(new Shader(((Traversal*)self)->getRayGenShader()));
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_loadShader_STss(TSTraversal self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Traversal*)self)->loadShader((Shader::Type)type, name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_loadShaderGLSL_STss(TSTraversal self, TS_ShaderType type, const char *name, const char *format) {
		TS_ASSERT(self);
		return ((Traversal*)self)->loadShaderGLSL((Shader::Type)type, name, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_loadShader_STscSspu(TSTraversal self, TS_ShaderType type, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Traversal*)self)->loadShader((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_loadShaderGLSL_STscSspu(TSTraversal self, TS_ShaderType type, const char *name, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Traversal*)self)->loadShaderGLSL((Shader::Type)type, name, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_loadShaderSPIRV(TSTraversal self, TS_ShaderType type, const char *name) {
		TS_ASSERT(self);
		return ((Traversal*)self)->loadShaderSPIRV((Shader::Type)type, name);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_createShader_STss(TSTraversal self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Traversal*)self)->createShader((Shader::Type)type, src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_createShaderGLSL_STss(TSTraversal self, TS_ShaderType type, const char *src, const char *format) {
		TS_ASSERT(self);
		return ((Traversal*)self)->createShaderGLSL((Shader::Type)type, src, "%s", format);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_createShader_STscSspu(TSTraversal self, TS_ShaderType type, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Traversal*)self)->createShader((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_createShaderGLSL_STscSspu(TSTraversal self, TS_ShaderType type, const char *src, const TSString macros, const char **includes, uint32_t size) {
		TS_ASSERT(self);
		return ((Traversal*)self)->createShaderGLSL((Shader::Type)type, src, (macros) ? *(const String*)macros : String::null, includes, size);
	}
	TS_CAPI bool_t TS_CCALL tsTraversal_createShaderSPIRV(TSTraversal self, TS_ShaderType type, const uint32_t *data, uint32_t data_size) {
		TS_ASSERT(self);
		Array<uint32_t> data_(data_size, data);
		return ((Traversal*)self)->createShaderSPIRV((Shader::Type)type, data_);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addSampler(TSTraversal self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addSampler((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumSamplers(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumSamplers();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSamplerOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSamplerOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getSamplerOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getSamplerOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSamplerMask(TSTraversal self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSamplerMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getSamplerMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getSamplerMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSamplerMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask, bool_t array) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSamplerMasks(index, num, (Shader::Mask)mask, (bool)array)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getSamplerMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getSamplerMasks(index, num);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSamplerArray(TSTraversal self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSamplerArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getSamplerArray(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getSamplerArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addTexture(TSTraversal self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addTexture((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumTextures(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumTextures();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTextureOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTextureOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getTextureOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getTextureOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTextureMask(TSTraversal self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTextureMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTextureMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTextureMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTextureMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask, bool_t array) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTextureMasks(index, num, (Shader::Mask)mask, (bool)array)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTextureMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTextureMasks(index, num);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTextureArray(TSTraversal self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTextureArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getTextureArray(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getTextureArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addSurface(TSTraversal self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addSurface((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumSurfaces(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumSurfaces();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSurfaceOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSurfaceOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getSurfaceOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getSurfaceOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSurfaceMask(TSTraversal self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSurfaceMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getSurfaceMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getSurfaceMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSurfaceMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask, bool_t array) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSurfaceMasks(index, num, (Shader::Mask)mask, (bool)array)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getSurfaceMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getSurfaceMasks(index, num);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setSurfaceArray(TSTraversal self, uint32_t index, uint32_t num, bool_t array) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setSurfaceArray(index, num, (bool)array)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getSurfaceArray(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getSurfaceArray(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addUniform(TSTraversal self, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addUniform((Shader::Mask)mask, (BindFlags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumUniforms(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumUniforms();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setUniformOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setUniformOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getUniformOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getUniformOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setUniformMask(TSTraversal self, uint32_t index, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setUniformMask(index, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getUniformMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getUniformMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setUniformMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setUniformMasks(index, num, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getUniformMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getUniformMasks(index, num);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setUniformFlags(TSTraversal self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setUniformFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsTraversal_getUniformFlags(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Traversal*)self)->getUniformFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addStorage(TSTraversal self, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addStorage((Shader::Mask)mask, (BindFlags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumStorages(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumStorages();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setStorageOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setStorageOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getStorageOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getStorageOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setStorageMask(TSTraversal self, uint32_t index, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setStorageMask(index, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getStorageMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getStorageMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setStorageMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setStorageMasks(index, num, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getStorageMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getStorageMasks(index, num);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setStorageFlags(TSTraversal self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setStorageFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsTraversal_getStorageFlags(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Traversal*)self)->getStorageFlags(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addTracing(TSTraversal self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addTracing((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumTracings(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumTracings();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTracingOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTracingOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getTracingOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getTracingOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTracingMask(TSTraversal self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTracingMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTracingMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTracingMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTracingMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTracingMasks(index, num, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTracingMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTracingMasks(index, num);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addTexel(TSTraversal self, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addTexel((Shader::Mask)mask);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumTexels(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumTexels();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTexelOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTexelOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getTexelOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getTexelOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTexelMask(TSTraversal self, uint32_t index, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTexelMask(index, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTexelMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTexelMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTexelMasks(TSTraversal self, uint32_t index, uint32_t num, TS_ShaderMask mask) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTexelMasks(index, num, (Shader::Mask)mask)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTexelMasks(TSTraversal self, uint32_t index, uint32_t num) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTexelMasks(index, num);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_addTable(TSTraversal self, TS_TableType type, uint32_t size, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return ((Traversal*)self)->addTable((TableType)type, size, (Shader::Mask)mask, (BindFlags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getNumTables(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getNumTables();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTableOffset(TSTraversal self, uint32_t offset) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTableOffset(offset)));
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getTableOffset(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getTableOffset();
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTableType(TSTraversal self, uint32_t index, TS_TableType type, uint32_t size, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTableType(index, (TableType)type, size, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_TableType TS_CCALL tsTraversal_getTableType(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_TableType)((Traversal*)self)->getTableType(index);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getTableSize(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getTableSize(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTableMask(TSTraversal self, uint32_t index, TS_ShaderMask mask, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTableMask(index, (Shader::Mask)mask, (BindFlags)flags)));
	}
	TS_CAPI TS_ShaderMask TS_CCALL tsTraversal_getTableMask(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_ShaderMask)((Traversal*)self)->getTableMask(index);
	}
	TS_CAPI TSTraversal TS_CCALL tsTraversal_setTableFlags(TSTraversal self, uint32_t index, TS_BindFlags flags) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((Traversal*)self)->setTableFlags(index, (BindFlags)flags)));
	}
	TS_CAPI TS_BindFlags TS_CCALL tsTraversal_getTableFlags(TSTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TS_BindFlags)((Traversal*)self)->getTableFlags(index);
	}
	TS_CAPI void TS_CCALL tsTraversal_setRecursionDepth(TSTraversal self, uint32_t depth) {
		TS_ASSERT(self);
		((Traversal*)self)->setRecursionDepth(depth);
	}
	TS_CAPI uint32_t TS_CCALL tsTraversal_getRecursionDepth(TSTraversal self) {
		TS_ASSERT(self);
		return ((Traversal*)self)->getRecursionDepth();
	}
	
	// Tellusim::D3D12Traversal
	TS_CAPI TSD3D12Traversal TS_CCALL tsD3D12Traversal_new(void) {
		D3D12Traversal *ret = new D3D12Traversal();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Traversal)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Traversal_delete(TSD3D12Traversal self) {
		if(self) delete (D3D12Traversal*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Traversal_equalPtr(const TSD3D12Traversal self, const TSD3D12Traversal ptr) {
		return (self && ptr && ((D3D12Traversal*)self)->operator==(*(D3D12Traversal*)ptr));
	}
	TS_CAPI TSD3D12Traversal TS_CCALL tsD3D12Traversal_copyPtr(TSD3D12Traversal self) {
		D3D12Traversal *ret = nullptr;
		if(self) ret = new D3D12Traversal(*(D3D12Traversal*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Traversal)ret;
	}
	TS_CAPI TSD3D12Traversal TS_CCALL tsD3D12Traversal_clonePtr(const TSD3D12Traversal self) {
		D3D12Traversal *ret = (self) ? new D3D12Traversal(((D3D12Traversal*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Traversal)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Traversal_clearPtr(TSD3D12Traversal self) {
		if(self) ((D3D12Traversal*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Traversal_destroyPtr(TSD3D12Traversal self) {
		if(self) ((D3D12Traversal*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Traversal_acquirePtr(TSD3D12Traversal self) {
		if(self) ((D3D12Traversal*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Traversal_unacquirePtr(TSD3D12Traversal self) {
		if(self) ((D3D12Traversal*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Traversal_isValidPtr(const TSD3D12Traversal self) {
		return (self && ((D3D12Traversal*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Traversal_isOwnerPtr(const TSD3D12Traversal self) {
		return (self && ((D3D12Traversal*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Traversal_isConstPtr(const TSD3D12Traversal self) {
		return (self && ((D3D12Traversal*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Traversal_getCountPtr(const TSD3D12Traversal self) {
		return ((D3D12Traversal*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Traversal_getInternalPtr(const TSD3D12Traversal self) {
		return ((D3D12Traversal*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Traversal_equalTraversalPtr(const TSD3D12Traversal self, const TSTraversal base) {
		return (self && base && ((D3D12Traversal*)self)->operator==(*(Traversal*)base));
	}
	TS_CAPI TSD3D12Traversal TS_CCALL tsD3D12Traversal_castTraversalPtr(TSTraversal base) {
		return (TSD3D12Traversal)(new D3D12Traversal(*(Traversal*)base));
	}
	TS_CAPI TSTraversal TS_CCALL tsD3D12Traversal_baseTraversalPtr(TSD3D12Traversal self) {
		return (TSTraversal)(new Traversal(((D3D12Traversal*)self)->getTraversal()));
	}
	TS_CAPI ID3D12RootSignature* TS_CCALL tsD3D12Traversal_getRootSignature(TSD3D12Traversal self) {
		TS_ASSERT(self);
		return ((D3D12Traversal*)self)->getRootSignature();
	}
	
	// Tellusim::FUTraversal
	TS_CAPI TSFUTraversal TS_CCALL tsFUTraversal_new(void) {
		FUTraversal *ret = new FUTraversal();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTraversal)ret;
	}
	TS_CAPI TSFUTraversal TS_CCALL tsFUTraversal_new_cATb(const TSTraversal *traversals, uint32_t traversals_size, bool_t owner) {
		Array<Traversal> traversals_(traversals_size);
		for(uint32_t i = 0; i < traversals_size; i++) if(traversals[i]) traversals_[i] = *(Traversal*)traversals[i];
		FUTraversal *ret = new FUTraversal(traversals_, (bool)owner);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTraversal)ret;
	}
	TS_CAPI void TS_CCALL tsFUTraversal_delete(TSFUTraversal self) {
		if(self) delete (FUTraversal*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFUTraversal_equalPtr(const TSFUTraversal self, const TSFUTraversal ptr) {
		return (self && ptr && ((FUTraversal*)self)->operator==(*(FUTraversal*)ptr));
	}
	TS_CAPI TSFUTraversal TS_CCALL tsFUTraversal_copyPtr(TSFUTraversal self) {
		FUTraversal *ret = nullptr;
		if(self) ret = new FUTraversal(*(FUTraversal*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTraversal)ret;
	}
	TS_CAPI TSFUTraversal TS_CCALL tsFUTraversal_clonePtr(const TSFUTraversal self) {
		FUTraversal *ret = (self) ? new FUTraversal(((FUTraversal*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFUTraversal)ret;
	}
	TS_CAPI void TS_CCALL tsFUTraversal_clearPtr(TSFUTraversal self) {
		if(self) ((FUTraversal*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFUTraversal_destroyPtr(TSFUTraversal self) {
		if(self) ((FUTraversal*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFUTraversal_acquirePtr(TSFUTraversal self) {
		if(self) ((FUTraversal*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFUTraversal_unacquirePtr(TSFUTraversal self) {
		if(self) ((FUTraversal*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTraversal_isValidPtr(const TSFUTraversal self) {
		return (self && ((FUTraversal*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTraversal_isOwnerPtr(const TSFUTraversal self) {
		return (self && ((FUTraversal*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFUTraversal_isConstPtr(const TSFUTraversal self) {
		return (self && ((FUTraversal*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFUTraversal_getCountPtr(const TSFUTraversal self) {
		return ((FUTraversal*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFUTraversal_getInternalPtr(const TSFUTraversal self) {
		return ((FUTraversal*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsFUTraversal_equalTraversalPtr(const TSFUTraversal self, const TSTraversal base) {
		return (self && base && ((FUTraversal*)self)->operator==(*(Traversal*)base));
	}
	TS_CAPI TSFUTraversal TS_CCALL tsFUTraversal_castTraversalPtr(TSTraversal base) {
		return (TSFUTraversal)(new FUTraversal(*(Traversal*)base));
	}
	TS_CAPI TSTraversal TS_CCALL tsFUTraversal_baseTraversalPtr(TSFUTraversal self) {
		return (TSTraversal)(new Traversal(((FUTraversal*)self)->getTraversal()));
	}
	TS_CAPI void TS_CCALL tsFUTraversal_setMask(TSFUTraversal self, uint32_t mask) {
		TS_ASSERT(self);
		((FUTraversal*)self)->setMask(mask);
	}
	TS_CAPI uint32_t TS_CCALL tsFUTraversal_getMask(TSFUTraversal self) {
		TS_ASSERT(self);
		return ((FUTraversal*)self)->getMask();
	}
	TS_CAPI uint32_t TS_CCALL tsFUTraversal_getNumTraversals(TSFUTraversal self) {
		TS_ASSERT(self);
		return ((FUTraversal*)self)->getNumTraversals();
	}
	TS_CAPI TSTraversal TS_CCALL tsFUTraversal_getTraversal_cu(TSFUTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((FUTraversal*)self)->getTraversal(index)));
	}
	TS_CAPI TSTraversal TS_CCALL tsFUTraversal_getTraversal_u(TSFUTraversal self, uint32_t index) {
		TS_ASSERT(self);
		return (TSTraversal)(new Traversal(((FUTraversal*)self)->getTraversal(index)));
	}
	
	// Tellusim::Surface
	TS_CAPI TSSurface TS_CCALL tsSurface_new(void) {
		Surface *ret = new Surface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSurface)ret;
	}
	TS_CAPI TSSurface TS_CCALL tsSurface_new_C(TSContext context) {
		TS_ASSERT(context);
		Surface *ret = new Surface(*(Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSurface)ret;
	}
	TS_CAPI TSSurface TS_CCALL tsSurface_new_P(TS_Platform platform) {
		Surface *ret = new Surface((Platform)platform);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSurface)ret;
	}
	TS_CAPI void TS_CCALL tsSurface_delete(TSSurface self) {
		if(self) delete (Surface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSurface_equalPtr(const TSSurface self, const TSSurface ptr) {
		return (self && ptr && ((Surface*)self)->operator==(*(Surface*)ptr));
	}
	TS_CAPI TSSurface TS_CCALL tsSurface_copyPtr(TSSurface self) {
		Surface *ret = nullptr;
		if(self) ret = new Surface(*(Surface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSurface)ret;
	}
	TS_CAPI TSSurface TS_CCALL tsSurface_clonePtr(const TSSurface self) {
		Surface *ret = (self) ? new Surface(((Surface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSurface)ret;
	}
	TS_CAPI void TS_CCALL tsSurface_clearPtr(TSSurface self) {
		if(self) ((Surface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSurface_destroyPtr(TSSurface self) {
		if(self) ((Surface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSurface_acquirePtr(TSSurface self) {
		if(self) ((Surface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSurface_unacquirePtr(TSSurface self) {
		if(self) ((Surface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSurface_isValidPtr(const TSSurface self) {
		return (self && ((Surface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSurface_isOwnerPtr(const TSSurface self) {
		return (self && ((Surface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSurface_isConstPtr(const TSSurface self) {
		return (self && ((Surface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getCountPtr(const TSSurface self) {
		return ((Surface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSurface_getInternalPtr(const TSSurface self) {
		return ((Surface*)self)->getInternalPtr();
	}
	TS_CAPI TS_Platform TS_CCALL tsSurface_getPlatform(TSSurface self) {
		TS_ASSERT(self);
		return (TS_Platform)((Surface*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsSurface_getPlatformName(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getIndex(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsSurface_setSize(TSSurface self, uint32_t width, uint32_t height) {
		TS_ASSERT(self);
		((Surface*)self)->setSize(width, height);
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getWidth(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getHeight(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getHeight();
	}
	TS_CAPI void TS_CCALL tsSurface_setMultisample(TSSurface self, uint32_t multisample) {
		TS_ASSERT(self);
		((Surface*)self)->setMultisample(multisample);
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getMultisample(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getMultisample();
	}
	TS_CAPI bool_t TS_CCALL tsSurface_hasMultisample(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->hasMultisample();
	}
	TS_CAPI void TS_CCALL tsSurface_setColorLayer(TSSurface self, uint32_t layer, uint32_t layers) {
		TS_ASSERT(self);
		((Surface*)self)->setColorLayer(layer, layers);
	}
	TS_CAPI void TS_CCALL tsSurface_setDepthLayer(TSSurface self, uint32_t layer, uint32_t layers) {
		TS_ASSERT(self);
		((Surface*)self)->setDepthLayer(layer, layers);
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getColorLayer(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getColorLayer();
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getDepthLayer(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getDepthLayer();
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getColorLayers(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getColorLayers();
	}
	TS_CAPI uint32_t TS_CCALL tsSurface_getDepthLayers(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->getDepthLayers();
	}
	TS_CAPI bool_t TS_CCALL tsSurface_hasColorLayers(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->hasColorLayers();
	}
	TS_CAPI bool_t TS_CCALL tsSurface_hasDepthLayers(TSSurface self) {
		TS_ASSERT(self);
		return ((Surface*)self)->hasDepthLayers();
	}
	TS_CAPI void TS_CCALL tsSurface_setColorFormat(TSSurface self, TS_Format format) {
		TS_ASSERT(self);
		((Surface*)self)->setColorFormat((Format)format);
	}
	TS_CAPI void TS_CCALL tsSurface_setDepthFormat(TSSurface self, TS_Format format) {
		TS_ASSERT(self);
		((Surface*)self)->setDepthFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL tsSurface_getColorFormat(TSSurface self) {
		TS_ASSERT(self);
		return (TS_Format)((Surface*)self)->getColorFormat();
	}
	TS_CAPI TS_Format TS_CCALL tsSurface_getDepthFormat(TSSurface self) {
		TS_ASSERT(self);
		return (TS_Format)((Surface*)self)->getDepthFormat();
	}
	
	// Tellusim::D3D12Surface
	TS_CAPI TSD3D12Surface TS_CCALL tsD3D12Surface_new(void) {
		D3D12Surface *ret = new D3D12Surface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Surface)ret;
	}
	TS_CAPI TSD3D12Surface TS_CCALL tsD3D12Surface_new_D3D12C(TSD3D12Context context) {
		TS_ASSERT(context);
		D3D12Surface *ret = new D3D12Surface(*(D3D12Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Surface)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_delete(TSD3D12Surface self) {
		if(self) delete (D3D12Surface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Surface_equalPtr(const TSD3D12Surface self, const TSD3D12Surface ptr) {
		return (self && ptr && ((D3D12Surface*)self)->operator==(*(D3D12Surface*)ptr));
	}
	TS_CAPI TSD3D12Surface TS_CCALL tsD3D12Surface_copyPtr(TSD3D12Surface self) {
		D3D12Surface *ret = nullptr;
		if(self) ret = new D3D12Surface(*(D3D12Surface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Surface)ret;
	}
	TS_CAPI TSD3D12Surface TS_CCALL tsD3D12Surface_clonePtr(const TSD3D12Surface self) {
		D3D12Surface *ret = (self) ? new D3D12Surface(((D3D12Surface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D12Surface)ret;
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_clearPtr(TSD3D12Surface self) {
		if(self) ((D3D12Surface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_destroyPtr(TSD3D12Surface self) {
		if(self) ((D3D12Surface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_acquirePtr(TSD3D12Surface self) {
		if(self) ((D3D12Surface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_unacquirePtr(TSD3D12Surface self) {
		if(self) ((D3D12Surface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Surface_isValidPtr(const TSD3D12Surface self) {
		return (self && ((D3D12Surface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Surface_isOwnerPtr(const TSD3D12Surface self) {
		return (self && ((D3D12Surface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Surface_isConstPtr(const TSD3D12Surface self) {
		return (self && ((D3D12Surface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Surface_getCountPtr(const TSD3D12Surface self) {
		return ((D3D12Surface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D12Surface_getInternalPtr(const TSD3D12Surface self) {
		return ((D3D12Surface*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D12Surface_equalSurfacePtr(const TSD3D12Surface self, const TSSurface base) {
		return (self && base && ((D3D12Surface*)self)->operator==(*(Surface*)base));
	}
	TS_CAPI TSD3D12Surface TS_CCALL tsD3D12Surface_castSurfacePtr(TSSurface base) {
		return (TSD3D12Surface)(new D3D12Surface(*(Surface*)base));
	}
	TS_CAPI TSSurface TS_CCALL tsD3D12Surface_baseSurfacePtr(TSD3D12Surface self) {
		return (TSSurface)(new Surface(((D3D12Surface*)self)->getSurface()));
	}
	TS_CAPI IDXGIFactory4* TS_CCALL tsD3D12Surface_getFactory(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getFactory();
	}
	TS_CAPI ID3D12Device* TS_CCALL tsD3D12Surface_getDevice(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getDevice();
	}
	TS_CAPI ID3D12CommandQueue* TS_CCALL tsD3D12Surface_getQueue(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getQueue();
	}
	TS_CAPI ID3D12GraphicsCommandList* TS_CCALL tsD3D12Surface_getCommand(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getCommand();
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_setSwapChain(TSD3D12Surface self, IDXGISwapChain *swap_chain) {
		TS_ASSERT(self);
		((D3D12Surface*)self)->setSwapChain(swap_chain);
	}
	TS_CAPI IDXGISwapChain* TS_CCALL tsD3D12Surface_getSwapChain(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getSwapChain();
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_setRenderTarget(TSD3D12Surface self, ID3D12Resource *render_target) {
		TS_ASSERT(self);
		((D3D12Surface*)self)->setRenderTarget(render_target);
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_setDepthStencil(TSD3D12Surface self, ID3D12Resource *depth_stencil) {
		TS_ASSERT(self);
		((D3D12Surface*)self)->setDepthStencil(depth_stencil);
	}
	TS_CAPI ID3D12Resource* TS_CCALL tsD3D12Surface_getRenderTarget(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getRenderTarget();
	}
	TS_CAPI ID3D12Resource* TS_CCALL tsD3D12Surface_getDepthStencil(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getDepthStencil();
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_setRenderTargetView(TSD3D12Surface self, size_t render_target_view) {
		TS_ASSERT(self);
		((D3D12Surface*)self)->setRenderTargetView(render_target_view);
	}
	TS_CAPI void TS_CCALL tsD3D12Surface_setDepthStencilView(TSD3D12Surface self, size_t depth_stencil_view) {
		TS_ASSERT(self);
		((D3D12Surface*)self)->setDepthStencilView(depth_stencil_view);
	}
	TS_CAPI size_t TS_CCALL tsD3D12Surface_getRenderTargetView(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getRenderTargetView();
	}
	TS_CAPI size_t TS_CCALL tsD3D12Surface_getDepthStencilView(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getDepthStencilView();
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Surface_getColorDXGIFormat(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getColorDXGIFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsD3D12Surface_getDepthDXGIFormat(TSD3D12Surface self) {
		TS_ASSERT(self);
		return ((D3D12Surface*)self)->getDepthDXGIFormat();
	}
	
	// Tellusim::D3D11Surface
	TS_CAPI TSD3D11Surface TS_CCALL tsD3D11Surface_new(void) {
		D3D11Surface *ret = new D3D11Surface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Surface)ret;
	}
	TS_CAPI TSD3D11Surface TS_CCALL tsD3D11Surface_new_D3D11C(TSD3D11Context context) {
		TS_ASSERT(context);
		D3D11Surface *ret = new D3D11Surface(*(D3D11Context*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Surface)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_delete(TSD3D11Surface self) {
		if(self) delete (D3D11Surface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Surface_equalPtr(const TSD3D11Surface self, const TSD3D11Surface ptr) {
		return (self && ptr && ((D3D11Surface*)self)->operator==(*(D3D11Surface*)ptr));
	}
	TS_CAPI TSD3D11Surface TS_CCALL tsD3D11Surface_copyPtr(TSD3D11Surface self) {
		D3D11Surface *ret = nullptr;
		if(self) ret = new D3D11Surface(*(D3D11Surface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Surface)ret;
	}
	TS_CAPI TSD3D11Surface TS_CCALL tsD3D11Surface_clonePtr(const TSD3D11Surface self) {
		D3D11Surface *ret = (self) ? new D3D11Surface(((D3D11Surface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSD3D11Surface)ret;
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_clearPtr(TSD3D11Surface self) {
		if(self) ((D3D11Surface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_destroyPtr(TSD3D11Surface self) {
		if(self) ((D3D11Surface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_acquirePtr(TSD3D11Surface self) {
		if(self) ((D3D11Surface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_unacquirePtr(TSD3D11Surface self) {
		if(self) ((D3D11Surface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Surface_isValidPtr(const TSD3D11Surface self) {
		return (self && ((D3D11Surface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Surface_isOwnerPtr(const TSD3D11Surface self) {
		return (self && ((D3D11Surface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Surface_isConstPtr(const TSD3D11Surface self) {
		return (self && ((D3D11Surface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Surface_getCountPtr(const TSD3D11Surface self) {
		return ((D3D11Surface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsD3D11Surface_getInternalPtr(const TSD3D11Surface self) {
		return ((D3D11Surface*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsD3D11Surface_equalSurfacePtr(const TSD3D11Surface self, const TSSurface base) {
		return (self && base && ((D3D11Surface*)self)->operator==(*(Surface*)base));
	}
	TS_CAPI TSD3D11Surface TS_CCALL tsD3D11Surface_castSurfacePtr(TSSurface base) {
		return (TSD3D11Surface)(new D3D11Surface(*(Surface*)base));
	}
	TS_CAPI TSSurface TS_CCALL tsD3D11Surface_baseSurfacePtr(TSD3D11Surface self) {
		return (TSSurface)(new Surface(((D3D11Surface*)self)->getSurface()));
	}
	TS_CAPI IDXGIFactory* TS_CCALL tsD3D11Surface_getFactory(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getFactory();
	}
	TS_CAPI ID3D11Device* TS_CCALL tsD3D11Surface_getDevice(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getDevice();
	}
	TS_CAPI ID3D11DeviceContext* TS_CCALL tsD3D11Surface_getContext(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getContext();
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_setSwapChain(TSD3D11Surface self, IDXGISwapChain *swap_chain) {
		TS_ASSERT(self);
		((D3D11Surface*)self)->setSwapChain(swap_chain);
	}
	TS_CAPI IDXGISwapChain* TS_CCALL tsD3D11Surface_getSwapChain(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getSwapChain();
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_setRenderTarget(TSD3D11Surface self, ID3D11Texture2D *render_target) {
		TS_ASSERT(self);
		((D3D11Surface*)self)->setRenderTarget(render_target);
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_setDepthStencil(TSD3D11Surface self, ID3D11Texture2D *depth_stencil) {
		TS_ASSERT(self);
		((D3D11Surface*)self)->setDepthStencil(depth_stencil);
	}
	TS_CAPI ID3D11Texture2D* TS_CCALL tsD3D11Surface_getRenderTarget(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getRenderTarget();
	}
	TS_CAPI ID3D11Texture2D* TS_CCALL tsD3D11Surface_getDepthStencil(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getDepthStencil();
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_setRenderTargetView(TSD3D11Surface self, ID3D11RenderTargetView *render_target_view) {
		TS_ASSERT(self);
		((D3D11Surface*)self)->setRenderTargetView(render_target_view);
	}
	TS_CAPI void TS_CCALL tsD3D11Surface_setDepthStencilView(TSD3D11Surface self, ID3D11DepthStencilView *depth_stencil_view) {
		TS_ASSERT(self);
		((D3D11Surface*)self)->setDepthStencilView(depth_stencil_view);
	}
	TS_CAPI ID3D11RenderTargetView* TS_CCALL tsD3D11Surface_getRenderTargetView(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getRenderTargetView();
	}
	TS_CAPI ID3D11DepthStencilView* TS_CCALL tsD3D11Surface_getDepthStencilView(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getDepthStencilView();
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Surface_getColorDXGIFormat(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getColorDXGIFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsD3D11Surface_getDepthDXGIFormat(TSD3D11Surface self) {
		TS_ASSERT(self);
		return ((D3D11Surface*)self)->getDepthDXGIFormat();
	}
	
	// Tellusim::MTLSurface
	TS_CAPI TSMTLSurface TS_CCALL tsMTLSurface_new(void) {
		MTLSurface *ret = new MTLSurface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSurface)ret;
	}
	TS_CAPI TSMTLSurface TS_CCALL tsMTLSurface_new_M(TSMTLContext context) {
		TS_ASSERT(context);
		MTLSurface *ret = new MTLSurface(*(MTLContext*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSurface)ret;
	}
	TS_CAPI void TS_CCALL tsMTLSurface_delete(TSMTLSurface self) {
		if(self) delete (MTLSurface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsMTLSurface_equalPtr(const TSMTLSurface self, const TSMTLSurface ptr) {
		return (self && ptr && ((MTLSurface*)self)->operator==(*(MTLSurface*)ptr));
	}
	TS_CAPI TSMTLSurface TS_CCALL tsMTLSurface_copyPtr(TSMTLSurface self) {
		MTLSurface *ret = nullptr;
		if(self) ret = new MTLSurface(*(MTLSurface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSurface)ret;
	}
	TS_CAPI TSMTLSurface TS_CCALL tsMTLSurface_clonePtr(const TSMTLSurface self) {
		MTLSurface *ret = (self) ? new MTLSurface(((MTLSurface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSMTLSurface)ret;
	}
	TS_CAPI void TS_CCALL tsMTLSurface_clearPtr(TSMTLSurface self) {
		if(self) ((MTLSurface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsMTLSurface_destroyPtr(TSMTLSurface self) {
		if(self) ((MTLSurface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsMTLSurface_acquirePtr(TSMTLSurface self) {
		if(self) ((MTLSurface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsMTLSurface_unacquirePtr(TSMTLSurface self) {
		if(self) ((MTLSurface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLSurface_isValidPtr(const TSMTLSurface self) {
		return (self && ((MTLSurface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLSurface_isOwnerPtr(const TSMTLSurface self) {
		return (self && ((MTLSurface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsMTLSurface_isConstPtr(const TSMTLSurface self) {
		return (self && ((MTLSurface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsMTLSurface_getCountPtr(const TSMTLSurface self) {
		return ((MTLSurface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsMTLSurface_getInternalPtr(const TSMTLSurface self) {
		return ((MTLSurface*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsMTLSurface_equalSurfacePtr(const TSMTLSurface self, const TSSurface base) {
		return (self && base && ((MTLSurface*)self)->operator==(*(Surface*)base));
	}
	TS_CAPI TSMTLSurface TS_CCALL tsMTLSurface_castSurfacePtr(TSSurface base) {
		return (TSMTLSurface)(new MTLSurface(*(Surface*)base));
	}
	TS_CAPI TSSurface TS_CCALL tsMTLSurface_baseSurfacePtr(TSMTLSurface self) {
		return (TSSurface)(new Surface(((MTLSurface*)self)->getSurface()));
	}
	TS_CAPI void* TS_CCALL tsMTLSurface_getDevice(TSMTLSurface self) {
		TS_ASSERT(self);
		return ((MTLSurface*)self)->getDevice();
	}
	TS_CAPI void* TS_CCALL tsMTLSurface_getQueue(TSMTLSurface self) {
		TS_ASSERT(self);
		return ((MTLSurface*)self)->getQueue();
	}
	TS_CAPI void* TS_CCALL tsMTLSurface_getCommand(TSMTLSurface self) {
		TS_ASSERT(self);
		return ((MTLSurface*)self)->getCommand();
	}
	TS_CAPI void TS_CCALL tsMTLSurface_setDescriptor(TSMTLSurface self, void *descriptor) {
		TS_ASSERT(self);
		((MTLSurface*)self)->setDescriptor(descriptor);
	}
	TS_CAPI void* TS_CCALL tsMTLSurface_getDescriptor(TSMTLSurface self) {
		TS_ASSERT(self);
		return ((MTLSurface*)self)->getDescriptor();
	}
	TS_CAPI uint32_t TS_CCALL tsMTLSurface_getColorPixelFormat(TSMTLSurface self) {
		TS_ASSERT(self);
		return ((MTLSurface*)self)->getColorPixelFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsMTLSurface_getDepthPixelFormat(TSMTLSurface self) {
		TS_ASSERT(self);
		return ((MTLSurface*)self)->getDepthPixelFormat();
	}
	
	// Tellusim::VKSurface
	TS_CAPI TSVKSurface TS_CCALL tsVKSurface_new(void) {
		VKSurface *ret = new VKSurface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKSurface)ret;
	}
	TS_CAPI TSVKSurface TS_CCALL tsVKSurface_new_V(TSVKContext context) {
		TS_ASSERT(context);
		VKSurface *ret = new VKSurface(*(VKContext*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKSurface)ret;
	}
	TS_CAPI void TS_CCALL tsVKSurface_delete(TSVKSurface self) {
		if(self) delete (VKSurface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsVKSurface_equalPtr(const TSVKSurface self, const TSVKSurface ptr) {
		return (self && ptr && ((VKSurface*)self)->operator==(*(VKSurface*)ptr));
	}
	TS_CAPI TSVKSurface TS_CCALL tsVKSurface_copyPtr(TSVKSurface self) {
		VKSurface *ret = nullptr;
		if(self) ret = new VKSurface(*(VKSurface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKSurface)ret;
	}
	TS_CAPI TSVKSurface TS_CCALL tsVKSurface_clonePtr(const TSVKSurface self) {
		VKSurface *ret = (self) ? new VKSurface(((VKSurface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSVKSurface)ret;
	}
	TS_CAPI void TS_CCALL tsVKSurface_clearPtr(TSVKSurface self) {
		if(self) ((VKSurface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsVKSurface_destroyPtr(TSVKSurface self) {
		if(self) ((VKSurface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsVKSurface_acquirePtr(TSVKSurface self) {
		if(self) ((VKSurface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsVKSurface_unacquirePtr(TSVKSurface self) {
		if(self) ((VKSurface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKSurface_isValidPtr(const TSVKSurface self) {
		return (self && ((VKSurface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKSurface_isOwnerPtr(const TSVKSurface self) {
		return (self && ((VKSurface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsVKSurface_isConstPtr(const TSVKSurface self) {
		return (self && ((VKSurface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsVKSurface_getCountPtr(const TSVKSurface self) {
		return ((VKSurface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsVKSurface_getInternalPtr(const TSVKSurface self) {
		return ((VKSurface*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsVKSurface_equalSurfacePtr(const TSVKSurface self, const TSSurface base) {
		return (self && base && ((VKSurface*)self)->operator==(*(Surface*)base));
	}
	TS_CAPI TSVKSurface TS_CCALL tsVKSurface_castSurfacePtr(TSSurface base) {
		return (TSVKSurface)(new VKSurface(*(Surface*)base));
	}
	TS_CAPI TSSurface TS_CCALL tsVKSurface_baseSurfacePtr(TSVKSurface self) {
		return (TSSurface)(new Surface(((VKSurface*)self)->getSurface()));
	}
	TS_CAPI VkInstance TS_CCALL tsVKSurface_getInstance(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getInstance();
	}
	TS_CAPI VkPhysicalDevice TS_CCALL tsVKSurface_getAdapter(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getAdapter();
	}
	TS_CAPI VkDevice TS_CCALL tsVKSurface_getDevice(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getDevice();
	}
	TS_CAPI VkQueue TS_CCALL tsVKSurface_getQueue(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getQueue();
	}
	TS_CAPI VkCommandBuffer TS_CCALL tsVKSurface_getCommand(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getCommand();
	}
	TS_CAPI uint32_t TS_CCALL tsVKSurface_getFamily(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getFamily();
	}
	TS_CAPI void TS_CCALL tsVKSurface_setColorImage(TSVKSurface self, VkImage image) {
		TS_ASSERT(self);
		((VKSurface*)self)->setColorImage(image);
	}
	TS_CAPI void TS_CCALL tsVKSurface_setDepthImage(TSVKSurface self, VkImage image) {
		TS_ASSERT(self);
		((VKSurface*)self)->setDepthImage(image);
	}
	TS_CAPI VkImage TS_CCALL tsVKSurface_getColorImage(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getColorImage();
	}
	TS_CAPI VkImage TS_CCALL tsVKSurface_getDepthImage(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getDepthImage();
	}
	TS_CAPI void TS_CCALL tsVKSurface_setColorImageView(TSVKSurface self, VkImageView image_view) {
		TS_ASSERT(self);
		((VKSurface*)self)->setColorImageView(image_view);
	}
	TS_CAPI void TS_CCALL tsVKSurface_setDepthImageView(TSVKSurface self, VkImageView image_view) {
		TS_ASSERT(self);
		((VKSurface*)self)->setDepthImageView(image_view);
	}
	TS_CAPI VkImageView TS_CCALL tsVKSurface_getColorImageView(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getColorImageView();
	}
	TS_CAPI VkImageView TS_CCALL tsVKSurface_getDepthImageView(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getDepthImageView();
	}
	TS_CAPI void TS_CCALL tsVKSurface_setRenderPass(TSVKSurface self, VkRenderPass render_pass) {
		TS_ASSERT(self);
		((VKSurface*)self)->setRenderPass(render_pass);
	}
	TS_CAPI void TS_CCALL tsVKSurface_setFramebuffer(TSVKSurface self, VkFramebuffer framebuffer) {
		TS_ASSERT(self);
		((VKSurface*)self)->setFramebuffer(framebuffer);
	}
	TS_CAPI VkRenderPass TS_CCALL tsVKSurface_getRenderPass(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getRenderPass();
	}
	TS_CAPI VkFramebuffer TS_CCALL tsVKSurface_getFramebuffer(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getFramebuffer();
	}
	TS_CAPI uint32_t TS_CCALL tsVKSurface_getColorPixelFormat(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getColorPixelFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsVKSurface_getDepthPixelFormat(TSVKSurface self) {
		TS_ASSERT(self);
		return ((VKSurface*)self)->getDepthPixelFormat();
	}
	
	// Tellusim::GLSurface
	TS_CAPI TSGLSurface TS_CCALL tsGLSurface_new(void) {
		GLSurface *ret = new GLSurface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLSurface)ret;
	}
	TS_CAPI TSGLSurface TS_CCALL tsGLSurface_new_G(TSGLContext context) {
		TS_ASSERT(context);
		GLSurface *ret = new GLSurface(*(GLContext*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLSurface)ret;
	}
	TS_CAPI void TS_CCALL tsGLSurface_delete(TSGLSurface self) {
		if(self) delete (GLSurface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLSurface_equalPtr(const TSGLSurface self, const TSGLSurface ptr) {
		return (self && ptr && ((GLSurface*)self)->operator==(*(GLSurface*)ptr));
	}
	TS_CAPI TSGLSurface TS_CCALL tsGLSurface_copyPtr(TSGLSurface self) {
		GLSurface *ret = nullptr;
		if(self) ret = new GLSurface(*(GLSurface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLSurface)ret;
	}
	TS_CAPI TSGLSurface TS_CCALL tsGLSurface_clonePtr(const TSGLSurface self) {
		GLSurface *ret = (self) ? new GLSurface(((GLSurface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLSurface)ret;
	}
	TS_CAPI void TS_CCALL tsGLSurface_clearPtr(TSGLSurface self) {
		if(self) ((GLSurface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLSurface_destroyPtr(TSGLSurface self) {
		if(self) ((GLSurface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLSurface_acquirePtr(TSGLSurface self) {
		if(self) ((GLSurface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLSurface_unacquirePtr(TSGLSurface self) {
		if(self) ((GLSurface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLSurface_isValidPtr(const TSGLSurface self) {
		return (self && ((GLSurface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLSurface_isOwnerPtr(const TSGLSurface self) {
		return (self && ((GLSurface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLSurface_isConstPtr(const TSGLSurface self) {
		return (self && ((GLSurface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLSurface_getCountPtr(const TSGLSurface self) {
		return ((GLSurface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLSurface_getInternalPtr(const TSGLSurface self) {
		return ((GLSurface*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLSurface_equalSurfacePtr(const TSGLSurface self, const TSSurface base) {
		return (self && base && ((GLSurface*)self)->operator==(*(Surface*)base));
	}
	TS_CAPI TSGLSurface TS_CCALL tsGLSurface_castSurfacePtr(TSSurface base) {
		return (TSGLSurface)(new GLSurface(*(Surface*)base));
	}
	TS_CAPI TSSurface TS_CCALL tsGLSurface_baseSurfacePtr(TSGLSurface self) {
		return (TSSurface)(new Surface(((GLSurface*)self)->getSurface()));
	}
	TS_CAPI void* TS_CCALL tsGLSurface_getContext(TSGLSurface self) {
		TS_ASSERT(self);
		return ((GLSurface*)self)->getContext();
	}
	TS_CAPI void TS_CCALL tsGLSurface_setColorTextureID(TSGLSurface self, uint32_t texture_id) {
		TS_ASSERT(self);
		((GLSurface*)self)->setColorTextureID(texture_id);
	}
	TS_CAPI void TS_CCALL tsGLSurface_setDepthTextureID(TSGLSurface self, uint32_t texture_id) {
		TS_ASSERT(self);
		((GLSurface*)self)->setDepthTextureID(texture_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLSurface_getColorTextureID(TSGLSurface self) {
		TS_ASSERT(self);
		return ((GLSurface*)self)->getColorTextureID();
	}
	TS_CAPI uint32_t TS_CCALL tsGLSurface_getDepthTextureID(TSGLSurface self) {
		TS_ASSERT(self);
		return ((GLSurface*)self)->getDepthTextureID();
	}
	TS_CAPI void TS_CCALL tsGLSurface_setFramebufferID(TSGLSurface self, uint32_t framebuffer_id) {
		TS_ASSERT(self);
		((GLSurface*)self)->setFramebufferID(framebuffer_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLSurface_getFramebufferID(TSGLSurface self) {
		TS_ASSERT(self);
		return ((GLSurface*)self)->getFramebufferID();
	}
	TS_CAPI uint32_t TS_CCALL tsGLSurface_getColorInternalFormat(TSGLSurface self) {
		TS_ASSERT(self);
		return ((GLSurface*)self)->getColorInternalFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsGLSurface_getDepthInternalFormat(TSGLSurface self) {
		TS_ASSERT(self);
		return ((GLSurface*)self)->getDepthInternalFormat();
	}
	
	// Tellusim::GLESSurface
	TS_CAPI TSGLESSurface TS_CCALL tsGLESSurface_new(void) {
		GLESSurface *ret = new GLESSurface();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESSurface)ret;
	}
	TS_CAPI TSGLESSurface TS_CCALL tsGLESSurface_new_G(TSGLESContext context) {
		TS_ASSERT(context);
		GLESSurface *ret = new GLESSurface(*(GLESContext*)context);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESSurface)ret;
	}
	TS_CAPI void TS_CCALL tsGLESSurface_delete(TSGLESSurface self) {
		if(self) delete (GLESSurface*)self;
	}
	TS_CAPI bool_t TS_CCALL tsGLESSurface_equalPtr(const TSGLESSurface self, const TSGLESSurface ptr) {
		return (self && ptr && ((GLESSurface*)self)->operator==(*(GLESSurface*)ptr));
	}
	TS_CAPI TSGLESSurface TS_CCALL tsGLESSurface_copyPtr(TSGLESSurface self) {
		GLESSurface *ret = nullptr;
		if(self) ret = new GLESSurface(*(GLESSurface*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESSurface)ret;
	}
	TS_CAPI TSGLESSurface TS_CCALL tsGLESSurface_clonePtr(const TSGLESSurface self) {
		GLESSurface *ret = (self) ? new GLESSurface(((GLESSurface*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSGLESSurface)ret;
	}
	TS_CAPI void TS_CCALL tsGLESSurface_clearPtr(TSGLESSurface self) {
		if(self) ((GLESSurface*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsGLESSurface_destroyPtr(TSGLESSurface self) {
		if(self) ((GLESSurface*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsGLESSurface_acquirePtr(TSGLESSurface self) {
		if(self) ((GLESSurface*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsGLESSurface_unacquirePtr(TSGLESSurface self) {
		if(self) ((GLESSurface*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESSurface_isValidPtr(const TSGLESSurface self) {
		return (self && ((GLESSurface*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESSurface_isOwnerPtr(const TSGLESSurface self) {
		return (self && ((GLESSurface*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsGLESSurface_isConstPtr(const TSGLESSurface self) {
		return (self && ((GLESSurface*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsGLESSurface_getCountPtr(const TSGLESSurface self) {
		return ((GLESSurface*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsGLESSurface_getInternalPtr(const TSGLESSurface self) {
		return ((GLESSurface*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsGLESSurface_equalSurfacePtr(const TSGLESSurface self, const TSSurface base) {
		return (self && base && ((GLESSurface*)self)->operator==(*(Surface*)base));
	}
	TS_CAPI TSGLESSurface TS_CCALL tsGLESSurface_castSurfacePtr(TSSurface base) {
		return (TSGLESSurface)(new GLESSurface(*(Surface*)base));
	}
	TS_CAPI TSSurface TS_CCALL tsGLESSurface_baseSurfacePtr(TSGLESSurface self) {
		return (TSSurface)(new Surface(((GLESSurface*)self)->getSurface()));
	}
	TS_CAPI void* TS_CCALL tsGLESSurface_getContext(TSGLESSurface self) {
		TS_ASSERT(self);
		return ((GLESSurface*)self)->getContext();
	}
	TS_CAPI void TS_CCALL tsGLESSurface_setColorTextureID(TSGLESSurface self, uint32_t texture_id) {
		TS_ASSERT(self);
		((GLESSurface*)self)->setColorTextureID(texture_id);
	}
	TS_CAPI void TS_CCALL tsGLESSurface_setDepthTextureID(TSGLESSurface self, uint32_t texture_id) {
		TS_ASSERT(self);
		((GLESSurface*)self)->setDepthTextureID(texture_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLESSurface_getColorTextureID(TSGLESSurface self) {
		TS_ASSERT(self);
		return ((GLESSurface*)self)->getColorTextureID();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESSurface_getDepthTextureID(TSGLESSurface self) {
		TS_ASSERT(self);
		return ((GLESSurface*)self)->getDepthTextureID();
	}
	TS_CAPI void TS_CCALL tsGLESSurface_setFramebufferID(TSGLESSurface self, uint32_t framebuffer_id) {
		TS_ASSERT(self);
		((GLESSurface*)self)->setFramebufferID(framebuffer_id);
	}
	TS_CAPI uint32_t TS_CCALL tsGLESSurface_getFramebufferID(TSGLESSurface self) {
		TS_ASSERT(self);
		return ((GLESSurface*)self)->getFramebufferID();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESSurface_getColorInternalFormat(TSGLESSurface self) {
		TS_ASSERT(self);
		return ((GLESSurface*)self)->getColorInternalFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsGLESSurface_getDepthInternalFormat(TSGLESSurface self) {
		TS_ASSERT(self);
		return ((GLESSurface*)self)->getDepthInternalFormat();
	}
	
	// Tellusim::Window
	TS_CAPI TSWindow TS_CCALL tsWindow_new(void) {
		Window *ret = new Window();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWindow)ret;
	}
	TS_CAPI TSWindow TS_CCALL tsWindow_new_Pu(TS_Platform platform, uint32_t index) {
		Window *ret = new Window((Platform)platform, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWindow)ret;
	}
	TS_CAPI TSWindow TS_CCALL tsWindow_new_S(TSSurface surface) {
		TS_ASSERT(surface);
		Window *ret = new Window(*(Surface*)surface);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWindow)ret;
	}
	TS_CAPI void TS_CCALL tsWindow_delete(TSWindow self) {
		if(self) delete (Window*)self;
	}
	TS_CAPI bool_t TS_CCALL tsWindow_equalPtr(const TSWindow self, const TSWindow ptr) {
		return (self && ptr && ((Window*)self)->operator==(*(Window*)ptr));
	}
	TS_CAPI TSWindow TS_CCALL tsWindow_copyPtr(TSWindow self) {
		Window *ret = nullptr;
		if(self) ret = new Window(*(Window*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWindow)ret;
	}
	TS_CAPI TSWindow TS_CCALL tsWindow_clonePtr(const TSWindow self) {
		Window *ret = (self) ? new Window(((Window*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSWindow)ret;
	}
	TS_CAPI void TS_CCALL tsWindow_clearPtr(TSWindow self) {
		if(self) ((Window*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsWindow_destroyPtr(TSWindow self) {
		if(self) ((Window*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsWindow_acquirePtr(TSWindow self) {
		if(self) ((Window*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsWindow_unacquirePtr(TSWindow self) {
		if(self) ((Window*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isValidPtr(const TSWindow self) {
		return (self && ((Window*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isOwnerPtr(const TSWindow self) {
		return (self && ((Window*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isConstPtr(const TSWindow self) {
		return (self && ((Window*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getCountPtr(const TSWindow self) {
		return ((Window*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsWindow_getInternalPtr(const TSWindow self) {
		return ((Window*)self)->getInternalPtr();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getNumWindows(void) {
		return Window::getNumWindows();
	}
	TS_CAPI TSWindow TS_CCALL tsWindow_getWindow(uint32_t index) {
		return (TSWindow)(new Window(Window::getWindow(index)));
	}
	TS_CAPI void TS_CCALL tsWindow_update(bool_t wait) {
		Window::update((bool)wait);
	}
	TS_CAPI TS_Platform TS_CCALL tsWindow_getPlatform(TSWindow self) {
		TS_ASSERT(self);
		return (TS_Platform)((Window*)self)->getPlatform();
	}
	TS_CAPI const char* TS_CCALL tsWindow_getPlatformName(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getPlatformName();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getIndex(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsWindow_setSurface(TSWindow self, TSSurface surface) {
		TS_ASSERT(self);
		TS_ASSERT(surface);
		((Window*)self)->setSurface(*(Surface*)surface);
	}
	TS_CAPI TSSurface TS_CCALL tsWindow_getSurface(TSWindow self) {
		TS_ASSERT(self);
		return (TSSurface)(new Surface(((Window*)self)->getSurface()));
	}
	TS_CAPI void* TS_CCALL tsWindow_getHandle(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getHandle();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isCreated(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_create_sWF(TSWindow self, const char *title, TS_WindowFlags flags) {
		TS_ASSERT(self);
		return ((Window*)self)->create(title, (Window::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_create_cSWF(TSWindow self, const TSString title, TS_WindowFlags flags) {
		TS_ASSERT(self);
		return ((Window*)self)->create((title) ? *(const String*)title : String::null, (Window::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_create_WF(TSWindow self, TS_WindowFlags flags) {
		TS_ASSERT(self);
		return ((Window*)self)->create((Window::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsWindow_release(TSWindow self) {
		TS_ASSERT(self);
		((Window*)self)->release();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_clear(TSWindow self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		return ((Window*)self)->clear(*(const Color*)color);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_grab(TSWindow self, TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((Window*)self)->grab(*(Image*)image);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_render(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->render();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_present(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->present();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_finish(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->finish();
	}
	TS_CAPI TS_Format TS_CCALL tsWindow_getColorFormat(TSWindow self) {
		TS_ASSERT(self);
		return (TS_Format)((Window*)self)->getColorFormat();
	}
	TS_CAPI TS_Format TS_CCALL tsWindow_getDepthFormat(TSWindow self) {
		TS_ASSERT(self);
		return (TS_Format)((Window*)self)->getDepthFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getMultisample(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMultisample();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_hasMultisample(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->hasMultisample();
	}
	TS_CAPI void TS_CCALL tsWindow_setFlags(TSWindow self, TS_WindowFlags flags) {
		TS_ASSERT(self);
		((Window*)self)->setFlags((Window::Flags)flags);
	}
	TS_CAPI TS_WindowFlags TS_CCALL tsWindow_getFlags(TSWindow self) {
		TS_ASSERT(self);
		return (TS_WindowFlags)((Window*)self)->getFlags();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_hasFlag(TSWindow self, TS_WindowFlags flags) {
		TS_ASSERT(self);
		return ((Window*)self)->hasFlag((Window::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_hasFlags(TSWindow self, TS_WindowFlags flags) {
		TS_ASSERT(self);
		return ((Window*)self)->hasFlags((Window::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsWindow_setRefreshRate(TSWindow self, uint32_t rate) {
		TS_ASSERT(self);
		((Window*)self)->setRefreshRate(rate);
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getRefreshRate(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getRefreshRate();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setHidden(TSWindow self, bool_t hidden) {
		TS_ASSERT(self);
		return ((Window*)self)->setHidden((bool)hidden);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isHidden(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isHidden();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setFocused(TSWindow self, bool_t focused) {
		TS_ASSERT(self);
		return ((Window*)self)->setFocused((bool)focused);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isFocused(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isFocused();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMinimized(TSWindow self, bool_t minimized) {
		TS_ASSERT(self);
		return ((Window*)self)->setMinimized((bool)minimized);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isMinimized(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isMinimized();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setFullscreen(TSWindow self, bool_t fullscreen) {
		TS_ASSERT(self);
		return ((Window*)self)->setFullscreen((bool)fullscreen);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isFullscreen(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isFullscreen();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isOccluded(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isOccluded();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setTitle_s(TSWindow self, const char *title) {
		TS_ASSERT(self);
		return ((Window*)self)->setTitle(title);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setTitle_cS(TSWindow self, const TSString title) {
		TS_ASSERT(self);
		return ((Window*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsWindow_getTitle(TSWindow self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Window*)self)->getTitle()));
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setIcon(TSWindow self, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((Window*)self)->setIcon(*(const Image*)image);
	}
	TS_CAPI TSImage TS_CCALL tsWindow_getIcon(TSWindow self) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((Window*)self)->getIcon()));
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setGeometry(TSWindow self, int32_t x, int32_t y, uint32_t width, uint32_t height, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setGeometry(x, y, width, height, (bool)force);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setPosition(TSWindow self, int32_t x, int32_t y, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setPosition(x, y, (bool)force);
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getPositionX(TSWindow self, bool_t title) {
		TS_ASSERT(self);
		return ((Window*)self)->getPositionX((bool)title);
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getPositionY(TSWindow self, bool_t title) {
		TS_ASSERT(self);
		return ((Window*)self)->getPositionY((bool)title);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setSize(TSWindow self, uint32_t width, uint32_t height, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setSize(width, height, (bool)force);
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getWidth(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getHeight(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getHeight();
	}
	TS_CAPI float32_t TS_CCALL tsWindow_getScale(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getScale();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getDpiX(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getDpiX();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getDpiY(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getDpiY();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMinSize(TSWindow self, uint32_t width, uint32_t height, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setMinSize(width, height, (bool)force);
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getMinWidth(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMinWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getMinHeight(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMinHeight();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMaxSize(TSWindow self, uint32_t width, uint32_t height, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setMaxSize(width, height, (bool)force);
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getMaxWidth(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMaxWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getMaxHeight(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMaxHeight();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouse(TSWindow self, int32_t x, int32_t y, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouse(x, y, (bool)force);
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getMouseX(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMouseX();
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getMouseY(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMouseY();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseDelta(TSWindow self, int32_t dx, int32_t dy) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseDelta(dx, dy);
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getMouseDX(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMouseDX();
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getMouseDY(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getMouseDY();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseHidden(TSWindow self, bool_t hidden, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseHidden((bool)hidden, (bool)force);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isMouseHidden(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isMouseHidden();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseClipped(TSWindow self, bool_t clipped, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseClipped((bool)clipped, (bool)force);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isMouseClipped(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isMouseClipped();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isMouseInside(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isMouseInside();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseCursor(TSWindow self, TS_WindowCursor cursor, bool_t force) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseCursor((Window::Cursor)cursor, (bool)force);
	}
	TS_CAPI TS_WindowCursor TS_CCALL tsWindow_getMouseCursor(TSWindow self) {
		TS_ASSERT(self);
		return (TS_WindowCursor)((Window*)self)->getMouseCursor();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseButtons(TSWindow self, TS_WindowButton buttons) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseButtons((Window::Button)buttons);
	}
	TS_CAPI TS_WindowButton TS_CCALL tsWindow_getMouseButtons(TSWindow self) {
		TS_ASSERT(self);
		return (TS_WindowButton)((Window*)self)->getMouseButtons();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseButton(TSWindow self, TS_WindowButton button, bool_t value) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseButton((Window::Button)button, (bool)value);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_getMouseButton(TSWindow self, TS_WindowButton button, bool_t clear) {
		TS_ASSERT(self);
		return ((Window*)self)->getMouseButton((Window::Button)button, (bool)clear);
	}
	TS_CAPI void TS_CCALL tsWindow_releaseMouseButtons(TSWindow self, TS_WindowButton buttons) {
		TS_ASSERT(self);
		((Window*)self)->releaseMouseButtons((Window::Button)buttons);
	}
	TS_CAPI TS_WindowButton TS_CCALL tsWindow_clearMouseButtons(TSWindow self) {
		TS_ASSERT(self);
		return (TS_WindowButton)((Window*)self)->clearMouseButtons();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setMouseAxis(TSWindow self, TS_WindowAxis axis, float32_t value) {
		TS_ASSERT(self);
		return ((Window*)self)->setMouseAxis((Window::Axis)axis, value);
	}
	TS_CAPI float32_t TS_CCALL tsWindow_getMouseAxis(TSWindow self, TS_WindowAxis axis) {
		TS_ASSERT(self);
		return ((Window*)self)->getMouseAxis((Window::Axis)axis);
	}
	TS_CAPI float32_t TS_CCALL tsWindow_clearMouseAxis(TSWindow self, TS_WindowAxis axis) {
		TS_ASSERT(self);
		return ((Window*)self)->clearMouseAxis((Window::Axis)axis);
	}
	TS_CAPI void TS_CCALL tsWindow_setMousePressedCallback(TSWindow self, const TSWindowMousePressedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setMousePressedCallback(makeTSWindowMousePressedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setMouseReleasedCallback(TSWindow self, const TSWindowMouseReleasedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setMouseReleasedCallback(makeTSWindowMouseReleasedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setMouseChangedCallback(TSWindow self, const TSWindowMouseChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setMouseChangedCallback(makeTSWindowMouseChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setMouseRotatedCallback(TSWindow self, const TSWindowMouseRotatedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setMouseRotatedCallback(makeTSWindowMouseRotatedCallback(func, data_));
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_getNumTouches(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->getNumTouches();
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_addTouch(TSWindow self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		return ((Window*)self)->addTouch(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getTouchX(TSWindow self, uint32_t touch) {
		TS_ASSERT(self);
		return ((Window*)self)->getTouchX(touch);
	}
	TS_CAPI int32_t TS_CCALL tsWindow_getTouchY(TSWindow self, uint32_t touch) {
		TS_ASSERT(self);
		return ((Window*)self)->getTouchY(touch);
	}
	TS_CAPI uint32_t TS_CCALL tsWindow_findTouch(TSWindow self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		return ((Window*)self)->findTouch(x, y);
	}
	TS_CAPI void TS_CCALL tsWindow_clearTouches(TSWindow self) {
		TS_ASSERT(self);
		((Window*)self)->clearTouches();
	}
	TS_CAPI void TS_CCALL tsWindow_setTouchChangedCallback(TSWindow self, const TSWindowTouchChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setTouchChangedCallback(makeTSWindowTouchChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setKeyboardKey(TSWindow self, uint32_t key, bool_t value) {
		TS_ASSERT(self);
		((Window*)self)->setKeyboardKey(key, (bool)value);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_getKeyboardKey(TSWindow self, uint32_t key, bool_t clear) {
		TS_ASSERT(self);
		return ((Window*)self)->getKeyboardKey(key, (bool)clear);
	}
	TS_CAPI void TS_CCALL tsWindow_setKeyboardPressedCallback(TSWindow self, const TSWindowKeyboardPressedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setKeyboardPressedCallback(makeTSWindowKeyboardPressedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setKeyboardReleasedCallback(TSWindow self, const TSWindowKeyboardReleasedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setKeyboardReleasedCallback(makeTSWindowKeyboardReleasedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setSizeChangedCallback(TSWindow self, const TSWindowSizeChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setSizeChangedCallback(makeTSWindowSizeChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setFocusChangedCallback(TSWindow self, const TSWindowFocusChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setFocusChangedCallback(makeTSWindowFocusChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setCloseClickedCallback(TSWindow self, const TSWindowCloseClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setCloseClickedCallback(makeTSWindowCloseClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setPauseChangedCallback(TSWindow self, const TSWindowPauseChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setPauseChangedCallback(makeTSWindowPauseChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setFileDroppedCallback(TSWindow self, const TSWindowFileDroppedCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setFileDroppedCallback(makeTSWindowFileDroppedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setUpdateCallback(TSWindow self, const TSWindowUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setUpdateCallback(makeTSWindowUpdateCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsWindow_setPresentCallback(TSWindow self, const TSWindowPresentCallback func, void *data_) {
		TS_ASSERT(self);
		((Window*)self)->setPresentCallback(makeTSWindowPresentCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsWindow_run(TSWindow self, const TSWindowMainLoopCallback func, void *data_) {
		TS_ASSERT(self);
		return ((Window*)self)->run(makeTSWindowMainLoopCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsWindow_isRunning(TSWindow self) {
		TS_ASSERT(self);
		return ((Window*)self)->isRunning();
	}
	TS_CAPI void TS_CCALL tsWindow_stop(TSWindow self) {
		TS_ASSERT(self);
		((Window*)self)->stop();
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setCopyText_s(TSWindow self, const char *text) {
		TS_ASSERT(self);
		return ((Window*)self)->setCopyText(text);
	}
	TS_CAPI bool_t TS_CCALL tsWindow_setCopyText_cS(TSWindow self, const TSString text) {
		TS_ASSERT(self);
		return ((Window*)self)->setCopyText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsWindow_getPasteText(TSWindow self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Window*)self)->getPasteText()));
	}
	
	// Tellusim::Font
	TS_CAPI TSFont TS_CCALL tsFont_new(void) {
		Font *ret = new Font();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFont)ret;
	}
	TS_CAPI void TS_CCALL tsFont_delete(TSFont self) {
		if(self) delete (Font*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFont_equalPtr(const TSFont self, const TSFont ptr) {
		return (self && ptr && ((Font*)self)->operator==(*(Font*)ptr));
	}
	TS_CAPI TSFont TS_CCALL tsFont_copyPtr(TSFont self) {
		Font *ret = nullptr;
		if(self) ret = new Font(*(Font*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFont)ret;
	}
	TS_CAPI TSFont TS_CCALL tsFont_clonePtr(const TSFont self) {
		Font *ret = (self) ? new Font(((Font*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFont)ret;
	}
	TS_CAPI void TS_CCALL tsFont_clearPtr(TSFont self) {
		if(self) ((Font*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFont_destroyPtr(TSFont self) {
		if(self) ((Font*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFont_acquirePtr(TSFont self) {
		if(self) ((Font*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFont_unacquirePtr(TSFont self) {
		if(self) ((Font*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFont_isValidPtr(const TSFont self) {
		return (self && ((Font*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFont_isOwnerPtr(const TSFont self) {
		return (self && ((Font*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFont_isConstPtr(const TSFont self) {
		return (self && ((Font*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFont_getCountPtr(const TSFont self) {
		return ((Font*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFont_getInternalPtr(const TSFont self) {
		return ((Font*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsFont_clear(TSFont self) {
		TS_ASSERT(self);
		((Font*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsFont_isLoaded(TSFont self) {
		TS_ASSERT(self);
		return ((Font*)self)->isLoaded();
	}
	TS_CAPI bool_t TS_CCALL tsFont_load_s(TSFont self, const char *name) {
		TS_ASSERT(self);
		return ((Font*)self)->load(name);
	}
	TS_CAPI bool_t TS_CCALL tsFont_load_St(TSFont self, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Font*)self)->load(*(Stream*)stream);
	}
	TS_CAPI float32_t TS_CCALL tsFont_getAdvance(TSFont self, const TSFontStyle *style, uint32_t code) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		return ((Font*)self)->getAdvance(*(const FontStyle*)style, code);
	}
	TS_CAPI TSRect TS_CCALL tsFont_getRect_cV3cFSs(TSFont self, const TSVector3f *position, const TSFontStyle *style, const char *str) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		TS_ASSERT(style);
		Rect ret = ((Font*)self)->getRect(*(const Vector3f*)position, *(const FontStyle*)style, str);
		return *(TSRect*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsFont_getRect_cV3cFSup(TSFont self, const TSVector3f *position, const TSFontStyle *style, const uint32_t *str) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		TS_ASSERT(style);
		Rect ret = ((Font*)self)->getRect(*(const Vector3f*)position, *(const FontStyle*)style, str);
		return *(TSRect*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsFont_getRect_cFBu(TSFont self, const TSFontBatch *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		Rect ret = ((Font*)self)->getRect(*(const FontBatch**)&batches, num_batches);
		return *(TSRect*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsFont_getRect_cFB32u(TSFont self, const TSFontBatch32 *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		Rect ret = ((Font*)self)->getRect(*(const FontBatch32**)&batches, num_batches);
		return *(TSRect*)&ret;
	}
	TS_CAPI void TS_CCALL tsFont_create_cDcFSs(TSFont self, const TSDevice device, const TSFontStyle *style, const char *str) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(style);
		((Font*)self)->create(*(const Device*)device, *(const FontStyle*)style, str);
	}
	TS_CAPI void TS_CCALL tsFont_create_cDcFSup(TSFont self, const TSDevice device, const TSFontStyle *style, const uint32_t *str) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(style);
		((Font*)self)->create(*(const Device*)device, *(const FontStyle*)style, str);
	}
	TS_CAPI void TS_CCALL tsFont_create_cDcFBu(TSFont self, const TSDevice device, const TSFontBatch *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		((Font*)self)->create(*(const Device*)device, *(const FontBatch**)&batches, num_batches);
	}
	TS_CAPI void TS_CCALL tsFont_create_cDcFB32u(TSFont self, const TSDevice device, const TSFontBatch32 *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		((Font*)self)->create(*(const Device*)device, *(const FontBatch32**)&batches, num_batches);
	}
	TS_CAPI void TS_CCALL tsFont_draw_CcV3cFSs(TSFont self, TSCommand command, const TSVector3f *position, const TSFontStyle *style, const char *str) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		TS_ASSERT(position);
		TS_ASSERT(style);
		((Font*)self)->draw(*(Command*)command, *(const Vector3f*)position, *(const FontStyle*)style, str);
	}
	TS_CAPI void TS_CCALL tsFont_draw_CcV3cFSup(TSFont self, TSCommand command, const TSVector3f *position, const TSFontStyle *style, const uint32_t *str) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		TS_ASSERT(position);
		TS_ASSERT(style);
		((Font*)self)->draw(*(Command*)command, *(const Vector3f*)position, *(const FontStyle*)style, str);
	}
	TS_CAPI void TS_CCALL tsFont_draw_CcFBu(TSFont self, TSCommand command, const TSFontBatch *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((Font*)self)->draw(*(Command*)command, *(const FontBatch**)&batches, num_batches);
	}
	TS_CAPI void TS_CCALL tsFont_draw_CcFB32u(TSFont self, TSCommand command, const TSFontBatch32 *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((Font*)self)->draw(*(Command*)command, *(const FontBatch32**)&batches, num_batches);
	}
	TS_CAPI bool_t TS_CCALL tsFont_flush(TSFont self, const TSDevice device) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((Font*)self)->flush(*(const Device*)device);
	}
	
	// Tellusim::CanvasElement
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasElement_new(void) {
		CanvasElement *ret = new CanvasElement();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasElement)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasElement_delete(TSCanvasElement self) {
		if(self) delete (CanvasElement*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_equalPtr(const TSCanvasElement self, const TSCanvasElement ptr) {
		return (self && ptr && ((CanvasElement*)self)->operator==(*(CanvasElement*)ptr));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasElement_copyPtr(TSCanvasElement self) {
		CanvasElement *ret = nullptr;
		if(self) ret = new CanvasElement(*(CanvasElement*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasElement)ret;
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasElement_clonePtr(const TSCanvasElement self) {
		CanvasElement *ret = (self) ? new CanvasElement(((CanvasElement*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasElement)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasElement_clearPtr(TSCanvasElement self) {
		if(self) ((CanvasElement*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_destroyPtr(TSCanvasElement self) {
		if(self) ((CanvasElement*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_acquirePtr(TSCanvasElement self) {
		if(self) ((CanvasElement*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_unacquirePtr(TSCanvasElement self) {
		if(self) ((CanvasElement*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isValidPtr(const TSCanvasElement self) {
		return (self && ((CanvasElement*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isOwnerPtr(const TSCanvasElement self) {
		return (self && ((CanvasElement*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isConstPtr(const TSCanvasElement self) {
		return (self && ((CanvasElement*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasElement_getCountPtr(const TSCanvasElement self) {
		return ((CanvasElement*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasElement_getInternalPtr(const TSCanvasElement self) {
		return ((CanvasElement*)self)->getInternalPtr();
	}
	TS_CAPI TS_CanvasElementType TS_CCALL tsCanvasElement_getType(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_CanvasElementType)((CanvasElement*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsCanvasElement_getTypeName_CET(TS_CanvasElementType type) {
		return CanvasElement::getTypeName((CanvasElement::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsCanvasElement_getTypeName_c(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isText(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isText();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isMesh(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isMesh();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isRect(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isRect();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isTriangle(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isTriangle();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isEllipse(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isEllipse();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isShape(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isShape();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isStrip(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isStrip();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setCanvas(TSCanvasElement self, TSCanvas canvas) {
		TS_ASSERT(self);
		TS_ASSERT(canvas);
		((CanvasElement*)self)->setCanvas(*(Canvas*)canvas);
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvasElement_getCanvas_c(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((CanvasElement*)self)->getCanvas()));
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvasElement_getCanvas(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((CanvasElement*)self)->getCanvas()));
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setMode(TSCanvasElement self, TS_CanvasElementMode mode) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setMode((CanvasElement::Mode)mode);
	}
	TS_CAPI TS_CanvasElementMode TS_CCALL tsCanvasElement_getMode(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_CanvasElementMode)((CanvasElement*)self)->getMode();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setAlign(TSCanvasElement self, TS_CanvasElementAlign align) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setAlign((CanvasElement::Align)align);
	}
	TS_CAPI TS_CanvasElementAlign TS_CCALL tsCanvasElement_getAlign(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_CanvasElementAlign)((CanvasElement*)self)->getAlign();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_hasAlign(TSCanvasElement self, TS_CanvasElementAlign align) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->hasAlign((CanvasElement::Align)align);
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_hasAligns(TSCanvasElement self, TS_CanvasElementAlign aligns) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->hasAligns((CanvasElement::Align)aligns);
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setOrder(TSCanvasElement self, int32_t order) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setOrder(order);
	}
	TS_CAPI int32_t TS_CCALL tsCanvasElement_getOrder(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->getOrder();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setEnabled(TSCanvasElement self, bool_t enabled) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setEnabled((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_isEnabled(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->isEnabled();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_clearColor(TSCanvasElement self) {
		TS_ASSERT(self);
		((CanvasElement*)self)->clearColor();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setColor_CES(TSCanvasElement self, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setColor((CanvasElement::Stack)op);
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setColor_cCCES(TSCanvasElement self, const TSColor *color, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasElement*)self)->setColor(*(const Color*)color, (CanvasElement::Stack)op);
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setColor_ffffCES(TSCanvasElement self, float32_t r, float32_t g, float32_t b, float32_t a, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setColor(r, g, b, a, (CanvasElement::Stack)op);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasElement_getColor(TSCanvasElement self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasElement*)self)->getColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI TS_CanvasElementStack TS_CCALL tsCanvasElement_getColorOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_CanvasElementStack)((CanvasElement*)self)->getColorOp();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_clearTransform(TSCanvasElement self) {
		TS_ASSERT(self);
		((CanvasElement*)self)->clearTransform();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setTransform_CES(TSCanvasElement self, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setTransform((CanvasElement::Stack)op);
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setTransform_cM44CES(TSCanvasElement self, const TSMatrix4x4f *transform, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((CanvasElement*)self)->setTransform(*(const Matrix4x4f*)transform, (CanvasElement::Stack)op);
	}
	TS_CAPI TSMatrix4x4f TS_CCALL tsCanvasElement_getTransform(TSCanvasElement self) {
		TS_ASSERT(self);
		const Matrix4x4f ret = ((CanvasElement*)self)->getTransform();
		return *(TSMatrix4x4f*)&ret;
	}
	TS_CAPI TS_CanvasElementStack TS_CCALL tsCanvasElement_getTransformOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_CanvasElementStack)((CanvasElement*)self)->getTransformOp();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_clearScissor(TSCanvasElement self) {
		TS_ASSERT(self);
		((CanvasElement*)self)->clearScissor();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setScissor_CES(TSCanvasElement self, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setScissor((CanvasElement::Stack)op);
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setScissor_cRCES(TSCanvasElement self, const TSRect *scissor, TS_CanvasElementStack op) {
		TS_ASSERT(self);
		TS_ASSERT(scissor);
		((CanvasElement*)self)->setScissor(*(const Rect*)scissor, (CanvasElement::Stack)op);
	}
	TS_CAPI TSRect TS_CCALL tsCanvasElement_getScissor(TSCanvasElement self) {
		TS_ASSERT(self);
		const Rect ret = ((CanvasElement*)self)->getScissor();
		return *(TSRect*)&ret;
	}
	TS_CAPI TS_CanvasElementStack TS_CCALL tsCanvasElement_getScissorOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_CanvasElementStack)((CanvasElement*)self)->getScissorOp();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setMipmap(TSCanvasElement self, float32_t mipmap) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setMipmap(mipmap);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasElement_getMipmap(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->getMipmap();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setSampler(TSCanvasElement self, TSSampler sampler) {
		TS_ASSERT(self);
		TS_ASSERT(sampler);
		((CanvasElement*)self)->setSampler(*(Sampler*)sampler);
	}
	TS_CAPI TSSampler TS_CCALL tsCanvasElement_getSampler(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TSSampler)(new Sampler(((CanvasElement*)self)->getSampler()));
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setFilter(TSCanvasElement self, TS_SamplerFilter filter) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setFilter((Sampler::Filter)filter);
	}
	TS_CAPI TS_SamplerFilter TS_CCALL tsCanvasElement_getFilter(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_SamplerFilter)((CanvasElement*)self)->getFilter();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setAnisotropy(TSCanvasElement self, uint32_t anisotropy) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setAnisotropy(anisotropy);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasElement_getAnisotropy(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->getAnisotropy();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setWrapMode(TSCanvasElement self, TS_SamplerWrapMode mode) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setWrapMode((Sampler::WrapMode)mode);
	}
	TS_CAPI TS_SamplerWrapMode TS_CCALL tsCanvasElement_getWrapMode(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_SamplerWrapMode)((CanvasElement*)self)->getWrapMode();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setTexture(TSCanvasElement self, TSTexture texture, bool_t linear) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((CanvasElement*)self)->setTexture(*(Texture*)texture, (bool)linear);
	}
	TS_CAPI TSTexture TS_CCALL tsCanvasElement_getTexture(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((CanvasElement*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsCanvasElement_getTextureLinear(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->getTextureLinear();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setPipeline(TSCanvasElement self, TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((CanvasElement*)self)->setPipeline(*(Pipeline*)pipeline);
	}
	TS_CAPI TSPipeline TS_CCALL tsCanvasElement_getPipeline(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((CanvasElement*)self)->getPipeline()));
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setPrimitive(TSCanvasElement self, TS_PipelinePrimitive primitive) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setPrimitive((Pipeline::Primitive)primitive);
	}
	TS_CAPI TS_PipelinePrimitive TS_CCALL tsCanvasElement_getPrimitive(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelinePrimitive)((CanvasElement*)self)->getPrimitive();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setCullMode(TSCanvasElement self, TS_PipelineCullMode mode) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setCullMode((Pipeline::CullMode)mode);
	}
	TS_CAPI TS_PipelineCullMode TS_CCALL tsCanvasElement_getCullMode(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineCullMode)((CanvasElement*)self)->getCullMode();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setFrontMode(TSCanvasElement self, TS_PipelineFrontMode mode) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setFrontMode((Pipeline::FrontMode)mode);
	}
	TS_CAPI TS_PipelineFrontMode TS_CCALL tsCanvasElement_getFrontMode(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineFrontMode)((CanvasElement*)self)->getFrontMode();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setBlend(TSCanvasElement self, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setBlend((Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI TS_PipelineBlendOp TS_CCALL tsCanvasElement_getBlendOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendOp)((CanvasElement*)self)->getBlendOp();
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsCanvasElement_getBlendSrcFunc(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((CanvasElement*)self)->getBlendSrcFunc();
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsCanvasElement_getBlendDestFunc(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((CanvasElement*)self)->getBlendDestFunc();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setColorMask(TSCanvasElement self, TS_PipelineColorMask mask) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setColorMask((Pipeline::ColorMask)mask);
	}
	TS_CAPI TS_PipelineColorMask TS_CCALL tsCanvasElement_getColorMask(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineColorMask)((CanvasElement*)self)->getColorMask();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setDepthMask(TSCanvasElement self, TS_PipelineDepthMask mask) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setDepthMask((Pipeline::DepthMask)mask);
	}
	TS_CAPI TS_PipelineDepthMask TS_CCALL tsCanvasElement_getDepthMask(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineDepthMask)((CanvasElement*)self)->getDepthMask();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setDepthFunc(TSCanvasElement self, TS_PipelineDepthFunc func) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setDepthFunc((Pipeline::DepthFunc)func);
	}
	TS_CAPI TS_PipelineDepthFunc TS_CCALL tsCanvasElement_getDepthFunc(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineDepthFunc)((CanvasElement*)self)->getDepthFunc();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setStencilRef(TSCanvasElement self, uint32_t ref) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setStencilRef(ref);
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setStencilFunc(TSCanvasElement self, TS_PipelineStencilFunc func, TS_PipelineStencilOp fail_op, TS_PipelineStencilOp dfail_op, TS_PipelineStencilOp dpass_op) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setStencilFunc((Pipeline::StencilFunc)func, (Pipeline::StencilOp)fail_op, (Pipeline::StencilOp)dfail_op, (Pipeline::StencilOp)dpass_op);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasElement_getStencilRef(TSCanvasElement self) {
		TS_ASSERT(self);
		return ((CanvasElement*)self)->getStencilRef();
	}
	TS_CAPI TS_PipelineStencilFunc TS_CCALL tsCanvasElement_getStencilFunc(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilFunc)((CanvasElement*)self)->getStencilFunc();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsCanvasElement_getStencilFailOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((CanvasElement*)self)->getStencilFailOp();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsCanvasElement_getStencilDepthFailOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((CanvasElement*)self)->getStencilDepthFailOp();
	}
	TS_CAPI TS_PipelineStencilOp TS_CCALL tsCanvasElement_getStencilDepthPassOp(TSCanvasElement self) {
		TS_ASSERT(self);
		return (TS_PipelineStencilOp)((CanvasElement*)self)->getStencilDepthPassOp();
	}
	TS_CAPI void TS_CCALL tsCanvasElement_setDrawCallback(TSCanvasElement self, const TSCanvasElementDrawCallback func, void *data_) {
		TS_ASSERT(self);
		((CanvasElement*)self)->setDrawCallback(makeTSCanvasElementDrawCallback(func, data_));
	}
	TS_CAPI TSRect TS_CCALL tsCanvasElement_getRect(TSCanvasElement self) {
		TS_ASSERT(self);
		const Rect ret = ((CanvasElement*)self)->getRect();
		return *(TSRect*)&ret;
	}
	
	// Tellusim::CanvasText
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_new(void) {
		CanvasText *ret = new CanvasText();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasText)ret;
	}
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasText *ret = new CanvasText(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasText)ret;
	}
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_new_Cs(TSCanvas canvas, const char *text) {
		TS_ASSERT(canvas);
		CanvasText *ret = new CanvasText(*(Canvas*)canvas, text);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasText)ret;
	}
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_new_CcS(TSCanvas canvas, const TSString text) {
		TS_ASSERT(canvas);
		CanvasText *ret = new CanvasText(*(Canvas*)canvas, (text) ? *(const String*)text : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasText)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasText_delete(TSCanvasText self) {
		if(self) delete (CanvasText*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_equalPtr(const TSCanvasText self, const TSCanvasText ptr) {
		return (self && ptr && ((CanvasText*)self)->operator==(*(CanvasText*)ptr));
	}
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_copyPtr(TSCanvasText self) {
		CanvasText *ret = nullptr;
		if(self) ret = new CanvasText(*(CanvasText*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasText)ret;
	}
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_clonePtr(const TSCanvasText self) {
		CanvasText *ret = (self) ? new CanvasText(((CanvasText*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasText)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasText_clearPtr(TSCanvasText self) {
		if(self) ((CanvasText*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasText_destroyPtr(TSCanvasText self) {
		if(self) ((CanvasText*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasText_acquirePtr(TSCanvasText self) {
		if(self) ((CanvasText*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasText_unacquirePtr(TSCanvasText self) {
		if(self) ((CanvasText*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_isValidPtr(const TSCanvasText self) {
		return (self && ((CanvasText*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_isOwnerPtr(const TSCanvasText self) {
		return (self && ((CanvasText*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_isConstPtr(const TSCanvasText self) {
		return (self && ((CanvasText*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasText_getCountPtr(const TSCanvasText self) {
		return ((CanvasText*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasText_getInternalPtr(const TSCanvasText self) {
		return ((CanvasText*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_equalCanvasElementPtr(const TSCanvasText self, const TSCanvasElement base) {
		return (self && base && ((CanvasText*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasText TS_CCALL tsCanvasText_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasText)(new CanvasText(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasText_baseCanvasElementPtr(TSCanvasText self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasText*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasText_setFontName_s(TSCanvasText self, const char *name) {
		TS_ASSERT(self);
		((CanvasText*)self)->setFontName(name);
	}
	TS_CAPI void TS_CCALL tsCanvasText_setFontName_cS(TSCanvasText self, const TSString name) {
		TS_ASSERT(self);
		((CanvasText*)self)->setFontName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsCanvasText_getFontName(TSCanvasText self) {
		TS_ASSERT(self);
		return (TSString)(new String(((CanvasText*)self)->getFontName()));
	}
	TS_CAPI void TS_CCALL tsCanvasText_setFontColor(TSCanvasText self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasText*)self)->setFontColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasText_getFontColor(TSCanvasText self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasText*)self)->getFontColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_setFontSize(TSCanvasText self, uint32_t scale) {
		TS_ASSERT(self);
		return ((CanvasText*)self)->setFontSize(scale);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasText_getFontSize(TSCanvasText self) {
		TS_ASSERT(self);
		return ((CanvasText*)self)->getFontSize();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_setFontScale(TSCanvasText self, uint32_t scale) {
		TS_ASSERT(self);
		return ((CanvasText*)self)->setFontScale(scale);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasText_getFontScale(TSCanvasText self) {
		TS_ASSERT(self);
		return ((CanvasText*)self)->getFontScale();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasText_setFontStyle(TSCanvasText self, const TSFontStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		return ((CanvasText*)self)->setFontStyle(*(const FontStyle*)style);
	}
	TS_CAPI TSFontStyle TS_CCALL tsCanvasText_getFontStyleConst(TSCanvasText self) {
		TS_ASSERT(self);
		const FontStyle ret = ((CanvasText*)self)->getFontStyleConst();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsCanvasText_getFontStyle_c(TSCanvasText self) {
		TS_ASSERT(self);
		const FontStyle ret = ((CanvasText*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsCanvasText_getFontStyle(TSCanvasText self) {
		TS_ASSERT(self);
		FontStyle ret = ((CanvasText*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasText_setPosition_cV3(TSCanvasText self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasText*)self)->setPosition(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasText_setPosition_fff(TSCanvasText self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasText*)self)->setPosition(x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasText_getPosition(TSCanvasText self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasText*)self)->getPosition();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasText_setText_s(TSCanvasText self, const char *text) {
		TS_ASSERT(self);
		((CanvasText*)self)->setText(text);
	}
	TS_CAPI void TS_CCALL tsCanvasText_setText_cS(TSCanvasText self, const TSString text) {
		TS_ASSERT(self);
		((CanvasText*)self)->setText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsCanvasText_getText(TSCanvasText self) {
		TS_ASSERT(self);
		return (TSString)(new String(((CanvasText*)self)->getText()));
	}
	TS_CAPI void TS_CCALL tsCanvasText_clearBatches(TSCanvasText self) {
		TS_ASSERT(self);
		((CanvasText*)self)->clearBatches();
	}
	TS_CAPI void TS_CCALL tsCanvasText_setBatches_cFBu(TSCanvasText self, const TSFontBatch *batches, uint32_t num_batches) {
		TS_ASSERT(self);
		((CanvasText*)self)->setBatches(*(const FontBatch**)&batches, num_batches);
	}
	
	// Tellusim::CanvasMesh
	TS_CAPI TSCanvasMesh TS_CCALL tsCanvasMesh_new(void) {
		CanvasMesh *ret = new CanvasMesh();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasMesh)ret;
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsCanvasMesh_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasMesh *ret = new CanvasMesh(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasMesh)ret;
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsCanvasMesh_new_CCEM(TSCanvas canvas, TS_CanvasElementMode mode) {
		TS_ASSERT(canvas);
		CanvasMesh *ret = new CanvasMesh(*(Canvas*)canvas, (CanvasElement::Mode)mode);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasMesh)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_delete(TSCanvasMesh self) {
		if(self) delete (CanvasMesh*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasMesh_equalPtr(const TSCanvasMesh self, const TSCanvasMesh ptr) {
		return (self && ptr && ((CanvasMesh*)self)->operator==(*(CanvasMesh*)ptr));
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsCanvasMesh_copyPtr(TSCanvasMesh self) {
		CanvasMesh *ret = nullptr;
		if(self) ret = new CanvasMesh(*(CanvasMesh*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasMesh)ret;
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsCanvasMesh_clonePtr(const TSCanvasMesh self) {
		CanvasMesh *ret = (self) ? new CanvasMesh(((CanvasMesh*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasMesh)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_clearPtr(TSCanvasMesh self) {
		if(self) ((CanvasMesh*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_destroyPtr(TSCanvasMesh self) {
		if(self) ((CanvasMesh*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_acquirePtr(TSCanvasMesh self) {
		if(self) ((CanvasMesh*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_unacquirePtr(TSCanvasMesh self) {
		if(self) ((CanvasMesh*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasMesh_isValidPtr(const TSCanvasMesh self) {
		return (self && ((CanvasMesh*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasMesh_isOwnerPtr(const TSCanvasMesh self) {
		return (self && ((CanvasMesh*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasMesh_isConstPtr(const TSCanvasMesh self) {
		return (self && ((CanvasMesh*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_getCountPtr(const TSCanvasMesh self) {
		return ((CanvasMesh*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasMesh_getInternalPtr(const TSCanvasMesh self) {
		return ((CanvasMesh*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasMesh_equalCanvasElementPtr(const TSCanvasMesh self, const TSCanvasElement base) {
		return (self && base && ((CanvasMesh*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsCanvasMesh_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasMesh)(new CanvasMesh(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasMesh_baseCanvasElementPtr(TSCanvasMesh self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasMesh*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setTextureName_s(TSCanvasMesh self, const char *name) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setTextureName(name);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setTextureName_cS(TSCanvasMesh self, const TSString name) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setTextureName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsCanvasMesh_getTextureName(TSCanvasMesh self) {
		TS_ASSERT(self);
		return (TSString)(new String(((CanvasMesh*)self)->getTextureName()));
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setGradientStyle(TSCanvasMesh self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasMesh*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasMesh_getGradientStyleConst(TSCanvasMesh self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasMesh*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasMesh_getGradientStyle_c(TSCanvasMesh self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasMesh*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasMesh_getGradientStyle(TSCanvasMesh self) {
		TS_ASSERT(self);
		GradientStyle ret = ((CanvasMesh*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_clearVertices(TSCanvasMesh self) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->clearVertices();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setNumVertices(TSCanvasMesh self, uint32_t num_vertices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setNumVertices(num_vertices);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_reserveVertices(TSCanvasMesh self, uint32_t num_vertices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->reserveVertices(num_vertices);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_getNumVertices(TSCanvasMesh self) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->getNumVertices();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertices(TSCanvasMesh self, const TSCanvasVertex *vertices, uint32_t num_vertices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setVertices(*(const CanvasVertex**)&vertices, num_vertices);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_addVertices(TSCanvasMesh self, const TSCanvasVertex *vertices, uint32_t num_vertices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->addVertices(*(const CanvasVertex**)&vertices, num_vertices);
	}
	TS_CAPI TSCanvasVertex* TS_CCALL tsCanvasMesh_getVertices_c(TSCanvasMesh self) {
		TS_ASSERT(self);
		return (TSCanvasVertex*)((CanvasMesh*)self)->getVertices();
	}
	TS_CAPI TSCanvasVertex* TS_CCALL tsCanvasMesh_getVertices(TSCanvasMesh self) {
		TS_ASSERT(self);
		return (TSCanvasVertex*)((CanvasMesh*)self)->getVertices();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertex(TSCanvasMesh self, uint32_t index, const TSCanvasVertex *vertex) {
		TS_ASSERT(self);
		TS_ASSERT(vertex);
		((CanvasMesh*)self)->setVertex(index, *(const CanvasVertex*)vertex);
	}
	TS_CAPI TSCanvasVertex TS_CCALL tsCanvasMesh_getVertex_cu(TSCanvasMesh self, uint32_t index) {
		TS_ASSERT(self);
		const CanvasVertex ret = ((CanvasMesh*)self)->getVertex(index);
		return *(TSCanvasVertex*)&ret;
	}
	TS_CAPI TSCanvasVertex TS_CCALL tsCanvasMesh_getVertex_u(TSCanvasMesh self, uint32_t index) {
		TS_ASSERT(self);
		CanvasVertex ret = ((CanvasMesh*)self)->getVertex(index);
		return *(TSCanvasVertex*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertexPosition_ucV3(TSCanvasMesh self, uint32_t index, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasMesh*)self)->setVertexPosition(index, *(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertexPosition_ufff(TSCanvasMesh self, uint32_t index, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setVertexPosition(index, x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasMesh_getVertexPosition(TSCanvasMesh self, uint32_t index) {
		TS_ASSERT(self);
		Vector3f ret = ((CanvasMesh*)self)->getVertexPosition(index);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertexTexCoord_ucV2(TSCanvasMesh self, uint32_t index, const TSVector2f *texcoord) {
		TS_ASSERT(self);
		TS_ASSERT(texcoord);
		((CanvasMesh*)self)->setVertexTexCoord(index, *(const Vector2f*)texcoord);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertexTexCoord_uff(TSCanvasMesh self, uint32_t index, float32_t s, float32_t t) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setVertexTexCoord(index, s, t);
	}
	TS_CAPI TSVector2f TS_CCALL tsCanvasMesh_getVertexTexCoord(TSCanvasMesh self, uint32_t index) {
		TS_ASSERT(self);
		Vector2f ret = ((CanvasMesh*)self)->getVertexTexCoord(index);
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertexColor_ucC(TSCanvasMesh self, uint32_t index, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasMesh*)self)->setVertexColor(index, *(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setVertexColor_uu(TSCanvasMesh self, uint32_t index, uint32_t color) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setVertexColor(index, color);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_getVertexColor(TSCanvasMesh self, uint32_t index) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->getVertexColor(index);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_cV3(TSCanvasMesh self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		return ((CanvasMesh*)self)->addVertex(*(const Vector3f*)position);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_cV3u(TSCanvasMesh self, const TSVector3f *position, uint32_t color) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		return ((CanvasMesh*)self)->addVertex(*(const Vector3f*)position, color);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_cV3cV2(TSCanvasMesh self, const TSVector3f *position, const TSVector2f *texcoord) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		TS_ASSERT(texcoord);
		return ((CanvasMesh*)self)->addVertex(*(const Vector3f*)position, *(const Vector2f*)texcoord);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_cV3cV2u(TSCanvasMesh self, const TSVector3f *position, const TSVector2f *texcoord, uint32_t color) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		TS_ASSERT(texcoord);
		return ((CanvasMesh*)self)->addVertex(*(const Vector3f*)position, *(const Vector2f*)texcoord, color);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_fffffu(TSCanvasMesh self, float32_t x, float32_t y, float32_t z, float32_t s, float32_t t, uint32_t color) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->addVertex(x, y, z, s, t, color);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_fffu(TSCanvasMesh self, float32_t x, float32_t y, float32_t z, uint32_t color) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->addVertex(x, y, z, color);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_addVertex_ffu(TSCanvasMesh self, float32_t x, float32_t y, uint32_t color) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->addVertex(x, y, color);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_clearIndices(TSCanvasMesh self) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->clearIndices();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setNumIndices(TSCanvasMesh self, uint32_t num_indices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setNumIndices(num_indices);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_reserveIndices(TSCanvasMesh self, uint32_t num_indices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->reserveIndices(num_indices);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_getNumIndices(TSCanvasMesh self) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->getNumIndices();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setIndices(TSCanvasMesh self, const uint32_t *indices, uint32_t num_indices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setIndices(indices, num_indices);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_addIndices_upu(TSCanvasMesh self, const uint32_t *indices, uint32_t num_indices) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->addIndices(indices, num_indices);
	}
	TS_CAPI const uint32_t* TS_CCALL tsCanvasMesh_getIndices_c(TSCanvasMesh self) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->getIndices();
	}
	TS_CAPI uint32_t* TS_CCALL tsCanvasMesh_getIndices(TSCanvasMesh self) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->getIndices();
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setIndex(TSCanvasMesh self, uint32_t index, uint32_t value) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->setIndex(index, value);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasMesh_getIndex(TSCanvasMesh self, uint32_t index) {
		TS_ASSERT(self);
		return ((CanvasMesh*)self)->getIndex(index);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_addIndex(TSCanvasMesh self, uint32_t i0) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->addIndex(i0);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_addIndices_uu(TSCanvasMesh self, uint32_t i0, uint32_t i1) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->addIndices(i0, i1);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_addIndices_uuu(TSCanvasMesh self, uint32_t i0, uint32_t i1, uint32_t i2) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->addIndices(i0, i1, i2);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_addIndices_uuuu(TSCanvasMesh self, uint32_t i0, uint32_t i1, uint32_t i2, uint32_t i3) {
		TS_ASSERT(self);
		((CanvasMesh*)self)->addIndices(i0, i1, i2, i3);
	}
	TS_CAPI void TS_CCALL tsCanvasMesh_setRect(TSCanvasMesh self, const TSRect *rect) {
		TS_ASSERT(self);
		TS_ASSERT(rect);
		((CanvasMesh*)self)->setRect(*(const Rect*)rect);
	}
	
	// Tellusim::CanvasRect
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_new(void) {
		CanvasRect *ret = new CanvasRect();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasRect)ret;
	}
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasRect *ret = new CanvasRect(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasRect)ret;
	}
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_new_Cf(TSCanvas canvas, float32_t radius) {
		TS_ASSERT(canvas);
		CanvasRect *ret = new CanvasRect(*(Canvas*)canvas, radius);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasRect)ret;
	}
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_new_CfcV2(TSCanvas canvas, float32_t radius, const TSVector2f *size) {
		TS_ASSERT(canvas);
		TS_ASSERT(size);
		CanvasRect *ret = new CanvasRect(*(Canvas*)canvas, radius, *(const Vector2f*)size);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasRect)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasRect_delete(TSCanvasRect self) {
		if(self) delete (CanvasRect*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasRect_equalPtr(const TSCanvasRect self, const TSCanvasRect ptr) {
		return (self && ptr && ((CanvasRect*)self)->operator==(*(CanvasRect*)ptr));
	}
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_copyPtr(TSCanvasRect self) {
		CanvasRect *ret = nullptr;
		if(self) ret = new CanvasRect(*(CanvasRect*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasRect)ret;
	}
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_clonePtr(const TSCanvasRect self) {
		CanvasRect *ret = (self) ? new CanvasRect(((CanvasRect*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasRect)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasRect_clearPtr(TSCanvasRect self) {
		if(self) ((CanvasRect*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasRect_destroyPtr(TSCanvasRect self) {
		if(self) ((CanvasRect*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasRect_acquirePtr(TSCanvasRect self) {
		if(self) ((CanvasRect*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasRect_unacquirePtr(TSCanvasRect self) {
		if(self) ((CanvasRect*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasRect_isValidPtr(const TSCanvasRect self) {
		return (self && ((CanvasRect*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasRect_isOwnerPtr(const TSCanvasRect self) {
		return (self && ((CanvasRect*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasRect_isConstPtr(const TSCanvasRect self) {
		return (self && ((CanvasRect*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasRect_getCountPtr(const TSCanvasRect self) {
		return ((CanvasRect*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasRect_getInternalPtr(const TSCanvasRect self) {
		return ((CanvasRect*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasRect_equalCanvasElementPtr(const TSCanvasRect self, const TSCanvasElement base) {
		return (self && base && ((CanvasRect*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasRect TS_CCALL tsCanvasRect_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasRect)(new CanvasRect(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasRect_baseCanvasElementPtr(TSCanvasRect self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasRect*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setRadius(TSCanvasRect self, float32_t radius) {
		TS_ASSERT(self);
		((CanvasRect*)self)->setRadius(radius);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasRect_getRadius(TSCanvasRect self) {
		TS_ASSERT(self);
		return ((CanvasRect*)self)->getRadius();
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setTextureName_s(TSCanvasRect self, const char *name) {
		TS_ASSERT(self);
		((CanvasRect*)self)->setTextureName(name);
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setTextureName_cS(TSCanvasRect self, const TSString name) {
		TS_ASSERT(self);
		((CanvasRect*)self)->setTextureName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsCanvasRect_getTextureName(TSCanvasRect self) {
		TS_ASSERT(self);
		return (TSString)(new String(((CanvasRect*)self)->getTextureName()));
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setStrokeColor(TSCanvasRect self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasRect*)self)->setStrokeColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasRect_getStrokeColor(TSCanvasRect self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasRect*)self)->getStrokeColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setStrokeStyle(TSCanvasRect self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasRect*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasRect_getStrokeStyleConst(TSCanvasRect self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasRect*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasRect_getStrokeStyle_c(TSCanvasRect self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasRect*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasRect_getStrokeStyle(TSCanvasRect self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((CanvasRect*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setGradientStyle(TSCanvasRect self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasRect*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasRect_getGradientStyleConst(TSCanvasRect self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasRect*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasRect_getGradientStyle_c(TSCanvasRect self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasRect*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasRect_getGradientStyle(TSCanvasRect self) {
		TS_ASSERT(self);
		GradientStyle ret = ((CanvasRect*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setSize_cV2(TSCanvasRect self, const TSVector2f *size) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		((CanvasRect*)self)->setSize(*(const Vector2f*)size);
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setSize_ff(TSCanvasRect self, float32_t width, float32_t height) {
		TS_ASSERT(self);
		((CanvasRect*)self)->setSize(width, height);
	}
	TS_CAPI TSVector2f TS_CCALL tsCanvasRect_getSize(TSCanvasRect self) {
		TS_ASSERT(self);
		const Vector2f ret = ((CanvasRect*)self)->getSize();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI float32_t TS_CCALL tsCanvasRect_getWidth(TSCanvasRect self) {
		TS_ASSERT(self);
		return ((CanvasRect*)self)->getWidth();
	}
	TS_CAPI float32_t TS_CCALL tsCanvasRect_getHeight(TSCanvasRect self) {
		TS_ASSERT(self);
		return ((CanvasRect*)self)->getHeight();
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setPosition_cV3(TSCanvasRect self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasRect*)self)->setPosition(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setPosition_fff(TSCanvasRect self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasRect*)self)->setPosition(x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasRect_getPosition(TSCanvasRect self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasRect*)self)->getPosition();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setTexCoord_cR(TSCanvasRect self, const TSRect *texcoord) {
		TS_ASSERT(self);
		TS_ASSERT(texcoord);
		((CanvasRect*)self)->setTexCoord(*(const Rect*)texcoord);
	}
	TS_CAPI void TS_CCALL tsCanvasRect_setTexCoord_ffff(TSCanvasRect self, float32_t left, float32_t right, float32_t bottom, float32_t top) {
		TS_ASSERT(self);
		((CanvasRect*)self)->setTexCoord(left, right, bottom, top);
	}
	TS_CAPI TSRect TS_CCALL tsCanvasRect_getTexCoord(TSCanvasRect self) {
		TS_ASSERT(self);
		const Rect ret = ((CanvasRect*)self)->getTexCoord();
		return *(TSRect*)&ret;
	}
	
	// Tellusim::CanvasTriangle
	TS_CAPI TSCanvasTriangle TS_CCALL tsCanvasTriangle_new(void) {
		CanvasTriangle *ret = new CanvasTriangle();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasTriangle)ret;
	}
	TS_CAPI TSCanvasTriangle TS_CCALL tsCanvasTriangle_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasTriangle *ret = new CanvasTriangle(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasTriangle)ret;
	}
	TS_CAPI TSCanvasTriangle TS_CCALL tsCanvasTriangle_new_Cf(TSCanvas canvas, float32_t radius) {
		TS_ASSERT(canvas);
		CanvasTriangle *ret = new CanvasTriangle(*(Canvas*)canvas, radius);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasTriangle)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_delete(TSCanvasTriangle self) {
		if(self) delete (CanvasTriangle*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasTriangle_equalPtr(const TSCanvasTriangle self, const TSCanvasTriangle ptr) {
		return (self && ptr && ((CanvasTriangle*)self)->operator==(*(CanvasTriangle*)ptr));
	}
	TS_CAPI TSCanvasTriangle TS_CCALL tsCanvasTriangle_copyPtr(TSCanvasTriangle self) {
		CanvasTriangle *ret = nullptr;
		if(self) ret = new CanvasTriangle(*(CanvasTriangle*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasTriangle)ret;
	}
	TS_CAPI TSCanvasTriangle TS_CCALL tsCanvasTriangle_clonePtr(const TSCanvasTriangle self) {
		CanvasTriangle *ret = (self) ? new CanvasTriangle(((CanvasTriangle*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasTriangle)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_clearPtr(TSCanvasTriangle self) {
		if(self) ((CanvasTriangle*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_destroyPtr(TSCanvasTriangle self) {
		if(self) ((CanvasTriangle*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_acquirePtr(TSCanvasTriangle self) {
		if(self) ((CanvasTriangle*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_unacquirePtr(TSCanvasTriangle self) {
		if(self) ((CanvasTriangle*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasTriangle_isValidPtr(const TSCanvasTriangle self) {
		return (self && ((CanvasTriangle*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasTriangle_isOwnerPtr(const TSCanvasTriangle self) {
		return (self && ((CanvasTriangle*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasTriangle_isConstPtr(const TSCanvasTriangle self) {
		return (self && ((CanvasTriangle*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasTriangle_getCountPtr(const TSCanvasTriangle self) {
		return ((CanvasTriangle*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasTriangle_getInternalPtr(const TSCanvasTriangle self) {
		return ((CanvasTriangle*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasTriangle_equalCanvasElementPtr(const TSCanvasTriangle self, const TSCanvasElement base) {
		return (self && base && ((CanvasTriangle*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasTriangle TS_CCALL tsCanvasTriangle_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasTriangle)(new CanvasTriangle(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasTriangle_baseCanvasElementPtr(TSCanvasTriangle self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasTriangle*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setRadius(TSCanvasTriangle self, float32_t radius) {
		TS_ASSERT(self);
		((CanvasTriangle*)self)->setRadius(radius);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasTriangle_getRadius(TSCanvasTriangle self) {
		TS_ASSERT(self);
		return ((CanvasTriangle*)self)->getRadius();
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setStrokeColor(TSCanvasTriangle self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasTriangle*)self)->setStrokeColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasTriangle_getStrokeColor(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasTriangle*)self)->getStrokeColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setStrokeStyle(TSCanvasTriangle self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasTriangle*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasTriangle_getStrokeStyleConst(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasTriangle*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasTriangle_getStrokeStyle_c(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasTriangle*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasTriangle_getStrokeStyle(TSCanvasTriangle self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((CanvasTriangle*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setGradientStyle(TSCanvasTriangle self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasTriangle*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasTriangle_getGradientStyleConst(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasTriangle*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasTriangle_getGradientStyle_c(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasTriangle*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasTriangle_getGradientStyle(TSCanvasTriangle self) {
		TS_ASSERT(self);
		GradientStyle ret = ((CanvasTriangle*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition0_cV3(TSCanvasTriangle self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasTriangle*)self)->setPosition0(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition1_cV3(TSCanvasTriangle self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasTriangle*)self)->setPosition1(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition2_cV3(TSCanvasTriangle self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasTriangle*)self)->setPosition2(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition0_fff(TSCanvasTriangle self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasTriangle*)self)->setPosition0(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition1_fff(TSCanvasTriangle self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasTriangle*)self)->setPosition1(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition2_fff(TSCanvasTriangle self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasTriangle*)self)->setPosition2(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasTriangle_setPosition(TSCanvasTriangle self, const TSVector3f *position_0, const TSVector3f *position_1, const TSVector3f *position_2) {
		TS_ASSERT(self);
		TS_ASSERT(position_0);
		TS_ASSERT(position_1);
		TS_ASSERT(position_2);
		((CanvasTriangle*)self)->setPosition(*(const Vector3f*)position_0, *(const Vector3f*)position_1, *(const Vector3f*)position_2);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasTriangle_getPosition0(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasTriangle*)self)->getPosition0();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasTriangle_getPosition1(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasTriangle*)self)->getPosition1();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasTriangle_getPosition2(TSCanvasTriangle self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasTriangle*)self)->getPosition2();
		return *(TSVector3f*)&ret;
	}
	
	// Tellusim::CanvasEllipse
	TS_CAPI TSCanvasEllipse TS_CCALL tsCanvasEllipse_new(void) {
		CanvasEllipse *ret = new CanvasEllipse();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasEllipse)ret;
	}
	TS_CAPI TSCanvasEllipse TS_CCALL tsCanvasEllipse_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasEllipse *ret = new CanvasEllipse(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasEllipse)ret;
	}
	TS_CAPI TSCanvasEllipse TS_CCALL tsCanvasEllipse_new_Cf(TSCanvas canvas, float32_t radius) {
		TS_ASSERT(canvas);
		CanvasEllipse *ret = new CanvasEllipse(*(Canvas*)canvas, radius);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasEllipse)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_delete(TSCanvasEllipse self) {
		if(self) delete (CanvasEllipse*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasEllipse_equalPtr(const TSCanvasEllipse self, const TSCanvasEllipse ptr) {
		return (self && ptr && ((CanvasEllipse*)self)->operator==(*(CanvasEllipse*)ptr));
	}
	TS_CAPI TSCanvasEllipse TS_CCALL tsCanvasEllipse_copyPtr(TSCanvasEllipse self) {
		CanvasEllipse *ret = nullptr;
		if(self) ret = new CanvasEllipse(*(CanvasEllipse*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasEllipse)ret;
	}
	TS_CAPI TSCanvasEllipse TS_CCALL tsCanvasEllipse_clonePtr(const TSCanvasEllipse self) {
		CanvasEllipse *ret = (self) ? new CanvasEllipse(((CanvasEllipse*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasEllipse)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_clearPtr(TSCanvasEllipse self) {
		if(self) ((CanvasEllipse*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_destroyPtr(TSCanvasEllipse self) {
		if(self) ((CanvasEllipse*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_acquirePtr(TSCanvasEllipse self) {
		if(self) ((CanvasEllipse*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_unacquirePtr(TSCanvasEllipse self) {
		if(self) ((CanvasEllipse*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasEllipse_isValidPtr(const TSCanvasEllipse self) {
		return (self && ((CanvasEllipse*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasEllipse_isOwnerPtr(const TSCanvasEllipse self) {
		return (self && ((CanvasEllipse*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasEllipse_isConstPtr(const TSCanvasEllipse self) {
		return (self && ((CanvasEllipse*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasEllipse_getCountPtr(const TSCanvasEllipse self) {
		return ((CanvasEllipse*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasEllipse_getInternalPtr(const TSCanvasEllipse self) {
		return ((CanvasEllipse*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasEllipse_equalCanvasElementPtr(const TSCanvasEllipse self, const TSCanvasElement base) {
		return (self && base && ((CanvasEllipse*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasEllipse TS_CCALL tsCanvasEllipse_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasEllipse)(new CanvasEllipse(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasEllipse_baseCanvasElementPtr(TSCanvasEllipse self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasEllipse*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setRadius(TSCanvasEllipse self, float32_t radius) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setRadius(radius);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasEllipse_getRadius(TSCanvasEllipse self) {
		TS_ASSERT(self);
		return ((CanvasEllipse*)self)->getRadius();
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setTextureName_s(TSCanvasEllipse self, const char *name) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setTextureName(name);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setTextureName_cS(TSCanvasEllipse self, const TSString name) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setTextureName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsCanvasEllipse_getTextureName(TSCanvasEllipse self) {
		TS_ASSERT(self);
		return (TSString)(new String(((CanvasEllipse*)self)->getTextureName()));
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setStrokeColor(TSCanvasEllipse self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasEllipse*)self)->setStrokeColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasEllipse_getStrokeColor(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasEllipse*)self)->getStrokeColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setStrokeStyle(TSCanvasEllipse self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasEllipse*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasEllipse_getStrokeStyleConst(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasEllipse*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasEllipse_getStrokeStyle_c(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasEllipse*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasEllipse_getStrokeStyle(TSCanvasEllipse self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((CanvasEllipse*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setGradientStyle(TSCanvasEllipse self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasEllipse*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasEllipse_getGradientStyleConst(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasEllipse*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasEllipse_getGradientStyle_c(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasEllipse*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasEllipse_getGradientStyle(TSCanvasEllipse self) {
		TS_ASSERT(self);
		GradientStyle ret = ((CanvasEllipse*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition_cV3(TSCanvasEllipse self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasEllipse*)self)->setPosition(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition0_cV3(TSCanvasEllipse self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasEllipse*)self)->setPosition0(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition1_cV3(TSCanvasEllipse self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasEllipse*)self)->setPosition1(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition_fff(TSCanvasEllipse self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setPosition(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition0_fff(TSCanvasEllipse self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setPosition0(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition1_fff(TSCanvasEllipse self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setPosition1(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setPosition_cV3cV3(TSCanvasEllipse self, const TSVector3f *position_0, const TSVector3f *position_1) {
		TS_ASSERT(self);
		TS_ASSERT(position_0);
		TS_ASSERT(position_1);
		((CanvasEllipse*)self)->setPosition(*(const Vector3f*)position_0, *(const Vector3f*)position_1);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasEllipse_getPosition0(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasEllipse*)self)->getPosition0();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasEllipse_getPosition1(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasEllipse*)self)->getPosition1();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setTexCoord_cR(TSCanvasEllipse self, const TSRect *texcoord) {
		TS_ASSERT(self);
		TS_ASSERT(texcoord);
		((CanvasEllipse*)self)->setTexCoord(*(const Rect*)texcoord);
	}
	TS_CAPI void TS_CCALL tsCanvasEllipse_setTexCoord_ffff(TSCanvasEllipse self, float32_t left, float32_t right, float32_t bottom, float32_t top) {
		TS_ASSERT(self);
		((CanvasEllipse*)self)->setTexCoord(left, right, bottom, top);
	}
	TS_CAPI TSRect TS_CCALL tsCanvasEllipse_getTexCoord(TSCanvasEllipse self) {
		TS_ASSERT(self);
		const Rect ret = ((CanvasEllipse*)self)->getTexCoord();
		return *(TSRect*)&ret;
	}
	
	// Tellusim::CanvasShape
	TS_CAPI TSCanvasShape TS_CCALL tsCanvasShape_new(void) {
		CanvasShape *ret = new CanvasShape();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasShape)ret;
	}
	TS_CAPI TSCanvasShape TS_CCALL tsCanvasShape_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasShape *ret = new CanvasShape(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasShape)ret;
	}
	TS_CAPI TSCanvasShape TS_CCALL tsCanvasShape_new_Cb(TSCanvas canvas, bool_t cubic) {
		TS_ASSERT(canvas);
		CanvasShape *ret = new CanvasShape(*(Canvas*)canvas, (bool)cubic);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasShape)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasShape_delete(TSCanvasShape self) {
		if(self) delete (CanvasShape*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_equalPtr(const TSCanvasShape self, const TSCanvasShape ptr) {
		return (self && ptr && ((CanvasShape*)self)->operator==(*(CanvasShape*)ptr));
	}
	TS_CAPI TSCanvasShape TS_CCALL tsCanvasShape_copyPtr(TSCanvasShape self) {
		CanvasShape *ret = nullptr;
		if(self) ret = new CanvasShape(*(CanvasShape*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasShape)ret;
	}
	TS_CAPI TSCanvasShape TS_CCALL tsCanvasShape_clonePtr(const TSCanvasShape self) {
		CanvasShape *ret = (self) ? new CanvasShape(((CanvasShape*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasShape)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasShape_clearPtr(TSCanvasShape self) {
		if(self) ((CanvasShape*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_destroyPtr(TSCanvasShape self) {
		if(self) ((CanvasShape*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_acquirePtr(TSCanvasShape self) {
		if(self) ((CanvasShape*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_unacquirePtr(TSCanvasShape self) {
		if(self) ((CanvasShape*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_isValidPtr(const TSCanvasShape self) {
		return (self && ((CanvasShape*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_isOwnerPtr(const TSCanvasShape self) {
		return (self && ((CanvasShape*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_isConstPtr(const TSCanvasShape self) {
		return (self && ((CanvasShape*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasShape_getCountPtr(const TSCanvasShape self) {
		return ((CanvasShape*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasShape_getInternalPtr(const TSCanvasShape self) {
		return ((CanvasShape*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_equalCanvasElementPtr(const TSCanvasShape self, const TSCanvasElement base) {
		return (self && base && ((CanvasShape*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasShape TS_CCALL tsCanvasShape_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasShape)(new CanvasShape(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasShape_baseCanvasElementPtr(TSCanvasShape self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasShape*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setCubic(TSCanvasShape self, bool_t cubic) {
		TS_ASSERT(self);
		((CanvasShape*)self)->setCubic((bool)cubic);
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_isCubic(TSCanvasShape self) {
		TS_ASSERT(self);
		return ((CanvasShape*)self)->isCubic();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setThreshold(TSCanvasShape self, float32_t threshold) {
		TS_ASSERT(self);
		((CanvasShape*)self)->setThreshold(threshold);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasShape_getThreshold(TSCanvasShape self) {
		TS_ASSERT(self);
		return ((CanvasShape*)self)->getThreshold();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setStrokeColor(TSCanvasShape self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasShape*)self)->setStrokeColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasShape_getStrokeColor(TSCanvasShape self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasShape*)self)->getStrokeColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setStrokeStyle(TSCanvasShape self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasShape*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasShape_getStrokeStyleConst(TSCanvasShape self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasShape*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasShape_getStrokeStyle_c(TSCanvasShape self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasShape*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasShape_getStrokeStyle(TSCanvasShape self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((CanvasShape*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setGradientStyle(TSCanvasShape self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasShape*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasShape_getGradientStyleConst(TSCanvasShape self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasShape*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasShape_getGradientStyle_c(TSCanvasShape self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((CanvasShape*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsCanvasShape_getGradientStyle(TSCanvasShape self) {
		TS_ASSERT(self);
		GradientStyle ret = ((CanvasShape*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasShape_createSVG(TSCanvasShape self, const char *src, float32_t scale) {
		TS_ASSERT(self);
		return ((CanvasShape*)self)->createSVG(src, scale);
	}
	TS_CAPI void TS_CCALL tsCanvasShape_clearPositions(TSCanvasShape self) {
		TS_ASSERT(self);
		((CanvasShape*)self)->clearPositions();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setNumPositions(TSCanvasShape self, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasShape*)self)->setNumPositions(num_positions);
	}
	TS_CAPI void TS_CCALL tsCanvasShape_reservePositions(TSCanvasShape self, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasShape*)self)->reservePositions(num_positions);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasShape_getNumPositions(TSCanvasShape self) {
		TS_ASSERT(self);
		return ((CanvasShape*)self)->getNumPositions();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setPositions(TSCanvasShape self, const TSVector3f *positions, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasShape*)self)->setPositions(*(const Vector3f**)&positions, num_positions);
	}
	TS_CAPI void TS_CCALL tsCanvasShape_addPositions(TSCanvasShape self, const TSVector3f *positions, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasShape*)self)->addPositions(*(const Vector3f**)&positions, num_positions);
	}
	TS_CAPI TSVector3f* TS_CCALL tsCanvasShape_getPositions_c(TSCanvasShape self) {
		TS_ASSERT(self);
		return (TSVector3f*)((CanvasShape*)self)->getPositions();
	}
	TS_CAPI TSVector3f* TS_CCALL tsCanvasShape_getPositions(TSCanvasShape self) {
		TS_ASSERT(self);
		return (TSVector3f*)((CanvasShape*)self)->getPositions();
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setPosition_ucV3(TSCanvasShape self, uint32_t index, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasShape*)self)->setPosition(index, *(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setPosition_ufff(TSCanvasShape self, uint32_t index, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasShape*)self)->setPosition(index, x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasShape_getPosition_cu(TSCanvasShape self, uint32_t index) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasShape*)self)->getPosition(index);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasShape_getPosition_u(TSCanvasShape self, uint32_t index) {
		TS_ASSERT(self);
		Vector3f ret = ((CanvasShape*)self)->getPosition(index);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasShape_addPosition_cV2(TSCanvasShape self, const TSVector2f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		return ((CanvasShape*)self)->addPosition(*(const Vector2f*)position);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasShape_addPosition_cV3(TSCanvasShape self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		return ((CanvasShape*)self)->addPosition(*(const Vector3f*)position);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasShape_addPosition_fff(TSCanvasShape self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		return ((CanvasShape*)self)->addPosition(x, y, z);
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setTexCoord_cR(TSCanvasShape self, const TSRect *texcoord) {
		TS_ASSERT(self);
		TS_ASSERT(texcoord);
		((CanvasShape*)self)->setTexCoord(*(const Rect*)texcoord);
	}
	TS_CAPI void TS_CCALL tsCanvasShape_setTexCoord_ffff(TSCanvasShape self, float32_t left, float32_t right, float32_t bottom, float32_t top) {
		TS_ASSERT(self);
		((CanvasShape*)self)->setTexCoord(left, right, bottom, top);
	}
	TS_CAPI TSRect TS_CCALL tsCanvasShape_getTexCoord(TSCanvasShape self) {
		TS_ASSERT(self);
		const Rect ret = ((CanvasShape*)self)->getTexCoord();
		return *(TSRect*)&ret;
	}
	
	// Tellusim::CanvasStrip
	TS_CAPI TSCanvasStrip TS_CCALL tsCanvasStrip_new(void) {
		CanvasStrip *ret = new CanvasStrip();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasStrip)ret;
	}
	TS_CAPI TSCanvasStrip TS_CCALL tsCanvasStrip_new_C(TSCanvas canvas) {
		TS_ASSERT(canvas);
		CanvasStrip *ret = new CanvasStrip(*(Canvas*)canvas);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasStrip)ret;
	}
	TS_CAPI TSCanvasStrip TS_CCALL tsCanvasStrip_new_Cf(TSCanvas canvas, float32_t width) {
		TS_ASSERT(canvas);
		CanvasStrip *ret = new CanvasStrip(*(Canvas*)canvas, width);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasStrip)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_delete(TSCanvasStrip self) {
		if(self) delete (CanvasStrip*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvasStrip_equalPtr(const TSCanvasStrip self, const TSCanvasStrip ptr) {
		return (self && ptr && ((CanvasStrip*)self)->operator==(*(CanvasStrip*)ptr));
	}
	TS_CAPI TSCanvasStrip TS_CCALL tsCanvasStrip_copyPtr(TSCanvasStrip self) {
		CanvasStrip *ret = nullptr;
		if(self) ret = new CanvasStrip(*(CanvasStrip*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasStrip)ret;
	}
	TS_CAPI TSCanvasStrip TS_CCALL tsCanvasStrip_clonePtr(const TSCanvasStrip self) {
		CanvasStrip *ret = (self) ? new CanvasStrip(((CanvasStrip*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvasStrip)ret;
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_clearPtr(TSCanvasStrip self) {
		if(self) ((CanvasStrip*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_destroyPtr(TSCanvasStrip self) {
		if(self) ((CanvasStrip*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_acquirePtr(TSCanvasStrip self) {
		if(self) ((CanvasStrip*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_unacquirePtr(TSCanvasStrip self) {
		if(self) ((CanvasStrip*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasStrip_isValidPtr(const TSCanvasStrip self) {
		return (self && ((CanvasStrip*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasStrip_isOwnerPtr(const TSCanvasStrip self) {
		return (self && ((CanvasStrip*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvasStrip_isConstPtr(const TSCanvasStrip self) {
		return (self && ((CanvasStrip*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasStrip_getCountPtr(const TSCanvasStrip self) {
		return ((CanvasStrip*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvasStrip_getInternalPtr(const TSCanvasStrip self) {
		return ((CanvasStrip*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvasStrip_equalCanvasElementPtr(const TSCanvasStrip self, const TSCanvasElement base) {
		return (self && base && ((CanvasStrip*)self)->operator==(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasStrip TS_CCALL tsCanvasStrip_castCanvasElementPtr(TSCanvasElement base) {
		return (TSCanvasStrip)(new CanvasStrip(*(CanvasElement*)base));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvasStrip_baseCanvasElementPtr(TSCanvasStrip self) {
		return (TSCanvasElement)(new CanvasElement(((CanvasStrip*)self)->getCanvasElement()));
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setWidth(TSCanvasStrip self, float32_t width) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->setWidth(width);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasStrip_getWidth(TSCanvasStrip self) {
		TS_ASSERT(self);
		return ((CanvasStrip*)self)->getWidth();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setOffset(TSCanvasStrip self, float32_t offset) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->setOffset(offset);
	}
	TS_CAPI float32_t TS_CCALL tsCanvasStrip_getOffset(TSCanvasStrip self) {
		TS_ASSERT(self);
		return ((CanvasStrip*)self)->getOffset();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setStrokeColor(TSCanvasStrip self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((CanvasStrip*)self)->setStrokeColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsCanvasStrip_getStrokeColor(TSCanvasStrip self) {
		TS_ASSERT(self);
		const Color ret = ((CanvasStrip*)self)->getStrokeColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setStrokeStyle(TSCanvasStrip self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((CanvasStrip*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasStrip_getStrokeStyleConst(TSCanvasStrip self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasStrip*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasStrip_getStrokeStyle_c(TSCanvasStrip self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((CanvasStrip*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsCanvasStrip_getStrokeStyle(TSCanvasStrip self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((CanvasStrip*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_createQuadratic_cV2cV2cV2f(TSCanvasStrip self, const TSVector2f *p0, const TSVector2f *p1, const TSVector2f *p2, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(p0);
		TS_ASSERT(p1);
		TS_ASSERT(p2);
		((CanvasStrip*)self)->createQuadratic(*(const Vector2f*)p0, *(const Vector2f*)p1, *(const Vector2f*)p2, threshold);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_createQuadratic_cV3cV3cV3f(TSCanvasStrip self, const TSVector3f *p0, const TSVector3f *p1, const TSVector3f *p2, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(p0);
		TS_ASSERT(p1);
		TS_ASSERT(p2);
		((CanvasStrip*)self)->createQuadratic(*(const Vector3f*)p0, *(const Vector3f*)p1, *(const Vector3f*)p2, threshold);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_createCubic_cV2cV2cV2cV2f(TSCanvasStrip self, const TSVector2f *p0, const TSVector2f *p1, const TSVector2f *p2, const TSVector2f *p3, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(p0);
		TS_ASSERT(p1);
		TS_ASSERT(p2);
		TS_ASSERT(p3);
		((CanvasStrip*)self)->createCubic(*(const Vector2f*)p0, *(const Vector2f*)p1, *(const Vector2f*)p2, *(const Vector2f*)p3, threshold);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_createCubic_cV3cV3cV3cV3f(TSCanvasStrip self, const TSVector3f *p0, const TSVector3f *p1, const TSVector3f *p2, const TSVector3f *p3, float32_t threshold) {
		TS_ASSERT(self);
		TS_ASSERT(p0);
		TS_ASSERT(p1);
		TS_ASSERT(p2);
		TS_ASSERT(p3);
		((CanvasStrip*)self)->createCubic(*(const Vector3f*)p0, *(const Vector3f*)p1, *(const Vector3f*)p2, *(const Vector3f*)p3, threshold);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_clearPositions(TSCanvasStrip self) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->clearPositions();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setNumPositions(TSCanvasStrip self, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->setNumPositions(num_positions);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_reservePositions(TSCanvasStrip self, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->reservePositions(num_positions);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasStrip_getNumPositions(TSCanvasStrip self) {
		TS_ASSERT(self);
		return ((CanvasStrip*)self)->getNumPositions();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setPositions(TSCanvasStrip self, const TSVector3f *positions, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->setPositions(*(const Vector3f**)&positions, num_positions);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_addPositions(TSCanvasStrip self, const TSVector3f *positions, uint32_t num_positions) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->addPositions(*(const Vector3f**)&positions, num_positions);
	}
	TS_CAPI TSVector3f* TS_CCALL tsCanvasStrip_getPositions_c(TSCanvasStrip self) {
		TS_ASSERT(self);
		return (TSVector3f*)((CanvasStrip*)self)->getPositions();
	}
	TS_CAPI TSVector3f* TS_CCALL tsCanvasStrip_getPositions(TSCanvasStrip self) {
		TS_ASSERT(self);
		return (TSVector3f*)((CanvasStrip*)self)->getPositions();
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setPosition_ucV3(TSCanvasStrip self, uint32_t index, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((CanvasStrip*)self)->setPosition(index, *(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsCanvasStrip_setPosition_ufff(TSCanvasStrip self, uint32_t index, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((CanvasStrip*)self)->setPosition(index, x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasStrip_getPosition_cu(TSCanvasStrip self, uint32_t index) {
		TS_ASSERT(self);
		const Vector3f ret = ((CanvasStrip*)self)->getPosition(index);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsCanvasStrip_getPosition_u(TSCanvasStrip self, uint32_t index) {
		TS_ASSERT(self);
		Vector3f ret = ((CanvasStrip*)self)->getPosition(index);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasStrip_addPosition_cV2(TSCanvasStrip self, const TSVector2f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		return ((CanvasStrip*)self)->addPosition(*(const Vector2f*)position);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasStrip_addPosition_cV3(TSCanvasStrip self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		return ((CanvasStrip*)self)->addPosition(*(const Vector3f*)position);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvasStrip_addPosition_fff(TSCanvasStrip self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		return ((CanvasStrip*)self)->addPosition(x, y, z);
	}
	
	// Tellusim::Canvas
	TS_CAPI TSCanvas TS_CCALL tsCanvas_new(void) {
		Canvas *ret = new Canvas();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvas)ret;
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_new_C(TSCanvas *parent) {
		Canvas *ret = new Canvas((parent) ? *(Canvas**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvas)ret;
	}
	TS_CAPI void TS_CCALL tsCanvas_delete(TSCanvas self) {
		if(self) delete (Canvas*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_equalPtr(const TSCanvas self, const TSCanvas ptr) {
		return (self && ptr && ((Canvas*)self)->operator==(*(Canvas*)ptr));
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_copyPtr(TSCanvas self) {
		Canvas *ret = nullptr;
		if(self) ret = new Canvas(*(Canvas*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvas)ret;
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_clonePtr(const TSCanvas self) {
		Canvas *ret = (self) ? new Canvas(((Canvas*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCanvas)ret;
	}
	TS_CAPI void TS_CCALL tsCanvas_clearPtr(TSCanvas self) {
		if(self) ((Canvas*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCanvas_destroyPtr(TSCanvas self) {
		if(self) ((Canvas*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCanvas_acquirePtr(TSCanvas self) {
		if(self) ((Canvas*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCanvas_unacquirePtr(TSCanvas self) {
		if(self) ((Canvas*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isValidPtr(const TSCanvas self) {
		return (self && ((Canvas*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isOwnerPtr(const TSCanvas self) {
		return (self && ((Canvas*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isConstPtr(const TSCanvas self) {
		return (self && ((Canvas*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getCountPtr(const TSCanvas self) {
		return ((Canvas*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCanvas_getInternalPtr(const TSCanvas self) {
		return ((Canvas*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsCanvas_clear(TSCanvas self) {
		TS_ASSERT(self);
		((Canvas*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isCreated(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->isCreated();
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getScale(TSCanvas self, const TSTarget target, uint32_t scale) {
		TS_ASSERT(self);
		TS_ASSERT(target);
		return ((Canvas*)self)->getScale(*(const Target*)target, scale);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_create_cDFFuu(TSCanvas self, const TSDevice device, TS_Format color, TS_Format depth, uint32_t multisample, uint32_t scale) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((Canvas*)self)->create(*(const Device*)device, (Format)color, (Format)depth, multisample, scale);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_create_cDcTu(TSCanvas self, const TSDevice device, const TSTarget target, uint32_t scale) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(target);
		return ((Canvas*)self)->create(*(const Device*)device, *(const Target*)target, scale);
	}
	TS_CAPI void TS_CCALL tsCanvas_setPipelineHash(TSCanvas self, uint32_t hash) {
		TS_ASSERT(self);
		((Canvas*)self)->setPipelineHash(hash);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getPipelineHash(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getPipelineHash();
	}
	TS_CAPI TS_Format TS_CCALL tsCanvas_getColorFormat(TSCanvas self) {
		TS_ASSERT(self);
		return (TS_Format)((Canvas*)self)->getColorFormat();
	}
	TS_CAPI TS_Format TS_CCALL tsCanvas_getDepthFormat(TSCanvas self) {
		TS_ASSERT(self);
		return (TS_Format)((Canvas*)self)->getDepthFormat();
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getMultisample(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getMultisample();
	}
	TS_CAPI void TS_CCALL tsCanvas_setOrder(TSCanvas self, int32_t order) {
		TS_ASSERT(self);
		((Canvas*)self)->setOrder(order);
	}
	TS_CAPI int32_t TS_CCALL tsCanvas_getOrder(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getOrder();
	}
	TS_CAPI void TS_CCALL tsCanvas_setEnabled(TSCanvas self, bool_t enabled) {
		TS_ASSERT(self);
		((Canvas*)self)->setEnabled((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isEnabled(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->isEnabled();
	}
	TS_CAPI void TS_CCALL tsCanvas_setViewport_cV(TSCanvas self, const TSViewport *viewport) {
		TS_ASSERT(self);
		TS_ASSERT(viewport);
		((Canvas*)self)->setViewport(*(const Viewport*)viewport);
	}
	TS_CAPI void TS_CCALL tsCanvas_setViewport_uu(TSCanvas self, uint32_t width, uint32_t height) {
		TS_ASSERT(self);
		((Canvas*)self)->setViewport(width, height);
	}
	TS_CAPI void TS_CCALL tsCanvas_setViewport_ff(TSCanvas self, float32_t width, float32_t height) {
		TS_ASSERT(self);
		((Canvas*)self)->setViewport(width, height);
	}
	TS_CAPI TSViewport TS_CCALL tsCanvas_getViewport(TSCanvas self) {
		TS_ASSERT(self);
		const Viewport ret = ((Canvas*)self)->getViewport();
		return *(TSViewport*)&ret;
	}
	TS_CAPI float32_t TS_CCALL tsCanvas_getWidth(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getWidth();
	}
	TS_CAPI float32_t TS_CCALL tsCanvas_getHeight(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getHeight();
	}
	TS_CAPI void TS_CCALL tsCanvas_clearColor(TSCanvas self) {
		TS_ASSERT(self);
		((Canvas*)self)->clearColor();
	}
	TS_CAPI void TS_CCALL tsCanvas_setColor_cC(TSCanvas self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((Canvas*)self)->setColor(*(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsCanvas_setColor_ffff(TSCanvas self, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((Canvas*)self)->setColor(r, g, b, a);
	}
	TS_CAPI TSColor TS_CCALL tsCanvas_getColor(TSCanvas self) {
		TS_ASSERT(self);
		const Color ret = ((Canvas*)self)->getColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvas_clearScissor(TSCanvas self) {
		TS_ASSERT(self);
		((Canvas*)self)->clearScissor();
	}
	TS_CAPI void TS_CCALL tsCanvas_setScissor(TSCanvas self, const TSRect *scissor) {
		TS_ASSERT(self);
		TS_ASSERT(scissor);
		((Canvas*)self)->setScissor(*(const Rect*)scissor);
	}
	TS_CAPI TSRect TS_CCALL tsCanvas_getScissor(TSCanvas self) {
		TS_ASSERT(self);
		const Rect ret = ((Canvas*)self)->getScissor();
		return *(TSRect*)&ret;
	}
	TS_CAPI void TS_CCALL tsCanvas_clearTransform(TSCanvas self) {
		TS_ASSERT(self);
		((Canvas*)self)->clearTransform();
	}
	TS_CAPI void TS_CCALL tsCanvas_setTransform(TSCanvas self, const TSMatrix4x4f *transform) {
		TS_ASSERT(self);
		TS_ASSERT(transform);
		((Canvas*)self)->setTransform(*(const Matrix4x4f*)transform);
	}
	TS_CAPI TSMatrix4x4f TS_CCALL tsCanvas_getTransform(TSCanvas self) {
		TS_ASSERT(self);
		const Matrix4x4f ret = ((Canvas*)self)->getTransform();
		return *(TSMatrix4x4f*)&ret;
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_setParent(TSCanvas self, TSCanvas parent) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((Canvas*)self)->setParent(*(Canvas*)parent);
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_getParent_c(TSCanvas self) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((Canvas*)self)->getParent()));
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_getParent(TSCanvas self) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((Canvas*)self)->getParent()));
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_addChild(TSCanvas self, TSCanvas child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Canvas*)self)->addChild(*(Canvas*)child);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_removeChild(TSCanvas self, TSCanvas child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Canvas*)self)->removeChild(*(Canvas*)child);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_raiseChild(TSCanvas self, TSCanvas child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Canvas*)self)->raiseChild(*(Canvas*)child);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_lowerChild(TSCanvas self, TSCanvas child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Canvas*)self)->lowerChild(*(Canvas*)child);
	}
	TS_CAPI void TS_CCALL tsCanvas_releaseChildren(TSCanvas self) {
		TS_ASSERT(self);
		((Canvas*)self)->releaseChildren();
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_findChild(TSCanvas self, const TSCanvas child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Canvas*)self)->findChild(*(const Canvas*)child);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isChild(TSCanvas self, const TSCanvas child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Canvas*)self)->isChild(*(const Canvas*)child);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getNumChildren(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getNumChildren();
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_getChild_cu(TSCanvas self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((Canvas*)self)->getChild(index)));
	}
	TS_CAPI TSCanvas TS_CCALL tsCanvas_getChild_u(TSCanvas self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((Canvas*)self)->getChild(index)));
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_addElement(TSCanvas self, TSCanvasElement element) {
		TS_ASSERT(self);
		TS_ASSERT(element);
		return ((Canvas*)self)->addElement(*(CanvasElement*)element);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_removeElement(TSCanvas self, TSCanvasElement element) {
		TS_ASSERT(self);
		TS_ASSERT(element);
		return ((Canvas*)self)->removeElement(*(CanvasElement*)element);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_raiseElement(TSCanvas self, TSCanvasElement element) {
		TS_ASSERT(self);
		TS_ASSERT(element);
		return ((Canvas*)self)->raiseElement(*(CanvasElement*)element);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_lowerElement(TSCanvas self, TSCanvasElement element) {
		TS_ASSERT(self);
		TS_ASSERT(element);
		return ((Canvas*)self)->lowerElement(*(CanvasElement*)element);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_findElement(TSCanvas self, const TSCanvasElement element) {
		TS_ASSERT(self);
		TS_ASSERT(element);
		return ((Canvas*)self)->findElement(*(const CanvasElement*)element);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isElement(TSCanvas self, const TSCanvasElement element) {
		TS_ASSERT(self);
		TS_ASSERT(element);
		return ((Canvas*)self)->isElement(*(const CanvasElement*)element);
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getNumElements(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getNumElements();
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvas_getElement_cu(TSCanvas self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCanvasElement)(new CanvasElement(((Canvas*)self)->getElement(index)));
	}
	TS_CAPI TSCanvasElement TS_CCALL tsCanvas_getElement_u(TSCanvas self, uint32_t index) {
		TS_ASSERT(self);
		return (TSCanvasElement)(new CanvasElement(((Canvas*)self)->getElement(index)));
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isFont(TSCanvas self, const char *name) {
		TS_ASSERT(self);
		return ((Canvas*)self)->isFont(name);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_addFont_sSt(TSCanvas self, const char *name, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Canvas*)self)->addFont(name, *(Stream*)stream);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_addFont_sbl(TSCanvas self, const char *name, const uint8_t (*blob)[256]) {
		TS_ASSERT(self);
		return ((Canvas*)self)->addFont(name, blob);
	}
	TS_CAPI void TS_CCALL tsCanvas_removeFont(TSCanvas self, const char *name) {
		TS_ASSERT(self);
		((Canvas*)self)->removeFont(name);
	}
	TS_CAPI TSFont TS_CCALL tsCanvas_getFont(TSCanvas self, const char *name) {
		TS_ASSERT(self);
		return (TSFont)(new Font(((Canvas*)self)->getFont(name)));
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_isTexture(TSCanvas self, const char *name) {
		TS_ASSERT(self);
		return ((Canvas*)self)->isTexture(name);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_addTexture_sSt(TSCanvas self, const char *name, TSStream stream) {
		TS_ASSERT(self);
		TS_ASSERT(stream);
		return ((Canvas*)self)->addTexture(name, *(Stream*)stream);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_addTexture_sT(TSCanvas self, const char *name, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		return ((Canvas*)self)->addTexture(name, *(Texture*)texture);
	}
	TS_CAPI bool_t TS_CCALL tsCanvas_addTexture_sbl(TSCanvas self, const char *name, const uint8_t (*blob)[256]) {
		TS_ASSERT(self);
		return ((Canvas*)self)->addTexture(name, blob);
	}
	TS_CAPI void TS_CCALL tsCanvas_removeTexture(TSCanvas self, const char *name) {
		TS_ASSERT(self);
		((Canvas*)self)->removeTexture(name);
	}
	TS_CAPI TSTexture TS_CCALL tsCanvas_getTexture(TSCanvas self, const char *name) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((Canvas*)self)->getTexture(name)));
	}
	TS_CAPI void TS_CCALL tsCanvas_setDepthMask(TSCanvas self, TS_PipelineDepthMask mask) {
		TS_ASSERT(self);
		((Canvas*)self)->setDepthMask((Pipeline::DepthMask)mask);
	}
	TS_CAPI TS_PipelineDepthMask TS_CCALL tsCanvas_getDepthMask(TSCanvas self) {
		TS_ASSERT(self);
		return (TS_PipelineDepthMask)((Canvas*)self)->getDepthMask();
	}
	TS_CAPI void TS_CCALL tsCanvas_setDepthFunc(TSCanvas self, TS_PipelineDepthFunc func) {
		TS_ASSERT(self);
		((Canvas*)self)->setDepthFunc((Pipeline::DepthFunc)func);
	}
	TS_CAPI TS_PipelineDepthFunc TS_CCALL tsCanvas_getDepthFunc(TSCanvas self) {
		TS_ASSERT(self);
		return (TS_PipelineDepthFunc)((Canvas*)self)->getDepthFunc();
	}
	TS_CAPI void TS_CCALL tsCanvas_draw_CcT(TSCanvas self, TSCommand command, const TSTarget target) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		TS_ASSERT(target);
		((Canvas*)self)->draw(*(Command*)command, *(const Target*)target);
	}
	TS_CAPI void TS_CCALL tsCanvas_draw_C(TSCanvas self, TSCommand command) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((Canvas*)self)->draw(*(Command*)command);
	}
	TS_CAPI void TS_CCALL tsCanvas_setCreateCallback(TSCanvas self, const TSCanvasCreateCallback func, void *data_) {
		TS_ASSERT(self);
		((Canvas*)self)->setCreateCallback(makeTSCanvasCreateCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsCanvas_setPipelineCallback(TSCanvas self, const TSCanvasPipelineCallback func, void *data_) {
		TS_ASSERT(self);
		((Canvas*)self)->setPipelineCallback(makeTSCanvasPipelineCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsCanvas_setBeginCallback(TSCanvas self, const TSCanvasBeginCallback func, void *data_) {
		TS_ASSERT(self);
		((Canvas*)self)->setBeginCallback(makeTSCanvasBeginCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsCanvas_setDrawCallback(TSCanvas self, const TSCanvasDrawCallback func, void *data_) {
		TS_ASSERT(self);
		((Canvas*)self)->setDrawCallback(makeTSCanvasDrawCallback(func, data_));
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getNumDrawPipelines(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getNumDrawPipelines();
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getNumDrawElements(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getNumDrawElements();
	}
	TS_CAPI uint32_t TS_CCALL tsCanvas_getNumDrawCommands(TSCanvas self) {
		TS_ASSERT(self);
		return ((Canvas*)self)->getNumDrawCommands();
	}
	TS_CAPI TSRect TS_CCALL tsCanvas_getRect(TSCanvas self) {
		TS_ASSERT(self);
		Rect ret = ((Canvas*)self)->getRect();
		return *(TSRect*)&ret;
	}
	
	// Tellusim::Control
	TS_CAPI TSControl TS_CCALL tsControl_new(void) {
		Control *ret = new Control();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControl)ret;
	}
	TS_CAPI TSControl TS_CCALL tsControl_new_C(TSControl *parent) {
		Control *ret = new Control((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControl)ret;
	}
	TS_CAPI TSControl TS_CCALL tsControl_new_Cff(TSControl *parent, float32_t width, float32_t height) {
		Control *ret = new Control((parent) ? *(Control**)parent : nullptr, width, height);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControl)ret;
	}
	TS_CAPI void TS_CCALL tsControl_delete(TSControl self) {
		if(self) delete (Control*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControl_equalPtr(const TSControl self, const TSControl ptr) {
		return (self && ptr && ((Control*)self)->operator==(*(Control*)ptr));
	}
	TS_CAPI TSControl TS_CCALL tsControl_copyPtr(TSControl self) {
		Control *ret = nullptr;
		if(self) ret = new Control(*(Control*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControl)ret;
	}
	TS_CAPI TSControl TS_CCALL tsControl_clonePtr(const TSControl self) {
		Control *ret = (self) ? new Control(((Control*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControl)ret;
	}
	TS_CAPI void TS_CCALL tsControl_clearPtr(TSControl self) {
		if(self) ((Control*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControl_destroyPtr(TSControl self) {
		if(self) ((Control*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControl_acquirePtr(TSControl self) {
		if(self) ((Control*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControl_unacquirePtr(TSControl self) {
		if(self) ((Control*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isValidPtr(const TSControl self) {
		return (self && ((Control*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControl_isOwnerPtr(const TSControl self) {
		return (self && ((Control*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControl_isConstPtr(const TSControl self) {
		return (self && ((Control*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControl_getCountPtr(const TSControl self) {
		return ((Control*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControl_getInternalPtr(const TSControl self) {
		return ((Control*)self)->getInternalPtr();
	}
	TS_CAPI TS_ControlType TS_CCALL tsControl_getType(TSControl self) {
		TS_ASSERT(self);
		return (TS_ControlType)((Control*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsControl_getTypeName_CT(TS_ControlType type) {
		return Control::getTypeName((Control::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsControl_getTypeName_c(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isUnknown(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isUnknown();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isRoot(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isRoot();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isText(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isText();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isRect(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isRect();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isGrid(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isGrid();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isGroup(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isGroup();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isPanel(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isPanel();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isDialog(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isDialog();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isWindow(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isWindow();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isCheck(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isCheck();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isCombo(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isCombo();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isButton(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isButton();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isSlider(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isSlider();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isScroll(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isScroll();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isSplit(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isSplit();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isArea(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isArea();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isTree(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isTree();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isEdit(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isEdit();
	}
	TS_CAPI void TS_CCALL tsControl_setAlign(TSControl self, TS_ControlAlign align) {
		TS_ASSERT(self);
		((Control*)self)->setAlign((Control::Align)align);
	}
	TS_CAPI TS_ControlAlign TS_CCALL tsControl_getAlign(TSControl self) {
		TS_ASSERT(self);
		return (TS_ControlAlign)((Control*)self)->getAlign();
	}
	TS_CAPI bool_t TS_CCALL tsControl_hasAlign(TSControl self, TS_ControlAlign align) {
		TS_ASSERT(self);
		return ((Control*)self)->hasAlign((Control::Align)align);
	}
	TS_CAPI bool_t TS_CCALL tsControl_hasAligns(TSControl self, TS_ControlAlign aligns) {
		TS_ASSERT(self);
		return ((Control*)self)->hasAligns((Control::Align)aligns);
	}
	TS_CAPI bool_t TS_CCALL tsControl_isSpacer(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isSpacer();
	}
	TS_CAPI void TS_CCALL tsControl_setCreated(TSControl self, bool_t created) {
		TS_ASSERT(self);
		((Control*)self)->setCreated((bool)created);
	}
	TS_CAPI bool_t TS_CCALL tsControl_isCreated(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isCreated();
	}
	TS_CAPI void TS_CCALL tsControl_setEnabled(TSControl self, bool_t enabled) {
		TS_ASSERT(self);
		((Control*)self)->setEnabled((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsControl_isEnabled(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isEnabled();
	}
	TS_CAPI bool_t TS_CCALL tsControl_wasEnabled(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->wasEnabled();
	}
	TS_CAPI bool_t TS_CCALL tsControl_wasUpdated(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->wasUpdated();
	}
	TS_CAPI void TS_CCALL tsControl_setDisabled(TSControl self, bool_t disabled) {
		TS_ASSERT(self);
		((Control*)self)->setDisabled((bool)disabled);
	}
	TS_CAPI bool_t TS_CCALL tsControl_isDisabled(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isDisabled();
	}
	TS_CAPI TSCanvas TS_CCALL tsControl_getCanvas(TSControl self) {
		TS_ASSERT(self);
		return (TSCanvas)(new Canvas(((Control*)self)->getCanvas()));
	}
	TS_CAPI TSControlRoot TS_CCALL tsControl_getRoot_c(TSControl self) {
		TS_ASSERT(self);
		return (TSControlRoot)(new ControlRoot(((Control*)self)->getRoot()));
	}
	TS_CAPI TSControlRoot TS_CCALL tsControl_getRoot(TSControl self) {
		TS_ASSERT(self);
		return (TSControlRoot)(new ControlRoot(((Control*)self)->getRoot()));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControl_getPanel_c(TSControl self) {
		TS_ASSERT(self);
		return (TSControlPanel)(new ControlPanel(((Control*)self)->getPanel()));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControl_getPanel(TSControl self) {
		TS_ASSERT(self);
		return (TSControlPanel)(new ControlPanel(((Control*)self)->getPanel()));
	}
	TS_CAPI uint32_t TS_CCALL tsControl_setParent(TSControl self, TSControl parent) {
		TS_ASSERT(self);
		TS_ASSERT(parent);
		return ((Control*)self)->setParent(*(Control*)parent);
	}
	TS_CAPI TSControl TS_CCALL tsControl_getParent_c(TSControl self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((Control*)self)->getParent()));
	}
	TS_CAPI TSControl TS_CCALL tsControl_getParent(TSControl self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((Control*)self)->getParent()));
	}
	TS_CAPI bool_t TS_CCALL tsControl_isParentEnabled(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isParentEnabled();
	}
	TS_CAPI bool_t TS_CCALL tsControl_isParentDisabled(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->isParentDisabled();
	}
	TS_CAPI uint32_t TS_CCALL tsControl_addChild(TSControl self, TSControl child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Control*)self)->addChild(*(Control*)child);
	}
	TS_CAPI TSControl TS_CCALL tsControl_setChild(TSControl self, uint32_t index, TSControl child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return (TSControl)(new Control(((Control*)self)->setChild(index, *(Control*)child)));
	}
	TS_CAPI bool_t TS_CCALL tsControl_raiseChild(TSControl self, TSControl child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Control*)self)->raiseChild(*(Control*)child);
	}
	TS_CAPI bool_t TS_CCALL tsControl_lowerChild(TSControl self, TSControl child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Control*)self)->lowerChild(*(Control*)child);
	}
	TS_CAPI bool_t TS_CCALL tsControl_removeChild(TSControl self, TSControl child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Control*)self)->removeChild(*(Control*)child);
	}
	TS_CAPI void TS_CCALL tsControl_releaseChildren(TSControl self) {
		TS_ASSERT(self);
		((Control*)self)->releaseChildren();
	}
	TS_CAPI uint32_t TS_CCALL tsControl_findChild(TSControl self, const TSControl child) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Control*)self)->findChild(*(const Control*)child);
	}
	TS_CAPI bool_t TS_CCALL tsControl_isChild(TSControl self, const TSControl child, bool_t hierarchy) {
		TS_ASSERT(self);
		TS_ASSERT(child);
		return ((Control*)self)->isChild(*(const Control*)child, (bool)hierarchy);
	}
	TS_CAPI uint32_t TS_CCALL tsControl_getNumChildren(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getNumChildren();
	}
	TS_CAPI TSControl TS_CCALL tsControl_getChild_cu(TSControl self, uint32_t index) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((Control*)self)->getChild(index)));
	}
	TS_CAPI TSControl TS_CCALL tsControl_getChild_u(TSControl self, uint32_t index) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((Control*)self)->getChild(index)));
	}
	TS_CAPI void TS_CCALL tsControl_setSize_cV2(TSControl self, const TSVector2f *size) {
		TS_ASSERT(self);
		TS_ASSERT(size);
		((Control*)self)->setSize(*(const Vector2f*)size);
	}
	TS_CAPI void TS_CCALL tsControl_setSize_ff(TSControl self, float32_t width, float32_t height) {
		TS_ASSERT(self);
		((Control*)self)->setSize(width, height);
	}
	TS_CAPI TSVector2f TS_CCALL tsControl_getSize(TSControl self) {
		TS_ASSERT(self);
		const Vector2f ret = ((Control*)self)->getSize();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI float32_t TS_CCALL tsControl_getWidth(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getWidth();
	}
	TS_CAPI float32_t TS_CCALL tsControl_getHeight(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getHeight();
	}
	TS_CAPI void TS_CCALL tsControl_setPosition_cV3(TSControl self, const TSVector3f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((Control*)self)->setPosition(*(const Vector3f*)position);
	}
	TS_CAPI void TS_CCALL tsControl_setPosition_fff(TSControl self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((Control*)self)->setPosition(x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsControl_getPosition(TSControl self) {
		TS_ASSERT(self);
		const Vector3f ret = ((Control*)self)->getPosition();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI float32_t TS_CCALL tsControl_getPositionX(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getPositionX();
	}
	TS_CAPI float32_t TS_CCALL tsControl_getPositionY(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsControl_setOffset_cV3(TSControl self, const TSVector3f *offset) {
		TS_ASSERT(self);
		TS_ASSERT(offset);
		((Control*)self)->setOffset(*(const Vector3f*)offset);
	}
	TS_CAPI void TS_CCALL tsControl_setOffset_fff(TSControl self, float32_t x, float32_t y, float32_t z) {
		TS_ASSERT(self);
		((Control*)self)->setOffset(x, y, z);
	}
	TS_CAPI TSVector3f TS_CCALL tsControl_getOffset(TSControl self) {
		TS_ASSERT(self);
		const Vector3f ret = ((Control*)self)->getOffset();
		return *(TSVector3f*)&ret;
	}
	TS_CAPI float32_t TS_CCALL tsControl_getOffsetX(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getOffsetX();
	}
	TS_CAPI float32_t TS_CCALL tsControl_getOffsetY(TSControl self) {
		TS_ASSERT(self);
		return ((Control*)self)->getOffsetY();
	}
	TS_CAPI void TS_CCALL tsControl_setMargin_f(TSControl self, float32_t value) {
		TS_ASSERT(self);
		((Control*)self)->setMargin(value);
	}
	TS_CAPI void TS_CCALL tsControl_setMargin_ff(TSControl self, float32_t horizontal, float32_t vertical) {
		TS_ASSERT(self);
		((Control*)self)->setMargin(horizontal, vertical);
	}
	TS_CAPI void TS_CCALL tsControl_setMargin_ffff(TSControl self, float32_t left, float32_t right, float32_t bottom, float32_t top) {
		TS_ASSERT(self);
		((Control*)self)->setMargin(left, right, bottom, top);
	}
	TS_CAPI void TS_CCALL tsControl_setMargin_cR(TSControl self, const TSRect *margin) {
		TS_ASSERT(self);
		TS_ASSERT(margin);
		((Control*)self)->setMargin(*(const Rect*)margin);
	}
	TS_CAPI TSRect TS_CCALL tsControl_getMargin(TSControl self) {
		TS_ASSERT(self);
		const Rect ret = ((Control*)self)->getMargin();
		return *(TSRect*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsControl_getRect(TSControl self) {
		TS_ASSERT(self);
		const Rect ret = ((Control*)self)->getRect();
		return *(TSRect*)&ret;
	}
	TS_CAPI TS_ControlState TS_CCALL tsControl_getState(TSControl self) {
		TS_ASSERT(self);
		return (TS_ControlState)((Control*)self)->getState();
	}
	
	// Tellusim::ControlRoot
	TS_CAPI TSControlRoot TS_CCALL tsControlRoot_new(void) {
		ControlRoot *ret = new ControlRoot();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRoot)ret;
	}
	TS_CAPI TSControlRoot TS_CCALL tsControlRoot_new_Cb(TSCanvas canvas, bool_t blob) {
		TS_ASSERT(canvas);
		ControlRoot *ret = new ControlRoot(*(Canvas*)canvas, (bool)blob);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRoot)ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_delete(TSControlRoot self) {
		if(self) delete (ControlRoot*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_equalPtr(const TSControlRoot self, const TSControlRoot ptr) {
		return (self && ptr && ((ControlRoot*)self)->operator==(*(ControlRoot*)ptr));
	}
	TS_CAPI TSControlRoot TS_CCALL tsControlRoot_copyPtr(TSControlRoot self) {
		ControlRoot *ret = nullptr;
		if(self) ret = new ControlRoot(*(ControlRoot*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRoot)ret;
	}
	TS_CAPI TSControlRoot TS_CCALL tsControlRoot_clonePtr(const TSControlRoot self) {
		ControlRoot *ret = (self) ? new ControlRoot(((ControlRoot*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRoot)ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_clearPtr(TSControlRoot self) {
		if(self) ((ControlRoot*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlRoot_destroyPtr(TSControlRoot self) {
		if(self) ((ControlRoot*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlRoot_acquirePtr(TSControlRoot self) {
		if(self) ((ControlRoot*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlRoot_unacquirePtr(TSControlRoot self) {
		if(self) ((ControlRoot*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isValidPtr(const TSControlRoot self) {
		return (self && ((ControlRoot*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isOwnerPtr(const TSControlRoot self) {
		return (self && ((ControlRoot*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isConstPtr(const TSControlRoot self) {
		return (self && ((ControlRoot*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlRoot_getCountPtr(const TSControlRoot self) {
		return ((ControlRoot*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlRoot_getInternalPtr(const TSControlRoot self) {
		return ((ControlRoot*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_equalControlPtr(const TSControlRoot self, const TSControl base) {
		return (self && base && ((ControlRoot*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlRoot TS_CCALL tsControlRoot_castControlPtr(TSControl base) {
		return (TSControlRoot)(new ControlRoot(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlRoot_baseControlPtr(TSControlRoot self) {
		return (TSControl)(new Control(((ControlRoot*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlRoot_setViewport_cV(TSControlRoot self, const TSViewport *viewport) {
		TS_ASSERT(self);
		TS_ASSERT(viewport);
		((ControlRoot*)self)->setViewport(*(const Viewport*)viewport);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setViewport_uu(TSControlRoot self, uint32_t width, uint32_t height) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setViewport(width, height);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setViewport_ff(TSControlRoot self, float32_t width, float32_t height) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setViewport(width, height);
	}
	TS_CAPI TSViewport TS_CCALL tsControlRoot_getViewport(TSControlRoot self) {
		TS_ASSERT(self);
		const Viewport ret = ((ControlRoot*)self)->getViewport();
		return *(TSViewport*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsControlRoot_getFontName(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlRoot*)self)->getFontName()));
	}
	TS_CAPI void TS_CCALL tsControlRoot_setFontName_s(TSControlRoot self, const char *name) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setFontName(name);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setFontName_cS(TSControlRoot self, const TSString name) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setFontName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setFontBlob(TSControlRoot self, const uint8_t (*blob)[256], const char *name) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setFontBlob(blob, name);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setFontSize(TSControlRoot self, uint32_t size, bool_t update) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setFontSize(size, (bool)update);
	}
	TS_CAPI uint32_t TS_CCALL tsControlRoot_getFontSize(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getFontSize();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setFontScale(TSControlRoot self, uint32_t scale, bool_t update) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setFontScale(scale, (bool)update);
	}
	TS_CAPI uint32_t TS_CCALL tsControlRoot_getFontScale(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getFontScale();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setFontStyle(TSControlRoot self, const TSFontStyle *style, bool_t update) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		return ((ControlRoot*)self)->setFontStyle(*(const FontStyle*)style, (bool)update);
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlRoot_getFontStyle_c(TSControlRoot self) {
		TS_ASSERT(self);
		const FontStyle ret = ((ControlRoot*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlRoot_getFontStyle(TSControlRoot self) {
		TS_ASSERT(self);
		FontStyle ret = ((ControlRoot*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSString TS_CCALL tsControlRoot_getTextureName(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlRoot*)self)->getTextureName()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setTextureName_suuf(TSControlRoot self, const char *name, uint32_t width, uint32_t height, float32_t border) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setTextureName(name, width, height, border);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setTextureName_cSuuf(TSControlRoot self, const TSString name, uint32_t width, uint32_t height, float32_t border) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setTextureName((name) ? *(const String*)name : String::null, width, height, border);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setTextureBlob(TSControlRoot self, const uint8_t (*blob)[256], const char *name, uint32_t width, uint32_t height, float32_t border) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setTextureBlob(blob, name, width, height, border);
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getTextureWidth(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getTextureWidth();
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getTextureHeight(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getTextureHeight();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setTextColor(TSControlRoot self, TS_ControlType type, TS_ControlState state, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlRoot*)self)->setTextColor((Control::Type)type, (Control::State)state, *(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setTextOffset(TSControlRoot self, TS_ControlType type, TS_ControlState state, const TSVector3f *offset) {
		TS_ASSERT(self);
		TS_ASSERT(offset);
		((ControlRoot*)self)->setTextOffset((Control::Type)type, (Control::State)state, *(const Vector3f*)offset);
	}
	TS_CAPI TSColor TS_CCALL tsControlRoot_getTextColor(TSControlRoot self, TS_ControlType type, TS_ControlState state) {
		TS_ASSERT(self);
		const Color ret = ((ControlRoot*)self)->getTextColor((Control::Type)type, (Control::State)state);
		return *(TSColor*)&ret;
	}
	TS_CAPI TSVector3f TS_CCALL tsControlRoot_getTextOffset(TSControlRoot self, TS_ControlType type, TS_ControlState state) {
		TS_ASSERT(self);
		const Vector3f ret = ((ControlRoot*)self)->getTextOffset((Control::Type)type, (Control::State)state);
		return *(TSVector3f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMeshColor(TSControlRoot self, TS_ControlMesh mesh, TS_ControlState state, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlRoot*)self)->setMeshColor((Control::Mesh)mesh, (Control::State)state, *(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMeshRegion(TSControlRoot self, TS_ControlMesh mesh, const TSRect *grid, const TSRect *region, const TSVector2f *border) {
		TS_ASSERT(self);
		TS_ASSERT(grid);
		TS_ASSERT(region);
		TS_ASSERT(border);
		((ControlRoot*)self)->setMeshRegion((Control::Mesh)mesh, *(const Rect*)grid, *(const Rect*)region, *(const Vector2f*)border);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMeshRegions(TSControlRoot self, TS_ControlMesh mesh, const TSRect *grid, const TSRect *regions, const TSVector2f *border) {
		TS_ASSERT(self);
		TS_ASSERT(grid);
		TS_ASSERT(regions);
		TS_ASSERT(border);
		((ControlRoot*)self)->setMeshRegions((Control::Mesh)mesh, *(const Rect*)grid, *(const Rect*)regions, *(const Vector2f*)border);
	}
	TS_CAPI uint32_t TS_CCALL tsControlRoot_getMeshColor(TSControlRoot self, TS_ControlMesh mesh, TS_ControlState state) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getMeshColor((Control::Mesh)mesh, (Control::State)state);
	}
	TS_CAPI TSRect TS_CCALL tsControlRoot_getMeshGrid(TSControlRoot self, TS_ControlMesh mesh) {
		TS_ASSERT(self);
		const Rect ret = ((ControlRoot*)self)->getMeshGrid((Control::Mesh)mesh);
		return *(TSRect*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsControlRoot_getMeshMargin(TSControlRoot self, TS_ControlMesh mesh) {
		TS_ASSERT(self);
		const Rect ret = ((ControlRoot*)self)->getMeshMargin((Control::Mesh)mesh);
		return *(TSRect*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsControlRoot_getMeshRegion(TSControlRoot self, TS_ControlMesh mesh, TS_ControlState state) {
		TS_ASSERT(self);
		const Rect ret = ((ControlRoot*)self)->getMeshRegion((Control::Mesh)mesh, (Control::State)state);
		return *(TSRect*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_setGroupRadius(TSControlRoot self, float32_t radius) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setGroupRadius(radius);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setGroupColor(TSControlRoot self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlRoot*)self)->setGroupColor(*(const Color*)color);
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getGroupRadius(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getGroupRadius();
	}
	TS_CAPI TSColor TS_CCALL tsControlRoot_getGroupColor(TSControlRoot self) {
		TS_ASSERT(self);
		const Color ret = ((ControlRoot*)self)->getGroupColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_setPanelRadius(TSControlRoot self, float32_t radius) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setPanelRadius(radius);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setPanelColor(TSControlRoot self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlRoot*)self)->setPanelColor(*(const Color*)color);
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getPanelRadius(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getPanelRadius();
	}
	TS_CAPI TSColor TS_CCALL tsControlRoot_getPanelColor(TSControlRoot self) {
		TS_ASSERT(self);
		const Color ret = ((ControlRoot*)self)->getPanelColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_setCheckedColor(TSControlRoot self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlRoot*)self)->setCheckedColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlRoot_getCheckedColor(TSControlRoot self) {
		TS_ASSERT(self);
		const Color ret = ((ControlRoot*)self)->getCheckedColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_setSplitSize(TSControlRoot self, float32_t size) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setSplitSize(size);
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getSplitSize(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getSplitSize();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMouse_iiCB(TSControlRoot self, int32_t x, int32_t y, TS_ControlButton buttons) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setMouse(x, y, (Control::Button)buttons);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMouse_ffCB(TSControlRoot self, float32_t x, float32_t y, TS_ControlButton buttons) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setMouse(x, y, (Control::Button)buttons);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlRoot_getMouse(TSControlRoot self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlRoot*)self)->getMouse();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI TS_ControlButton TS_CCALL tsControlRoot_getMouseButtons(TSControlRoot self) {
		TS_ASSERT(self);
		return (TS_ControlButton)((ControlRoot*)self)->getMouseButtons();
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getMouseX(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getMouseX();
	}
	TS_CAPI float32_t TS_CCALL tsControlRoot_getMouseY(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getMouseY();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMouseOffset(TSControlRoot self, const TSVector2f *offset) {
		TS_ASSERT(self);
		TS_ASSERT(offset);
		((ControlRoot*)self)->setMouseOffset(*(const Vector2f*)offset);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlRoot_getMouseOffset(TSControlRoot self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlRoot*)self)->getMouseOffset();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMouseAxis(TSControlRoot self, TS_ControlAxis axis, float32_t delta) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setMouseAxis((Control::Axis)axis, delta);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMouseAlign(TSControlRoot self, TS_ControlAlign align, bool_t clear) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setMouseAlign((Control::Align)align, (bool)clear);
	}
	TS_CAPI TS_ControlAlign TS_CCALL tsControlRoot_getMouseAlign(TSControlRoot self) {
		TS_ASSERT(self);
		return (TS_ControlAlign)((ControlRoot*)self)->getMouseAlign();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_hasMouseAlign(TSControlRoot self, TS_ControlAlign align) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->hasMouseAlign((Control::Align)align);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_hasMouseAligns(TSControlRoot self, TS_ControlAlign aligns) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->hasMouseAligns((Control::Align)aligns);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_setKeyboardKey(TSControlRoot self, uint32_t key, uint32_t code, bool_t value) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->setKeyboardKey(key, code, (bool)value);
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_getKeyboardKey(TSControlRoot self, uint32_t key, bool_t clear) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getKeyboardKey(key, (bool)clear);
	}
	TS_CAPI void TS_CCALL tsControlRoot_clearCurrentControl(TSControlRoot self) {
		TS_ASSERT(self);
		((ControlRoot*)self)->clearCurrentControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setCurrentControl(TSControlRoot self, TSControl control, bool_t grab) {
		TS_ASSERT(self);
		TS_ASSERT(control);
		((ControlRoot*)self)->setCurrentControl(*(Control*)control, (bool)grab);
	}
	TS_CAPI TSControl TS_CCALL tsControlRoot_getCurrentControl(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((ControlRoot*)self)->getCurrentControl()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isCurrentControl(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->isCurrentControl();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_getControlGrab(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getControlGrab();
	}
	TS_CAPI void TS_CCALL tsControlRoot_clearFocusedControl(TSControlRoot self) {
		TS_ASSERT(self);
		((ControlRoot*)self)->clearFocusedControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setFocusedControl(TSControlRoot self, TSControl control) {
		TS_ASSERT(self);
		TS_ASSERT(control);
		((ControlRoot*)self)->setFocusedControl(*(Control*)control);
	}
	TS_CAPI TSControl TS_CCALL tsControlRoot_getFocusedControl(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((ControlRoot*)self)->getFocusedControl()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isFocusedControl(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->isFocusedControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_clearMouseControl(TSControlRoot self) {
		TS_ASSERT(self);
		((ControlRoot*)self)->clearMouseControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setMouseControl(TSControlRoot self, TSControl control) {
		TS_ASSERT(self);
		TS_ASSERT(control);
		((ControlRoot*)self)->setMouseControl(*(Control*)control);
	}
	TS_CAPI TSControl TS_CCALL tsControlRoot_getMouseControl(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((ControlRoot*)self)->getMouseControl()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isMouseControl(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->isMouseControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_clearInputControl(TSControlRoot self) {
		TS_ASSERT(self);
		((ControlRoot*)self)->clearInputControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setInputControl(TSControlRoot self, TSControl control) {
		TS_ASSERT(self);
		TS_ASSERT(control);
		((ControlRoot*)self)->setInputControl(*(Control*)control);
	}
	TS_CAPI TSControl TS_CCALL tsControlRoot_getInputControl(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((ControlRoot*)self)->getInputControl()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isInputControl(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->isInputControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_clearModalControl(TSControlRoot self) {
		TS_ASSERT(self);
		((ControlRoot*)self)->clearModalControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setModalControl(TSControlRoot self, TSControl control, bool_t disabled) {
		TS_ASSERT(self);
		TS_ASSERT(control);
		((ControlRoot*)self)->setModalControl(*(Control*)control, (bool)disabled);
	}
	TS_CAPI TSControl TS_CCALL tsControlRoot_getModalControl(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSControl)(new Control(((ControlRoot*)self)->getModalControl()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isModalDisabled(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->isModalDisabled();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_isModalControl(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->isModalControl();
	}
	TS_CAPI void TS_CCALL tsControlRoot_setOverlayOrder(TSControlRoot self, int32_t order) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setOverlayOrder(order);
	}
	TS_CAPI int32_t TS_CCALL tsControlRoot_getOverlayOrder(TSControlRoot self) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->getOverlayOrder();
	}
	TS_CAPI bool_t TS_CCALL tsControlRoot_update(TSControlRoot self, uint32_t scale, int32_t order) {
		TS_ASSERT(self);
		return ((ControlRoot*)self)->update(scale, order);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setCopyText_s(TSControlRoot self, const char *text) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setCopyText(text);
	}
	TS_CAPI void TS_CCALL tsControlRoot_setCopyText_cS(TSControlRoot self, const TSString text) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setCopyText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlRoot_getPasteText(TSControlRoot self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlRoot*)self)->getPasteText()));
	}
	TS_CAPI void TS_CCALL tsControlRoot_setCopyCallback(TSControlRoot self, const TSControlRootCopyCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setCopyCallback(makeTSControlRootCopyCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlRoot_setPasteCallback(TSControlRoot self, const TSControlRootPasteCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRoot*)self)->setPasteCallback(makeTSControlRootPasteCallback(func, data_));
	}
	
	// Tellusim::ControlText
	TS_CAPI TSControlText TS_CCALL tsControlText_new(void) {
		ControlText *ret = new ControlText();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlText)ret;
	}
	TS_CAPI TSControlText TS_CCALL tsControlText_new_C(TSControl *parent) {
		ControlText *ret = new ControlText((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlText)ret;
	}
	TS_CAPI TSControlText TS_CCALL tsControlText_new_Cs(TSControl *parent, const char *text) {
		ControlText *ret = new ControlText((parent) ? *(Control**)parent : nullptr, text);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlText)ret;
	}
	TS_CAPI TSControlText TS_CCALL tsControlText_new_CcS(TSControl *parent, const TSString text) {
		ControlText *ret = new ControlText((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlText)ret;
	}
	TS_CAPI void TS_CCALL tsControlText_delete(TSControlText self) {
		if(self) delete (ControlText*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlText_equalPtr(const TSControlText self, const TSControlText ptr) {
		return (self && ptr && ((ControlText*)self)->operator==(*(ControlText*)ptr));
	}
	TS_CAPI TSControlText TS_CCALL tsControlText_copyPtr(TSControlText self) {
		ControlText *ret = nullptr;
		if(self) ret = new ControlText(*(ControlText*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlText)ret;
	}
	TS_CAPI TSControlText TS_CCALL tsControlText_clonePtr(const TSControlText self) {
		ControlText *ret = (self) ? new ControlText(((ControlText*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlText)ret;
	}
	TS_CAPI void TS_CCALL tsControlText_clearPtr(TSControlText self) {
		if(self) ((ControlText*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlText_destroyPtr(TSControlText self) {
		if(self) ((ControlText*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlText_acquirePtr(TSControlText self) {
		if(self) ((ControlText*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlText_unacquirePtr(TSControlText self) {
		if(self) ((ControlText*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlText_isValidPtr(const TSControlText self) {
		return (self && ((ControlText*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlText_isOwnerPtr(const TSControlText self) {
		return (self && ((ControlText*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlText_isConstPtr(const TSControlText self) {
		return (self && ((ControlText*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlText_getCountPtr(const TSControlText self) {
		return ((ControlText*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlText_getInternalPtr(const TSControlText self) {
		return ((ControlText*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlText_equalControlPtr(const TSControlText self, const TSControl base) {
		return (self && base && ((ControlText*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlText_castControlPtr(TSControl base) {
		return (TSControlText)(new ControlText(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlText_baseControlPtr(TSControlText self) {
		return (TSControl)(new Control(((ControlText*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlText_setMode(TSControlText self, TS_CanvasElementMode mode) {
		TS_ASSERT(self);
		((ControlText*)self)->setMode((CanvasElement::Mode)mode);
	}
	TS_CAPI TS_CanvasElementMode TS_CCALL tsControlText_getMode(TSControlText self) {
		TS_ASSERT(self);
		return (TS_CanvasElementMode)((ControlText*)self)->getMode();
	}
	TS_CAPI void TS_CCALL tsControlText_setPipeline_P(TSControlText self, TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((ControlText*)self)->setPipeline(*(Pipeline*)pipeline);
	}
	TS_CAPI void TS_CCALL tsControlText_setPipeline_PcCEDC(TSControlText self, TSPipeline pipeline, const TSCanvasElementDrawCallback func, void *data_) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((ControlText*)self)->setPipeline(*(Pipeline*)pipeline, makeTSCanvasElementDrawCallback(func, data_));
	}
	TS_CAPI TSPipeline TS_CCALL tsControlText_getPipeline(TSControlText self) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((ControlText*)self)->getPipeline()));
	}
	TS_CAPI void TS_CCALL tsControlText_setColor_cC(TSControlText self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlText*)self)->setColor(*(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsControlText_setColor_ffff(TSControlText self, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((ControlText*)self)->setColor(r, g, b, a);
	}
	TS_CAPI TSColor TS_CCALL tsControlText_getColor(TSControlText self) {
		TS_ASSERT(self);
		const Color ret = ((ControlText*)self)->getColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlText_setFilter(TSControlText self, TS_SamplerFilter filter) {
		TS_ASSERT(self);
		((ControlText*)self)->setFilter((Sampler::Filter)filter);
	}
	TS_CAPI TS_SamplerFilter TS_CCALL tsControlText_getFilter(TSControlText self) {
		TS_ASSERT(self);
		return (TS_SamplerFilter)((ControlText*)self)->getFilter();
	}
	TS_CAPI void TS_CCALL tsControlText_setAnisotropy(TSControlText self, uint32_t anisotropy) {
		TS_ASSERT(self);
		((ControlText*)self)->setAnisotropy(anisotropy);
	}
	TS_CAPI uint32_t TS_CCALL tsControlText_getAnisotropy(TSControlText self) {
		TS_ASSERT(self);
		return ((ControlText*)self)->getAnisotropy();
	}
	TS_CAPI void TS_CCALL tsControlText_setBlend(TSControlText self, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((ControlText*)self)->setBlend((Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI TS_PipelineBlendOp TS_CCALL tsControlText_getBlendOp(TSControlText self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendOp)((ControlText*)self)->getBlendOp();
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsControlText_getBlendSrcFunc(TSControlText self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((ControlText*)self)->getBlendSrcFunc();
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsControlText_getBlendDestFunc(TSControlText self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((ControlText*)self)->getBlendDestFunc();
	}
	TS_CAPI void TS_CCALL tsControlText_setFontName_s(TSControlText self, const char *name) {
		TS_ASSERT(self);
		((ControlText*)self)->setFontName(name);
	}
	TS_CAPI void TS_CCALL tsControlText_setFontName_cS(TSControlText self, const TSString name) {
		TS_ASSERT(self);
		((ControlText*)self)->setFontName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlText_getFontName(TSControlText self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlText*)self)->getFontName()));
	}
	TS_CAPI void TS_CCALL tsControlText_setFontColor(TSControlText self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlText*)self)->setFontColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlText_getFontColor(TSControlText self) {
		TS_ASSERT(self);
		const Color ret = ((ControlText*)self)->getFontColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsControlText_setFontSize(TSControlText self, uint32_t size) {
		TS_ASSERT(self);
		return ((ControlText*)self)->setFontSize(size);
	}
	TS_CAPI uint32_t TS_CCALL tsControlText_getFontSize(TSControlText self) {
		TS_ASSERT(self);
		return ((ControlText*)self)->getFontSize();
	}
	TS_CAPI bool_t TS_CCALL tsControlText_setFontStyle(TSControlText self, const TSFontStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		return ((ControlText*)self)->setFontStyle(*(const FontStyle*)style);
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlText_getFontStyleConst(TSControlText self) {
		TS_ASSERT(self);
		const FontStyle ret = ((ControlText*)self)->getFontStyleConst();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlText_getFontStyle_c(TSControlText self) {
		TS_ASSERT(self);
		const FontStyle ret = ((ControlText*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlText_getFontStyle(TSControlText self) {
		TS_ASSERT(self);
		FontStyle ret = ((ControlText*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlText_setFontAlign(TSControlText self, TS_ControlAlign align) {
		TS_ASSERT(self);
		((ControlText*)self)->setFontAlign((Control::Align)align);
	}
	TS_CAPI TS_ControlAlign TS_CCALL tsControlText_getFontAlign(TSControlText self) {
		TS_ASSERT(self);
		return (TS_ControlAlign)((ControlText*)self)->getFontAlign();
	}
	TS_CAPI bool_t TS_CCALL tsControlText_hasFontAlign(TSControlText self, TS_ControlAlign align) {
		TS_ASSERT(self);
		return ((ControlText*)self)->hasFontAlign((Control::Align)align);
	}
	TS_CAPI bool_t TS_CCALL tsControlText_hasFontAligns(TSControlText self, TS_ControlAlign aligns) {
		TS_ASSERT(self);
		return ((ControlText*)self)->hasFontAligns((Control::Align)aligns);
	}
	TS_CAPI void TS_CCALL tsControlText_setText_s(TSControlText self, const char *text) {
		TS_ASSERT(self);
		((ControlText*)self)->setText(text);
	}
	TS_CAPI void TS_CCALL tsControlText_setText_cS(TSControlText self, const TSString text) {
		TS_ASSERT(self);
		((ControlText*)self)->setText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlText_getText(TSControlText self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlText*)self)->getText()));
	}
	TS_CAPI TSCanvasText TS_CCALL tsControlText_getCanvasText(TSControlText self) {
		TS_ASSERT(self);
		return (TSCanvasText)(new CanvasText(((ControlText*)self)->getCanvasText()));
	}
	
	// Tellusim::ControlRect
	TS_CAPI TSControlRect TS_CCALL tsControlRect_new(void) {
		ControlRect *ret = new ControlRect();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_new_C(TSControl *parent) {
		ControlRect *ret = new ControlRect((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_new_CT(TSControl *parent, TSTexture texture) {
		TS_ASSERT(texture);
		ControlRect *ret = new ControlRect((parent) ? *(Control**)parent : nullptr, *(Texture*)texture);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_new_Cs(TSControl *parent, const char *name) {
		ControlRect *ret = new ControlRect((parent) ? *(Control**)parent : nullptr, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_new_CCEM(TSControl *parent, TS_CanvasElementMode mode) {
		ControlRect *ret = new ControlRect((parent) ? *(Control**)parent : nullptr, (CanvasElement::Mode)mode);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI void TS_CCALL tsControlRect_delete(TSControlRect self) {
		if(self) delete (ControlRect*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_equalPtr(const TSControlRect self, const TSControlRect ptr) {
		return (self && ptr && ((ControlRect*)self)->operator==(*(ControlRect*)ptr));
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_copyPtr(TSControlRect self) {
		ControlRect *ret = nullptr;
		if(self) ret = new ControlRect(*(ControlRect*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_clonePtr(const TSControlRect self) {
		ControlRect *ret = (self) ? new ControlRect(((ControlRect*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlRect)ret;
	}
	TS_CAPI void TS_CCALL tsControlRect_clearPtr(TSControlRect self) {
		if(self) ((ControlRect*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlRect_destroyPtr(TSControlRect self) {
		if(self) ((ControlRect*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlRect_acquirePtr(TSControlRect self) {
		if(self) ((ControlRect*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlRect_unacquirePtr(TSControlRect self) {
		if(self) ((ControlRect*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_isValidPtr(const TSControlRect self) {
		return (self && ((ControlRect*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_isOwnerPtr(const TSControlRect self) {
		return (self && ((ControlRect*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_isConstPtr(const TSControlRect self) {
		return (self && ((ControlRect*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlRect_getCountPtr(const TSControlRect self) {
		return ((ControlRect*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlRect_getInternalPtr(const TSControlRect self) {
		return ((ControlRect*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_equalControlPtr(const TSControlRect self, const TSControl base) {
		return (self && base && ((ControlRect*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlRect TS_CCALL tsControlRect_castControlPtr(TSControl base) {
		return (TSControlRect)(new ControlRect(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlRect_baseControlPtr(TSControlRect self) {
		return (TSControl)(new Control(((ControlRect*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlRect_setCallback(TSControlRect self, bool_t callback) {
		TS_ASSERT(self);
		((ControlRect*)self)->setCallback((bool)callback);
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_getCallback(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getCallback();
	}
	TS_CAPI void TS_CCALL tsControlRect_setFullscreen(TSControlRect self, bool_t fullscreen) {
		TS_ASSERT(self);
		((ControlRect*)self)->setFullscreen((bool)fullscreen);
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_isFullscreen(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->isFullscreen();
	}
	TS_CAPI void TS_CCALL tsControlRect_setMode(TSControlRect self, TS_CanvasElementMode mode) {
		TS_ASSERT(self);
		((ControlRect*)self)->setMode((CanvasElement::Mode)mode);
	}
	TS_CAPI TS_CanvasElementMode TS_CCALL tsControlRect_getMode(TSControlRect self) {
		TS_ASSERT(self);
		return (TS_CanvasElementMode)((ControlRect*)self)->getMode();
	}
	TS_CAPI void TS_CCALL tsControlRect_setPipeline_P(TSControlRect self, TSPipeline pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((ControlRect*)self)->setPipeline(*(Pipeline*)pipeline);
	}
	TS_CAPI void TS_CCALL tsControlRect_setPipeline_PcCEDC(TSControlRect self, TSPipeline pipeline, const TSCanvasElementDrawCallback func, void *data_) {
		TS_ASSERT(self);
		TS_ASSERT(pipeline);
		((ControlRect*)self)->setPipeline(*(Pipeline*)pipeline, makeTSCanvasElementDrawCallback(func, data_));
	}
	TS_CAPI TSPipeline TS_CCALL tsControlRect_getPipeline(TSControlRect self) {
		TS_ASSERT(self);
		return (TSPipeline)(new Pipeline(((ControlRect*)self)->getPipeline()));
	}
	TS_CAPI void TS_CCALL tsControlRect_setRadius(TSControlRect self, float32_t radius) {
		TS_ASSERT(self);
		((ControlRect*)self)->setRadius(radius);
	}
	TS_CAPI float32_t TS_CCALL tsControlRect_getRadius(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getRadius();
	}
	TS_CAPI void TS_CCALL tsControlRect_setColor_cC(TSControlRect self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlRect*)self)->setColor(*(const Color*)color);
	}
	TS_CAPI void TS_CCALL tsControlRect_setColor_ffff(TSControlRect self, float32_t r, float32_t g, float32_t b, float32_t a) {
		TS_ASSERT(self);
		((ControlRect*)self)->setColor(r, g, b, a);
	}
	TS_CAPI TSColor TS_CCALL tsControlRect_getColor(TSControlRect self) {
		TS_ASSERT(self);
		const Color ret = ((ControlRect*)self)->getColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRect_setStrokeStyle(TSControlRect self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((ControlRect*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlRect_getStrokeStyleConst(TSControlRect self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((ControlRect*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlRect_getStrokeStyle_c(TSControlRect self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((ControlRect*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlRect_getStrokeStyle(TSControlRect self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((ControlRect*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRect_setGradientStyle(TSControlRect self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((ControlRect*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlRect_getGradientStyleConst(TSControlRect self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((ControlRect*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlRect_getGradientStyle_c(TSControlRect self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((ControlRect*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlRect_getGradientStyle(TSControlRect self) {
		TS_ASSERT(self);
		GradientStyle ret = ((ControlRect*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRect_setMipmap(TSControlRect self, float32_t mipmap) {
		TS_ASSERT(self);
		((ControlRect*)self)->setMipmap(mipmap);
	}
	TS_CAPI float32_t TS_CCALL tsControlRect_getMipmap(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getMipmap();
	}
	TS_CAPI void TS_CCALL tsControlRect_setFilter(TSControlRect self, TS_SamplerFilter filter) {
		TS_ASSERT(self);
		((ControlRect*)self)->setFilter((Sampler::Filter)filter);
	}
	TS_CAPI TS_SamplerFilter TS_CCALL tsControlRect_getFilter(TSControlRect self) {
		TS_ASSERT(self);
		return (TS_SamplerFilter)((ControlRect*)self)->getFilter();
	}
	TS_CAPI void TS_CCALL tsControlRect_setAnisotropy(TSControlRect self, uint32_t anisotropy) {
		TS_ASSERT(self);
		((ControlRect*)self)->setAnisotropy(anisotropy);
	}
	TS_CAPI uint32_t TS_CCALL tsControlRect_getAnisotropy(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getAnisotropy();
	}
	TS_CAPI void TS_CCALL tsControlRect_setWrapMode(TSControlRect self, TS_SamplerWrapMode mode) {
		TS_ASSERT(self);
		((ControlRect*)self)->setWrapMode((Sampler::WrapMode)mode);
	}
	TS_CAPI TS_SamplerWrapMode TS_CCALL tsControlRect_getWrapMode(TSControlRect self) {
		TS_ASSERT(self);
		return (TS_SamplerWrapMode)((ControlRect*)self)->getWrapMode();
	}
	TS_CAPI void TS_CCALL tsControlRect_setBlend(TSControlRect self, TS_PipelineBlendOp op, TS_PipelineBlendFunc src, TS_PipelineBlendFunc dest) {
		TS_ASSERT(self);
		((ControlRect*)self)->setBlend((Pipeline::BlendOp)op, (Pipeline::BlendFunc)src, (Pipeline::BlendFunc)dest);
	}
	TS_CAPI TS_PipelineBlendOp TS_CCALL tsControlRect_getBlendOp(TSControlRect self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendOp)((ControlRect*)self)->getBlendOp();
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsControlRect_getBlendSrcFunc(TSControlRect self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((ControlRect*)self)->getBlendSrcFunc();
	}
	TS_CAPI TS_PipelineBlendFunc TS_CCALL tsControlRect_getBlendDestFunc(TSControlRect self) {
		TS_ASSERT(self);
		return (TS_PipelineBlendFunc)((ControlRect*)self)->getBlendDestFunc();
	}
	TS_CAPI void TS_CCALL tsControlRect_setTexture(TSControlRect self, TSTexture texture, bool_t linear) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((ControlRect*)self)->setTexture(*(Texture*)texture, (bool)linear);
	}
	TS_CAPI TSTexture TS_CCALL tsControlRect_getTexture(TSControlRect self) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((ControlRect*)self)->getTexture()));
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_getTextureLinear(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getTextureLinear();
	}
	TS_CAPI void TS_CCALL tsControlRect_setTextureName_s(TSControlRect self, const char *name) {
		TS_ASSERT(self);
		((ControlRect*)self)->setTextureName(name);
	}
	TS_CAPI void TS_CCALL tsControlRect_setTextureName_cS(TSControlRect self, const TSString name) {
		TS_ASSERT(self);
		((ControlRect*)self)->setTextureName((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlRect_getTextureName(TSControlRect self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlRect*)self)->getTextureName()));
	}
	TS_CAPI void TS_CCALL tsControlRect_setTextureScale(TSControlRect self, float32_t scale_x, float32_t scale_y) {
		TS_ASSERT(self);
		((ControlRect*)self)->setTextureScale(scale_x, scale_y);
	}
	TS_CAPI float32_t TS_CCALL tsControlRect_getTextureScaleX(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getTextureScaleX();
	}
	TS_CAPI float32_t TS_CCALL tsControlRect_getTextureScaleY(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getTextureScaleY();
	}
	TS_CAPI void TS_CCALL tsControlRect_setTextureFlip(TSControlRect self, bool_t flip_x, bool_t flip_y) {
		TS_ASSERT(self);
		((ControlRect*)self)->setTextureFlip((bool)flip_x, (bool)flip_y);
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_getTextureFlipX(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getTextureFlipX();
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_getTextureFlipY(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getTextureFlipY();
	}
	TS_CAPI void TS_CCALL tsControlRect_setTextureProj(TSControlRect self, bool_t projection) {
		TS_ASSERT(self);
		((ControlRect*)self)->setTextureProj((bool)projection);
	}
	TS_CAPI bool_t TS_CCALL tsControlRect_getTextureProj(TSControlRect self) {
		TS_ASSERT(self);
		return ((ControlRect*)self)->getTextureProj();
	}
	TS_CAPI void TS_CCALL tsControlRect_setTexCoord_cR(TSControlRect self, const TSRect *texcoord) {
		TS_ASSERT(self);
		TS_ASSERT(texcoord);
		((ControlRect*)self)->setTexCoord(*(const Rect*)texcoord);
	}
	TS_CAPI void TS_CCALL tsControlRect_setTexCoord_ffff(TSControlRect self, float32_t left, float32_t right, float32_t bottom, float32_t top) {
		TS_ASSERT(self);
		((ControlRect*)self)->setTexCoord(left, right, bottom, top);
	}
	TS_CAPI TSRect TS_CCALL tsControlRect_getTexCoord(TSControlRect self) {
		TS_ASSERT(self);
		const Rect ret = ((ControlRect*)self)->getTexCoord();
		return *(TSRect*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlRect_setInsideCallback(TSControlRect self, const TSControlRectInsideCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRect*)self)->setInsideCallback(makeTSControlRectInsideCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlRect_setPressedCallback(TSControlRect self, const TSControlRectPressedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRect*)self)->setPressedCallback(makeTSControlRectPressedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlRect_setReleasedCallback(TSControlRect self, const TSControlRectReleasedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRect*)self)->setReleasedCallback(makeTSControlRectReleasedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlRect_setClickedCallback(TSControlRect self, const TSControlRectClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRect*)self)->setClickedCallback(makeTSControlRectClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlRect_setClicked2Callback(TSControlRect self, const TSControlRectClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRect*)self)->setClicked2Callback(makeTSControlRectClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlRect_setClickedRightCallback(TSControlRect self, const TSControlRectClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlRect*)self)->setClickedRightCallback(makeTSControlRectClickedCallback(func, data_));
	}
	TS_CAPI TSCanvasRect TS_CCALL tsControlRect_getCanvasRect(TSControlRect self) {
		TS_ASSERT(self);
		return (TSCanvasRect)(new CanvasRect(((ControlRect*)self)->getCanvasRect()));
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlRect_getCanvasMesh(TSControlRect self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlRect*)self)->getCanvasMesh()));
	}
	
	// Tellusim::ControlGrid
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_new(void) {
		ControlGrid *ret = new ControlGrid();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGrid)ret;
	}
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_new_C(TSControl *parent) {
		ControlGrid *ret = new ControlGrid((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGrid)ret;
	}
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_new_Cu(TSControl *parent, uint32_t columns) {
		ControlGrid *ret = new ControlGrid((parent) ? *(Control**)parent : nullptr, columns);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGrid)ret;
	}
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_new_Cuff(TSControl *parent, uint32_t columns, float32_t x, float32_t y) {
		ControlGrid *ret = new ControlGrid((parent) ? *(Control**)parent : nullptr, columns, x, y);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGrid)ret;
	}
	TS_CAPI void TS_CCALL tsControlGrid_delete(TSControlGrid self) {
		if(self) delete (ControlGrid*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlGrid_equalPtr(const TSControlGrid self, const TSControlGrid ptr) {
		return (self && ptr && ((ControlGrid*)self)->operator==(*(ControlGrid*)ptr));
	}
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_copyPtr(TSControlGrid self) {
		ControlGrid *ret = nullptr;
		if(self) ret = new ControlGrid(*(ControlGrid*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGrid)ret;
	}
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_clonePtr(const TSControlGrid self) {
		ControlGrid *ret = (self) ? new ControlGrid(((ControlGrid*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGrid)ret;
	}
	TS_CAPI void TS_CCALL tsControlGrid_clearPtr(TSControlGrid self) {
		if(self) ((ControlGrid*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlGrid_destroyPtr(TSControlGrid self) {
		if(self) ((ControlGrid*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlGrid_acquirePtr(TSControlGrid self) {
		if(self) ((ControlGrid*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlGrid_unacquirePtr(TSControlGrid self) {
		if(self) ((ControlGrid*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlGrid_isValidPtr(const TSControlGrid self) {
		return (self && ((ControlGrid*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlGrid_isOwnerPtr(const TSControlGrid self) {
		return (self && ((ControlGrid*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlGrid_isConstPtr(const TSControlGrid self) {
		return (self && ((ControlGrid*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlGrid_getCountPtr(const TSControlGrid self) {
		return ((ControlGrid*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlGrid_getInternalPtr(const TSControlGrid self) {
		return ((ControlGrid*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlGrid_equalControlPtr(const TSControlGrid self, const TSControl base) {
		return (self && base && ((ControlGrid*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlGrid TS_CCALL tsControlGrid_castControlPtr(TSControl base) {
		return (TSControlGrid)(new ControlGrid(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlGrid_baseControlPtr(TSControlGrid self) {
		return (TSControl)(new Control(((ControlGrid*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlGrid_setColumns(TSControlGrid self, uint32_t columns) {
		TS_ASSERT(self);
		((ControlGrid*)self)->setColumns(columns);
	}
	TS_CAPI uint32_t TS_CCALL tsControlGrid_getColumns(TSControlGrid self) {
		TS_ASSERT(self);
		return ((ControlGrid*)self)->getColumns();
	}
	TS_CAPI void TS_CCALL tsControlGrid_setSpacing_cV2(TSControlGrid self, const TSVector2f *spacing) {
		TS_ASSERT(self);
		TS_ASSERT(spacing);
		((ControlGrid*)self)->setSpacing(*(const Vector2f*)spacing);
	}
	TS_CAPI void TS_CCALL tsControlGrid_setSpacing_ff(TSControlGrid self, float32_t x, float32_t y) {
		TS_ASSERT(self);
		((ControlGrid*)self)->setSpacing(x, y);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlGrid_getSpacing(TSControlGrid self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlGrid*)self)->getSpacing();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlGrid_setColumnRatio(TSControlGrid self, uint32_t index, float32_t ratio) {
		TS_ASSERT(self);
		((ControlGrid*)self)->setColumnRatio(index, ratio);
	}
	TS_CAPI float32_t TS_CCALL tsControlGrid_getColumnRatio(TSControlGrid self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlGrid*)self)->getColumnRatio(index);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlGrid_getControlsSize(TSControlGrid self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlGrid*)self)->getControlsSize();
		return *(TSVector2f*)&ret;
	}
	
	// Tellusim::ControlGroup
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_new(void) {
		ControlGroup *ret = new ControlGroup();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_new_Cb(TSControl *parent, bool_t above) {
		ControlGroup *ret = new ControlGroup((parent) ? *(Control**)parent : nullptr, (bool)above);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_new_Csb(TSControl *parent, const char *text, bool_t above) {
		ControlGroup *ret = new ControlGroup((parent) ? *(Control**)parent : nullptr, text, (bool)above);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_new_CcSb(TSControl *parent, const TSString text, bool_t above) {
		ControlGroup *ret = new ControlGroup((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null, (bool)above);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_new_Csub(TSControl *parent, const char *text, uint32_t columns, bool_t above) {
		ControlGroup *ret = new ControlGroup((parent) ? *(Control**)parent : nullptr, text, columns, (bool)above);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_new_Csuffb(TSControl *parent, const char *text, uint32_t columns, float32_t x, float32_t y, bool_t above) {
		ControlGroup *ret = new ControlGroup((parent) ? *(Control**)parent : nullptr, text, columns, x, y, (bool)above);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_delete(TSControlGroup self) {
		if(self) delete (ControlGroup*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_equalPtr(const TSControlGroup self, const TSControlGroup ptr) {
		return (self && ptr && ((ControlGroup*)self)->operator==(*(ControlGroup*)ptr));
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_copyPtr(TSControlGroup self) {
		ControlGroup *ret = nullptr;
		if(self) ret = new ControlGroup(*(ControlGroup*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_clonePtr(const TSControlGroup self) {
		ControlGroup *ret = (self) ? new ControlGroup(((ControlGroup*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlGroup)ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_clearPtr(TSControlGroup self) {
		if(self) ((ControlGroup*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlGroup_destroyPtr(TSControlGroup self) {
		if(self) ((ControlGroup*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlGroup_acquirePtr(TSControlGroup self) {
		if(self) ((ControlGroup*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlGroup_unacquirePtr(TSControlGroup self) {
		if(self) ((ControlGroup*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isValidPtr(const TSControlGroup self) {
		return (self && ((ControlGroup*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isOwnerPtr(const TSControlGroup self) {
		return (self && ((ControlGroup*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isConstPtr(const TSControlGroup self) {
		return (self && ((ControlGroup*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlGroup_getCountPtr(const TSControlGroup self) {
		return ((ControlGroup*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlGroup_getInternalPtr(const TSControlGroup self) {
		return ((ControlGroup*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_equalControlTextPtr(const TSControlGroup self, const TSControlText base) {
		return (self && base && ((ControlGroup*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_castControlTextPtr(TSControlText base) {
		return (TSControlGroup)(new ControlGroup(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlGroup_baseControlTextPtr(TSControlGroup self) {
		return (TSControlText)(new ControlText(((ControlGroup*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_equalControlPtr(const TSControlGroup self, const TSControl base) {
		return (self && base && ((ControlGroup*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlGroup TS_CCALL tsControlGroup_castControlPtr(TSControl base) {
		return (TSControlGroup)(new ControlGroup(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlGroup_baseControlPtr(TSControlGroup self) {
		return (TSControl)(new Control(((ControlGroup*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlGroup_setAbove(TSControlGroup self, bool_t above, bool_t text) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setAbove((bool)above, (bool)text);
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isAbove(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->isAbove();
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isBelow(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->isBelow();
	}
	TS_CAPI void TS_CCALL tsControlGroup_setFoldable(TSControlGroup self, bool_t foldable) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setFoldable((bool)foldable);
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isFoldable(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->isFoldable();
	}
	TS_CAPI void TS_CCALL tsControlGroup_setExpanded(TSControlGroup self, bool_t expanded) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setExpanded((bool)expanded);
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isExpanded(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->isExpanded();
	}
	TS_CAPI void TS_CCALL tsControlGroup_setBackground(TSControlGroup self, bool_t background) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setBackground((bool)background);
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_getBackground(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->getBackground();
	}
	TS_CAPI void TS_CCALL tsControlGroup_setGroupRadius(TSControlGroup self, float32_t radius) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setGroupRadius(radius);
	}
	TS_CAPI float32_t TS_CCALL tsControlGroup_getGroupRadius(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->getGroupRadius();
	}
	TS_CAPI void TS_CCALL tsControlGroup_setGroupColor(TSControlGroup self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlGroup*)self)->setGroupColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlGroup_getGroupColor(TSControlGroup self) {
		TS_ASSERT(self);
		const Color ret = ((ControlGroup*)self)->getGroupColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_setStrokeStyle(TSControlGroup self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((ControlGroup*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlGroup_getStrokeStyleConst(TSControlGroup self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((ControlGroup*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlGroup_getStrokeStyle_c(TSControlGroup self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((ControlGroup*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlGroup_getStrokeStyle(TSControlGroup self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((ControlGroup*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_setGradientStyle(TSControlGroup self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((ControlGroup*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlGroup_getGradientStyleConst(TSControlGroup self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((ControlGroup*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlGroup_getGradientStyle_c(TSControlGroup self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((ControlGroup*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlGroup_getGradientStyle(TSControlGroup self) {
		TS_ASSERT(self);
		GradientStyle ret = ((ControlGroup*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_setFoldedText_s(TSControlGroup self, const char *text) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setFoldedText(text);
	}
	TS_CAPI void TS_CCALL tsControlGroup_setFoldedText_cS(TSControlGroup self, const TSString text) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setFoldedText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlGroup_getFoldedText(TSControlGroup self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlGroup*)self)->getFoldedText()));
	}
	TS_CAPI void TS_CCALL tsControlGroup_setExpandedText_s(TSControlGroup self, const char *text) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setExpandedText(text);
	}
	TS_CAPI void TS_CCALL tsControlGroup_setExpandedText_cS(TSControlGroup self, const TSString text) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setExpandedText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlGroup_getExpandedText(TSControlGroup self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlGroup*)self)->getExpandedText()));
	}
	TS_CAPI void TS_CCALL tsControlGroup_setColumns(TSControlGroup self, uint32_t columns) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setColumns(columns);
	}
	TS_CAPI uint32_t TS_CCALL tsControlGroup_getColumns(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->getColumns();
	}
	TS_CAPI void TS_CCALL tsControlGroup_setSpacing_cV2(TSControlGroup self, const TSVector2f *spacing) {
		TS_ASSERT(self);
		TS_ASSERT(spacing);
		((ControlGroup*)self)->setSpacing(*(const Vector2f*)spacing);
	}
	TS_CAPI void TS_CCALL tsControlGroup_setSpacing_ff(TSControlGroup self, float32_t x, float32_t y) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setSpacing(x, y);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlGroup_getSpacing(TSControlGroup self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlGroup*)self)->getSpacing();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_setColumnRatio(TSControlGroup self, uint32_t index, float32_t ratio) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setColumnRatio(index, ratio);
	}
	TS_CAPI float32_t TS_CCALL tsControlGroup_getColumnRatio(TSControlGroup self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->getColumnRatio(index);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlGroup_getControlsSize(TSControlGroup self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlGroup*)self)->getControlsSize();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlGroup_setClickedCallback(TSControlGroup self, const TSControlGroupClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlGroup*)self)->setClickedCallback(makeTSControlGroupClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlGroup_isClicked(TSControlGroup self) {
		TS_ASSERT(self);
		return ((ControlGroup*)self)->isClicked();
	}
	TS_CAPI TSCanvasRect TS_CCALL tsControlGroup_getCanvasRect(TSControlGroup self) {
		TS_ASSERT(self);
		return (TSCanvasRect)(new CanvasRect(((ControlGroup*)self)->getCanvasRect()));
	}
	
	// Tellusim::ControlPanel
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_new(void) {
		ControlPanel *ret = new ControlPanel();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlPanel)ret;
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_new_C(TSControl *parent) {
		ControlPanel *ret = new ControlPanel((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlPanel)ret;
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_new_Cu(TSControl *parent, uint32_t columns) {
		ControlPanel *ret = new ControlPanel((parent) ? *(Control**)parent : nullptr, columns);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlPanel)ret;
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_new_Cuff(TSControl *parent, uint32_t columns, float32_t x, float32_t y) {
		ControlPanel *ret = new ControlPanel((parent) ? *(Control**)parent : nullptr, columns, x, y);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlPanel)ret;
	}
	TS_CAPI void TS_CCALL tsControlPanel_delete(TSControlPanel self) {
		if(self) delete (ControlPanel*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlPanel_equalPtr(const TSControlPanel self, const TSControlPanel ptr) {
		return (self && ptr && ((ControlPanel*)self)->operator==(*(ControlPanel*)ptr));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_copyPtr(TSControlPanel self) {
		ControlPanel *ret = nullptr;
		if(self) ret = new ControlPanel(*(ControlPanel*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlPanel)ret;
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_clonePtr(const TSControlPanel self) {
		ControlPanel *ret = (self) ? new ControlPanel(((ControlPanel*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlPanel)ret;
	}
	TS_CAPI void TS_CCALL tsControlPanel_clearPtr(TSControlPanel self) {
		if(self) ((ControlPanel*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlPanel_destroyPtr(TSControlPanel self) {
		if(self) ((ControlPanel*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlPanel_acquirePtr(TSControlPanel self) {
		if(self) ((ControlPanel*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlPanel_unacquirePtr(TSControlPanel self) {
		if(self) ((ControlPanel*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlPanel_isValidPtr(const TSControlPanel self) {
		return (self && ((ControlPanel*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlPanel_isOwnerPtr(const TSControlPanel self) {
		return (self && ((ControlPanel*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlPanel_isConstPtr(const TSControlPanel self) {
		return (self && ((ControlPanel*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlPanel_getCountPtr(const TSControlPanel self) {
		return ((ControlPanel*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlPanel_getInternalPtr(const TSControlPanel self) {
		return ((ControlPanel*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlPanel_equalControlRectPtr(const TSControlPanel self, const TSControlRect base) {
		return (self && base && ((ControlPanel*)self)->operator==(*(ControlRect*)base));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_castControlRectPtr(TSControlRect base) {
		return (TSControlPanel)(new ControlPanel(*(ControlRect*)base));
	}
	TS_CAPI TSControlRect TS_CCALL tsControlPanel_baseControlRectPtr(TSControlPanel self) {
		return (TSControlRect)(new ControlRect(((ControlPanel*)self)->getControlRect()));
	}
	TS_CAPI bool_t TS_CCALL tsControlPanel_equalControlPtr(const TSControlPanel self, const TSControl base) {
		return (self && base && ((ControlPanel*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlPanel_castControlPtr(TSControl base) {
		return (TSControlPanel)(new ControlPanel(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlPanel_baseControlPtr(TSControlPanel self) {
		return (TSControl)(new Control(((ControlPanel*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlPanel_setColumns(TSControlPanel self, uint32_t columns) {
		TS_ASSERT(self);
		((ControlPanel*)self)->setColumns(columns);
	}
	TS_CAPI uint32_t TS_CCALL tsControlPanel_getColumns(TSControlPanel self) {
		TS_ASSERT(self);
		return ((ControlPanel*)self)->getColumns();
	}
	TS_CAPI void TS_CCALL tsControlPanel_setSpacing_cV2(TSControlPanel self, const TSVector2f *spacing) {
		TS_ASSERT(self);
		TS_ASSERT(spacing);
		((ControlPanel*)self)->setSpacing(*(const Vector2f*)spacing);
	}
	TS_CAPI void TS_CCALL tsControlPanel_setSpacing_ff(TSControlPanel self, float32_t x, float32_t y) {
		TS_ASSERT(self);
		((ControlPanel*)self)->setSpacing(x, y);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlPanel_getSpacing(TSControlPanel self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlPanel*)self)->getSpacing();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlPanel_setColumnRatio(TSControlPanel self, uint32_t index, float32_t ratio) {
		TS_ASSERT(self);
		((ControlPanel*)self)->setColumnRatio(index, ratio);
	}
	TS_CAPI float32_t TS_CCALL tsControlPanel_getColumnRatio(TSControlPanel self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlPanel*)self)->getColumnRatio(index);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlPanel_getControlsSize(TSControlPanel self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlPanel*)self)->getControlsSize();
		return *(TSVector2f*)&ret;
	}
	
	// Tellusim::ControlDialog
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_new(void) {
		ControlDialog *ret = new ControlDialog();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlDialog)ret;
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_new_C(TSControl *parent) {
		ControlDialog *ret = new ControlDialog((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlDialog)ret;
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_new_Cu(TSControl *parent, uint32_t columns) {
		ControlDialog *ret = new ControlDialog((parent) ? *(Control**)parent : nullptr, columns);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlDialog)ret;
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_new_Cuff(TSControl *parent, uint32_t columns, float32_t x, float32_t y) {
		ControlDialog *ret = new ControlDialog((parent) ? *(Control**)parent : nullptr, columns, x, y);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlDialog)ret;
	}
	TS_CAPI void TS_CCALL tsControlDialog_delete(TSControlDialog self) {
		if(self) delete (ControlDialog*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_equalPtr(const TSControlDialog self, const TSControlDialog ptr) {
		return (self && ptr && ((ControlDialog*)self)->operator==(*(ControlDialog*)ptr));
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_copyPtr(TSControlDialog self) {
		ControlDialog *ret = nullptr;
		if(self) ret = new ControlDialog(*(ControlDialog*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlDialog)ret;
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_clonePtr(const TSControlDialog self) {
		ControlDialog *ret = (self) ? new ControlDialog(((ControlDialog*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlDialog)ret;
	}
	TS_CAPI void TS_CCALL tsControlDialog_clearPtr(TSControlDialog self) {
		if(self) ((ControlDialog*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlDialog_destroyPtr(TSControlDialog self) {
		if(self) ((ControlDialog*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlDialog_acquirePtr(TSControlDialog self) {
		if(self) ((ControlDialog*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlDialog_unacquirePtr(TSControlDialog self) {
		if(self) ((ControlDialog*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isValidPtr(const TSControlDialog self) {
		return (self && ((ControlDialog*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isOwnerPtr(const TSControlDialog self) {
		return (self && ((ControlDialog*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isConstPtr(const TSControlDialog self) {
		return (self && ((ControlDialog*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlDialog_getCountPtr(const TSControlDialog self) {
		return ((ControlDialog*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlDialog_getInternalPtr(const TSControlDialog self) {
		return ((ControlDialog*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_equalControlPanelPtr(const TSControlDialog self, const TSControlPanel base) {
		return (self && base && ((ControlDialog*)self)->operator==(*(ControlPanel*)base));
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_castControlPanelPtr(TSControlPanel base) {
		return (TSControlDialog)(new ControlDialog(*(ControlPanel*)base));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlDialog_baseControlPanelPtr(TSControlDialog self) {
		return (TSControlPanel)(new ControlPanel(((ControlDialog*)self)->getControlPanel()));
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_equalControlRectPtr(const TSControlDialog self, const TSControlRect base) {
		return (self && base && ((ControlDialog*)self)->operator==(*(ControlRect*)base));
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_castControlRectPtr(TSControlRect base) {
		return (TSControlDialog)(new ControlDialog(*(ControlRect*)base));
	}
	TS_CAPI TSControlRect TS_CCALL tsControlDialog_baseControlRectPtr(TSControlDialog self) {
		return (TSControlRect)(new ControlRect(((ControlDialog*)self)->getControlRect()));
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_equalControlPtr(const TSControlDialog self, const TSControl base) {
		return (self && base && ((ControlDialog*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlDialog_castControlPtr(TSControl base) {
		return (TSControlDialog)(new ControlDialog(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlDialog_baseControlPtr(TSControlDialog self) {
		return (TSControl)(new Control(((ControlDialog*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlDialog_setConstrained(TSControlDialog self, bool_t constrained) {
		TS_ASSERT(self);
		((ControlDialog*)self)->setConstrained((bool)constrained);
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isConstrained(TSControlDialog self) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->isConstrained();
	}
	TS_CAPI void TS_CCALL tsControlDialog_setResizable(TSControlDialog self, bool_t resizable) {
		TS_ASSERT(self);
		((ControlDialog*)self)->setResizable((bool)resizable);
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isResizable(TSControlDialog self) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->isResizable();
	}
	TS_CAPI void TS_CCALL tsControlDialog_setMoveable(TSControlDialog self, bool_t moveable) {
		TS_ASSERT(self);
		((ControlDialog*)self)->setMoveable((bool)moveable);
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isMoveable(TSControlDialog self) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->isMoveable();
	}
	TS_CAPI void TS_CCALL tsControlDialog_setResizeArea(TSControlDialog self, float32_t area) {
		TS_ASSERT(self);
		((ControlDialog*)self)->setResizeArea(area);
	}
	TS_CAPI float32_t TS_CCALL tsControlDialog_getResizeArea(TSControlDialog self) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->getResizeArea();
	}
	TS_CAPI TS_ControlAlign TS_CCALL tsControlDialog_getResizeAlign(TSControlDialog self) {
		TS_ASSERT(self);
		return (TS_ControlAlign)((ControlDialog*)self)->getResizeAlign();
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_hasResizeAlign(TSControlDialog self, TS_ControlAlign align) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->hasResizeAlign((Control::Align)align);
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_hasResizeAligns(TSControlDialog self, TS_ControlAlign aligns) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->hasResizeAligns((Control::Align)aligns);
	}
	TS_CAPI void TS_CCALL tsControlDialog_setMousePosition(TSControlDialog self, const TSVector2f *position) {
		TS_ASSERT(self);
		TS_ASSERT(position);
		((ControlDialog*)self)->setMousePosition(*(const Vector2f*)position);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlDialog_getMousePosition(TSControlDialog self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlDialog*)self)->getMousePosition();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlDialog_setUpdatedCallback(TSControlDialog self, const TSControlDialogUpdatedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlDialog*)self)->setUpdatedCallback(makeTSControlDialogUpdatedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlDialog_isUpdated(TSControlDialog self) {
		TS_ASSERT(self);
		return ((ControlDialog*)self)->isUpdated();
	}
	
	// Tellusim::ControlWindow
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_new(void) {
		ControlWindow *ret = new ControlWindow();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlWindow)ret;
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_new_CRWW(TSControlRoot *root, TSWindow parent, TSWindow window) {
		TS_ASSERT(parent);
		TS_ASSERT(window);
		ControlWindow *ret = new ControlWindow((root) ? *(ControlRoot**)root : nullptr, *(Window*)parent, *(Window*)window);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlWindow)ret;
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_new_CRWWu(TSControlRoot *root, TSWindow parent, TSWindow window, uint32_t columns) {
		TS_ASSERT(parent);
		TS_ASSERT(window);
		ControlWindow *ret = new ControlWindow((root) ? *(ControlRoot**)root : nullptr, *(Window*)parent, *(Window*)window, columns);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlWindow)ret;
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_new_CRWWuff(TSControlRoot *root, TSWindow parent, TSWindow window, uint32_t columns, float32_t x, float32_t y) {
		TS_ASSERT(parent);
		TS_ASSERT(window);
		ControlWindow *ret = new ControlWindow((root) ? *(ControlRoot**)root : nullptr, *(Window*)parent, *(Window*)window, columns, x, y);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlWindow)ret;
	}
	TS_CAPI void TS_CCALL tsControlWindow_delete(TSControlWindow self) {
		if(self) delete (ControlWindow*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_equalPtr(const TSControlWindow self, const TSControlWindow ptr) {
		return (self && ptr && ((ControlWindow*)self)->operator==(*(ControlWindow*)ptr));
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_copyPtr(TSControlWindow self) {
		ControlWindow *ret = nullptr;
		if(self) ret = new ControlWindow(*(ControlWindow*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlWindow)ret;
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_clonePtr(const TSControlWindow self) {
		ControlWindow *ret = (self) ? new ControlWindow(((ControlWindow*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlWindow)ret;
	}
	TS_CAPI void TS_CCALL tsControlWindow_clearPtr(TSControlWindow self) {
		if(self) ((ControlWindow*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlWindow_destroyPtr(TSControlWindow self) {
		if(self) ((ControlWindow*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlWindow_acquirePtr(TSControlWindow self) {
		if(self) ((ControlWindow*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlWindow_unacquirePtr(TSControlWindow self) {
		if(self) ((ControlWindow*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_isValidPtr(const TSControlWindow self) {
		return (self && ((ControlWindow*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_isOwnerPtr(const TSControlWindow self) {
		return (self && ((ControlWindow*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_isConstPtr(const TSControlWindow self) {
		return (self && ((ControlWindow*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlWindow_getCountPtr(const TSControlWindow self) {
		return ((ControlWindow*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlWindow_getInternalPtr(const TSControlWindow self) {
		return ((ControlWindow*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_equalControlDialogPtr(const TSControlWindow self, const TSControlDialog base) {
		return (self && base && ((ControlWindow*)self)->operator==(*(ControlDialog*)base));
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_castControlDialogPtr(TSControlDialog base) {
		return (TSControlWindow)(new ControlWindow(*(ControlDialog*)base));
	}
	TS_CAPI TSControlDialog TS_CCALL tsControlWindow_baseControlDialogPtr(TSControlWindow self) {
		return (TSControlDialog)(new ControlDialog(((ControlWindow*)self)->getControlDialog()));
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_equalControlPanelPtr(const TSControlWindow self, const TSControlPanel base) {
		return (self && base && ((ControlWindow*)self)->operator==(*(ControlPanel*)base));
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_castControlPanelPtr(TSControlPanel base) {
		return (TSControlWindow)(new ControlWindow(*(ControlPanel*)base));
	}
	TS_CAPI TSControlPanel TS_CCALL tsControlWindow_baseControlPanelPtr(TSControlWindow self) {
		return (TSControlPanel)(new ControlPanel(((ControlWindow*)self)->getControlPanel()));
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_equalControlRectPtr(const TSControlWindow self, const TSControlRect base) {
		return (self && base && ((ControlWindow*)self)->operator==(*(ControlRect*)base));
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_castControlRectPtr(TSControlRect base) {
		return (TSControlWindow)(new ControlWindow(*(ControlRect*)base));
	}
	TS_CAPI TSControlRect TS_CCALL tsControlWindow_baseControlRectPtr(TSControlWindow self) {
		return (TSControlRect)(new ControlRect(((ControlWindow*)self)->getControlRect()));
	}
	TS_CAPI bool_t TS_CCALL tsControlWindow_equalControlPtr(const TSControlWindow self, const TSControl base) {
		return (self && base && ((ControlWindow*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlWindow TS_CCALL tsControlWindow_castControlPtr(TSControl base) {
		return (TSControlWindow)(new ControlWindow(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlWindow_baseControlPtr(TSControlWindow self) {
		return (TSControl)(new Control(((ControlWindow*)self)->getControl()));
	}
	TS_CAPI TSWindow TS_CCALL tsControlWindow_getParentWindow(TSControlWindow self) {
		TS_ASSERT(self);
		return (TSWindow)(new Window(((ControlWindow*)self)->getParentWindow()));
	}
	TS_CAPI TSWindow TS_CCALL tsControlWindow_getDialogWindow(TSControlWindow self) {
		TS_ASSERT(self);
		return (TSWindow)(new Window(((ControlWindow*)self)->getDialogWindow()));
	}
	
	// Tellusim::ControlCheck
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_new(void) {
		ControlCheck *ret = new ControlCheck();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_new_C(TSControl *parent) {
		ControlCheck *ret = new ControlCheck((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_new_Cs(TSControl *parent, const char *text) {
		ControlCheck *ret = new ControlCheck((parent) ? *(Control**)parent : nullptr, text);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_new_CcS(TSControl *parent, const TSString text) {
		ControlCheck *ret = new ControlCheck((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_new_Csb(TSControl *parent, const char *text, bool_t checked) {
		ControlCheck *ret = new ControlCheck((parent) ? *(Control**)parent : nullptr, text, (bool)checked);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_new_CcSb(TSControl *parent, const TSString text, bool_t checked) {
		ControlCheck *ret = new ControlCheck((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null, (bool)checked);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI void TS_CCALL tsControlCheck_delete(TSControlCheck self) {
		if(self) delete (ControlCheck*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_equalPtr(const TSControlCheck self, const TSControlCheck ptr) {
		return (self && ptr && ((ControlCheck*)self)->operator==(*(ControlCheck*)ptr));
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_copyPtr(TSControlCheck self) {
		ControlCheck *ret = nullptr;
		if(self) ret = new ControlCheck(*(ControlCheck*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_clonePtr(const TSControlCheck self) {
		ControlCheck *ret = (self) ? new ControlCheck(((ControlCheck*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCheck)ret;
	}
	TS_CAPI void TS_CCALL tsControlCheck_clearPtr(TSControlCheck self) {
		if(self) ((ControlCheck*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlCheck_destroyPtr(TSControlCheck self) {
		if(self) ((ControlCheck*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlCheck_acquirePtr(TSControlCheck self) {
		if(self) ((ControlCheck*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlCheck_unacquirePtr(TSControlCheck self) {
		if(self) ((ControlCheck*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_isValidPtr(const TSControlCheck self) {
		return (self && ((ControlCheck*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_isOwnerPtr(const TSControlCheck self) {
		return (self && ((ControlCheck*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_isConstPtr(const TSControlCheck self) {
		return (self && ((ControlCheck*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlCheck_getCountPtr(const TSControlCheck self) {
		return ((ControlCheck*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlCheck_getInternalPtr(const TSControlCheck self) {
		return ((ControlCheck*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_equalControlTextPtr(const TSControlCheck self, const TSControlText base) {
		return (self && base && ((ControlCheck*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_castControlTextPtr(TSControlText base) {
		return (TSControlCheck)(new ControlCheck(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlCheck_baseControlTextPtr(TSControlCheck self) {
		return (TSControlText)(new ControlText(((ControlCheck*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_equalControlPtr(const TSControlCheck self, const TSControl base) {
		return (self && base && ((ControlCheck*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlCheck TS_CCALL tsControlCheck_castControlPtr(TSControl base) {
		return (TSControlCheck)(new ControlCheck(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlCheck_baseControlPtr(TSControlCheck self) {
		return (TSControl)(new Control(((ControlCheck*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlCheck_setCheckText_s(TSControlCheck self, const char *text) {
		TS_ASSERT(self);
		((ControlCheck*)self)->setCheckText(text);
	}
	TS_CAPI void TS_CCALL tsControlCheck_setCheckText_cS(TSControlCheck self, const TSString text) {
		TS_ASSERT(self);
		((ControlCheck*)self)->setCheckText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlCheck_getCheckText(TSControlCheck self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlCheck*)self)->getCheckText()));
	}
	TS_CAPI void TS_CCALL tsControlCheck_setCheckColor(TSControlCheck self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlCheck*)self)->setCheckColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlCheck_getCheckColor(TSControlCheck self) {
		TS_ASSERT(self);
		const Color ret = ((ControlCheck*)self)->getCheckColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlCheck_setCheckedColor(TSControlCheck self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlCheck*)self)->setCheckedColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlCheck_getCheckedColor(TSControlCheck self) {
		TS_ASSERT(self);
		const Color ret = ((ControlCheck*)self)->getCheckedColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_switchChecked(TSControlCheck self, bool_t callback) {
		TS_ASSERT(self);
		return ((ControlCheck*)self)->switchChecked((bool)callback);
	}
	TS_CAPI void TS_CCALL tsControlCheck_setChecked(TSControlCheck self, bool_t checked, bool_t callback) {
		TS_ASSERT(self);
		((ControlCheck*)self)->setChecked((bool)checked, (bool)callback);
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_isChecked(TSControlCheck self) {
		TS_ASSERT(self);
		return ((ControlCheck*)self)->isChecked();
	}
	TS_CAPI void TS_CCALL tsControlCheck_setClickedCallback(TSControlCheck self, const TSControlCheckClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlCheck*)self)->setClickedCallback(makeTSControlCheckClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlCheck_isClicked(TSControlCheck self) {
		TS_ASSERT(self);
		return ((ControlCheck*)self)->isClicked();
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlCheck_getCanvasMesh(TSControlCheck self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlCheck*)self)->getCanvasMesh()));
	}
	
	// Tellusim::ControlCombo
	TS_CAPI TSControlCombo TS_CCALL tsControlCombo_new(void) {
		ControlCombo *ret = new ControlCombo();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCombo)ret;
	}
	TS_CAPI TSControlCombo TS_CCALL tsControlCombo_new_C(TSControl *parent) {
		ControlCombo *ret = new ControlCombo((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCombo)ret;
	}
	TS_CAPI void TS_CCALL tsControlCombo_delete(TSControlCombo self) {
		if(self) delete (ControlCombo*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_equalPtr(const TSControlCombo self, const TSControlCombo ptr) {
		return (self && ptr && ((ControlCombo*)self)->operator==(*(ControlCombo*)ptr));
	}
	TS_CAPI TSControlCombo TS_CCALL tsControlCombo_copyPtr(TSControlCombo self) {
		ControlCombo *ret = nullptr;
		if(self) ret = new ControlCombo(*(ControlCombo*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCombo)ret;
	}
	TS_CAPI TSControlCombo TS_CCALL tsControlCombo_clonePtr(const TSControlCombo self) {
		ControlCombo *ret = (self) ? new ControlCombo(((ControlCombo*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlCombo)ret;
	}
	TS_CAPI void TS_CCALL tsControlCombo_clearPtr(TSControlCombo self) {
		if(self) ((ControlCombo*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlCombo_destroyPtr(TSControlCombo self) {
		if(self) ((ControlCombo*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlCombo_acquirePtr(TSControlCombo self) {
		if(self) ((ControlCombo*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlCombo_unacquirePtr(TSControlCombo self) {
		if(self) ((ControlCombo*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isValidPtr(const TSControlCombo self) {
		return (self && ((ControlCombo*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isOwnerPtr(const TSControlCombo self) {
		return (self && ((ControlCombo*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isConstPtr(const TSControlCombo self) {
		return (self && ((ControlCombo*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_getCountPtr(const TSControlCombo self) {
		return ((ControlCombo*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlCombo_getInternalPtr(const TSControlCombo self) {
		return ((ControlCombo*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_equalControlTextPtr(const TSControlCombo self, const TSControlText base) {
		return (self && base && ((ControlCombo*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlCombo TS_CCALL tsControlCombo_castControlTextPtr(TSControlText base) {
		return (TSControlCombo)(new ControlCombo(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlCombo_baseControlTextPtr(TSControlCombo self) {
		return (TSControlText)(new ControlText(((ControlCombo*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_equalControlPtr(const TSControlCombo self, const TSControl base) {
		return (self && base && ((ControlCombo*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlCombo TS_CCALL tsControlCombo_castControlPtr(TSControl base) {
		return (TSControlCombo)(new ControlCombo(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlCombo_baseControlPtr(TSControlCombo self) {
		return (TSControl)(new Control(((ControlCombo*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlCombo_setTextEnabled(TSControlCombo self, bool_t enabled) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setTextEnabled((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isTextEnabled(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->isTextEnabled();
	}
	TS_CAPI void TS_CCALL tsControlCombo_setMultiSelection(TSControlCombo self, bool_t multi_selection) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setMultiSelection((bool)multi_selection);
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isMultiSelection(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->isMultiSelection();
	}
	TS_CAPI void TS_CCALL tsControlCombo_setComboText_s(TSControlCombo self, const char *text) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setComboText(text);
	}
	TS_CAPI void TS_CCALL tsControlCombo_setComboText_cS(TSControlCombo self, const TSString text) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setComboText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlCombo_getComboText(TSControlCombo self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlCombo*)self)->getComboText()));
	}
	TS_CAPI void TS_CCALL tsControlCombo_setComboColor(TSControlCombo self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlCombo*)self)->setComboColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlCombo_getComboColor(TSControlCombo self) {
		TS_ASSERT(self);
		const Color ret = ((ControlCombo*)self)->getComboColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlCombo_setItemsSpacing(TSControlCombo self, float32_t spacing) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setItemsSpacing(spacing);
	}
	TS_CAPI float32_t TS_CCALL tsControlCombo_getItemsSpacing(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->getItemsSpacing();
	}
	TS_CAPI void TS_CCALL tsControlCombo_clearItems(TSControlCombo self) {
		TS_ASSERT(self);
		((ControlCombo*)self)->clearItems();
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_addItem_s(TSControlCombo self, const char *text) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->addItem(text);
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_addItem_cS(TSControlCombo self, const TSString text) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->addItem((text) ? *(const String*)text : String::null);
	}
	TS_CAPI void TS_CCALL tsControlCombo_addItem_us(TSControlCombo self, uint32_t index, const char *text) {
		TS_ASSERT(self);
		((ControlCombo*)self)->addItem(index, text);
	}
	TS_CAPI void TS_CCALL tsControlCombo_addItem_ucS(TSControlCombo self, uint32_t index, const TSString text) {
		TS_ASSERT(self);
		((ControlCombo*)self)->addItem(index, (text) ? *(const String*)text : String::null);
	}
	TS_CAPI void TS_CCALL tsControlCombo_removeItem(TSControlCombo self, uint32_t index) {
		TS_ASSERT(self);
		((ControlCombo*)self)->removeItem(index);
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_getNumItems(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->getNumItems();
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_switchItemSelected(TSControlCombo self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->switchItemSelected(index);
	}
	TS_CAPI void TS_CCALL tsControlCombo_setItemSelected(TSControlCombo self, uint32_t index, bool_t selected) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setItemSelected(index, (bool)selected);
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isItemSelected(TSControlCombo self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->isItemSelected(index);
	}
	TS_CAPI void TS_CCALL tsControlCombo_setItemText_us(TSControlCombo self, uint32_t index, const char *text) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setItemText(index, text);
	}
	TS_CAPI void TS_CCALL tsControlCombo_setItemText_ucS(TSControlCombo self, uint32_t index, const TSString text) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setItemText(index, (text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlCombo_getItemText(TSControlCombo self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlCombo*)self)->getItemText(index)));
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_findItemText_cs(TSControlCombo self, const char *text) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->findItemText(text);
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_findItemText_ccS(TSControlCombo self, const TSString text) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->findItemText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI void TS_CCALL tsControlCombo_setItemColor(TSControlCombo self, uint32_t index, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlCombo*)self)->setItemColor(index, *(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlCombo_getItemColor(TSControlCombo self, uint32_t index) {
		TS_ASSERT(self);
		const Color ret = ((ControlCombo*)self)->getItemColor(index);
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlCombo_setCurrentIndex(TSControlCombo self, uint32_t index, bool_t callback) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setCurrentIndex(index, (bool)callback);
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_setCurrentText_sb(TSControlCombo self, const char *text, bool_t callback) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->setCurrentText(text, (bool)callback);
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_setCurrentText_cSb(TSControlCombo self, const TSString text, bool_t callback) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->setCurrentText((text) ? *(const String*)text : String::null, (bool)callback);
	}
	TS_CAPI uint32_t TS_CCALL tsControlCombo_getCurrentIndex(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->getCurrentIndex();
	}
	TS_CAPI TSString TS_CCALL tsControlCombo_getCurrentText(TSControlCombo self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlCombo*)self)->getCurrentText()));
	}
	TS_CAPI void TS_CCALL tsControlCombo_setClickedCallback(TSControlCombo self, const TSControlComboClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setClickedCallback(makeTSControlComboClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isClicked(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->isClicked();
	}
	TS_CAPI void TS_CCALL tsControlCombo_setChangedCallback(TSControlCombo self, const TSControlComboChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlCombo*)self)->setChangedCallback(makeTSControlComboChangedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlCombo_isChanged(TSControlCombo self) {
		TS_ASSERT(self);
		return ((ControlCombo*)self)->isChanged();
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlCombo_getCanvasMesh(TSControlCombo self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlCombo*)self)->getCanvasMesh()));
	}
	
	// Tellusim::ControlButton
	TS_CAPI TSControlButton TS_CCALL tsControlButton_new(void) {
		ControlButton *ret = new ControlButton();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlButton)ret;
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_new_C(TSControl *parent) {
		ControlButton *ret = new ControlButton((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlButton)ret;
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_new_Cs(TSControl *parent, const char *text) {
		ControlButton *ret = new ControlButton((parent) ? *(Control**)parent : nullptr, text);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlButton)ret;
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_new_CcS(TSControl *parent, const TSString text) {
		ControlButton *ret = new ControlButton((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlButton)ret;
	}
	TS_CAPI void TS_CCALL tsControlButton_delete(TSControlButton self) {
		if(self) delete (ControlButton*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_equalPtr(const TSControlButton self, const TSControlButton ptr) {
		return (self && ptr && ((ControlButton*)self)->operator==(*(ControlButton*)ptr));
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_copyPtr(TSControlButton self) {
		ControlButton *ret = nullptr;
		if(self) ret = new ControlButton(*(ControlButton*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlButton)ret;
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_clonePtr(const TSControlButton self) {
		ControlButton *ret = (self) ? new ControlButton(((ControlButton*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlButton)ret;
	}
	TS_CAPI void TS_CCALL tsControlButton_clearPtr(TSControlButton self) {
		if(self) ((ControlButton*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlButton_destroyPtr(TSControlButton self) {
		if(self) ((ControlButton*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlButton_acquirePtr(TSControlButton self) {
		if(self) ((ControlButton*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlButton_unacquirePtr(TSControlButton self) {
		if(self) ((ControlButton*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_isValidPtr(const TSControlButton self) {
		return (self && ((ControlButton*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_isOwnerPtr(const TSControlButton self) {
		return (self && ((ControlButton*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_isConstPtr(const TSControlButton self) {
		return (self && ((ControlButton*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlButton_getCountPtr(const TSControlButton self) {
		return ((ControlButton*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlButton_getInternalPtr(const TSControlButton self) {
		return ((ControlButton*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_equalControlTextPtr(const TSControlButton self, const TSControlText base) {
		return (self && base && ((ControlButton*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_castControlTextPtr(TSControlText base) {
		return (TSControlButton)(new ControlButton(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlButton_baseControlTextPtr(TSControlButton self) {
		return (TSControlText)(new ControlText(((ControlButton*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_equalControlPtr(const TSControlButton self, const TSControl base) {
		return (self && base && ((ControlButton*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlButton TS_CCALL tsControlButton_castControlPtr(TSControl base) {
		return (TSControlButton)(new ControlButton(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlButton_baseControlPtr(TSControlButton self) {
		return (TSControl)(new Control(((ControlButton*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlButton_setBackground(TSControlButton self, bool_t background) {
		TS_ASSERT(self);
		((ControlButton*)self)->setBackground((bool)background);
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_getBackground(TSControlButton self) {
		TS_ASSERT(self);
		return ((ControlButton*)self)->getBackground();
	}
	TS_CAPI void TS_CCALL tsControlButton_setButtonMode(TSControlButton self, TS_CanvasElementMode mode) {
		TS_ASSERT(self);
		((ControlButton*)self)->setButtonMode((CanvasElement::Mode)mode);
	}
	TS_CAPI TS_CanvasElementMode TS_CCALL tsControlButton_getButtonMode(TSControlButton self) {
		TS_ASSERT(self);
		return (TS_CanvasElementMode)((ControlButton*)self)->getButtonMode();
	}
	TS_CAPI void TS_CCALL tsControlButton_setButtonRadius(TSControlButton self, float32_t radius) {
		TS_ASSERT(self);
		((ControlButton*)self)->setButtonRadius(radius);
	}
	TS_CAPI float32_t TS_CCALL tsControlButton_getButtonRadius(TSControlButton self) {
		TS_ASSERT(self);
		return ((ControlButton*)self)->getButtonRadius();
	}
	TS_CAPI void TS_CCALL tsControlButton_setButtonColor(TSControlButton self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlButton*)self)->setButtonColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlButton_getButtonColor(TSControlButton self) {
		TS_ASSERT(self);
		const Color ret = ((ControlButton*)self)->getButtonColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlButton_setStrokeStyle(TSControlButton self, const TSStrokeStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((ControlButton*)self)->setStrokeStyle(*(const StrokeStyle*)style);
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlButton_getStrokeStyleConst(TSControlButton self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((ControlButton*)self)->getStrokeStyleConst();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlButton_getStrokeStyle_c(TSControlButton self) {
		TS_ASSERT(self);
		const StrokeStyle ret = ((ControlButton*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI TSStrokeStyle TS_CCALL tsControlButton_getStrokeStyle(TSControlButton self) {
		TS_ASSERT(self);
		StrokeStyle ret = ((ControlButton*)self)->getStrokeStyle();
		return *(TSStrokeStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlButton_setGradientStyle(TSControlButton self, const TSGradientStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		((ControlButton*)self)->setGradientStyle(*(const GradientStyle*)style);
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlButton_getGradientStyleConst(TSControlButton self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((ControlButton*)self)->getGradientStyleConst();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlButton_getGradientStyle_c(TSControlButton self) {
		TS_ASSERT(self);
		const GradientStyle ret = ((ControlButton*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI TSGradientStyle TS_CCALL tsControlButton_getGradientStyle(TSControlButton self) {
		TS_ASSERT(self);
		GradientStyle ret = ((ControlButton*)self)->getGradientStyle();
		return *(TSGradientStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlButton_setPressedCallback(TSControlButton self, const TSControlButtonPressedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlButton*)self)->setPressedCallback(makeTSControlButtonPressedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_isPressed(TSControlButton self) {
		TS_ASSERT(self);
		return ((ControlButton*)self)->isPressed();
	}
	TS_CAPI void TS_CCALL tsControlButton_setReleasedCallback(TSControlButton self, const TSControlButtonReleasedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlButton*)self)->setReleasedCallback(makeTSControlButtonReleasedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_isReleased(TSControlButton self) {
		TS_ASSERT(self);
		return ((ControlButton*)self)->isReleased();
	}
	TS_CAPI void TS_CCALL tsControlButton_setClickedCallback(TSControlButton self, const TSControlButtonClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlButton*)self)->setClickedCallback(makeTSControlButtonClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlButton_isClicked(TSControlButton self) {
		TS_ASSERT(self);
		return ((ControlButton*)self)->isClicked();
	}
	TS_CAPI TSCanvasRect TS_CCALL tsControlButton_getCanvasRect(TSControlButton self) {
		TS_ASSERT(self);
		return (TSCanvasRect)(new CanvasRect(((ControlButton*)self)->getCanvasRect()));
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlButton_getCanvasMesh(TSControlButton self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlButton*)self)->getCanvasMesh()));
	}
	
	// Tellusim::ControlSlider
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new(void) {
		ControlSlider *ret = new ControlSlider();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_C(TSControl *parent) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Cs(TSControl *parent, const char *text) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_CcS(TSControl *parent, const TSString text) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Csu(TSControl *parent, const char *text, uint32_t digits) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text, digits);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Csuf64(TSControl *parent, const char *text, uint32_t digits, float64_t value) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text, digits, value);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Csuf64f64f64(TSControl *parent, const char *text, uint32_t digits, float64_t value, float64_t min, float64_t max) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text, digits, value, min, max);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Csf64f64f64(TSControl *parent, const char *text, float64_t value, float64_t min, float64_t max) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text, value, min, max);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Csuuu(TSControl *parent, const char *text, uint32_t value, uint32_t min, uint32_t max) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text, value, min, max);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_new_Csiii(TSControl *parent, const char *text, int32_t value, int32_t min, int32_t max) {
		ControlSlider *ret = new ControlSlider((parent) ? *(Control**)parent : nullptr, text, value, min, max);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI void TS_CCALL tsControlSlider_delete(TSControlSlider self) {
		if(self) delete (ControlSlider*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_equalPtr(const TSControlSlider self, const TSControlSlider ptr) {
		return (self && ptr && ((ControlSlider*)self)->operator==(*(ControlSlider*)ptr));
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_copyPtr(TSControlSlider self) {
		ControlSlider *ret = nullptr;
		if(self) ret = new ControlSlider(*(ControlSlider*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_clonePtr(const TSControlSlider self) {
		ControlSlider *ret = (self) ? new ControlSlider(((ControlSlider*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSlider)ret;
	}
	TS_CAPI void TS_CCALL tsControlSlider_clearPtr(TSControlSlider self) {
		if(self) ((ControlSlider*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlSlider_destroyPtr(TSControlSlider self) {
		if(self) ((ControlSlider*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlSlider_acquirePtr(TSControlSlider self) {
		if(self) ((ControlSlider*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlSlider_unacquirePtr(TSControlSlider self) {
		if(self) ((ControlSlider*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isValidPtr(const TSControlSlider self) {
		return (self && ((ControlSlider*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isOwnerPtr(const TSControlSlider self) {
		return (self && ((ControlSlider*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isConstPtr(const TSControlSlider self) {
		return (self && ((ControlSlider*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlSlider_getCountPtr(const TSControlSlider self) {
		return ((ControlSlider*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlSlider_getInternalPtr(const TSControlSlider self) {
		return ((ControlSlider*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_equalControlTextPtr(const TSControlSlider self, const TSControlText base) {
		return (self && base && ((ControlSlider*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_castControlTextPtr(TSControlText base) {
		return (TSControlSlider)(new ControlSlider(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlSlider_baseControlTextPtr(TSControlSlider self) {
		return (TSControlText)(new ControlText(((ControlSlider*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_equalControlPtr(const TSControlSlider self, const TSControl base) {
		return (self && base && ((ControlSlider*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlSlider TS_CCALL tsControlSlider_castControlPtr(TSControl base) {
		return (TSControlSlider)(new ControlSlider(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlSlider_baseControlPtr(TSControlSlider self) {
		return (TSControl)(new Control(((ControlSlider*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlSlider_setConstrained(TSControlSlider self, bool_t constrained) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setConstrained((bool)constrained);
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isConstrained(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->isConstrained();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setTextEnabled(TSControlSlider self, bool_t enabled) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setTextEnabled((bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isTextEnabled(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->isTextEnabled();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setSliderColor(TSControlSlider self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlSlider*)self)->setSliderColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlSlider_getSliderColor(TSControlSlider self) {
		TS_ASSERT(self);
		const Color ret = ((ControlSlider*)self)->getSliderColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlSlider_setDigits(TSControlSlider self, uint32_t digits) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setDigits(digits);
	}
	TS_CAPI uint32_t TS_CCALL tsControlSlider_getDigits(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getDigits();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setStep(TSControlSlider self, float64_t step) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setStep(step);
	}
	TS_CAPI float64_t TS_CCALL tsControlSlider_getStep(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getStep();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setBase(TSControlSlider self, float64_t base) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setBase(base);
	}
	TS_CAPI float64_t TS_CCALL tsControlSlider_getBase(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getBase();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setFormat_s(TSControlSlider self, const char *format) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setFormat(format);
	}
	TS_CAPI void TS_CCALL tsControlSlider_setFormat_cS(TSControlSlider self, const TSString format) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setFormat((format) ? *(const String*)format : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlSlider_getFormat(TSControlSlider self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlSlider*)self)->getFormat()));
	}
	TS_CAPI void TS_CCALL tsControlSlider_setValue(TSControlSlider self, float64_t value, bool_t callback, bool_t exponent) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setValue(value, (bool)callback, (bool)exponent);
	}
	TS_CAPI float64_t TS_CCALL tsControlSlider_getValue(TSControlSlider self, bool_t exponent) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getValue((bool)exponent);
	}
	TS_CAPI float32_t TS_CCALL tsControlSlider_getValuef32(TSControlSlider self, bool_t exponent) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getValuef32((bool)exponent);
	}
	TS_CAPI uint32_t TS_CCALL tsControlSlider_getValueu32(TSControlSlider self, bool_t exponent) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getValueu32((bool)exponent);
	}
	TS_CAPI int32_t TS_CCALL tsControlSlider_getValuei32(TSControlSlider self, bool_t exponent) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getValuei32((bool)exponent);
	}
	TS_CAPI void TS_CCALL tsControlSlider_setRange(TSControlSlider self, float64_t min, float64_t max, bool_t exponent) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setRange(min, max, (bool)exponent);
	}
	TS_CAPI float64_t TS_CCALL tsControlSlider_getMinRange(TSControlSlider self, bool_t exponent) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getMinRange((bool)exponent);
	}
	TS_CAPI float64_t TS_CCALL tsControlSlider_getMaxRange(TSControlSlider self, bool_t exponent) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getMaxRange((bool)exponent);
	}
	TS_CAPI void TS_CCALL tsControlSlider_setHandleSize(TSControlSlider self, float32_t size) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setHandleSize(size);
	}
	TS_CAPI float32_t TS_CCALL tsControlSlider_getHandleSize(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->getHandleSize();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setFormatCallback(TSControlSlider self, const TSControlSliderFormatCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setFormatCallback(makeTSControlSliderFormatCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlSlider_setPressedCallback(TSControlSlider self, const TSControlSliderPressedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setPressedCallback(makeTSControlSliderPressedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isPressed(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->isPressed();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setReleasedCallback(TSControlSlider self, const TSControlSliderReleasedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setReleasedCallback(makeTSControlSliderReleasedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isReleased(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->isReleased();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setClickedCallback(TSControlSlider self, const TSControlSliderClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setClickedCallback(makeTSControlSliderClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlSlider_setClicked2Callback(TSControlSlider self, const TSControlSliderClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setClicked2Callback(makeTSControlSliderClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlSlider_setClickedRightCallback(TSControlSlider self, const TSControlSliderClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setClickedRightCallback(makeTSControlSliderClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isClicked(TSControlSlider self) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->isClicked();
	}
	TS_CAPI void TS_CCALL tsControlSlider_setChangedCallback(TSControlSlider self, const TSControlSliderChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlSlider*)self)->setChangedCallback(makeTSControlSliderChangedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlSlider_isChanged(TSControlSlider self, bool_t clear) {
		TS_ASSERT(self);
		return ((ControlSlider*)self)->isChanged((bool)clear);
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlSlider_getCanvasMesh(TSControlSlider self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlSlider*)self)->getCanvasMesh()));
	}
	
	// Tellusim::ControlScroll
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_new(void) {
		ControlScroll *ret = new ControlScroll();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_new_Cb(TSControl *parent, bool_t vertical) {
		ControlScroll *ret = new ControlScroll((parent) ? *(Control**)parent : nullptr, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_new_Cf64b(TSControl *parent, float64_t value, bool_t vertical) {
		ControlScroll *ret = new ControlScroll((parent) ? *(Control**)parent : nullptr, value, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_new_Cf64f64f64b(TSControl *parent, float64_t value, float64_t frame, float64_t range, bool_t vertical) {
		ControlScroll *ret = new ControlScroll((parent) ? *(Control**)parent : nullptr, value, frame, range, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_new_Cuuub(TSControl *parent, uint32_t value, uint32_t frame, uint32_t range, bool_t vertical) {
		ControlScroll *ret = new ControlScroll((parent) ? *(Control**)parent : nullptr, value, frame, range, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_new_Ciiib(TSControl *parent, int32_t value, int32_t frame, int32_t range, bool_t vertical) {
		ControlScroll *ret = new ControlScroll((parent) ? *(Control**)parent : nullptr, value, frame, range, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI void TS_CCALL tsControlScroll_delete(TSControlScroll self) {
		if(self) delete (ControlScroll*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_equalPtr(const TSControlScroll self, const TSControlScroll ptr) {
		return (self && ptr && ((ControlScroll*)self)->operator==(*(ControlScroll*)ptr));
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_copyPtr(TSControlScroll self) {
		ControlScroll *ret = nullptr;
		if(self) ret = new ControlScroll(*(ControlScroll*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_clonePtr(const TSControlScroll self) {
		ControlScroll *ret = (self) ? new ControlScroll(((ControlScroll*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlScroll)ret;
	}
	TS_CAPI void TS_CCALL tsControlScroll_clearPtr(TSControlScroll self) {
		if(self) ((ControlScroll*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlScroll_destroyPtr(TSControlScroll self) {
		if(self) ((ControlScroll*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlScroll_acquirePtr(TSControlScroll self) {
		if(self) ((ControlScroll*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlScroll_unacquirePtr(TSControlScroll self) {
		if(self) ((ControlScroll*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isValidPtr(const TSControlScroll self) {
		return (self && ((ControlScroll*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isOwnerPtr(const TSControlScroll self) {
		return (self && ((ControlScroll*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isConstPtr(const TSControlScroll self) {
		return (self && ((ControlScroll*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlScroll_getCountPtr(const TSControlScroll self) {
		return ((ControlScroll*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlScroll_getInternalPtr(const TSControlScroll self) {
		return ((ControlScroll*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_equalControlTextPtr(const TSControlScroll self, const TSControlText base) {
		return (self && base && ((ControlScroll*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_castControlTextPtr(TSControlText base) {
		return (TSControlScroll)(new ControlScroll(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlScroll_baseControlTextPtr(TSControlScroll self) {
		return (TSControlText)(new ControlText(((ControlScroll*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_equalControlPtr(const TSControlScroll self, const TSControl base) {
		return (self && base && ((ControlScroll*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlScroll_castControlPtr(TSControl base) {
		return (TSControlScroll)(new ControlScroll(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlScroll_baseControlPtr(TSControlScroll self) {
		return (TSControl)(new Control(((ControlScroll*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlScroll_setVertical(TSControlScroll self, bool_t vertical, bool_t text) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setVertical((bool)vertical, (bool)text);
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isHorizontal(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->isHorizontal();
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isVertical(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->isVertical();
	}
	TS_CAPI void TS_CCALL tsControlScroll_setPrevText_s(TSControlScroll self, const char *text) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setPrevText(text);
	}
	TS_CAPI void TS_CCALL tsControlScroll_setPrevText_cS(TSControlScroll self, const TSString text) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setPrevText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlScroll_getPrevText(TSControlScroll self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlScroll*)self)->getPrevText()));
	}
	TS_CAPI void TS_CCALL tsControlScroll_setNextText_s(TSControlScroll self, const char *text) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setNextText(text);
	}
	TS_CAPI void TS_CCALL tsControlScroll_setNextText_cS(TSControlScroll self, const TSString text) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setNextText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlScroll_getNextText(TSControlScroll self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlScroll*)self)->getNextText()));
	}
	TS_CAPI void TS_CCALL tsControlScroll_setScrollColor(TSControlScroll self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlScroll*)self)->setScrollColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlScroll_getScrollColor(TSControlScroll self) {
		TS_ASSERT(self);
		const Color ret = ((ControlScroll*)self)->getScrollColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlScroll_setStep(TSControlScroll self, float64_t step) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setStep(step);
	}
	TS_CAPI float64_t TS_CCALL tsControlScroll_getStep(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->getStep();
	}
	TS_CAPI void TS_CCALL tsControlScroll_setValue(TSControlScroll self, float64_t value, bool_t callback) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setValue(value, (bool)callback);
	}
	TS_CAPI float64_t TS_CCALL tsControlScroll_getValue(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->getValue();
	}
	TS_CAPI void TS_CCALL tsControlScroll_setFrame(TSControlScroll self, float64_t frame) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setFrame(frame);
	}
	TS_CAPI float64_t TS_CCALL tsControlScroll_getFrame(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->getFrame();
	}
	TS_CAPI void TS_CCALL tsControlScroll_setRange(TSControlScroll self, float64_t range) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setRange(range);
	}
	TS_CAPI float64_t TS_CCALL tsControlScroll_getRange(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->getRange();
	}
	TS_CAPI void TS_CCALL tsControlScroll_setFrameAlign(TSControlScroll self, TS_ControlAlign align) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setFrameAlign((Control::Align)align);
	}
	TS_CAPI TS_ControlAlign TS_CCALL tsControlScroll_getFrameAlign(TSControlScroll self) {
		TS_ASSERT(self);
		return (TS_ControlAlign)((ControlScroll*)self)->getFrameAlign();
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_hasFrameAlign(TSControlScroll self, TS_ControlAlign align) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->hasFrameAlign((Control::Align)align);
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_hasFrameAligns(TSControlScroll self, TS_ControlAlign aligns) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->hasFrameAligns((Control::Align)aligns);
	}
	TS_CAPI void TS_CCALL tsControlScroll_setClickedCallback(TSControlScroll self, const TSControlScrollClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setClickedCallback(makeTSControlScrollClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isClicked(TSControlScroll self) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->isClicked();
	}
	TS_CAPI void TS_CCALL tsControlScroll_setChangedCallback(TSControlScroll self, const TSControlScrollChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlScroll*)self)->setChangedCallback(makeTSControlScrollChangedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlScroll_isChanged(TSControlScroll self, bool_t clear) {
		TS_ASSERT(self);
		return ((ControlScroll*)self)->isChanged((bool)clear);
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlScroll_getCanvasMesh(TSControlScroll self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlScroll*)self)->getCanvasMesh()));
	}
	
	// Tellusim::ControlSplit
	TS_CAPI TSControlSplit TS_CCALL tsControlSplit_new(void) {
		ControlSplit *ret = new ControlSplit();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSplit)ret;
	}
	TS_CAPI TSControlSplit TS_CCALL tsControlSplit_new_Cb(TSControl *parent, bool_t vertical) {
		ControlSplit *ret = new ControlSplit((parent) ? *(Control**)parent : nullptr, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSplit)ret;
	}
	TS_CAPI TSControlSplit TS_CCALL tsControlSplit_new_Cfb(TSControl *parent, float32_t value, bool_t vertical) {
		ControlSplit *ret = new ControlSplit((parent) ? *(Control**)parent : nullptr, value, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSplit)ret;
	}
	TS_CAPI void TS_CCALL tsControlSplit_delete(TSControlSplit self) {
		if(self) delete (ControlSplit*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_equalPtr(const TSControlSplit self, const TSControlSplit ptr) {
		return (self && ptr && ((ControlSplit*)self)->operator==(*(ControlSplit*)ptr));
	}
	TS_CAPI TSControlSplit TS_CCALL tsControlSplit_copyPtr(TSControlSplit self) {
		ControlSplit *ret = nullptr;
		if(self) ret = new ControlSplit(*(ControlSplit*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSplit)ret;
	}
	TS_CAPI TSControlSplit TS_CCALL tsControlSplit_clonePtr(const TSControlSplit self) {
		ControlSplit *ret = (self) ? new ControlSplit(((ControlSplit*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlSplit)ret;
	}
	TS_CAPI void TS_CCALL tsControlSplit_clearPtr(TSControlSplit self) {
		if(self) ((ControlSplit*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlSplit_destroyPtr(TSControlSplit self) {
		if(self) ((ControlSplit*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlSplit_acquirePtr(TSControlSplit self) {
		if(self) ((ControlSplit*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlSplit_unacquirePtr(TSControlSplit self) {
		if(self) ((ControlSplit*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_isValidPtr(const TSControlSplit self) {
		return (self && ((ControlSplit*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_isOwnerPtr(const TSControlSplit self) {
		return (self && ((ControlSplit*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_isConstPtr(const TSControlSplit self) {
		return (self && ((ControlSplit*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlSplit_getCountPtr(const TSControlSplit self) {
		return ((ControlSplit*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlSplit_getInternalPtr(const TSControlSplit self) {
		return ((ControlSplit*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_equalControlPtr(const TSControlSplit self, const TSControl base) {
		return (self && base && ((ControlSplit*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlSplit TS_CCALL tsControlSplit_castControlPtr(TSControl base) {
		return (TSControlSplit)(new ControlSplit(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlSplit_baseControlPtr(TSControlSplit self) {
		return (TSControl)(new Control(((ControlSplit*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlSplit_setAbsolute(TSControlSplit self, bool_t absolute) {
		TS_ASSERT(self);
		((ControlSplit*)self)->setAbsolute((bool)absolute);
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_isAbsolute(TSControlSplit self) {
		TS_ASSERT(self);
		return ((ControlSplit*)self)->isAbsolute();
	}
	TS_CAPI void TS_CCALL tsControlSplit_setVertical(TSControlSplit self, bool_t vertical) {
		TS_ASSERT(self);
		((ControlSplit*)self)->setVertical((bool)vertical);
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_isHorizontal(TSControlSplit self) {
		TS_ASSERT(self);
		return ((ControlSplit*)self)->isHorizontal();
	}
	TS_CAPI bool_t TS_CCALL tsControlSplit_isVertical(TSControlSplit self) {
		TS_ASSERT(self);
		return ((ControlSplit*)self)->isVertical();
	}
	TS_CAPI void TS_CCALL tsControlSplit_setValue(TSControlSplit self, float32_t value) {
		TS_ASSERT(self);
		((ControlSplit*)self)->setValue(value);
	}
	TS_CAPI float32_t TS_CCALL tsControlSplit_getValue(TSControlSplit self) {
		TS_ASSERT(self);
		return ((ControlSplit*)self)->getValue();
	}
	TS_CAPI void TS_CCALL tsControlSplit_setHandleSize(TSControlSplit self, float32_t size) {
		TS_ASSERT(self);
		((ControlSplit*)self)->setHandleSize(size);
	}
	TS_CAPI float32_t TS_CCALL tsControlSplit_getHandleSize(TSControlSplit self) {
		TS_ASSERT(self);
		return ((ControlSplit*)self)->getHandleSize();
	}
	TS_CAPI TSVector2f TS_CCALL tsControlSplit_getControlsSize(TSControlSplit self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlSplit*)self)->getControlsSize();
		return *(TSVector2f*)&ret;
	}
	
	// Tellusim::ControlArea
	TS_CAPI TSControlArea TS_CCALL tsControlArea_new(void) {
		ControlArea *ret = new ControlArea();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_new_C(TSControl *parent) {
		ControlArea *ret = new ControlArea((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_new_Cu(TSControl *parent, uint32_t columns) {
		ControlArea *ret = new ControlArea((parent) ? *(Control**)parent : nullptr, columns);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_new_Cbb(TSControl *parent, bool_t horizontal, bool_t vertical) {
		ControlArea *ret = new ControlArea((parent) ? *(Control**)parent : nullptr, (bool)horizontal, (bool)vertical);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_new_Cuff(TSControl *parent, uint32_t columns, float32_t x, float32_t y) {
		ControlArea *ret = new ControlArea((parent) ? *(Control**)parent : nullptr, columns, x, y);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI void TS_CCALL tsControlArea_delete(TSControlArea self) {
		if(self) delete (ControlArea*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_equalPtr(const TSControlArea self, const TSControlArea ptr) {
		return (self && ptr && ((ControlArea*)self)->operator==(*(ControlArea*)ptr));
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_copyPtr(TSControlArea self) {
		ControlArea *ret = nullptr;
		if(self) ret = new ControlArea(*(ControlArea*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_clonePtr(const TSControlArea self) {
		ControlArea *ret = (self) ? new ControlArea(((ControlArea*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlArea)ret;
	}
	TS_CAPI void TS_CCALL tsControlArea_clearPtr(TSControlArea self) {
		if(self) ((ControlArea*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlArea_destroyPtr(TSControlArea self) {
		if(self) ((ControlArea*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlArea_acquirePtr(TSControlArea self) {
		if(self) ((ControlArea*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlArea_unacquirePtr(TSControlArea self) {
		if(self) ((ControlArea*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isValidPtr(const TSControlArea self) {
		return (self && ((ControlArea*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isOwnerPtr(const TSControlArea self) {
		return (self && ((ControlArea*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isConstPtr(const TSControlArea self) {
		return (self && ((ControlArea*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlArea_getCountPtr(const TSControlArea self) {
		return ((ControlArea*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlArea_getInternalPtr(const TSControlArea self) {
		return ((ControlArea*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_equalControlPtr(const TSControlArea self, const TSControl base) {
		return (self && base && ((ControlArea*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlArea TS_CCALL tsControlArea_castControlPtr(TSControl base) {
		return (TSControlArea)(new ControlArea(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlArea_baseControlPtr(TSControlArea self) {
		return (TSControl)(new Control(((ControlArea*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlArea_setAbsolute(TSControlArea self, bool_t absolute) {
		TS_ASSERT(self);
		((ControlArea*)self)->setAbsolute((bool)absolute);
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isAbsolute(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isAbsolute();
	}
	TS_CAPI void TS_CCALL tsControlArea_setScalable(TSControlArea self, bool_t scalable) {
		TS_ASSERT(self);
		((ControlArea*)self)->setScalable((bool)scalable);
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isScalable(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isScalable();
	}
	TS_CAPI void TS_CCALL tsControlArea_setScrollable(TSControlArea self, bool_t scrollable) {
		TS_ASSERT(self);
		((ControlArea*)self)->setScrollable((bool)scrollable);
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isScrollable(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isScrollable();
	}
	TS_CAPI void TS_CCALL tsControlArea_setScale(TSControlArea self, float32_t scale) {
		TS_ASSERT(self);
		((ControlArea*)self)->setScale(scale);
	}
	TS_CAPI float32_t TS_CCALL tsControlArea_getScale(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getScale();
	}
	TS_CAPI void TS_CCALL tsControlArea_setScaleRange(TSControlArea self, float32_t min, float32_t max) {
		TS_ASSERT(self);
		((ControlArea*)self)->setScaleRange(min, max);
	}
	TS_CAPI float32_t TS_CCALL tsControlArea_getMinScale(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getMinScale();
	}
	TS_CAPI float32_t TS_CCALL tsControlArea_getMaxScale(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getMaxScale();
	}
	TS_CAPI void TS_CCALL tsControlArea_setHorizontalStep(TSControlArea self, float64_t step) {
		TS_ASSERT(self);
		((ControlArea*)self)->setHorizontalStep(step);
	}
	TS_CAPI void TS_CCALL tsControlArea_setVerticalStep(TSControlArea self, float64_t step) {
		TS_ASSERT(self);
		((ControlArea*)self)->setVerticalStep(step);
	}
	TS_CAPI void TS_CCALL tsControlArea_setStep(TSControlArea self, float64_t horizontal, float64_t vertical) {
		TS_ASSERT(self);
		((ControlArea*)self)->setStep(horizontal, vertical);
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getHorizontalStep(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getHorizontalStep();
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getVerticalStep(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getVerticalStep();
	}
	TS_CAPI void TS_CCALL tsControlArea_setHorizontalValue(TSControlArea self, float64_t value) {
		TS_ASSERT(self);
		((ControlArea*)self)->setHorizontalValue(value);
	}
	TS_CAPI void TS_CCALL tsControlArea_setVerticalValue(TSControlArea self, float64_t value) {
		TS_ASSERT(self);
		((ControlArea*)self)->setVerticalValue(value);
	}
	TS_CAPI void TS_CCALL tsControlArea_setValue(TSControlArea self, float64_t horizontal, float64_t vertical) {
		TS_ASSERT(self);
		((ControlArea*)self)->setValue(horizontal, vertical);
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getHorizontalValue(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getHorizontalValue();
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getVerticalValue(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getVerticalValue();
	}
	TS_CAPI void TS_CCALL tsControlArea_setFrameAlign(TSControlArea self, TS_ControlAlign align) {
		TS_ASSERT(self);
		((ControlArea*)self)->setFrameAlign((Control::Align)align);
	}
	TS_CAPI TS_ControlAlign TS_CCALL tsControlArea_getFrameAlign(TSControlArea self) {
		TS_ASSERT(self);
		return (TS_ControlAlign)((ControlArea*)self)->getFrameAlign();
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getHorizontalFrame(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getHorizontalFrame();
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getVerticalFrame(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getVerticalFrame();
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getHorizontalRange(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getHorizontalRange();
	}
	TS_CAPI float64_t TS_CCALL tsControlArea_getVerticalRange(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getVerticalRange();
	}
	TS_CAPI void TS_CCALL tsControlArea_setHorizontalEnabled(TSControlArea self, bool_t enabled, bool_t dynamic) {
		TS_ASSERT(self);
		((ControlArea*)self)->setHorizontalEnabled((bool)enabled, (bool)dynamic);
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isHorizontalEnabled(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isHorizontalEnabled();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isHorizontalDynamic(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isHorizontalDynamic();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isHorizontalHidden(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isHorizontalHidden();
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlArea_getHorizontalScroll_c(TSControlArea self) {
		TS_ASSERT(self);
		return (TSControlScroll)(new ControlScroll(((ControlArea*)self)->getHorizontalScroll()));
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlArea_getHorizontalScroll(TSControlArea self) {
		TS_ASSERT(self);
		return (TSControlScroll)(new ControlScroll(((ControlArea*)self)->getHorizontalScroll()));
	}
	TS_CAPI void TS_CCALL tsControlArea_setVerticalEnabled(TSControlArea self, bool_t enabled, bool_t dynamic) {
		TS_ASSERT(self);
		((ControlArea*)self)->setVerticalEnabled((bool)enabled, (bool)dynamic);
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isVerticalEnabled(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isVerticalEnabled();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isVerticalDynamic(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isVerticalDynamic();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_isVerticalHidden(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->isVerticalHidden();
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlArea_getVerticalScroll_c(TSControlArea self) {
		TS_ASSERT(self);
		return (TSControlScroll)(new ControlScroll(((ControlArea*)self)->getVerticalScroll()));
	}
	TS_CAPI TSControlScroll TS_CCALL tsControlArea_getVerticalScroll(TSControlArea self) {
		TS_ASSERT(self);
		return (TSControlScroll)(new ControlScroll(((ControlArea*)self)->getVerticalScroll()));
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_setFontSize(TSControlArea self, uint32_t size) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->setFontSize(size);
	}
	TS_CAPI uint32_t TS_CCALL tsControlArea_getFontSize(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getFontSize();
	}
	TS_CAPI bool_t TS_CCALL tsControlArea_setFontStyle(TSControlArea self, const TSFontStyle *style) {
		TS_ASSERT(self);
		TS_ASSERT(style);
		return ((ControlArea*)self)->setFontStyle(*(const FontStyle*)style);
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlArea_getFontStyleConst(TSControlArea self) {
		TS_ASSERT(self);
		const FontStyle ret = ((ControlArea*)self)->getFontStyleConst();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlArea_getFontStyle_c(TSControlArea self) {
		TS_ASSERT(self);
		const FontStyle ret = ((ControlArea*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI TSFontStyle TS_CCALL tsControlArea_getFontStyle(TSControlArea self) {
		TS_ASSERT(self);
		FontStyle ret = ((ControlArea*)self)->getFontStyle();
		return *(TSFontStyle*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlArea_setColumns(TSControlArea self, uint32_t columns) {
		TS_ASSERT(self);
		((ControlArea*)self)->setColumns(columns);
	}
	TS_CAPI uint32_t TS_CCALL tsControlArea_getColumns(TSControlArea self) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getColumns();
	}
	TS_CAPI void TS_CCALL tsControlArea_setSpacing_cV2(TSControlArea self, const TSVector2f *spacing) {
		TS_ASSERT(self);
		TS_ASSERT(spacing);
		((ControlArea*)self)->setSpacing(*(const Vector2f*)spacing);
	}
	TS_CAPI void TS_CCALL tsControlArea_setSpacing_ff(TSControlArea self, float32_t x, float32_t y) {
		TS_ASSERT(self);
		((ControlArea*)self)->setSpacing(x, y);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlArea_getSpacing(TSControlArea self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlArea*)self)->getSpacing();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlArea_setColumnRatio(TSControlArea self, uint32_t index, float32_t ratio) {
		TS_ASSERT(self);
		((ControlArea*)self)->setColumnRatio(index, ratio);
	}
	TS_CAPI float32_t TS_CCALL tsControlArea_getColumnRatio(TSControlArea self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlArea*)self)->getColumnRatio(index);
	}
	TS_CAPI TSVector2f TS_CCALL tsControlArea_getControlsSize(TSControlArea self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlArea*)self)->getControlsSize();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI TSVector2f TS_CCALL tsControlArea_getControlsOffset(TSControlArea self) {
		TS_ASSERT(self);
		const Vector2f ret = ((ControlArea*)self)->getControlsOffset();
		return *(TSVector2f*)&ret;
	}
	TS_CAPI TSRect TS_CCALL tsControlArea_getViewRect(TSControlArea self) {
		TS_ASSERT(self);
		const Rect ret = ((ControlArea*)self)->getViewRect();
		return *(TSRect*)&ret;
	}
	
	// Tellusim::ControlTree
	TS_CAPI TSControlTree TS_CCALL tsControlTree_new(void) {
		ControlTree *ret = new ControlTree();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlTree)ret;
	}
	TS_CAPI TSControlTree TS_CCALL tsControlTree_new_C(TSControl *parent) {
		ControlTree *ret = new ControlTree((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlTree)ret;
	}
	TS_CAPI void TS_CCALL tsControlTree_delete(TSControlTree self) {
		if(self) delete (ControlTree*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_equalPtr(const TSControlTree self, const TSControlTree ptr) {
		return (self && ptr && ((ControlTree*)self)->operator==(*(ControlTree*)ptr));
	}
	TS_CAPI TSControlTree TS_CCALL tsControlTree_copyPtr(TSControlTree self) {
		ControlTree *ret = nullptr;
		if(self) ret = new ControlTree(*(ControlTree*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlTree)ret;
	}
	TS_CAPI TSControlTree TS_CCALL tsControlTree_clonePtr(const TSControlTree self) {
		ControlTree *ret = (self) ? new ControlTree(((ControlTree*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlTree)ret;
	}
	TS_CAPI void TS_CCALL tsControlTree_clearPtr(TSControlTree self) {
		if(self) ((ControlTree*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlTree_destroyPtr(TSControlTree self) {
		if(self) ((ControlTree*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlTree_acquirePtr(TSControlTree self) {
		if(self) ((ControlTree*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlTree_unacquirePtr(TSControlTree self) {
		if(self) ((ControlTree*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isValidPtr(const TSControlTree self) {
		return (self && ((ControlTree*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isOwnerPtr(const TSControlTree self) {
		return (self && ((ControlTree*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isConstPtr(const TSControlTree self) {
		return (self && ((ControlTree*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getCountPtr(const TSControlTree self) {
		return ((ControlTree*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlTree_getInternalPtr(const TSControlTree self) {
		return ((ControlTree*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_equalControlTextPtr(const TSControlTree self, const TSControlText base) {
		return (self && base && ((ControlTree*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlTree TS_CCALL tsControlTree_castControlTextPtr(TSControlText base) {
		return (TSControlTree)(new ControlTree(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlTree_baseControlTextPtr(TSControlTree self) {
		return (TSControlText)(new ControlText(((ControlTree*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_equalControlPtr(const TSControlTree self, const TSControl base) {
		return (self && base && ((ControlTree*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlTree TS_CCALL tsControlTree_castControlPtr(TSControl base) {
		return (TSControlTree)(new ControlTree(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlTree_baseControlPtr(TSControlTree self) {
		return (TSControl)(new Control(((ControlTree*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlTree_setSelectable(TSControlTree self, bool_t selectable) {
		TS_ASSERT(self);
		((ControlTree*)self)->setSelectable((bool)selectable);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isSelectable(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isSelectable();
	}
	TS_CAPI void TS_CCALL tsControlTree_setMultiSelection(TSControlTree self, bool_t multi_selection) {
		TS_ASSERT(self);
		((ControlTree*)self)->setMultiSelection((bool)multi_selection);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isMultiSelection(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isMultiSelection();
	}
	TS_CAPI void TS_CCALL tsControlTree_setFoldedText_s(TSControlTree self, const char *text) {
		TS_ASSERT(self);
		((ControlTree*)self)->setFoldedText(text);
	}
	TS_CAPI void TS_CCALL tsControlTree_setFoldedText_cS(TSControlTree self, const TSString text) {
		TS_ASSERT(self);
		((ControlTree*)self)->setFoldedText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlTree_getFoldedText(TSControlTree self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlTree*)self)->getFoldedText()));
	}
	TS_CAPI void TS_CCALL tsControlTree_setExpandedText_s(TSControlTree self, const char *text) {
		TS_ASSERT(self);
		((ControlTree*)self)->setExpandedText(text);
	}
	TS_CAPI void TS_CCALL tsControlTree_setExpandedText_cS(TSControlTree self, const TSString text) {
		TS_ASSERT(self);
		((ControlTree*)self)->setExpandedText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlTree_getExpandedText(TSControlTree self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlTree*)self)->getExpandedText()));
	}
	TS_CAPI void TS_CCALL tsControlTree_setTexture(TSControlTree self, TSTexture texture, uint32_t rows, uint32_t columns) {
		TS_ASSERT(self);
		TS_ASSERT(texture);
		((ControlTree*)self)->setTexture(*(Texture*)texture, rows, columns);
	}
	TS_CAPI TSTexture TS_CCALL tsControlTree_getTexture(TSControlTree self) {
		TS_ASSERT(self);
		return (TSTexture)(new Texture(((ControlTree*)self)->getTexture()));
	}
	TS_CAPI void TS_CCALL tsControlTree_setTextureName_suu(TSControlTree self, const char *name, uint32_t rows, uint32_t columns) {
		TS_ASSERT(self);
		((ControlTree*)self)->setTextureName(name, rows, columns);
	}
	TS_CAPI void TS_CCALL tsControlTree_setTextureName_cSuu(TSControlTree self, const TSString name, uint32_t rows, uint32_t columns) {
		TS_ASSERT(self);
		((ControlTree*)self)->setTextureName((name) ? *(const String*)name : String::null, rows, columns);
	}
	TS_CAPI TSString TS_CCALL tsControlTree_getTextureName(TSControlTree self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlTree*)self)->getTextureName()));
	}
	TS_CAPI void TS_CCALL tsControlTree_setTextureGrid(TSControlTree self, uint32_t rows, uint32_t columns) {
		TS_ASSERT(self);
		((ControlTree*)self)->setTextureGrid(rows, columns);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getTextureRows(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getTextureRows();
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getTextureColumns(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getTextureColumns();
	}
	TS_CAPI void TS_CCALL tsControlTree_clearItems(TSControlTree self) {
		TS_ASSERT(self);
		((ControlTree*)self)->clearItems();
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_addItem_sub(TSControlTree self, const char *text, uint32_t parent, bool_t expanded) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->addItem(text, parent, (bool)expanded);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_addItem_cSub(TSControlTree self, const TSString text, uint32_t parent, bool_t expanded) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->addItem((text) ? *(const String*)text : String::null, parent, (bool)expanded);
	}
	TS_CAPI void TS_CCALL tsControlTree_removeItem(TSControlTree self, uint32_t item, bool_t children) {
		TS_ASSERT(self);
		((ControlTree*)self)->removeItem(item, (bool)children);
	}
	TS_CAPI void TS_CCALL tsControlTree_viewItem(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		((ControlTree*)self)->viewItem(item);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getNumItems(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getNumItems();
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getItem(TSControlTree self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getItem(index);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_switchItemHidden(TSControlTree self, uint32_t item, bool_t children) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->switchItemHidden(item, (bool)children);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemHidden(TSControlTree self, uint32_t item, bool_t hidden, bool_t children) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemHidden(item, (bool)hidden, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isItemHidden(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isItemHidden(item);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_switchItemExpanded(TSControlTree self, uint32_t item, bool_t children) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->switchItemExpanded(item, (bool)children);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemExpanded(TSControlTree self, uint32_t item, bool_t expanded, bool_t children) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemExpanded(item, (bool)expanded, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isItemExpanded(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isItemExpanded(item);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_switchItemSelected(TSControlTree self, uint32_t item, bool_t children) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->switchItemSelected(item, (bool)children);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemSelected(TSControlTree self, uint32_t item, bool_t selected, bool_t children) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemSelected(item, (bool)selected, (bool)children);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isItemSelected(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isItemSelected(item);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemParent(TSControlTree self, uint32_t item, uint32_t parent) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemParent(item, parent);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getItemParent(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getItemParent(item);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isItemParent(TSControlTree self, uint32_t item, uint32_t parent, bool_t hierarchy) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isItemParent(item, parent, (bool)hierarchy);
	}
	TS_CAPI void TS_CCALL tsControlTree_addItemChild(TSControlTree self, uint32_t item, uint32_t child) {
		TS_ASSERT(self);
		((ControlTree*)self)->addItemChild(item, child);
	}
	TS_CAPI void TS_CCALL tsControlTree_removeItemChild(TSControlTree self, uint32_t item, uint32_t child) {
		TS_ASSERT(self);
		((ControlTree*)self)->removeItemChild(item, child);
	}
	TS_CAPI void TS_CCALL tsControlTree_addItemChildren(TSControlTree self, uint32_t item, const uint32_t *children, uint32_t children_size) {
		TS_ASSERT(self);
		Array<uint32_t> children_(children_size, children);
		((ControlTree*)self)->addItemChildren(item, children_);
	}
	TS_CAPI void TS_CCALL tsControlTree_removeItemChildren(TSControlTree self, uint32_t item, const uint32_t *children, uint32_t children_size) {
		TS_ASSERT(self);
		Array<uint32_t> children_(children_size, children);
		((ControlTree*)self)->removeItemChildren(item, children_);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_findItemChild(TSControlTree self, uint32_t item, uint32_t child) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->findItemChild(item, child);
	}
	TS_CAPI bool_t TS_CCALL tsControlTree_isItemChild(TSControlTree self, uint32_t item, uint32_t child) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->isItemChild(item, child);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getNumItemChildren(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getNumItemChildren(item);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getItemChild(TSControlTree self, uint32_t item, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getItemChild(item, index);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemText_us(TSControlTree self, uint32_t item, const char *text) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemText(item, text);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemText_ucS(TSControlTree self, uint32_t item, const TSString text) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemText(item, (text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsControlTree_getItemText(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlTree*)self)->getItemText(item)));
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_findItemText_cs(TSControlTree self, const char *text) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->findItemText(text);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_findItemText_ccS(TSControlTree self, const TSString text) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->findItemText((text) ? *(const String*)text : String::null);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemColor(TSControlTree self, uint32_t item, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlTree*)self)->setItemColor(item, *(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlTree_getItemColor(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		const Color ret = ((ControlTree*)self)->getItemColor(item);
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemTexture(TSControlTree self, uint32_t item, uint32_t row, uint32_t column) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemTexture(item, row, column);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getItemTextureRow(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getItemTextureRow(item);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getItemTextureColumn(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getItemTextureColumn(item);
	}
	TS_CAPI void TS_CCALL tsControlTree_setItemData(TSControlTree self, uint32_t item, void *data) {
		TS_ASSERT(self);
		((ControlTree*)self)->setItemData(item, data);
	}
	TS_CAPI void* TS_CCALL tsControlTree_getItemData(TSControlTree self, uint32_t item) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getItemData(item);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getFocusedItem(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getFocusedItem();
	}
	TS_CAPI void TS_CCALL tsControlTree_setCurrentItem(TSControlTree self, uint32_t item, bool_t select, bool_t view, bool_t callback) {
		TS_ASSERT(self);
		((ControlTree*)self)->setCurrentItem(item, (bool)select, (bool)view, (bool)callback);
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getCurrentItem(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getCurrentItem();
	}
	TS_CAPI TSString TS_CCALL tsControlTree_getCurrentText(TSControlTree self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlTree*)self)->getCurrentText()));
	}
	TS_CAPI void TS_CCALL tsControlTree_setSelection(TSControlTree self) {
		TS_ASSERT(self);
		((ControlTree*)self)->setSelection();
	}
	TS_CAPI void TS_CCALL tsControlTree_clearSelection(TSControlTree self) {
		TS_ASSERT(self);
		((ControlTree*)self)->clearSelection();
	}
	TS_CAPI void TS_CCALL tsControlTree_inverseSelection(TSControlTree self) {
		TS_ASSERT(self);
		((ControlTree*)self)->inverseSelection();
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getNumSelectedItems(TSControlTree self) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getNumSelectedItems();
	}
	TS_CAPI uint32_t TS_CCALL tsControlTree_getSelectedItem(TSControlTree self, uint32_t index) {
		TS_ASSERT(self);
		return ((ControlTree*)self)->getSelectedItem(index);
	}
	TS_CAPI void TS_CCALL tsControlTree_setChangedCallback(TSControlTree self, const TSControlTreeChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setChangedCallback(makeTSControlTreeChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setDraggedCallback(TSControlTree self, const TSControlTreeDraggedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setDraggedCallback(makeTSControlTreeDraggedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setDroppedCallback(TSControlTree self, const TSControlTreeDroppedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setDroppedCallback(makeTSControlTreeDroppedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setClickedCallback(TSControlTree self, const TSControlTreeClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setClickedCallback(makeTSControlTreeClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setClicked2Callback(TSControlTree self, const TSControlTreeClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setClicked2Callback(makeTSControlTreeClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setClickedRightCallback(TSControlTree self, const TSControlTreeClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setClickedRightCallback(makeTSControlTreeClickedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setExpandedCallback(TSControlTree self, const TSControlTreeExpandedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setExpandedCallback(makeTSControlTreeExpandedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsControlTree_setSelectedCallback(TSControlTree self, const TSControlTreeSelectedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlTree*)self)->setSelectedCallback(makeTSControlTreeSelectedCallback(func, data_));
	}
	
	// Tellusim::ControlEdit
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_new(void) {
		ControlEdit *ret = new ControlEdit();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlEdit)ret;
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_new_C(TSControl *parent) {
		ControlEdit *ret = new ControlEdit((parent) ? *(Control**)parent : nullptr);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlEdit)ret;
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_new_Cs(TSControl *parent, const char *text) {
		ControlEdit *ret = new ControlEdit((parent) ? *(Control**)parent : nullptr, text);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlEdit)ret;
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_new_CcS(TSControl *parent, const TSString text) {
		ControlEdit *ret = new ControlEdit((parent) ? *(Control**)parent : nullptr, (text) ? *(const String*)text : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlEdit)ret;
	}
	TS_CAPI void TS_CCALL tsControlEdit_delete(TSControlEdit self) {
		if(self) delete (ControlEdit*)self;
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_equalPtr(const TSControlEdit self, const TSControlEdit ptr) {
		return (self && ptr && ((ControlEdit*)self)->operator==(*(ControlEdit*)ptr));
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_copyPtr(TSControlEdit self) {
		ControlEdit *ret = nullptr;
		if(self) ret = new ControlEdit(*(ControlEdit*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlEdit)ret;
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_clonePtr(const TSControlEdit self) {
		ControlEdit *ret = (self) ? new ControlEdit(((ControlEdit*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSControlEdit)ret;
	}
	TS_CAPI void TS_CCALL tsControlEdit_clearPtr(TSControlEdit self) {
		if(self) ((ControlEdit*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsControlEdit_destroyPtr(TSControlEdit self) {
		if(self) ((ControlEdit*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsControlEdit_acquirePtr(TSControlEdit self) {
		if(self) ((ControlEdit*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsControlEdit_unacquirePtr(TSControlEdit self) {
		if(self) ((ControlEdit*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_isValidPtr(const TSControlEdit self) {
		return (self && ((ControlEdit*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_isOwnerPtr(const TSControlEdit self) {
		return (self && ((ControlEdit*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_isConstPtr(const TSControlEdit self) {
		return (self && ((ControlEdit*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsControlEdit_getCountPtr(const TSControlEdit self) {
		return ((ControlEdit*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsControlEdit_getInternalPtr(const TSControlEdit self) {
		return ((ControlEdit*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_equalControlTextPtr(const TSControlEdit self, const TSControlText base) {
		return (self && base && ((ControlEdit*)self)->operator==(*(ControlText*)base));
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_castControlTextPtr(TSControlText base) {
		return (TSControlEdit)(new ControlEdit(*(ControlText*)base));
	}
	TS_CAPI TSControlText TS_CCALL tsControlEdit_baseControlTextPtr(TSControlEdit self) {
		return (TSControlText)(new ControlText(((ControlEdit*)self)->getControlText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_equalControlPtr(const TSControlEdit self, const TSControl base) {
		return (self && base && ((ControlEdit*)self)->operator==(*(Control*)base));
	}
	TS_CAPI TSControlEdit TS_CCALL tsControlEdit_castControlPtr(TSControl base) {
		return (TSControlEdit)(new ControlEdit(*(Control*)base));
	}
	TS_CAPI TSControl TS_CCALL tsControlEdit_baseControlPtr(TSControlEdit self) {
		return (TSControl)(new Control(((ControlEdit*)self)->getControl()));
	}
	TS_CAPI void TS_CCALL tsControlEdit_setFrame(TSControlEdit self, bool_t frame) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setFrame((bool)frame);
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_getFrame(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getFrame();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setBackground(TSControlEdit self, bool_t background) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setBackground((bool)background);
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_getBackground(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getBackground();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setEditColor(TSControlEdit self, const TSColor *color) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((ControlEdit*)self)->setEditColor(*(const Color*)color);
	}
	TS_CAPI TSColor TS_CCALL tsControlEdit_getEditColor(TSControlEdit self) {
		TS_ASSERT(self);
		const Color ret = ((ControlEdit*)self)->getEditColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsControlEdit_setEditMode(TSControlEdit self, TS_ControlEditEditMode mode) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setEditMode((ControlEdit::EditMode)mode);
	}
	TS_CAPI TS_ControlEditEditMode TS_CCALL tsControlEdit_getEditMode(TSControlEdit self) {
		TS_ASSERT(self);
		return (TS_ControlEditEditMode)((ControlEdit*)self)->getEditMode();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setPasswordCode(TSControlEdit self, uint32_t code) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setPasswordCode(code);
	}
	TS_CAPI uint32_t TS_CCALL tsControlEdit_getPasswordCode(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getPasswordCode();
	}
	TS_CAPI uint32_t TS_CCALL tsControlEdit_getNumCodes(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getNumCodes();
	}
	TS_CAPI const uint32_t* TS_CCALL tsControlEdit_getCodes(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getCodes();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setCurrentIndex(TSControlEdit self, uint32_t index, uint32_t selection_index) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setCurrentIndex(index, selection_index);
	}
	TS_CAPI uint32_t TS_CCALL tsControlEdit_getCurrentIndex(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getCurrentIndex();
	}
	TS_CAPI uint32_t TS_CCALL tsControlEdit_getSelectionIndex(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->getSelectionIndex();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setSelection(TSControlEdit self, bool_t current, bool_t changed) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setSelection((bool)current, (bool)changed);
	}
	TS_CAPI void TS_CCALL tsControlEdit_clearSelection(TSControlEdit self) {
		TS_ASSERT(self);
		((ControlEdit*)self)->clearSelection();
	}
	TS_CAPI TSString TS_CCALL tsControlEdit_getSelectedText(TSControlEdit self) {
		TS_ASSERT(self);
		return (TSString)(new String(((ControlEdit*)self)->getSelectedText()));
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_updateKeyboard(TSControlEdit self, TSControlRoot root, uint32_t key, uint32_t code) {
		TS_ASSERT(self);
		TS_ASSERT(root);
		return ((ControlEdit*)self)->updateKeyboard(*(ControlRoot*)root, key, code);
	}
	TS_CAPI void TS_CCALL tsControlEdit_setClickedCallback(TSControlEdit self, const TSControlEditClickedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setClickedCallback(makeTSControlEditClickedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_isClicked(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->isClicked();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setChangedCallback(TSControlEdit self, const TSControlEditChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setChangedCallback(makeTSControlEditChangedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_isChanged(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->isChanged();
	}
	TS_CAPI void TS_CCALL tsControlEdit_setReturnedCallback(TSControlEdit self, const TSControlEditReturnedCallback func, void *data_) {
		TS_ASSERT(self);
		((ControlEdit*)self)->setReturnedCallback(makeTSControlEditReturnedCallback(func, data_));
	}
	TS_CAPI bool_t TS_CCALL tsControlEdit_isReturned(TSControlEdit self) {
		TS_ASSERT(self);
		return ((ControlEdit*)self)->isReturned();
	}
	TS_CAPI TSCanvasMesh TS_CCALL tsControlEdit_getCanvasMesh(TSControlEdit self) {
		TS_ASSERT(self);
		return (TSCanvasMesh)(new CanvasMesh(((ControlEdit*)self)->getCanvasMesh()));
	}
	
	// Tellusim::DialogMessage
	TS_CAPI TSDialogMessage TS_CCALL tsDialogMessage_new_ss(const char *title, const char *message) {
		DialogMessage *ret = new DialogMessage(title, message);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMessage)ret;
	}
	TS_CAPI TSDialogMessage TS_CCALL tsDialogMessage_new_cSs(const TSString title, const char *message) {
		DialogMessage *ret = new DialogMessage((title) ? *(const String*)title : String::null, message);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMessage)ret;
	}
	TS_CAPI TSDialogMessage TS_CCALL tsDialogMessage_new_scS(const char *title, const TSString message) {
		DialogMessage *ret = new DialogMessage(title, (message) ? *(const String*)message : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMessage)ret;
	}
	TS_CAPI TSDialogMessage TS_CCALL tsDialogMessage_new_cScS(const TSString title, const TSString message) {
		DialogMessage *ret = new DialogMessage((title) ? *(const String*)title : String::null, (message) ? *(const String*)message : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMessage)ret;
	}
	TS_CAPI void TS_CCALL tsDialogMessage_delete(TSDialogMessage self) {
		if(self) delete (DialogMessage*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogMessage_equalPtr(const TSDialogMessage self, const TSDialogMessage ptr) {
		return (self && ptr && ((DialogMessage*)self)->operator==(*(DialogMessage*)ptr));
	}
	TS_CAPI TSDialogMessage TS_CCALL tsDialogMessage_copyPtr(TSDialogMessage self) {
		DialogMessage *ret = nullptr;
		if(self) ret = new DialogMessage(*(DialogMessage*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMessage)ret;
	}
	TS_CAPI TSDialogMessage TS_CCALL tsDialogMessage_clonePtr(const TSDialogMessage self) {
		DialogMessage *ret = (self) ? new DialogMessage(((DialogMessage*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMessage)ret;
	}
	TS_CAPI void TS_CCALL tsDialogMessage_clearPtr(TSDialogMessage self) {
		if(self) ((DialogMessage*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogMessage_destroyPtr(TSDialogMessage self) {
		if(self) ((DialogMessage*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogMessage_acquirePtr(TSDialogMessage self) {
		if(self) ((DialogMessage*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogMessage_unacquirePtr(TSDialogMessage self) {
		if(self) ((DialogMessage*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogMessage_isValidPtr(const TSDialogMessage self) {
		return (self && ((DialogMessage*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogMessage_isOwnerPtr(const TSDialogMessage self) {
		return (self && ((DialogMessage*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogMessage_isConstPtr(const TSDialogMessage self) {
		return (self && ((DialogMessage*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMessage_getCountPtr(const TSDialogMessage self) {
		return ((DialogMessage*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogMessage_getInternalPtr(const TSDialogMessage self) {
		return ((DialogMessage*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogMessage_setPosition(TSDialogMessage self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogMessage*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogMessage_getPositionX(TSDialogMessage self) {
		TS_ASSERT(self);
		return ((DialogMessage*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogMessage_getPositionY(TSDialogMessage self) {
		TS_ASSERT(self);
		return ((DialogMessage*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsDialogMessage_setTitle_s(TSDialogMessage self, const char *title) {
		TS_ASSERT(self);
		((DialogMessage*)self)->setTitle(title);
	}
	TS_CAPI void TS_CCALL tsDialogMessage_setTitle_cS(TSDialogMessage self, const TSString title) {
		TS_ASSERT(self);
		((DialogMessage*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogMessage_getTitle(TSDialogMessage self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogMessage*)self)->getTitle()));
	}
	TS_CAPI void TS_CCALL tsDialogMessage_setMessage_s(TSDialogMessage self, const char *message) {
		TS_ASSERT(self);
		((DialogMessage*)self)->setMessage(message);
	}
	TS_CAPI void TS_CCALL tsDialogMessage_setMessage_cS(TSDialogMessage self, const TSString message) {
		TS_ASSERT(self);
		((DialogMessage*)self)->setMessage((message) ? *(const String*)message : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogMessage_getMessage(TSDialogMessage self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogMessage*)self)->getMessage()));
	}
	TS_CAPI void TS_CCALL tsDialogMessage_setUpdateCallback(TSDialogMessage self, const TSDialogMessageUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogMessage*)self)->setUpdateCallback(makeTSDialogMessageUpdateCallback(func, data_));
	}
	TS_CAPI TS_DialogMessageResult TS_CCALL tsDialogMessage_run(TSDialogMessage self, TS_DialogMessageFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogMessageResult)((DialogMessage*)self)->run((DialogMessage::Flags)flags);
	}
	
	// Tellusim::DialogFileOpen
	TS_CAPI TSDialogFileOpen TS_CCALL tsDialogFileOpen_new_ss(const char *title, const char *name) {
		DialogFileOpen *ret = new DialogFileOpen(title, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileOpen)ret;
	}
	TS_CAPI TSDialogFileOpen TS_CCALL tsDialogFileOpen_new_cSs(const TSString title, const char *name) {
		DialogFileOpen *ret = new DialogFileOpen((title) ? *(const String*)title : String::null, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileOpen)ret;
	}
	TS_CAPI TSDialogFileOpen TS_CCALL tsDialogFileOpen_new_scS(const char *title, const TSString name) {
		DialogFileOpen *ret = new DialogFileOpen(title, (name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileOpen)ret;
	}
	TS_CAPI TSDialogFileOpen TS_CCALL tsDialogFileOpen_new_cScS(const TSString title, const TSString name) {
		DialogFileOpen *ret = new DialogFileOpen((title) ? *(const String*)title : String::null, (name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileOpen)ret;
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_delete(TSDialogFileOpen self) {
		if(self) delete (DialogFileOpen*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileOpen_equalPtr(const TSDialogFileOpen self, const TSDialogFileOpen ptr) {
		return (self && ptr && ((DialogFileOpen*)self)->operator==(*(DialogFileOpen*)ptr));
	}
	TS_CAPI TSDialogFileOpen TS_CCALL tsDialogFileOpen_copyPtr(TSDialogFileOpen self) {
		DialogFileOpen *ret = nullptr;
		if(self) ret = new DialogFileOpen(*(DialogFileOpen*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileOpen)ret;
	}
	TS_CAPI TSDialogFileOpen TS_CCALL tsDialogFileOpen_clonePtr(const TSDialogFileOpen self) {
		DialogFileOpen *ret = (self) ? new DialogFileOpen(((DialogFileOpen*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileOpen)ret;
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_clearPtr(TSDialogFileOpen self) {
		if(self) ((DialogFileOpen*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_destroyPtr(TSDialogFileOpen self) {
		if(self) ((DialogFileOpen*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_acquirePtr(TSDialogFileOpen self) {
		if(self) ((DialogFileOpen*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_unacquirePtr(TSDialogFileOpen self) {
		if(self) ((DialogFileOpen*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileOpen_isValidPtr(const TSDialogFileOpen self) {
		return (self && ((DialogFileOpen*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileOpen_isOwnerPtr(const TSDialogFileOpen self) {
		return (self && ((DialogFileOpen*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileOpen_isConstPtr(const TSDialogFileOpen self) {
		return (self && ((DialogFileOpen*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogFileOpen_getCountPtr(const TSDialogFileOpen self) {
		return ((DialogFileOpen*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogFileOpen_getInternalPtr(const TSDialogFileOpen self) {
		return ((DialogFileOpen*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setPosition(TSDialogFileOpen self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogFileOpen_getPositionX(TSDialogFileOpen self) {
		TS_ASSERT(self);
		return ((DialogFileOpen*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogFileOpen_getPositionY(TSDialogFileOpen self) {
		TS_ASSERT(self);
		return ((DialogFileOpen*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setTitle_s(TSDialogFileOpen self, const char *title) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setTitle(title);
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setTitle_cS(TSDialogFileOpen self, const TSString title) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogFileOpen_getTitle(TSDialogFileOpen self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogFileOpen*)self)->getTitle()));
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setFilter_s(TSDialogFileOpen self, const char *filter) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setFilter(filter);
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setFilter_cS(TSDialogFileOpen self, const TSString filter) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setFilter((filter) ? *(const String*)filter : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogFileOpen_getFilter(TSDialogFileOpen self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogFileOpen*)self)->getFilter()));
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setFile_s(TSDialogFileOpen self, const char *name) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setFile(name);
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setFile_cS(TSDialogFileOpen self, const TSString name) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogFileOpen_getFile(TSDialogFileOpen self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogFileOpen*)self)->getFile()));
	}
	TS_CAPI void TS_CCALL tsDialogFileOpen_setUpdateCallback(TSDialogFileOpen self, const TSDialogFileOpenUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogFileOpen*)self)->setUpdateCallback(makeTSDialogFileOpenUpdateCallback(func, data_));
	}
	TS_CAPI TS_DialogFileOpenResult TS_CCALL tsDialogFileOpen_run(TSDialogFileOpen self, TS_DialogFileOpenFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogFileOpenResult)((DialogFileOpen*)self)->run((DialogFileOpen::Flags)flags);
	}
	
	// Tellusim::DialogFileSave
	TS_CAPI TSDialogFileSave TS_CCALL tsDialogFileSave_new_ss(const char *title, const char *name) {
		DialogFileSave *ret = new DialogFileSave(title, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileSave)ret;
	}
	TS_CAPI TSDialogFileSave TS_CCALL tsDialogFileSave_new_cSs(const TSString title, const char *name) {
		DialogFileSave *ret = new DialogFileSave((title) ? *(const String*)title : String::null, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileSave)ret;
	}
	TS_CAPI TSDialogFileSave TS_CCALL tsDialogFileSave_new_scS(const char *title, const TSString name) {
		DialogFileSave *ret = new DialogFileSave(title, (name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileSave)ret;
	}
	TS_CAPI TSDialogFileSave TS_CCALL tsDialogFileSave_new_cScS(const TSString title, const TSString name) {
		DialogFileSave *ret = new DialogFileSave((title) ? *(const String*)title : String::null, (name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileSave)ret;
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_delete(TSDialogFileSave self) {
		if(self) delete (DialogFileSave*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileSave_equalPtr(const TSDialogFileSave self, const TSDialogFileSave ptr) {
		return (self && ptr && ((DialogFileSave*)self)->operator==(*(DialogFileSave*)ptr));
	}
	TS_CAPI TSDialogFileSave TS_CCALL tsDialogFileSave_copyPtr(TSDialogFileSave self) {
		DialogFileSave *ret = nullptr;
		if(self) ret = new DialogFileSave(*(DialogFileSave*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileSave)ret;
	}
	TS_CAPI TSDialogFileSave TS_CCALL tsDialogFileSave_clonePtr(const TSDialogFileSave self) {
		DialogFileSave *ret = (self) ? new DialogFileSave(((DialogFileSave*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogFileSave)ret;
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_clearPtr(TSDialogFileSave self) {
		if(self) ((DialogFileSave*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_destroyPtr(TSDialogFileSave self) {
		if(self) ((DialogFileSave*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_acquirePtr(TSDialogFileSave self) {
		if(self) ((DialogFileSave*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_unacquirePtr(TSDialogFileSave self) {
		if(self) ((DialogFileSave*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileSave_isValidPtr(const TSDialogFileSave self) {
		return (self && ((DialogFileSave*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileSave_isOwnerPtr(const TSDialogFileSave self) {
		return (self && ((DialogFileSave*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogFileSave_isConstPtr(const TSDialogFileSave self) {
		return (self && ((DialogFileSave*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogFileSave_getCountPtr(const TSDialogFileSave self) {
		return ((DialogFileSave*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogFileSave_getInternalPtr(const TSDialogFileSave self) {
		return ((DialogFileSave*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setPosition(TSDialogFileSave self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogFileSave_getPositionX(TSDialogFileSave self) {
		TS_ASSERT(self);
		return ((DialogFileSave*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogFileSave_getPositionY(TSDialogFileSave self) {
		TS_ASSERT(self);
		return ((DialogFileSave*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setTitle_s(TSDialogFileSave self, const char *title) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setTitle(title);
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setTitle_cS(TSDialogFileSave self, const TSString title) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogFileSave_getTitle(TSDialogFileSave self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogFileSave*)self)->getTitle()));
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setFilter_s(TSDialogFileSave self, const char *filter) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setFilter(filter);
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setFilter_cS(TSDialogFileSave self, const TSString filter) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setFilter((filter) ? *(const String*)filter : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogFileSave_getFilter(TSDialogFileSave self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogFileSave*)self)->getFilter()));
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setFile_s(TSDialogFileSave self, const char *name) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setFile(name);
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setFile_cS(TSDialogFileSave self, const TSString name) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setFile((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogFileSave_getFile(TSDialogFileSave self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogFileSave*)self)->getFile()));
	}
	TS_CAPI void TS_CCALL tsDialogFileSave_setUpdateCallback(TSDialogFileSave self, const TSDialogFileSaveUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogFileSave*)self)->setUpdateCallback(makeTSDialogFileSaveUpdateCallback(func, data_));
	}
	TS_CAPI TS_DialogFileSaveResult TS_CCALL tsDialogFileSave_run(TSDialogFileSave self, TS_DialogFileSaveFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogFileSaveResult)((DialogFileSave*)self)->run((DialogFileSave::Flags)flags);
	}
	
	// Tellusim::DialogDirectory
	TS_CAPI TSDialogDirectory TS_CCALL tsDialogDirectory_new_ss(const char *title, const char *name) {
		DialogDirectory *ret = new DialogDirectory(title, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogDirectory)ret;
	}
	TS_CAPI TSDialogDirectory TS_CCALL tsDialogDirectory_new_cSs(const TSString title, const char *name) {
		DialogDirectory *ret = new DialogDirectory((title) ? *(const String*)title : String::null, name);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogDirectory)ret;
	}
	TS_CAPI TSDialogDirectory TS_CCALL tsDialogDirectory_new_scS(const char *title, const TSString name) {
		DialogDirectory *ret = new DialogDirectory(title, (name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogDirectory)ret;
	}
	TS_CAPI TSDialogDirectory TS_CCALL tsDialogDirectory_new_cScS(const TSString title, const TSString name) {
		DialogDirectory *ret = new DialogDirectory((title) ? *(const String*)title : String::null, (name) ? *(const String*)name : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogDirectory)ret;
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_delete(TSDialogDirectory self) {
		if(self) delete (DialogDirectory*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogDirectory_equalPtr(const TSDialogDirectory self, const TSDialogDirectory ptr) {
		return (self && ptr && ((DialogDirectory*)self)->operator==(*(DialogDirectory*)ptr));
	}
	TS_CAPI TSDialogDirectory TS_CCALL tsDialogDirectory_copyPtr(TSDialogDirectory self) {
		DialogDirectory *ret = nullptr;
		if(self) ret = new DialogDirectory(*(DialogDirectory*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogDirectory)ret;
	}
	TS_CAPI TSDialogDirectory TS_CCALL tsDialogDirectory_clonePtr(const TSDialogDirectory self) {
		DialogDirectory *ret = (self) ? new DialogDirectory(((DialogDirectory*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogDirectory)ret;
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_clearPtr(TSDialogDirectory self) {
		if(self) ((DialogDirectory*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_destroyPtr(TSDialogDirectory self) {
		if(self) ((DialogDirectory*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_acquirePtr(TSDialogDirectory self) {
		if(self) ((DialogDirectory*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_unacquirePtr(TSDialogDirectory self) {
		if(self) ((DialogDirectory*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogDirectory_isValidPtr(const TSDialogDirectory self) {
		return (self && ((DialogDirectory*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogDirectory_isOwnerPtr(const TSDialogDirectory self) {
		return (self && ((DialogDirectory*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogDirectory_isConstPtr(const TSDialogDirectory self) {
		return (self && ((DialogDirectory*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogDirectory_getCountPtr(const TSDialogDirectory self) {
		return ((DialogDirectory*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogDirectory_getInternalPtr(const TSDialogDirectory self) {
		return ((DialogDirectory*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_setPosition(TSDialogDirectory self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogDirectory*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogDirectory_getPositionX(TSDialogDirectory self) {
		TS_ASSERT(self);
		return ((DialogDirectory*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogDirectory_getPositionY(TSDialogDirectory self) {
		TS_ASSERT(self);
		return ((DialogDirectory*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_setTitle_s(TSDialogDirectory self, const char *title) {
		TS_ASSERT(self);
		((DialogDirectory*)self)->setTitle(title);
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_setTitle_cS(TSDialogDirectory self, const TSString title) {
		TS_ASSERT(self);
		((DialogDirectory*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogDirectory_getTitle(TSDialogDirectory self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogDirectory*)self)->getTitle()));
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_setDirectory_s(TSDialogDirectory self, const char *name) {
		TS_ASSERT(self);
		((DialogDirectory*)self)->setDirectory(name);
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_setDirectory_cS(TSDialogDirectory self, const TSString name) {
		TS_ASSERT(self);
		((DialogDirectory*)self)->setDirectory((name) ? *(const String*)name : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogDirectory_getDirectory(TSDialogDirectory self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogDirectory*)self)->getDirectory()));
	}
	TS_CAPI void TS_CCALL tsDialogDirectory_setUpdateCallback(TSDialogDirectory self, const TSDialogDirectoryUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogDirectory*)self)->setUpdateCallback(makeTSDialogDirectoryUpdateCallback(func, data_));
	}
	TS_CAPI TS_DialogDirectoryResult TS_CCALL tsDialogDirectory_run(TSDialogDirectory self, TS_DialogDirectoryFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogDirectoryResult)((DialogDirectory*)self)->run((DialogDirectory::Flags)flags);
	}
	
	// Tellusim::DialogProgress
	TS_CAPI TSDialogProgress TS_CCALL tsDialogProgress_new_ss(const char *title, const char *message) {
		DialogProgress *ret = new DialogProgress(title, message);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogProgress)ret;
	}
	TS_CAPI TSDialogProgress TS_CCALL tsDialogProgress_new_cSs(const TSString title, const char *message) {
		DialogProgress *ret = new DialogProgress((title) ? *(const String*)title : String::null, message);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogProgress)ret;
	}
	TS_CAPI TSDialogProgress TS_CCALL tsDialogProgress_new_scS(const char *title, const TSString message) {
		DialogProgress *ret = new DialogProgress(title, (message) ? *(const String*)message : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogProgress)ret;
	}
	TS_CAPI TSDialogProgress TS_CCALL tsDialogProgress_new_cScS(const TSString title, const TSString message) {
		DialogProgress *ret = new DialogProgress((title) ? *(const String*)title : String::null, (message) ? *(const String*)message : String::null);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogProgress)ret;
	}
	TS_CAPI void TS_CCALL tsDialogProgress_delete(TSDialogProgress self) {
		if(self) delete (DialogProgress*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogProgress_equalPtr(const TSDialogProgress self, const TSDialogProgress ptr) {
		return (self && ptr && ((DialogProgress*)self)->operator==(*(DialogProgress*)ptr));
	}
	TS_CAPI TSDialogProgress TS_CCALL tsDialogProgress_copyPtr(TSDialogProgress self) {
		DialogProgress *ret = nullptr;
		if(self) ret = new DialogProgress(*(DialogProgress*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogProgress)ret;
	}
	TS_CAPI TSDialogProgress TS_CCALL tsDialogProgress_clonePtr(const TSDialogProgress self) {
		DialogProgress *ret = (self) ? new DialogProgress(((DialogProgress*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogProgress)ret;
	}
	TS_CAPI void TS_CCALL tsDialogProgress_clearPtr(TSDialogProgress self) {
		if(self) ((DialogProgress*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogProgress_destroyPtr(TSDialogProgress self) {
		if(self) ((DialogProgress*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogProgress_acquirePtr(TSDialogProgress self) {
		if(self) ((DialogProgress*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogProgress_unacquirePtr(TSDialogProgress self) {
		if(self) ((DialogProgress*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogProgress_isValidPtr(const TSDialogProgress self) {
		return (self && ((DialogProgress*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogProgress_isOwnerPtr(const TSDialogProgress self) {
		return (self && ((DialogProgress*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogProgress_isConstPtr(const TSDialogProgress self) {
		return (self && ((DialogProgress*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogProgress_getCountPtr(const TSDialogProgress self) {
		return ((DialogProgress*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogProgress_getInternalPtr(const TSDialogProgress self) {
		return ((DialogProgress*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogProgress_setPosition(TSDialogProgress self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogProgress*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogProgress_getPositionX(TSDialogProgress self) {
		TS_ASSERT(self);
		return ((DialogProgress*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogProgress_getPositionY(TSDialogProgress self) {
		TS_ASSERT(self);
		return ((DialogProgress*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsDialogProgress_setTitle_s(TSDialogProgress self, const char *title) {
		TS_ASSERT(self);
		((DialogProgress*)self)->setTitle(title);
	}
	TS_CAPI void TS_CCALL tsDialogProgress_setTitle_cS(TSDialogProgress self, const TSString title) {
		TS_ASSERT(self);
		((DialogProgress*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogProgress_getTitle(TSDialogProgress self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogProgress*)self)->getTitle()));
	}
	TS_CAPI void TS_CCALL tsDialogProgress_setMessage_s(TSDialogProgress self, const char *message) {
		TS_ASSERT(self);
		((DialogProgress*)self)->setMessage(message);
	}
	TS_CAPI void TS_CCALL tsDialogProgress_setMessage_cS(TSDialogProgress self, const TSString message) {
		TS_ASSERT(self);
		((DialogProgress*)self)->setMessage((message) ? *(const String*)message : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogProgress_getMessage(TSDialogProgress self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogProgress*)self)->getMessage()));
	}
	TS_CAPI void TS_CCALL tsDialogProgress_setProgress(TSDialogProgress self, uint32_t progress) {
		TS_ASSERT(self);
		((DialogProgress*)self)->setProgress(progress);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogProgress_getProgress(TSDialogProgress self) {
		TS_ASSERT(self);
		return ((DialogProgress*)self)->getProgress();
	}
	TS_CAPI TS_DialogProgressResult TS_CCALL tsDialogProgress_run(TSDialogProgress self, TS_DialogProgressFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogProgressResult)((DialogProgress*)self)->run((DialogProgress::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsDialogProgress_close(TSDialogProgress self) {
		TS_ASSERT(self);
		((DialogProgress*)self)->close();
	}
	
	// Tellusim::DialogColor
	TS_CAPI TSDialogColor TS_CCALL tsDialogColor_new_scC(const char *title, const TSColor *color) {
		TS_ASSERT(color);
		DialogColor *ret = new DialogColor(title, *(const Color*)color);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogColor)ret;
	}
	TS_CAPI TSDialogColor TS_CCALL tsDialogColor_new_cScC(const TSString title, const TSColor *color) {
		TS_ASSERT(color);
		DialogColor *ret = new DialogColor((title) ? *(const String*)title : String::null, *(const Color*)color);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogColor)ret;
	}
	TS_CAPI void TS_CCALL tsDialogColor_delete(TSDialogColor self) {
		if(self) delete (DialogColor*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogColor_equalPtr(const TSDialogColor self, const TSDialogColor ptr) {
		return (self && ptr && ((DialogColor*)self)->operator==(*(DialogColor*)ptr));
	}
	TS_CAPI TSDialogColor TS_CCALL tsDialogColor_copyPtr(TSDialogColor self) {
		DialogColor *ret = nullptr;
		if(self) ret = new DialogColor(*(DialogColor*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogColor)ret;
	}
	TS_CAPI TSDialogColor TS_CCALL tsDialogColor_clonePtr(const TSDialogColor self) {
		DialogColor *ret = (self) ? new DialogColor(((DialogColor*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogColor)ret;
	}
	TS_CAPI void TS_CCALL tsDialogColor_clearPtr(TSDialogColor self) {
		if(self) ((DialogColor*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogColor_destroyPtr(TSDialogColor self) {
		if(self) ((DialogColor*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogColor_acquirePtr(TSDialogColor self) {
		if(self) ((DialogColor*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogColor_unacquirePtr(TSDialogColor self) {
		if(self) ((DialogColor*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogColor_isValidPtr(const TSDialogColor self) {
		return (self && ((DialogColor*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogColor_isOwnerPtr(const TSDialogColor self) {
		return (self && ((DialogColor*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogColor_isConstPtr(const TSDialogColor self) {
		return (self && ((DialogColor*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogColor_getCountPtr(const TSDialogColor self) {
		return ((DialogColor*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogColor_getInternalPtr(const TSDialogColor self) {
		return ((DialogColor*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogColor_setPosition(TSDialogColor self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogColor*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogColor_getPositionX(TSDialogColor self) {
		TS_ASSERT(self);
		return ((DialogColor*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogColor_getPositionY(TSDialogColor self) {
		TS_ASSERT(self);
		return ((DialogColor*)self)->getPositionY();
	}
	TS_CAPI void TS_CCALL tsDialogColor_setTitle_s(TSDialogColor self, const char *title) {
		TS_ASSERT(self);
		((DialogColor*)self)->setTitle(title);
	}
	TS_CAPI void TS_CCALL tsDialogColor_setTitle_cS(TSDialogColor self, const TSString title) {
		TS_ASSERT(self);
		((DialogColor*)self)->setTitle((title) ? *(const String*)title : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogColor_getTitle(TSDialogColor self) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogColor*)self)->getTitle()));
	}
	TS_CAPI void TS_CCALL tsDialogColor_setColor(TSDialogColor self, const TSColor *color, bool_t callback) {
		TS_ASSERT(self);
		TS_ASSERT(color);
		((DialogColor*)self)->setColor(*(const Color*)color, (bool)callback);
	}
	TS_CAPI TSColor TS_CCALL tsDialogColor_getColor(TSDialogColor self) {
		TS_ASSERT(self);
		const Color ret = ((DialogColor*)self)->getColor();
		return *(TSColor*)&ret;
	}
	TS_CAPI void TS_CCALL tsDialogColor_setChangedCallback(TSDialogColor self, const TSDialogColorChangedCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogColor*)self)->setChangedCallback(makeTSDialogColorChangedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsDialogColor_setUpdateCallback(TSDialogColor self, const TSDialogColorUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogColor*)self)->setUpdateCallback(makeTSDialogColorUpdateCallback(func, data_));
	}
	TS_CAPI TS_DialogColorResult TS_CCALL tsDialogColor_run(TSDialogColor self, TS_DialogColorFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogColorResult)((DialogColor*)self)->run((DialogColor::Flags)flags);
	}
	
	// Tellusim::DialogMenu
	TS_CAPI TSDialogMenu TS_CCALL tsDialogMenu_new(void) {
		DialogMenu *ret = new DialogMenu();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMenu)ret;
	}
	TS_CAPI void TS_CCALL tsDialogMenu_delete(TSDialogMenu self) {
		if(self) delete (DialogMenu*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_equalPtr(const TSDialogMenu self, const TSDialogMenu ptr) {
		return (self && ptr && ((DialogMenu*)self)->operator==(*(DialogMenu*)ptr));
	}
	TS_CAPI TSDialogMenu TS_CCALL tsDialogMenu_copyPtr(TSDialogMenu self) {
		DialogMenu *ret = nullptr;
		if(self) ret = new DialogMenu(*(DialogMenu*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMenu)ret;
	}
	TS_CAPI TSDialogMenu TS_CCALL tsDialogMenu_clonePtr(const TSDialogMenu self) {
		DialogMenu *ret = (self) ? new DialogMenu(((DialogMenu*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDialogMenu)ret;
	}
	TS_CAPI void TS_CCALL tsDialogMenu_clearPtr(TSDialogMenu self) {
		if(self) ((DialogMenu*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDialogMenu_destroyPtr(TSDialogMenu self) {
		if(self) ((DialogMenu*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDialogMenu_acquirePtr(TSDialogMenu self) {
		if(self) ((DialogMenu*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDialogMenu_unacquirePtr(TSDialogMenu self) {
		if(self) ((DialogMenu*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_isValidPtr(const TSDialogMenu self) {
		return (self && ((DialogMenu*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_isOwnerPtr(const TSDialogMenu self) {
		return (self && ((DialogMenu*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_isConstPtr(const TSDialogMenu self) {
		return (self && ((DialogMenu*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_getCountPtr(const TSDialogMenu self) {
		return ((DialogMenu*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDialogMenu_getInternalPtr(const TSDialogMenu self) {
		return ((DialogMenu*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setPosition(TSDialogMenu self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setPosition(x, y);
	}
	TS_CAPI int32_t TS_CCALL tsDialogMenu_getPositionX(TSDialogMenu self) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDialogMenu_getPositionY(TSDialogMenu self) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->getPositionY();
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_getNumItems(TSDialogMenu self) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->getNumItems();
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemText_us(TSDialogMenu self, uint32_t index, const char *text) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemText(index, text);
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemText_ucS(TSDialogMenu self, uint32_t index, const TSString text) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemText(index, (text) ? *(const String*)text : String::null);
	}
	TS_CAPI TSString TS_CCALL tsDialogMenu_getItemText(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogMenu*)self)->getItemText(index)));
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemKey(TSDialogMenu self, uint32_t index, const char *key) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemKey(index, key);
	}
	TS_CAPI TSString TS_CCALL tsDialogMenu_getItemKey(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((DialogMenu*)self)->getItemKey(index)));
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemImage(TSDialogMenu self, uint32_t index, const TSImage image) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		((DialogMenu*)self)->setItemImage(index, *(const Image*)image);
	}
	TS_CAPI TSImage TS_CCALL tsDialogMenu_getItemImage(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return (TSImage)(new Image(((DialogMenu*)self)->getItemImage(index)));
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemChecked(TSDialogMenu self, uint32_t index, bool_t checked, bool_t callback) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemChecked(index, (bool)checked, (bool)callback);
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_isItemChecked(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->isItemChecked(index);
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemEnabled(TSDialogMenu self, uint32_t index, bool_t enabled) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemEnabled(index, (bool)enabled);
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_isItemEnabled(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->isItemEnabled(index);
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemHidden(TSDialogMenu self, uint32_t index, bool_t hidden) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemHidden(index, (bool)hidden);
	}
	TS_CAPI bool_t TS_CCALL tsDialogMenu_isItemHidden(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->isItemHidden(index);
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setItemsGroup(TSDialogMenu self, uint32_t index, uint32_t size) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setItemsGroup(index, size);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_getItemGroupIndex(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->getItemGroupIndex(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_getItemGroupSize(TSDialogMenu self, uint32_t index) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->getItemGroupSize(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_ss(TSDialogMenu self, const char *text, const char *key) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->addItem(text, key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_cSs(TSDialogMenu self, const TSString text, const char *key) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->addItem((text) ? *(const String*)text : String::null, key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_scIs(TSDialogMenu self, const char *text, const TSImage image, const char *key) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((DialogMenu*)self)->addItem(text, *(const Image*)image, key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_cScIs(TSDialogMenu self, const TSString text, const TSImage image, const char *key) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((DialogMenu*)self)->addItem((text) ? *(const String*)text : String::null, *(const Image*)image, key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_scDMCCs(TSDialogMenu self, const char *text, const TSDialogMenuClickedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->addItem(text, makeTSDialogMenuClickedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_cScDMCCs(TSDialogMenu self, const TSString text, const TSDialogMenuClickedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->addItem((text) ? *(const String*)text : String::null, makeTSDialogMenuClickedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_scIcDMCCs(TSDialogMenu self, const char *text, const TSImage image, const TSDialogMenuClickedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((DialogMenu*)self)->addItem(text, *(const Image*)image, makeTSDialogMenuClickedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_cScIcDMCCs(TSDialogMenu self, const TSString text, const TSImage image, const TSDialogMenuClickedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((DialogMenu*)self)->addItem((text) ? *(const String*)text : String::null, *(const Image*)image, makeTSDialogMenuClickedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_sbcDMCCs(TSDialogMenu self, const char *text, bool_t checked, const TSDialogMenuChangedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->addItem(text, (bool)checked, makeTSDialogMenuChangedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_cSbcDMCCs(TSDialogMenu self, const TSString text, bool_t checked, const TSDialogMenuChangedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		return ((DialogMenu*)self)->addItem((text) ? *(const String*)text : String::null, (bool)checked, makeTSDialogMenuChangedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_scIbcDMCCs(TSDialogMenu self, const char *text, const TSImage image, bool_t checked, const TSDialogMenuChangedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((DialogMenu*)self)->addItem(text, *(const Image*)image, (bool)checked, makeTSDialogMenuChangedCallback(func, data_), key);
	}
	TS_CAPI uint32_t TS_CCALL tsDialogMenu_addItem_cScIbcDMCCs(TSDialogMenu self, const TSString text, const TSImage image, bool_t checked, const TSDialogMenuChangedCallback func, const char *key, void *data_) {
		TS_ASSERT(self);
		TS_ASSERT(image);
		return ((DialogMenu*)self)->addItem((text) ? *(const String*)text : String::null, *(const Image*)image, (bool)checked, makeTSDialogMenuChangedCallback(func, data_), key);
	}
	TS_CAPI void TS_CCALL tsDialogMenu_setUpdateCallback(TSDialogMenu self, const TSDialogMenuUpdateCallback func, void *data_) {
		TS_ASSERT(self);
		((DialogMenu*)self)->setUpdateCallback(makeTSDialogMenuUpdateCallback(func, data_));
	}
	TS_CAPI TS_DialogMenuResult TS_CCALL tsDialogMenu_run(TSDialogMenu self, TS_DialogMenuFlags flags) {
		TS_ASSERT(self);
		return (TS_DialogMenuResult)((DialogMenu*)self)->run((DialogMenu::Flags)flags);
	}
	
	// Tellusim::CubeFilter
	TS_CAPI TSCubeFilter TS_CCALL tsCubeFilter_new(void) {
		CubeFilter *ret = new CubeFilter();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCubeFilter)ret;
	}
	TS_CAPI void TS_CCALL tsCubeFilter_delete(TSCubeFilter self) {
		if(self) delete (CubeFilter*)self;
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_equalPtr(const TSCubeFilter self, const TSCubeFilter ptr) {
		return (self && ptr && ((CubeFilter*)self)->operator==(*(CubeFilter*)ptr));
	}
	TS_CAPI TSCubeFilter TS_CCALL tsCubeFilter_copyPtr(TSCubeFilter self) {
		CubeFilter *ret = nullptr;
		if(self) ret = new CubeFilter(*(CubeFilter*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCubeFilter)ret;
	}
	TS_CAPI TSCubeFilter TS_CCALL tsCubeFilter_clonePtr(const TSCubeFilter self) {
		CubeFilter *ret = (self) ? new CubeFilter(((CubeFilter*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSCubeFilter)ret;
	}
	TS_CAPI void TS_CCALL tsCubeFilter_clearPtr(TSCubeFilter self) {
		if(self) ((CubeFilter*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsCubeFilter_destroyPtr(TSCubeFilter self) {
		if(self) ((CubeFilter*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsCubeFilter_acquirePtr(TSCubeFilter self) {
		if(self) ((CubeFilter*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsCubeFilter_unacquirePtr(TSCubeFilter self) {
		if(self) ((CubeFilter*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_isValidPtr(const TSCubeFilter self) {
		return (self && ((CubeFilter*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_isOwnerPtr(const TSCubeFilter self) {
		return (self && ((CubeFilter*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_isConstPtr(const TSCubeFilter self) {
		return (self && ((CubeFilter*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsCubeFilter_getCountPtr(const TSCubeFilter self) {
		return ((CubeFilter*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsCubeFilter_getInternalPtr(const TSCubeFilter self) {
		return ((CubeFilter*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsCubeFilter_clear(TSCubeFilter self) {
		TS_ASSERT(self);
		((CubeFilter*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_isCreated(TSCubeFilter self, TS_CubeFilterMode mode) {
		TS_ASSERT(self);
		return ((CubeFilter*)self)->isCreated((CubeFilter::Mode)mode);
	}
	TS_CAPI uint32_t TS_CCALL tsCubeFilter_getGroupSize(TSCubeFilter self) {
		TS_ASSERT(self);
		return ((CubeFilter*)self)->getGroupSize();
	}
	TS_CAPI uint32_t TS_CCALL tsCubeFilter_getMaxOrder(TSCubeFilter self) {
		TS_ASSERT(self);
		return ((CubeFilter*)self)->getMaxOrder();
	}
	TS_CAPI uint32_t TS_CCALL tsCubeFilter_getMaxSize(TSCubeFilter self) {
		TS_ASSERT(self);
		return ((CubeFilter*)self)->getMaxSize();
	}
	TS_CAPI uint32_t TS_CCALL tsCubeFilter_getHarmonics(TSCubeFilter self) {
		TS_ASSERT(self);
		return ((CubeFilter*)self)->getHarmonics();
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_create_cDCFMuuu(TSCubeFilter self, const TSDevice device, TS_CubeFilterMode mode, uint32_t order, uint32_t size, uint32_t groups) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((CubeFilter*)self)->create(*(const Device*)device, (CubeFilter::Mode)mode, order, size, groups);
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_create_cDCFFuuu(TSCubeFilter self, const TSDevice device, TS_CubeFilterFlags flags, uint32_t order, uint32_t size, uint32_t groups) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((CubeFilter*)self)->create(*(const Device*)device, (CubeFilter::Flags)flags, order, size, groups);
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_dispatch_cCBuTcS(TSCubeFilter self, TSCompute compute, TSBuffer buffer, uint32_t offset, TSTexture texture, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(buffer);
		TS_ASSERT(texture);
		return ((CubeFilter*)self)->dispatch(*(Compute*)compute, *(Buffer*)buffer, offset, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_dispatch_cCBuT(TSCubeFilter self, TSCompute compute, TSBuffer buffer, uint32_t offset, TSTexture texture) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(buffer);
		TS_ASSERT(texture);
		return ((CubeFilter*)self)->dispatch(*(Compute*)compute, *(Buffer*)buffer, offset, *(Texture*)texture);
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_dispatch_cCTcSBu(TSCubeFilter self, TSCompute compute, TSTexture texture, const TSSlice *slice, TSBuffer buffer, uint32_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(texture);
		TS_ASSERT(buffer);
		return ((CubeFilter*)self)->dispatch(*(Compute*)compute, *(Texture*)texture, (slice) ? *(const Slice*)slice : Slice(), *(Buffer*)buffer, offset);
	}
	TS_CAPI bool_t TS_CCALL tsCubeFilter_dispatch_cCTBu(TSCubeFilter self, TSCompute compute, TSTexture texture, TSBuffer buffer, uint32_t offset) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(texture);
		TS_ASSERT(buffer);
		return ((CubeFilter*)self)->dispatch(*(Compute*)compute, *(Texture*)texture, *(Buffer*)buffer, offset);
	}
	
	// Tellusim::DecoderJPEG
	TS_CAPI TSDecoderJPEG TS_CCALL tsDecoderJPEG_new(void) {
		DecoderJPEG *ret = new DecoderJPEG();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDecoderJPEG)ret;
	}
	TS_CAPI void TS_CCALL tsDecoderJPEG_delete(TSDecoderJPEG self) {
		if(self) delete (DecoderJPEG*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_equalPtr(const TSDecoderJPEG self, const TSDecoderJPEG ptr) {
		return (self && ptr && ((DecoderJPEG*)self)->operator==(*(DecoderJPEG*)ptr));
	}
	TS_CAPI TSDecoderJPEG TS_CCALL tsDecoderJPEG_copyPtr(TSDecoderJPEG self) {
		DecoderJPEG *ret = nullptr;
		if(self) ret = new DecoderJPEG(*(DecoderJPEG*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDecoderJPEG)ret;
	}
	TS_CAPI TSDecoderJPEG TS_CCALL tsDecoderJPEG_clonePtr(const TSDecoderJPEG self) {
		DecoderJPEG *ret = (self) ? new DecoderJPEG(((DecoderJPEG*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDecoderJPEG)ret;
	}
	TS_CAPI void TS_CCALL tsDecoderJPEG_clearPtr(TSDecoderJPEG self) {
		if(self) ((DecoderJPEG*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDecoderJPEG_destroyPtr(TSDecoderJPEG self) {
		if(self) ((DecoderJPEG*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDecoderJPEG_acquirePtr(TSDecoderJPEG self) {
		if(self) ((DecoderJPEG*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDecoderJPEG_unacquirePtr(TSDecoderJPEG self) {
		if(self) ((DecoderJPEG*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_isValidPtr(const TSDecoderJPEG self) {
		return (self && ((DecoderJPEG*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_isOwnerPtr(const TSDecoderJPEG self) {
		return (self && ((DecoderJPEG*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_isConstPtr(const TSDecoderJPEG self) {
		return (self && ((DecoderJPEG*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDecoderJPEG_getCountPtr(const TSDecoderJPEG self) {
		return ((DecoderJPEG*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDecoderJPEG_getInternalPtr(const TSDecoderJPEG self) {
		return ((DecoderJPEG*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsDecoderJPEG_clear(TSDecoderJPEG self) {
		TS_ASSERT(self);
		((DecoderJPEG*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_isCreated(TSDecoderJPEG self, TS_DecoderJPEGMode mode) {
		TS_ASSERT(self);
		return ((DecoderJPEG*)self)->isCreated((DecoderJPEG::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_isYUV(TS_DecoderJPEGMode mode) {
		return DecoderJPEG::isYUV((DecoderJPEG::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_create_cDDJM(TSDecoderJPEG self, const TSDevice device, TS_DecoderJPEGMode mode) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((DecoderJPEG*)self)->create(*(const Device*)device, (DecoderJPEG::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_create_cDDJF(TSDecoderJPEG self, const TSDevice device, TS_DecoderJPEGFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((DecoderJPEG*)self)->create(*(const Device*)device, (DecoderJPEG::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_load_sIDJMS(const char *name, TSImage image, TS_DecoderJPEGMode *mode, TSSize *size) {
		TS_ASSERT(image);
		TS_ASSERT(mode);
		TS_ASSERT(size);
		return DecoderJPEG::load(name, *(Image*)image, (DecoderJPEG::Mode&)*mode, *(Size*)size);
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_load_StIDJMS(TSStream stream, TSImage image, TS_DecoderJPEGMode *mode, TSSize *size) {
		TS_ASSERT(stream);
		TS_ASSERT(image);
		TS_ASSERT(mode);
		TS_ASSERT(size);
		return DecoderJPEG::load(*(Stream*)stream, *(Image*)image, (DecoderJPEG::Mode&)*mode, *(Size*)size);
	}
	TS_CAPI TSTexture TS_CCALL tsDecoderJPEG_loadTexture_ccDsTF(TSDecoderJPEG self, const TSDevice device, const char *name, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return (TSTexture)(new Texture(((DecoderJPEG*)self)->loadTexture(*(const Device*)device, name, (Texture::Flags)flags)));
	}
	TS_CAPI TSTexture TS_CCALL tsDecoderJPEG_loadTexture_ccDStTF(TSDecoderJPEG self, const TSDevice device, TSStream stream, TS_TextureFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(stream);
		return (TSTexture)(new Texture(((DecoderJPEG*)self)->loadTexture(*(const Device*)device, *(Stream*)stream, (Texture::Flags)flags)));
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_dispatch_cCDJMTTcScS(TSDecoderJPEG self, TSCompute compute, TS_DecoderJPEGMode mode, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((DecoderJPEG*)self)->dispatch(*(Compute*)compute, (DecoderJPEG::Mode)mode, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_dispatch_cCDJMTTcS(TSDecoderJPEG self, TSCompute compute, TS_DecoderJPEGMode mode, TSTexture dest, TSTexture src, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((DecoderJPEG*)self)->dispatch(*(Compute*)compute, (DecoderJPEG::Mode)mode, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_dispatch_cCDJMTT(TSDecoderJPEG self, TSCompute compute, TS_DecoderJPEGMode mode, TSTexture dest, TSTexture src) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((DecoderJPEG*)self)->dispatch(*(Compute*)compute, (DecoderJPEG::Mode)mode, *(Texture*)dest, *(Texture*)src);
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_dispatchYUV_cCDJMTTcScS(TSDecoderJPEG self, TSCompute compute, TS_DecoderJPEGMode mode, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((DecoderJPEG*)self)->dispatchYUV(*(Compute*)compute, (DecoderJPEG::Mode)mode, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_dispatchYUV_cCDJMTTcS(TSDecoderJPEG self, TSCompute compute, TS_DecoderJPEGMode mode, TSTexture dest, TSTexture src, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((DecoderJPEG*)self)->dispatchYUV(*(Compute*)compute, (DecoderJPEG::Mode)mode, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsDecoderJPEG_dispatchYUV_cCDJMTT(TSDecoderJPEG self, TSCompute compute, TS_DecoderJPEGMode mode, TSTexture dest, TSTexture src) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((DecoderJPEG*)self)->dispatchYUV(*(Compute*)compute, (DecoderJPEG::Mode)mode, *(Texture*)dest, *(Texture*)src);
	}
	
	// Tellusim::EncoderBC15
	TS_CAPI TSEncoderBC15 TS_CCALL tsEncoderBC15_new(void) {
		EncoderBC15 *ret = new EncoderBC15();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderBC15)ret;
	}
	TS_CAPI void TS_CCALL tsEncoderBC15_delete(TSEncoderBC15 self) {
		if(self) delete (EncoderBC15*)self;
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_equalPtr(const TSEncoderBC15 self, const TSEncoderBC15 ptr) {
		return (self && ptr && ((EncoderBC15*)self)->operator==(*(EncoderBC15*)ptr));
	}
	TS_CAPI TSEncoderBC15 TS_CCALL tsEncoderBC15_copyPtr(TSEncoderBC15 self) {
		EncoderBC15 *ret = nullptr;
		if(self) ret = new EncoderBC15(*(EncoderBC15*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderBC15)ret;
	}
	TS_CAPI TSEncoderBC15 TS_CCALL tsEncoderBC15_clonePtr(const TSEncoderBC15 self) {
		EncoderBC15 *ret = (self) ? new EncoderBC15(((EncoderBC15*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderBC15)ret;
	}
	TS_CAPI void TS_CCALL tsEncoderBC15_clearPtr(TSEncoderBC15 self) {
		if(self) ((EncoderBC15*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC15_destroyPtr(TSEncoderBC15 self) {
		if(self) ((EncoderBC15*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC15_acquirePtr(TSEncoderBC15 self) {
		if(self) ((EncoderBC15*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC15_unacquirePtr(TSEncoderBC15 self) {
		if(self) ((EncoderBC15*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_isValidPtr(const TSEncoderBC15 self) {
		return (self && ((EncoderBC15*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_isOwnerPtr(const TSEncoderBC15 self) {
		return (self && ((EncoderBC15*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_isConstPtr(const TSEncoderBC15 self) {
		return (self && ((EncoderBC15*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsEncoderBC15_getCountPtr(const TSEncoderBC15 self) {
		return ((EncoderBC15*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsEncoderBC15_getInternalPtr(const TSEncoderBC15 self) {
		return ((EncoderBC15*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC15_clear(TSEncoderBC15 self) {
		TS_ASSERT(self);
		((EncoderBC15*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_isCreated(TSEncoderBC15 self, TS_EncoderBC15Mode mode) {
		TS_ASSERT(self);
		return ((EncoderBC15*)self)->isCreated((EncoderBC15::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_create_cDEB15M(TSEncoderBC15 self, const TSDevice device, TS_EncoderBC15Mode mode) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((EncoderBC15*)self)->create(*(const Device*)device, (EncoderBC15::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_create_cDEB15F(TSEncoderBC15 self, const TSDevice device, TS_EncoderBC15Flags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((EncoderBC15*)self)->create(*(const Device*)device, (EncoderBC15::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_dispatch_cCEB15MTTcScS(TSEncoderBC15 self, TSCompute compute, TS_EncoderBC15Mode mode, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderBC15*)self)->dispatch(*(Compute*)compute, (EncoderBC15::Mode)mode, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_dispatch_cCEB15MTTcS(TSEncoderBC15 self, TSCompute compute, TS_EncoderBC15Mode mode, TSTexture dest, TSTexture src, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderBC15*)self)->dispatch(*(Compute*)compute, (EncoderBC15::Mode)mode, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC15_dispatch_cCEB15MTT(TSEncoderBC15 self, TSCompute compute, TS_EncoderBC15Mode mode, TSTexture dest, TSTexture src) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderBC15*)self)->dispatch(*(Compute*)compute, (EncoderBC15::Mode)mode, *(Texture*)dest, *(Texture*)src);
	}
	
	// Tellusim::EncoderBC67
	TS_CAPI TSEncoderBC67 TS_CCALL tsEncoderBC67_new(void) {
		EncoderBC67 *ret = new EncoderBC67();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderBC67)ret;
	}
	TS_CAPI void TS_CCALL tsEncoderBC67_delete(TSEncoderBC67 self) {
		if(self) delete (EncoderBC67*)self;
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_equalPtr(const TSEncoderBC67 self, const TSEncoderBC67 ptr) {
		return (self && ptr && ((EncoderBC67*)self)->operator==(*(EncoderBC67*)ptr));
	}
	TS_CAPI TSEncoderBC67 TS_CCALL tsEncoderBC67_copyPtr(TSEncoderBC67 self) {
		EncoderBC67 *ret = nullptr;
		if(self) ret = new EncoderBC67(*(EncoderBC67*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderBC67)ret;
	}
	TS_CAPI TSEncoderBC67 TS_CCALL tsEncoderBC67_clonePtr(const TSEncoderBC67 self) {
		EncoderBC67 *ret = (self) ? new EncoderBC67(((EncoderBC67*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderBC67)ret;
	}
	TS_CAPI void TS_CCALL tsEncoderBC67_clearPtr(TSEncoderBC67 self) {
		if(self) ((EncoderBC67*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC67_destroyPtr(TSEncoderBC67 self) {
		if(self) ((EncoderBC67*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC67_acquirePtr(TSEncoderBC67 self) {
		if(self) ((EncoderBC67*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC67_unacquirePtr(TSEncoderBC67 self) {
		if(self) ((EncoderBC67*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_isValidPtr(const TSEncoderBC67 self) {
		return (self && ((EncoderBC67*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_isOwnerPtr(const TSEncoderBC67 self) {
		return (self && ((EncoderBC67*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_isConstPtr(const TSEncoderBC67 self) {
		return (self && ((EncoderBC67*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsEncoderBC67_getCountPtr(const TSEncoderBC67 self) {
		return ((EncoderBC67*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsEncoderBC67_getInternalPtr(const TSEncoderBC67 self) {
		return ((EncoderBC67*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderBC67_clear(TSEncoderBC67 self) {
		TS_ASSERT(self);
		((EncoderBC67*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_isCreated(TSEncoderBC67 self, TS_EncoderBC67Mode mode) {
		TS_ASSERT(self);
		return ((EncoderBC67*)self)->isCreated((EncoderBC67::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_create_cDEB67M(TSEncoderBC67 self, const TSDevice device, TS_EncoderBC67Mode mode) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((EncoderBC67*)self)->create(*(const Device*)device, (EncoderBC67::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_create_cDEB67F(TSEncoderBC67 self, const TSDevice device, TS_EncoderBC67Flags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((EncoderBC67*)self)->create(*(const Device*)device, (EncoderBC67::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_dispatch_cCEB67MTTcScSu(TSEncoderBC67 self, TSCompute compute, TS_EncoderBC67Mode mode, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice, uint32_t components) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderBC67*)self)->dispatch(*(Compute*)compute, (EncoderBC67::Mode)mode, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice(), components);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_dispatch_cCEB67MTTcSu(TSEncoderBC67 self, TSCompute compute, TS_EncoderBC67Mode mode, TSTexture dest, TSTexture src, const TSSlice *src_slice, uint32_t components) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderBC67*)self)->dispatch(*(Compute*)compute, (EncoderBC67::Mode)mode, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice(), components);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderBC67_dispatch_cCEB67MTTu(TSEncoderBC67 self, TSCompute compute, TS_EncoderBC67Mode mode, TSTexture dest, TSTexture src, uint32_t components) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderBC67*)self)->dispatch(*(Compute*)compute, (EncoderBC67::Mode)mode, *(Texture*)dest, *(Texture*)src, components);
	}
	
	// Tellusim::EncoderASTC
	TS_CAPI TSEncoderASTC TS_CCALL tsEncoderASTC_new(void) {
		EncoderASTC *ret = new EncoderASTC();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderASTC)ret;
	}
	TS_CAPI void TS_CCALL tsEncoderASTC_delete(TSEncoderASTC self) {
		if(self) delete (EncoderASTC*)self;
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_equalPtr(const TSEncoderASTC self, const TSEncoderASTC ptr) {
		return (self && ptr && ((EncoderASTC*)self)->operator==(*(EncoderASTC*)ptr));
	}
	TS_CAPI TSEncoderASTC TS_CCALL tsEncoderASTC_copyPtr(TSEncoderASTC self) {
		EncoderASTC *ret = nullptr;
		if(self) ret = new EncoderASTC(*(EncoderASTC*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderASTC)ret;
	}
	TS_CAPI TSEncoderASTC TS_CCALL tsEncoderASTC_clonePtr(const TSEncoderASTC self) {
		EncoderASTC *ret = (self) ? new EncoderASTC(((EncoderASTC*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSEncoderASTC)ret;
	}
	TS_CAPI void TS_CCALL tsEncoderASTC_clearPtr(TSEncoderASTC self) {
		if(self) ((EncoderASTC*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderASTC_destroyPtr(TSEncoderASTC self) {
		if(self) ((EncoderASTC*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderASTC_acquirePtr(TSEncoderASTC self) {
		if(self) ((EncoderASTC*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsEncoderASTC_unacquirePtr(TSEncoderASTC self) {
		if(self) ((EncoderASTC*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_isValidPtr(const TSEncoderASTC self) {
		return (self && ((EncoderASTC*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_isOwnerPtr(const TSEncoderASTC self) {
		return (self && ((EncoderASTC*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_isConstPtr(const TSEncoderASTC self) {
		return (self && ((EncoderASTC*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsEncoderASTC_getCountPtr(const TSEncoderASTC self) {
		return ((EncoderASTC*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsEncoderASTC_getInternalPtr(const TSEncoderASTC self) {
		return ((EncoderASTC*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsEncoderASTC_clear(TSEncoderASTC self) {
		TS_ASSERT(self);
		((EncoderASTC*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_isCreated(TSEncoderASTC self, TS_EncoderASTCMode mode) {
		TS_ASSERT(self);
		return ((EncoderASTC*)self)->isCreated((EncoderASTC::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_create_cDEAM(TSEncoderASTC self, const TSDevice device, TS_EncoderASTCMode mode) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((EncoderASTC*)self)->create(*(const Device*)device, (EncoderASTC::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_create_cDEAF(TSEncoderASTC self, const TSDevice device, TS_EncoderASTCFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((EncoderASTC*)self)->create(*(const Device*)device, (EncoderASTC::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_dispatch_cCEAMTTcScSu(TSEncoderASTC self, TSCompute compute, TS_EncoderASTCMode mode, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice, uint32_t components) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderASTC*)self)->dispatch(*(Compute*)compute, (EncoderASTC::Mode)mode, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice(), components);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_dispatch_cCEAMTTcSu(TSEncoderASTC self, TSCompute compute, TS_EncoderASTCMode mode, TSTexture dest, TSTexture src, const TSSlice *src_slice, uint32_t components) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderASTC*)self)->dispatch(*(Compute*)compute, (EncoderASTC::Mode)mode, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice(), components);
	}
	TS_CAPI bool_t TS_CCALL tsEncoderASTC_dispatch_cCEAMTTu(TSEncoderASTC self, TSCompute compute, TS_EncoderASTCMode mode, TSTexture dest, TSTexture src, uint32_t components) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((EncoderASTC*)self)->dispatch(*(Compute*)compute, (EncoderASTC::Mode)mode, *(Texture*)dest, *(Texture*)src, components);
	}
	
	// Tellusim::MeshModel
	TS_CAPI TSMeshModel TS_CCALL tsMeshModel_new(void) {
		return (TSMeshModel)(new MeshModel());
	}
	TS_CAPI void TS_CCALL tsMeshModel_delete(TSMeshModel self) {
		if(self) delete (MeshModel*)self;
	}
	TS_CAPI void TS_CCALL tsMeshModel_clear(TSMeshModel self) {
		TS_ASSERT(self);
		((MeshModel*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_isCreated(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->isCreated();
	}
	TS_CAPI TS_MeshModelFlags TS_CCALL tsMeshModel_getFlags(TSMeshModel self) {
		TS_ASSERT(self);
		return (TS_MeshModelFlags)((MeshModel*)self)->getFlags();
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_hasFlag(TSMeshModel self, TS_MeshModelFlags flags) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->hasFlag((MeshModel::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_hasFlags(TSMeshModel self, TS_MeshModelFlags flags) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->hasFlags((MeshModel::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_load_cDcPsMMFA(TSMeshModel self, const TSDevice device, const TSPipeline pipeline, const char *name, TS_MeshModelFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(pipeline);
		return ((MeshModel*)self)->load(*(const Device*)device, *(const Pipeline*)pipeline, name, (MeshModel::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_load_cDcPStMMFA(TSMeshModel self, const TSDevice device, const TSPipeline pipeline, TSStream stream, TS_MeshModelFlags flags, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(pipeline);
		TS_ASSERT(stream);
		return ((MeshModel*)self)->load(*(const Device*)device, *(const Pipeline*)pipeline, *(Stream*)stream, (MeshModel::Flags)flags, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_create_cDcPsMMF(TSMeshModel self, const TSDevice device, const TSPipeline pipeline, const char *name, TS_MeshModelFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(pipeline);
		return ((MeshModel*)self)->create(*(const Device*)device, *(const Pipeline*)pipeline, name, (MeshModel::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_create_cDcPcMMMF(TSMeshModel self, const TSDevice device, const TSPipeline pipeline, const TSMesh mesh, TS_MeshModelFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(pipeline);
		TS_ASSERT(mesh);
		return ((MeshModel*)self)->create(*(const Device*)device, *(const Pipeline*)pipeline, *(const Mesh*)mesh, (MeshModel::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_create_cDcPcMGMMF(TSMeshModel self, const TSDevice device, const TSPipeline pipeline, const TSMeshGeometry geometry, TS_MeshModelFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(pipeline);
		TS_ASSERT(geometry);
		return ((MeshModel*)self)->create(*(const Device*)device, *(const Pipeline*)pipeline, *(const MeshGeometry*)geometry, (MeshModel::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsMeshModel_create_cDcPcAMGMMF(TSMeshModel self, const TSDevice device, const TSPipeline pipeline, const TSMeshGeometry *geometries, uint32_t geometries_size, TS_MeshModelFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(pipeline);
		Array<MeshGeometry> geometries_(geometries_size);
		for(uint32_t i = 0; i < geometries_size; i++) if(geometries[i]) geometries_[i] = *(MeshGeometry*)geometries[i];
		return ((MeshModel*)self)->create(*(const Device*)device, *(const Pipeline*)pipeline, geometries_, (MeshModel::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsMeshModel_setVertexBufferCallback(TSMeshModel self, const TSMeshModelCreateCallback func, void *data_) {
		TS_ASSERT(self);
		((MeshModel*)self)->setVertexBufferCallback(makeTSMeshModelCreateCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsMeshModel_setIndexBufferCallback(TSMeshModel self, const TSMeshModelCreateCallback func, void *data_) {
		TS_ASSERT(self);
		((MeshModel*)self)->setIndexBufferCallback(makeTSMeshModelCreateCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsMeshModel_setMeshBufferCallback(TSMeshModel self, const TSMeshModelCreateCallback func, void *data_) {
		TS_ASSERT(self);
		((MeshModel*)self)->setMeshBufferCallback(makeTSMeshModelCreateCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsMeshModel_setBuffers(TSMeshModel self, TSCommand command, uint32_t index, const TSPipeline *pipeline) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((MeshModel*)self)->setBuffers(*(Command*)command, index, (pipeline) ? *(const Pipeline**)pipeline : nullptr);
	}
	TS_CAPI void TS_CCALL tsMeshModel_draw_cC(TSMeshModel self, TSCommand command) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((MeshModel*)self)->draw(*(Command*)command);
	}
	TS_CAPI void TS_CCALL tsMeshModel_draw_cCu(TSMeshModel self, TSCommand command, uint32_t geometry) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((MeshModel*)self)->draw(*(Command*)command, geometry);
	}
	TS_CAPI void TS_CCALL tsMeshModel_draw_cCuu(TSMeshModel self, TSCommand command, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((MeshModel*)self)->draw(*(Command*)command, geometry, material);
	}
	TS_CAPI void TS_CCALL tsMeshModel_drawInstanced_cCuuu(TSMeshModel self, TSCommand command, uint32_t geometry, uint32_t num_instances, uint32_t base_instance) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((MeshModel*)self)->drawInstanced(*(Command*)command, geometry, num_instances, base_instance);
	}
	TS_CAPI void TS_CCALL tsMeshModel_drawInstanced_cCuuuu(TSMeshModel self, TSCommand command, uint32_t geometry, uint32_t material, uint32_t num_instances, uint32_t base_instance) {
		TS_ASSERT(self);
		TS_ASSERT(command);
		((MeshModel*)self)->drawInstanced(*(Command*)command, geometry, material, num_instances, base_instance);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumVertices(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumVertices();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumVertexBuffers(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumVertexBuffers();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getVertexBufferStride(TSMeshModel self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getVertexBufferStride(index);
	}
	TS_CAPI size_t TS_CCALL tsMeshModel_getVertexBufferOffset(TSMeshModel self, uint32_t index) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getVertexBufferOffset(index);
	}
	TS_CAPI TSBuffer TS_CCALL tsMeshModel_getVertexBuffer(TSMeshModel self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((MeshModel*)self)->getVertexBuffer()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumIndices(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumIndices();
	}
	TS_CAPI TS_Format TS_CCALL tsMeshModel_getIndexFormat(TSMeshModel self) {
		TS_ASSERT(self);
		return (TS_Format)((MeshModel*)self)->getIndexFormat();
	}
	TS_CAPI TSBuffer TS_CCALL tsMeshModel_getIndexBuffer(TSMeshModel self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((MeshModel*)self)->getIndexBuffer()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumMeshlets(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumMeshlets();
	}
	TS_CAPI TSBuffer TS_CCALL tsMeshModel_getMeshletBuffer(TSMeshModel self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((MeshModel*)self)->getMeshletBuffer()));
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumGeometries(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumGeometries();
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumGeometryIndices(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumGeometryIndices(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumGeometryVertices(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumGeometryVertices(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumGeometryMeshlets(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumGeometryMeshlets(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getGeometryBaseIndex(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getGeometryBaseIndex(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getGeometryBaseVertex(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getGeometryBaseVertex(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getGeometryBaseMeshlet(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getGeometryBaseMeshlet(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumMaterials(TSMeshModel self, uint32_t geometry) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumMaterials(geometry);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumMaterialIndices(TSMeshModel self, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumMaterialIndices(geometry, material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumMaterialVertices(TSMeshModel self, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumMaterialVertices(geometry, material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getNumMaterialMeshlets(TSMeshModel self, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getNumMaterialMeshlets(geometry, material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getMaterialBaseIndex(TSMeshModel self, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getMaterialBaseIndex(geometry, material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getMaterialBaseVertex(TSMeshModel self, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getMaterialBaseVertex(geometry, material);
	}
	TS_CAPI uint32_t TS_CCALL tsMeshModel_getMaterialBaseMeshlet(TSMeshModel self, uint32_t geometry, uint32_t material) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getMaterialBaseMeshlet(geometry, material);
	}
	TS_CAPI size_t TS_CCALL tsMeshModel_getMemory(TSMeshModel self) {
		TS_ASSERT(self);
		return ((MeshModel*)self)->getMemory();
	}
	
	// Tellusim::SeparableFilter
	TS_CAPI TSSeparableFilter TS_CCALL tsSeparableFilter_new(void) {
		SeparableFilter *ret = new SeparableFilter();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSeparableFilter)ret;
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_delete(TSSeparableFilter self) {
		if(self) delete (SeparableFilter*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_equalPtr(const TSSeparableFilter self, const TSSeparableFilter ptr) {
		return (self && ptr && ((SeparableFilter*)self)->operator==(*(SeparableFilter*)ptr));
	}
	TS_CAPI TSSeparableFilter TS_CCALL tsSeparableFilter_copyPtr(TSSeparableFilter self) {
		SeparableFilter *ret = nullptr;
		if(self) ret = new SeparableFilter(*(SeparableFilter*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSeparableFilter)ret;
	}
	TS_CAPI TSSeparableFilter TS_CCALL tsSeparableFilter_clonePtr(const TSSeparableFilter self) {
		SeparableFilter *ret = (self) ? new SeparableFilter(((SeparableFilter*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSeparableFilter)ret;
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_clearPtr(TSSeparableFilter self) {
		if(self) ((SeparableFilter*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_destroyPtr(TSSeparableFilter self) {
		if(self) ((SeparableFilter*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_acquirePtr(TSSeparableFilter self) {
		if(self) ((SeparableFilter*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_unacquirePtr(TSSeparableFilter self) {
		if(self) ((SeparableFilter*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_isValidPtr(const TSSeparableFilter self) {
		return (self && ((SeparableFilter*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_isOwnerPtr(const TSSeparableFilter self) {
		return (self && ((SeparableFilter*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_isConstPtr(const TSSeparableFilter self) {
		return (self && ((SeparableFilter*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSeparableFilter_getCountPtr(const TSSeparableFilter self) {
		return ((SeparableFilter*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSeparableFilter_getInternalPtr(const TSSeparableFilter self) {
		return ((SeparableFilter*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_clear(TSSeparableFilter self) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_isCreated(TSSeparableFilter self, TS_Format format, uint32_t size) {
		TS_ASSERT(self);
		return ((SeparableFilter*)self)->isCreated((Format)format, size);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setInputSource(TSSeparableFilter self, TS_SeparableFilterMode mode, const char *src) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->setInputSource((SeparableFilter::Mode)mode, src);
	}
	TS_CAPI TSString TS_CCALL tsSeparableFilter_getInputSource(TSSeparableFilter self, TS_SeparableFilterMode mode) {
		TS_ASSERT(self);
		return (TSString)(new String(((SeparableFilter*)self)->getInputSource((SeparableFilter::Mode)mode)));
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setOutputSource(TSSeparableFilter self, TS_SeparableFilterMode mode, const char *src) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->setOutputSource((SeparableFilter::Mode)mode, src);
	}
	TS_CAPI TSString TS_CCALL tsSeparableFilter_getOutputSource(TSSeparableFilter self, TS_SeparableFilterMode mode) {
		TS_ASSERT(self);
		return (TSString)(new String(((SeparableFilter*)self)->getOutputSource((SeparableFilter::Mode)mode)));
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_create(TSSeparableFilter self, const TSDevice device, TS_Format format, uint32_t size, TS_SeparableFilterFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((SeparableFilter*)self)->create(*(const Device*)device, (Format)format, size, (SeparableFilter::Flags)flags);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setWeights_SFMcAV4b(TSSeparableFilter self, TS_SeparableFilterMode mode, const TSVector4f *weights, uint32_t weights_size, bool_t normalize) {
		TS_ASSERT(self);
		Array<Vector4f> weights_(weights_size, (const Vector4f*)weights);
		((SeparableFilter*)self)->setWeights((SeparableFilter::Mode)mode, weights_, (bool)normalize);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setWeights_SFMcA32b(TSSeparableFilter self, TS_SeparableFilterMode mode, const float32_t *weights, uint32_t weights_size, bool_t normalize) {
		TS_ASSERT(self);
		Array<float32_t> weights_(weights_size, weights);
		((SeparableFilter*)self)->setWeights((SeparableFilter::Mode)mode, weights_, (bool)normalize);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setGaussianWeights_ucV4(TSSeparableFilter self, uint32_t size, const TSVector4f *sigma) {
		TS_ASSERT(self);
		TS_ASSERT(sigma);
		((SeparableFilter*)self)->setGaussianWeights(size, *(const Vector4f*)sigma);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setGaussianWeights_uf(TSSeparableFilter self, uint32_t size, float32_t sigma) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->setGaussianWeights(size, sigma);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setSobelXWeights(TSSeparableFilter self, uint32_t size) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->setSobelXWeights(size);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setSobelYWeights(TSSeparableFilter self, uint32_t size) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->setSobelYWeights(size);
	}
	TS_CAPI void TS_CCALL tsSeparableFilter_setBoxWeights(TSSeparableFilter self, uint32_t size) {
		TS_ASSERT(self);
		((SeparableFilter*)self)->setBoxWeights(size);
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_dispatch_cCSFMuTTcScScV4(TSSeparableFilter self, TSCompute compute, TS_SeparableFilterMode mode, uint32_t size, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice, const TSVector4f *parameters) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		TS_ASSERT(parameters);
		return ((SeparableFilter*)self)->dispatch(*(Compute*)compute, (SeparableFilter::Mode)mode, size, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice(), *(const Vector4f*)parameters);
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_dispatch_cCSFMuTTcScV4(TSSeparableFilter self, TSCompute compute, TS_SeparableFilterMode mode, uint32_t size, TSTexture dest, TSTexture src, const TSSlice *src_slice, const TSVector4f *parameters) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		TS_ASSERT(parameters);
		return ((SeparableFilter*)self)->dispatch(*(Compute*)compute, (SeparableFilter::Mode)mode, size, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice(), *(const Vector4f*)parameters);
	}
	TS_CAPI bool_t TS_CCALL tsSeparableFilter_dispatch_cCSFMuTTcV4(TSSeparableFilter self, TSCompute compute, TS_SeparableFilterMode mode, uint32_t size, TSTexture dest, TSTexture src, const TSVector4f *parameters) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		TS_ASSERT(parameters);
		return ((SeparableFilter*)self)->dispatch(*(Compute*)compute, (SeparableFilter::Mode)mode, size, *(Texture*)dest, *(Texture*)src, *(const Vector4f*)parameters);
	}
	
	// Tellusim::PrefixScan
	TS_CAPI TSPrefixScan TS_CCALL tsPrefixScan_new(void) {
		PrefixScan *ret = new PrefixScan();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSPrefixScan)ret;
	}
	TS_CAPI void TS_CCALL tsPrefixScan_delete(TSPrefixScan self) {
		if(self) delete (PrefixScan*)self;
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_equalPtr(const TSPrefixScan self, const TSPrefixScan ptr) {
		return (self && ptr && ((PrefixScan*)self)->operator==(*(PrefixScan*)ptr));
	}
	TS_CAPI TSPrefixScan TS_CCALL tsPrefixScan_copyPtr(TSPrefixScan self) {
		PrefixScan *ret = nullptr;
		if(self) ret = new PrefixScan(*(PrefixScan*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSPrefixScan)ret;
	}
	TS_CAPI TSPrefixScan TS_CCALL tsPrefixScan_clonePtr(const TSPrefixScan self) {
		PrefixScan *ret = (self) ? new PrefixScan(((PrefixScan*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSPrefixScan)ret;
	}
	TS_CAPI void TS_CCALL tsPrefixScan_clearPtr(TSPrefixScan self) {
		if(self) ((PrefixScan*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsPrefixScan_destroyPtr(TSPrefixScan self) {
		if(self) ((PrefixScan*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsPrefixScan_acquirePtr(TSPrefixScan self) {
		if(self) ((PrefixScan*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsPrefixScan_unacquirePtr(TSPrefixScan self) {
		if(self) ((PrefixScan*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_isValidPtr(const TSPrefixScan self) {
		return (self && ((PrefixScan*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_isOwnerPtr(const TSPrefixScan self) {
		return (self && ((PrefixScan*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_isConstPtr(const TSPrefixScan self) {
		return (self && ((PrefixScan*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsPrefixScan_getCountPtr(const TSPrefixScan self) {
		return ((PrefixScan*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsPrefixScan_getInternalPtr(const TSPrefixScan self) {
		return ((PrefixScan*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsPrefixScan_clear(TSPrefixScan self) {
		TS_ASSERT(self);
		((PrefixScan*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_isCreated(TSPrefixScan self, TS_PrefixScanFlags flags) {
		TS_ASSERT(self);
		return ((PrefixScan*)self)->isCreated((PrefixScan::Flags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsPrefixScan_getGroupSize(TSPrefixScan self) {
		TS_ASSERT(self);
		return ((PrefixScan*)self)->getGroupSize();
	}
	TS_CAPI uint32_t TS_CCALL tsPrefixScan_getScanElements(TSPrefixScan self) {
		TS_ASSERT(self);
		return ((PrefixScan*)self)->getScanElements();
	}
	TS_CAPI uint32_t TS_CCALL tsPrefixScan_getMaxElements(TSPrefixScan self) {
		TS_ASSERT(self);
		return ((PrefixScan*)self)->getMaxElements();
	}
	TS_CAPI uint32_t TS_CCALL tsPrefixScan_getMaxRegions(TSPrefixScan self) {
		TS_ASSERT(self);
		return ((PrefixScan*)self)->getMaxRegions();
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_create_cDPSMuuA(TSPrefixScan self, const TSDevice device, TS_PrefixScanMode mode, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((PrefixScan*)self)->create(*(const Device*)device, (PrefixScan::Mode)mode, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_create_cDPSFuuA(TSPrefixScan self, const TSDevice device, TS_PrefixScanFlags flags, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((PrefixScan*)self)->create(*(const Device*)device, (PrefixScan::Flags)flags, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_dispatch_CBuu(TSPrefixScan self, TSCompute compute, TSBuffer data, uint32_t offset, uint32_t size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((PrefixScan*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, offset, size);
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_dispatch_CBuupupPSF(TSPrefixScan self, TSCompute compute, TSBuffer data, uint32_t count, const uint32_t *offsets, const uint32_t *sizes, TS_PrefixScanFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((PrefixScan*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, count, offsets, sizes, (PrefixScan::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_dispatchIndirect_CBBuPSFu(TSPrefixScan self, TSCompute compute, TSBuffer data, TSBuffer dispatch, uint32_t offset, TS_PrefixScanFlags flags, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((PrefixScan*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)dispatch, offset, (PrefixScan::Flags)flags, max_size);
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_dispatchIndirect_CBuBuPSFu(TSPrefixScan self, TSCompute compute, TSBuffer data, uint32_t count, TSBuffer dispatch, uint32_t offset, TS_PrefixScanFlags flags, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((PrefixScan*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, count, *(Buffer*)dispatch, offset, (PrefixScan::Flags)flags, max_size);
	}
	TS_CAPI bool_t TS_CCALL tsPrefixScan_dispatchIndirect_CBBBuuPSFu(TSPrefixScan self, TSCompute compute, TSBuffer data, TSBuffer count, TSBuffer dispatch, uint32_t count_offset, uint32_t dispatch_offset, TS_PrefixScanFlags flags, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(count);
		TS_ASSERT(dispatch);
		return ((PrefixScan*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)count, *(Buffer*)dispatch, count_offset, dispatch_offset, (PrefixScan::Flags)flags, max_size);
	}
	
	// Tellusim::RadixSort
	TS_CAPI TSRadixSort TS_CCALL tsRadixSort_new(void) {
		RadixSort *ret = new RadixSort();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSRadixSort)ret;
	}
	TS_CAPI void TS_CCALL tsRadixSort_delete(TSRadixSort self) {
		if(self) delete (RadixSort*)self;
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_equalPtr(const TSRadixSort self, const TSRadixSort ptr) {
		return (self && ptr && ((RadixSort*)self)->operator==(*(RadixSort*)ptr));
	}
	TS_CAPI TSRadixSort TS_CCALL tsRadixSort_copyPtr(TSRadixSort self) {
		RadixSort *ret = nullptr;
		if(self) ret = new RadixSort(*(RadixSort*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSRadixSort)ret;
	}
	TS_CAPI TSRadixSort TS_CCALL tsRadixSort_clonePtr(const TSRadixSort self) {
		RadixSort *ret = (self) ? new RadixSort(((RadixSort*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSRadixSort)ret;
	}
	TS_CAPI void TS_CCALL tsRadixSort_clearPtr(TSRadixSort self) {
		if(self) ((RadixSort*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsRadixSort_destroyPtr(TSRadixSort self) {
		if(self) ((RadixSort*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsRadixSort_acquirePtr(TSRadixSort self) {
		if(self) ((RadixSort*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsRadixSort_unacquirePtr(TSRadixSort self) {
		if(self) ((RadixSort*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_isValidPtr(const TSRadixSort self) {
		return (self && ((RadixSort*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_isOwnerPtr(const TSRadixSort self) {
		return (self && ((RadixSort*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_isConstPtr(const TSRadixSort self) {
		return (self && ((RadixSort*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getCountPtr(const TSRadixSort self) {
		return ((RadixSort*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsRadixSort_getInternalPtr(const TSRadixSort self) {
		return ((RadixSort*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsRadixSort_clear(TSRadixSort self) {
		TS_ASSERT(self);
		((RadixSort*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_isCreated(TSRadixSort self, TS_RadixSortFlags flags) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->isCreated((RadixSort::Flags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getDataSize(TSRadixSort self) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->getDataSize();
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getGroupSize(TSRadixSort self) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->getGroupSize();
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getSortElements(TSRadixSort self) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->getSortElements();
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getUpdateElements(TSRadixSort self) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->getUpdateElements();
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getMaxElements(TSRadixSort self) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->getMaxElements();
	}
	TS_CAPI uint32_t TS_CCALL tsRadixSort_getMaxRegions(TSRadixSort self) {
		TS_ASSERT(self);
		return ((RadixSort*)self)->getMaxRegions();
	}
	TS_CAPI TSPrefixScan TS_CCALL tsRadixSort_getPrefixScan(TSRadixSort self) {
		TS_ASSERT(self);
		return (TSPrefixScan)(new PrefixScan(((RadixSort*)self)->getPrefixScan()));
	}
	TS_CAPI TSBuffer TS_CCALL tsRadixSort_getDataBuffer(TSRadixSort self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((RadixSort*)self)->getDataBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_create_cDRSMPSuuuA(TSRadixSort self, const TSDevice device, TS_RadixSortMode mode, TSPrefixScan scan, uint32_t size, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(scan);
		return ((RadixSort*)self)->create(*(const Device*)device, (RadixSort::Mode)mode, *(PrefixScan*)scan, size, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_create_cDRSFPSuuuA(TSRadixSort self, const TSDevice device, TS_RadixSortFlags flags, TSPrefixScan scan, uint32_t size, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(scan);
		return ((RadixSort*)self)->create(*(const Device*)device, (RadixSort::Flags)flags, *(PrefixScan*)scan, size, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_dispatch_CBuuuRSFu(TSRadixSort self, TSCompute compute, TSBuffer data, uint32_t keys_offset, uint32_t data_offset, uint32_t size, TS_RadixSortFlags flags, uint32_t bits) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((RadixSort*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, keys_offset, data_offset, size, (RadixSort::Flags)flags, bits);
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_dispatch_CBuupupupRSFu(TSRadixSort self, TSCompute compute, TSBuffer data, uint32_t count, const uint32_t *keys_offsets, const uint32_t *data_offsets, const uint32_t *sizes, TS_RadixSortFlags flags, uint32_t bits) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((RadixSort*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, count, keys_offsets, data_offsets, sizes, (RadixSort::Flags)flags, bits);
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_dispatchIndirect_CBBuRSFuu(TSRadixSort self, TSCompute compute, TSBuffer data, TSBuffer dispatch, uint32_t offset, TS_RadixSortFlags flags, uint32_t bits, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((RadixSort*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)dispatch, offset, (RadixSort::Flags)flags, bits, max_size);
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_dispatchIndirect_CBuBuRSFuu(TSRadixSort self, TSCompute compute, TSBuffer data, uint32_t count, TSBuffer dispatch, uint32_t offset, TS_RadixSortFlags flags, uint32_t bits, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((RadixSort*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, count, *(Buffer*)dispatch, offset, (RadixSort::Flags)flags, bits, max_size);
	}
	TS_CAPI bool_t TS_CCALL tsRadixSort_dispatchIndirect_CBBBuuRSFuu(TSRadixSort self, TSCompute compute, TSBuffer data, TSBuffer count, TSBuffer dispatch, uint32_t count_offset, uint32_t dispatch_offset, TS_RadixSortFlags flags, uint32_t bits, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(count);
		TS_ASSERT(dispatch);
		return ((RadixSort*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)count, *(Buffer*)dispatch, count_offset, dispatch_offset, (RadixSort::Flags)flags, bits, max_size);
	}
	
	// Tellusim::BitonicSort
	TS_CAPI TSBitonicSort TS_CCALL tsBitonicSort_new(void) {
		BitonicSort *ret = new BitonicSort();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBitonicSort)ret;
	}
	TS_CAPI void TS_CCALL tsBitonicSort_delete(TSBitonicSort self) {
		if(self) delete (BitonicSort*)self;
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_equalPtr(const TSBitonicSort self, const TSBitonicSort ptr) {
		return (self && ptr && ((BitonicSort*)self)->operator==(*(BitonicSort*)ptr));
	}
	TS_CAPI TSBitonicSort TS_CCALL tsBitonicSort_copyPtr(TSBitonicSort self) {
		BitonicSort *ret = nullptr;
		if(self) ret = new BitonicSort(*(BitonicSort*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBitonicSort)ret;
	}
	TS_CAPI TSBitonicSort TS_CCALL tsBitonicSort_clonePtr(const TSBitonicSort self) {
		BitonicSort *ret = (self) ? new BitonicSort(((BitonicSort*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSBitonicSort)ret;
	}
	TS_CAPI void TS_CCALL tsBitonicSort_clearPtr(TSBitonicSort self) {
		if(self) ((BitonicSort*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsBitonicSort_destroyPtr(TSBitonicSort self) {
		if(self) ((BitonicSort*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsBitonicSort_acquirePtr(TSBitonicSort self) {
		if(self) ((BitonicSort*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsBitonicSort_unacquirePtr(TSBitonicSort self) {
		if(self) ((BitonicSort*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_isValidPtr(const TSBitonicSort self) {
		return (self && ((BitonicSort*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_isOwnerPtr(const TSBitonicSort self) {
		return (self && ((BitonicSort*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_isConstPtr(const TSBitonicSort self) {
		return (self && ((BitonicSort*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsBitonicSort_getCountPtr(const TSBitonicSort self) {
		return ((BitonicSort*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsBitonicSort_getInternalPtr(const TSBitonicSort self) {
		return ((BitonicSort*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsBitonicSort_clear(TSBitonicSort self) {
		TS_ASSERT(self);
		((BitonicSort*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_isCreated(TSBitonicSort self, TS_BitonicSortFlags flags) {
		TS_ASSERT(self);
		return ((BitonicSort*)self)->isCreated((BitonicSort::Flags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsBitonicSort_getDataSize(TSBitonicSort self) {
		TS_ASSERT(self);
		return ((BitonicSort*)self)->getDataSize();
	}
	TS_CAPI uint32_t TS_CCALL tsBitonicSort_getGroupSize(TSBitonicSort self) {
		TS_ASSERT(self);
		return ((BitonicSort*)self)->getGroupSize();
	}
	TS_CAPI uint32_t TS_CCALL tsBitonicSort_getSortElements(TSBitonicSort self) {
		TS_ASSERT(self);
		return ((BitonicSort*)self)->getSortElements();
	}
	TS_CAPI uint32_t TS_CCALL tsBitonicSort_getMaxRegions(TSBitonicSort self) {
		TS_ASSERT(self);
		return ((BitonicSort*)self)->getMaxRegions();
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_create_cDBSMuuuA(TSBitonicSort self, const TSDevice device, TS_BitonicSortMode mode, uint32_t size, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((BitonicSort*)self)->create(*(const Device*)device, (BitonicSort::Mode)mode, size, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_create_cDBSFuuuA(TSBitonicSort self, const TSDevice device, TS_BitonicSortFlags flags, uint32_t size, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((BitonicSort*)self)->create(*(const Device*)device, (BitonicSort::Flags)flags, size, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_dispatch_CBuuuBSF(TSBitonicSort self, TSCompute compute, TSBuffer data, uint32_t keys_offset, uint32_t data_offset, uint32_t size, TS_BitonicSortFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((BitonicSort*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, keys_offset, data_offset, size, (BitonicSort::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_dispatch_CBuupupupBSF(TSBitonicSort self, TSCompute compute, TSBuffer data, uint32_t count, const uint32_t *keys_offsets, const uint32_t *data_offsets, const uint32_t *sizes, TS_BitonicSortFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((BitonicSort*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, count, keys_offsets, data_offsets, sizes, (BitonicSort::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_dispatchIndirect_CBBuBSF(TSBitonicSort self, TSCompute compute, TSBuffer data, TSBuffer dispatch, uint32_t offset, TS_BitonicSortFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((BitonicSort*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)dispatch, offset, (BitonicSort::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_dispatchIndirect_CBuBuBSF(TSBitonicSort self, TSCompute compute, TSBuffer data, uint32_t count, TSBuffer dispatch, uint32_t offset, TS_BitonicSortFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((BitonicSort*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, count, *(Buffer*)dispatch, offset, (BitonicSort::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsBitonicSort_dispatchIndirect_CBBBuuBSF(TSBitonicSort self, TSCompute compute, TSBuffer data, TSBuffer count, TSBuffer dispatch, uint32_t count_offset, uint32_t dispatch_offset, TS_BitonicSortFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(count);
		TS_ASSERT(dispatch);
		return ((BitonicSort*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)count, *(Buffer*)dispatch, count_offset, dispatch_offset, (BitonicSort::Flags)flags);
	}
	
	// Tellusim::SpatialGrid
	TS_CAPI TSSpatialGrid TS_CCALL tsSpatialGrid_new(void) {
		SpatialGrid *ret = new SpatialGrid();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSpatialGrid)ret;
	}
	TS_CAPI void TS_CCALL tsSpatialGrid_delete(TSSpatialGrid self) {
		if(self) delete (SpatialGrid*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_equalPtr(const TSSpatialGrid self, const TSSpatialGrid ptr) {
		return (self && ptr && ((SpatialGrid*)self)->operator==(*(SpatialGrid*)ptr));
	}
	TS_CAPI TSSpatialGrid TS_CCALL tsSpatialGrid_copyPtr(TSSpatialGrid self) {
		SpatialGrid *ret = nullptr;
		if(self) ret = new SpatialGrid(*(SpatialGrid*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSpatialGrid)ret;
	}
	TS_CAPI TSSpatialGrid TS_CCALL tsSpatialGrid_clonePtr(const TSSpatialGrid self) {
		SpatialGrid *ret = (self) ? new SpatialGrid(((SpatialGrid*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSpatialGrid)ret;
	}
	TS_CAPI void TS_CCALL tsSpatialGrid_clearPtr(TSSpatialGrid self) {
		if(self) ((SpatialGrid*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSpatialGrid_destroyPtr(TSSpatialGrid self) {
		if(self) ((SpatialGrid*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSpatialGrid_acquirePtr(TSSpatialGrid self) {
		if(self) ((SpatialGrid*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSpatialGrid_unacquirePtr(TSSpatialGrid self) {
		if(self) ((SpatialGrid*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_isValidPtr(const TSSpatialGrid self) {
		return (self && ((SpatialGrid*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_isOwnerPtr(const TSSpatialGrid self) {
		return (self && ((SpatialGrid*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_isConstPtr(const TSSpatialGrid self) {
		return (self && ((SpatialGrid*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialGrid_getCountPtr(const TSSpatialGrid self) {
		return ((SpatialGrid*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSpatialGrid_getInternalPtr(const TSSpatialGrid self) {
		return ((SpatialGrid*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsSpatialGrid_clear(TSSpatialGrid self) {
		TS_ASSERT(self);
		((SpatialGrid*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_isCreated(TSSpatialGrid self) {
		TS_ASSERT(self);
		return ((SpatialGrid*)self)->isCreated();
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialGrid_getGroupSize(TSSpatialGrid self) {
		TS_ASSERT(self);
		return ((SpatialGrid*)self)->getGroupSize();
	}
	TS_CAPI TSRadixSort TS_CCALL tsSpatialGrid_getRadixSort(TSSpatialGrid self) {
		TS_ASSERT(self);
		return (TSRadixSort)(new RadixSort(((SpatialGrid*)self)->getRadixSort()));
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_create(TSSpatialGrid self, const TSDevice device, TSRadixSort sort, uint32_t groups) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(sort);
		return ((SpatialGrid*)self)->create(*(const Device*)device, *(RadixSort*)sort, groups);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_dispatch(TSSpatialGrid self, TSCompute compute, TSBuffer data, uint32_t offset, uint32_t size, uint32_t bits) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		return ((SpatialGrid*)self)->dispatch(*(Compute*)compute, *(Buffer*)data, offset, size, bits);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialGrid_dispatchIndirect(TSSpatialGrid self, TSCompute compute, TSBuffer data, TSBuffer dispatch, uint32_t offset, uint32_t max_size) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(data);
		TS_ASSERT(dispatch);
		return ((SpatialGrid*)self)->dispatchIndirect(*(Compute*)compute, *(Buffer*)data, *(Buffer*)dispatch, offset, max_size);
	}
	
	// Tellusim::SpatialTree
	TS_CAPI TSSpatialTree TS_CCALL tsSpatialTree_new(void) {
		SpatialTree *ret = new SpatialTree();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSpatialTree)ret;
	}
	TS_CAPI void TS_CCALL tsSpatialTree_delete(TSSpatialTree self) {
		if(self) delete (SpatialTree*)self;
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_equalPtr(const TSSpatialTree self, const TSSpatialTree ptr) {
		return (self && ptr && ((SpatialTree*)self)->operator==(*(SpatialTree*)ptr));
	}
	TS_CAPI TSSpatialTree TS_CCALL tsSpatialTree_copyPtr(TSSpatialTree self) {
		SpatialTree *ret = nullptr;
		if(self) ret = new SpatialTree(*(SpatialTree*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSpatialTree)ret;
	}
	TS_CAPI TSSpatialTree TS_CCALL tsSpatialTree_clonePtr(const TSSpatialTree self) {
		SpatialTree *ret = (self) ? new SpatialTree(((SpatialTree*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSSpatialTree)ret;
	}
	TS_CAPI void TS_CCALL tsSpatialTree_clearPtr(TSSpatialTree self) {
		if(self) ((SpatialTree*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsSpatialTree_destroyPtr(TSSpatialTree self) {
		if(self) ((SpatialTree*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsSpatialTree_acquirePtr(TSSpatialTree self) {
		if(self) ((SpatialTree*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsSpatialTree_unacquirePtr(TSSpatialTree self) {
		if(self) ((SpatialTree*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_isValidPtr(const TSSpatialTree self) {
		return (self && ((SpatialTree*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_isOwnerPtr(const TSSpatialTree self) {
		return (self && ((SpatialTree*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_isConstPtr(const TSSpatialTree self) {
		return (self && ((SpatialTree*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialTree_getCountPtr(const TSSpatialTree self) {
		return ((SpatialTree*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsSpatialTree_getInternalPtr(const TSSpatialTree self) {
		return ((SpatialTree*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsSpatialTree_clear(TSSpatialTree self) {
		TS_ASSERT(self);
		((SpatialTree*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_isCreated(TSSpatialTree self, TS_SpatialTreeFlags flags) {
		TS_ASSERT(self);
		return ((SpatialTree*)self)->isCreated((SpatialTree::Flags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialTree_getGroupSize(TSSpatialTree self) {
		TS_ASSERT(self);
		return ((SpatialTree*)self)->getGroupSize();
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialTree_getBoundsNodes(TSSpatialTree self) {
		TS_ASSERT(self);
		return ((SpatialTree*)self)->getBoundsNodes();
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialTree_getMaxNodes(TSSpatialTree self) {
		TS_ASSERT(self);
		return ((SpatialTree*)self)->getMaxNodes();
	}
	TS_CAPI uint32_t TS_CCALL tsSpatialTree_getMaxRegions(TSSpatialTree self) {
		TS_ASSERT(self);
		return ((SpatialTree*)self)->getMaxRegions();
	}
	TS_CAPI TSRadixSort TS_CCALL tsSpatialTree_getRadixSort(TSSpatialTree self) {
		TS_ASSERT(self);
		return (TSRadixSort)(new RadixSort(((SpatialTree*)self)->getRadixSort()));
	}
	TS_CAPI TSBuffer TS_CCALL tsSpatialTree_getHashBuffer(TSSpatialTree self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((SpatialTree*)self)->getHashBuffer()));
	}
	TS_CAPI TSBuffer TS_CCALL tsSpatialTree_getParentsBuffer(TSSpatialTree self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((SpatialTree*)self)->getParentsBuffer()));
	}
	TS_CAPI TSBuffer TS_CCALL tsSpatialTree_getCounterBuffer(TSSpatialTree self) {
		TS_ASSERT(self);
		return (TSBuffer)(new Buffer(((SpatialTree*)self)->getCounterBuffer()));
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_create_cDSTMRSuuuA(TSSpatialTree self, const TSDevice device, TS_SpatialTreeMode mode, TSRadixSort sort, uint32_t size, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(sort);
		return ((SpatialTree*)self)->create(*(const Device*)device, (SpatialTree::Mode)mode, *(RadixSort*)sort, size, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_create_cDSTFRSuuuA(TSSpatialTree self, const TSDevice device, TS_SpatialTreeFlags flags, TSRadixSort sort, uint32_t size, uint32_t groups, uint32_t regions, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		TS_ASSERT(sort);
		return ((SpatialTree*)self)->create(*(const Device*)device, (SpatialTree::Flags)flags, *(RadixSort*)sort, size, groups, regions, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_dispatch_CSTHBuuSTF(TSSpatialTree self, TSCompute compute, TS_SpatialTreeHash hash, TSBuffer nodes, uint32_t offset, uint32_t size, TS_SpatialTreeFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(nodes);
		return ((SpatialTree*)self)->dispatch(*(Compute*)compute, (SpatialTree::Hash)hash, *(Buffer*)nodes, offset, size, (SpatialTree::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_dispatch_CSTHBuupupSTF(TSSpatialTree self, TSCompute compute, TS_SpatialTreeHash hash, TSBuffer nodes, uint32_t count, const uint32_t *offsets, const uint32_t *sizes, TS_SpatialTreeFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(nodes);
		return ((SpatialTree*)self)->dispatch(*(Compute*)compute, (SpatialTree::Hash)hash, *(Buffer*)nodes, count, offsets, sizes, (SpatialTree::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_dispatchIndirect_CSTHBBuuSTF(TSSpatialTree self, TSCompute compute, TS_SpatialTreeHash hash, TSBuffer nodes, TSBuffer dispatch, uint32_t offset, uint32_t max_size, TS_SpatialTreeFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(nodes);
		TS_ASSERT(dispatch);
		return ((SpatialTree*)self)->dispatchIndirect(*(Compute*)compute, (SpatialTree::Hash)hash, *(Buffer*)nodes, *(Buffer*)dispatch, offset, max_size, (SpatialTree::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsSpatialTree_dispatchIndirect_CSTHBuBuuSTF(TSSpatialTree self, TSCompute compute, TS_SpatialTreeHash hash, TSBuffer nodes, uint32_t count, TSBuffer dispatch, uint32_t offset, uint32_t max_size, TS_SpatialTreeFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(nodes);
		TS_ASSERT(dispatch);
		return ((SpatialTree*)self)->dispatchIndirect(*(Compute*)compute, (SpatialTree::Hash)hash, *(Buffer*)nodes, count, *(Buffer*)dispatch, offset, max_size, (SpatialTree::Flags)flags);
	}
	
	// Tellusim::FourierTransform
	TS_CAPI TSFourierTransform TS_CCALL tsFourierTransform_new(void) {
		FourierTransform *ret = new FourierTransform();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFourierTransform)ret;
	}
	TS_CAPI void TS_CCALL tsFourierTransform_delete(TSFourierTransform self) {
		if(self) delete (FourierTransform*)self;
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_equalPtr(const TSFourierTransform self, const TSFourierTransform ptr) {
		return (self && ptr && ((FourierTransform*)self)->operator==(*(FourierTransform*)ptr));
	}
	TS_CAPI TSFourierTransform TS_CCALL tsFourierTransform_copyPtr(TSFourierTransform self) {
		FourierTransform *ret = nullptr;
		if(self) ret = new FourierTransform(*(FourierTransform*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFourierTransform)ret;
	}
	TS_CAPI TSFourierTransform TS_CCALL tsFourierTransform_clonePtr(const TSFourierTransform self) {
		FourierTransform *ret = (self) ? new FourierTransform(((FourierTransform*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSFourierTransform)ret;
	}
	TS_CAPI void TS_CCALL tsFourierTransform_clearPtr(TSFourierTransform self) {
		if(self) ((FourierTransform*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsFourierTransform_destroyPtr(TSFourierTransform self) {
		if(self) ((FourierTransform*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsFourierTransform_acquirePtr(TSFourierTransform self) {
		if(self) ((FourierTransform*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsFourierTransform_unacquirePtr(TSFourierTransform self) {
		if(self) ((FourierTransform*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_isValidPtr(const TSFourierTransform self) {
		return (self && ((FourierTransform*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_isOwnerPtr(const TSFourierTransform self) {
		return (self && ((FourierTransform*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_isConstPtr(const TSFourierTransform self) {
		return (self && ((FourierTransform*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsFourierTransform_getCountPtr(const TSFourierTransform self) {
		return ((FourierTransform*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsFourierTransform_getInternalPtr(const TSFourierTransform self) {
		return ((FourierTransform*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsFourierTransform_clear(TSFourierTransform self) {
		TS_ASSERT(self);
		((FourierTransform*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_isCreated_cFTM(TSFourierTransform self, TS_FourierTransformMode mode) {
		TS_ASSERT(self);
		return ((FourierTransform*)self)->isCreated((FourierTransform::Mode)mode);
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_isCreated_cFTF(TSFourierTransform self, TS_FourierTransformFlags flags) {
		TS_ASSERT(self);
		return ((FourierTransform*)self)->isCreated((FourierTransform::Flags)flags);
	}
	TS_CAPI uint32_t TS_CCALL tsFourierTransform_getMaxWidth(TSFourierTransform self) {
		TS_ASSERT(self);
		return ((FourierTransform*)self)->getMaxWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsFourierTransform_getMaxHeight(TSFourierTransform self) {
		TS_ASSERT(self);
		return ((FourierTransform*)self)->getMaxHeight();
	}
	TS_CAPI uint32_t TS_CCALL tsFourierTransform_getAlignedSize(TSFourierTransform self, uint32_t size) {
		TS_ASSERT(self);
		return ((FourierTransform*)self)->getAlignedSize(size);
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_create_cDFTMuuA(TSFourierTransform self, const TSDevice device, TS_FourierTransformMode mode, uint32_t width, uint32_t height, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((FourierTransform*)self)->create(*(const Device*)device, (FourierTransform::Mode)mode, width, height, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_create_cDFTFuuA(TSFourierTransform self, const TSDevice device, TS_FourierTransformFlags flags, uint32_t width, uint32_t height, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((FourierTransform*)self)->create(*(const Device*)device, (FourierTransform::Flags)flags, width, height, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_dispatch_cCFTMFTOTTcScS(TSFourierTransform self, TSCompute compute, TS_FourierTransformMode mode, TS_FourierTransformOperation op, TSTexture dest, TSTexture src, const TSSlice *dest_slice, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((FourierTransform*)self)->dispatch(*(Compute*)compute, (FourierTransform::Mode)mode, (FourierTransform::Operation)op, *(Texture*)dest, *(Texture*)src, (dest_slice) ? *(const Slice*)dest_slice : Slice(), (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_dispatch_cCFTMFTOTTcS(TSFourierTransform self, TSCompute compute, TS_FourierTransformMode mode, TS_FourierTransformOperation op, TSTexture dest, TSTexture src, const TSSlice *src_slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((FourierTransform*)self)->dispatch(*(Compute*)compute, (FourierTransform::Mode)mode, (FourierTransform::Operation)op, *(Texture*)dest, *(Texture*)src, (src_slice) ? *(const Slice*)src_slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsFourierTransform_dispatch_cCFTMFTOTT(TSFourierTransform self, TSCompute compute, TS_FourierTransformMode mode, TS_FourierTransformOperation op, TSTexture dest, TSTexture src) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((FourierTransform*)self)->dispatch(*(Compute*)compute, (FourierTransform::Mode)mode, (FourierTransform::Operation)op, *(Texture*)dest, *(Texture*)src);
	}
	
	// Tellusim::TensorGraph
	TS_CAPI TSTensorGraph TS_CCALL tsTensorGraph_new(void) {
		TensorGraph *ret = new TensorGraph();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTensorGraph)ret;
	}
	TS_CAPI void TS_CCALL tsTensorGraph_delete(TSTensorGraph self) {
		if(self) delete (TensorGraph*)self;
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_equalPtr(const TSTensorGraph self, const TSTensorGraph ptr) {
		return (self && ptr && ((TensorGraph*)self)->operator==(*(TensorGraph*)ptr));
	}
	TS_CAPI TSTensorGraph TS_CCALL tsTensorGraph_copyPtr(TSTensorGraph self) {
		TensorGraph *ret = nullptr;
		if(self) ret = new TensorGraph(*(TensorGraph*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTensorGraph)ret;
	}
	TS_CAPI TSTensorGraph TS_CCALL tsTensorGraph_clonePtr(const TSTensorGraph self) {
		TensorGraph *ret = (self) ? new TensorGraph(((TensorGraph*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSTensorGraph)ret;
	}
	TS_CAPI void TS_CCALL tsTensorGraph_clearPtr(TSTensorGraph self) {
		if(self) ((TensorGraph*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsTensorGraph_destroyPtr(TSTensorGraph self) {
		if(self) ((TensorGraph*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsTensorGraph_acquirePtr(TSTensorGraph self) {
		if(self) ((TensorGraph*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsTensorGraph_unacquirePtr(TSTensorGraph self) {
		if(self) ((TensorGraph*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_isValidPtr(const TSTensorGraph self) {
		return (self && ((TensorGraph*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_isOwnerPtr(const TSTensorGraph self) {
		return (self && ((TensorGraph*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_isConstPtr(const TSTensorGraph self) {
		return (self && ((TensorGraph*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsTensorGraph_getCountPtr(const TSTensorGraph self) {
		return ((TensorGraph*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsTensorGraph_getInternalPtr(const TSTensorGraph self) {
		return ((TensorGraph*)self)->getInternalPtr();
	}
	TS_CAPI void TS_CCALL tsTensorGraph_clear(TSTensorGraph self) {
		TS_ASSERT(self);
		((TensorGraph*)self)->clear();
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_isCreated(TSTensorGraph self) {
		TS_ASSERT(self);
		return ((TensorGraph*)self)->isCreated();
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_create(TSTensorGraph self, const TSDevice device, TS_TensorGraphFlags flags, TS_TensorGraphMasks masks, TSAsync *async) {
		TS_ASSERT(self);
		TS_ASSERT(device);
		return ((TensorGraph*)self)->create(*(const Device*)device, (TensorGraph::Flags)flags, (TensorGraph::Masks)masks, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCTGOcTTGF(TSTensorGraph self, TSCompute compute, TS_TensorGraphOperation op, const TSTensor *dest, TS_TensorGraphFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, (TensorGraph::Operation)op, *(const Tensor*)dest, (TensorGraph::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCTGOTcTTGF(TSTensorGraph self, TSCompute compute, TS_TensorGraphOperation op, TSTensor *dest, const TSTensor *src_0, TS_TensorGraphFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src_0);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, (TensorGraph::Operation)op, *(Tensor*)dest, *(const Tensor*)src_0, (TensorGraph::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCTGOTcTcTTGF(TSTensorGraph self, TSCompute compute, TS_TensorGraphOperation op, TSTensor *dest, const TSTensor *src_0, const TSTensor *src_1, TS_TensorGraphFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src_0);
		TS_ASSERT(src_1);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, (TensorGraph::Operation)op, *(Tensor*)dest, *(const Tensor*)src_0, *(const Tensor*)src_1, (TensorGraph::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCTGOTcTcTcTTGF(TSTensorGraph self, TSCompute compute, TS_TensorGraphOperation op, TSTensor *dest, const TSTensor *src_0, const TSTensor *src_1, const TSTensor *src_2, TS_TensorGraphFlags flags) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src_0);
		TS_ASSERT(src_1);
		TS_ASSERT(src_2);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, (TensorGraph::Operation)op, *(Tensor*)dest, *(const Tensor*)src_0, *(const Tensor*)src_1, *(const Tensor*)src_2, (TensorGraph::Flags)flags);
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCcTTcRcS(TSTensorGraph self, TSCompute compute, const TSTensor *dest, TSTexture src, const TSRegion *region, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		TS_ASSERT(region);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, *(const Tensor*)dest, *(Texture*)src, *(const Region*)region, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCcTTcS(TSTensorGraph self, TSCompute compute, const TSTensor *dest, TSTexture src, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, *(const Tensor*)dest, *(Texture*)src, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCTcTcRcS(TSTensorGraph self, TSCompute compute, TSTexture dest, const TSTensor *src, const TSRegion *region, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		TS_ASSERT(region);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, *(Texture*)dest, *(const Tensor*)src, *(const Region*)region, (slice) ? *(const Slice*)slice : Slice());
	}
	TS_CAPI bool_t TS_CCALL tsTensorGraph_dispatch_cCTcTcS(TSTensorGraph self, TSCompute compute, TSTexture dest, const TSTensor *src, const TSSlice *slice) {
		TS_ASSERT(self);
		TS_ASSERT(compute);
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return ((TensorGraph*)self)->dispatch(*(Compute*)compute, *(Texture*)dest, *(const Tensor*)src, (slice) ? *(const Slice*)slice : Slice());
	}
	
	// Tellusim::Controller
	TS_CAPI TSController TS_CCALL tsController_new(void) {
		Controller *ret = new Controller();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSController)ret;
	}
	TS_CAPI TSController TS_CCALL tsController_new_u(uint32_t index) {
		Controller *ret = new Controller(index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSController)ret;
	}
	TS_CAPI TSController TS_CCALL tsController_new_CTu(TS_ControllerType type, uint32_t index) {
		Controller *ret = new Controller((Controller::Type)type, index);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSController)ret;
	}
	TS_CAPI void TS_CCALL tsController_delete(TSController self) {
		if(self) delete (Controller*)self;
	}
	TS_CAPI bool_t TS_CCALL tsController_equalPtr(const TSController self, const TSController ptr) {
		return (self && ptr && ((Controller*)self)->operator==(*(Controller*)ptr));
	}
	TS_CAPI TSController TS_CCALL tsController_copyPtr(TSController self) {
		Controller *ret = nullptr;
		if(self) ret = new Controller(*(Controller*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSController)ret;
	}
	TS_CAPI TSController TS_CCALL tsController_clonePtr(const TSController self) {
		Controller *ret = (self) ? new Controller(((Controller*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSController)ret;
	}
	TS_CAPI void TS_CCALL tsController_clearPtr(TSController self) {
		if(self) ((Controller*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsController_destroyPtr(TSController self) {
		if(self) ((Controller*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsController_acquirePtr(TSController self) {
		if(self) ((Controller*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsController_unacquirePtr(TSController self) {
		if(self) ((Controller*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsController_isValidPtr(const TSController self) {
		return (self && ((Controller*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsController_isOwnerPtr(const TSController self) {
		return (self && ((Controller*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsController_isConstPtr(const TSController self) {
		return (self && ((Controller*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsController_getCountPtr(const TSController self) {
		return ((Controller*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsController_getInternalPtr(const TSController self) {
		return ((Controller*)self)->getInternalPtr();
	}
	TS_CAPI uint32_t TS_CCALL tsController_getNumControllers(void) {
		return Controller::getNumControllers();
	}
	TS_CAPI uint32_t TS_CCALL tsController_findController(const char *name) {
		return Controller::findController(name);
	}
	TS_CAPI TSController TS_CCALL tsController_getController(uint32_t index) {
		return (TSController)(new Controller(Controller::getController(index)));
	}
	TS_CAPI void TS_CCALL tsController_update(void) {
		Controller::update();
	}
	TS_CAPI void TS_CCALL tsController_setType(TSController self, TS_ControllerType type) {
		TS_ASSERT(self);
		((Controller*)self)->setType((Controller::Type)type);
	}
	TS_CAPI TS_ControllerType TS_CCALL tsController_getType(TSController self) {
		TS_ASSERT(self);
		return (TS_ControllerType)((Controller*)self)->getType();
	}
	TS_CAPI const char* TS_CCALL tsController_getTypeName_CT(TS_ControllerType type) {
		return Controller::getTypeName((Controller::Type)type);
	}
	TS_CAPI const char* TS_CCALL tsController_getTypeName_c(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->getTypeName();
	}
	TS_CAPI bool_t TS_CCALL tsController_isUnknown(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->isUnknown();
	}
	TS_CAPI bool_t TS_CCALL tsController_isJoystick(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->isJoystick();
	}
	TS_CAPI bool_t TS_CCALL tsController_isGamePad(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->isGamePad();
	}
	TS_CAPI bool_t TS_CCALL tsController_isWheel(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->isWheel();
	}
	TS_CAPI void TS_CCALL tsController_setIndex(TSController self, uint32_t index) {
		TS_ASSERT(self);
		((Controller*)self)->setIndex(index);
	}
	TS_CAPI uint32_t TS_CCALL tsController_getIndex(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->getIndex();
	}
	TS_CAPI void TS_CCALL tsController_setName(TSController self, const char *name) {
		TS_ASSERT(self);
		((Controller*)self)->setName(name);
	}
	TS_CAPI TSString TS_CCALL tsController_getName(TSController self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Controller*)self)->getName()));
	}
	TS_CAPI void TS_CCALL tsController_setModel(TSController self, const char *model) {
		TS_ASSERT(self);
		((Controller*)self)->setModel(model);
	}
	TS_CAPI TSString TS_CCALL tsController_getModel(TSController self) {
		TS_ASSERT(self);
		return (TSString)(new String(((Controller*)self)->getModel()));
	}
	TS_CAPI bool_t TS_CCALL tsController_isConnected(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->isConnected();
	}
	TS_CAPI bool_t TS_CCALL tsController_wasConnected(TSController self) {
		TS_ASSERT(self);
		return ((Controller*)self)->wasConnected();
	}
	TS_CAPI bool_t TS_CCALL tsController_connect(TSController self, const char *name) {
		TS_ASSERT(self);
		return ((Controller*)self)->connect(name);
	}
	TS_CAPI void TS_CCALL tsController_release(TSController self) {
		TS_ASSERT(self);
		((Controller*)self)->release();
	}
	TS_CAPI void TS_CCALL tsController_setStickName(TSController self, TS_ControllerStick stick, const char *name) {
		TS_ASSERT(self);
		((Controller*)self)->setStickName((Controller::Stick)stick, name);
	}
	TS_CAPI TSString TS_CCALL tsController_getStickName(TSController self, TS_ControllerStick stick) {
		TS_ASSERT(self);
		return (TSString)(new String(((Controller*)self)->getStickName((Controller::Stick)stick)));
	}
	TS_CAPI TS_ControllerStick TS_CCALL tsController_findStick(TSController self, const char *name) {
		TS_ASSERT(self);
		return (TS_ControllerStick)((Controller*)self)->findStick(name);
	}
	TS_CAPI void TS_CCALL tsController_setStick(TSController self, TS_ControllerStick stick, float32_t x, float32_t y) {
		TS_ASSERT(self);
		((Controller*)self)->setStick((Controller::Stick)stick, x, y);
	}
	TS_CAPI float32_t TS_CCALL tsController_getStickX(TSController self, TS_ControllerStick stick) {
		TS_ASSERT(self);
		return ((Controller*)self)->getStickX((Controller::Stick)stick);
	}
	TS_CAPI float32_t TS_CCALL tsController_getStickY(TSController self, TS_ControllerStick stick) {
		TS_ASSERT(self);
		return ((Controller*)self)->getStickY((Controller::Stick)stick);
	}
	TS_CAPI void TS_CCALL tsController_setAxisName(TSController self, TS_ControllerAxis axis, const char *name) {
		TS_ASSERT(self);
		((Controller*)self)->setAxisName((Controller::Axis)axis, name);
	}
	TS_CAPI TSString TS_CCALL tsController_getAxisName(TSController self, TS_ControllerAxis axis) {
		TS_ASSERT(self);
		return (TSString)(new String(((Controller*)self)->getAxisName((Controller::Axis)axis)));
	}
	TS_CAPI TS_ControllerAxis TS_CCALL tsController_findAxis(TSController self, const char *name) {
		TS_ASSERT(self);
		return (TS_ControllerAxis)((Controller*)self)->findAxis(name);
	}
	TS_CAPI void TS_CCALL tsController_setAxis(TSController self, TS_ControllerAxis axis, float32_t value) {
		TS_ASSERT(self);
		((Controller*)self)->setAxis((Controller::Axis)axis, value);
	}
	TS_CAPI float32_t TS_CCALL tsController_getAxis(TSController self, TS_ControllerAxis axis) {
		TS_ASSERT(self);
		return ((Controller*)self)->getAxis((Controller::Axis)axis);
	}
	TS_CAPI void TS_CCALL tsController_setButtonName(TSController self, TS_ControllerButton button, const char *name) {
		TS_ASSERT(self);
		((Controller*)self)->setButtonName((Controller::Button)button, name);
	}
	TS_CAPI TSString TS_CCALL tsController_getButtonName(TSController self, TS_ControllerButton button) {
		TS_ASSERT(self);
		return (TSString)(new String(((Controller*)self)->getButtonName((Controller::Button)button)));
	}
	TS_CAPI TS_ControllerButton TS_CCALL tsController_findButton(TSController self, const char *name) {
		TS_ASSERT(self);
		return (TS_ControllerButton)((Controller*)self)->findButton(name);
	}
	TS_CAPI void TS_CCALL tsController_setButton(TSController self, TS_ControllerButton button, bool_t value) {
		TS_ASSERT(self);
		((Controller*)self)->setButton((Controller::Button)button, (bool)value);
	}
	TS_CAPI bool_t TS_CCALL tsController_getButton(TSController self, TS_ControllerButton button, bool_t clear) {
		TS_ASSERT(self);
		return ((Controller*)self)->getButton((Controller::Button)button, (bool)clear);
	}
	TS_CAPI void TS_CCALL tsController_setButtonValue(TSController self, TS_ControllerButton button, float32_t value) {
		TS_ASSERT(self);
		((Controller*)self)->setButtonValue((Controller::Button)button, value);
	}
	TS_CAPI float32_t TS_CCALL tsController_getButtonValue(TSController self, TS_ControllerButton button) {
		TS_ASSERT(self);
		return ((Controller*)self)->getButtonValue((Controller::Button)button);
	}
	TS_CAPI void TS_CCALL tsController_setMotorName(TSController self, TS_ControllerMotor motor, const char *name) {
		TS_ASSERT(self);
		((Controller*)self)->setMotorName((Controller::Motor)motor, name);
	}
	TS_CAPI TSString TS_CCALL tsController_getMotorName(TSController self, TS_ControllerMotor motor) {
		TS_ASSERT(self);
		return (TSString)(new String(((Controller*)self)->getMotorName((Controller::Motor)motor)));
	}
	TS_CAPI TS_ControllerMotor TS_CCALL tsController_findMotor(TSController self, const char *name) {
		TS_ASSERT(self);
		return (TS_ControllerMotor)((Controller*)self)->findMotor(name);
	}
	TS_CAPI void TS_CCALL tsController_setMotor(TSController self, TS_ControllerMotor motor, float32_t value) {
		TS_ASSERT(self);
		((Controller*)self)->setMotor((Controller::Motor)motor, value);
	}
	TS_CAPI float32_t TS_CCALL tsController_getMotor(TSController self, TS_ControllerMotor motor) {
		TS_ASSERT(self);
		return ((Controller*)self)->getMotor((Controller::Motor)motor);
	}
	TS_CAPI void TS_CCALL tsController_setButtonPressedCallback(TSController self, const TSControllerButtonPressedCallback func, void *data_) {
		TS_ASSERT(self);
		((Controller*)self)->setButtonPressedCallback(makeTSControllerButtonPressedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsController_setButtonReleasedCallback(TSController self, const TSControllerButtonReleasedCallback func, void *data_) {
		TS_ASSERT(self);
		((Controller*)self)->setButtonReleasedCallback(makeTSControllerButtonReleasedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsController_setConnectedCallback(TSController self, const TSControllerConnectedCallback func, void *data_) {
		TS_ASSERT(self);
		((Controller*)self)->setConnectedCallback(makeTSControllerConnectedCallback(func, data_));
	}
	TS_CAPI void TS_CCALL tsController_setDisconnectedCallback(TSController self, const TSControllerDisconnectedCallback func, void *data_) {
		TS_ASSERT(self);
		((Controller*)self)->setDisconnectedCallback(makeTSControllerDisconnectedCallback(func, data_));
	}
	TS_CAPI const char* tsControllerNameXbox = Controller::NameXbox;
	TS_CAPI const char* tsControllerNamePlayStation = Controller::NamePlayStation;
	TS_CAPI const char* tsControllerNameNintendo = Controller::NameNintendo;
	
	// Tellusim::Desktop
	TS_CAPI TSDesktop TS_CCALL tsDesktop_new(void) {
		Desktop *ret = new Desktop();
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDesktop)ret;
	}
	TS_CAPI void TS_CCALL tsDesktop_delete(TSDesktop self) {
		if(self) delete (Desktop*)self;
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_equalPtr(const TSDesktop self, const TSDesktop ptr) {
		return (self && ptr && ((Desktop*)self)->operator==(*(Desktop*)ptr));
	}
	TS_CAPI TSDesktop TS_CCALL tsDesktop_copyPtr(TSDesktop self) {
		Desktop *ret = nullptr;
		if(self) ret = new Desktop(*(Desktop*)self);
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDesktop)ret;
	}
	TS_CAPI TSDesktop TS_CCALL tsDesktop_clonePtr(const TSDesktop self) {
		Desktop *ret = (self) ? new Desktop(((Desktop*)self)->clonePtr()) : nullptr;
		if(ret && !ret->isValidPtr()) { delete ret; ret = nullptr; }
		return (TSDesktop)ret;
	}
	TS_CAPI void TS_CCALL tsDesktop_clearPtr(TSDesktop self) {
		if(self) ((Desktop*)self)->clearPtr();
	}
	TS_CAPI void TS_CCALL tsDesktop_destroyPtr(TSDesktop self) {
		if(self) ((Desktop*)self)->destroyPtr();
	}
	TS_CAPI void TS_CCALL tsDesktop_acquirePtr(TSDesktop self) {
		if(self) ((Desktop*)self)->acquirePtr();
	}
	TS_CAPI void TS_CCALL tsDesktop_unacquirePtr(TSDesktop self) {
		if(self) ((Desktop*)self)->unacquirePtr();
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_isValidPtr(const TSDesktop self) {
		return (self && ((Desktop*)self)->isValidPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_isOwnerPtr(const TSDesktop self) {
		return (self && ((Desktop*)self)->isOwnerPtr());
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_isConstPtr(const TSDesktop self) {
		return (self && ((Desktop*)self)->isConstPtr());
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getCountPtr(const TSDesktop self) {
		return ((Desktop*)self)->getCountPtr();
	}
	TS_CAPI const void* TS_CCALL tsDesktop_getInternalPtr(const TSDesktop self) {
		return ((Desktop*)self)->getInternalPtr();
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_update(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->update();
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getWidth_c(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getWidth();
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getHeight_c(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getHeight();
	}
	TS_CAPI int32_t TS_CCALL tsDesktop_getPositionX_c(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getPositionX();
	}
	TS_CAPI int32_t TS_CCALL tsDesktop_getPositionY_c(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getPositionY();
	}
	TS_CAPI float32_t TS_CCALL tsDesktop_getScale(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScale();
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getNumScreens(TSDesktop self) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getNumScreens();
	}
	TS_CAPI TSString TS_CCALL tsDesktop_getScreenName(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Desktop*)self)->getScreenName(index)));
	}
	TS_CAPI TSString TS_CCALL tsDesktop_getScreenDevice(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return (TSString)(new String(((Desktop*)self)->getScreenDevice(index)));
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getScreenWidth(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScreenWidth(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getScreenHeight(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScreenHeight(index);
	}
	TS_CAPI int32_t TS_CCALL tsDesktop_getScreenPositionX(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScreenPositionX(index);
	}
	TS_CAPI int32_t TS_CCALL tsDesktop_getScreenPositionY(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScreenPositionY(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getScreenFrequency(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScreenFrequency(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getNumModes(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getNumModes(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getModeWidth(TSDesktop self, uint32_t index, uint32_t mode) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getModeWidth(index, mode);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getModeHeight(TSDesktop self, uint32_t index, uint32_t mode) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getModeHeight(index, mode);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getModeIndex(TSDesktop self, uint32_t index, uint32_t width, uint32_t height) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getModeIndex(index, width, height);
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_setMode(TSDesktop self, uint32_t index, uint32_t width, uint32_t height) {
		TS_ASSERT(self);
		return ((Desktop*)self)->setMode(index, width, height);
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_restoreMode(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->restoreMode(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getWidth_cu(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getWidth(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getHeight_cu(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getHeight(index);
	}
	TS_CAPI int32_t TS_CCALL tsDesktop_getPositionX_cu(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getPositionX(index);
	}
	TS_CAPI int32_t TS_CCALL tsDesktop_getPositionY_cu(TSDesktop self, uint32_t index) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getPositionY(index);
	}
	TS_CAPI uint32_t TS_CCALL tsDesktop_getScreenIndex(TSDesktop self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		return ((Desktop*)self)->getScreenIndex(x, y);
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_setMouse(TSDesktop self, int32_t x, int32_t y) {
		TS_ASSERT(self);
		return ((Desktop*)self)->setMouse(x, y);
	}
	TS_CAPI bool_t TS_CCALL tsDesktop_getMouse(TSDesktop self, int32_t *x, int32_t *y) {
		TS_ASSERT(self);
		TS_ASSERT(x);
		TS_ASSERT(y);
		return ((Desktop*)self)->getMouse(*x, *y);
	}
	TS_CAPI const char* TS_CCALL ts_getPlatformName(TS_Platform platform) {
		return getPlatformName((Platform)platform);
	}
	TS_CAPI TS_Platform TS_CCALL ts_findPlatformName(const char *name) {
		return (TS_Platform)findPlatformName(name);
	}
	TS_CAPI bool_t TS_CCALL ts_isPlatformAvailable(TS_Platform platform) {
		return isPlatformAvailable((Platform)platform);
	}
	TS_CAPI const char* TS_CCALL ts_getFormatName(TS_Format format) {
		return getFormatName((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_findFormatName(const char *name) {
		return (TS_Format)findFormatName(name);
	}
	TS_CAPI const char* TS_CCALL ts_getGLSLFormatName(TS_Format format) {
		return getGLSLFormatName((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_findGLSLFormatName(const char *name) {
		return (TS_Format)findGLSLFormatName(name);
	}
	TS_CAPI bool_t TS_CCALL ts_isColorFormat(TS_Format format) {
		return isColorFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isDepthFormat(TS_Format format) {
		return isDepthFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isPixelFormat(TS_Format format) {
		return isPixelFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isPlainFormat(TS_Format format) {
		return isPlainFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isMixedFormat(TS_Format format) {
		return isMixedFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isBlockFormat(TS_Format format) {
		return isBlockFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isStencilFormat(TS_Format format) {
		return isStencilFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toPixelFormat(TS_Format format) {
		return (TS_Format)toPixelFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isNormFormat(TS_Format format) {
		return isNormFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isSRGBFormat(TS_Format format) {
		return isSRGBFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isSignedFormat(TS_Format format) {
		return isSignedFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isUnsignedFormat(TS_Format format) {
		return isUnsignedFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isIntegerFormat(TS_Format format) {
		return isIntegerFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isFloatFormat(TS_Format format) {
		return isFloatFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toNormFormat(TS_Format format) {
		return (TS_Format)toNormFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toSRGBFormat(TS_Format format) {
		return (TS_Format)toSRGBFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toSignedFormat(TS_Format format) {
		return (TS_Format)toSignedFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toUnsignedFormat(TS_Format format) {
		return (TS_Format)toUnsignedFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toFloatFormat(TS_Format format) {
		return (TS_Format)toFloatFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isi8Format(TS_Format format) {
		return isi8Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isu8Format(TS_Format format) {
		return isu8Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_is8BitFormat(TS_Format format) {
		return is8BitFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_to8BitFormat(TS_Format format) {
		return (TS_Format)to8BitFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isi16Format(TS_Format format) {
		return isi16Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isu16Format(TS_Format format) {
		return isu16Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isf16Format(TS_Format format) {
		return isf16Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_is16BitFormat(TS_Format format) {
		return is16BitFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_to16BitFormat(TS_Format format) {
		return (TS_Format)to16BitFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isi32Format(TS_Format format) {
		return isi32Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isu32Format(TS_Format format) {
		return isu32Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isf32Format(TS_Format format) {
		return isf32Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_is32BitFormat(TS_Format format) {
		return is32BitFormat((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_to32BitFormat(TS_Format format) {
		return (TS_Format)to32BitFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isi64Format(TS_Format format) {
		return isi64Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isu64Format(TS_Format format) {
		return isu64Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isf64Format(TS_Format format) {
		return isf64Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_is64BitFormat(TS_Format format) {
		return is64BitFormat((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isBC15Format(TS_Format format) {
		return isBC15Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isBC67Format(TS_Format format) {
		return isBC67Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isETC2Format(TS_Format format) {
		return isETC2Format((Format)format);
	}
	TS_CAPI bool_t TS_CCALL ts_isASTCFormat(TS_Format format) {
		return isASTCFormat((Format)format);
	}
	TS_CAPI uint32_t TS_CCALL ts_getFormatComponents(TS_Format format) {
		return getFormatComponents((Format)format);
	}
	TS_CAPI TS_Format TS_CCALL ts_toFormatComponents(TS_Format format, uint32_t components) {
		return (TS_Format)toFormatComponents((Format)format, components);
	}
	TS_CAPI uint32_t TS_CCALL ts_getFormatPixelSize(TS_Format format) {
		return getFormatPixelSize((Format)format);
	}
	TS_CAPI uint32_t TS_CCALL ts_getFormatBlockSize(TS_Format format) {
		return getFormatBlockSize((Format)format);
	}
	TS_CAPI uint32_t TS_CCALL ts_getFormatBlockWidth(TS_Format format) {
		return getFormatBlockWidth((Format)format);
	}
	TS_CAPI uint32_t TS_CCALL ts_getFormatBlockHeight(TS_Format format) {
		return getFormatBlockHeight((Format)format);
	}
	TS_CAPI uint32_t TS_CCALL ts_getPixelFormatValue(TS_Format format, float32_t value[4], const void *src, uint32_t stride) {
		return getPixelFormatValue((Format)format, value, src, stride);
	}
	TS_CAPI uint32_t TS_CCALL ts_setPixelFormatValue(TS_Format format, void *dest, const float32_t value[4], uint32_t stride) {
		return setPixelFormatValue((Format)format, dest, value, stride);
	}
	TS_CAPI void* TS_CCALL tsAllocator_allocate_z(size_t size) {
		return Allocator::allocate(size);
	}
	TS_CAPI void* TS_CCALL tsAllocator_reallocate(void *ptr, size_t old_size, size_t new_size) {
		return Allocator::reallocate(ptr, old_size, new_size);
	}
	TS_CAPI void TS_CCALL tsAllocator_free(const void *ptr, size_t size) {
		Allocator::free(ptr, size);
	}
	TS_CAPI size_t TS_CCALL tsAllocator_getMemory(void) {
		return Allocator::getMemory();
	}
	TS_CAPI size_t TS_CCALL tsAllocator_getAllocations(void) {
		return Allocator::getAllocations();
	}
	TS_CAPI void TS_CCALL tsLog_setLevel(TS_LogLevel level) {
		Log::setLevel((Log::Level)level);
	}
	TS_CAPI TS_LogLevel TS_CCALL tsLog_getLevel(void) {
		return (TS_LogLevel)Log::getLevel();
	}
	TS_CAPI void* TS_CCALL tsLog_getCallbackData(void) {
		return Log::getCallbackData();
	}
	TS_CAPI void TS_CCALL tsLog_unlockCallback(void) {
		Log::unlockCallback();
	}
	TS_CAPI void TS_CCALL tsLog_lockCallback(void) {
		Log::lockCallback();
	}
	TS_CAPI void TS_CCALL tsLog_print_s(const char *str) {
		Log::print(str);
	}
	TS_CAPI void TS_CCALL tsLog_vprintf_sva(const char *str, va_list args) {
		Log::vprintf(str, args);
	}
	TS_CAPI void TS_CCALL tsLog_print_LLs(TS_LogLevel level, const char *str) {
		Log::print((Log::Level)level, str);
	}
	TS_CAPI void TS_CCALL tsLog_printe(TS_LogLevel level, const char *str) {
		Log::printe((Log::Level)level, str);
	}
	TS_CAPI void TS_CCALL tsLog_vprintf_LLsva(TS_LogLevel level, const char *str, va_list args) {
		Log::vprintf((Log::Level)level, str, args);
	}
	TS_CAPI void TS_CCALL tsLog_vprintef(TS_LogLevel level, const char *str, va_list args) {
		Log::vprintef((Log::Level)level, str, args);
	}
	TS_CAPI uint64_t TS_CCALL tsTime_current(void) {
		return Time::current();
	}
	TS_CAPI float64_t TS_CCALL tsTime_seconds(void) {
		return Time::seconds();
	}
	TS_CAPI void TS_CCALL tsTime_sleep(uint32_t usec) {
		Time::sleep(usec);
	}
	TS_CAPI uint32_t TS_CCALL tsSystem_getThreadID(void) {
		return System::getThreadID();
	}
	TS_CAPI bool_t TS_CCALL tsSystem_setEnvironment_ss(const char *name, const char *value) {
		return System::setEnvironment(name, value);
	}
	TS_CAPI bool_t TS_CCALL tsSystem_setEnvironment_cSs(const TSString name, const char *value) {
		return System::setEnvironment((name) ? *(const String*)name : String::null, value);
	}
	TS_CAPI TSString TS_CCALL tsSystem_getEnvironment_s(const char *name) {
		return (TSString)(new String(System::getEnvironment(name)));
	}
	TS_CAPI TSString TS_CCALL tsSystem_getEnvironment_cS(const TSString name) {
		return (TSString)(new String(System::getEnvironment((name) ? *(const String*)name : String::null)));
	}
	TS_CAPI void* TS_CCALL tsSystem_loadLibrary_s(const char *name) {
		return System::loadLibrary(name);
	}
	TS_CAPI void* TS_CCALL tsSystem_loadLibrary_cS(const TSString name) {
		return System::loadLibrary((name) ? *(const String*)name : String::null);
	}
	TS_CAPI void* TS_CCALL tsSystem_getFunction_prs(void *handle, const char *name) {
		return System::getFunction(handle, name);
	}
	TS_CAPI void* TS_CCALL tsSystem_getFunction_prcS(void *handle, const TSString name) {
		return System::getFunction(handle, (name) ? *(const String*)name : String::null);
	}
	TS_CAPI void TS_CCALL tsSystem_closeLibrary(void *handle) {
		System::closeLibrary(handle);
	}
	TS_CAPI bool_t TS_CCALL tsSystem_exec_sbb(const char *command, bool_t wait, bool_t console) {
		return System::exec(command, (bool)wait, (bool)console);
	}
	TS_CAPI bool_t TS_CCALL tsSystem_exec_cSbb(const TSString command, bool_t wait, bool_t console) {
		return System::exec((command) ? *(const String*)command : String::null, (bool)wait, (bool)console);
	}
	TS_CAPI bool_t TS_CCALL tsSystem_open_s(const char *command) {
		return System::open(command);
	}
	TS_CAPI bool_t TS_CCALL tsSystem_open_cS(const TSString command) {
		return System::open((command) ? *(const String*)command : String::null);
	}
	TS_CAPI bool_t TS_CCALL tsMeshGraph_create_MMuucMGPCA(TSMesh dest, TSMesh src, uint32_t max_attributes, uint32_t max_primitives, const TSMeshGraphProgressCallback func, TSAsync *async, void *data_) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		auto func_ts = makeTSMeshGraphProgressCallback((func) ? *func : nullptr, data_);
		return MeshGraph::create(*(Mesh*)dest, *(Mesh*)src, max_attributes, max_primitives, (func) ? &func_ts : nullptr, (async) ? *(Async**)async : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMeshReduce_collapse_McMffcMRPC(TSMesh dest, const TSMesh src, float32_t ratio, float32_t threshold, const TSMeshReduceProgressCallback func, void *data_) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		auto func_ts = makeTSMeshReduceProgressCallback((func) ? *func : nullptr, data_);
		return MeshReduce::collapse(*(Mesh*)dest, *(const Mesh*)src, ratio, threshold, (func) ? &func_ts : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMeshReduce_collapse_MGcMGffcMRPCu(TSMeshGeometry dest, const TSMeshGeometry src, float32_t ratio, float32_t threshold, const TSMeshReduceProgressCallback func, uint32_t position, void *data_) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		auto func_ts = makeTSMeshReduceProgressCallback((func) ? *func : nullptr, data_);
		return MeshReduce::collapse(*(MeshGeometry*)dest, *(const MeshGeometry*)src, ratio, threshold, (func) ? &func_ts : nullptr, position);
	}
	TS_CAPI bool_t TS_CCALL tsMeshRefine_subdiv_McMuf(TSMesh dest, const TSMesh src, uint32_t steps, float32_t weight) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return MeshRefine::subdiv(*(Mesh*)dest, *(const Mesh*)src, steps, weight);
	}
	TS_CAPI bool_t TS_CCALL tsMeshRefine_subdiv_MGcMGufu(TSMeshGeometry dest, const TSMeshGeometry src, uint32_t steps, float32_t weight, uint32_t position) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		return MeshRefine::subdiv(*(MeshGeometry*)dest, *(const MeshGeometry*)src, steps, weight, position);
	}
	TS_CAPI bool_t TS_CCALL tsMeshSolid_create_McMffcMSPC(TSMesh dest, const TSMesh src, float32_t ratio, float32_t threshold, const TSMeshSolidProgressCallback func, void *data_) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		auto func_ts = makeTSMeshSolidProgressCallback((func) ? *func : nullptr, data_);
		return MeshSolid::create(*(Mesh*)dest, *(const Mesh*)src, ratio, threshold, (func) ? &func_ts : nullptr);
	}
	TS_CAPI bool_t TS_CCALL tsMeshSolid_create_MGcMGffcMSPCu(TSMeshGeometry dest, const TSMeshGeometry src, float32_t ratio, float32_t threshold, const TSMeshSolidProgressCallback func, uint32_t position, void *data_) {
		TS_ASSERT(dest);
		TS_ASSERT(src);
		auto func_ts = makeTSMeshSolidProgressCallback((func) ? *func : nullptr, data_);
		return MeshSolid::create(*(MeshGeometry*)dest, *(const MeshGeometry*)src, ratio, threshold, (func) ? &func_ts : nullptr, position);
	}
	
	} /* extern "C" */
}
