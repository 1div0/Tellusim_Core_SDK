// Copyright (C) 2018-2025, Tellusim Technologies Inc. All rights reserved
// https://tellusim.com/

#include <TellusimApp.h>
#include <TellusimFormat.h>
#include <core/TellusimCore.h>
#include <core/TellusimSystem.h>
#include <core/TellusimDirectory.h>
#include <math/TellusimMath.h>
#include <math/TellusimExpression.h>
#include <format/TellusimFormats.h>
#include <platform/TellusimPlatforms.h>
#include <interface/TellusimFont.h>
#include <interface/TellusimControls.h>
#include <interface/TellusimDialogs.h>
#include <geometry/TellusimGeometry.h>
#include <graphics/TellusimGraphics.h>
#include <parallel/TellusimParallels.h>
#include <system/TellusimController.h>
#include <system/TellusimDesktop.h>
#include <core/TellusimAtomic.h>

#include "../include/TellusimReflectionImpl.h"

/*
 */
namespace Tellusim {
	
	// Tellusim names
	static const char *reflection_names[] = {
		nullptr, "-1", "-Maxf32", "0", "0.0f", "0xffffffffu", "1", "1.0", "1.0f", "10", "100", "1024", "12", "15", "16", "1e-3f", "1e-6f", "256", "3", "32", "4", "6", "95", "Add", "Align", "AlignAspect", "AlignBottom", "AlignCenter",
		"AlignCenterX", "AlignCenterY", "AlignExpand", "AlignExpandX", "AlignExpandY", "AlignLeft", "AlignLeftBottom", "AlignLeftTop", "AlignNone", "AlignOverlap", "AlignRight", "AlignRightBottom",
		"AlignRightTop", "AlignSpacer", "AlignTop", "App", "Archive", "Array<Canvas>", "Array<CanvasElement>", "Array<Control>", "Array<Json>", "Array<MeshAnimation>", "Array<MeshAttachment>",
		"Array<MeshAttribute>", "Array<MeshGeometry>", "Array<MeshIndices>", "Array<MeshJoint>", "Array<MeshMaterial>", "Array<MeshNode>", "Array<MeshTransform>", "Array<Xml>", "Array<uint32_t>",
		"Async", "Async&", "Async*", "Async::Task", "Attribute", "AttributeBasis", "AttributeBinormal", "AttributeColor", "AttributeExecute", "AttributeHidden", "AttributeIndex", "AttributeJoints",
		"AttributeNone", "AttributeNormal", "AttributePosition", "AttributeRead", "AttributeTangent", "AttributeTemporary", "AttributeTexCoord", "AttributeWeights", "AttributeWrite", "Attributes",
		"AvgPool", "Axis", "AxisNX", "AxisNY", "AxisNZ", "AxisPX", "AxisPY", "AxisPZ", "AxisRX", "AxisRY", "AxisRZ", "AxisUnknown", "AxisW", "AxisX", "AxisY", "AxisZ", "BackwardCtoC", "BackwardCtoR", "Basis",
		"BasisUnknown", "BasisXUpLeft", "BasisXUpRight", "BasisYUpLeft", "BasisYUpRight", "BasisZUpLeft", "BasisZUpMaya", "BasisZUpRight", "BatchMad", "BatchNorm", "BeginCallback", "BeginClear",
		"BeginDiscard", "BeginLoad", "BeginMask", "BindFlagNone", "BindFlags", "BitonicSort", "BitonicSort&", "BitonicSort::Flags", "BitonicSort::Mode", "BlendFunc", "BlendFuncDestAlpha", "BlendFuncDestColor",
		"BlendFuncFactorAlpha", "BlendFuncFactorColor", "BlendFuncInvDestAlpha", "BlendFuncInvDestColor", "BlendFuncInvFactorAlpha", "BlendFuncInvFactorColor", "BlendFuncInvSrc1Alpha",
		"BlendFuncInvSrc1Color", "BlendFuncInvSrcAlpha", "BlendFuncInvSrcColor", "BlendFuncNone", "BlendFuncOne", "BlendFuncSrc1Alpha", "BlendFuncSrc1Color", "BlendFuncSrcAlpha", "BlendFuncSrcColor",
		"BlendFuncZero", "BlendOp", "BlendOpAdd", "BlendOpMax", "BlendOpMin", "BlendOpSub", "Blob", "Blob&", "BoundBoxd", "BoundBoxf", "BoundSpheref", "Buffer", "Buffer&", "Buffer::FlagNone", "Buffer::Flags",
		"Buffer::null", "BufferTable", "BufferTable&", "Button", "ButtonA", "ButtonB", "ButtonBack", "ButtonBack2", "ButtonCircle", "ButtonCross", "ButtonDown", "ButtonForward", "ButtonForward2",
		"ButtonHome", "ButtonL1", "ButtonL2", "ButtonL3", "ButtonLeft", "ButtonLeft2", "ButtonMenu", "ButtonMiddle", "ButtonMiddle2", "ButtonNone", "ButtonOptions", "ButtonPressedCallback", "ButtonR1",
		"ButtonR2", "ButtonR3", "ButtonReleasedCallback", "ButtonRight", "ButtonRight2", "ButtonShare", "ButtonShoulderLeft", "ButtonShoulderRight", "ButtonSquare", "ButtonStickLeft", "ButtonStickRight",
		"ButtonTriangle", "ButtonTriggerLeft", "ButtonTriggerRight", "ButtonUp", "ButtonView", "ButtonX", "ButtonY", "CUBuffer", "CUBuffer&", "CUContext", "CUContext&", "CUShader", "CUShader&", "CUTexture",
		"CUTexture&", "CUarray", "CUcontext", "CUevent", "CUexternalMemory", "CUfunction", "CUmipmappedArray", "CUmodule", "CUstream", "Canvas", "Canvas&", "Canvas*", "Canvas::BeginCallback", "Canvas::CreateCallback",
		"Canvas::DrawCallback", "Canvas::PipelineCallback", "CanvasElement", "CanvasElement&", "CanvasElement::Align", "CanvasElement::DrawCallback", "CanvasElement::Mode", "CanvasElement::Stack",
		"CanvasElement::Type", "CanvasEllipse", "CanvasEllipse&", "CanvasMesh", "CanvasMesh&", "CanvasRect", "CanvasRect&", "CanvasShape", "CanvasShape&", "CanvasStrip", "CanvasStrip&", "CanvasText",
		"CanvasText&", "CanvasTriangle", "CanvasTriangle&", "CanvasVertex&", "CanvasVertex*", "Cat", "ChangedCallback", "Clear", "ClickedCallback", "CloseClickedCallback", "Color", "Color::white",
		"Color::zero", "ColorMask", "ColorMaskA", "ColorMaskAll", "ColorMaskB", "ColorMaskG", "ColorMaskNone", "ColorMaskR", "ColorMaskRGB", "ColorMaskUnknown", "Command", "Command&", "CompareFunc",
		"CompareFuncEqual", "CompareFuncGreater", "CompareFuncGreaterEqual", "CompareFuncLess", "CompareFuncLessEqual", "CompareFuncNone", "CompareFuncNotEqual", "Compute", "Compute&", "ConnectedCallback",
		"Context", "Context&", "Control", "Control&", "Control*", "Control::Align", "Control::Axis", "Control::Button", "Control::Mesh", "Control::State", "Control::Type", "ControlArea", "ControlArea&",
		"ControlButton", "ControlButton&", "ControlButton::ClickedCallback", "ControlButton::PressedCallback", "ControlButton::ReleasedCallback", "ControlCheck", "ControlCheck&", "ControlCheck::ClickedCallback",
		"ControlCombo", "ControlCombo&", "ControlCombo::ChangedCallback", "ControlCombo::ClickedCallback", "ControlDialog", "ControlDialog&", "ControlDialog::UpdatedCallback", "ControlEdit",
		"ControlEdit&", "ControlEdit::ChangedCallback", "ControlEdit::ClickedCallback", "ControlEdit::EditMode", "ControlEdit::ReturnedCallback", "ControlGrid", "ControlGrid&", "ControlGroup",
		"ControlGroup&", "ControlGroup::ClickedCallback", "ControlPanel", "ControlPanel&", "ControlRect", "ControlRect&", "ControlRect::ClickedCallback", "ControlRect::InsideCallback", "ControlRect::PressedCallback",
		"ControlRect::ReleasedCallback", "ControlRoot", "ControlRoot&", "ControlRoot*", "ControlRoot::CopyCallback", "ControlRoot::PasteCallback", "ControlScroll", "ControlScroll&", "ControlScroll::ChangedCallback",
		"ControlScroll::ClickedCallback", "ControlSlider", "ControlSlider&", "ControlSlider::ChangedCallback", "ControlSlider::ClickedCallback", "ControlSlider::FormatCallback", "ControlSlider::PressedCallback",
		"ControlSlider::ReleasedCallback", "ControlSplit", "ControlSplit&", "ControlText", "ControlText&", "ControlTree", "ControlTree&", "ControlTree::ChangedCallback", "ControlTree::ClickedCallback",
		"ControlTree::DraggedCallback", "ControlTree::DroppedCallback", "ControlTree::ExpandedCallback", "ControlTree::SelectedCallback", "ControlWindow", "ControlWindow&", "Controller",
		"Controller&", "Controller::Axis", "Controller::Button", "Controller::ButtonPressedCallback", "Controller::ButtonReleasedCallback", "Controller::ConnectedCallback", "Controller::DisconnectedCallback",
		"Controller::Motor", "Controller::Stick", "Controller::Type", "Conv", "Copy", "CopyCallback", "Cos", "CreateCallback", "CubeFilter", "CubeFilter&", "CubeFilter::Flags", "CubeFilter::Mode",
		"CullMode", "CullModeBack", "CullModeFront", "CullModeNone", "Cursor", "CursorAll", "CursorArrow", "CursorBottom", "CursorHeight", "CursorInvalid", "CursorLeft", "CursorMajor", "CursorMinor",
		"CursorRight", "CursorTop", "CursorWidth", "D3D11Buffer", "D3D11Buffer&", "D3D11Context", "D3D11Context&", "D3D11Device", "D3D11Device&", "D3D11Shader", "D3D11Shader&", "D3D11Surface", "D3D11Surface&",
		"D3D11Target", "D3D11Target&", "D3D11Texture", "D3D11Texture&", "D3D12Buffer", "D3D12Buffer&", "D3D12Command", "D3D12Command&", "D3D12Compute", "D3D12Compute&", "D3D12Context", "D3D12Context&",
		"D3D12Device", "D3D12Device&", "D3D12Kernel", "D3D12Kernel&", "D3D12Pipeline", "D3D12Pipeline&", "D3D12Shader", "D3D12Shader&", "D3D12Surface", "D3D12Surface&", "D3D12Target", "D3D12Target&",
		"D3D12Texture", "D3D12Texture&", "D3D12Tracing", "D3D12Tracing&", "D3D12Traversal", "D3D12Traversal&", "Date", "Date&", "DeConv", "DecoderJPEG", "DecoderJPEG&", "DecoderJPEG::Flags", "DecoderJPEG::Mode",
		"DecoderJPEG::Mode&", "DefaultFlags", "DepthFunc", "DepthFuncAlways", "DepthFuncEqual", "DepthFuncGreater", "DepthFuncGreaterEqual", "DepthFuncLess", "DepthFuncLessEqual", "DepthFuncNever",
		"DepthFuncNone", "DepthFuncNotEqual", "DepthMask", "DepthMaskNone", "DepthMaskRead", "DepthMaskWrite", "Desktop", "Desktop&", "Device", "Device&", "DialogColor", "DialogColor&", "DialogColor::ChangedCallback",
		"DialogColor::Flags", "DialogColor::Result", "DialogColor::UpdateCallback", "DialogDirectory", "DialogDirectory&", "DialogDirectory::Flags", "DialogDirectory::Result", "DialogDirectory::UpdateCallback",
		"DialogFileOpen", "DialogFileOpen&", "DialogFileOpen::Flags", "DialogFileOpen::Result", "DialogFileOpen::UpdateCallback", "DialogFileSave", "DialogFileSave&", "DialogFileSave::Flags",
		"DialogFileSave::Result", "DialogFileSave::UpdateCallback", "DialogMenu", "DialogMenu&", "DialogMenu::ChangedCallback", "DialogMenu::ClickedCallback", "DialogMenu::Flags", "DialogMenu::Result",
		"DialogMenu::UpdateCallback", "DialogMessage", "DialogMessage&", "DialogMessage::Flags", "DialogMessage::Result", "DialogMessage::UpdateCallback", "DialogProgress", "DialogProgress&",
		"DialogProgress::Flags", "DialogProgress::Result", "Directory", "Directory&", "Directory::Attributes", "DisconnectedCallback", "Div", "DraggedCallback", "DrawCallback", "DroppedCallback",
		"EditMode", "EditModeHexadecimal", "EditModeNumber", "EditModePassword", "EditModeSigned", "EditModeText", "EditModeUnsigned", "EncoderASTC", "EncoderASTC&", "EncoderASTC::Flags", "EncoderASTC::Mode",
		"EncoderBC15", "EncoderBC15&", "EncoderBC15::Flags", "EncoderBC15::Mode", "EncoderBC67", "EncoderBC67&", "EncoderBC67::Flags", "EncoderBC67::Mode", "EndDiscard", "EndMask", "EndResolve",
		"EndStore", "Exp", "ExpandedCallback", "FUBuffer", "FUBuffer&", "FUCommand", "FUCommand&", "FUCompute", "FUCompute&", "FUDevice", "FUDevice&", "FUFence", "FUFence&", "FUKernel", "FUKernel&", "FUPipeline",
		"FUPipeline&", "FUQuery", "FUQuery&", "FUSampler", "FUSampler&", "FUShader", "FUShader&", "FUTarget", "FUTarget&", "FUTexture", "FUTexture&", "FUTracing", "FUTracing&", "FUTraversal", "FUTraversal&",
		"Fence", "Fence&", "Fence::Flags", "File", "File&", "FileDroppedCallback", "FillMode", "FillModeLine", "FillModeSolid", "Filter", "FilterBilinear", "FilterBipoint", "FilterBox", "FilterCR",
		"FilterCubic", "FilterLinear", "FilterMax", "FilterMin", "FilterMip", "FilterPoint", "FilterSinc", "FilterTrilinear", "FilterUnknown", "Flag32Bit", "FlagASTC44RGBAu8n", "FlagASTC54RGBAu8n",
		"FlagASTC55RGBAu8n", "FlagAccel", "FlagAddress", "FlagAlpha", "FlagAtomic", "FlagBC1RGBu8n", "FlagBC2RGBAu8n", "FlagBC3RGBAu8n", "FlagBC4Ru8n", "FlagBC5RGu8n", "FlagBC6RGBf16s", "FlagBC6RGBf16u",
		"FlagBC7RGBAu8n", "FlagBest", "FlagBinding", "FlagBlob", "FlagBool", "FlagBuffer", "FlagBufferAddress", "FlagBufferSource", "FlagBufferStorage", "FlagBufferTexel", "FlagBufferTracing",
		"FlagBufferWrite", "FlagCancel", "FlagClearNormal", "FlagClearOne", "FlagClearZero", "FlagClose", "FlagColor", "FlagColorRGBAf16", "FlagColorRGBAu8ns", "FlagColorRGBu10Au2n", "FlagCompact",
		"FlagConditional", "FlagConvert", "FlagCos", "FlagCube", "FlagDirect", "FlagDynamic", "FlagEmbed", "FlagError", "FlagExp", "FlagExtern", "FlagFast", "FlagFastBuild", "FlagFastTrace", "FlagFileDropped",
		"FlagFormat", "FlagFormatNorm", "FlagFormatRf16", "FlagFormatRf32", "FlagFormatSRGB", "FlagFormatSigned", "FlagFrame", "FlagFullscreen", "FlagGELU", "FlagGamma", "FlagGenerate", "FlagHidden",
		"FlagImage", "FlagIndex", "FlagIndices10", "FlagIndices16", "FlagIndices32", "FlagIndirect", "FlagInfo", "FlagInterop", "FlagKernel", "FlagLayout", "FlagLeafNodef16", "FlagMSLIndirect",
		"FlagMapped", "FlagMaterials", "FlagMath", "FlagMatrix3x2f", "FlagMaximize", "FlagMeshlet128x212", "FlagMeshlet64x126", "FlagMeshlet64x84", "FlagMeshlet96x169", "FlagMeshlets", "FlagMessage",
		"FlagMinimize", "FlagMipmaps", "FlagMouse", "FlagMultiple", "FlagMultipleOptimize", "FlagMultipleUpdate", "FlagMultisample", "FlagMultisample2", "FlagMultisample4", "FlagMultisample8",
		"FlagMutable", "FlagName", "FlagNo", "FlagNoAllocate", "FlagNoClear", "FlagNone", "FlagNormalize", "FlagNpot", "FlagOk", "FlagOkCancel", "FlagOptimize", "FlagOrder", "FlagOverwrite", "FlagPanorama",
		"FlagPerceptual", "FlagQuestion", "FlagR", "FlagRG", "FlagRGBA", "FlagRGBf16c", "FlagRGBf16p", "FlagRGBf21c", "FlagRGBf32p", "FlagRGf16i", "FlagRGf32i", "FlagReLU", "FlagRead", "FlagReadBias",
		"FlagReadScale", "FlagRefreshSync", "FlagRepeat", "FlagResize", "FlagRf16i", "FlagRf32i", "FlagSRGB", "FlagScalarf32", "FlagScratch", "FlagSemaphore", "FlagShared", "FlagSiLU", "FlagSigm",
		"FlagSignaled", "FlagSin", "FlagSingle", "FlagSingleOptimize", "FlagSingleUpdate", "FlagSizeQuery", "FlagSource", "FlagSparse", "FlagSpatialData", "FlagStorage", "FlagSurface", "FlagTanh",
		"FlagTarget", "FlagTexel", "FlagTexture", "FlagTitle", "FlagTracing", "FlagTransient", "FlagTransparent", "FlagTranspose", "FlagUniform", "FlagUnit", "FlagUpdate", "FlagVector4f", "FlagVerbose",
		"FlagVertex", "FlagVerticalSync", "FlagWarning", "FlagWrap", "FlagWrapClamp", "FlagWrapRepeat", "FlagWrite", "FlagYUV420", "FlagYUV422H", "FlagYUV422V", "FlagYUV444", "FlagYes", "FlagYesNo",
		"FlagZero", "Flags", "FlagsAll", "FlagsAllOptimize", "FlagsBC13", "FlagsBC45", "FlagsComplex", "FlagsInterleaved", "FlagsPlanar", "FocusChangedCallback", "Font", "Font&", "FontStyle&", "Format",
		"FormatCallback", "FormatUnknown", "ForwardCtoC", "ForwardRtoC", "FourierTransform", "FourierTransform&", "FourierTransform::Flags", "FourierTransform::Mode", "FourierTransform::Operation",
		"FrontMode", "FrontModeCCW", "FrontModeCW", "GELU", "GLBuffer", "GLBuffer&", "GLContext", "GLContext&", "GLESBuffer", "GLESBuffer&", "GLESContext", "GLESContext&", "GLESShader", "GLESShader&",
		"GLESSurface", "GLESSurface&", "GLESTarget", "GLESTarget&", "GLESTexture", "GLESTexture&", "GLShader", "GLShader&", "GLSurface", "GLSurface&", "GLTarget", "GLTarget&", "GLTexture", "GLTexture&",
		"GradientStyle&", "HIPBuffer", "HIPBuffer&", "HIPContext", "HIPContext&", "HIPShader", "HIPShader&", "HIPTexture", "HIPTexture&", "Hash", "HashXY10", "HashXY12", "HashXY14", "HashXY15", "HashXYZ10",
		"HashXYZ8", "HashXYZ9", "ID3D11Buffer*", "ID3D11DepthStencilView*", "ID3D11Device*", "ID3D11DeviceContext*", "ID3D11RenderTargetView*", "ID3D11RenderTargetView**", "ID3D11ShaderResourceView*",
		"ID3D11Texture2D*", "ID3D11UnorderedAccessView*", "ID3D12CommandQueue*", "ID3D12Device*", "ID3D12GraphicsCommandList*", "ID3D12Resource*", "ID3D12RootSignature*", "ID3DBlob*", "IDXGIFactory*",
		"IDXGIFactory4*", "IDXGISwapChain*", "Image", "Image&", "Image::Filter", "Image::FilterLinear", "Image::FlagNone", "Image::Flags", "Image::Type", "ImageColor", "ImageSampler", "Info", "Info&",
		"InsideCallback", "InstanceSize", "IsCallback", "Json", "Json&", "Json*", "Json::Type", "Kernel", "Kernel&", "Key", "KeyAlt", "KeyBackspace", "KeyCaps", "KeyCmd", "KeyCtrl", "KeyDelete", "KeyDown",
		"KeyEnd", "KeyEsc", "KeyF1", "KeyF10", "KeyF11", "KeyF12", "KeyF2", "KeyF3", "KeyF4", "KeyF5", "KeyF6", "KeyF7", "KeyF8", "KeyF9", "KeyHome", "KeyInsert", "KeyLeft", "KeyMenu", "KeyNext", "KeyNone", "KeyNum",
		"KeyOption", "KeyPause", "KeyPrior", "KeyReturn", "KeyRight", "KeyScroll", "KeyShift", "KeyTab", "KeyUp", "KeyWin", "KeyboardPressedCallback", "KeyboardReleasedCallback", "MTLBuffer", "MTLBuffer&",
		"MTLCommand", "MTLCommand&", "MTLCompute", "MTLCompute&", "MTLContext", "MTLContext&", "MTLDevice", "MTLDevice&", "MTLKernel", "MTLKernel&", "MTLPipeline", "MTLPipeline&", "MTLSampler", "MTLSampler&",
		"MTLShader", "MTLShader&", "MTLSurface", "MTLSurface&", "MTLTarget", "MTLTarget&", "MTLTexture", "MTLTexture&", "MTLTracing", "MTLTracing&", "Mad", "MainLoopCallback", "Mask", "MaskAdd", "MaskAll",
		"MaskAvgPool", "MaskBatchMad", "MaskBatchNorm", "MaskCallable", "MaskCat", "MaskClear", "MaskClosest", "MaskCompute", "MaskControl", "MaskConv", "MaskCopy", "MaskCos", "MaskDeConv", "MaskDiv",
		"MaskEvaluate", "MaskExp", "MaskFirstHit", "MaskFragment", "MaskGELU", "MaskGeometry", "MaskGraphics", "MaskIntersection", "MaskMad", "MaskMatMul", "MaskMaxPool", "MaskMesh", "MaskMul", "MaskNone",
		"MaskRange", "MaskRayGen", "MaskRayMiss", "MaskReLU", "MaskSiLU", "MaskSigm", "MaskSin", "MaskSoftMax", "MaskSoftMin", "MaskTanh", "MaskTask", "MaskTracing", "MaskTranspose", "MaskVertex", "MaskVertexFragment",
		"Masks", "MasksAll", "MatMul", "Matrix3x2f::identity", "Matrix4x3d", "Matrix4x3d::identity", "Matrix4x3f", "Matrix4x3f::identity", "MaxAnisotropy", "MaxPool", "Maxf32", "Maxu32", "Mesh", "Mesh&",
		"Mesh::Axis", "Mesh::Basis", "Mesh::Flags", "MeshAnimation", "MeshAnimation&", "MeshAttachment", "MeshAttachment&", "MeshAttachment::Flags", "MeshAttachment::Type", "MeshAttribute",
		"MeshAttribute&", "MeshAttribute::Type", "MeshBackground", "MeshBorder", "MeshButton", "MeshCheck", "MeshFrame", "MeshGeometry", "MeshGeometry&", "MeshHScrollHandle", "MeshHScrollLine",
		"MeshIndices", "MeshIndices&", "MeshIndices::Type", "MeshJoint", "MeshJoint&", "MeshMaterial", "MeshMaterial&", "MeshMaterial::Flags", "MeshModel", "MeshModel::Flags", "MeshNode", "MeshNode&",
		"MeshNode*", "MeshSelection", "MeshSliderHandle", "MeshSliderLine", "MeshTransform", "MeshTransform&", "MeshTransform::MorphKeys", "MeshTransform::RotateKeys", "MeshTransform::ScaleKeys",
		"MeshTransform::TranslateKeys", "MeshVScrollHandle", "MeshVScrollLine", "MinAnisotropy", "Mode", "ModeASTC44RGBAu8n", "ModeASTC54RGBAu8n", "ModeASTC55RGBAu8n", "ModeBC1RGBu8n", "ModeBC2RGBAu8n",
		"ModeBC3RGBAu8n", "ModeBC4Ru8n", "ModeBC5RGu8n", "ModeBC6RGBf16s", "ModeBC6RGBf16u", "ModeBC7RGBAu8n", "ModeCube", "ModeGradient", "ModeHorizontal", "ModeMultiple", "ModePanorama", "ModeR",
		"ModeRG", "ModeRGBA", "ModeRGBf16c", "ModeRGBf16p", "ModeRGBf21c", "ModeRGBf32p", "ModeRGf16i", "ModeRGf32i", "ModeRf16i", "ModeRf32i", "ModeSingle", "ModeSolid", "ModeTexture", "ModeTextureAlpha",
		"ModeTextureBlue", "ModeTextureClamp", "ModeTextureCubic", "ModeTextureCubic3x3", "ModeTextureCubic5x5", "ModeTextureFetch", "ModeTextureGreen", "ModeTextureRed", "ModeTextureYOG",
		"ModeVertical", "ModeYUV420", "ModeYUV422H", "ModeYUV422V", "ModeYUV444", "Motor", "MotorHigh", "MotorLow", "MouseChangedCallback", "MousePressedCallback", "MouseReleasedCallback", "MouseRotatedCallback",
		"Mul", "NumAligns", "NumAttributeTypes", "NumAttributes", "NumAxes", "NumBases", "NumBlendFunctions", "NumBlendOperations", "NumButtons", "NumCompareFunctions", "NumCullModes", "NumCursors",
		"NumDepthFunctions", "NumDepthMasks", "NumFillModes", "NumFilters", "NumFlags", "NumFrontModes", "NumKeys", "NumMeshes", "NumModes", "NumMotors", "NumOperations", "NumPrimitiveTypes", "NumReductionModes",
		"NumResults", "NumStates", "NumStencilFunctions", "NumStencilOperations", "NumSticks", "NumTouches", "NumTypes", "NumWrapModes", "OpClearDiscard", "OpClearStore", "OpDefault", "OpLoad",
		"OpLoadStore", "OpNone", "OpenCallback", "Operation", "PFN_vkGetDeviceProcAddr", "PFN_vkGetInstanceProcAddr", "PasteCallback", "PauseChangedCallback", "Pipeline", "Pipeline&", "Pipeline::Attribute",
		"Pipeline::BlendFunc", "Pipeline::BlendOp", "Pipeline::ColorMask", "Pipeline::CullMode", "Pipeline::DepthFunc", "Pipeline::DepthMask", "Pipeline::FillMode", "Pipeline::FrontMode",
		"Pipeline::Primitive", "Pipeline::StencilFunc", "Pipeline::StencilOp", "PipelineCallback", "Platform", "PlatformUnknown", "PrefixScan", "PrefixScan&", "PrefixScan::Flags", "PrefixScan::Mode",
		"PresentCallback", "PressedCallback", "Primitive", "PrimitiveLine", "PrimitiveLineAdj", "PrimitiveLinePatch", "PrimitiveLineStrip", "PrimitivePoint", "PrimitivePointPatch", "PrimitiveQuadrilateralPatch",
		"PrimitiveTriangle", "PrimitiveTriangleAdj", "PrimitiveTrianglePatch", "PrimitiveTriangleStrip", "Quaternionf", "Query", "Query&", "Query::Statistics", "Query::Type", "RadixSort", "RadixSort&",
		"RadixSort::Flags", "RadixSort::Mode", "Range", "ReLU", "Rect", "ReductionMode", "ReductionModeAverage", "ReductionModeMax", "ReductionModeMin", "Region", "ReleasedCallback", "Result", "ResultCancel",
		"ResultClick", "ResultClose", "ResultNo", "ResultOk", "ResultYes", "ReturnedCallback", "Sampler", "Sampler&", "Sampler::CompareFunc", "Sampler::Filter", "Sampler::MaxAnisotropy", "Sampler::ReductionMode",
		"Sampler::WrapMode", "Sampler::WrapModeRepeat", "SelectedCallback", "SeparableFilter", "SeparableFilter&", "SeparableFilter::Flags", "SeparableFilter::Mode", "Shader", "Shader&", "Shader::Mask",
		"Shader::Type", "ShaderCompiler", "ShaderCompiler&", "ShaderCompiler::Flags", "SiLU", "Sigm", "Sin", "Size", "Size&", "SizeChangedCallback", "Slice", "Slice()", "Socket", "Socket&", "Socket::Type",
		"SocketSSL", "SocketSSL&", "SoftMax", "SoftMin", "Source", "Source&", "Source::IsCallback*", "Source::OpenCallback*", "SpatialGrid", "SpatialGrid&", "SpatialTree", "SpatialTree&", "SpatialTree::Flags",
		"SpatialTree::Hash", "SpatialTree::Mode", "Stack", "StackGet", "StackMul", "StackNone", "StackPop", "StackPush", "StackSet", "State", "StateDisabled", "StateFocused", "StateNormal", "StatePressed",
		"StateUnknown", "StencilFunc", "StencilFuncAlways", "StencilFuncEqual", "StencilFuncGreater", "StencilFuncGreaterEqual", "StencilFuncLess", "StencilFuncLessEqual", "StencilFuncNever",
		"StencilFuncNone", "StencilFuncNotEqual", "StencilOp", "StencilOpDecrSat", "StencilOpDecrWrap", "StencilOpIncrSat", "StencilOpIncrWrap", "StencilOpInvert", "StencilOpKeep", "StencilOpReplace",
		"Stick", "StickLeft", "StickRight", "Stream", "Stream&", "String", "String&", "String*", "String::null", "StrokeStyle&", "Surface", "Surface&", "TableType", "Tanh", "Target", "Target&", "Target::OpDefault",
		"Target::Operation", "Tensor&", "TensorGraph", "TensorGraph&", "TensorGraph::Flags", "TensorGraph::Masks", "TensorGraph::Operation", "Texture", "Texture&", "Texture::DefaultFlags", "Texture::FlagNone",
		"Texture::Flags", "Texture::Type", "TextureTable", "TextureTable&", "TouchChangedCallback", "Tracing", "Tracing&", "Tracing::DefaultFlags", "Tracing::FlagNone", "Tracing::Flags", "Tracing::Type",
		"Transpose", "Traversal", "Traversal&", "Type", "Type2D", "Type3D", "TypeArea", "TypeArray", "TypeBasis", "TypeBinormal", "TypeBool", "TypeBound", "TypeButton", "TypeCallable", "TypeCameraOrthographic",
		"TypeCameraPerspective", "TypeCheck", "TypeClock", "TypeClosest", "TypeColor", "TypeCombo", "TypeCompute", "TypeControl", "TypeCrease", "TypeCube", "TypeDatagram", "TypeDialog", "TypeEdge",
		"TypeEdit", "TypeEllipse", "TypeEvaluate", "TypeFirstHit", "TypeFragment", "TypeGamePad", "TypeGeometry", "TypeGrid", "TypeGroup", "TypeIndex", "TypeInstance", "TypeIntersection", "TypeIsland",
		"TypeJoint", "TypeJoints", "TypeJoystick", "TypeLightGlobal", "TypeLightImage", "TypeLightPoint", "TypeLightSpot", "TypeLine", "TypeMaterial", "TypeMesh", "TypeNormal", "TypeNull", "TypeNumber",
		"TypeObject", "TypePanel", "TypePoint", "TypePosition", "TypeQuadrilateral", "TypeRayGen", "TypeRayMiss", "TypeRect", "TypeRoot", "TypeSamples", "TypeSamples1", "TypeScroll", "TypeShape",
		"TypeSlider", "TypeSplit", "TypeStatistics", "TypeStream", "TypeString", "TypeStrip", "TypeTangent", "TypeTask", "TypeTetrahedron", "TypeTexCoord", "TypeText", "TypeTime", "TypeTree", "TypeTriangle",
		"TypeUnknown", "TypeVertex", "TypeWeights", "TypeWheel", "TypeWindow", "UpdateCallback", "UpdatedCallback", "VKBuffer", "VKBuffer&", "VKCommand", "VKCommand&", "VKCompute", "VKCompute&", "VKContext",
		"VKContext&", "VKDevice", "VKDevice&", "VKFence", "VKFence&", "VKShader", "VKShader&", "VKSurface", "VKSurface&", "VKTarget", "VKTarget&", "VKTexture", "VKTexture&", "VKTracing", "VKTracing&",
		"Vector2f", "Vector3d", "Vector3f", "Vector3f&", "Vector3f*", "Vector4f", "Vector4f::zero", "Version", "Version_19", "Version_20", "Version_21", "Version_22", "Version_23", "Version_24", "Version_25",
		"Version_26", "Version_27", "Version_28", "Version_29", "Version_30", "Version_31", "Version_32", "Version_33", "Version_34", "Version_35", "Version_36", "Version_37", "Version_38", "Version_39",
		"Version_40", "Version_41", "VkAccelerationStructureKHR", "VkBuffer", "VkBufferView", "VkCommandBuffer", "VkDescriptorSet", "VkDevice", "VkFence", "VkFramebuffer", "VkImage", "VkImageView",
		"VkInstance", "VkPhysicalDevice", "VkQueue", "VkRenderPass", "VkSemaphore", "VkShaderModule", "VkSwapchainKHR", "WGContext", "WGContext&", "WGPUAdapter", "WGPUDevice", "WGPUInstance", "Window",
		"Window&", "Window::Axis", "Window::Button", "Window::CloseClickedCallback", "Window::Cursor", "Window::FileDroppedCallback", "Window::Flags", "Window::FocusChangedCallback", "Window::KeyboardPressedCallback",
		"Window::KeyboardReleasedCallback", "Window::MainLoopCallback", "Window::MouseChangedCallback", "Window::MousePressedCallback", "Window::MouseReleasedCallback", "Window::MouseRotatedCallback",
		"Window::PauseChangedCallback", "Window::PresentCallback", "Window::SizeChangedCallback", "Window::TouchChangedCallback", "Window::UpdateCallback", "WrapMode", "WrapModeBorder",
		"WrapModeClamp", "WrapModeMirror", "WrapModeRepeat", "Xml", "Xml&", "Xml*", "a", "above", "absolute", "accept", "access", "acquirePtr", "adapter", "addAdapterExtension", "addAdapterFeatures",
		"addAnimation", "addAttachment", "addAttribute", "addBoundBuffer", "addChild", "addChild0", "addChild1", "addContextExtension", "addElement", "addFont", "addGeometry", "addIndex", "addIndexBuffer",
		"addIndices", "addItem", "addItemChild", "addItemChildren", "addItems", "addJoint", "addMaterial", "addNode", "addParameter", "addPosition", "addPositions", "addSampler", "addShader", "addStorage",
		"addSurface", "addTable", "addTexel", "addTexture", "addTouch", "addTracing", "addUniform", "addVertex", "addVertexBuffer", "addVertices", "align", "alignment", "aligns", "angle", "animation",
		"anisotropy", "append", "apply", "area", "argc", "args", "argv", "array", "async", "attachShader", "attachment", "attribute", "attribute_0", "attribute_1", "attributes", "axis", "b", "background", "barrier",
		"base", "base_index", "base_instance", "base_vertex", "basis", "batches", "begin", "beginConditional", "beginQuery", "bias", "bindBuffer", "bindTexture", "bits", "blob", "block", "bool", "bool*",
		"border", "bottom", "bound_buffer", "bound_offset", "bound_stride", "box", "buffer", "buffer_id", "buffers", "buildTracing", "buildTracings", "button", "buttons", "cache", "callback", "canvas",
		"changeDirectory", "changed", "char", "char**", "check", "checked", "child", "children", "clamp", "clear", "clearAnimations", "clearAttachments", "clearAttributes", "clearBatches", "clearBuffer",
		"clearCache", "clearColor", "clearCurrentControl", "clearFocusedControl", "clearGeometries", "clearIncludes", "clearIndices", "clearInputControl", "clearItems", "clearJoints", "clearMacros",
		"clearMaterials", "clearModalControl", "clearMouseAxis", "clearMouseButtons", "clearMouseControl", "clearNodes", "clearParameters", "clearPositions", "clearPtr", "clearScissor", "clearSelection",
		"clearTexture", "clearTouches", "clearTransform", "clearVertices", "clipped", "clockwise", "clone", "clonePtr", "close", "code", "color", "column", "columns", "command", "commands", "commit", "compact",
		"compare", "component", "component_0", "component_1", "components", "compute", "computes", "connect", "const Array<Async::Task>&", "const Array<Buffer>&", "const Array<BufferTable>&",
		"const Array<Canvas>", "const Array<CanvasElement>", "const Array<Command>&", "const Array<Compute>&", "const Array<Control>", "const Array<Device>&", "const Array<Fence>&", "const Array<FontBatch>&",
		"const Array<Json>", "const Array<Kernel>&", "const Array<MeshAnimation>", "const Array<MeshAttachment>", "const Array<MeshAttribute>", "const Array<MeshGeometry>", "const Array<MeshGeometry>&",
		"const Array<MeshIndices>", "const Array<MeshJoint>", "const Array<MeshMaterial>", "const Array<MeshNode>", "const Array<MeshTransform>", "const Array<Pipeline>&", "const Array<Query>&",
		"const Array<Sampler>&", "const Array<Shader>&", "const Array<String>", "const Array<String>&", "const Array<Target>&", "const Array<Texture>&", "const Array<TextureTable>&", "const Array<Tracing>&",
		"const Array<Traversal>&", "const Array<Vector4f>&", "const Array<Xml>", "const Array<float32_t>&", "const Array<size_t>&", "const Array<uint32_t>&", "const Async::Task&", "const Async::Task*",
		"const Blob&", "const BoundBoxf&", "const BoundSpheref&", "const Buffer", "const Canvas", "const Canvas&", "const Canvas::BeginCallback&", "const Canvas::CreateCallback&", "const Canvas::DrawCallback&",
		"const Canvas::PipelineCallback&", "const CanvasElement", "const CanvasElement&", "const CanvasElement::DrawCallback&", "const CanvasVertex&", "const CanvasVertex*", "const Color&",
		"const Command", "const Compute", "const Control", "const Control&", "const ControlButton::ClickedCallback&", "const ControlButton::PressedCallback&", "const ControlButton::ReleasedCallback&",
		"const ControlCheck::ClickedCallback&", "const ControlCombo::ChangedCallback&", "const ControlCombo::ClickedCallback&", "const ControlDialog::UpdatedCallback&", "const ControlEdit::ChangedCallback&",
		"const ControlEdit::ClickedCallback&", "const ControlEdit::ReturnedCallback&", "const ControlGroup::ClickedCallback&", "const ControlPanel", "const ControlRect::ClickedCallback&",
		"const ControlRect::InsideCallback&", "const ControlRect::PressedCallback&", "const ControlRect::ReleasedCallback&", "const ControlRoot", "const ControlRoot::CopyCallback&",
		"const ControlRoot::PasteCallback&", "const ControlScroll", "const ControlScroll::ChangedCallback&", "const ControlScroll::ClickedCallback&", "const ControlSlider::ChangedCallback&",
		"const ControlSlider::ClickedCallback&", "const ControlSlider::FormatCallback&", "const ControlSlider::PressedCallback&", "const ControlSlider::ReleasedCallback&", "const ControlTree::ChangedCallback&",
		"const ControlTree::ClickedCallback&", "const ControlTree::DraggedCallback&", "const ControlTree::DroppedCallback&", "const ControlTree::ExpandedCallback&", "const ControlTree::SelectedCallback&",
		"const Controller::ButtonPressedCallback&", "const Controller::ButtonReleasedCallback&", "const Controller::ConnectedCallback&", "const Controller::DisconnectedCallback&",
		"const Device", "const Device&", "const Device::Features&", "const DialogColor::ChangedCallback&", "const DialogColor::UpdateCallback&", "const DialogDirectory::UpdateCallback&",
		"const DialogFileOpen::UpdateCallback&", "const DialogFileSave::UpdateCallback&", "const DialogMenu::ChangedCallback&", "const DialogMenu::ClickedCallback&", "const DialogMenu::UpdateCallback&",
		"const DialogMessage::UpdateCallback&", "const Fence", "const FontBatch*", "const FontBatch32*", "const FontStyle&", "const GradientStyle&", "const Image", "const Image&", "const ImageColor&",
		"const InitializerList<Buffer>&", "const InitializerList<BufferTable>&", "const InitializerList<Query>&", "const InitializerList<Sampler>&", "const InitializerList<Texture>&",
		"const InitializerList<TextureTable>&", "const InitializerList<Tracing>&", "const InitializerList<const char*>&", "const InitializerList<size_t>&", "const InitializerList<uint16_t>&",
		"const Json", "const Kernel", "const Kernel&", "const Matrix3x2f&", "const Matrix4x3d&", "const Matrix4x3f&", "const Matrix4x4f&", "const Mesh", "const Mesh&", "const MeshAnimation",
		"const MeshAnimation&", "const MeshAttachment", "const MeshAttachment&", "const MeshAttribute", "const MeshAttribute&", "const MeshGeometry", "const MeshGeometry&", "const MeshIndices",
		"const MeshIndices&", "const MeshJoint", "const MeshJoint&", "const MeshMaterial", "const MeshMaterial&", "const MeshModel::CreateCallback&", "const MeshNode", "const MeshNode&",
		"const MeshTransform", "const MeshTransform::MorphKeys&", "const MeshTransform::RotateKeys&", "const MeshTransform::ScaleKeys&", "const MeshTransform::TranslateKeys&", "const Origin&",
		"const Pipeline", "const Pipeline&", "const Pipeline*", "const Quaternionf&", "const Query", "const Rect&", "const Region&", "const Region*", "const Sampler", "const Sampler&", "const Scissor&",
		"const Scissor*", "const Shader", "const Size&", "const Slice&", "const Slice*", "const String&", "const String*", "const StrokeStyle&", "const Target", "const Target&", "const Tensor&",
		"const Texture", "const Texture&", "const Tracing", "const Tracing&", "const Tracing::Instance*", "const Traversal", "const Traversal&", "const Vector2f&", "const Vector3d&", "const Vector3f&",
		"const Vector3f*", "const Vector4f&", "const Viewport&", "const Viewport*", "const Window::CloseClickedCallback&", "const Window::FileDroppedCallback&", "const Window::FocusChangedCallback&",
		"const Window::KeyboardPressedCallback&", "const Window::KeyboardReleasedCallback&", "const Window::MainLoopCallback&", "const Window::MouseChangedCallback&", "const Window::MousePressedCallback&",
		"const Window::MouseReleasedCallback&", "const Window::MouseRotatedCallback&", "const Window::PauseChangedCallback&", "const Window::PresentCallback&", "const Window::SizeChangedCallback&",
		"const Window::TouchChangedCallback&", "const Window::UpdateCallback&", "const Xml", "const char*", "const char**", "const float32_t*", "const float64_t*", "const int32_t*", "const uint32_t*",
		"const uint8_t(*)[256]", "const uint8_t*", "const void*", "constrained", "context", "control", "controller", "copy", "copyBuffer", "copyDirectory", "copyFile", "copyParameters", "copyQueries",
		"copyQuery", "copyTexture", "copyTracing", "copyTracings", "count", "count_offset", "create", "create2D", "create3D", "createBasis", "createBounds", "createBuffer", "createBufferTable", "createCommand",
		"createCommandDevice", "createCompute", "createComputeDevice", "createCopyDevice", "createCube", "createCubic", "createDevice", "createDirectory", "createFence", "createGLSL", "createGlobalTransforms",
		"createIslands", "createKernel", "createLocalTransforms", "createMipmaps", "createNormals", "createPipeline", "createQuadratic", "createQuery", "createSPIRV", "createSVG", "createSampler",
		"createShader", "createShaderGLSL", "createShaderSPIRV", "createTangents", "createTarget", "createTexture", "createTexture2D", "createTexture3D", "createTextureCube", "createTextureTable",
		"createTracing", "createTraversal", "created", "cubic", "current", "cursor", "data", "data_offset", "data_offsets", "date", "day", "decodeBase64", "decodeLz4", "decodeZip", "delay", "delimiter",
		"delta", "depth", "depth_stencil", "depth_stencil_view", "descriptor", "dest", "dest_component", "dest_offset", "dest_origin", "dest_slice", "destroyPtr", "device", "devices", "dfail_op", "digits",
		"disabled", "discard", "dispatch", "dispatchIndirect", "dispatchYUV", "dispatch_offset", "distance", "dpass_op", "draw", "drawArrays", "drawArraysIndirect", "drawArraysInstanced", "drawElements",
		"drawElementsIndirect", "drawElementsInstanced", "drawInstanced", "drawMesh", "drawMeshIndirect", "dx", "dy", "dynamic", "element", "empty", "enabled", "encodeBase64", "encodeLz4", "encodeLz4Best",
		"encodeLz4Fast", "encodeZip", "encodeZipBest", "encodeZipFast", "encoder", "end", "endConditional", "endEncoder", "endQuery", "enqueue", "error", "execute", "expand", "expanded", "exponent", "fail_op",
		"false", "family", "fd", "features", "fence", "fences", "filter", "findAnimation", "findAttachment", "findAttribute", "findAxis", "findButton", "findChild", "findController", "findElement", "findFile",
		"findGeometry", "findIndices", "findItemChild", "findItemText", "findJoint", "findMaterial", "findMipmap", "findMotor", "findNode", "findParameter", "findStick", "findTouch", "finish", "flags",
		"flip", "flipX", "flipY", "flip_x", "flip_y", "float32_t", "float32_t&", "float32_t*", "float64_t", "float64_t*", "flush", "flushBuffer", "flushBuffers", "flushTexture", "flushTextures", "flushTracing",
		"flushTracings", "focused", "foldable", "force", "format", "frame", "framebuffer", "framebuffer_id", "frames", "from", "front", "fullscreen", "func", "g", "geometries", "geometry", "get", "get2D", "get3D",
		"getAPIHash", "getAccelerationStructure", "getAdapter", "getAddress", "getAdvance", "getAlign", "getAlignedSize", "getAlphaToCoverage", "getAnimation", "getAnimations", "getAnisotropy",
		"getArgument", "getArguments", "getArrayChannels", "getArrayFormat", "getAttachment", "getAttachments", "getAttribute", "getAttributeFormat", "getAttributeName", "getAttributeOffset",
		"getAttributeRate", "getAttributeStride", "getAttributeType", "getAttributeVertex", "getAttributef32", "getAttributef64", "getAttributei32", "getAttributes", "getAttributeu32", "getAttributeu64",
		"getAxis", "getAxisName", "getBackground", "getBase", "getBasis", "getBasisName", "getBeginCallback", "getBinary", "getBinaryDirectory", "getBlendAlphaOp", "getBlendColorOp", "getBlendDestAlphaFunc",
		"getBlendDestColorFunc", "getBlendDestFunc", "getBlendOp", "getBlendSrcAlphaFunc", "getBlendSrcColorFunc", "getBlendSrcFunc", "getBlitEncoder", "getBlock", "getBlockHeight", "getBlockSize",
		"getBlockWidth", "getBorderColor", "getBoundBox", "getBoundBuffer", "getBoundOffset", "getBoundSphere", "getBoundStride", "getBoundsNodes", "getBuffer", "getBufferAccess", "getBufferAddress",
		"getBufferData", "getBufferDescriptor", "getBufferEvent", "getBufferID", "getBufferPtr", "getBufferState", "getBufferView", "getBuildDate", "getBuildDesc", "getBuildGeometryInfo", "getBuildInfo",
		"getBuildInputs", "getBuildSize", "getBuildSizeInfo", "getButton", "getButtonColor", "getButtonMode", "getButtonName", "getButtonPressedCallback", "getButtonRadius", "getButtonReleasedCallback",
		"getButtonValue", "getBytes", "getCPUCores", "getCPUCount", "getCPUFanSpeed", "getCPUFrequency", "getCPUName", "getCPUPower", "getCPUTemperature", "getCPUThreads", "getCPUUtilization",
		"getCPUVendor", "getCUContext", "getCallback", "getCallbackData", "getCanvas", "getCanvasMesh", "getCanvasRect", "getCanvasText", "getCapacity", "getChangedCallback", "getCheckColor",
		"getCheckText", "getCheckedColor", "getChild", "getChildren", "getClearColor", "getClearDepth", "getClearStencil", "getClicked2Callback", "getClickedCallback", "getClickedRightCallback",
		"getCloseClickedCallback", "getCodes", "getColor", "getColorDXGIFormat", "getColorFormat", "getColorImage", "getColorImageView", "getColorInternalFormat", "getColorLayer", "getColorLayers",
		"getColorMask", "getColorOp", "getColorPixelFormat", "getColorResolve", "getColorResolveSlice", "getColorTexture", "getColorTextureID", "getColorTextureSlice", "getColumnRatio", "getColumns",
		"getComboColor", "getComboText", "getCommand", "getCompareFunc", "getComponent", "getComponents", "getCompute", "getComputeEncoder", "getComputeFunction", "getComputeShader", "getConfigDirectory",
		"getConnectedCallback", "getConservativeRaster", "getContext", "getControlGrab", "getControlShader", "getController", "getControlsOffset", "getControlsSize", "getCopyCallback", "getCountPtr",
		"getCounterBuffer", "getCovarianceMatrix", "getCreateCallback", "getCube", "getCubeFace", "getCullMode", "getCurrentControl", "getCurrentDirectory", "getCurrentIndex", "getCurrentItem",
		"getCurrentText", "getD3D11Buffer", "getD3D11Context", "getD3D11Device", "getD3D11Shader", "getD3D11Texture", "getD3D12Buffer", "getD3D12Command", "getD3D12Device", "getD3D12Texture",
		"getDXGIFormat", "getData", "getDataBool", "getDataBuffer", "getDataSize", "getDataf32", "getDataf64", "getDatai32", "getDatau32", "getDatau64", "getDate", "getDay", "getDelay", "getDepth",
		"getDepthBias", "getDepthClamp", "getDepthClip", "getDepthDXGIFormat", "getDepthFormat", "getDepthFunc", "getDepthImage", "getDepthImageView", "getDepthInternalFormat", "getDepthLayer",
		"getDepthLayers", "getDepthMask", "getDepthOp", "getDepthPixelFormat", "getDepthReplace", "getDepthResolve", "getDepthResolveSlice", "getDepthSlope", "getDepthStencil", "getDepthStencilView",
		"getDepthTexture", "getDepthTextureID", "getDepthTextureSlice", "getDescription", "getDescriptor", "getDevice", "getDeviceProcAddress", "getDialogWindow", "getDigits", "getDirectories",
		"getDirectory", "getDirectoryAttributes", "getDirectoryCTime", "getDirectoryName", "getDirectorySize", "getDisconnectedCallback", "getDocumentsDirectory", "getDpiX", "getDpiY", "getDraggedCallback",
		"getDrawCallback", "getDriveNames", "getDroppedCallback", "getEditColor", "getEditMode", "getElement", "getElements", "getEncoder", "getEvaluateShader", "getExpandedCallback", "getExpandedText",
		"getFD", "getFaces", "getFactory", "getFamily", "getFeatures", "getFence", "getFile", "getFileATime", "getFileAttributes", "getFileCTime", "getFileDroppedCallback", "getFileMTime", "getFileName",
		"getFileSize", "getFiles", "getFillMode", "getFilter", "getFlags", "getFlagsName", "getFocusChangedCallback", "getFocusedControl", "getFocusedItem", "getFoldedText", "getFont", "getFontAlign",
		"getFontColor", "getFontName", "getFontScale", "getFontSize", "getFontStyle", "getFontStyleConst", "getFormat", "getFormatCallback", "getFormatName", "getFragmentFunction", "getFragmentShader",
		"getFrame", "getFrameAlign", "getFramebuffer", "getFramebufferID", "getFrontAxis", "getFrontAxisName", "getFrontMode", "getFunction", "getGLConfig", "getGLContext", "getGLDisplay", "getGLESConfig",
		"getGLESContext", "getGLESDisplay", "getGLSurface", "getGLVisual", "getGPUCount", "getGPUDevice", "getGPUFanSpeed", "getGPUFrequency", "getGPUMemory", "getGPUName", "getGPUPower", "getGPUScreens",
		"getGPUSerial", "getGPUTemperature", "getGPUUtilization", "getGPUVendor", "getGPUVersion", "getGeometries", "getGeometry", "getGeometryBaseIndex", "getGeometryBaseMeshlet", "getGeometryBaseVertex",
		"getGeometryDesc", "getGeometryShader", "getGlobalTransform", "getGradientStyle", "getGradientStyleConst", "getGroupColor", "getGroupRadius", "getGroupSize", "getGroupSizeX", "getGroupSizeY",
		"getGroupSizeZ", "getHIPContext", "getHandle", "getHandleSize", "getHarmonics", "getHashBuffer", "getHeight", "getHomeDirectory", "getHorizontalFrame", "getHorizontalRange", "getHorizontalScroll",
		"getHorizontalStep", "getHorizontalValue", "getHours", "getITransform", "getIcon", "getImageDescriptor", "getIndex", "getIndexBuffer", "getIndexData", "getIndexFormat", "getIndexOffset",
		"getIndices", "getIndirectBuffer", "getIndirectData", "getIndirectOffset", "getInputControl", "getInputSize", "getInputSource", "getInsideCallback", "getInstance", "getInstanceBuffer",
		"getInstanceDesc", "getInstanceOffset", "getInstanceProcAddress", "getInternalFormat", "getInternalPtr", "getInteropHandle", "getIsCallback", "getItem", "getItemChangedCallback", "getItemChild",
		"getItemChildren", "getItemClickedCallback", "getItemColor", "getItemData", "getItemGroupIndex", "getItemGroupSize", "getItemImage", "getItemKey", "getItemParent", "getItemText", "getItemTextureColumn",
		"getItemTextureRow", "getItemsSpacing", "getJoint", "getJointITransform", "getJoints", "getKernel", "getKernelVersion", "getKeyboardKey", "getKeyboardPressedCallback", "getKeyboardReleasedCallback",
		"getLayerSize", "getLayers", "getLibrary", "getLocalTransform", "getLodBias", "getLodMax", "getLodMin", "getMD5", "getMTLBuffer", "getMTLDevice", "getMTLTexture", "getMTime", "getMacros",
		"getMainLoopCallback", "getMargin", "getMask", "getMaterial", "getMaterialBaseIndex", "getMaterialBaseMeshlet", "getMaterialBaseVertex", "getMaterials", "getMaxElements", "getMaxHeight",
		"getMaxIndex", "getMaxNodes", "getMaxOrder", "getMaxRange", "getMaxRegions", "getMaxScale", "getMaxSize", "getMaxTime", "getMaxVisibility", "getMaxWidth", "getMemory", "getMemoryIndex",
		"getMesh", "getMeshColor", "getMeshGrid", "getMeshMargin", "getMeshRegion", "getMeshShader", "getMeshletBuffer", "getMessage", "getMetaInfo", "getMinHeight", "getMinIndex", "getMinRange",
		"getMinScale", "getMinTime", "getMinTransform", "getMinVisibility", "getMinWidth", "getMinutes", "getMipmap", "getMipmapSize", "getMipmapped", "getMipmaps", "getModalControl", "getMode",
		"getModeHeight", "getModeIndex", "getModeWidth", "getModel", "getModule", "getMonth", "getMorph", "getMorphKeys", "getMorphTransform", "getMotor", "getMotorName", "getMouse", "getMouseAlign",
		"getMouseAxis", "getMouseButton", "getMouseButtons", "getMouseChangedCallback", "getMouseControl", "getMouseCursor", "getMouseDX", "getMouseDY", "getMouseOffset", "getMousePosition",
		"getMousePressedCallback", "getMouseReleasedCallback", "getMouseRotatedCallback", "getMouseX", "getMouseY", "getMultisample", "getMultisampleRaster", "getName", "getNextText", "getNode",
		"getNodeIndex", "getNodes", "getNumAnimations", "getNumArguments", "getNumAttachments", "getNumAttributes", "getNumBounds", "getNumBuffers", "getNumChildren", "getNumClipDistances",
		"getNumCodes", "getNumCommands", "getNumComputes", "getNumControllers", "getNumCores", "getNumDevices", "getNumDirectories", "getNumDrawCommands", "getNumDrawElements", "getNumDrawPipelines",
		"getNumElements", "getNumFences", "getNumFiles", "getNumGeometries", "getNumGeometryIndices", "getNumGeometryMeshlets", "getNumGeometryPositions", "getNumGeometryPrimitives", "getNumGeometryVertices",
		"getNumIndices", "getNumInstances", "getNumItemChildren", "getNumItems", "getNumJoints", "getNumKernels", "getNumMaterialIndices", "getNumMaterialMeshlets", "getNumMaterialVertices",
		"getNumMaterials", "getNumMeshlets", "getNumModes", "getNumNodes", "getNumParameters", "getNumPipelines", "getNumPositions", "getNumQueries", "getNumQueues", "getNumSamplers", "getNumScreens",
		"getNumSelectedItems", "getNumShaders", "getNumStorages", "getNumSurfaces", "getNumTables", "getNumTargets", "getNumTasks", "getNumTexels", "getNumTextures", "getNumThreads", "getNumTouches",
		"getNumTracings", "getNumTransforms", "getNumTraversals", "getNumUniforms", "getNumVertexBuffers", "getNumVertices", "getNumViewports", "getNumWindows", "getNumber", "getOffset", "getOffsetX",
		"getOffsetY", "getOpenCallback", "getOrder", "getOutputSize", "getOutputSource", "getOverlayOrder", "getPageSize", "getPanel", "getPanelColor", "getPanelRadius", "getParameterBlob", "getParameterBool",
		"getParameterColor", "getParameterFlags", "getParameterImage", "getParameterLayout", "getParameterMatrix3x2f", "getParameterName", "getParameterScalarf32", "getParameterType", "getParameterVector4f",
		"getParent", "getParent0", "getParent1", "getParentWindow", "getParentsBuffer", "getPasswordCode", "getPasteCallback", "getPasteText", "getPatchSize", "getPathName", "getPauseChangedCallback",
		"getPipeline", "getPipelineCallback", "getPipelineHash", "getPivotTransform", "getPixelFormat", "getPixelSize", "getPlatform", "getPlatformName", "getPort", "getPosition", "getPosition0",
		"getPosition1", "getPosition2", "getPositionX", "getPositionY", "getPositions", "getPrebuildInfo", "getPrefixScan", "getPresentCallback", "getPressedCallback", "getPrevText", "getPrimitive",
		"getPrimitiveDesc", "getPrimitiveSize", "getProcAddress", "getProgress", "getPtr", "getQuery", "getQueue", "getQueueFamily", "getQueueFlags", "getRadius", "getRadixSort", "getRange", "getRasterDiscard",
		"getRayGenShader", "getRect", "getRecursionDepth", "getReductionMode", "getRefreshRate", "getRegion", "getReleasedCallback", "getRenderEncoder", "getRenderPass", "getRenderTarget", "getRenderTargetView",
		"getRenderTargetViews", "getResizeAlign", "getResizeArea", "getResized", "getReturnedCallback", "getRightAxis", "getRightAxisName", "getRoot", "getRootSignature", "getRotate", "getRotateKeys",
		"getRotated", "getSHA1", "getSampleMask", "getSampleShading", "getSampler", "getSamplerArray", "getSamplerDescriptor", "getSamplerMask", "getSamplerMasks", "getSamplerOffset", "getSamples",
		"getScale", "getScaleKeys", "getScanElements", "getScissor", "getScissorOp", "getScissorTest", "getScreenDevice", "getScreenFrequency", "getScreenHeight", "getScreenIndex", "getScreenName",
		"getScreenPositionX", "getScreenPositionY", "getScreenWidth", "getScrollColor", "getSeconds", "getSelectedCallback", "getSelectedItem", "getSelectedItems", "getSelectedText", "getSelectionIndex",
		"getSemaphore", "getShader", "getShaderBlob", "getShaderID", "getShaderResourceView", "getShaderType", "getSharedHandle", "getSharedMemory", "getSharedPtr", "getSize", "getSizeChangedCallback",
		"getSlice", "getSliderColor", "getSortElements", "getSource", "getSpacing", "getSplitSize", "getState", "getStatistics", "getStencilBackDepthFailOp", "getStencilBackDepthPassOp", "getStencilBackFailOp",
		"getStencilBackFunc", "getStencilBackMask", "getStencilDepthFailOp", "getStencilDepthPassOp", "getStencilFailOp", "getStencilFrontDepthFailOp", "getStencilFrontDepthPassOp", "getStencilFrontFailOp",
		"getStencilFrontFunc", "getStencilFrontMask", "getStencilFunc", "getStencilRef", "getStep", "getStickName", "getStickX", "getStickY", "getStorageData", "getStorageFlags", "getStorageMask",
		"getStorageMasks", "getStorageOffset", "getStream", "getStride", "getString", "getStrokeColor", "getStrokeStyle", "getStrokeStyleConst", "getSurface", "getSurfaceArray", "getSurfaceMask",
		"getSurfaceMasks", "getSurfaceOffset", "getSwapChain", "getSystemMemory", "getSystemName", "getSystemUptime", "getSystemVersion", "getTableFlags", "getTableMask", "getTableOffset", "getTableSize",
		"getTableType", "getTarget", "getTaskShader", "getTempDirectory", "getTexCoord", "getTexel", "getTexelDescriptor", "getTexelMask", "getTexelMasks", "getTexelOffset", "getTexels", "getText",
		"getTextColor", "getTextOffset", "getTexture", "getTextureArray", "getTextureColumns", "getTextureFlipX", "getTextureFlipY", "getTextureHeight", "getTextureID", "getTextureLayout", "getTextureLevel",
		"getTextureLinear", "getTextureMask", "getTextureMasks", "getTextureName", "getTextureOffset", "getTextureProj", "getTextureRange", "getTextureRows", "getTextureScaleX", "getTextureScaleY",
		"getTextureState", "getTextureType", "getTextureView", "getTextureWidth", "getThreshold", "getTileDepth", "getTileHeight", "getTileMipmaps", "getTileSize", "getTileWidth", "getTime", "getTimeZone",
		"getTimeout", "getTitle", "getTouchChangedCallback", "getTouchX", "getTouchY", "getTracing", "getTracingAddress", "getTracingBuffer", "getTracingDescriptor", "getTracingEncoder", "getTracingMask",
		"getTracingMasks", "getTracingOffset", "getTransform", "getTransformOp", "getTransforms", "getTranslate", "getTranslateKeys", "getTraversal", "getType", "getTypeName", "getTypeSize", "getUniformData",
		"getUniformFlags", "getUniformMask", "getUniformMasks", "getUniformOffset", "getUnorderedAccessView", "getUpAxis", "getUpAxisName", "getUpdateCallback", "getUpdateElements", "getUpdateSize",
		"getUpdatedCallback", "getVKBuffer", "getVKCommand", "getVKDevice", "getVKFence", "getVKTexture", "getValue", "getValuef32", "getValuei32", "getValueu32", "getVendor", "getVersion", "getVertex",
		"getVertexBuffer", "getVertexBufferOffset", "getVertexBufferStride", "getVertexColor", "getVertexData", "getVertexFormat", "getVertexFunction", "getVertexOffset", "getVertexPosition",
		"getVertexRate", "getVertexShader", "getVertexStride", "getVertexTexCoord", "getVerticalFrame", "getVerticalRange", "getVerticalScroll", "getVerticalStep", "getVerticalValue", "getVertices",
		"getViewRect", "getViewport", "getVisibilityError", "getWidth", "getWindow", "getWrapMode", "getWrapModeR", "getWrapModeS", "getWrapModeT", "getYear", "gets", "grab", "grid", "groups", "handshake",
		"hasAlign", "hasAligns", "hasAnisotropy", "hasAttribute", "hasCache", "hasColorLayers", "hasDepthLayers", "hasFaces", "hasFlag", "hasFlags", "hasFontAlign", "hasFontAligns", "hasFrameAlign",
		"hasFrameAligns", "hasGeometryAttribute", "hasGeometryIndices", "hasIndices", "hasLayers", "hasMemoryType", "hasMipmaps", "hasMorphKeys", "hasMouseAlign", "hasMouseAligns", "hasMultisample",
		"hasParameter", "hasParameterFlag", "hasParameterFlags", "hasQuery", "hasResizeAlign", "hasResizeAligns", "hasRotateKeys", "hasScaleKeys", "hasShader", "hasSolidIndices", "hasSurface",
		"hasTarget", "hasTexture", "hasTransformKeys", "hasTranslateKeys", "hasVisibilityRange", "hash", "height", "hidden", "hierarchy", "horizontal", "hours", "i0", "i1", "i2", "i3", "image", "image_flags",
		"image_view", "includes", "index", "index_format", "indices", "info", "init", "instance", "instance_buffer", "instance_offset", "instances", "int16_t", "int32_t", "int32_t&", "int32_t*", "int64_t",
		"int8_t", "inverseSelection", "is16BitFormat", "is2DType", "is32BitFormat", "is3DType", "is64BitFormat", "is8BitFormat", "isASTCFormat", "isAbove", "isAbsolute", "isAllocated", "isArea", "isArgument",
		"isArray", "isAtomic", "isAttribute", "isAvailable", "isBC15Format", "isBC67Format", "isBasis", "isBegan", "isBelow", "isBinormal", "isBlockFormat", "isBool", "isBoundType", "isBuildCore", "isBuildDebug",
		"isBuildFloat64", "isBuilt", "isButton", "isCallable", "isCamera", "isChanged", "isCheck", "isChecked", "isChild", "isClicked", "isClock", "isClosest", "isColor", "isColorFormat", "isCombo", "isCompute",
		"isConnected", "isConstPtr", "isConstrained", "isControl", "isCrease", "isCreated", "isCubeType", "isCubic", "isCurrentControl", "isDepthFormat", "isDialog", "isDirect", "isDirectory", "isDisabled",
		"isETC2Format", "isEdge", "isEdit", "isElement", "isEllipse", "isEnabled", "isEnded", "isEvaluate", "isExpanded", "isFile", "isFirstHit", "isFlipped", "isFloatFormat", "isFocused", "isFocusedControl",
		"isFoldable", "isFont", "isFragment", "isFullscreen", "isGPUThrottling", "isGamePad", "isGeometry", "isGeometryType", "isGraphicsType", "isGrid", "isGroup", "isHidden", "isHorizontal", "isHorizontalDynamic",
		"isHorizontalEnabled", "isHorizontalHidden", "isInclude", "isIndirect", "isInitialized", "isInputControl", "isInstanceType", "isIntegerFormat", "isIntersection", "isItemChecked", "isItemChild",
		"isItemEnabled", "isItemExpanded", "isItemHidden", "isItemParent", "isItemSelected", "isJoint", "isJoints", "isJoystick", "isLight", "isLine", "isLoaded", "isMacro", "isMapped", "isMaterial",
		"isMesh", "isMeshType", "isMinimized", "isMixedFormat", "isModalControl", "isModalDisabled", "isMouseClipped", "isMouseControl", "isMouseHidden", "isMouseInside", "isMoveable", "isMultiSelection",
		"isNormFormat", "isNormal", "isNormalized", "isNull", "isNumber", "isObject", "isOccluded", "isOpened", "isOptimized", "isOwner", "isOwnerPtr", "isPacked", "isPanel", "isParentDisabled", "isParentEnabled",
		"isPixelFormat", "isPlainFormat", "isPoint", "isPointFilter", "isPosition", "isPressed", "isPrimitive", "isQuadrilateral", "isRayGen", "isRayMiss", "isRect", "isReleased", "isResizable", "isReturned",
		"isRoot", "isRunning", "isSRGBFormat", "isSamples", "isSamples1", "isSamplesType", "isScalable", "isScroll", "isScrollable", "isSelectable", "isShape", "isSignedFormat", "isSlider", "isSolid",
		"isSource", "isSpacer", "isSpatial", "isSplit", "isStatistics", "isStencilFormat", "isString", "isStrip", "isTangent", "isTask", "isTessellationType", "isTetrahedron", "isTexCoord", "isText",
		"isTextEnabled", "isTexture", "isTime", "isTimeType", "isTracingType", "isTree", "isTriangle", "isTriangleType", "isUniform", "isUnknown", "isUnsignedFormat", "isUpdated", "isValidPtr", "isVertex",
		"isVertical", "isVerticalDynamic", "isVerticalEnabled", "isVerticalHidden", "isVolume", "isWeights", "isWheel", "isWindow", "isYUV", "is_func", "isf16Format", "isf32Format", "isf64Format",
		"isi16Format", "isi32Format", "isi64Format", "isi8Format", "isu16Format", "isu32Format", "isu64Format", "isu8Format", "item", "items", "itransform", "joint", "k", "kernel", "kernels", "key", "keys",
		"keys_offset", "keys_offsets", "layer", "layer_size", "layers", "layout", "left", "level", "linear", "load", "loadCache", "loadGLSL", "loadSPIRV", "loadShader", "loadShaderGLSL", "loadShaderSPIRV",
		"loadTexture", "local", "loop", "lowerChild", "lowerElement", "m", "macros", "mad", "mag", "mapBuffer", "margin", "mask", "masks", "material", "matrix", "max", "max_attributes", "max_primitives", "max_size",
		"mergeGeometries", "mesh", "message", "min", "minimized", "minutes", "mipmap", "mode", "mode_r", "mode_s", "mode_t", "model", "month", "morph", "morphAttribute", "motor", "move", "moveable", "multi_selection",
		"multisample", "name", "new_name", "node", "nodes", "normal", "normalize", "nullptr", "num", "num_animations", "num_attachments", "num_attributes", "num_batches", "num_bounds", "num_children",
		"num_distances", "num_draws", "num_geometries", "num_indices", "num_instances", "num_joints", "num_materials", "num_nodes", "num_positions", "num_regions", "num_scissors", "num_slices",
		"num_transforms", "num_vertices", "num_viewports", "offset", "offsets", "old_animation", "old_attachment", "old_attribute", "old_geometry", "old_indices", "old_joint", "old_material", "op",
		"open", "openFile", "open_func", "optimizeAnimations", "optimizeAttribute", "optimizeAttributes", "optimizeGeometries", "optimizeIndices", "optimizeMaterials", "optimizeOrder", "optimizeTransforms",
		"optimizeWinding", "order", "origin", "owner", "p0", "p1", "p2", "p3", "packAttributes", "parameters", "parent", "paused", "pipeline", "pipelines", "platform", "popen", "port", "position", "position_0",
		"position_1", "position_2", "position_attribute", "positions", "preprocessor", "present", "primitive", "program_id", "progress", "projection", "puts", "quality", "queries", "query", "queue", "r",
		"radius", "radix", "raiseChild", "raiseElement", "range", "rate", "ratio", "read", "readLine", "readLz4", "readStream", "readString", "readToken", "readZip", "readf32", "readf64", "readi16", "readi32",
		"readi32e", "readi64", "readi64e", "readi8", "readu16", "readu32", "readu32e", "readu64", "readu64e", "readu8", "rect", "ref", "region", "regions", "relative", "release", "releaseBuffer", "releaseBufferTable",
		"releaseChildren", "releaseKernel", "releaseMouseButtons", "releasePipeline", "releaseSampler", "releaseTexture", "releaseTextureTable", "releaseTracing", "releaseTraversal", "remain",
		"remove", "removeAnimation", "removeAttachment", "removeAttribute", "removeAttributes", "removeChild", "removeDirectory", "removeElement", "removeFile", "removeFont", "removeGeometry",
		"removeInclude", "removeIndices", "removeItem", "removeItemChild", "removeItemChildren", "removeJoint", "removeMacro", "removeMaterial", "removeNode", "removeParameter", "removeTexture",
		"rename", "render", "render_pass", "render_target", "render_target_view", "repeat", "replaceAnimation", "replaceAttachment", "replaceAttribute", "replaceAttributeIndices", "replaceGeometry",
		"replaceIndices", "replaceJoint", "replaceMaterial", "reserveAnimations", "reserveAttachments", "reserveAttributes", "reserveChildren", "reserveGeometries", "reserveIndices", "reserveJoints",
		"reserveMaterials", "reserveNodes", "reservePositions", "reserveVertices", "reset", "resizable", "restoreMode", "result", "right", "root", "rotate", "row", "rows", "run", "s", "sample_mask", "sampler",
		"samplers", "save", "saveCache", "saveState", "scalable", "scale", "scale_x", "scale_y", "scan", "scissor", "scissors", "scrollable", "sec", "seconds", "seek", "seekBack", "seekCur", "select", "selectable",
		"selected", "selection_index", "semaphore", "set", "set2D", "set3D", "setAbove", "setAbsolute", "setAlign", "setAlphaToCoverage", "setAnisotropy", "setAttribute", "setAttributeFormat", "setAttributeOffset",
		"setAttributeRate", "setAttributeStride", "setAttributeType", "setAttributeVertex", "setAttributes", "setAxis", "setAxisName", "setBackground", "setBase", "setBasis", "setBatches", "setBeginCallback",
		"setBlend", "setBlendAlpha", "setBlendColor", "setBlock", "setBorderColor", "setBoundBox", "setBoundBuffer", "setBoundSphere", "setBoxWeights", "setBuffer", "setBufferAccess", "setBufferState",
		"setBufferTable", "setBuffers", "setButton", "setButtonColor", "setButtonMode", "setButtonName", "setButtonPressedCallback", "setButtonRadius", "setButtonReleasedCallback", "setButtonValue",
		"setCache", "setCallback", "setCanvas", "setCapacity", "setChangedCallback", "setCheckColor", "setCheckText", "setChecked", "setCheckedColor", "setChild", "setClearColor", "setClearDepth",
		"setClicked2Callback", "setClickedCallback", "setClickedRightCallback", "setCloseClickedCallback", "setColor", "setColorFormat", "setColorImage", "setColorImageView", "setColorLayer",
		"setColorMask", "setColorResolve", "setColorTexture", "setColorTextureID", "setColumnRatio", "setColumns", "setComboColor", "setComboText", "setCompareFunc", "setConnectedCallback",
		"setConservativeRaster", "setConstrained", "setCopyCallback", "setCopyText", "setCreateCallback", "setCreated", "setCube", "setCubic", "setCullMode", "setCurrentControl", "setCurrentIndex",
		"setCurrentItem", "setCurrentText", "setData", "setDate", "setDay", "setDelay", "setDepthBias", "setDepthClip", "setDepthFormat", "setDepthFunc", "setDepthImage", "setDepthImageView", "setDepthLayer",
		"setDepthMask", "setDepthReplace", "setDepthResolve", "setDepthStencil", "setDepthStencilView", "setDepthTexture", "setDepthTextureID", "setDescriptor", "setDigits", "setDirectory",
		"setDisabled", "setDisconnectedCallback", "setDraggedCallback", "setDrawCallback", "setDroppedCallback", "setEditColor", "setEditMode", "setEnabled", "setExpanded", "setExpandedCallback",
		"setExpandedText", "setFile", "setFileAttributes", "setFileDroppedCallback", "setFileMTime", "setFillMode", "setFilter", "setFlags", "setFocusChangedCallback", "setFocused", "setFocusedControl",
		"setFoldable", "setFoldedText", "setFontAlign", "setFontBlob", "setFontColor", "setFontName", "setFontScale", "setFontSize", "setFontStyle", "setFormat", "setFormatCallback", "setFrame",
		"setFrameAlign", "setFramebuffer", "setFramebufferID", "setFrontMode", "setFullscreen", "setGaussianWeights", "setGeometry", "setGlobalTransform", "setGradientStyle", "setGroupColor",
		"setGroupRadius", "setGroupSize", "setHandleSize", "setHidden", "setHorizontalEnabled", "setHorizontalStep", "setHorizontalValue", "setHours", "setITransform", "setIcon", "setInclude",
		"setIndex", "setIndexBuffer", "setIndexBufferCallback", "setIndexData", "setIndexOffset", "setIndices", "setIndirect", "setIndirectBuffer", "setIndirectData", "setIndirectOffset", "setInputControl",
		"setInputSize", "setInputSource", "setInsideCallback", "setInstanceBuffer", "setItemChecked", "setItemColor", "setItemData", "setItemEnabled", "setItemExpanded", "setItemHidden", "setItemImage",
		"setItemKey", "setItemParent", "setItemSelected", "setItemText", "setItemTexture", "setItemsGroup", "setItemsSpacing", "setJointITransform", "setKernel", "setKeyboardKey", "setKeyboardPressedCallback",
		"setKeyboardReleasedCallback", "setLocalTransform", "setLod", "setLodBias", "setLodMax", "setLodMin", "setMacro", "setMacros", "setMargin", "setMask", "setMaxSize", "setMaxVisibility", "setMesh",
		"setMeshBufferCallback", "setMeshColor", "setMeshRegion", "setMeshRegions", "setMessage", "setMetaInfo", "setMinSize", "setMinVisibility", "setMinimized", "setMinutes", "setMipmap", "setModalControl",
		"setMode", "setModel", "setMonth", "setMorph", "setMorphKeys", "setMorphTransform", "setMotor", "setMotorName", "setMouse", "setMouseAlign", "setMouseAxis", "setMouseButton", "setMouseButtons",
		"setMouseChangedCallback", "setMouseClipped", "setMouseControl", "setMouseCursor", "setMouseDelta", "setMouseHidden", "setMouseOffset", "setMousePosition", "setMousePressedCallback",
		"setMouseReleasedCallback", "setMouseRotatedCallback", "setMoveable", "setMultiSelection", "setMultisample", "setMultisampleRaster", "setName", "setNextText", "setNode", "setNumBounds",
		"setNumClipDistances", "setNumIndices", "setNumInstances", "setNumPositions", "setNumTransforms", "setNumVertices", "setNumViewports", "setOffset", "setOrder", "setOutputSize", "setOutputSource",
		"setOverlayOrder", "setPanelColor", "setPanelRadius", "setParameters", "setParent", "setParent0", "setParent1", "setPasswordCode", "setPasteCallback", "setPatchSize", "setPauseChangedCallback",
		"setPipeline", "setPipelineCallback", "setPipelineHash", "setPivotTransform", "setPlatform", "setPosition", "setPosition0", "setPosition1", "setPosition2", "setPositions", "setPresentCallback",
		"setPressedCallback", "setPrevText", "setPrimitive", "setProgress", "setRadius", "setRange", "setRasterDiscard", "setRect", "setRecursionDepth", "setReductionMode", "setRefreshRate", "setReleasedCallback",
		"setRenderPass", "setRenderTarget", "setRenderTargetView", "setResizable", "setResizeArea", "setReturnedCallback", "setRotate", "setRotateKeys", "setSampleMask", "setSampleShading",
		"setSampler", "setSamplerArray", "setSamplerMask", "setSamplerMasks", "setSamplerOffset", "setSamplers", "setScalable", "setScale", "setScaleKeys", "setScaleRange", "setScissor", "setScissorTest",
		"setScissors", "setScrollColor", "setScrollable", "setSeconds", "setSelectable", "setSelectedCallback", "setSelection", "setShader", "setSize", "setSizeChangedCallback", "setSliderColor",
		"setSobelXWeights", "setSobelYWeights", "setSpacing", "setSplitSize", "setStencilBackFunc", "setStencilBackMask", "setStencilFrontFunc", "setStencilFrontMask", "setStencilFunc", "setStencilMask",
		"setStencilRef", "setStep", "setStick", "setStickName", "setStorageBuffer", "setStorageBuffers", "setStorageData", "setStorageFlags", "setStorageMask", "setStorageMasks", "setStorageOffset",
		"setStorageTable", "setStorageTables", "setStorages", "setString", "setStrokeColor", "setStrokeStyle", "setSurface", "setSurfaceArray", "setSurfaceMask", "setSurfaceMasks", "setSurfaceOffset",
		"setSurfaceTexture", "setSurfaceTextures", "setSurfaces", "setSwapChain", "setTableFlags", "setTableMask", "setTableOffset", "setTableType", "setTexCoord", "setTexel", "setTexelBuffer",
		"setTexelBuffers", "setTexelMask", "setTexelMasks", "setTexelOffset", "setTexels", "setText", "setTextColor", "setTextEnabled", "setTextOffset", "setTexture", "setTextureArray", "setTextureBlob",
		"setTextureFlip", "setTextureGrid", "setTextureLayout", "setTextureMask", "setTextureMasks", "setTextureName", "setTextureOffset", "setTextureProj", "setTextureScale", "setTextureState",
		"setTextureTable", "setTextureTables", "setTextures", "setThreshold", "setTime", "setTimeout", "setTitle", "setTouchChangedCallback", "setTracing", "setTracingMask", "setTracingMasks",
		"setTracingOffset", "setTracings", "setTransform", "setTranslate", "setTranslateKeys", "setTraversal", "setType", "setUniformBuffer", "setUniformBuffers", "setUniformData", "setUniformFlags",
		"setUniformMask", "setUniformMasks", "setUniformOffset", "setUniforms", "setUpdateCallback", "setUpdatedCallback", "setValue", "setVertex", "setVertexBuffer", "setVertexBufferCallback",
		"setVertexBuffers", "setVertexColor", "setVertexData", "setVertexOffset", "setVertexPosition", "setVertexTexCoord", "setVertical", "setVerticalEnabled", "setVerticalStep", "setVerticalValue",
		"setVertices", "setViewport", "setViewports", "setVisibilityError", "setVisibilityRange", "setWeights", "setWidth", "setWrapMode", "setWrapModeR", "setWrapModeS", "setWrapModeT", "setYear",
		"shader", "shaders", "shared", "shutdown", "sigma", "signalFence", "signalSemaphore", "signalVKFence", "size", "size_t", "size_t*", "sizeof(DrawArraysIndirect)", "sizeof(DrawElementsIndirect)",
		"sizeof(DrawMeshIndirect)", "sizes", "slice", "slices", "slope", "socket", "sort", "spacing", "spatial", "sphere", "src", "src_0", "src_1", "src_2", "src_component", "src_offset", "src_region", "src_slice",
		"state", "status", "stencil", "step", "stick", "stop", "str", "stream", "stride", "style", "surface", "swap", "swap_chain", "switchChecked", "switchItemExpanded", "switchItemHidden", "switchItemSelected",
		"t", "table", "tables", "tangent", "target", "targets", "task", "tasks", "tell", "term", "texcoord", "text", "texture", "texture_format", "texture_id", "textures", "threshold", "time", "timeout", "title",
		"to", "toDirect", "toFormat", "toType", "top", "touch", "tracing", "tracings", "transform", "translate", "transparent", "traversal", "traversals", "true", "tx", "ty", "type", "types", "uint16_t", "uint32_t",
		"uint32_t&", "uint32_t*", "uint32_t[4]", "uint32_t[5]", "uint64_t", "uint8_t", "uint8_t*", "unacquirePtr", "unmapBuffer", "unpackAttributes", "up", "update", "updateKeyboard", "usec", "va_list",
		"validate", "value", "value_0", "value_1", "value_2", "value_3", "values", "vector", "version", "vertex", "vertex_format", "vertex_stride", "vertical", "vertices", "view", "viewItem", "viewport",
		"viewports", "void", "void*", "vprintf", "wait", "waitFence", "waitSemaphore", "waitVKFence", "wasButtonPressed", "wasButtonReleased", "wasConnected", "wasEnabled", "wasKeyboardKeyPressed",
		"wasKeyboardKeyReleased", "wasMouseButtonReleased", "wasUpdated", "weights", "width", "window", "wrap", "write", "writeLz4", "writeLz4Best", "writeLz4Fast", "writeStream", "writeString", "writeZip",
		"writeZipBest", "writeZipFast", "writef32", "writef64", "writei16", "writei32", "writei32e", "writei64", "writei64e", "writei8", "writeu16", "writeu32", "writeu32e", "writeu64", "writeu64e", "writeu8",
		"x", "y", "year", "z", "~0ull"
	};
	
	// Tellusim::App
	class ReflectionApp : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return App::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<App, TypeList<int32_t, char**>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<App>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(App::*)()>(&App::clear));
						case 1: return FunctionPtr(new FunctionImpl<Platform(App::*)() const>(&App::getPlatform));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(App::*)() const>(&App::getDevice));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(App::*)() const>(&App::getWidth));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(App::*)() const>(&App::getHeight));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(App::*)() const>(&App::getMultisample));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(App::*)() const>(&App::getNumArguments));
						case 7: return FunctionPtr(new FunctionImpl<const String&(App::*)(uint32_t) const>(&App::getArgument));
						case 8: return FunctionPtr(new FunctionImpl<const Array<String>&(App::*)() const>(&App::getArguments));
						case 9: return FunctionPtr(new FunctionImpl<bool(App::*)(const char*) const>(&App::isArgument));
						case 10: return FunctionPtr(new FunctionImpl<const String&(App::*)(const char*) const>(&App::getArgument));
						case 11: return FunctionPtr(new FunctionImpl<bool(App::*)(Platform, uint32_t)>(&App::create, Tellusim::PlatformUnknown, App::Version));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Platform, uint32_t)>(&App::setPlatform, (Platform)0, Maxu32));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(uint32_t, uint32_t, uint32_t)>(&App::setSize, {}, {}, 0));
						case 14: return FunctionPtr(new FunctionImpl<bool()>(&App::isBuildCore));
						case 15: return FunctionPtr(new FunctionImpl<bool()>(&App::isBuildDebug));
						case 16: return FunctionPtr(new FunctionImpl<bool()>(&App::isBuildFloat64));
						case 17: return FunctionPtr(new FunctionImpl<String()>(&App::getBuildDate));
						case 18: return FunctionPtr(new FunctionImpl<String()>(&App::getBuildInfo));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t()>(&App::getVersion));
						case 20: return FunctionPtr(new FunctionImpl<uint64_t()>(&App::getAPIHash));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 3003, 1606 };
			static constexpr uint16_t constructor_arg_names[] = { 1555, 1557 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_names[] = { 1612, 2668, 2298, 2927, 2410, 2554, 2562, 2092, 2093, 3020, 2092, 1902, 3781, 3830, 3034, 3035, 3036, 2152, 2155, 2903, 2081 };
			static constexpr uint16_t function_types[] = { 4073, 1146, 4039, 4039, 4039, 4039, 4039, 1841, 1693, 1585, 1841, 1585, 4073, 4073, 1585, 1585, 1585, 1274, 1274, 4039, 4044 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 5, 7, 10, 10, 10, 10, 10, 10, 10, 10 };
			static constexpr uint16_t function_arg_types[] = { 4039, 1877, 1877, 1146, 4039, 1146, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3295, 3288, 3288, 3352, 4063, 3352, 1969, 4089, 2980, 3287 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 1147, 1425, 0, 984, 0, 0, 3 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0, 24 };
			static constexpr uint16_t enum_var_names[] = { 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1425 };
	};
	constexpr uint16_t ReflectionApp::constructor_bases[];
	constexpr uint16_t ReflectionApp::constructor_arg_types[];
	constexpr uint16_t ReflectionApp::constructor_arg_names[];
	constexpr uint16_t ReflectionApp::constructor_arg_values[];
	constexpr uint8_t ReflectionApp::function_flags[];
	constexpr uint16_t ReflectionApp::function_names[];
	constexpr uint16_t ReflectionApp::function_types[];
	constexpr uint16_t ReflectionApp::function_bases[];
	constexpr uint16_t ReflectionApp::function_arg_types[];
	constexpr uint16_t ReflectionApp::function_arg_names[];
	constexpr uint16_t ReflectionApp::function_arg_values[];
	constexpr uint16_t ReflectionApp::callback_names[];
	constexpr uint16_t ReflectionApp::callback_types[];
	constexpr uint16_t ReflectionApp::callback_bases[];
	constexpr uint16_t ReflectionApp::callback_arg_types[];
	constexpr uint16_t ReflectionApp::callback_arg_names[];
	constexpr uint16_t ReflectionApp::enum_names[];
	constexpr uint16_t ReflectionApp::enum_bases[];
	constexpr uint16_t ReflectionApp::enum_var_names[];
	static ReflectionApp reflection_app;
	
	// Tellusim::Async
	class ReflectionAsync : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Async::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Async, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Async>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(Async::*)(uint32_t)>(&Async::init, 0));
						case 1: return FunctionPtr(new FunctionImpl<bool(Async::*)()>(&Async::shutdown));
						case 2: return FunctionPtr(new FunctionImpl<bool(Async::*)() const>(&Async::isInitialized));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t()>(&Async::getNumCores));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(Async::*)() const>(&Async::getNumThreads));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Async::*)(const Async::Task&)>(&Async::append));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Async::*)()>(&Async::clear));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(Async::*)(bool) const>(&Async::getNumTasks, false));
						case 8: return FunctionPtr(new FunctionImpl<Async::Task(Async::*)(uint32_t)>(&Async::run));
						case 9: return FunctionPtr(new FunctionImpl<Async::Task(Async::*)(uint64_t)>(&Async::run, ~0ull));
						case 10: return FunctionPtr(new FunctionImpl<bool(Async::*)(const Async::Task*, uint32_t) const>(&Async::check));
						case 11: return FunctionPtr(new FunctionImpl<bool(Async::*)(const Array<Async::Task>&) const>(&Async::check));
						case 12: return FunctionPtr(new FunctionImpl<bool(Async::*)() const>(&Async::check));
						case 13: return FunctionPtr(new FunctionImpl<bool(Async::*)(const Async::Task*, uint32_t) const>(&Async::wait));
						case 14: return FunctionPtr(new FunctionImpl<bool(Async::*)(const Array<Async::Task>&) const>(&Async::wait));
						case 15: return FunctionPtr(new FunctionImpl<bool(Async::*)() const>(&Async::wait));
						case 16: return FunctionPtr(new FunctionImpl<Async(Async::*)() const>(&Async::clonePtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Async::*)()>(&Async::clearPtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(Async::*)()>(&Async::destroyPtr));
						case 19: return FunctionPtr(new FunctionImpl<Async&(Async::*)()>(&Async::acquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<Async&(Async::*)()>(&Async::unacquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(Async::*)() const>(&Async::isValidPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(Async::*)() const>(&Async::isOwnerPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(Async::*)() const>(&Async::isConstPtr));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(Async::*)() const>(&Async::getCountPtr));
						case 25: return FunctionPtr(new FunctionImpl<const void*(Async::*)() const>(&Async::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 1, 2, 0, 0, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2997, 3955, 3099, 2573, 2617, 1552, 1612, 2614, 3475, 3475, 1607, 1607, 1607, 4076, 4076, 4076, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 1585, 4039, 4039, 4073, 4073, 4039, 63, 63, 1585, 1585, 1585, 1585, 1585, 1585, 60, 4073, 4073, 61, 61, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 2, 2, 3, 4, 5, 7, 8, 8, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11 };
			static constexpr uint16_t function_arg_types[] = { 4039, 1704, 1585, 4039, 4044, 1705, 4039, 1665, 1705, 4039, 1665 };
			static constexpr uint16_t function_arg_names[] = { 3295, 4006, 1607, 3260, 3260, 4007, 3295, 4007, 4007, 3295, 4007 };
			static constexpr uint16_t function_arg_values[] = { 3, 0, 2016, 0, 4119, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionAsync::constructor_bases[];
	constexpr uint16_t ReflectionAsync::constructor_arg_types[];
	constexpr uint16_t ReflectionAsync::constructor_arg_names[];
	constexpr uint16_t ReflectionAsync::constructor_arg_values[];
	constexpr uint8_t ReflectionAsync::function_flags[];
	constexpr uint16_t ReflectionAsync::function_names[];
	constexpr uint16_t ReflectionAsync::function_types[];
	constexpr uint16_t ReflectionAsync::function_bases[];
	constexpr uint16_t ReflectionAsync::function_arg_types[];
	constexpr uint16_t ReflectionAsync::function_arg_names[];
	constexpr uint16_t ReflectionAsync::function_arg_values[];
	constexpr uint16_t ReflectionAsync::callback_names[];
	constexpr uint16_t ReflectionAsync::callback_types[];
	constexpr uint16_t ReflectionAsync::callback_bases[];
	constexpr uint16_t ReflectionAsync::callback_arg_types[];
	constexpr uint16_t ReflectionAsync::callback_arg_names[];
	constexpr uint16_t ReflectionAsync::enum_names[];
	constexpr uint16_t ReflectionAsync::enum_bases[];
	constexpr uint16_t ReflectionAsync::enum_var_names[];
	static ReflectionAsync reflection_async;
	
	// Tellusim::Stream
	class ReflectionStream : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Stream::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Stream, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Stream>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Stream(Stream::*)()>(&Stream::move));
						case 1: return FunctionPtr(new FunctionImpl<bool(Stream::*)() const>(&Stream::isOpened));
						case 2: return FunctionPtr(new FunctionImpl<bool(Stream::*)() const>(&Stream::isMapped));
						case 3: return FunctionPtr(new FunctionImpl<bool(Stream::*)() const>(&Stream::isAvailable));
						case 4: return FunctionPtr(new FunctionImpl<size_t(Stream::*)() const>(&Stream::getSize));
						case 5: return FunctionPtr(new FunctionImpl<String(Stream::*)() const>(&Stream::getName));
						case 6: return FunctionPtr(new FunctionImpl<size_t(Stream::*)()>(&Stream::tell));
						case 7: return FunctionPtr(new FunctionImpl<bool(Stream::*)(size_t)>(&Stream::seek));
						case 8: return FunctionPtr(new FunctionImpl<bool(Stream::*)(size_t)>(&Stream::seekBack));
						case 9: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int64_t)>(&Stream::seekCur));
						case 10: return FunctionPtr(new FunctionImpl<const uint8_t*(Stream::*)() const>(&Stream::getData));
						case 11: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(void*, size_t)>(&Stream::read));
						case 12: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t)>(&Stream::write));
						case 13: return FunctionPtr(new FunctionImpl<bool(Stream::*)()>(&Stream::flush));
						case 14: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const char*)>(&Stream::puts));
						case 15: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const String&)>(&Stream::puts));
						case 16: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const char*, va_list)>(&Stream::vprintf));
						case 17: return FunctionPtr(new FunctionImpl<String(Stream::*)(bool*)>(&Stream::gets, nullptr));
						case 18: return FunctionPtr(new FunctionImpl<int8_t(Stream::*)(bool*)>(&Stream::readi8, nullptr));
						case 19: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int8_t)>(&Stream::writei8));
						case 20: return FunctionPtr(new FunctionImpl<uint8_t(Stream::*)(bool*)>(&Stream::readu8, nullptr));
						case 21: return FunctionPtr(new FunctionImpl<bool(Stream::*)(uint8_t)>(&Stream::writeu8));
						case 22: return FunctionPtr(new FunctionImpl<int16_t(Stream::*)(bool*)>(&Stream::readi16, nullptr));
						case 23: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int16_t)>(&Stream::writei16));
						case 24: return FunctionPtr(new FunctionImpl<uint16_t(Stream::*)(bool*)>(&Stream::readu16, nullptr));
						case 25: return FunctionPtr(new FunctionImpl<bool(Stream::*)(uint16_t)>(&Stream::writeu16));
						case 26: return FunctionPtr(new FunctionImpl<int32_t(Stream::*)(bool*)>(&Stream::readi32, nullptr));
						case 27: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int32_t)>(&Stream::writei32));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(Stream::*)(bool*)>(&Stream::readu32, nullptr));
						case 29: return FunctionPtr(new FunctionImpl<bool(Stream::*)(uint32_t)>(&Stream::writeu32));
						case 30: return FunctionPtr(new FunctionImpl<int64_t(Stream::*)(bool*)>(&Stream::readi64, nullptr));
						case 31: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int64_t)>(&Stream::writei64));
						case 32: return FunctionPtr(new FunctionImpl<uint64_t(Stream::*)(bool*)>(&Stream::readu64, nullptr));
						case 33: return FunctionPtr(new FunctionImpl<bool(Stream::*)(uint64_t)>(&Stream::writeu64));
						case 34: return FunctionPtr(new FunctionImpl<float32_t(Stream::*)(bool*)>(&Stream::readf32, nullptr));
						case 35: return FunctionPtr(new FunctionImpl<bool(Stream::*)(float32_t)>(&Stream::writef32));
						case 36: return FunctionPtr(new FunctionImpl<float64_t(Stream::*)(bool*)>(&Stream::readf64, nullptr));
						case 37: return FunctionPtr(new FunctionImpl<bool(Stream::*)(float64_t)>(&Stream::writef64));
						case 38: return FunctionPtr(new FunctionImpl<int32_t(Stream::*)(bool*)>(&Stream::readi32e, nullptr));
						case 39: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int32_t)>(&Stream::writei32e));
						case 40: return FunctionPtr(new FunctionImpl<uint32_t(Stream::*)(bool*)>(&Stream::readu32e, nullptr));
						case 41: return FunctionPtr(new FunctionImpl<bool(Stream::*)(uint32_t)>(&Stream::writeu32e));
						case 42: return FunctionPtr(new FunctionImpl<int64_t(Stream::*)(bool*)>(&Stream::readi64e, nullptr));
						case 43: return FunctionPtr(new FunctionImpl<bool(Stream::*)(int64_t)>(&Stream::writei64e));
						case 44: return FunctionPtr(new FunctionImpl<uint64_t(Stream::*)(bool*)>(&Stream::readu64e, nullptr));
						case 45: return FunctionPtr(new FunctionImpl<bool(Stream::*)(uint64_t)>(&Stream::writeu64e));
						case 46: return FunctionPtr(new FunctionImpl<String(Stream::*)(bool*)>(&Stream::readString, nullptr));
						case 47: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const String&)>(&Stream::writeString));
						case 48: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const char*)>(&Stream::writeString));
						case 49: return FunctionPtr(new FunctionImpl<String(Stream::*)(char, bool*, uint32_t)>(&Stream::readString, {}, nullptr, Maxu32));
						case 50: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const String&, char)>(&Stream::writeString));
						case 51: return FunctionPtr(new FunctionImpl<bool(Stream::*)(const char*, char)>(&Stream::writeString));
						case 52: return FunctionPtr(new FunctionImpl<String(Stream::*)(bool*)>(&Stream::readToken, nullptr));
						case 53: return FunctionPtr(new FunctionImpl<bool(Stream::*)(String&, bool)>(&Stream::readToken, {}, true));
						case 54: return FunctionPtr(new FunctionImpl<String(Stream::*)(bool*)>(&Stream::readLine, nullptr));
						case 55: return FunctionPtr(new FunctionImpl<bool(Stream::*)(String&, bool, bool)>(&Stream::readLine, {}, false, true));
						case 56: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::readStream, Stream::null, 0, nullptr));
						case 57: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::writeStream, Stream::null, 0, nullptr));
						case 58: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(void*, size_t)>(&Stream::readZip));
						case 59: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t, int32_t)>(&Stream::writeZip, {}, {}, -1));
						case 60: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t)>(&Stream::writeZipFast));
						case 61: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t)>(&Stream::writeZipBest));
						case 62: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(void*, size_t)>(&Stream::readLz4));
						case 63: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t, int32_t)>(&Stream::writeLz4, {}, {}, -1));
						case 64: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t)>(&Stream::writeLz4Fast));
						case 65: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(const void*, size_t)>(&Stream::writeLz4Best));
						case 66: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*, int32_t)>(&Stream::decodeZip, Stream::null, 0, nullptr, 15));
						case 67: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*, int32_t)>(&Stream::encodeZip, Stream::null, 0, nullptr, -1));
						case 68: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::encodeZipFast, Stream::null, 0, nullptr));
						case 69: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::encodeZipBest, Stream::null, 0, nullptr));
						case 70: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::decodeLz4, Stream::null, 0, nullptr));
						case 71: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*, int32_t)>(&Stream::encodeLz4, Stream::null, 0, nullptr, -1));
						case 72: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::encodeLz4Fast, Stream::null, 0, nullptr));
						case 73: return FunctionPtr(new FunctionImpl<size_t(Stream::*)(Stream&, size_t, bool*)>(&Stream::encodeLz4Best, Stream::null, 0, nullptr));
						case 74: return FunctionPtr(new FunctionImpl<Stream(Stream::*)() const>(&Stream::clonePtr));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(Stream::*)()>(&Stream::clearPtr));
						case 76: return FunctionPtr(new FunctionVoidImpl<void(Stream::*)()>(&Stream::destroyPtr));
						case 77: return FunctionPtr(new FunctionImpl<Stream&(Stream::*)()>(&Stream::acquirePtr));
						case 78: return FunctionPtr(new FunctionImpl<Stream&(Stream::*)()>(&Stream::unacquirePtr));
						case 79: return FunctionPtr(new FunctionImpl<bool(Stream::*)() const>(&Stream::isValidPtr));
						case 80: return FunctionPtr(new FunctionImpl<bool(Stream::*)() const>(&Stream::isOwnerPtr));
						case 81: return FunctionPtr(new FunctionImpl<bool(Stream::*)() const>(&Stream::isConstPtr));
						case 82: return FunctionPtr(new FunctionImpl<uint32_t(Stream::*)() const>(&Stream::getCountPtr));
						case 83: return FunctionPtr(new FunctionImpl<const void*(Stream::*)() const>(&Stream::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3284, 3139, 3118, 3024, 2760, 2556, 4008, 3493, 3494, 3495, 2260, 3380, 4092, 2056, 3367, 3367, 4075, 2934, 3394, 4108, 3400, 4114, 3389, 4103, 3395, 4109, 3390, 4104, 3396, 4110, 3392, 4106, 3398, 4112, 3387, 4101, 3388, 4102, 3391, 4105, 3397, 4111, 3393, 4107, 3399, 4113, 3384, 4097, 4097, 3384, 4097, 4097, 3385, 3385, 3381, 3381, 3383, 4096, 3386, 4098, 4100, 4099, 3382, 4093, 4095, 4094, 1955, 2001, 2003, 2002, 1954, 1998, 2000, 1999, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1272, 1585, 1585, 1585, 3961, 1274, 3961, 1585, 1585, 1585, 1884, 3961, 3961, 1585, 1585, 1585, 1585, 1274, 3007, 1585, 4045, 1585, 3002, 1585, 4038, 1585, 3003, 1585, 4039, 1585, 3006, 1585, 4044, 1585, 2051, 1585, 2054, 1585, 3003, 1585, 4039, 1585, 3006, 1585, 4044, 1585, 1274, 1585, 1585, 1274, 1585, 1585, 1274, 1585, 1274, 1585, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 3961, 1272, 4073, 4073, 1273, 1273, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 5, 7, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46, 48, 50, 51, 53, 54, 57, 60, 63, 65, 68, 70, 72, 74, 77, 79, 81, 85, 89, 92, 95, 98, 102, 105, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108 };
			static constexpr uint16_t function_arg_types[] = { 3961, 3961, 3006, 4074, 3961, 1885, 3961, 1877, 1841, 1877, 4054, 1586, 1586, 3007, 1586, 4045, 1586, 3002, 1586, 4038, 1586, 3003, 1586, 4039, 1586, 3006, 1586, 4044, 1586, 2051, 1586, 2054, 1586, 3003, 1586, 4039, 1586, 3006, 1586, 4044, 1586, 1841, 1877, 1605, 1586, 4039, 1841, 1605, 1877, 1605, 1586, 1275, 1585, 1586, 1275, 1585, 1585, 1273, 3961, 1586, 1273, 3961, 1586, 4074, 3961, 1885, 3961, 3003, 1885, 3961, 1885, 3961, 4074, 3961, 1885, 3961, 3003, 1885, 3961, 1885, 3961, 1273, 3961, 1586, 3003, 1273, 3961, 1586, 3003, 1273, 3961, 1586, 1273, 3961, 1586, 1273, 3961, 1586, 1273, 3961, 1586, 3003, 1273, 3961, 1586, 1273, 3961, 1586 };
			static constexpr uint16_t function_arg_names[] = { 3317, 3317, 3317, 1963, 3960, 3975, 3960, 3989, 3989, 2066, 1556, 3984, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 4056, 3984, 3989, 3989, 4009, 3984, 3960, 3989, 4009, 3989, 4009, 3984, 1963, 1612, 3984, 1963, 1995, 1612, 1963, 3960, 3984, 3975, 3960, 3984, 1963, 3960, 3975, 3960, 3240, 3975, 3960, 3975, 3960, 1963, 3960, 3975, 3960, 3240, 3975, 3960, 3975, 3960, 3975, 3960, 3984, 4090, 1963, 3960, 3984, 3240, 1963, 3960, 3984, 1963, 3960, 3984, 3975, 3960, 3984, 1963, 3960, 3984, 3240, 1963, 3960, 3984, 1963, 3960, 3984 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 3294, 0, 0, 0, 3294, 984, 0, 0, 0, 0, 3294, 0, 4033, 3294, 0, 2016, 4033, 0, 3, 3294, 0, 3, 3294, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 3294, 13, 0, 3, 3294, 1, 0, 3, 3294, 0, 3, 3294, 0, 3, 3294, 0, 3, 3294, 1, 0, 3, 3294, 0, 3, 3294 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionStream::constructor_bases[];
	constexpr uint16_t ReflectionStream::constructor_arg_types[];
	constexpr uint16_t ReflectionStream::constructor_arg_names[];
	constexpr uint16_t ReflectionStream::constructor_arg_values[];
	constexpr uint8_t ReflectionStream::function_flags[];
	constexpr uint16_t ReflectionStream::function_names[];
	constexpr uint16_t ReflectionStream::function_types[];
	constexpr uint16_t ReflectionStream::function_bases[];
	constexpr uint16_t ReflectionStream::function_arg_types[];
	constexpr uint16_t ReflectionStream::function_arg_names[];
	constexpr uint16_t ReflectionStream::function_arg_values[];
	constexpr uint16_t ReflectionStream::callback_names[];
	constexpr uint16_t ReflectionStream::callback_types[];
	constexpr uint16_t ReflectionStream::callback_bases[];
	constexpr uint16_t ReflectionStream::callback_arg_types[];
	constexpr uint16_t ReflectionStream::callback_arg_names[];
	constexpr uint16_t ReflectionStream::enum_names[];
	constexpr uint16_t ReflectionStream::enum_bases[];
	constexpr uint16_t ReflectionStream::enum_var_names[];
	static ReflectionStream reflection_stream;
	
	// Tellusim::Blob
	class ReflectionBlob : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Blob::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_stream;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Blob, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<Blob, TypeList<const String&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<Blob, TypeList<size_t, const char*>>({}, nullptr));
						case 3: return ConstructorPtr(new ConstructorImpl<Blob, TypeList<const uint8_t*, size_t, const char*>>({}, {}, nullptr));
						case 4: return ConstructorPtr(new ConstructorImpl<Blob, TypeList<const uint8_t(*)[256], const char*>>({}, nullptr));
						case 5: return ConstructorPtr(new ConstructorImpl<Blob, TypeList<const Blob&, bool>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Blob>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)()>(&Blob::release));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)()>(&Blob::clear));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)(const char*)>(&Blob::setName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)(const String&)>(&Blob::setName));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)(size_t)>(&Blob::setSize));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)(size_t)>(&Blob::setCapacity));
						case 6: return FunctionPtr(new FunctionImpl<size_t(Blob::*)() const>(&Blob::getCapacity));
						case 7: return FunctionPtr(new FunctionImpl<bool(Blob::*)(const uint8_t*, size_t)>(&Blob::setData));
						case 8: return FunctionPtr(new FunctionImpl<bool(Blob::*)(const uint8_t(*)[256])>(&Blob::setData));
						case 9: return FunctionPtr(new FunctionImpl<bool(Blob::*)(const Blob&)>(&Blob::setData));
						case 10: return FunctionPtr(new FunctionImpl<const uint8_t*(Blob::*)() const>(&Blob::getData));
						case 11: return FunctionPtr(new FunctionImpl<uint8_t*(Blob::*)()>(&Blob::getData));
						case 12: return FunctionPtr(new FunctionImpl<String(Blob::*)(size_t)>(&Blob::encodeBase64, 0));
						case 13: return FunctionPtr(new FunctionImpl<bool(Blob::*)(const char*)>(&Blob::decodeBase64));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)(uint32_t[4], size_t)>(&Blob::getMD5, {}, 0));
						case 15: return FunctionPtr(new FunctionImpl<String(Blob::*)(size_t)>(&Blob::getMD5, 0));
						case 16: return FunctionPtr(new FunctionImpl<String(const String&)>(&Blob::getMD5));
						case 17: return FunctionPtr(new FunctionImpl<String(const void*, size_t)>(&Blob::getMD5));
						case 18: return FunctionPtr(new FunctionImpl<String(Stream&, size_t)>(&Blob::getMD5, Stream::null, 0));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)(uint32_t[5], size_t)>(&Blob::getSHA1, {}, 0));
						case 20: return FunctionPtr(new FunctionImpl<String(Blob::*)(size_t)>(&Blob::getSHA1, 0));
						case 21: return FunctionPtr(new FunctionImpl<String(const String&)>(&Blob::getSHA1));
						case 22: return FunctionPtr(new FunctionImpl<String(const void*, size_t)>(&Blob::getSHA1));
						case 23: return FunctionPtr(new FunctionImpl<String(Stream&, size_t)>(&Blob::getSHA1, Stream::null, 0));
						case 24: return FunctionPtr(new FunctionImpl<Blob(Blob::*)() const>(&Blob::clonePtr));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)()>(&Blob::clearPtr));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(Blob::*)()>(&Blob::destroyPtr));
						case 27: return FunctionPtr(new FunctionImpl<Blob&(Blob::*)()>(&Blob::acquirePtr));
						case 28: return FunctionPtr(new FunctionImpl<Blob&(Blob::*)()>(&Blob::unacquirePtr));
						case 29: return FunctionPtr(new FunctionImpl<bool(Blob::*)() const>(&Blob::isValidPtr));
						case 30: return FunctionPtr(new FunctionImpl<bool(Blob::*)() const>(&Blob::isOwnerPtr));
						case 31: return FunctionPtr(new FunctionImpl<bool(Blob::*)() const>(&Blob::isConstPtr));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(Blob::*)() const>(&Blob::getCountPtr));
						case 33: return FunctionPtr(new FunctionImpl<const void*(Blob::*)() const>(&Blob::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 2, 4, 7, 9, 11 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1841, 3961, 1877, 1884, 3961, 1877, 1883, 1877, 1706, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 3288, 3960, 3288, 1948, 3960, 3288, 1583, 3288, 1583, 3284 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 0, 3294, 0, 0, 3294, 0, 3294, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3406, 1612, 3751, 3751, 3830, 3549, 2185, 3590, 3590, 3590, 2260, 2260, 1997, 1953, 2474, 2474, 2474, 2474, 2474, 2720, 2720, 2720, 2720, 2720, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 4073, 4073, 4073, 4073, 3961, 1585, 1585, 1585, 1884, 4046, 1274, 1585, 4073, 1274, 1274, 1274, 1274, 4073, 1274, 1274, 1274, 1274, 147, 4073, 4073, 148, 148, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 1, 2, 3, 4, 4, 6, 7, 8, 8, 8, 9, 10, 12, 13, 14, 16, 18, 20, 21, 22, 24, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1841, 3961, 3961, 1884, 3961, 1883, 1706, 3961, 1877, 4042, 3961, 3961, 1841, 1885, 3961, 1273, 3961, 4043, 3961, 3961, 1841, 1885, 3961, 1273, 3961 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3288, 3960, 3960, 1948, 3960, 1583, 1583, 3960, 3975, 2979, 3960, 3960, 3989, 3975, 3960, 3975, 3960, 2979, 3960, 3960, 3989, 3975, 3960, 3975, 3960 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 0, 0, 3, 0, 3, 3, 0, 0, 0, 0, 3 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionBlob::constructor_bases[];
	constexpr uint16_t ReflectionBlob::constructor_arg_types[];
	constexpr uint16_t ReflectionBlob::constructor_arg_names[];
	constexpr uint16_t ReflectionBlob::constructor_arg_values[];
	constexpr uint8_t ReflectionBlob::function_flags[];
	constexpr uint16_t ReflectionBlob::function_names[];
	constexpr uint16_t ReflectionBlob::function_types[];
	constexpr uint16_t ReflectionBlob::function_bases[];
	constexpr uint16_t ReflectionBlob::function_arg_types[];
	constexpr uint16_t ReflectionBlob::function_arg_names[];
	constexpr uint16_t ReflectionBlob::function_arg_values[];
	constexpr uint16_t ReflectionBlob::callback_names[];
	constexpr uint16_t ReflectionBlob::callback_types[];
	constexpr uint16_t ReflectionBlob::callback_bases[];
	constexpr uint16_t ReflectionBlob::callback_arg_types[];
	constexpr uint16_t ReflectionBlob::callback_arg_names[];
	constexpr uint16_t ReflectionBlob::enum_names[];
	constexpr uint16_t ReflectionBlob::enum_bases[];
	constexpr uint16_t ReflectionBlob::enum_var_names[];
	static ReflectionBlob reflection_blob;
	
	// Tellusim::File
	class ReflectionFile : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return File::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_stream;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<File, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<File>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(File::*)(const char*, const char*)>(&File::open));
						case 1: return FunctionPtr(new FunctionImpl<bool(File::*)(const String&, const char*)>(&File::open));
						case 2: return FunctionPtr(new FunctionImpl<bool(File::*)(int32_t, const char*, const char*)>(&File::open));
						case 3: return FunctionPtr(new FunctionImpl<bool(File::*)(const char*, const char*)>(&File::popen));
						case 4: return FunctionPtr(new FunctionImpl<bool(File::*)(const String&, const char*)>(&File::popen));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(File::*)()>(&File::close));
						case 6: return FunctionPtr(new FunctionImpl<bool(const char*)>(&File::isFile));
						case 7: return FunctionPtr(new FunctionImpl<bool(const String&)>(&File::isFile));
						case 8: return FunctionPtr(new FunctionImpl<uint64_t(const char*)>(&File::getMTime));
						case 9: return FunctionPtr(new FunctionImpl<size_t(const char*)>(&File::getSize));
						case 10: return FunctionPtr(new FunctionImpl<bool(const char*)>(&File::remove));
						case 11: return FunctionPtr(new FunctionImpl<File(File::*)() const>(&File::clonePtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(File::*)()>(&File::clearPtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(File::*)()>(&File::destroyPtr));
						case 14: return FunctionPtr(new FunctionImpl<File&(File::*)()>(&File::acquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<File&(File::*)()>(&File::unacquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(File::*)() const>(&File::isValidPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(File::*)() const>(&File::isOwnerPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(File::*)() const>(&File::isConstPtr));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(File::*)() const>(&File::getCountPtr));
						case 20: return FunctionPtr(new FunctionImpl<const void*(File::*)() const>(&File::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3327, 3327, 3327, 3353, 3353, 1648, 3075, 3075, 2478, 2760, 3419, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 1585, 1585, 1585, 4073, 1585, 1585, 4044, 3961, 1585, 557, 4073, 4073, 558, 558, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 4, 7, 9, 11, 11, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1877, 1841, 1877, 3003, 1877, 1877, 1877, 1877, 1841, 1877, 1877, 1841, 1877, 1877, 1877 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3275, 3288, 3275, 2018, 3288, 3275, 1653, 3275, 1653, 3275, 3288, 3288, 3288, 3288, 3288 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFile::constructor_bases[];
	constexpr uint16_t ReflectionFile::constructor_arg_types[];
	constexpr uint16_t ReflectionFile::constructor_arg_names[];
	constexpr uint16_t ReflectionFile::constructor_arg_values[];
	constexpr uint8_t ReflectionFile::function_flags[];
	constexpr uint16_t ReflectionFile::function_names[];
	constexpr uint16_t ReflectionFile::function_types[];
	constexpr uint16_t ReflectionFile::function_bases[];
	constexpr uint16_t ReflectionFile::function_arg_types[];
	constexpr uint16_t ReflectionFile::function_arg_names[];
	constexpr uint16_t ReflectionFile::function_arg_values[];
	constexpr uint16_t ReflectionFile::callback_names[];
	constexpr uint16_t ReflectionFile::callback_types[];
	constexpr uint16_t ReflectionFile::callback_bases[];
	constexpr uint16_t ReflectionFile::callback_arg_types[];
	constexpr uint16_t ReflectionFile::callback_arg_names[];
	constexpr uint16_t ReflectionFile::enum_names[];
	constexpr uint16_t ReflectionFile::enum_bases[];
	constexpr uint16_t ReflectionFile::enum_var_names[];
	static ReflectionFile reflection_file;
	
	// Tellusim::Socket
	class ReflectionSocket : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Socket::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_stream;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Socket, TypeList<Socket::Type>>(Socket::TypeStream));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Socket>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(Socket::*)(uint16_t, uint16_t)>(&Socket::open, {}, 32));
						case 1: return FunctionPtr(new FunctionImpl<bool(Socket::*)(const char*, uint16_t)>(&Socket::open));
						case 2: return FunctionPtr(new FunctionImpl<bool(Socket::*)(const String&, uint16_t)>(&Socket::open));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Socket::*)()>(&Socket::close));
						case 4: return FunctionPtr(new FunctionImpl<bool(Socket::*)(uint32_t, uint32_t)>(&Socket::connect, {}, 0));
						case 5: return FunctionPtr(new FunctionImpl<bool(Socket::*)(Socket&)>(&Socket::accept));
						case 6: return FunctionPtr(new FunctionImpl<bool(Socket::*)(uint32_t, uint32_t)>(&Socket::select, {}, 0));
						case 7: return FunctionPtr(new FunctionImpl<bool(Socket::*)(uint32_t)>(&Socket::setTimeout));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(Socket::*)() const>(&Socket::getTimeout));
						case 9: return FunctionPtr(new FunctionImpl<bool(Socket::*)(bool)>(&Socket::setBlock));
						case 10: return FunctionPtr(new FunctionImpl<bool(Socket::*)() const>(&Socket::getBlock));
						case 11: return FunctionPtr(new FunctionImpl<bool(Socket::*)(bool)>(&Socket::setDelay));
						case 12: return FunctionPtr(new FunctionImpl<bool(Socket::*)() const>(&Socket::getDelay));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Socket::*)(const char*)>(&Socket::setName));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Socket::*)(const String&)>(&Socket::setName));
						case 15: return FunctionPtr(new FunctionImpl<uint16_t(Socket::*)() const>(&Socket::getPort));
						case 16: return FunctionPtr(new FunctionImpl<int32_t(Socket::*)() const>(&Socket::getFD));
						case 17: return FunctionPtr(new FunctionImpl<Socket::Type(Socket::*)() const>(&Socket::getType));
						case 18: return FunctionPtr(new FunctionImpl<String(const char*)>(&Socket::getAddress, nullptr));
						case 19: return FunctionPtr(new FunctionImpl<Socket(Socket::*)() const>(&Socket::clonePtr));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(Socket::*)()>(&Socket::clearPtr));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Socket::*)()>(&Socket::destroyPtr));
						case 22: return FunctionPtr(new FunctionImpl<Socket&(Socket::*)()>(&Socket::acquirePtr));
						case 23: return FunctionPtr(new FunctionImpl<Socket&(Socket::*)()>(&Socket::unacquirePtr));
						case 24: return FunctionPtr(new FunctionImpl<bool(Socket::*)() const>(&Socket::isValidPtr));
						case 25: return FunctionPtr(new FunctionImpl<bool(Socket::*)() const>(&Socket::isOwnerPtr));
						case 26: return FunctionPtr(new FunctionImpl<bool(Socket::*)() const>(&Socket::isConstPtr));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(Socket::*)() const>(&Socket::getCountPtr));
						case 28: return FunctionPtr(new FunctionImpl<const void*(Socket::*)() const>(&Socket::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 1222 };
			static constexpr uint16_t constructor_arg_names[] = { 4036 };
			static constexpr uint16_t constructor_arg_values[] = { 1378 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 2, 2, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3327, 3327, 3327, 1648, 1664, 1503, 3496, 3903, 2859, 3527, 2131, 3593, 2271, 3751, 3751, 2670, 2324, 2878, 2084, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 1585, 4073, 1585, 1585, 1585, 1585, 4039, 1585, 1585, 1585, 1585, 4073, 4073, 4038, 3003, 1222, 1274, 1220, 4073, 4073, 1221, 1221, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 4, 6, 6, 8, 9, 11, 12, 12, 13, 13, 14, 14, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17 };
			static constexpr uint16_t function_arg_types[] = { 4038, 4038, 1877, 4038, 1841, 4038, 4039, 4039, 1221, 4039, 4039, 4039, 1585, 1585, 1877, 1841, 1877 };
			static constexpr uint16_t function_arg_names[] = { 3354, 3295, 3288, 3354, 3288, 3354, 3491, 4053, 3970, 3491, 4053, 3491, 1584, 1956, 3288, 3288, 1957 };
			static constexpr uint16_t function_arg_values[] = { 0, 19, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3294 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311 };
			static constexpr uint16_t enum_bases[] = { 0, 3 };
			static constexpr uint16_t enum_var_names[] = { 1378, 1333, 1117 };
	};
	constexpr uint16_t ReflectionSocket::constructor_bases[];
	constexpr uint16_t ReflectionSocket::constructor_arg_types[];
	constexpr uint16_t ReflectionSocket::constructor_arg_names[];
	constexpr uint16_t ReflectionSocket::constructor_arg_values[];
	constexpr uint8_t ReflectionSocket::function_flags[];
	constexpr uint16_t ReflectionSocket::function_names[];
	constexpr uint16_t ReflectionSocket::function_types[];
	constexpr uint16_t ReflectionSocket::function_bases[];
	constexpr uint16_t ReflectionSocket::function_arg_types[];
	constexpr uint16_t ReflectionSocket::function_arg_names[];
	constexpr uint16_t ReflectionSocket::function_arg_values[];
	constexpr uint16_t ReflectionSocket::callback_names[];
	constexpr uint16_t ReflectionSocket::callback_types[];
	constexpr uint16_t ReflectionSocket::callback_bases[];
	constexpr uint16_t ReflectionSocket::callback_arg_types[];
	constexpr uint16_t ReflectionSocket::callback_arg_names[];
	constexpr uint16_t ReflectionSocket::enum_names[];
	constexpr uint16_t ReflectionSocket::enum_bases[];
	constexpr uint16_t ReflectionSocket::enum_var_names[];
	static ReflectionSocket reflection_socket;
	
	// Tellusim::SocketSSL
	class ReflectionSocketSSL : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return SocketSSL::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_socket;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<SocketSSL, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<SocketSSL>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)(const char*)>(&SocketSSL::handshake, nullptr));
						case 1: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)(SocketSSL&)>(&SocketSSL::accept));
						case 2: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)(Socket&)>(&SocketSSL::accept));
						case 3: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)(Stream&)>(&SocketSSL::load));
						case 4: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)(const char*)>(&SocketSSL::load));
						case 5: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)(const String&)>(&SocketSSL::load));
						case 6: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)() const>(&SocketSSL::isConnected));
						case 7: return FunctionPtr(new FunctionImpl<SocketSSL(SocketSSL::*)() const>(&SocketSSL::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(SocketSSL::*)()>(&SocketSSL::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(SocketSSL::*)()>(&SocketSSL::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<SocketSSL&(SocketSSL::*)()>(&SocketSSL::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<SocketSSL&(SocketSSL::*)()>(&SocketSSL::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)() const>(&SocketSSL::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)() const>(&SocketSSL::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(SocketSSL::*)() const>(&SocketSSL::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(SocketSSL::*)() const>(&SocketSSL::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(SocketSSL::*)() const>(&SocketSSL::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 4, 4, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2938, 1503, 1503, 3242, 3242, 3242, 3052, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1223, 4073, 4073, 1224, 1224, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1224, 1221, 1273, 1877, 1841 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3970, 3970, 3990, 3288, 3288 };
			static constexpr uint16_t function_arg_values[] = { 3294, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionSocketSSL::constructor_bases[];
	constexpr uint16_t ReflectionSocketSSL::constructor_arg_types[];
	constexpr uint16_t ReflectionSocketSSL::constructor_arg_names[];
	constexpr uint16_t ReflectionSocketSSL::constructor_arg_values[];
	constexpr uint8_t ReflectionSocketSSL::function_flags[];
	constexpr uint16_t ReflectionSocketSSL::function_names[];
	constexpr uint16_t ReflectionSocketSSL::function_types[];
	constexpr uint16_t ReflectionSocketSSL::function_bases[];
	constexpr uint16_t ReflectionSocketSSL::function_arg_types[];
	constexpr uint16_t ReflectionSocketSSL::function_arg_names[];
	constexpr uint16_t ReflectionSocketSSL::function_arg_values[];
	constexpr uint16_t ReflectionSocketSSL::callback_names[];
	constexpr uint16_t ReflectionSocketSSL::callback_types[];
	constexpr uint16_t ReflectionSocketSSL::callback_bases[];
	constexpr uint16_t ReflectionSocketSSL::callback_arg_types[];
	constexpr uint16_t ReflectionSocketSSL::callback_arg_names[];
	constexpr uint16_t ReflectionSocketSSL::enum_names[];
	constexpr uint16_t ReflectionSocketSSL::enum_bases[];
	constexpr uint16_t ReflectionSocketSSL::enum_var_names[];
	static ReflectionSocketSSL reflection_socket_ssl;
	
	// Tellusim::Source
	class ReflectionSource : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Source::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_stream;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Source, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Source, TypeList<const uint8_t*, size_t, const char*>>({}, {}, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Source>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(Source::*)(const char*, bool, bool)>(&Source::open, {}, true, false));
						case 1: return FunctionPtr(new FunctionImpl<bool(Source::*)(const String&, bool, bool)>(&Source::open, {}, true, false));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(Source::*)()>(&Source::close));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Source::*)(const char*, size_t, size_t)>(&Source::setName));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(Source::*)(const String&, size_t, size_t)>(&Source::setName));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Source::*)(const uint8_t*, size_t, const char*)>(&Source::setData, {}, {}, nullptr));
						case 6: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Source::isSource));
						case 7: return FunctionPtr(new FunctionImpl<bool(const String&)>(&Source::isSource));
						case 8: return FunctionPtr(new FunctionImpl<uint64_t(const char*)>(&Source::getMTime));
						case 9: return FunctionPtr(new FunctionImpl<size_t(const char*)>(&Source::getSize));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Source::OpenCallback*, void*)>(&Source::setCallback, {}, nullptr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(Source::OpenCallback*, Source::IsCallback*, void*)>(&Source::setCallback, {}, {}, nullptr));
						case 12: return FunctionPtr(new FunctionImpl<Source::OpenCallback*()>(&Source::getOpenCallback));
						case 13: return FunctionPtr(new FunctionImpl<Source::IsCallback*()>(&Source::getIsCallback));
						case 14: return FunctionPtr(new FunctionVoidImpl<void*()>(&Source::getCallbackData));
						case 15: return FunctionPtr(new FunctionImpl<Source(Source::*)() const>(&Source::clonePtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Source::*)()>(&Source::clearPtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Source::*)()>(&Source::destroyPtr));
						case 18: return FunctionPtr(new FunctionImpl<Source&(Source::*)()>(&Source::acquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<Source&(Source::*)()>(&Source::unacquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(Source::*)() const>(&Source::isValidPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(Source::*)() const>(&Source::isOwnerPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(Source::*)() const>(&Source::isConstPtr));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(Source::*)() const>(&Source::getCountPtr));
						case 24: return FunctionPtr(new FunctionImpl<const void*(Source::*)() const>(&Source::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 1884, 3961, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 1948, 3960, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3327, 3327, 1648, 3751, 3751, 3590, 3175, 3175, 2478, 2760, 3547, 3547, 2631, 2442, 2180, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 4073, 4073, 4073, 4073, 1585, 1585, 4044, 3961, 4073, 4073, 1230, 1229, 4074, 1227, 4073, 4073, 1228, 1228, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 3, 6, 6, 9, 12, 15, 16, 17, 18, 19, 21, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1585, 1585, 1841, 1585, 1585, 1877, 3961, 3961, 1841, 3961, 3961, 1884, 3961, 1877, 1877, 1841, 1877, 1877, 1230, 4074, 1230, 1229, 4074 };
			static constexpr uint16_t function_arg_names[] = { 3288, 1601, 4092, 3288, 1601, 4092, 3288, 3317, 3960, 3288, 3317, 3960, 1948, 3960, 3288, 3288, 3288, 3288, 3288, 3329, 1948, 3329, 3212, 1948 };
			static constexpr uint16_t function_arg_values[] = { 0, 4033, 2016, 0, 4033, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 0, 0, 0, 3294, 0, 0, 3294 };
			static constexpr uint16_t callback_names[] = { 851, 1125 };
			static constexpr uint16_t callback_types[] = { 1585, 1272 };
			static constexpr uint16_t callback_bases[] = { 0, 2, 4 };
			static constexpr uint16_t callback_arg_types[] = { 1877, 4074, 1877, 4074 };
			static constexpr uint16_t callback_arg_names[] = { 3288, 1948, 3288, 1948 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionSource::constructor_bases[];
	constexpr uint16_t ReflectionSource::constructor_arg_types[];
	constexpr uint16_t ReflectionSource::constructor_arg_names[];
	constexpr uint16_t ReflectionSource::constructor_arg_values[];
	constexpr uint8_t ReflectionSource::function_flags[];
	constexpr uint16_t ReflectionSource::function_names[];
	constexpr uint16_t ReflectionSource::function_types[];
	constexpr uint16_t ReflectionSource::function_bases[];
	constexpr uint16_t ReflectionSource::function_arg_types[];
	constexpr uint16_t ReflectionSource::function_arg_names[];
	constexpr uint16_t ReflectionSource::function_arg_values[];
	constexpr uint16_t ReflectionSource::callback_names[];
	constexpr uint16_t ReflectionSource::callback_types[];
	constexpr uint16_t ReflectionSource::callback_bases[];
	constexpr uint16_t ReflectionSource::callback_arg_types[];
	constexpr uint16_t ReflectionSource::callback_arg_names[];
	constexpr uint16_t ReflectionSource::enum_names[];
	constexpr uint16_t ReflectionSource::enum_bases[];
	constexpr uint16_t ReflectionSource::enum_var_names[];
	static ReflectionSource reflection_source;
	
	// Tellusim::Date
	class ReflectionDate : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Date::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Date, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Date, TypeList<int64_t, bool>>({}, true));
						case 2: return ConstructorPtr(new ConstructorImpl<Date, TypeList<const char*, const char*>>({}, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Date>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Date::*)()>(&Date::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(int64_t, bool)>(&Date::setTime, {}, true));
						case 2: return FunctionPtr(new FunctionImpl<int64_t(Date::*)(bool) const>(&Date::getTime, true));
						case 3: return FunctionPtr(new FunctionImpl<bool(Date::*)(const char*, const char*)>(&Date::setString, {}, nullptr));
						case 4: return FunctionPtr(new FunctionImpl<String(Date::*)(const char*) const>(&Date::getString, nullptr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setYear));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setMonth));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setDate));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setDay));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setHours));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setMinutes));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(Date::*)(uint32_t)>(&Date::setSeconds));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getYear));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getMonth));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getDate));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getDay));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getHours));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getMinutes));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getSeconds));
						case 19: return FunctionPtr(new FunctionImpl<int32_t()>(&Date::getTimeZone));
						case 20: return FunctionPtr(new FunctionImpl<Date(Date::*)() const>(&Date::clonePtr));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Date::*)()>(&Date::clearPtr));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Date::*)()>(&Date::destroyPtr));
						case 23: return FunctionPtr(new FunctionImpl<Date&(Date::*)()>(&Date::acquirePtr));
						case 24: return FunctionPtr(new FunctionImpl<Date&(Date::*)()>(&Date::unacquirePtr));
						case 25: return FunctionPtr(new FunctionImpl<bool(Date::*)() const>(&Date::isValidPtr));
						case 26: return FunctionPtr(new FunctionImpl<bool(Date::*)() const>(&Date::isOwnerPtr));
						case 27: return FunctionPtr(new FunctionImpl<bool(Date::*)() const>(&Date::isConstPtr));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(Date::*)() const>(&Date::getCountPtr));
						case 29: return FunctionPtr(new FunctionImpl<const void*(Date::*)() const>(&Date::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 4 };
			static constexpr uint16_t constructor_arg_types[] = { 3006, 1585, 1877, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 4017, 3250, 3989, 2066 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 4033, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3902, 2857, 3857, 2796, 3951, 3725, 3591, 3592, 3661, 3720, 3825, 2933, 2531, 2269, 2270, 2417, 2519, 2745, 2858, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 3006, 1585, 1274, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 3003, 429, 4073, 4073, 430, 430, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13 };
			static constexpr uint16_t function_arg_types[] = { 3006, 1585, 1585, 1877, 1877, 1877, 4039, 4039, 4039, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 4017, 3250, 3250, 3989, 2066, 2066, 4117, 3280, 1951, 1952, 2984, 3273, 3492 };
			static constexpr uint16_t function_arg_values[] = { 0, 4033, 4033, 0, 3294, 3294, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionDate::constructor_bases[];
	constexpr uint16_t ReflectionDate::constructor_arg_types[];
	constexpr uint16_t ReflectionDate::constructor_arg_names[];
	constexpr uint16_t ReflectionDate::constructor_arg_values[];
	constexpr uint8_t ReflectionDate::function_flags[];
	constexpr uint16_t ReflectionDate::function_names[];
	constexpr uint16_t ReflectionDate::function_types[];
	constexpr uint16_t ReflectionDate::function_bases[];
	constexpr uint16_t ReflectionDate::function_arg_types[];
	constexpr uint16_t ReflectionDate::function_arg_names[];
	constexpr uint16_t ReflectionDate::function_arg_values[];
	constexpr uint16_t ReflectionDate::callback_names[];
	constexpr uint16_t ReflectionDate::callback_types[];
	constexpr uint16_t ReflectionDate::callback_bases[];
	constexpr uint16_t ReflectionDate::callback_arg_types[];
	constexpr uint16_t ReflectionDate::callback_arg_names[];
	constexpr uint16_t ReflectionDate::enum_names[];
	constexpr uint16_t ReflectionDate::enum_bases[];
	constexpr uint16_t ReflectionDate::enum_var_names[];
	static ReflectionDate reflection_date;
	
	// Tellusim::Info
	class ReflectionInfo : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Info::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Info, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Info>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<size_t(Info::*)() const>(&Info::getSystemMemory));
						case 1: return FunctionPtr(new FunctionImpl<uint64_t(Info::*)() const>(&Info::getSystemUptime));
						case 2: return FunctionPtr(new FunctionImpl<String(Info::*)() const>(&Info::getSystemName));
						case 3: return FunctionPtr(new FunctionImpl<String(Info::*)() const>(&Info::getSystemVersion));
						case 4: return FunctionPtr(new FunctionImpl<String(Info::*)() const>(&Info::getKernelVersion));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)() const>(&Info::getCPUCount));
						case 6: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getCPUName));
						case 7: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getCPUVendor));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getCPUCores));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getCPUThreads));
						case 10: return FunctionPtr(new FunctionImpl<uint64_t(Info::*)(uint32_t) const>(&Info::getCPUFrequency));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getCPUTemperature));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getCPUUtilization));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getCPUFanSpeed));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getCPUPower));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)() const>(&Info::getGPUCount));
						case 16: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getGPUName));
						case 17: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getGPUVendor));
						case 18: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getGPUSerial));
						case 19: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getGPUDevice));
						case 20: return FunctionPtr(new FunctionImpl<String(Info::*)(uint32_t) const>(&Info::getGPUVersion));
						case 21: return FunctionPtr(new FunctionImpl<size_t(Info::*)(uint32_t) const>(&Info::getGPUMemory));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getGPUScreens));
						case 23: return FunctionPtr(new FunctionImpl<uint64_t(Info::*)(uint32_t) const>(&Info::getGPUFrequency));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getGPUTemperature));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getGPUUtilization));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getGPUFanSpeed));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)(uint32_t) const>(&Info::getGPUPower));
						case 28: return FunctionPtr(new FunctionImpl<bool(Info::*)(uint32_t) const>(&Info::isGPUThrottling));
						case 29: return FunctionPtr(new FunctionImpl<Info(Info::*)() const>(&Info::clonePtr));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(Info::*)()>(&Info::clearPtr));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Info::*)()>(&Info::destroyPtr));
						case 32: return FunctionPtr(new FunctionImpl<Info&(Info::*)()>(&Info::acquirePtr));
						case 33: return FunctionPtr(new FunctionImpl<Info&(Info::*)()>(&Info::unacquirePtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(Info::*)() const>(&Info::isValidPtr));
						case 35: return FunctionPtr(new FunctionImpl<bool(Info::*)() const>(&Info::isOwnerPtr));
						case 36: return FunctionPtr(new FunctionImpl<bool(Info::*)() const>(&Info::isConstPtr));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(Info::*)() const>(&Info::getCountPtr));
						case 38: return FunctionPtr(new FunctionImpl<const void*(Info::*)() const>(&Info::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2806, 2808, 2807, 2809, 2463, 2169, 2172, 2177, 2168, 2175, 2171, 2174, 2176, 2170, 2173, 2376, 2381, 2387, 2384, 2377, 2388, 2380, 2383, 2379, 2385, 2386, 2378, 2382, 3085, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 3961, 4044, 1274, 1274, 1274, 4039, 1274, 1274, 4039, 4039, 4044, 4039, 4039, 4039, 4039, 4039, 1274, 1274, 1274, 1274, 1274, 3961, 4039, 4044, 4039, 4039, 4039, 4039, 1585, 847, 4073, 4073, 848, 848, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionInfo::constructor_bases[];
	constexpr uint16_t ReflectionInfo::constructor_arg_types[];
	constexpr uint16_t ReflectionInfo::constructor_arg_names[];
	constexpr uint16_t ReflectionInfo::constructor_arg_values[];
	constexpr uint8_t ReflectionInfo::function_flags[];
	constexpr uint16_t ReflectionInfo::function_names[];
	constexpr uint16_t ReflectionInfo::function_types[];
	constexpr uint16_t ReflectionInfo::function_bases[];
	constexpr uint16_t ReflectionInfo::function_arg_types[];
	constexpr uint16_t ReflectionInfo::function_arg_names[];
	constexpr uint16_t ReflectionInfo::function_arg_values[];
	constexpr uint16_t ReflectionInfo::callback_names[];
	constexpr uint16_t ReflectionInfo::callback_types[];
	constexpr uint16_t ReflectionInfo::callback_bases[];
	constexpr uint16_t ReflectionInfo::callback_arg_types[];
	constexpr uint16_t ReflectionInfo::callback_arg_names[];
	constexpr uint16_t ReflectionInfo::enum_names[];
	constexpr uint16_t ReflectionInfo::enum_bases[];
	constexpr uint16_t ReflectionInfo::enum_var_names[];
	static ReflectionInfo reflection_info;
	
	// Tellusim::Directory
	class ReflectionDirectory : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Directory::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Directory, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Directory>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(Directory::*)(const char*, bool)>(&Directory::open, {}, false));
						case 1: return FunctionPtr(new FunctionImpl<bool(Directory::*)(const String&, bool)>(&Directory::open, {}, false));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(Directory::*)()>(&Directory::close));
						case 3: return FunctionPtr(new FunctionImpl<bool(Directory::*)() const>(&Directory::isOpened));
						case 4: return FunctionPtr(new FunctionImpl<String(Directory::*)() const>(&Directory::getName));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(Directory::*)() const>(&Directory::getNumFiles));
						case 6: return FunctionPtr(new FunctionImpl<String(Directory::*)(uint32_t) const>(&Directory::getFileName));
						case 7: return FunctionPtr(new FunctionImpl<Directory::Attributes(Directory::*)(uint32_t) const>(&Directory::getFileAttributes));
						case 8: return FunctionPtr(new FunctionImpl<uint64_t(Directory::*)(uint32_t) const>(&Directory::getFileMTime));
						case 9: return FunctionPtr(new FunctionImpl<uint64_t(Directory::*)(uint32_t) const>(&Directory::getFileATime));
						case 10: return FunctionPtr(new FunctionImpl<uint64_t(Directory::*)(uint32_t) const>(&Directory::getFileCTime));
						case 11: return FunctionPtr(new FunctionImpl<size_t(Directory::*)(uint32_t) const>(&Directory::getFileSize));
						case 12: return FunctionPtr(new FunctionImpl<const Array<String>(Directory::*)() const>(&Directory::getFiles));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(Directory::*)() const>(&Directory::getNumDirectories));
						case 14: return FunctionPtr(new FunctionImpl<String(Directory::*)(uint32_t) const>(&Directory::getDirectoryName));
						case 15: return FunctionPtr(new FunctionImpl<Directory::Attributes(Directory::*)(uint32_t) const>(&Directory::getDirectoryAttributes));
						case 16: return FunctionPtr(new FunctionImpl<uint64_t(Directory::*)(uint32_t) const>(&Directory::getDirectoryCTime));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(Directory::*)(uint32_t) const>(&Directory::getDirectorySize));
						case 18: return FunctionPtr(new FunctionImpl<const Array<String>(Directory::*)() const>(&Directory::getDirectories));
						case 19: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Directory::isFile));
						case 20: return FunctionPtr(new FunctionImpl<bool(const String&)>(&Directory::isFile));
						case 21: return FunctionPtr(new FunctionImpl<bool(const char*, Directory::Attributes)>(&Directory::setFileAttributes));
						case 22: return FunctionPtr(new FunctionImpl<Directory::Attributes(const char*)>(&Directory::getFileAttributes));
						case 23: return FunctionPtr(new FunctionImpl<bool(const char*, uint64_t)>(&Directory::setFileMTime));
						case 24: return FunctionPtr(new FunctionImpl<uint64_t(const char*)>(&Directory::getFileMTime));
						case 25: return FunctionPtr(new FunctionImpl<uint64_t(const char*)>(&Directory::getFileATime));
						case 26: return FunctionPtr(new FunctionImpl<uint64_t(const char*)>(&Directory::getFileCTime));
						case 27: return FunctionPtr(new FunctionImpl<size_t(const char*)>(&Directory::getFileSize));
						case 28: return FunctionPtr(new FunctionImpl<size_t(const String&)>(&Directory::getFileSize));
						case 29: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Directory::removeFile));
						case 30: return FunctionPtr(new FunctionImpl<bool(const String&)>(&Directory::removeFile));
						case 31: return FunctionPtr(new FunctionImpl<bool(const char*, const char*, bool)>(&Directory::copyFile, {}, {}, false));
						case 32: return FunctionPtr(new FunctionImpl<bool(const String&, const String&, bool)>(&Directory::copyFile, {}, {}, false));
						case 33: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Directory::isDirectory));
						case 34: return FunctionPtr(new FunctionImpl<bool(const String&)>(&Directory::isDirectory));
						case 35: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Directory::changeDirectory));
						case 36: return FunctionPtr(new FunctionImpl<bool(const String&)>(&Directory::changeDirectory));
						case 37: return FunctionPtr(new FunctionImpl<bool(const char*, bool)>(&Directory::createDirectory, {}, false));
						case 38: return FunctionPtr(new FunctionImpl<bool(const String&, bool)>(&Directory::createDirectory, {}, false));
						case 39: return FunctionPtr(new FunctionImpl<bool(const char*, bool)>(&Directory::removeDirectory, {}, false));
						case 40: return FunctionPtr(new FunctionImpl<bool(const String&, bool)>(&Directory::removeDirectory, {}, false));
						case 41: return FunctionPtr(new FunctionImpl<bool(const char*, const char*, bool)>(&Directory::copyDirectory, {}, {}, false));
						case 42: return FunctionPtr(new FunctionImpl<bool(const String&, const String&, bool)>(&Directory::copyDirectory, {}, {}, false));
						case 43: return FunctionPtr(new FunctionImpl<bool(const char*, const char*)>(&Directory::rename));
						case 44: return FunctionPtr(new FunctionImpl<bool(const String&, const String&)>(&Directory::rename));
						case 45: return FunctionPtr(new FunctionImpl<String()>(&Directory::getCurrentDirectory));
						case 46: return FunctionPtr(new FunctionImpl<String()>(&Directory::getBinaryDirectory));
						case 47: return FunctionPtr(new FunctionImpl<String()>(&Directory::getHomeDirectory));
						case 48: return FunctionPtr(new FunctionImpl<String()>(&Directory::getTempDirectory));
						case 49: return FunctionPtr(new FunctionImpl<String()>(&Directory::getConfigDirectory));
						case 50: return FunctionPtr(new FunctionImpl<String()>(&Directory::getDocumentsDirectory));
						case 51: return FunctionPtr(new FunctionImpl<const Array<String>()>(&Directory::getDriveNames));
						case 52: return FunctionPtr(new FunctionImpl<Directory(Directory::*)() const>(&Directory::clonePtr));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(Directory::*)()>(&Directory::clearPtr));
						case 54: return FunctionPtr(new FunctionVoidImpl<void(Directory::*)()>(&Directory::destroyPtr));
						case 55: return FunctionPtr(new FunctionImpl<Directory&(Directory::*)()>(&Directory::acquirePtr));
						case 56: return FunctionPtr(new FunctionImpl<Directory&(Directory::*)()>(&Directory::unacquirePtr));
						case 57: return FunctionPtr(new FunctionImpl<bool(Directory::*)() const>(&Directory::isValidPtr));
						case 58: return FunctionPtr(new FunctionImpl<bool(Directory::*)() const>(&Directory::isOwnerPtr));
						case 59: return FunctionPtr(new FunctionImpl<bool(Directory::*)() const>(&Directory::isConstPtr));
						case 60: return FunctionPtr(new FunctionImpl<uint32_t(Directory::*)() const>(&Directory::getCountPtr));
						case 61: return FunctionPtr(new FunctionImpl<const void*(Directory::*)() const>(&Directory::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3327, 3327, 1648, 3139, 2556, 2581, 2336, 2332, 2335, 2331, 2333, 2337, 2338, 2575, 2306, 2304, 2305, 2307, 2302, 3075, 3075, 3623, 2332, 3625, 2335, 2331, 2333, 2337, 2337, 3427, 3427, 1893, 1893, 3064, 3064, 1603, 1603, 1917, 1917, 3425, 3425, 1892, 1892, 3441, 3441, 2246, 2120, 2411, 2817, 2228, 2309, 2314, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 4073, 1585, 1274, 4039, 1274, 495, 4044, 4044, 4044, 3961, 1692, 4039, 1274, 495, 4044, 4039, 1692, 1585, 1585, 1585, 495, 1585, 4044, 4044, 4044, 3961, 3961, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1274, 1274, 1274, 1274, 1274, 1274, 1692, 493, 4073, 4073, 494, 494, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 10, 10, 11, 12, 13, 14, 14, 15, 16, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 31, 34, 35, 36, 37, 38, 40, 42, 44, 46, 49, 52, 54, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1585, 1841, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1877, 1841, 1877, 495, 1877, 1877, 4044, 1877, 1877, 1877, 1877, 1841, 1877, 1841, 1877, 1877, 1585, 1841, 1841, 1585, 1877, 1841, 1877, 1841, 1877, 1585, 1841, 1585, 1877, 1585, 1841, 1585, 1877, 1877, 1585, 1841, 1841, 1585, 1877, 1877, 1841, 1841 };
			static constexpr uint16_t function_arg_names[] = { 3288, 1610, 3288, 1610, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 3288, 3288, 3288, 1565, 3288, 3288, 4017, 3288, 3288, 3288, 3288, 3288, 3288, 3288, 3288, 3289, 1565, 3288, 3289, 1565, 3288, 3288, 3288, 3288, 3288, 1610, 3288, 1610, 3288, 1610, 3288, 1610, 3288, 3289, 1565, 3288, 3289, 1565, 3288, 3289, 3288, 3289 };
			static constexpr uint16_t function_arg_values[] = { 0, 2016, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 2016, 0, 0, 0, 0, 0, 2016, 0, 2016, 0, 2016, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 81 };
			static constexpr uint16_t enum_bases[] = { 0, 7 };
			static constexpr uint16_t enum_var_names[] = { 72, 75, 80, 69, 68, 77, 1089 };
	};
	constexpr uint16_t ReflectionDirectory::constructor_bases[];
	constexpr uint16_t ReflectionDirectory::constructor_arg_types[];
	constexpr uint16_t ReflectionDirectory::constructor_arg_names[];
	constexpr uint16_t ReflectionDirectory::constructor_arg_values[];
	constexpr uint8_t ReflectionDirectory::function_flags[];
	constexpr uint16_t ReflectionDirectory::function_names[];
	constexpr uint16_t ReflectionDirectory::function_types[];
	constexpr uint16_t ReflectionDirectory::function_bases[];
	constexpr uint16_t ReflectionDirectory::function_arg_types[];
	constexpr uint16_t ReflectionDirectory::function_arg_names[];
	constexpr uint16_t ReflectionDirectory::function_arg_values[];
	constexpr uint16_t ReflectionDirectory::callback_names[];
	constexpr uint16_t ReflectionDirectory::callback_types[];
	constexpr uint16_t ReflectionDirectory::callback_bases[];
	constexpr uint16_t ReflectionDirectory::callback_arg_types[];
	constexpr uint16_t ReflectionDirectory::callback_arg_names[];
	constexpr uint16_t ReflectionDirectory::enum_names[];
	constexpr uint16_t ReflectionDirectory::enum_bases[];
	constexpr uint16_t ReflectionDirectory::enum_var_names[];
	static ReflectionDirectory reflection_directory;
	
	// Tellusim::Archive
	class ReflectionArchive : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Archive::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Archive, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Archive>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(Archive::*)(const char*, const char*)>(&Archive::open, {}, nullptr));
						case 1: return FunctionPtr(new FunctionImpl<bool(Archive::*)(const String&, const char*)>(&Archive::open, {}, nullptr));
						case 2: return FunctionPtr(new FunctionImpl<bool(Archive::*)(Stream&, const char*)>(&Archive::open, Stream::null, nullptr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Archive::*)()>(&Archive::close));
						case 4: return FunctionPtr(new FunctionImpl<bool(Archive::*)() const>(&Archive::isOpened));
						case 5: return FunctionPtr(new FunctionImpl<String(Archive::*)() const>(&Archive::getName));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(Archive::*)() const>(&Archive::getNumFiles));
						case 7: return FunctionPtr(new FunctionImpl<String(Archive::*)(uint32_t) const>(&Archive::getFileName));
						case 8: return FunctionPtr(new FunctionImpl<uint64_t(Archive::*)(uint32_t) const>(&Archive::getFileMTime));
						case 9: return FunctionPtr(new FunctionImpl<size_t(Archive::*)(uint32_t) const>(&Archive::getFileSize));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(Archive::*)(const char*) const>(&Archive::findFile));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Archive::*)(const String&) const>(&Archive::findFile));
						case 12: return FunctionPtr(new FunctionImpl<bool(Archive::*)(const char*) const>(&Archive::isFile));
						case 13: return FunctionPtr(new FunctionImpl<bool(Archive::*)(const String&) const>(&Archive::isFile));
						case 14: return FunctionPtr(new FunctionImpl<Stream(Archive::*)(const char*) const>(&Archive::openFile));
						case 15: return FunctionPtr(new FunctionImpl<Stream(Archive::*)(const String&) const>(&Archive::openFile));
						case 16: return FunctionPtr(new FunctionImpl<Stream(Archive::*)(uint32_t) const>(&Archive::openFile));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3327, 3327, 3327, 1648, 3139, 2556, 2581, 2336, 2335, 2337, 2031, 2031, 3075, 3075, 3328, 3328, 3328 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 1585, 4073, 1585, 1274, 4039, 1274, 4044, 3961, 4039, 4039, 1585, 1585, 1272, 1272, 1272 };
			static constexpr uint16_t function_bases[] = { 0, 2, 4, 6, 6, 6, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1877, 1841, 1877, 1273, 1877, 4039, 4039, 4039, 1877, 1841, 1877, 1841, 1877, 1841, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4036, 3288, 4036, 3990, 4036, 2993, 2993, 2993, 3288, 3288, 3288, 3288, 3288, 3288, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 3294, 0, 3294, 0, 3294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionArchive::constructor_bases[];
	constexpr uint16_t ReflectionArchive::constructor_arg_types[];
	constexpr uint16_t ReflectionArchive::constructor_arg_names[];
	constexpr uint16_t ReflectionArchive::constructor_arg_values[];
	constexpr uint8_t ReflectionArchive::function_flags[];
	constexpr uint16_t ReflectionArchive::function_names[];
	constexpr uint16_t ReflectionArchive::function_types[];
	constexpr uint16_t ReflectionArchive::function_bases[];
	constexpr uint16_t ReflectionArchive::function_arg_types[];
	constexpr uint16_t ReflectionArchive::function_arg_names[];
	constexpr uint16_t ReflectionArchive::function_arg_values[];
	constexpr uint16_t ReflectionArchive::callback_names[];
	constexpr uint16_t ReflectionArchive::callback_types[];
	constexpr uint16_t ReflectionArchive::callback_bases[];
	constexpr uint16_t ReflectionArchive::callback_arg_types[];
	constexpr uint16_t ReflectionArchive::callback_arg_names[];
	constexpr uint16_t ReflectionArchive::enum_names[];
	constexpr uint16_t ReflectionArchive::enum_bases[];
	constexpr uint16_t ReflectionArchive::enum_var_names[];
	static ReflectionArchive reflection_archive;
	
	// Tellusim::Image
	class ReflectionImage : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Image::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Image, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Image, TypeList<const char*, Image::Flags, uint32_t>>({}, Image::FlagNone, 0));
						case 2: return ConstructorPtr(new ConstructorImpl<Image, TypeList<Stream&, Image::Flags, uint32_t>>(Stream::null, Image::FlagNone, 0));
						case 3: return ConstructorPtr(new ConstructorImpl<Image, TypeList<Image::Type, Format, const Size&, Image::Flags>>((Image::Type)0, (Format)0, {}, Image::FlagNone));
						case 4: return ConstructorPtr(new ConstructorImpl<Image, TypeList<Image::Type, Format, const Size&, uint32_t, Image::Flags>>((Image::Type)0, (Format)0, {}, {}, Image::FlagNone));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Image>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Image::*)()>(&Image::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isLoaded));
						case 2: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isAllocated));
						case 3: return FunctionPtr(new FunctionImpl<Image::Type(Image::*)() const>(&Image::getType));
						case 4: return FunctionPtr(new FunctionImpl<const char*(Image::Type)>(&Image::getTypeName));
						case 5: return FunctionPtr(new FunctionImpl<const char*(Image::*)() const>(&Image::getTypeName));
						case 6: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::is2DType));
						case 7: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::is3DType));
						case 8: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isCubeType));
						case 9: return FunctionPtr(new FunctionImpl<Format(Image::*)() const>(&Image::getFormat));
						case 10: return FunctionPtr(new FunctionImpl<const char*(Image::*)() const>(&Image::getFormatName));
						case 11: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isColorFormat));
						case 12: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isDepthFormat));
						case 13: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isPixelFormat));
						case 14: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isPlainFormat));
						case 15: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isMixedFormat));
						case 16: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isBlockFormat));
						case 17: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isStencilFormat));
						case 18: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isNormFormat));
						case 19: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isSRGBFormat));
						case 20: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isFloatFormat));
						case 21: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isSignedFormat));
						case 22: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isUnsignedFormat));
						case 23: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isIntegerFormat));
						case 24: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isi8Format));
						case 25: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isu8Format));
						case 26: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::is8BitFormat));
						case 27: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isi16Format));
						case 28: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isu16Format));
						case 29: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isf16Format));
						case 30: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::is16BitFormat));
						case 31: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isi32Format));
						case 32: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isu32Format));
						case 33: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isf32Format));
						case 34: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::is32BitFormat));
						case 35: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isi64Format));
						case 36: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isu64Format));
						case 37: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isf64Format));
						case 38: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::is64BitFormat));
						case 39: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isBC15Format));
						case 40: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isBC67Format));
						case 41: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isETC2Format));
						case 42: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isASTCFormat));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getComponents));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getPixelSize));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getBlockSize));
						case 46: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getBlockWidth));
						case 47: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getBlockHeight));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getWidth));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getHeight));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getDepth));
						case 51: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getFaces));
						case 52: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getLayers));
						case 53: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getMipmaps));
						case 54: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)(const Size&) const>(&Image::findMipmap));
						case 55: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)(uint32_t) const>(&Image::getWidth));
						case 56: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)(uint32_t) const>(&Image::getHeight));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)(uint32_t) const>(&Image::getDepth));
						case 58: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::hasLayers));
						case 59: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::hasMipmaps));
						case 60: return FunctionPtr(new FunctionImpl<Size(Image::*)() const>(&Image::getSize));
						case 61: return FunctionPtr(new FunctionImpl<Region(Image::*)() const>(&Image::getRegion));
						case 62: return FunctionPtr(new FunctionImpl<Slice(Image::*)() const>(&Image::getSlice));
						case 63: return FunctionPtr(new FunctionImpl<Size(Image::*)(uint32_t) const>(&Image::getSize));
						case 64: return FunctionPtr(new FunctionImpl<Region(Image::*)(uint32_t) const>(&Image::getRegion));
						case 65: return FunctionPtr(new FunctionImpl<Slice(Image::*)(uint32_t) const>(&Image::getSlice));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(Image::*)(const String&)>(&Image::setMetaInfo));
						case 67: return FunctionPtr(new FunctionImpl<String(Image::*)() const>(&Image::getMetaInfo));
						case 68: return FunctionPtr(new FunctionImpl<String(Image::*)() const>(&Image::getDescription));
						case 69: return FunctionPtr(new FunctionImpl<size_t(Image::*)(const Slice&, uint32_t) const>(&Image::getOffset, {}, 1));
						case 70: return FunctionPtr(new FunctionImpl<size_t(Image::*)(uint32_t, uint32_t) const>(&Image::getStride, 0, 1));
						case 71: return FunctionPtr(new FunctionImpl<size_t(Image::*)(uint32_t, uint32_t) const>(&Image::getMipmapSize, {}, 1));
						case 72: return FunctionPtr(new FunctionImpl<size_t(Image::*)(uint32_t) const>(&Image::getLayerSize, 1));
						case 73: return FunctionPtr(new FunctionImpl<size_t(Image::*)(uint32_t) const>(&Image::getDataSize, 1));
						case 74: return FunctionPtr(new FunctionImpl<bool(Image::*)(Image::Type, Format, const Size&, Image::Flags)>(&Image::create, (Image::Type)0, (Format)0, {}, Image::FlagNone));
						case 75: return FunctionPtr(new FunctionImpl<bool(Image::*)(Image::Type, Format, const Size&, uint32_t, Image::Flags)>(&Image::create, (Image::Type)0, (Format)0, {}, {}, Image::FlagNone));
						case 76: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, Image::Flags)>(&Image::create2D, (Format)0, {}, Image::FlagNone));
						case 77: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, Image::Flags)>(&Image::create3D, (Format)0, {}, Image::FlagNone));
						case 78: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, Image::Flags)>(&Image::createCube, (Format)0, {}, Image::FlagNone));
						case 79: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, uint32_t, Image::Flags)>(&Image::create2D, (Format)0, {}, {}, Image::FlagNone));
						case 80: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, uint32_t, uint32_t, Image::Flags)>(&Image::create3D, (Format)0, {}, {}, {}, Image::FlagNone));
						case 81: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, uint32_t, uint32_t, Image::Flags)>(&Image::create2D, (Format)0, {}, {}, {}, Image::FlagNone));
						case 82: return FunctionPtr(new FunctionImpl<bool(Image::*)(Format, uint32_t, uint32_t, Image::Flags)>(&Image::createCube, (Format)0, {}, {}, Image::FlagNone));
						case 83: return FunctionPtr(new FunctionImpl<bool(Image::*)(const char*, Image::Flags, uint32_t, Async*)>(&Image::info, {}, Image::FlagNone, 0, nullptr));
						case 84: return FunctionPtr(new FunctionImpl<bool(Image::*)(const String&, Image::Flags, uint32_t, Async*)>(&Image::info, {}, Image::FlagNone, 0, nullptr));
						case 85: return FunctionPtr(new FunctionImpl<bool(Image::*)(Stream&, Image::Flags, uint32_t, Async*)>(&Image::info, Stream::null, Image::FlagNone, 0, nullptr));
						case 86: return FunctionPtr(new FunctionImpl<bool(Image::*)(const char*, Async*)>(&Image::info));
						case 87: return FunctionPtr(new FunctionImpl<bool(Image::*)(const String&, Async*)>(&Image::info));
						case 88: return FunctionPtr(new FunctionImpl<bool(Image::*)(Stream&, Async*)>(&Image::info));
						case 89: return FunctionPtr(new FunctionImpl<bool(Image::*)(const char*, Image::Flags, uint32_t, Async*)>(&Image::load, {}, Image::FlagNone, 0, nullptr));
						case 90: return FunctionPtr(new FunctionImpl<bool(Image::*)(const String&, Image::Flags, uint32_t, Async*)>(&Image::load, {}, Image::FlagNone, 0, nullptr));
						case 91: return FunctionPtr(new FunctionImpl<bool(Image::*)(Stream&, Image::Flags, uint32_t, Async*)>(&Image::load, Stream::null, Image::FlagNone, 0, nullptr));
						case 92: return FunctionPtr(new FunctionImpl<bool(Image::*)(const char*, Async*)>(&Image::load));
						case 93: return FunctionPtr(new FunctionImpl<bool(Image::*)(const String&, Async*)>(&Image::load));
						case 94: return FunctionPtr(new FunctionImpl<bool(Image::*)(Stream&, Async*)>(&Image::load));
						case 95: return FunctionPtr(new FunctionImpl<bool(Image::*)(const char*, Image::Flags, uint32_t) const>(&Image::save, {}, Image::FlagNone, 95));
						case 96: return FunctionPtr(new FunctionImpl<bool(Image::*)(const String&, Image::Flags, uint32_t) const>(&Image::save, {}, Image::FlagNone, 95));
						case 97: return FunctionPtr(new FunctionImpl<bool(Image::*)(Stream&, Image::Flags, uint32_t) const>(&Image::save, Stream::null, Image::FlagNone, 95));
						case 98: return FunctionPtr(new FunctionImpl<bool(Image::*)(uint32_t, uint32_t)>(&Image::swap));
						case 99: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, uint32_t, uint32_t)>(&Image::copy));
						case 100: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Region&, const Slice&)>(&Image::flipX));
						case 101: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Region&)>(&Image::flipX));
						case 102: return FunctionPtr(new FunctionImpl<bool(Image::*)()>(&Image::flipX));
						case 103: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Region&, const Slice&)>(&Image::flipY));
						case 104: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Region&)>(&Image::flipY));
						case 105: return FunctionPtr(new FunctionImpl<bool(Image::*)()>(&Image::flipY));
						case 106: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, const Origin&, const Region&, const Slice&, const Slice&)>(&Image::copy));
						case 107: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, const Origin&, const Region&)>(&Image::copy));
						case 108: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, const Origin&, const Slice&)>(&Image::copy));
						case 109: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, const Slice&, const Slice&)>(&Image::copy));
						case 110: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, const Origin&)>(&Image::copy));
						case 111: return FunctionPtr(new FunctionImpl<bool(Image::*)(const Image&, const Slice&)>(&Image::copy));
						case 112: return FunctionPtr(new FunctionImpl<Image(Image::*)(Image::Type, Image::Flags, Async*) const>(&Image::toType, (Image::Type)0, (Image::Flags)0, nullptr));
						case 113: return FunctionPtr(new FunctionImpl<Image(Image::*)(Image::Type, Async*) const>(&Image::toType, (Image::Type)0, nullptr));
						case 114: return FunctionPtr(new FunctionImpl<Image(Image::*)(Format, Image::Flags, Async*) const>(&Image::toFormat, (Format)0, (Image::Flags)0, nullptr));
						case 115: return FunctionPtr(new FunctionImpl<Image(Image::*)(Format, Async*) const>(&Image::toFormat, (Format)0, nullptr));
						case 116: return FunctionPtr(new FunctionImpl<Image(Image::*)(const Slice&) const>(&Image::getSlice));
						case 117: return FunctionPtr(new FunctionImpl<Image(Image::*)(uint32_t) const>(&Image::getComponent));
						case 118: return FunctionPtr(new FunctionImpl<Image(Image::*)(const Region&, const Slice&) const>(&Image::getRegion));
						case 119: return FunctionPtr(new FunctionImpl<Image(Image::*)(const Region&) const>(&Image::getRegion));
						case 120: return FunctionPtr(new FunctionImpl<Image(Image::*)(int32_t, const Slice&) const>(&Image::getRotated));
						case 121: return FunctionPtr(new FunctionImpl<Image(Image::*)(int32_t) const>(&Image::getRotated));
						case 122: return FunctionPtr(new FunctionImpl<Image(Image::*)(const Size&, Image::Filter, Image::Filter, Image::Flags, Async*) const>(&Image::getResized, {}, (Image::Filter)0, (Image::Filter)0, (Image::Flags)0, nullptr));
						case 123: return FunctionPtr(new FunctionImpl<Image(Image::*)(const Size&, Image::Filter, Image::Filter, Async*) const>(&Image::getResized, {}, (Image::Filter)0, Image::FilterCubic, nullptr));
						case 124: return FunctionPtr(new FunctionImpl<Image(Image::*)(const Size&, Async*) const>(&Image::getResized, {}, nullptr));
						case 125: return FunctionPtr(new FunctionImpl<Image(Image::*)(Image::Filter, Image::Flags, Async*) const>(&Image::getMipmapped, (Image::Filter)0, (Image::Flags)0, nullptr));
						case 126: return FunctionPtr(new FunctionImpl<Image(Image::*)(Image::Filter, Async*) const>(&Image::getMipmapped, (Image::Filter)0, nullptr));
						case 127: return FunctionPtr(new FunctionImpl<Image(Image::*)(Async*) const>(&Image::getMipmapped, nullptr));
						case 128: return FunctionPtr(new FunctionImpl<int32_t(Image::*)(const Image&) const>(&Image::compare));
						case 129: return FunctionPtr(new FunctionImpl<const uint8_t*(Image::*)(const Slice&) const>(&Image::getData, Slice()));
						case 130: return FunctionPtr(new FunctionImpl<uint8_t*(Image::*)(const Slice&)>(&Image::getData, Slice()));
						case 131: return FunctionPtr(new FunctionImpl<const uint8_t*(Image::*)(const Origin&, const Slice&) const>(&Image::getData, {}, Slice()));
						case 132: return FunctionPtr(new FunctionImpl<uint8_t*(Image::*)(const Origin&, const Slice&)>(&Image::getData, {}, Slice()));
						case 133: return FunctionPtr(new FunctionImpl<bool(Image::*)(const void*, const Slice&, uint32_t, size_t)>(&Image::setData, {}, Slice(), 1, 0));
						case 134: return FunctionPtr(new FunctionImpl<bool(Image::*)(void*, const Slice&, uint32_t, size_t) const>(&Image::getData, {}, Slice(), 1, 0));
						case 135: return FunctionPtr(new FunctionImpl<size_t(Image::*)() const>(&Image::getMemory));
						case 136: return FunctionPtr(new FunctionImpl<Image(Image::*)() const>(&Image::clonePtr));
						case 137: return FunctionPtr(new FunctionVoidImpl<void(Image::*)()>(&Image::clearPtr));
						case 138: return FunctionPtr(new FunctionVoidImpl<void(Image::*)()>(&Image::destroyPtr));
						case 139: return FunctionPtr(new FunctionImpl<Image&(Image::*)()>(&Image::acquirePtr));
						case 140: return FunctionPtr(new FunctionImpl<Image&(Image::*)()>(&Image::unacquirePtr));
						case 141: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isValidPtr));
						case 142: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isOwnerPtr));
						case 143: return FunctionPtr(new FunctionImpl<bool(Image::*)() const>(&Image::isConstPtr));
						case 144: return FunctionPtr(new FunctionImpl<uint32_t(Image::*)() const>(&Image::getCountPtr));
						case 145: return FunctionPtr(new FunctionImpl<const void*(Image::*)() const>(&Image::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 3, 6, 10, 15 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 843, 4039, 1273, 843, 4039, 844, 765, 1838, 843, 844, 765, 1838, 4039, 843 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 2045, 3317, 3990, 2045, 3317, 4036, 2066, 3960, 2045, 4036, 2066, 3960, 3237, 2045 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 678, 3, 0, 678, 3, 0, 0, 0, 678, 0, 0, 0, 0, 678 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3116, 3018, 2878, 2879, 2879, 3010, 3012, 3058, 2355, 2357, 3049, 3061, 3147, 3148, 3123, 3031, 3180, 3132, 3163, 3078, 3172, 3199, 3102, 3219, 3223, 3014, 3216, 3220, 3213, 3009, 3217, 3221, 3214, 3011, 3218, 3222, 3215, 3013, 3025, 3026, 3066, 3015, 2223, 2667, 2133, 2134, 2132, 2927, 2410, 2272, 2325, 2468, 2523, 2038, 2927, 2410, 2272, 2956, 2958, 2760, 2702, 2762, 2760, 2702, 2762, 3716, 2510, 2296, 2628, 2795, 2521, 2467, 2263, 1902, 1902, 1903, 1904, 1914, 1903, 1904, 1903, 1914, 2996, 2996, 2996, 2996, 2996, 2996, 3242, 3242, 3242, 3242, 3242, 3242, 3480, 3480, 3480, 3994, 1890, 2047, 2047, 2047, 2048, 2048, 2048, 1890, 1890, 1890, 1890, 1890, 1890, 4023, 4023, 4022, 4022, 2762, 2222, 2702, 2702, 2719, 2719, 2711, 2711, 2711, 2522, 2522, 2522, 1657, 2260, 2260, 2260, 2260, 3590, 2260, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 844, 1877, 1877, 1585, 1585, 1585, 765, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1585, 1585, 1215, 1182, 1218, 1215, 1182, 1218, 4073, 1274, 1274, 3961, 3961, 3961, 3961, 3961, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 3003, 1884, 4046, 1884, 4046, 1585, 1585, 3961, 838, 4073, 4073, 839, 839, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 9, 9, 11, 13, 15, 16, 17, 21, 26, 29, 32, 35, 39, 44, 49, 53, 57, 61, 65, 67, 69, 71, 75, 79, 83, 85, 87, 89, 92, 95, 98, 100, 103, 105, 106, 106, 108, 109, 109, 114, 117, 120, 123, 125, 127, 130, 132, 135, 137, 138, 139, 141, 142, 144, 145, 150, 154, 156, 159, 161, 162, 163, 164, 165, 167, 169, 173, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177 };
			static constexpr uint16_t function_arg_types[] = { 844, 1838, 4039, 4039, 4039, 4039, 4039, 4039, 1841, 1839, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 844, 765, 1838, 843, 844, 765, 1838, 4039, 843, 765, 4039, 843, 765, 4039, 843, 765, 4039, 843, 765, 4039, 4039, 843, 765, 4039, 4039, 4039, 843, 765, 4039, 4039, 4039, 843, 765, 4039, 4039, 843, 1877, 843, 4039, 62, 1841, 843, 4039, 62, 1273, 843, 4039, 62, 1877, 62, 1841, 62, 1273, 62, 1877, 843, 4039, 62, 1841, 843, 4039, 62, 1273, 843, 4039, 62, 1877, 62, 1841, 62, 1273, 62, 1877, 843, 4039, 1841, 843, 4039, 1273, 843, 4039, 4039, 4039, 1781, 4039, 4039, 1831, 1839, 1831, 1831, 1839, 1831, 1781, 1824, 1831, 1839, 1839, 1781, 1824, 1831, 1781, 1824, 1839, 1781, 1839, 1839, 1781, 1824, 1781, 1839, 844, 843, 62, 844, 62, 765, 843, 62, 765, 62, 1839, 4039, 1831, 1839, 1831, 3003, 1839, 3003, 1838, 840, 840, 843, 62, 1838, 840, 840, 62, 1838, 62, 840, 843, 62, 840, 62, 62, 1781, 1839, 1839, 1824, 1839, 1824, 1839, 1885, 1839, 4039, 3961, 4074, 1839, 4039, 3961 };
			static constexpr uint16_t function_arg_names[] = { 4036, 3960, 3274, 3274, 3274, 3274, 3274, 3274, 3989, 3967, 1547, 3274, 1547, 3274, 1547, 1547, 1547, 4036, 2066, 3960, 2045, 4036, 2066, 3960, 3237, 2045, 2066, 3960, 2045, 2066, 3960, 2045, 2066, 3960, 2045, 2066, 4089, 2980, 2045, 2066, 4089, 2980, 1959, 2045, 2066, 4089, 2980, 3237, 2045, 2066, 3960, 3237, 2045, 3288, 2045, 3317, 1559, 3288, 2045, 3317, 1559, 3990, 2045, 3317, 1559, 3288, 1559, 3288, 1559, 3990, 1559, 3288, 2045, 3317, 1559, 3288, 2045, 3317, 1559, 3990, 2045, 3317, 1559, 3288, 1559, 3288, 1559, 3990, 1559, 3288, 2045, 3368, 3288, 2045, 3368, 3990, 2045, 3368, 1659, 1660, 3975, 1964, 3979, 3403, 3967, 3403, 3403, 3967, 3403, 3975, 1966, 3981, 1967, 3982, 3975, 1966, 3981, 3975, 1966, 1967, 3975, 1967, 3982, 3975, 1966, 3975, 1967, 4036, 2045, 1559, 4036, 1559, 2066, 2045, 1559, 2066, 1559, 3967, 1658, 3403, 3967, 3403, 1549, 3967, 1549, 3960, 3271, 3257, 2045, 1559, 3960, 3271, 3257, 1559, 3960, 1559, 2022, 2045, 1559, 2022, 1559, 1559, 2989, 3967, 3967, 3340, 3967, 3340, 3967, 3975, 3967, 1547, 3991, 1963, 3967, 1547, 3991 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 3, 6, 0, 6, 6, 6, 0, 0, 0, 678, 0, 0, 0, 0, 678, 0, 0, 678, 0, 0, 678, 0, 0, 678, 0, 0, 0, 678, 0, 0, 0, 0, 678, 0, 0, 0, 0, 678, 0, 0, 0, 678, 0, 678, 3, 3294, 0, 678, 3, 3294, 0, 678, 3, 3294, 0, 0, 0, 0, 0, 0, 0, 678, 3, 3294, 0, 678, 3, 3294, 0, 678, 3, 3294, 0, 0, 0, 0, 0, 0, 0, 678, 22, 0, 678, 22, 0, 678, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 3294, 0, 0, 3294, 0, 3294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 568, 3294, 0, 3294, 0, 0, 3294, 0, 3294, 3294, 0, 1219, 1219, 0, 1219, 0, 1219, 0, 1219, 6, 3, 0, 1219, 6, 3 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311, 753, 563 };
			static constexpr uint16_t enum_bases[] = { 0, 5, 17, 28 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1312, 1313, 1332, 1117, 678, 664, 677, 676, 624, 593, 687, 686, 679, 637, 707, 1102, 576, 573, 569, 568, 574, 566, 570, 571, 572, 567, 1101 };
	};
	constexpr uint16_t ReflectionImage::constructor_bases[];
	constexpr uint16_t ReflectionImage::constructor_arg_types[];
	constexpr uint16_t ReflectionImage::constructor_arg_names[];
	constexpr uint16_t ReflectionImage::constructor_arg_values[];
	constexpr uint8_t ReflectionImage::function_flags[];
	constexpr uint16_t ReflectionImage::function_names[];
	constexpr uint16_t ReflectionImage::function_types[];
	constexpr uint16_t ReflectionImage::function_bases[];
	constexpr uint16_t ReflectionImage::function_arg_types[];
	constexpr uint16_t ReflectionImage::function_arg_names[];
	constexpr uint16_t ReflectionImage::function_arg_values[];
	constexpr uint16_t ReflectionImage::callback_names[];
	constexpr uint16_t ReflectionImage::callback_types[];
	constexpr uint16_t ReflectionImage::callback_bases[];
	constexpr uint16_t ReflectionImage::callback_arg_types[];
	constexpr uint16_t ReflectionImage::callback_arg_names[];
	constexpr uint16_t ReflectionImage::enum_names[];
	constexpr uint16_t ReflectionImage::enum_bases[];
	constexpr uint16_t ReflectionImage::enum_var_names[];
	static ReflectionImage reflection_image;
	
	// Tellusim::ImageSampler
	class ReflectionImageSampler : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ImageSampler::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ImageSampler, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ImageSampler, TypeList<Image&, const Slice&>>(Image::null, Slice()));
						case 2: return ConstructorPtr(new ConstructorImpl<ImageSampler, TypeList<const Image&, const Slice&>>(Image::null, Slice()));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ImageSampler>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ImageSampler::*)()>(&ImageSampler::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)() const>(&ImageSampler::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<Image::Type(ImageSampler::*)() const>(&ImageSampler::getType));
						case 3: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)() const>(&ImageSampler::is2DType));
						case 4: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)() const>(&ImageSampler::is3DType));
						case 5: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)() const>(&ImageSampler::isCubeType));
						case 6: return FunctionPtr(new FunctionImpl<Format(ImageSampler::*)() const>(&ImageSampler::getFormat));
						case 7: return FunctionPtr(new FunctionImpl<const char*(ImageSampler::*)() const>(&ImageSampler::getFormatName));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)() const>(&ImageSampler::getWidth));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)() const>(&ImageSampler::getHeight));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)() const>(&ImageSampler::getDepth));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)() const>(&ImageSampler::getFaces));
						case 12: return FunctionPtr(new FunctionImpl<size_t(ImageSampler::*)() const>(&ImageSampler::getTexels));
						case 13: return FunctionPtr(new FunctionImpl<Size(ImageSampler::*)() const>(&ImageSampler::getSize));
						case 14: return FunctionPtr(new FunctionImpl<Region(ImageSampler::*)() const>(&ImageSampler::getRegion));
						case 15: return FunctionPtr(new FunctionImpl<size_t(ImageSampler::*)() const>(&ImageSampler::getStride));
						case 16: return FunctionPtr(new FunctionImpl<size_t(ImageSampler::*)() const>(&ImageSampler::getLayerSize));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)() const>(&ImageSampler::getPixelSize));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)() const>(&ImageSampler::getComponents));
						case 19: return FunctionPtr(new FunctionImpl<const uint8_t*(ImageSampler::*)() const>(&ImageSampler::getData));
						case 20: return FunctionPtr(new FunctionImpl<uint8_t*(ImageSampler::*)()>(&ImageSampler::getData));
						case 21: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(Image&, const Slice&)>(&ImageSampler::create, Image::null, Slice()));
						case 22: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(const Image&, const Slice&)>(&ImageSampler::create, Image::null, Slice()));
						case 23: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(Image::Type, Format, const Size&, size_t, void*)>(&ImageSampler::create));
						case 24: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(Image::Type, Format, const Size&, size_t, const void*)>(&ImageSampler::create));
						case 25: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(Image::Type, Format, const Size&, size_t, size_t, void*)>(&ImageSampler::create));
						case 26: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(Image::Type, Format, const Size&, size_t, size_t, const void*)>(&ImageSampler::create));
						case 27: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(const Color&)>(&ImageSampler::clear));
						case 28: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(const ImageColor&)>(&ImageSampler::clear));
						case 29: return FunctionPtr(new FunctionImpl<bool(ImageSampler::*)(const Color&, const Color&)>(&ImageSampler::mad));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(ImageSampler::*)(uint32_t, uint32_t, const ImageColor&)>(&ImageSampler::set2D));
						case 31: return FunctionPtr(new FunctionImpl<ImageColor(ImageSampler::*)(uint32_t, uint32_t, bool) const>(&ImageSampler::get2D, {}, {}, false));
						case 32: return FunctionPtr(new FunctionImpl<ImageColor(ImageSampler::*)(float64_t, float64_t, bool, Image::Filter) const>(&ImageSampler::get2D, {}, {}, false, Image::FilterLinear));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(ImageSampler::*)(uint32_t, uint32_t, uint32_t, const ImageColor&)>(&ImageSampler::set3D));
						case 34: return FunctionPtr(new FunctionImpl<ImageColor(ImageSampler::*)(uint32_t, uint32_t, uint32_t, bool) const>(&ImageSampler::get3D, {}, {}, {}, false));
						case 35: return FunctionPtr(new FunctionImpl<ImageColor(ImageSampler::*)(float32_t, float32_t, float32_t, bool, Image::Filter) const>(&ImageSampler::get3D, {}, {}, {}, false, Image::FilterLinear));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(ImageSampler::*)(float32_t, float32_t, float32_t, const ImageColor&)>(&ImageSampler::setCube));
						case 37: return FunctionPtr(new FunctionImpl<ImageColor(ImageSampler::*)(float32_t, float32_t, float32_t, Image::Filter) const>(&ImageSampler::getCube, {}, {}, {}, Image::FilterLinear));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(ImageSampler::*)(float32_t, float32_t, float32_t, float32_t&, float32_t&) const>(&ImageSampler::getCubeFace));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(ImageSampler::*)(size_t, const ImageColor&)>(&ImageSampler::setTexel));
						case 40: return FunctionPtr(new FunctionImpl<ImageColor(ImageSampler::*)(size_t) const>(&ImageSampler::getTexel));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 4 };
			static constexpr uint16_t constructor_arg_types[] = { 839, 1839, 1781, 1839 };
			static constexpr uint16_t constructor_arg_names[] = { 2989, 3967, 2989, 3967 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 1219, 0, 1219 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2878, 3010, 3012, 3058, 2355, 2357, 2927, 2410, 2272, 2325, 2824, 2760, 2702, 2795, 2467, 2667, 2223, 2260, 2260, 1902, 1902, 1902, 1902, 1902, 1902, 1612, 1612, 3256, 3502, 2079, 2079, 3503, 2080, 2080, 3583, 2242, 2243, 3874, 2819 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 844, 1585, 1585, 1585, 765, 1877, 4039, 4039, 4039, 4039, 3961, 1215, 1182, 3961, 3961, 4039, 4039, 1884, 4046, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 845, 845, 4073, 845, 845, 4073, 845, 4039, 4073, 845 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 9, 14, 20, 26, 27, 28, 30, 33, 36, 40, 44, 48, 53, 57, 61, 66, 68, 69 };
			static constexpr uint16_t function_arg_types[] = { 839, 1839, 1781, 1839, 844, 765, 1838, 3961, 4074, 844, 765, 1838, 3961, 1885, 844, 765, 1838, 3961, 3961, 4074, 844, 765, 1838, 3961, 3961, 1885, 1721, 1782, 1721, 1721, 4039, 4039, 1782, 4039, 4039, 1585, 2054, 2054, 1585, 840, 4039, 4039, 4039, 1782, 4039, 4039, 4039, 1585, 2051, 2051, 2051, 1585, 840, 2051, 2051, 2051, 1782, 2051, 2051, 2051, 840, 2051, 2051, 2051, 2052, 2052, 3961, 1782, 3961 };
			static constexpr uint16_t function_arg_names[] = { 2989, 3967, 2989, 3967, 4036, 2066, 3960, 3991, 1948, 4036, 2066, 3960, 3991, 1948, 4036, 2066, 3960, 3991, 3236, 1948, 4036, 2066, 3960, 3991, 3236, 1948, 1650, 1650, 3254, 1500, 4115, 4116, 1650, 4115, 4116, 3446, 4115, 4116, 3446, 2022, 4115, 4116, 4118, 1650, 4115, 4116, 4118, 3446, 4115, 4116, 4118, 3446, 2022, 4115, 4116, 4118, 1650, 4115, 4116, 4118, 2022, 4115, 4116, 4118, 4034, 4035, 4000, 1650, 4000 };
			static constexpr uint16_t function_arg_values[] = { 0, 1219, 0, 1219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 2016, 841, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 2016, 841, 0, 0, 0, 0, 0, 0, 0, 841, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionImageSampler::constructor_bases[];
	constexpr uint16_t ReflectionImageSampler::constructor_arg_types[];
	constexpr uint16_t ReflectionImageSampler::constructor_arg_names[];
	constexpr uint16_t ReflectionImageSampler::constructor_arg_values[];
	constexpr uint8_t ReflectionImageSampler::function_flags[];
	constexpr uint16_t ReflectionImageSampler::function_names[];
	constexpr uint16_t ReflectionImageSampler::function_types[];
	constexpr uint16_t ReflectionImageSampler::function_bases[];
	constexpr uint16_t ReflectionImageSampler::function_arg_types[];
	constexpr uint16_t ReflectionImageSampler::function_arg_names[];
	constexpr uint16_t ReflectionImageSampler::function_arg_values[];
	constexpr uint16_t ReflectionImageSampler::callback_names[];
	constexpr uint16_t ReflectionImageSampler::callback_types[];
	constexpr uint16_t ReflectionImageSampler::callback_bases[];
	constexpr uint16_t ReflectionImageSampler::callback_arg_types[];
	constexpr uint16_t ReflectionImageSampler::callback_arg_names[];
	constexpr uint16_t ReflectionImageSampler::enum_names[];
	constexpr uint16_t ReflectionImageSampler::enum_bases[];
	constexpr uint16_t ReflectionImageSampler::enum_var_names[];
	static ReflectionImageSampler reflection_image_sampler;
	
	// Tellusim::MeshNode
	class ReflectionMeshNode : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshNode::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshNode, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshNode, TypeList<Mesh&, const char*>>(Mesh::null, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<MeshNode, TypeList<MeshNode*, const char*>>({}, nullptr));
						case 3: return ConstructorPtr(new ConstructorImpl<MeshNode, TypeList<Mesh&, MeshNode*, const char*>>(Mesh::null, {}, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshNode>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)()>(&MeshNode::clear));
						case 1: return FunctionPtr(new FunctionImpl<MeshNode(MeshNode::*)(Mesh&) const>(&MeshNode::clone));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const char*)>(&MeshNode::setName));
						case 3: return FunctionPtr(new FunctionImpl<String(MeshNode::*)() const>(&MeshNode::getName));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)() const>(&MeshNode::getIndex));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(Mesh&, bool)>(&MeshNode::setMesh, Mesh::null, true));
						case 6: return FunctionPtr(new FunctionImpl<const Mesh(MeshNode::*)() const>(&MeshNode::getMesh));
						case 7: return FunctionPtr(new FunctionImpl<Mesh(MeshNode::*)()>(&MeshNode::getMesh));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(MeshNode&, bool)>(&MeshNode::setParent, MeshNode::null, true));
						case 9: return FunctionPtr(new FunctionImpl<const MeshNode(MeshNode::*)() const>(&MeshNode::getParent));
						case 10: return FunctionPtr(new FunctionImpl<MeshNode(MeshNode::*)()>(&MeshNode::getParent));
						case 11: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)() const>(&MeshNode::isRoot));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(uint32_t)>(&MeshNode::reserveChildren));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(MeshNode&, bool)>(&MeshNode::addChild, MeshNode::null, true));
						case 14: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)(MeshNode&)>(&MeshNode::removeChild));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)()>(&MeshNode::releaseChildren));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(const MeshNode&) const>(&MeshNode::findChild));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(const char*) const>(&MeshNode::findChild));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)() const>(&MeshNode::getNumChildren));
						case 19: return FunctionPtr(new FunctionImpl<const Array<MeshNode>(MeshNode::*)() const>(&MeshNode::getChildren));
						case 20: return FunctionPtr(new FunctionImpl<Array<MeshNode>(MeshNode::*)()>(&MeshNode::getChildren));
						case 21: return FunctionPtr(new FunctionImpl<const MeshNode(MeshNode::*)(uint32_t) const>(&MeshNode::getChild));
						case 22: return FunctionPtr(new FunctionImpl<const MeshNode(MeshNode::*)(const char*) const>(&MeshNode::getChild));
						case 23: return FunctionPtr(new FunctionImpl<MeshNode(MeshNode::*)(uint32_t)>(&MeshNode::getChild));
						case 24: return FunctionPtr(new FunctionImpl<MeshNode(MeshNode::*)(const char*)>(&MeshNode::getChild));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)()>(&MeshNode::clearGeometries));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(uint32_t)>(&MeshNode::reserveGeometries));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(MeshGeometry&, bool)>(&MeshNode::addGeometry, MeshGeometry::null, true));
						case 28: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)(MeshGeometry&)>(&MeshNode::removeGeometry));
						case 29: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)(MeshGeometry&, MeshGeometry&)>(&MeshNode::replaceGeometry));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(const MeshGeometry&) const>(&MeshNode::findGeometry));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)() const>(&MeshNode::getNumGeometries));
						case 32: return FunctionPtr(new FunctionImpl<const Array<MeshGeometry>(MeshNode::*)() const>(&MeshNode::getGeometries));
						case 33: return FunctionPtr(new FunctionImpl<Array<MeshGeometry>(MeshNode::*)()>(&MeshNode::getGeometries));
						case 34: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshNode::*)(uint32_t) const>(&MeshNode::getGeometry));
						case 35: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshNode::*)(uint32_t)>(&MeshNode::getGeometry));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)()>(&MeshNode::clearAttachments));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(uint32_t)>(&MeshNode::reserveAttachments));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(MeshAttachment&, bool)>(&MeshNode::addAttachment, MeshAttachment::null, true));
						case 39: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)(MeshAttachment&)>(&MeshNode::removeAttachment));
						case 40: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)(MeshAttachment&, MeshAttachment&)>(&MeshNode::replaceAttachment));
						case 41: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(const MeshAttachment&) const>(&MeshNode::findAttachment));
						case 42: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)(const char*) const>(&MeshNode::findAttachment));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)() const>(&MeshNode::getNumAttachments));
						case 44: return FunctionPtr(new FunctionImpl<const Array<MeshAttachment>(MeshNode::*)() const>(&MeshNode::getAttachments));
						case 45: return FunctionPtr(new FunctionImpl<Array<MeshAttachment>(MeshNode::*)()>(&MeshNode::getAttachments));
						case 46: return FunctionPtr(new FunctionImpl<const MeshAttachment(MeshNode::*)(uint32_t) const>(&MeshNode::getAttachment));
						case 47: return FunctionPtr(new FunctionImpl<MeshAttachment(MeshNode::*)(uint32_t)>(&MeshNode::getAttachment));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Matrix4x3d&)>(&MeshNode::setLocalTransform));
						case 49: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshNode::*)() const>(&MeshNode::getLocalTransform));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Matrix4x3d&)>(&MeshNode::setGlobalTransform));
						case 51: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshNode::*)() const>(&MeshNode::getGlobalTransform));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Matrix4x3d&)>(&MeshNode::setPivotTransform));
						case 53: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshNode::*)() const>(&MeshNode::getPivotTransform));
						case 54: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Vector4f&)>(&MeshNode::setMorphTransform));
						case 55: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshNode::*)() const>(&MeshNode::getMorphTransform));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Matrix4x3d&)>(&MeshNode::createLocalTransforms, Matrix4x3d::identity));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Matrix4x3d&)>(&MeshNode::createGlobalTransforms, Matrix4x3d::identity));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)(const Vector3d&)>(&MeshNode::setTransform));
						case 59: return FunctionPtr(new FunctionImpl<size_t(MeshNode::*)() const>(&MeshNode::getMemory));
						case 60: return FunctionPtr(new FunctionImpl<MeshNode(MeshNode::*)() const>(&MeshNode::clonePtr));
						case 61: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)()>(&MeshNode::clearPtr));
						case 62: return FunctionPtr(new FunctionVoidImpl<void(MeshNode::*)()>(&MeshNode::destroyPtr));
						case 63: return FunctionPtr(new FunctionImpl<MeshNode&(MeshNode::*)()>(&MeshNode::acquirePtr));
						case 64: return FunctionPtr(new FunctionImpl<MeshNode&(MeshNode::*)()>(&MeshNode::unacquirePtr));
						case 65: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)() const>(&MeshNode::isValidPtr));
						case 66: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)() const>(&MeshNode::isOwnerPtr));
						case 67: return FunctionPtr(new FunctionImpl<bool(MeshNode::*)() const>(&MeshNode::isConstPtr));
						case 68: return FunctionPtr(new FunctionImpl<uint32_t(MeshNode::*)() const>(&MeshNode::getCountPtr));
						case 69: return FunctionPtr(new FunctionImpl<const void*(MeshNode::*)() const>(&MeshNode::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 3, 5, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 986, 1877, 1020, 1877, 986, 1020, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 3269, 3288, 3348, 3288, 3269, 3348, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 3294, 0, 3294, 0, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 1646, 3751, 2556, 2421, 3710, 2502, 2502, 3770, 2651, 2651, 3161, 3458, 1513, 3424, 3409, 2028, 2028, 2567, 2191, 2191, 2190, 2190, 2190, 2190, 1622, 3459, 1519, 3429, 3451, 2032, 2582, 2389, 2389, 2390, 2390, 1614, 3456, 1510, 3421, 3448, 2024, 2024, 2563, 2097, 2097, 2096, 2096, 3699, 2470, 3651, 2396, 3780, 2665, 3728, 2534, 1923, 1920, 3911, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1018, 4073, 1274, 4039, 4073, 1800, 985, 4039, 1817, 1018, 1585, 4073, 4039, 1585, 4073, 4039, 4039, 4039, 1686, 56, 1817, 1817, 1018, 1018, 4073, 4073, 4039, 1585, 1585, 4039, 4039, 1681, 52, 1808, 1004, 4073, 4073, 4039, 1585, 1585, 4039, 4039, 4039, 1679, 50, 1804, 992, 4073, 1797, 4073, 1797, 4073, 1797, 4073, 1858, 4073, 4073, 4073, 3961, 1018, 4073, 4073, 1019, 1019, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 2, 2, 4, 4, 4, 6, 6, 6, 6, 7, 9, 10, 10, 11, 12, 12, 12, 12, 13, 14, 15, 16, 16, 17, 19, 20, 22, 23, 23, 23, 23, 24, 25, 25, 26, 28, 29, 31, 32, 33, 33, 33, 33, 34, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42 };
			static constexpr uint16_t function_arg_types[] = { 986, 1877, 986, 1585, 1019, 1585, 4039, 1019, 1585, 1019, 1818, 1877, 4039, 1877, 4039, 1877, 4039, 1005, 1585, 1005, 1005, 1005, 1809, 4039, 4039, 4039, 993, 1585, 993, 993, 993, 1805, 1877, 4039, 4039, 1797, 1797, 1797, 1858, 1797, 1797, 1855 };
			static constexpr uint16_t function_arg_names[] = { 3269, 3288, 3269, 1607, 3348, 1607, 3301, 1609, 1607, 1609, 1609, 3288, 2993, 3288, 2993, 3288, 3304, 2077, 1607, 2077, 3322, 2077, 2077, 2993, 2993, 3297, 1561, 1607, 1561, 3320, 1561, 1561, 3288, 2993, 2993, 4028, 4028, 4028, 4028, 3226, 4028, 3484 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 4033, 0, 4033, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 978, 978, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMeshNode::constructor_bases[];
	constexpr uint16_t ReflectionMeshNode::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshNode::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshNode::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshNode::function_flags[];
	constexpr uint16_t ReflectionMeshNode::function_names[];
	constexpr uint16_t ReflectionMeshNode::function_types[];
	constexpr uint16_t ReflectionMeshNode::function_bases[];
	constexpr uint16_t ReflectionMeshNode::function_arg_types[];
	constexpr uint16_t ReflectionMeshNode::function_arg_names[];
	constexpr uint16_t ReflectionMeshNode::function_arg_values[];
	constexpr uint16_t ReflectionMeshNode::callback_names[];
	constexpr uint16_t ReflectionMeshNode::callback_types[];
	constexpr uint16_t ReflectionMeshNode::callback_bases[];
	constexpr uint16_t ReflectionMeshNode::callback_arg_types[];
	constexpr uint16_t ReflectionMeshNode::callback_arg_names[];
	constexpr uint16_t ReflectionMeshNode::enum_names[];
	constexpr uint16_t ReflectionMeshNode::enum_bases[];
	constexpr uint16_t ReflectionMeshNode::enum_var_names[];
	static ReflectionMeshNode reflection_mesh_node;
	
	// Tellusim::MeshIndices
	class ReflectionMeshIndices : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshIndices::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshIndices, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshIndices, TypeList<MeshIndices::Type, Format, const char*>>((MeshIndices::Type)0, (Format)0, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<MeshIndices, TypeList<MeshIndices::Type, Format, uint32_t, const char*>>((MeshIndices::Type)0, (Format)0, {}, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshIndices>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)()>(&MeshIndices::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(const char*)>(&MeshIndices::setName));
						case 2: return FunctionPtr(new FunctionImpl<String(MeshIndices::*)() const>(&MeshIndices::getName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(MeshIndices::Type, Format, uint32_t)>(&MeshIndices::create, (MeshIndices::Type)0, (Format)0, 0));
						case 4: return FunctionPtr(new FunctionImpl<MeshIndices::Type(MeshIndices::*)() const>(&MeshIndices::getType));
						case 5: return FunctionPtr(new FunctionImpl<const char*(MeshIndices::Type)>(&MeshIndices::getTypeName));
						case 6: return FunctionPtr(new FunctionImpl<const char*(MeshIndices::*)() const>(&MeshIndices::getTypeName));
						case 7: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isUnknown));
						case 8: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isPoint));
						case 9: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isLine));
						case 10: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isTriangle));
						case 11: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isQuadrilateral));
						case 12: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isTetrahedron));
						case 13: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isPrimitive));
						case 14: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isSolid));
						case 15: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isVolume));
						case 16: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isMaterial));
						case 17: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isGroup));
						case 18: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isJoint));
						case 19: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isEdge));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)() const>(&MeshIndices::getPrimitiveSize));
						case 21: return FunctionPtr(new FunctionImpl<Format(MeshIndices::*)() const>(&MeshIndices::getFormat));
						case 22: return FunctionPtr(new FunctionImpl<const char*(MeshIndices::*)() const>(&MeshIndices::getFormatName));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(MeshGeometry&, bool)>(&MeshIndices::setGeometry, MeshGeometry::null, true));
						case 24: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshIndices::*)() const>(&MeshIndices::getGeometry));
						case 25: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshIndices::*)()>(&MeshIndices::getGeometry));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, bool, bool)>(&MeshIndices::setSize, {}, true, false));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)() const>(&MeshIndices::getSize));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)() const>(&MeshIndices::getStride));
						case 29: return FunctionPtr(new FunctionImpl<size_t(MeshIndices::*)() const>(&MeshIndices::getBytes));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t, uint32_t)>(&MeshIndices::setData, {}, 0, 0));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(const void*, Format, uint32_t, uint32_t)>(&MeshIndices::setData, {}, Tellusim::FormatUnknown, 0, 1));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(void*, Format, uint32_t, uint32_t) const>(&MeshIndices::getData, {}, Tellusim::FormatUnknown, 0, 1));
						case 33: return FunctionPtr(new FunctionVoidImpl<const void*(MeshIndices::*)() const>(&MeshIndices::getData));
						case 34: return FunctionPtr(new FunctionVoidImpl<void*(MeshIndices::*)()>(&MeshIndices::getData));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t)>(&MeshIndices::set));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t, uint32_t)>(&MeshIndices::set));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t, uint32_t, uint32_t)>(&MeshIndices::set));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t)>(&MeshIndices::set));
						case 39: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)(uint32_t) const>(&MeshIndices::get));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t&, uint32_t&) const>(&MeshIndices::get));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t&, uint32_t&, uint32_t&) const>(&MeshIndices::get));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(uint32_t, uint32_t&, uint32_t&, uint32_t&, uint32_t&) const>(&MeshIndices::get));
						case 43: return FunctionPtr(new FunctionVoidImpl<const void*(MeshIndices::*)(uint32_t) const>(&MeshIndices::getPtr));
						case 44: return FunctionPtr(new FunctionVoidImpl<void*(MeshIndices::*)(uint32_t)>(&MeshIndices::getPtr));
						case 45: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isDirect));
						case 46: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isUniform));
						case 47: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)() const>(&MeshIndices::getMinIndex));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)() const>(&MeshIndices::getMaxIndex));
						case 49: return FunctionPtr(new FunctionImpl<int32_t(MeshIndices::*)(const MeshIndices&) const>(&MeshIndices::compare));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)(const MeshIndices&, uint32_t, bool)>(&MeshIndices::addIndices, MeshIndices::null, {}, false));
						case 51: return FunctionPtr(new FunctionImpl<MeshIndices(MeshIndices::*)(Format) const>(&MeshIndices::toFormat));
						case 52: return FunctionPtr(new FunctionImpl<MeshIndices(MeshIndices::*)(MeshIndices::Type) const>(&MeshIndices::toType));
						case 53: return FunctionPtr(new FunctionImpl<MeshIndices(MeshIndices::*)(MeshIndices::Type, const MeshAttribute&) const>(&MeshIndices::toType));
						case 54: return FunctionPtr(new FunctionImpl<size_t(MeshIndices::*)() const>(&MeshIndices::getMemory));
						case 55: return FunctionPtr(new FunctionImpl<MeshIndices(MeshIndices::*)() const>(&MeshIndices::clonePtr));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)()>(&MeshIndices::clearPtr));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(MeshIndices::*)()>(&MeshIndices::destroyPtr));
						case 58: return FunctionPtr(new FunctionImpl<MeshIndices&(MeshIndices::*)()>(&MeshIndices::acquirePtr));
						case 59: return FunctionPtr(new FunctionImpl<MeshIndices&(MeshIndices::*)()>(&MeshIndices::unacquirePtr));
						case 60: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isValidPtr));
						case 61: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isOwnerPtr));
						case 62: return FunctionPtr(new FunctionImpl<bool(MeshIndices::*)() const>(&MeshIndices::isConstPtr));
						case 63: return FunctionPtr(new FunctionImpl<uint32_t(MeshIndices::*)() const>(&MeshIndices::getCountPtr));
						case 64: return FunctionPtr(new FunctionImpl<const void*(MeshIndices::*)() const>(&MeshIndices::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 4, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1010, 765, 1877, 1010, 765, 4039, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 4036, 2066, 3288, 4036, 2066, 3960, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 0, 3294, 0, 0, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 2, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3751, 2556, 1902, 2878, 2879, 2879, 3198, 3149, 3115, 3195, 3154, 3186, 3153, 3174, 3207, 3119, 3091, 3111, 3067, 2685, 2355, 2357, 3650, 2390, 2390, 3830, 2760, 2795, 2167, 3590, 3590, 2260, 2260, 2260, 3501, 3501, 3501, 3501, 2078, 2078, 2078, 2078, 2688, 2688, 3063, 3197, 2512, 2490, 1657, 1522, 4022, 4023, 4023, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4073, 1010, 1877, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 765, 1877, 4073, 1808, 1004, 4073, 4039, 4039, 3961, 4073, 4073, 4073, 1885, 4074, 4073, 4073, 4073, 4073, 4039, 4073, 4073, 4073, 1885, 4074, 1585, 1585, 4039, 4039, 3003, 4073, 1008, 1008, 1008, 3961, 1008, 4073, 4073, 1009, 1009, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7, 10, 10, 10, 10, 13, 17, 21, 21, 21, 23, 26, 30, 35, 36, 39, 43, 48, 49, 50, 50, 50, 50, 50, 51, 54, 55, 56, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1010, 765, 4039, 1010, 1005, 1585, 4039, 1585, 1585, 4039, 4039, 4039, 1885, 765, 4039, 4039, 4074, 765, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4040, 4040, 4039, 4040, 4040, 4040, 4039, 4040, 4040, 4040, 4040, 4039, 4039, 1811, 1811, 4039, 1585, 765, 1010, 1010, 1807 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4036, 2066, 3960, 4036, 2077, 1607, 3960, 1974, 1612, 4056, 3960, 3317, 3975, 2066, 3960, 3446, 1963, 2066, 3960, 3446, 2993, 4056, 2993, 4057, 4058, 2993, 4057, 4058, 4059, 2993, 4057, 4058, 4059, 4060, 2993, 2993, 4057, 4058, 2993, 4057, 4058, 4059, 2993, 4057, 4058, 4059, 4060, 2993, 2993, 2995, 2995, 3317, 2012, 2066, 4036, 4036, 3359 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 3, 0, 0, 4033, 0, 4033, 2016, 0, 3, 3, 0, 767, 3, 6, 0, 767, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311 };
			static constexpr uint16_t enum_bases[] = { 0, 12 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1364, 1356, 1388, 1366, 1383, 1357, 1348, 1344, 1349, 1335, 1117 };
	};
	constexpr uint16_t ReflectionMeshIndices::constructor_bases[];
	constexpr uint16_t ReflectionMeshIndices::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshIndices::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshIndices::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshIndices::function_flags[];
	constexpr uint16_t ReflectionMeshIndices::function_names[];
	constexpr uint16_t ReflectionMeshIndices::function_types[];
	constexpr uint16_t ReflectionMeshIndices::function_bases[];
	constexpr uint16_t ReflectionMeshIndices::function_arg_types[];
	constexpr uint16_t ReflectionMeshIndices::function_arg_names[];
	constexpr uint16_t ReflectionMeshIndices::function_arg_values[];
	constexpr uint16_t ReflectionMeshIndices::callback_names[];
	constexpr uint16_t ReflectionMeshIndices::callback_types[];
	constexpr uint16_t ReflectionMeshIndices::callback_bases[];
	constexpr uint16_t ReflectionMeshIndices::callback_arg_types[];
	constexpr uint16_t ReflectionMeshIndices::callback_arg_names[];
	constexpr uint16_t ReflectionMeshIndices::enum_names[];
	constexpr uint16_t ReflectionMeshIndices::enum_bases[];
	constexpr uint16_t ReflectionMeshIndices::enum_var_names[];
	static ReflectionMeshIndices reflection_mesh_indices;
	
	// Tellusim::MeshAttribute
	class ReflectionMeshAttribute : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshAttribute::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshAttribute, TypeList<const char*, uint32_t>>(nullptr, 0));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshAttribute, TypeList<MeshAttribute::Type, Format, const char*, uint32_t>>((MeshAttribute::Type)0, (Format)0, nullptr, 0));
						case 2: return ConstructorPtr(new ConstructorImpl<MeshAttribute, TypeList<MeshAttribute::Type, Format, uint32_t, const char*, uint32_t>>((MeshAttribute::Type)0, (Format)0, {}, nullptr, 0));
						case 3: return ConstructorPtr(new ConstructorImpl<MeshAttribute, TypeList<MeshAttribute::Type, Format, uint32_t, uint32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshAttribute>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)()>(&MeshAttribute::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(const char*)>(&MeshAttribute::setName));
						case 2: return FunctionPtr(new FunctionImpl<String(MeshAttribute::*)() const>(&MeshAttribute::getName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(MeshAttribute::Type, Format, uint32_t)>(&MeshAttribute::create, (MeshAttribute::Type)0, (Format)0, 0));
						case 4: return FunctionPtr(new FunctionImpl<MeshAttribute::Type(MeshAttribute::*)() const>(&MeshAttribute::getType));
						case 5: return FunctionPtr(new FunctionImpl<const char*(MeshAttribute::Type)>(&MeshAttribute::getTypeName));
						case 6: return FunctionPtr(new FunctionImpl<const char*(MeshAttribute::*)() const>(&MeshAttribute::getTypeName));
						case 7: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isUnknown));
						case 8: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isPosition));
						case 9: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isBasis));
						case 10: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isNormal));
						case 11: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isTangent));
						case 12: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isBinormal));
						case 13: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isSpatial));
						case 14: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isNormalized));
						case 15: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isTexCoord));
						case 16: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isWeights));
						case 17: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isJoints));
						case 18: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isColor));
						case 19: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isVertex));
						case 20: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isCrease));
						case 21: return FunctionPtr(new FunctionImpl<Format(MeshAttribute::*)() const>(&MeshAttribute::getFormat));
						case 22: return FunctionPtr(new FunctionImpl<const char*(MeshAttribute::*)() const>(&MeshAttribute::getFormatName));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttribute::*)() const>(&MeshAttribute::getComponents));
						case 24: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isPacked));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(uint32_t)>(&MeshAttribute::setIndex));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttribute::*)() const>(&MeshAttribute::getIndex));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(MeshIndices&)>(&MeshAttribute::setIndices));
						case 28: return FunctionPtr(new FunctionImpl<const MeshIndices(MeshAttribute::*)() const>(&MeshAttribute::getIndices));
						case 29: return FunctionPtr(new FunctionImpl<MeshIndices(MeshAttribute::*)()>(&MeshAttribute::getIndices));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(MeshGeometry&, bool)>(&MeshAttribute::setGeometry, MeshGeometry::null, true));
						case 31: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshAttribute::*)() const>(&MeshAttribute::getGeometry));
						case 32: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshAttribute::*)()>(&MeshAttribute::getGeometry));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(uint32_t, bool, bool)>(&MeshAttribute::setSize, {}, true, false));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttribute::*)() const>(&MeshAttribute::getSize));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttribute::*)() const>(&MeshAttribute::getStride));
						case 36: return FunctionPtr(new FunctionImpl<size_t(MeshAttribute::*)() const>(&MeshAttribute::getBytes));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(const void*, uint32_t, uint32_t)>(&MeshAttribute::setData, {}, 0, 0));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(const void*, const Array<uint32_t>&, uint32_t)>(&MeshAttribute::setData, {}, {}, 0));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(void*, uint32_t, uint32_t) const>(&MeshAttribute::getData, {}, 0, 0));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(void*, const MeshIndices&, uint32_t) const>(&MeshAttribute::getData, {}, MeshIndices::null, 0));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(void*, const Array<uint32_t>&, uint32_t) const>(&MeshAttribute::getData, {}, {}, 0));
						case 42: return FunctionPtr(new FunctionVoidImpl<const void*(MeshAttribute::*)() const>(&MeshAttribute::getData));
						case 43: return FunctionPtr(new FunctionVoidImpl<void*(MeshAttribute::*)()>(&MeshAttribute::getData));
						case 44: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(uint32_t, const void*, size_t)>(&MeshAttribute::setValue));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(uint32_t, void*, size_t) const>(&MeshAttribute::getValue));
						case 46: return FunctionPtr(new FunctionVoidImpl<const void*(MeshAttribute::*)(uint32_t) const>(&MeshAttribute::getPtr));
						case 47: return FunctionPtr(new FunctionVoidImpl<void*(MeshAttribute::*)(uint32_t)>(&MeshAttribute::getPtr));
						case 48: return FunctionPtr(new FunctionImpl<int32_t(MeshAttribute::*)(const MeshAttribute&, const Matrix4x3f&, float32_t, bool) const>(&MeshAttribute::compare, MeshAttribute::null, Matrix4x3f::identity, 1e-6f, true));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)(const MeshAttribute&)>(&MeshAttribute::addAttribute));
						case 50: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)(const Matrix4x3f&)>(&MeshAttribute::setTransform));
						case 51: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)(const MeshAttribute&, float32_t)>(&MeshAttribute::morphAttribute));
						case 52: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)(const MeshAttribute&, const MeshAttribute&, Format)>(&MeshAttribute::packAttributes));
						case 53: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)(MeshAttribute&, MeshAttribute&) const>(&MeshAttribute::unpackAttributes));
						case 54: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshAttribute::*)(MeshIndices&) const>(&MeshAttribute::optimizeAttribute));
						case 55: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshAttribute::*)(const MeshIndices&) const>(&MeshAttribute::toDirect));
						case 56: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshAttribute::*)(Format) const>(&MeshAttribute::toFormat));
						case 57: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshAttribute::*)(MeshAttribute::Type) const>(&MeshAttribute::toType));
						case 58: return FunctionPtr(new FunctionImpl<Matrix4x3f(MeshAttribute::*)() const>(&MeshAttribute::getCovarianceMatrix));
						case 59: return FunctionPtr(new FunctionImpl<Matrix4x3f(MeshAttribute::*)() const>(&MeshAttribute::getMinTransform));
						case 60: return FunctionPtr(new FunctionImpl<BoundBoxf(MeshAttribute::*)() const>(&MeshAttribute::getBoundBox));
						case 61: return FunctionPtr(new FunctionImpl<BoundSpheref(MeshAttribute::*)() const>(&MeshAttribute::getBoundSphere));
						case 62: return FunctionPtr(new FunctionImpl<size_t(MeshAttribute::*)() const>(&MeshAttribute::getMemory));
						case 63: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshAttribute::*)() const>(&MeshAttribute::clonePtr));
						case 64: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)()>(&MeshAttribute::clearPtr));
						case 65: return FunctionPtr(new FunctionVoidImpl<void(MeshAttribute::*)()>(&MeshAttribute::destroyPtr));
						case 66: return FunctionPtr(new FunctionImpl<MeshAttribute&(MeshAttribute::*)()>(&MeshAttribute::acquirePtr));
						case 67: return FunctionPtr(new FunctionImpl<MeshAttribute&(MeshAttribute::*)()>(&MeshAttribute::unacquirePtr));
						case 68: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isValidPtr));
						case 69: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isOwnerPtr));
						case 70: return FunctionPtr(new FunctionImpl<bool(MeshAttribute::*)() const>(&MeshAttribute::isConstPtr));
						case 71: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttribute::*)() const>(&MeshAttribute::getCountPtr));
						case 72: return FunctionPtr(new FunctionImpl<const void*(MeshAttribute::*)() const>(&MeshAttribute::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 6, 11, 15 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 4039, 998, 765, 1877, 4039, 998, 765, 4039, 1877, 4039, 998, 765, 4039, 4039 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 2993, 4036, 2066, 3288, 2993, 4036, 2066, 3960, 3288, 2993, 4036, 2066, 3960, 2993 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 3, 0, 0, 3294, 3, 0, 0, 0, 3294, 3, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3751, 2556, 1902, 2878, 2879, 2879, 3198, 3151, 3027, 3133, 3183, 3030, 3177, 3134, 3187, 3208, 3112, 3048, 3202, 3056, 2355, 2357, 2223, 3143, 3665, 2421, 3670, 2426, 2426, 3650, 2390, 2390, 3830, 2760, 2795, 2167, 3590, 3590, 2260, 2260, 2260, 2260, 2260, 3926, 2898, 2688, 2688, 1657, 1511, 3911, 3282, 3346, 4049, 3331, 4021, 4022, 4023, 2240, 2516, 2136, 2139, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4073, 998, 1877, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 765, 1877, 4039, 1585, 4073, 4039, 4073, 1810, 1008, 4073, 1808, 1004, 4073, 4039, 4039, 3961, 4073, 4073, 4073, 4073, 4073, 1885, 4074, 4073, 4073, 1885, 4074, 3003, 4073, 1585, 1585, 1585, 1585, 996, 996, 996, 996, 979, 979, 150, 151, 3961, 996, 4073, 4073, 997, 997, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 7, 7, 7, 9, 9, 9, 12, 12, 12, 12, 15, 18, 21, 24, 27, 27, 27, 30, 33, 34, 35, 39, 40, 41, 43, 46, 48, 49, 50, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52 };
			static constexpr uint16_t function_arg_types[] = { 1877, 998, 765, 4039, 998, 4039, 1009, 1005, 1585, 4039, 1585, 1585, 1885, 4039, 4039, 1885, 1703, 4039, 4074, 4039, 4039, 4074, 1811, 4039, 4074, 1703, 4039, 4039, 1885, 3961, 4039, 4074, 3961, 4039, 4039, 1807, 1798, 2051, 1585, 1807, 1798, 1807, 2051, 1807, 1807, 765, 997, 997, 1009, 1811, 765, 998 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4036, 2066, 3960, 4036, 2993, 2995, 2077, 1607, 3960, 1974, 1612, 3975, 3960, 3991, 3975, 2995, 3991, 1963, 3960, 3991, 1963, 2995, 3991, 1963, 2995, 3991, 2993, 3975, 3960, 2993, 1963, 3960, 2993, 2993, 1562, 4028, 4016, 3973, 1562, 4028, 1562, 3228, 1563, 1564, 2066, 1563, 1564, 2995, 2995, 2066, 4036 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 3, 0, 0, 0, 0, 4033, 0, 4033, 2016, 0, 3, 3, 0, 0, 3, 0, 3, 3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 980, 16, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311 };
			static constexpr uint16_t enum_bases[] = { 0, 13 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1365, 1316, 1359, 1381, 1317, 1384, 1391, 1350, 1327, 1331, 1345, 1117 };
	};
	constexpr uint16_t ReflectionMeshAttribute::constructor_bases[];
	constexpr uint16_t ReflectionMeshAttribute::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshAttribute::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshAttribute::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshAttribute::function_flags[];
	constexpr uint16_t ReflectionMeshAttribute::function_names[];
	constexpr uint16_t ReflectionMeshAttribute::function_types[];
	constexpr uint16_t ReflectionMeshAttribute::function_bases[];
	constexpr uint16_t ReflectionMeshAttribute::function_arg_types[];
	constexpr uint16_t ReflectionMeshAttribute::function_arg_names[];
	constexpr uint16_t ReflectionMeshAttribute::function_arg_values[];
	constexpr uint16_t ReflectionMeshAttribute::callback_names[];
	constexpr uint16_t ReflectionMeshAttribute::callback_types[];
	constexpr uint16_t ReflectionMeshAttribute::callback_bases[];
	constexpr uint16_t ReflectionMeshAttribute::callback_arg_types[];
	constexpr uint16_t ReflectionMeshAttribute::callback_arg_names[];
	constexpr uint16_t ReflectionMeshAttribute::enum_names[];
	constexpr uint16_t ReflectionMeshAttribute::enum_bases[];
	constexpr uint16_t ReflectionMeshAttribute::enum_var_names[];
	static ReflectionMeshAttribute reflection_mesh_attribute;
	
	// Tellusim::MeshJoint
	class ReflectionMeshJoint : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshJoint::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshJoint, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshJoint, TypeList<MeshGeometry&, const char*>>(MeshGeometry::null, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshJoint>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)()>(&MeshJoint::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(const char*)>(&MeshJoint::setName));
						case 2: return FunctionPtr(new FunctionImpl<String(MeshJoint::*)() const>(&MeshJoint::getName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(MeshNode&)>(&MeshJoint::setNode));
						case 4: return FunctionPtr(new FunctionImpl<const MeshNode(MeshJoint::*)() const>(&MeshJoint::getNode));
						case 5: return FunctionPtr(new FunctionImpl<MeshNode(MeshJoint::*)()>(&MeshJoint::getNode));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(MeshJoint::*)() const>(&MeshJoint::getNodeIndex));
						case 7: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshJoint::*)() const>(&MeshJoint::getLocalTransform));
						case 8: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshJoint::*)() const>(&MeshJoint::getGlobalTransform));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(MeshIndices&)>(&MeshJoint::setIndices));
						case 10: return FunctionPtr(new FunctionImpl<const MeshIndices(MeshJoint::*)() const>(&MeshJoint::getIndices));
						case 11: return FunctionPtr(new FunctionImpl<MeshIndices(MeshJoint::*)()>(&MeshJoint::getIndices));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(MeshGeometry&, bool)>(&MeshJoint::setGeometry, MeshGeometry::null, true));
						case 13: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshJoint::*)() const>(&MeshJoint::getGeometry));
						case 14: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshJoint::*)()>(&MeshJoint::getGeometry));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(const BoundBoxf&)>(&MeshJoint::setBoundBox));
						case 16: return FunctionPtr(new FunctionImpl<const BoundBoxf&(MeshJoint::*)() const>(&MeshJoint::getBoundBox));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(const BoundSpheref&)>(&MeshJoint::setBoundSphere));
						case 18: return FunctionPtr(new FunctionImpl<const BoundSpheref&(MeshJoint::*)()>(&MeshJoint::getBoundSphere));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)(const Matrix4x3f&)>(&MeshJoint::setITransform));
						case 20: return FunctionPtr(new FunctionImpl<const Matrix4x3f&(MeshJoint::*)() const>(&MeshJoint::getITransform));
						case 21: return FunctionPtr(new FunctionImpl<int32_t(MeshJoint::*)(const MeshJoint&) const>(&MeshJoint::compare));
						case 22: return FunctionPtr(new FunctionImpl<size_t(MeshJoint::*)() const>(&MeshJoint::getMemory));
						case 23: return FunctionPtr(new FunctionImpl<MeshJoint(MeshJoint::*)() const>(&MeshJoint::clonePtr));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)()>(&MeshJoint::clearPtr));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(MeshJoint::*)()>(&MeshJoint::destroyPtr));
						case 26: return FunctionPtr(new FunctionImpl<MeshJoint&(MeshJoint::*)()>(&MeshJoint::acquirePtr));
						case 27: return FunctionPtr(new FunctionImpl<MeshJoint&(MeshJoint::*)()>(&MeshJoint::unacquirePtr));
						case 28: return FunctionPtr(new FunctionImpl<bool(MeshJoint::*)() const>(&MeshJoint::isValidPtr));
						case 29: return FunctionPtr(new FunctionImpl<bool(MeshJoint::*)() const>(&MeshJoint::isOwnerPtr));
						case 30: return FunctionPtr(new FunctionImpl<bool(MeshJoint::*)() const>(&MeshJoint::isConstPtr));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(MeshJoint::*)() const>(&MeshJoint::getCountPtr));
						case 32: return FunctionPtr(new FunctionImpl<const void*(MeshJoint::*)() const>(&MeshJoint::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1005, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 2077, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3751, 2556, 3753, 2558, 2558, 2559, 2470, 2396, 3670, 2426, 2426, 3650, 2390, 2390, 3529, 2136, 3531, 2139, 3662, 2418, 1657, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4073, 1817, 1018, 4039, 1797, 1797, 4073, 1810, 1008, 4073, 1808, 1004, 4073, 1707, 4073, 1708, 4073, 1798, 3003, 3961, 1011, 4073, 4073, 1012, 1012, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1019, 1009, 1005, 1585, 1707, 1708, 1798, 1813 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3290, 2995, 2077, 1607, 1592, 3974, 3226, 3227 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 4033, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMeshJoint::constructor_bases[];
	constexpr uint16_t ReflectionMeshJoint::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshJoint::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshJoint::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshJoint::function_flags[];
	constexpr uint16_t ReflectionMeshJoint::function_names[];
	constexpr uint16_t ReflectionMeshJoint::function_types[];
	constexpr uint16_t ReflectionMeshJoint::function_bases[];
	constexpr uint16_t ReflectionMeshJoint::function_arg_types[];
	constexpr uint16_t ReflectionMeshJoint::function_arg_names[];
	constexpr uint16_t ReflectionMeshJoint::function_arg_values[];
	constexpr uint16_t ReflectionMeshJoint::callback_names[];
	constexpr uint16_t ReflectionMeshJoint::callback_types[];
	constexpr uint16_t ReflectionMeshJoint::callback_bases[];
	constexpr uint16_t ReflectionMeshJoint::callback_arg_types[];
	constexpr uint16_t ReflectionMeshJoint::callback_arg_names[];
	constexpr uint16_t ReflectionMeshJoint::enum_names[];
	constexpr uint16_t ReflectionMeshJoint::enum_bases[];
	constexpr uint16_t ReflectionMeshJoint::enum_var_names[];
	static ReflectionMeshJoint reflection_mesh_joint;
	
	// Tellusim::MeshMaterial
	class ReflectionMeshMaterial : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshMaterial::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshMaterial, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshMaterial, TypeList<MeshGeometry&, const char*>>(MeshGeometry::null, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshMaterial>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)()>(&MeshMaterial::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*)>(&MeshMaterial::setName));
						case 2: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)() const>(&MeshMaterial::getName));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(MeshMaterial::*)() const>(&MeshMaterial::getIndex));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(MeshIndices&)>(&MeshMaterial::setIndices));
						case 5: return FunctionPtr(new FunctionImpl<const MeshIndices(MeshMaterial::*)() const>(&MeshMaterial::getIndices));
						case 6: return FunctionPtr(new FunctionImpl<MeshIndices(MeshMaterial::*)()>(&MeshMaterial::getIndices));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(MeshGeometry&, bool)>(&MeshMaterial::setGeometry, MeshGeometry::null, true));
						case 8: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshMaterial::*)() const>(&MeshMaterial::getGeometry));
						case 9: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshMaterial::*)()>(&MeshMaterial::getGeometry));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*)>(&MeshMaterial::setData));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const String&)>(&MeshMaterial::setData));
						case 12: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)() const>(&MeshMaterial::getData));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)()>(&MeshMaterial::clearParameters));
						case 14: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(const char*)>(&MeshMaterial::removeParameter));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const MeshMaterial&)>(&MeshMaterial::copyParameters));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(MeshMaterial::*)(const char*) const>(&MeshMaterial::findParameter));
						case 17: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(const char*) const>(&MeshMaterial::hasParameter));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(MeshMaterial::*)() const>(&MeshMaterial::getNumParameters));
						case 19: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)(uint32_t) const>(&MeshMaterial::getParameterType));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, bool)>(&MeshMaterial::addParameter));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, float32_t)>(&MeshMaterial::addParameter));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, const Vector4f&)>(&MeshMaterial::addParameter));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, const Matrix3x2f&)>(&MeshMaterial::addParameter));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, const Color&)>(&MeshMaterial::addParameter));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, const char*, const char*)>(&MeshMaterial::addParameter, {}, {}, nullptr));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, const String&, const char*)>(&MeshMaterial::addParameter, {}, {}, nullptr));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, const Image&, const char*)>(&MeshMaterial::addParameter, {}, Image::null, nullptr));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)(const char*, Blob&, const char*)>(&MeshMaterial::addParameter, {}, Blob::null, nullptr));
						case 29: return FunctionPtr(new FunctionImpl<MeshMaterial::Flags(MeshMaterial::*)(uint32_t) const>(&MeshMaterial::getParameterFlags));
						case 30: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(uint32_t, MeshMaterial::Flags) const>(&MeshMaterial::hasParameterFlag));
						case 31: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(uint32_t, MeshMaterial::Flags) const>(&MeshMaterial::hasParameterFlags));
						case 32: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(uint32_t, bool) const>(&MeshMaterial::getParameterBool, {}, false));
						case 33: return FunctionPtr(new FunctionImpl<float32_t(MeshMaterial::*)(uint32_t, float32_t) const>(&MeshMaterial::getParameterScalarf32, {}, 0.0f));
						case 34: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshMaterial::*)(uint32_t, const Vector4f&) const>(&MeshMaterial::getParameterVector4f, {}, Vector4f::zero));
						case 35: return FunctionPtr(new FunctionImpl<const Matrix3x2f&(MeshMaterial::*)(uint32_t, const Matrix3x2f&) const>(&MeshMaterial::getParameterMatrix3x2f, {}, Matrix3x2f::identity));
						case 36: return FunctionPtr(new FunctionImpl<const Color&(MeshMaterial::*)(uint32_t, const Color&) const>(&MeshMaterial::getParameterColor, {}, Color::white));
						case 37: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)(uint32_t, const String&) const>(&MeshMaterial::getParameterName, {}, String::null));
						case 38: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)(uint32_t, const String&) const>(&MeshMaterial::getParameterLayout, {}, String::null));
						case 39: return FunctionPtr(new FunctionImpl<const Image(MeshMaterial::*)(uint32_t) const>(&MeshMaterial::getParameterImage));
						case 40: return FunctionPtr(new FunctionImpl<Blob(MeshMaterial::*)(uint32_t) const>(&MeshMaterial::getParameterBlob));
						case 41: return FunctionPtr(new FunctionImpl<Image(MeshMaterial::*)(uint32_t)>(&MeshMaterial::getParameterImage));
						case 42: return FunctionPtr(new FunctionImpl<Blob(MeshMaterial::*)(uint32_t)>(&MeshMaterial::getParameterBlob));
						case 43: return FunctionPtr(new FunctionImpl<MeshMaterial::Flags(MeshMaterial::*)(const char*) const>(&MeshMaterial::getParameterFlags));
						case 44: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(const char*, MeshMaterial::Flags) const>(&MeshMaterial::hasParameterFlag));
						case 45: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(const char*, MeshMaterial::Flags) const>(&MeshMaterial::hasParameterFlags));
						case 46: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)(const char*, bool) const>(&MeshMaterial::getParameterBool, {}, false));
						case 47: return FunctionPtr(new FunctionImpl<float32_t(MeshMaterial::*)(const char*, float32_t) const>(&MeshMaterial::getParameterScalarf32, {}, 0.0f));
						case 48: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshMaterial::*)(const char*, const Vector4f&) const>(&MeshMaterial::getParameterVector4f, {}, Vector4f::zero));
						case 49: return FunctionPtr(new FunctionImpl<const Matrix3x2f&(MeshMaterial::*)(const char*, const Matrix3x2f&) const>(&MeshMaterial::getParameterMatrix3x2f, {}, Matrix3x2f::identity));
						case 50: return FunctionPtr(new FunctionImpl<const Color&(MeshMaterial::*)(const char*, const Color&) const>(&MeshMaterial::getParameterColor, {}, Color::white));
						case 51: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)(const char*, const String&) const>(&MeshMaterial::getParameterName, {}, String::null));
						case 52: return FunctionPtr(new FunctionImpl<String(MeshMaterial::*)(const char*, const String&) const>(&MeshMaterial::getParameterLayout, {}, String::null));
						case 53: return FunctionPtr(new FunctionImpl<int32_t(MeshMaterial::*)(const MeshMaterial&) const>(&MeshMaterial::compare));
						case 54: return FunctionPtr(new FunctionImpl<size_t(MeshMaterial::*)() const>(&MeshMaterial::getMemory));
						case 55: return FunctionPtr(new FunctionImpl<MeshMaterial(MeshMaterial::*)() const>(&MeshMaterial::clonePtr));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)()>(&MeshMaterial::clearPtr));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(MeshMaterial::*)()>(&MeshMaterial::destroyPtr));
						case 58: return FunctionPtr(new FunctionImpl<MeshMaterial&(MeshMaterial::*)()>(&MeshMaterial::acquirePtr));
						case 59: return FunctionPtr(new FunctionImpl<MeshMaterial&(MeshMaterial::*)()>(&MeshMaterial::unacquirePtr));
						case 60: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)() const>(&MeshMaterial::isValidPtr));
						case 61: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)() const>(&MeshMaterial::isOwnerPtr));
						case 62: return FunctionPtr(new FunctionImpl<bool(MeshMaterial::*)() const>(&MeshMaterial::isConstPtr));
						case 63: return FunctionPtr(new FunctionImpl<uint32_t(MeshMaterial::*)() const>(&MeshMaterial::getCountPtr));
						case 64: return FunctionPtr(new FunctionImpl<const void*(MeshMaterial::*)() const>(&MeshMaterial::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1005, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 2077, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 2, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3751, 2556, 2421, 3670, 2426, 2426, 3650, 2390, 2390, 3590, 3590, 2260, 1635, 3439, 1894, 2041, 2963, 2601, 2649, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 2643, 2964, 2965, 2641, 2648, 2650, 2646, 2642, 2647, 2645, 2644, 2640, 2644, 2640, 2643, 2964, 2965, 2641, 2648, 2650, 2646, 2642, 2647, 2645, 1657, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4039, 4073, 1810, 1008, 4073, 1808, 1004, 4073, 4073, 1274, 4073, 1585, 4073, 4039, 1585, 4039, 1274, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1015, 1585, 1585, 1585, 2051, 1858, 1796, 1721, 1274, 1274, 1780, 147, 838, 147, 1015, 1585, 1585, 1585, 2051, 1858, 1796, 1721, 1274, 1274, 3003, 3961, 1013, 4073, 4073, 1014, 1014, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 2, 2, 2, 4, 4, 4, 5, 6, 6, 6, 7, 8, 9, 10, 10, 11, 13, 15, 17, 19, 21, 24, 27, 30, 33, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 53, 54, 55, 56, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1009, 1005, 1585, 1877, 1841, 1877, 1815, 1877, 1877, 4039, 1877, 1585, 1877, 2051, 1877, 1858, 1877, 1796, 1877, 1721, 1877, 1877, 1877, 1877, 1841, 1877, 1877, 1781, 1877, 1877, 148, 1877, 4039, 4039, 1015, 4039, 1015, 4039, 1585, 4039, 2051, 4039, 1858, 4039, 1796, 4039, 1721, 4039, 1841, 4039, 1841, 4039, 4039, 4039, 4039, 1877, 1877, 1015, 1877, 1015, 1877, 1585, 1877, 2051, 1877, 1858, 1877, 1796, 1877, 1721, 1877, 1841, 1877, 1841, 1815 };
			static constexpr uint16_t function_arg_names[] = { 3288, 2995, 2077, 1607, 1948, 1948, 4036, 3262, 4036, 4036, 2993, 4036, 4056, 4036, 4056, 4036, 4056, 4036, 4056, 4036, 1650, 4036, 3288, 3238, 4036, 3288, 3238, 4036, 2989, 3238, 4036, 1583, 3238, 2993, 2993, 2045, 2993, 2045, 2993, 4056, 2993, 4056, 2993, 4062, 2993, 3263, 2993, 1650, 2993, 3288, 2993, 3238, 2993, 2993, 2993, 2993, 4036, 4036, 2045, 4036, 2045, 4036, 4056, 4036, 4056, 4036, 4062, 4036, 3263, 4036, 1650, 4036, 3288, 4036, 3238, 3262 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 3294, 0, 0, 3294, 0, 0, 3294, 0, 0, 0, 0, 0, 0, 2016, 0, 4, 0, 1424, 0, 976, 0, 252, 0, 1277, 0, 1277, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 4, 0, 1424, 0, 976, 0, 252, 0, 1277, 0, 1277, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753 };
			static constexpr uint16_t enum_bases[] = { 0, 11 };
			static constexpr uint16_t enum_var_names[] = { 678, 596, 708, 737, 655, 609, 674, 649, 595, 640, 728 };
	};
	constexpr uint16_t ReflectionMeshMaterial::constructor_bases[];
	constexpr uint16_t ReflectionMeshMaterial::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshMaterial::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshMaterial::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshMaterial::function_flags[];
	constexpr uint16_t ReflectionMeshMaterial::function_names[];
	constexpr uint16_t ReflectionMeshMaterial::function_types[];
	constexpr uint16_t ReflectionMeshMaterial::function_bases[];
	constexpr uint16_t ReflectionMeshMaterial::function_arg_types[];
	constexpr uint16_t ReflectionMeshMaterial::function_arg_names[];
	constexpr uint16_t ReflectionMeshMaterial::function_arg_values[];
	constexpr uint16_t ReflectionMeshMaterial::callback_names[];
	constexpr uint16_t ReflectionMeshMaterial::callback_types[];
	constexpr uint16_t ReflectionMeshMaterial::callback_bases[];
	constexpr uint16_t ReflectionMeshMaterial::callback_arg_types[];
	constexpr uint16_t ReflectionMeshMaterial::callback_arg_names[];
	constexpr uint16_t ReflectionMeshMaterial::enum_names[];
	constexpr uint16_t ReflectionMeshMaterial::enum_bases[];
	constexpr uint16_t ReflectionMeshMaterial::enum_var_names[];
	static ReflectionMeshMaterial reflection_mesh_material;
	
	// Tellusim::MeshGeometry
	class ReflectionMeshGeometry : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshGeometry::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshGeometry, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshGeometry, TypeList<Mesh&, const char*>>(Mesh::null, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshGeometry>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(const char*)>(&MeshGeometry::setName));
						case 2: return FunctionPtr(new FunctionImpl<String(MeshGeometry::*)() const>(&MeshGeometry::getName));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getIndex));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(Mesh&, bool)>(&MeshGeometry::setMesh, Mesh::null, true));
						case 5: return FunctionPtr(new FunctionImpl<const Mesh(MeshGeometry::*)() const>(&MeshGeometry::getMesh));
						case 6: return FunctionPtr(new FunctionImpl<Mesh(MeshGeometry::*)()>(&MeshGeometry::getMesh));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshGeometry&, bool)>(&MeshGeometry::setParent0, MeshGeometry::null, true));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshGeometry&, bool)>(&MeshGeometry::setParent1, MeshGeometry::null, true));
						case 9: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshGeometry::*)() const>(&MeshGeometry::getParent0));
						case 10: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshGeometry::*)() const>(&MeshGeometry::getParent1));
						case 11: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshGeometry::*)()>(&MeshGeometry::getParent0));
						case 12: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshGeometry::*)()>(&MeshGeometry::getParent1));
						case 13: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::isRoot));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(uint32_t)>(&MeshGeometry::reserveChildren));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshGeometry&, bool)>(&MeshGeometry::addChild0, MeshGeometry::null, true));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshGeometry&, bool)>(&MeshGeometry::addChild1, MeshGeometry::null, true));
						case 17: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshGeometry&)>(&MeshGeometry::removeChild));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::releaseChildren));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshGeometry&) const>(&MeshGeometry::findChild));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getNumChildren));
						case 21: return FunctionPtr(new FunctionImpl<const Array<MeshGeometry>(MeshGeometry::*)() const>(&MeshGeometry::getChildren));
						case 22: return FunctionPtr(new FunctionImpl<Array<MeshGeometry>(MeshGeometry::*)()>(&MeshGeometry::getChildren));
						case 23: return FunctionPtr(new FunctionImpl<const MeshGeometry(MeshGeometry::*)(uint32_t) const>(&MeshGeometry::getChild));
						case 24: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshGeometry::*)(uint32_t)>(&MeshGeometry::getChild));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::clearIndices));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(uint32_t)>(&MeshGeometry::reserveIndices));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshIndices&, bool)>(&MeshGeometry::addIndices, MeshIndices::null, true));
						case 28: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshIndices&)>(&MeshGeometry::removeIndices));
						case 29: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshIndices&, MeshIndices&)>(&MeshGeometry::replaceIndices));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshIndices&) const>(&MeshGeometry::findIndices));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshIndices::Type) const>(&MeshGeometry::findIndices));
						case 32: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshIndices::Type) const>(&MeshGeometry::hasIndices));
						case 33: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::hasSolidIndices));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshIndices::Type) const>(&MeshGeometry::getNumIndices));
						case 35: return FunctionPtr(new FunctionImpl<const MeshIndices(MeshGeometry::*)(MeshIndices::Type) const>(&MeshGeometry::getIndices));
						case 36: return FunctionPtr(new FunctionImpl<MeshIndices(MeshGeometry::*)(MeshIndices::Type)>(&MeshGeometry::getIndices));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getNumIndices));
						case 38: return FunctionPtr(new FunctionImpl<const Array<MeshIndices>(MeshGeometry::*)() const>(&MeshGeometry::getIndices));
						case 39: return FunctionPtr(new FunctionImpl<Array<MeshIndices>(MeshGeometry::*)()>(&MeshGeometry::getIndices));
						case 40: return FunctionPtr(new FunctionImpl<const MeshIndices(MeshGeometry::*)(uint32_t) const>(&MeshGeometry::getIndices));
						case 41: return FunctionPtr(new FunctionImpl<MeshIndices(MeshGeometry::*)(uint32_t)>(&MeshGeometry::getIndices));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::clearAttributes));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(uint32_t)>(&MeshGeometry::reserveAttributes));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshAttribute&, bool)>(&MeshGeometry::addAttribute, MeshAttribute::null, true));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshAttribute&, MeshIndices&, bool)>(&MeshGeometry::addAttribute, MeshAttribute::null, MeshIndices::null, true));
						case 46: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshAttribute&)>(&MeshGeometry::removeAttribute));
						case 47: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshAttribute&, MeshAttribute&)>(&MeshGeometry::replaceAttribute));
						case 48: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(const MeshIndices&, MeshIndices&)>(&MeshGeometry::replaceAttributeIndices));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshAttribute::Type, Format, uint32_t) const>(&MeshGeometry::findAttribute, {}, (Format)0, 0));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshAttribute::Type, uint32_t) const>(&MeshGeometry::findAttribute, {}, 0));
						case 51: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const char*, uint32_t) const>(&MeshGeometry::findAttribute, {}, 0));
						case 52: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshAttribute&) const>(&MeshGeometry::findAttribute));
						case 53: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshAttribute::Type, Format, uint32_t) const>(&MeshGeometry::hasAttribute, {}, (Format)0, 0));
						case 54: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshAttribute::Type, uint32_t) const>(&MeshGeometry::hasAttribute, {}, 0));
						case 55: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(const char*, uint32_t) const>(&MeshGeometry::hasAttribute, {}, 0));
						case 56: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(const MeshAttribute&) const>(&MeshGeometry::hasAttribute));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshAttribute::Type) const>(&MeshGeometry::getNumAttributes));
						case 58: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshIndices&) const>(&MeshGeometry::getNumAttributes));
						case 59: return FunctionPtr(new FunctionImpl<const MeshAttribute(MeshGeometry::*)(MeshAttribute::Type, uint32_t) const>(&MeshGeometry::getAttribute, {}, 0));
						case 60: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshGeometry::*)(MeshAttribute::Type, uint32_t)>(&MeshGeometry::getAttribute, {}, 0));
						case 61: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getNumAttributes));
						case 62: return FunctionPtr(new FunctionImpl<const Array<MeshAttribute>(MeshGeometry::*)() const>(&MeshGeometry::getAttributes));
						case 63: return FunctionPtr(new FunctionImpl<Array<MeshAttribute>(MeshGeometry::*)()>(&MeshGeometry::getAttributes));
						case 64: return FunctionPtr(new FunctionImpl<const MeshAttribute(MeshGeometry::*)(uint32_t) const>(&MeshGeometry::getAttribute));
						case 65: return FunctionPtr(new FunctionImpl<MeshAttribute(MeshGeometry::*)(uint32_t)>(&MeshGeometry::getAttribute));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::clearJoints));
						case 67: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(uint32_t)>(&MeshGeometry::reserveJoints));
						case 68: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshJoint&, bool)>(&MeshGeometry::addJoint, MeshJoint::null, true));
						case 69: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshJoint&, MeshNode&, bool)>(&MeshGeometry::addJoint, MeshJoint::null, MeshNode::null, true));
						case 70: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshJoint&)>(&MeshGeometry::removeJoint));
						case 71: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshJoint&, MeshJoint&)>(&MeshGeometry::replaceJoint));
						case 72: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshJoint&) const>(&MeshGeometry::findJoint));
						case 73: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshNode&) const>(&MeshGeometry::findJoint));
						case 74: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const char*) const>(&MeshGeometry::findJoint));
						case 75: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getNumJoints));
						case 76: return FunctionPtr(new FunctionImpl<const Array<MeshJoint>(MeshGeometry::*)() const>(&MeshGeometry::getJoints));
						case 77: return FunctionPtr(new FunctionImpl<Array<MeshJoint>(MeshGeometry::*)()>(&MeshGeometry::getJoints));
						case 78: return FunctionPtr(new FunctionImpl<const MeshJoint(MeshGeometry::*)(uint32_t) const>(&MeshGeometry::getJoint));
						case 79: return FunctionPtr(new FunctionImpl<MeshJoint(MeshGeometry::*)(uint32_t)>(&MeshGeometry::getJoint));
						case 80: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::clearMaterials));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(uint32_t)>(&MeshGeometry::reserveMaterials));
						case 82: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshMaterial&, bool)>(&MeshGeometry::addMaterial, MeshMaterial::null, true));
						case 83: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(MeshMaterial&, MeshIndices&, bool)>(&MeshGeometry::addMaterial, MeshMaterial::null, MeshIndices::null, true));
						case 84: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshMaterial&)>(&MeshGeometry::removeMaterial));
						case 85: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(MeshMaterial&, MeshMaterial&)>(&MeshGeometry::replaceMaterial));
						case 86: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const MeshMaterial&) const>(&MeshGeometry::findMaterial));
						case 87: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(const char*) const>(&MeshGeometry::findMaterial));
						case 88: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getNumMaterials));
						case 89: return FunctionPtr(new FunctionImpl<const Array<MeshMaterial>(MeshGeometry::*)() const>(&MeshGeometry::getMaterials));
						case 90: return FunctionPtr(new FunctionImpl<Array<MeshMaterial>(MeshGeometry::*)()>(&MeshGeometry::getMaterials));
						case 91: return FunctionPtr(new FunctionImpl<const MeshMaterial(MeshGeometry::*)(uint32_t) const>(&MeshGeometry::getMaterial));
						case 92: return FunctionPtr(new FunctionImpl<MeshMaterial(MeshGeometry::*)(uint32_t)>(&MeshGeometry::getMaterial));
						case 93: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(const BoundBoxf&)>(&MeshGeometry::setBoundBox));
						case 94: return FunctionPtr(new FunctionImpl<const BoundBoxf&(MeshGeometry::*)() const>(&MeshGeometry::getBoundBox));
						case 95: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(const BoundSpheref&)>(&MeshGeometry::setBoundSphere));
						case 96: return FunctionPtr(new FunctionImpl<const BoundSpheref&(MeshGeometry::*)() const>(&MeshGeometry::getBoundSphere));
						case 97: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(const Vector3f&)>(&MeshGeometry::setTransform));
						case 98: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(const Matrix4x3f&, bool)>(&MeshGeometry::setTransform, {}, false));
						case 99: return FunctionPtr(new FunctionImpl<const Matrix4x3f&(MeshGeometry::*)() const>(&MeshGeometry::getTransform));
						case 100: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(const Matrix4x3f&)>(&MeshGeometry::setJointITransform));
						case 101: return FunctionPtr(new FunctionImpl<const Matrix4x3f&(MeshGeometry::*)() const>(&MeshGeometry::getJointITransform));
						case 102: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(float32_t)>(&MeshGeometry::setMinVisibility));
						case 103: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(float32_t)>(&MeshGeometry::setMaxVisibility));
						case 104: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(float32_t, float32_t)>(&MeshGeometry::setVisibilityRange));
						case 105: return FunctionPtr(new FunctionImpl<float32_t(MeshGeometry::*)() const>(&MeshGeometry::getMinVisibility));
						case 106: return FunctionPtr(new FunctionImpl<float32_t(MeshGeometry::*)() const>(&MeshGeometry::getMaxVisibility));
						case 107: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::hasVisibilityRange));
						case 108: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)(float32_t)>(&MeshGeometry::setVisibilityError));
						case 109: return FunctionPtr(new FunctionImpl<float32_t(MeshGeometry::*)() const>(&MeshGeometry::getVisibilityError));
						case 110: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(bool, uint32_t)>(&MeshGeometry::createBounds, false, Maxu32));
						case 111: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(bool, uint32_t, uint32_t, uint32_t, bool)>(&MeshGeometry::createBasis, false, Maxu32, Maxu32, Maxu32, false));
						case 112: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(float32_t, bool, uint32_t, uint32_t, uint32_t, bool)>(&MeshGeometry::createBasis, {}, false, Maxu32, Maxu32, Maxu32, false));
						case 113: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(bool, uint32_t, bool)>(&MeshGeometry::createNormals, false, Maxu32, false));
						case 114: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(float32_t, bool, uint32_t, bool)>(&MeshGeometry::createNormals, {}, false, Maxu32, false));
						case 115: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(bool, uint32_t, uint32_t, uint32_t, bool)>(&MeshGeometry::createTangents, false, Maxu32, Maxu32, Maxu32, false));
						case 116: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)(uint32_t, uint32_t, bool, uint32_t, uint32_t, bool)>(&MeshGeometry::createIslands, {}, {}, false, Maxu32, Maxu32, false));
						case 117: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(uint32_t, bool, uint32_t, uint32_t)>(&MeshGeometry::optimizeIndices, 32, false, Maxu32, Maxu32));
						case 118: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(uint32_t)>(&MeshGeometry::optimizeAttributes, Maxu32));
						case 119: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::optimizeMaterials));
						case 120: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(bool)>(&MeshGeometry::packAttributes, true));
						case 121: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)(bool)>(&MeshGeometry::unpackAttributes, true));
						case 122: return FunctionPtr(new FunctionImpl<int32_t(MeshGeometry::*)(const MeshGeometry&, const Matrix4x3f&, float32_t, bool) const>(&MeshGeometry::compare, MeshGeometry::null, Matrix4x3f::identity, 1e-6f, true));
						case 123: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::isOptimized));
						case 124: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::validate));
						case 125: return FunctionPtr(new FunctionImpl<size_t(MeshGeometry::*)() const>(&MeshGeometry::getMemory));
						case 126: return FunctionPtr(new FunctionImpl<MeshGeometry(MeshGeometry::*)() const>(&MeshGeometry::clonePtr));
						case 127: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::clearPtr));
						case 128: return FunctionPtr(new FunctionVoidImpl<void(MeshGeometry::*)()>(&MeshGeometry::destroyPtr));
						case 129: return FunctionPtr(new FunctionImpl<MeshGeometry&(MeshGeometry::*)()>(&MeshGeometry::acquirePtr));
						case 130: return FunctionPtr(new FunctionImpl<MeshGeometry&(MeshGeometry::*)()>(&MeshGeometry::unacquirePtr));
						case 131: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::isValidPtr));
						case 132: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::isOwnerPtr));
						case 133: return FunctionPtr(new FunctionImpl<bool(MeshGeometry::*)() const>(&MeshGeometry::isConstPtr));
						case 134: return FunctionPtr(new FunctionImpl<uint32_t(MeshGeometry::*)() const>(&MeshGeometry::getCountPtr));
						case 135: return FunctionPtr(new FunctionImpl<const void*(MeshGeometry::*)() const>(&MeshGeometry::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 986, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 3269, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 2, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3751, 2556, 2421, 3710, 2502, 2502, 3771, 3772, 2652, 2653, 2652, 2653, 3161, 3458, 1514, 1515, 3424, 3409, 2028, 2567, 2191, 2191, 2190, 2190, 1624, 3460, 1522, 3431, 3452, 2033, 2033, 2955, 2972, 2588, 2426, 2426, 2588, 2426, 2426, 2426, 2426, 1615, 3457, 1511, 1511, 3422, 3449, 3450, 2025, 2025, 2025, 2025, 2942, 2942, 2942, 2942, 2564, 2564, 2098, 2098, 2564, 2109, 2109, 2098, 2098, 1627, 3461, 1527, 1527, 3435, 3453, 2036, 2036, 2036, 2592, 2461, 2461, 2459, 2459, 1629, 3462, 1528, 1528, 3437, 3454, 2037, 2037, 2597, 2487, 2487, 2483, 2483, 3529, 2136, 3531, 2139, 3911, 3911, 2872, 3694, 2460, 3718, 3709, 3944, 2517, 2498, 2978, 3943, 2926, 1906, 1905, 1905, 1925, 1925, 1935, 1921, 3334, 3332, 3335, 3346, 4049, 1657, 3140, 4055, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4039, 4073, 1800, 985, 4039, 4039, 1808, 1808, 1004, 1004, 1585, 4073, 4039, 4039, 1585, 4073, 4039, 4039, 1681, 52, 1808, 1004, 4073, 4073, 4039, 1585, 1585, 4039, 4039, 1585, 1585, 4039, 1810, 1008, 4039, 1683, 53, 1810, 1008, 4073, 4073, 4039, 4039, 1585, 1585, 1585, 4039, 4039, 4039, 4039, 1585, 1585, 1585, 1585, 4039, 4039, 1806, 996, 4039, 1680, 51, 1806, 996, 4073, 4073, 4039, 4039, 1585, 1585, 4039, 4039, 4039, 4039, 1684, 54, 1812, 1011, 4073, 4073, 4039, 4039, 1585, 1585, 4039, 4039, 4039, 1685, 55, 1814, 1013, 4073, 1707, 4073, 1708, 1585, 1585, 1798, 4073, 1798, 4073, 4073, 4073, 2051, 2051, 1585, 4073, 2051, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 1585, 1585, 4073, 1585, 1585, 3003, 1585, 1585, 3961, 1004, 4073, 4073, 1005, 1005, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 3, 3, 3, 5, 7, 7, 7, 7, 7, 7, 8, 10, 12, 13, 13, 14, 14, 14, 14, 15, 16, 16, 17, 19, 20, 22, 23, 24, 25, 25, 26, 27, 28, 28, 28, 28, 29, 30, 30, 31, 33, 36, 37, 39, 41, 44, 46, 48, 49, 52, 54, 56, 57, 58, 59, 61, 63, 63, 63, 63, 64, 65, 65, 66, 68, 71, 72, 74, 75, 76, 77, 77, 77, 77, 78, 79, 79, 80, 82, 85, 86, 88, 89, 90, 90, 90, 90, 91, 92, 93, 93, 94, 94, 95, 97, 97, 98, 98, 99, 100, 102, 102, 102, 102, 103, 103, 105, 110, 116, 119, 123, 128, 134, 138, 139, 139, 140, 141, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145 };
			static constexpr uint16_t function_arg_types[] = { 1877, 986, 1585, 1005, 1585, 1005, 1585, 4039, 1005, 1585, 1005, 1585, 1005, 1809, 4039, 4039, 4039, 1009, 1585, 1009, 1009, 1009, 1811, 1010, 1010, 1010, 1010, 1010, 4039, 4039, 4039, 997, 1585, 997, 1009, 1585, 997, 997, 997, 1811, 1009, 998, 765, 4039, 998, 4039, 1877, 4039, 1807, 998, 765, 4039, 998, 4039, 1877, 4039, 1807, 998, 1811, 998, 4039, 998, 4039, 4039, 4039, 4039, 1012, 1585, 1012, 1019, 1585, 1012, 1012, 1012, 1813, 1818, 1877, 4039, 4039, 4039, 1014, 1585, 1014, 1009, 1585, 1014, 1014, 1014, 1815, 1877, 4039, 4039, 1707, 1708, 1856, 1798, 1585, 1798, 2051, 2051, 2051, 2051, 2051, 1585, 4039, 1585, 4039, 4039, 4039, 1585, 2051, 1585, 4039, 4039, 4039, 1585, 1585, 4039, 1585, 2051, 1585, 4039, 1585, 1585, 4039, 4039, 4039, 1585, 4039, 4039, 1585, 4039, 4039, 1585, 4039, 1585, 4039, 4039, 4039, 1585, 1585, 1809, 1798, 2051, 1585 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3269, 1607, 3348, 1607, 3348, 1607, 3301, 1609, 1607, 1609, 1607, 1609, 1609, 2993, 2993, 3305, 2995, 1607, 2995, 3323, 2995, 2995, 4036, 4036, 4036, 4036, 4036, 2993, 2993, 3298, 1562, 1607, 1562, 2995, 1607, 1562, 3321, 1562, 3323, 2995, 4036, 2066, 2993, 4036, 2993, 3288, 2993, 1562, 4036, 2066, 2993, 4036, 2993, 3288, 2993, 1562, 4036, 2995, 4036, 2993, 4036, 2993, 2993, 2993, 3307, 3227, 1607, 3227, 3290, 1607, 3227, 3324, 3227, 3227, 3290, 3288, 2993, 2993, 3308, 3262, 1607, 3262, 2995, 1607, 3262, 3325, 3262, 3262, 3288, 2993, 2993, 1592, 3974, 3484, 4028, 1553, 3226, 1979, 1979, 3271, 3264, 2010, 2065, 3355, 2065, 3355, 3292, 4003, 1552, 1549, 2065, 3355, 3292, 4003, 1552, 2065, 3355, 1552, 1549, 2065, 3355, 1552, 2065, 3355, 3292, 4010, 1552, 3265, 3266, 2065, 2993, 3355, 1552, 1600, 4030, 2993, 3355, 3262, 3419, 3419, 2077, 4028, 4016, 3973 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 4033, 0, 4033, 0, 4033, 0, 0, 4033, 0, 4033, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 4033, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 2016, 984, 2016, 984, 984, 984, 2016, 0, 2016, 984, 984, 984, 2016, 2016, 984, 2016, 0, 2016, 984, 2016, 2016, 984, 984, 984, 2016, 0, 0, 2016, 984, 984, 2016, 19, 2016, 984, 984, 984, 4033, 4033, 0, 980, 16, 4033 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMeshGeometry::constructor_bases[];
	constexpr uint16_t ReflectionMeshGeometry::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshGeometry::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshGeometry::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshGeometry::function_flags[];
	constexpr uint16_t ReflectionMeshGeometry::function_names[];
	constexpr uint16_t ReflectionMeshGeometry::function_types[];
	constexpr uint16_t ReflectionMeshGeometry::function_bases[];
	constexpr uint16_t ReflectionMeshGeometry::function_arg_types[];
	constexpr uint16_t ReflectionMeshGeometry::function_arg_names[];
	constexpr uint16_t ReflectionMeshGeometry::function_arg_values[];
	constexpr uint16_t ReflectionMeshGeometry::callback_names[];
	constexpr uint16_t ReflectionMeshGeometry::callback_types[];
	constexpr uint16_t ReflectionMeshGeometry::callback_bases[];
	constexpr uint16_t ReflectionMeshGeometry::callback_arg_types[];
	constexpr uint16_t ReflectionMeshGeometry::callback_arg_names[];
	constexpr uint16_t ReflectionMeshGeometry::enum_names[];
	constexpr uint16_t ReflectionMeshGeometry::enum_bases[];
	constexpr uint16_t ReflectionMeshGeometry::enum_var_names[];
	static ReflectionMeshGeometry reflection_mesh_geometry;
	
	// Tellusim::MeshTransform
	class ReflectionMeshTransform : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshTransform::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshTransform, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshTransform>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)()>(&MeshTransform::clear));
						case 1: return FunctionPtr(new FunctionImpl<float64_t(MeshTransform::*)() const>(&MeshTransform::getMinTime));
						case 2: return FunctionPtr(new FunctionImpl<float64_t(MeshTransform::*)() const>(&MeshTransform::getMaxTime));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(float64_t, const Matrix4x3d&, float32_t)>(&MeshTransform::setTransform, {}, {}, 1e-6f));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(float64_t, const Vector3d&, float32_t)>(&MeshTransform::setTranslate, {}, {}, 1e-6f));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(float64_t, const Quaternionf&, float32_t)>(&MeshTransform::setRotate, {}, {}, 1e-6f));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(float64_t, const Vector3f&, float32_t)>(&MeshTransform::setScale, {}, {}, 1e-6f));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(float64_t, const Vector4f&, float32_t)>(&MeshTransform::setMorph, {}, {}, 1e-6f));
						case 8: return FunctionPtr(new FunctionImpl<Matrix4x3d(MeshTransform::*)(float64_t) const>(&MeshTransform::getTransform));
						case 9: return FunctionPtr(new FunctionImpl<Vector3d(MeshTransform::*)(float64_t) const>(&MeshTransform::getTranslate));
						case 10: return FunctionPtr(new FunctionImpl<Quaternionf(MeshTransform::*)(float64_t) const>(&MeshTransform::getRotate));
						case 11: return FunctionPtr(new FunctionImpl<Vector3f(MeshTransform::*)(float64_t) const>(&MeshTransform::getScale));
						case 12: return FunctionPtr(new FunctionImpl<Vector4f(MeshTransform::*)(float64_t) const>(&MeshTransform::getMorph));
						case 13: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::hasTransformKeys));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(const MeshTransform::TranslateKeys&, float64_t)>(&MeshTransform::setTranslateKeys, {}, 1.0));
						case 15: return FunctionPtr(new FunctionImpl<MeshTransform::TranslateKeys(MeshTransform::*)() const>(&MeshTransform::getTranslateKeys));
						case 16: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::hasTranslateKeys));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(const MeshTransform::RotateKeys&)>(&MeshTransform::setRotateKeys));
						case 18: return FunctionPtr(new FunctionImpl<MeshTransform::RotateKeys(MeshTransform::*)() const>(&MeshTransform::getRotateKeys));
						case 19: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::hasRotateKeys));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(const MeshTransform::ScaleKeys&)>(&MeshTransform::setScaleKeys));
						case 21: return FunctionPtr(new FunctionImpl<MeshTransform::ScaleKeys(MeshTransform::*)() const>(&MeshTransform::getScaleKeys));
						case 22: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::hasScaleKeys));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(const MeshTransform::MorphKeys&)>(&MeshTransform::setMorphKeys));
						case 24: return FunctionPtr(new FunctionImpl<MeshTransform::MorphKeys(MeshTransform::*)() const>(&MeshTransform::getMorphKeys));
						case 25: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::hasMorphKeys));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(const Vector3d&)>(&MeshTransform::setTransform));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)(const Matrix4x3d&)>(&MeshTransform::setTransform));
						case 28: return FunctionPtr(new FunctionImpl<size_t(MeshTransform::*)() const>(&MeshTransform::getMemory));
						case 29: return FunctionPtr(new FunctionImpl<MeshTransform(MeshTransform::*)() const>(&MeshTransform::clonePtr));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)()>(&MeshTransform::clearPtr));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(MeshTransform::*)()>(&MeshTransform::destroyPtr));
						case 32: return FunctionPtr(new FunctionImpl<MeshTransform&(MeshTransform::*)()>(&MeshTransform::acquirePtr));
						case 33: return FunctionPtr(new FunctionImpl<MeshTransform&(MeshTransform::*)()>(&MeshTransform::unacquirePtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::isValidPtr));
						case 35: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::isOwnerPtr));
						case 36: return FunctionPtr(new FunctionImpl<bool(MeshTransform::*)() const>(&MeshTransform::isConstPtr));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(MeshTransform::*)() const>(&MeshTransform::getCountPtr));
						case 38: return FunctionPtr(new FunctionImpl<const void*(MeshTransform::*)() const>(&MeshTransform::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 2515, 2497, 3911, 3912, 3806, 3817, 3726, 2872, 2875, 2717, 2730, 2532, 2976, 3913, 2876, 2977, 3807, 2718, 2969, 3818, 2731, 2970, 3727, 2533, 2959, 3911, 3911, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 2054, 2054, 4073, 4073, 4073, 4073, 4073, 977, 1419, 1166, 1420, 1423, 1585, 4073, 1029, 1585, 4073, 1027, 1585, 4073, 1028, 1585, 4073, 1026, 1585, 4073, 4073, 3961, 1024, 4073, 4073, 1025, 1025, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 3, 6, 9, 12, 15, 16, 17, 18, 19, 20, 20, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27 };
			static constexpr uint16_t function_arg_types[] = { 2054, 1797, 2051, 2054, 1855, 2051, 2054, 1828, 2051, 2054, 1856, 2051, 2054, 1858, 2051, 2054, 2054, 2054, 2054, 2054, 1823, 2054, 1821, 1822, 1820, 1855, 1797 };
			static constexpr uint16_t function_arg_names[] = { 4017, 4028, 4016, 4017, 4029, 4016, 4017, 3472, 4016, 4017, 3484, 4016, 4017, 3281, 4016, 4017, 4017, 4017, 4017, 4017, 3232, 3484, 3232, 3232, 3232, 3484, 4028 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 16, 0, 0, 16, 0, 0, 16, 0, 0, 16, 0, 0, 16, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMeshTransform::constructor_bases[];
	constexpr uint16_t ReflectionMeshTransform::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshTransform::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshTransform::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshTransform::function_flags[];
	constexpr uint16_t ReflectionMeshTransform::function_names[];
	constexpr uint16_t ReflectionMeshTransform::function_types[];
	constexpr uint16_t ReflectionMeshTransform::function_bases[];
	constexpr uint16_t ReflectionMeshTransform::function_arg_types[];
	constexpr uint16_t ReflectionMeshTransform::function_arg_names[];
	constexpr uint16_t ReflectionMeshTransform::function_arg_values[];
	constexpr uint16_t ReflectionMeshTransform::callback_names[];
	constexpr uint16_t ReflectionMeshTransform::callback_types[];
	constexpr uint16_t ReflectionMeshTransform::callback_bases[];
	constexpr uint16_t ReflectionMeshTransform::callback_arg_types[];
	constexpr uint16_t ReflectionMeshTransform::callback_arg_names[];
	constexpr uint16_t ReflectionMeshTransform::enum_names[];
	constexpr uint16_t ReflectionMeshTransform::enum_bases[];
	constexpr uint16_t ReflectionMeshTransform::enum_var_names[];
	static ReflectionMeshTransform reflection_mesh_transform;
	
	// Tellusim::MeshAnimation
	class ReflectionMeshAnimation : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshAnimation::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshAnimation, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshAnimation, TypeList<Mesh&, const char*>>(Mesh::null, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshAnimation>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)()>(&MeshAnimation::clear));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(MeshAnimation::*)() const>(&MeshAnimation::getIndex));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(const char*)>(&MeshAnimation::setName));
						case 3: return FunctionPtr(new FunctionImpl<String(MeshAnimation::*)() const>(&MeshAnimation::getName));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(Mesh&, bool)>(&MeshAnimation::setMesh, Mesh::null, true));
						case 5: return FunctionPtr(new FunctionImpl<const Mesh(MeshAnimation::*)() const>(&MeshAnimation::getMesh));
						case 6: return FunctionPtr(new FunctionImpl<Mesh(MeshAnimation::*)()>(&MeshAnimation::getMesh));
						case 7: return FunctionPtr(new FunctionImpl<float64_t(MeshAnimation::*)() const>(&MeshAnimation::getMinTime));
						case 8: return FunctionPtr(new FunctionImpl<float64_t(MeshAnimation::*)() const>(&MeshAnimation::getMaxTime));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(uint32_t)>(&MeshAnimation::setNumTransforms));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(MeshAnimation::*)() const>(&MeshAnimation::getNumTransforms));
						case 11: return FunctionPtr(new FunctionImpl<const Array<MeshTransform>(MeshAnimation::*)() const>(&MeshAnimation::getTransforms));
						case 12: return FunctionPtr(new FunctionImpl<Array<MeshTransform>(MeshAnimation::*)()>(&MeshAnimation::getTransforms));
						case 13: return FunctionPtr(new FunctionImpl<const MeshTransform(MeshAnimation::*)(uint32_t) const>(&MeshAnimation::getTransform));
						case 14: return FunctionPtr(new FunctionImpl<MeshTransform(MeshAnimation::*)(uint32_t)>(&MeshAnimation::getTransform));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, uint32_t, const Matrix4x3d&, float32_t)>(&MeshAnimation::setTransform, {}, {}, {}, 1e-6f));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, uint32_t, const Vector3d&, float32_t)>(&MeshAnimation::setTranslate, {}, {}, {}, 1e-6f));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, uint32_t, const Quaternionf&, float32_t)>(&MeshAnimation::setRotate, {}, {}, {}, 1e-6f));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, uint32_t, const Vector3f&, float32_t)>(&MeshAnimation::setScale, {}, {}, {}, 1e-6f));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, uint32_t, const Vector4f&, float32_t)>(&MeshAnimation::setMorph, {}, {}, {}, 1e-6f));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, const Matrix4x3d&, bool, float64_t, float64_t)>(&MeshAnimation::setTime, {}, Matrix4x3d::identity, true, -Maxf32, Maxf32));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float64_t, bool, float64_t, float64_t)>(&MeshAnimation::setTime, {}, {}, -Maxf32, Maxf32));
						case 22: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshAnimation::*)(uint32_t) const>(&MeshAnimation::getLocalTransform));
						case 23: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshAnimation::*)(const MeshNode&) const>(&MeshAnimation::getLocalTransform));
						case 24: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshAnimation::*)(const MeshJoint&) const>(&MeshAnimation::getLocalTransform));
						case 25: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshAnimation::*)(uint32_t) const>(&MeshAnimation::getGlobalTransform));
						case 26: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshAnimation::*)(const MeshNode&) const>(&MeshAnimation::getGlobalTransform));
						case 27: return FunctionPtr(new FunctionImpl<const Matrix4x3d&(MeshAnimation::*)(const MeshJoint&) const>(&MeshAnimation::getGlobalTransform));
						case 28: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshAnimation::*)(uint32_t) const>(&MeshAnimation::getMorphTransform));
						case 29: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshAnimation::*)(const MeshNode&) const>(&MeshAnimation::getMorphTransform));
						case 30: return FunctionPtr(new FunctionImpl<BoundBoxd(MeshAnimation::*)() const>(&MeshAnimation::getBoundBox));
						case 31: return FunctionPtr(new FunctionImpl<BoundBoxd(MeshAnimation::*)(const MeshNode&) const>(&MeshAnimation::getBoundBox));
						case 32: return FunctionPtr(new FunctionImpl<BoundBoxd(MeshAnimation::*)(const MeshGeometry&) const>(&MeshAnimation::getBoundBox));
						case 33: return FunctionPtr(new FunctionImpl<BoundBoxd(MeshAnimation::*)(const MeshGeometry&, const Vector4f&) const>(&MeshAnimation::getBoundBox));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(const Vector3d&)>(&MeshAnimation::setTransform));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(const Matrix4x3d&)>(&MeshAnimation::setTransform));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)(float32_t)>(&MeshAnimation::optimizeTransforms, 1e-6f));
						case 37: return FunctionPtr(new FunctionImpl<size_t(MeshAnimation::*)() const>(&MeshAnimation::getMemory));
						case 38: return FunctionPtr(new FunctionImpl<MeshAnimation(MeshAnimation::*)() const>(&MeshAnimation::clonePtr));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)()>(&MeshAnimation::clearPtr));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(MeshAnimation::*)()>(&MeshAnimation::destroyPtr));
						case 41: return FunctionPtr(new FunctionImpl<MeshAnimation&(MeshAnimation::*)()>(&MeshAnimation::acquirePtr));
						case 42: return FunctionPtr(new FunctionImpl<MeshAnimation&(MeshAnimation::*)()>(&MeshAnimation::unacquirePtr));
						case 43: return FunctionPtr(new FunctionImpl<bool(MeshAnimation::*)() const>(&MeshAnimation::isValidPtr));
						case 44: return FunctionPtr(new FunctionImpl<bool(MeshAnimation::*)() const>(&MeshAnimation::isOwnerPtr));
						case 45: return FunctionPtr(new FunctionImpl<bool(MeshAnimation::*)() const>(&MeshAnimation::isConstPtr));
						case 46: return FunctionPtr(new FunctionImpl<uint32_t(MeshAnimation::*)() const>(&MeshAnimation::getCountPtr));
						case 47: return FunctionPtr(new FunctionImpl<const void*(MeshAnimation::*)() const>(&MeshAnimation::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 986, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 3269, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 2421, 3751, 2556, 3710, 2502, 2502, 2515, 2497, 3759, 2620, 2874, 2874, 2872, 2872, 3911, 3912, 3806, 3817, 3726, 3902, 3902, 2470, 2470, 2470, 2396, 2396, 2396, 2534, 2534, 2136, 2136, 2136, 2136, 3911, 3911, 3337, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4073, 1274, 4073, 1800, 985, 2054, 2054, 4073, 4039, 1687, 57, 1819, 1024, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1797, 1797, 1797, 1797, 1797, 1797, 1858, 1858, 149, 149, 149, 149, 4073, 4073, 4073, 3961, 990, 4073, 4073, 991, 991, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 1, 1, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 10, 14, 18, 22, 26, 31, 35, 36, 37, 38, 39, 40, 41, 42, 43, 43, 44, 45, 47, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50 };
			static constexpr uint16_t function_arg_types[] = { 1877, 986, 1585, 4039, 4039, 4039, 2054, 4039, 1797, 2051, 2054, 4039, 1855, 2051, 2054, 4039, 1828, 2051, 2054, 4039, 1856, 2051, 2054, 4039, 1858, 2051, 2054, 1797, 1585, 2054, 2054, 2054, 1585, 2054, 2054, 4039, 1818, 1813, 4039, 1818, 1813, 4039, 1818, 1818, 1809, 1809, 1858, 1855, 1797, 2051 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3269, 1607, 3314, 3290, 3290, 4017, 3290, 4028, 4016, 4017, 3290, 4029, 4016, 4017, 3290, 3472, 4016, 4017, 3290, 3484, 4016, 4017, 3290, 3281, 4016, 4017, 4028, 3251, 2071, 4020, 4017, 3251, 2071, 4020, 3290, 3290, 3227, 3290, 3290, 3227, 3290, 3290, 3290, 2077, 2077, 3281, 3484, 4028, 4016 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 4033, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 16, 0, 978, 4033, 2, 983, 0, 0, 2, 983, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMeshAnimation::constructor_bases[];
	constexpr uint16_t ReflectionMeshAnimation::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshAnimation::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshAnimation::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshAnimation::function_flags[];
	constexpr uint16_t ReflectionMeshAnimation::function_names[];
	constexpr uint16_t ReflectionMeshAnimation::function_types[];
	constexpr uint16_t ReflectionMeshAnimation::function_bases[];
	constexpr uint16_t ReflectionMeshAnimation::function_arg_types[];
	constexpr uint16_t ReflectionMeshAnimation::function_arg_names[];
	constexpr uint16_t ReflectionMeshAnimation::function_arg_values[];
	constexpr uint16_t ReflectionMeshAnimation::callback_names[];
	constexpr uint16_t ReflectionMeshAnimation::callback_types[];
	constexpr uint16_t ReflectionMeshAnimation::callback_bases[];
	constexpr uint16_t ReflectionMeshAnimation::callback_arg_types[];
	constexpr uint16_t ReflectionMeshAnimation::callback_arg_names[];
	constexpr uint16_t ReflectionMeshAnimation::enum_names[];
	constexpr uint16_t ReflectionMeshAnimation::enum_bases[];
	constexpr uint16_t ReflectionMeshAnimation::enum_var_names[];
	static ReflectionMeshAnimation reflection_mesh_animation;
	
	// Tellusim::MeshAttachment
	class ReflectionMeshAttachment : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshAttachment::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshAttachment, TypeList<const char*>>(nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<MeshAttachment, TypeList<MeshAttachment::Type, const char*>>((MeshAttachment::Type)0, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<MeshAttachment, TypeList<MeshNode&, const char*>>(MeshNode::null, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshAttachment>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)()>(&MeshAttachment::clear));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(MeshAttachment::Type)>(&MeshAttachment::setType));
						case 2: return FunctionPtr(new FunctionImpl<MeshAttachment::Type(MeshAttachment::*)() const>(&MeshAttachment::getType));
						case 3: return FunctionPtr(new FunctionImpl<const char*(MeshAttachment::Type)>(&MeshAttachment::getTypeName));
						case 4: return FunctionPtr(new FunctionImpl<const char*(MeshAttachment::*)() const>(&MeshAttachment::getTypeName));
						case 5: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)() const>(&MeshAttachment::isUnknown));
						case 6: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)() const>(&MeshAttachment::isLight));
						case 7: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)() const>(&MeshAttachment::isCamera));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*)>(&MeshAttachment::setName));
						case 9: return FunctionPtr(new FunctionImpl<String(MeshAttachment::*)() const>(&MeshAttachment::getName));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(MeshNode&, bool)>(&MeshAttachment::setNode, MeshNode::null, true));
						case 11: return FunctionPtr(new FunctionImpl<const MeshNode(MeshAttachment::*)() const>(&MeshAttachment::getNode));
						case 12: return FunctionPtr(new FunctionImpl<MeshNode(MeshAttachment::*)()>(&MeshAttachment::getNode));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*)>(&MeshAttachment::setData));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const String&)>(&MeshAttachment::setData));
						case 15: return FunctionPtr(new FunctionImpl<String(MeshAttachment::*)() const>(&MeshAttachment::getData));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)()>(&MeshAttachment::clearParameters));
						case 17: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(const char*)>(&MeshAttachment::removeParameter));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const MeshAttachment&)>(&MeshAttachment::copyParameters));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttachment::*)(const char*) const>(&MeshAttachment::findParameter));
						case 20: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(const char*) const>(&MeshAttachment::hasParameter));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttachment::*)() const>(&MeshAttachment::getNumParameters));
						case 22: return FunctionPtr(new FunctionImpl<String(MeshAttachment::*)(uint32_t) const>(&MeshAttachment::getParameterType));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*, bool)>(&MeshAttachment::addParameter));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*, float32_t)>(&MeshAttachment::addParameter));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*, const Vector4f&)>(&MeshAttachment::addParameter));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*, const Color&)>(&MeshAttachment::addParameter));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*, const char*)>(&MeshAttachment::addParameter));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const char*, const String&)>(&MeshAttachment::addParameter));
						case 29: return FunctionPtr(new FunctionImpl<MeshAttachment::Flags(MeshAttachment::*)(uint32_t) const>(&MeshAttachment::getParameterFlags));
						case 30: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(uint32_t, MeshAttachment::Flags) const>(&MeshAttachment::hasParameterFlag));
						case 31: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(uint32_t, MeshAttachment::Flags) const>(&MeshAttachment::hasParameterFlags));
						case 32: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(uint32_t, bool) const>(&MeshAttachment::getParameterBool, {}, false));
						case 33: return FunctionPtr(new FunctionImpl<float32_t(MeshAttachment::*)(uint32_t, float32_t) const>(&MeshAttachment::getParameterScalarf32, {}, 0.0f));
						case 34: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshAttachment::*)(uint32_t, const Vector4f&) const>(&MeshAttachment::getParameterVector4f, {}, Vector4f::zero));
						case 35: return FunctionPtr(new FunctionImpl<const Color&(MeshAttachment::*)(uint32_t, const Color&) const>(&MeshAttachment::getParameterColor, {}, Color::white));
						case 36: return FunctionPtr(new FunctionImpl<String(MeshAttachment::*)(uint32_t, const String&) const>(&MeshAttachment::getParameterName, {}, String::null));
						case 37: return FunctionPtr(new FunctionImpl<MeshAttachment::Flags(MeshAttachment::*)(const char*) const>(&MeshAttachment::getParameterFlags));
						case 38: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(const char*, MeshAttachment::Flags) const>(&MeshAttachment::hasParameterFlag));
						case 39: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(const char*, MeshAttachment::Flags) const>(&MeshAttachment::hasParameterFlags));
						case 40: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)(const char*, bool) const>(&MeshAttachment::getParameterBool, {}, false));
						case 41: return FunctionPtr(new FunctionImpl<float32_t(MeshAttachment::*)(const char*, float32_t) const>(&MeshAttachment::getParameterScalarf32, {}, 0.0f));
						case 42: return FunctionPtr(new FunctionImpl<const Vector4f&(MeshAttachment::*)(const char*, const Vector4f&) const>(&MeshAttachment::getParameterVector4f, {}, Vector4f::zero));
						case 43: return FunctionPtr(new FunctionImpl<const Color&(MeshAttachment::*)(const char*, const Color&) const>(&MeshAttachment::getParameterColor, {}, Color::white));
						case 44: return FunctionPtr(new FunctionImpl<String(MeshAttachment::*)(const char*, const String&) const>(&MeshAttachment::getParameterName, {}, String::null));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const Vector3f&)>(&MeshAttachment::setTransform));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)(const Matrix4x3f&)>(&MeshAttachment::setTransform));
						case 47: return FunctionPtr(new FunctionImpl<const Matrix4x3f&(MeshAttachment::*)() const>(&MeshAttachment::getTransform));
						case 48: return FunctionPtr(new FunctionImpl<int32_t(MeshAttachment::*)(const MeshAttachment&) const>(&MeshAttachment::compare));
						case 49: return FunctionPtr(new FunctionImpl<size_t(MeshAttachment::*)() const>(&MeshAttachment::getMemory));
						case 50: return FunctionPtr(new FunctionImpl<MeshAttachment(MeshAttachment::*)() const>(&MeshAttachment::clonePtr));
						case 51: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)()>(&MeshAttachment::clearPtr));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(MeshAttachment::*)()>(&MeshAttachment::destroyPtr));
						case 53: return FunctionPtr(new FunctionImpl<MeshAttachment&(MeshAttachment::*)()>(&MeshAttachment::acquirePtr));
						case 54: return FunctionPtr(new FunctionImpl<MeshAttachment&(MeshAttachment::*)()>(&MeshAttachment::unacquirePtr));
						case 55: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)() const>(&MeshAttachment::isValidPtr));
						case 56: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)() const>(&MeshAttachment::isOwnerPtr));
						case 57: return FunctionPtr(new FunctionImpl<bool(MeshAttachment::*)() const>(&MeshAttachment::isConstPtr));
						case 58: return FunctionPtr(new FunctionImpl<uint32_t(MeshAttachment::*)() const>(&MeshAttachment::getCountPtr));
						case 59: return FunctionPtr(new FunctionImpl<const void*(MeshAttachment::*)() const>(&MeshAttachment::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 1, 3, 5 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 995, 1877, 1019, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 4036, 3288, 3290, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 0, 3294, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 1, 2, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3915, 2878, 2879, 2879, 3198, 3114, 3040, 3751, 2556, 3753, 2558, 2558, 3590, 3590, 2260, 1635, 3439, 1894, 2041, 2963, 2601, 2649, 1530, 1530, 1530, 1530, 1530, 1530, 2643, 2964, 2965, 2641, 2648, 2650, 2642, 2647, 2643, 2964, 2965, 2641, 2648, 2650, 2642, 2647, 3911, 3911, 2872, 1657, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 995, 1877, 1877, 1585, 1585, 1585, 4073, 1274, 4073, 1817, 1018, 4073, 4073, 1274, 4073, 1585, 4073, 4039, 1585, 4039, 1274, 4073, 4073, 4073, 4073, 4073, 4073, 994, 1585, 1585, 1585, 2051, 1858, 1721, 1274, 994, 1585, 1585, 1585, 2051, 1858, 1721, 1274, 4073, 4073, 1798, 3003, 3961, 992, 4073, 4073, 993, 993, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 2, 2, 2, 2, 2, 3, 3, 5, 5, 5, 6, 7, 7, 7, 8, 9, 10, 11, 11, 12, 14, 16, 18, 20, 22, 24, 25, 27, 29, 31, 33, 35, 37, 39, 40, 42, 44, 46, 48, 50, 52, 54, 55, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57 };
			static constexpr uint16_t function_arg_types[] = { 995, 995, 1877, 1019, 1585, 1877, 1841, 1877, 1805, 1877, 1877, 4039, 1877, 1585, 1877, 2051, 1877, 1858, 1877, 1721, 1877, 1877, 1877, 1841, 4039, 4039, 994, 4039, 994, 4039, 1585, 4039, 2051, 4039, 1858, 4039, 1721, 4039, 1841, 1877, 1877, 994, 1877, 994, 1877, 1585, 1877, 2051, 1877, 1858, 1877, 1721, 1877, 1841, 1856, 1798, 1805 };
			static constexpr uint16_t function_arg_names[] = { 4036, 4036, 3288, 3290, 1607, 1948, 1948, 4036, 1561, 4036, 4036, 2993, 4036, 4056, 4036, 4056, 4036, 4062, 4036, 1650, 4036, 3288, 4036, 3288, 2993, 2993, 2045, 2993, 2045, 2993, 4056, 2993, 4056, 2993, 4062, 2993, 1650, 2993, 3288, 4036, 4036, 2045, 4036, 2045, 4036, 4056, 4036, 4056, 4036, 4062, 4036, 1650, 4036, 3288, 3484, 4028, 1561 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 4, 0, 1424, 0, 252, 0, 1277, 0, 0, 0, 0, 0, 0, 2016, 0, 4, 0, 1424, 0, 252, 0, 1277, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 8, 14 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1352, 1354, 1355, 1353, 1323, 1322, 1117, 678, 596, 708, 737, 609, 674 };
	};
	constexpr uint16_t ReflectionMeshAttachment::constructor_bases[];
	constexpr uint16_t ReflectionMeshAttachment::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshAttachment::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshAttachment::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshAttachment::function_flags[];
	constexpr uint16_t ReflectionMeshAttachment::function_names[];
	constexpr uint16_t ReflectionMeshAttachment::function_types[];
	constexpr uint16_t ReflectionMeshAttachment::function_bases[];
	constexpr uint16_t ReflectionMeshAttachment::function_arg_types[];
	constexpr uint16_t ReflectionMeshAttachment::function_arg_names[];
	constexpr uint16_t ReflectionMeshAttachment::function_arg_values[];
	constexpr uint16_t ReflectionMeshAttachment::callback_names[];
	constexpr uint16_t ReflectionMeshAttachment::callback_types[];
	constexpr uint16_t ReflectionMeshAttachment::callback_bases[];
	constexpr uint16_t ReflectionMeshAttachment::callback_arg_types[];
	constexpr uint16_t ReflectionMeshAttachment::callback_arg_names[];
	constexpr uint16_t ReflectionMeshAttachment::enum_names[];
	constexpr uint16_t ReflectionMeshAttachment::enum_bases[];
	constexpr uint16_t ReflectionMeshAttachment::enum_var_names[];
	static ReflectionMeshAttachment reflection_mesh_attachment;
	
	// Tellusim::Mesh
	class ReflectionMesh : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Mesh::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Mesh, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Mesh>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(Mesh::*)() const>(&Mesh::isLoaded));
						case 2: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const char*, Mesh::Flags, Async*)>(&Mesh::info, {}, Mesh::FlagNone, nullptr));
						case 3: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const String&, Mesh::Flags, Async*)>(&Mesh::info, {}, Mesh::FlagNone, nullptr));
						case 4: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Stream&, Mesh::Flags, Async*)>(&Mesh::info, Stream::null, Mesh::FlagNone, nullptr));
						case 5: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const char*, Async*)>(&Mesh::info));
						case 6: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const String&, Async*)>(&Mesh::info));
						case 7: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Stream&, Async*)>(&Mesh::info));
						case 8: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const char*, Mesh::Flags, Async*)>(&Mesh::load, {}, Mesh::FlagNone, nullptr));
						case 9: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const String&, Mesh::Flags, Async*)>(&Mesh::load, {}, Mesh::FlagNone, nullptr));
						case 10: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Stream&, Mesh::Flags, Async*)>(&Mesh::load, Stream::null, Mesh::FlagNone, nullptr));
						case 11: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const char*, Async*)>(&Mesh::load));
						case 12: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const String&, Async*)>(&Mesh::load));
						case 13: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Stream&, Async*)>(&Mesh::load));
						case 14: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const char*, Mesh::Flags) const>(&Mesh::save, {}, Mesh::FlagNone));
						case 15: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const String&, Mesh::Flags) const>(&Mesh::save, {}, Mesh::FlagNone));
						case 16: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Stream&, Mesh::Flags) const>(&Mesh::save, Stream::null, Mesh::FlagNone));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(const char*)>(&Mesh::setName));
						case 18: return FunctionPtr(new FunctionImpl<String(Mesh::*)() const>(&Mesh::getName));
						case 19: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Mesh::Axis, Mesh::Axis, Mesh::Axis)>(&Mesh::setBasis));
						case 20: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Mesh::Basis)>(&Mesh::setBasis));
						case 21: return FunctionPtr(new FunctionImpl<Mesh::Axis(Mesh::*)() const>(&Mesh::getFrontAxis));
						case 22: return FunctionPtr(new FunctionImpl<Mesh::Axis(Mesh::*)() const>(&Mesh::getRightAxis));
						case 23: return FunctionPtr(new FunctionImpl<Mesh::Axis(Mesh::*)() const>(&Mesh::getUpAxis));
						case 24: return FunctionPtr(new FunctionImpl<Mesh::Basis(Mesh::*)() const>(&Mesh::getBasis));
						case 25: return FunctionPtr(new FunctionImpl<const char*(Mesh::*)() const>(&Mesh::getFrontAxisName));
						case 26: return FunctionPtr(new FunctionImpl<const char*(Mesh::*)() const>(&Mesh::getRightAxisName));
						case 27: return FunctionPtr(new FunctionImpl<const char*(Mesh::*)() const>(&Mesh::getUpAxisName));
						case 28: return FunctionPtr(new FunctionImpl<String(Mesh::*)() const>(&Mesh::getBasisName));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::clearNodes));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(uint32_t)>(&Mesh::reserveNodes));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(MeshNode&, bool)>(&Mesh::addNode, MeshNode::null, true));
						case 32: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshNode&)>(&Mesh::removeNode));
						case 33: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(const MeshNode&) const>(&Mesh::findNode));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(const char*) const>(&Mesh::findNode));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)() const>(&Mesh::getNumNodes));
						case 36: return FunctionPtr(new FunctionImpl<const Array<MeshNode>(Mesh::*)() const>(&Mesh::getNodes));
						case 37: return FunctionPtr(new FunctionImpl<Array<MeshNode>(Mesh::*)()>(&Mesh::getNodes));
						case 38: return FunctionPtr(new FunctionImpl<const MeshNode(Mesh::*)(uint32_t) const>(&Mesh::getNode));
						case 39: return FunctionPtr(new FunctionImpl<MeshNode(Mesh::*)(uint32_t)>(&Mesh::getNode));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(const Matrix4x3d&)>(&Mesh::createLocalTransforms, Matrix4x3d::identity));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(const Matrix4x3d&)>(&Mesh::createGlobalTransforms, Matrix4x3d::identity));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::clearGeometries));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(uint32_t)>(&Mesh::reserveGeometries));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(MeshGeometry&, bool)>(&Mesh::addGeometry, MeshGeometry::null, true));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(MeshGeometry&, MeshNode&, bool)>(&Mesh::addGeometry, MeshGeometry::null, MeshNode::null, true));
						case 46: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshGeometry&)>(&Mesh::removeGeometry));
						case 47: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshGeometry&, MeshGeometry&)>(&Mesh::replaceGeometry));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(const MeshGeometry&) const>(&Mesh::findGeometry));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(const char*) const>(&Mesh::findGeometry));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)() const>(&Mesh::getNumGeometries));
						case 51: return FunctionPtr(new FunctionImpl<const Array<MeshGeometry>(Mesh::*)() const>(&Mesh::getGeometries));
						case 52: return FunctionPtr(new FunctionImpl<Array<MeshGeometry>(Mesh::*)()>(&Mesh::getGeometries));
						case 53: return FunctionPtr(new FunctionImpl<const MeshGeometry(Mesh::*)(uint32_t) const>(&Mesh::getGeometry));
						case 54: return FunctionPtr(new FunctionImpl<MeshGeometry(Mesh::*)(uint32_t)>(&Mesh::getGeometry));
						case 55: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshIndices::Type) const>(&Mesh::hasGeometryIndices));
						case 56: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshAttribute::Type) const>(&Mesh::hasGeometryAttribute));
						case 57: return FunctionPtr(new FunctionImpl<size_t(Mesh::*)() const>(&Mesh::getNumGeometryPositions));
						case 58: return FunctionPtr(new FunctionImpl<size_t(Mesh::*)() const>(&Mesh::getNumGeometryPrimitives));
						case 59: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::clearAnimations));
						case 60: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(uint32_t)>(&Mesh::reserveAnimations));
						case 61: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(MeshAnimation&, bool)>(&Mesh::addAnimation, MeshAnimation::null, true));
						case 62: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshAnimation&)>(&Mesh::removeAnimation));
						case 63: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(MeshAnimation&, MeshAnimation&)>(&Mesh::replaceAnimation));
						case 64: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(const MeshAnimation&) const>(&Mesh::findAnimation));
						case 65: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)(const char*) const>(&Mesh::findAnimation));
						case 66: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)() const>(&Mesh::getNumAnimations));
						case 67: return FunctionPtr(new FunctionImpl<const Array<MeshAnimation>(Mesh::*)() const>(&Mesh::getAnimations));
						case 68: return FunctionPtr(new FunctionImpl<Array<MeshAnimation>(Mesh::*)()>(&Mesh::getAnimations));
						case 69: return FunctionPtr(new FunctionImpl<const MeshAnimation(Mesh::*)(uint32_t) const>(&Mesh::getAnimation));
						case 70: return FunctionPtr(new FunctionImpl<MeshAnimation(Mesh::*)(uint32_t)>(&Mesh::getAnimation));
						case 71: return FunctionPtr(new FunctionImpl<BoundBoxd(Mesh::*)() const>(&Mesh::getBoundBox));
						case 72: return FunctionPtr(new FunctionImpl<BoundBoxd(Mesh::*)(const MeshNode&) const>(&Mesh::getBoundBox));
						case 73: return FunctionPtr(new FunctionImpl<BoundBoxd(Mesh::*)(const MeshGeometry&) const>(&Mesh::getBoundBox));
						case 74: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool, Async*)>(&Mesh::createBounds, {}, nullptr));
						case 75: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Async*)>(&Mesh::createBounds, nullptr));
						case 76: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool, Async*)>(&Mesh::createBasis, {}, nullptr));
						case 77: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(float32_t, bool, Async*)>(&Mesh::createBasis, {}, {}, nullptr));
						case 78: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Async*)>(&Mesh::createBasis, nullptr));
						case 79: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(float32_t, Async*)>(&Mesh::createBasis, {}, nullptr));
						case 80: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool, Async*)>(&Mesh::createNormals, {}, nullptr));
						case 81: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(float32_t, bool, Async*)>(&Mesh::createNormals, {}, {}, nullptr));
						case 82: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Async*)>(&Mesh::createNormals, nullptr));
						case 83: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(float32_t, Async*)>(&Mesh::createNormals, {}, nullptr));
						case 84: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool, Async*)>(&Mesh::createTangents, {}, nullptr));
						case 85: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Async*)>(&Mesh::createTangents, nullptr));
						case 86: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(uint32_t, uint32_t, bool, Async*)>(&Mesh::createIslands, {}, {}, {}, nullptr));
						case 87: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(uint32_t, uint32_t, Async*)>(&Mesh::createIslands, {}, {}, nullptr));
						case 88: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(uint32_t, bool, Async*)>(&Mesh::optimizeIndices, {}, {}, nullptr));
						case 89: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Async*)>(&Mesh::optimizeIndices, nullptr));
						case 90: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(uint32_t, Async*)>(&Mesh::optimizeIndices, {}, nullptr));
						case 91: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(Async*)>(&Mesh::optimizeAttributes, nullptr));
						case 92: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::optimizeMaterials));
						case 93: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool)>(&Mesh::optimizeWinding, false));
						case 94: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(float32_t, uint32_t)>(&Mesh::optimizeGeometries, 1e-3f, 16));
						case 95: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)(float32_t)>(&Mesh::optimizeAnimations, 1e-6f));
						case 96: return FunctionPtr(new FunctionImpl<bool(Mesh::*)()>(&Mesh::optimizeOrder));
						case 97: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::mergeGeometries));
						case 98: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool)>(&Mesh::packAttributes, true));
						case 99: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(bool)>(&Mesh::unpackAttributes, true));
						case 100: return FunctionPtr(new FunctionImpl<bool(Mesh::*)(const Vector3d&)>(&Mesh::setTransform));
						case 101: return FunctionPtr(new FunctionImpl<size_t(Mesh::*)() const>(&Mesh::getMemory));
						case 102: return FunctionPtr(new FunctionImpl<Mesh(Mesh::*)() const>(&Mesh::clonePtr));
						case 103: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::clearPtr));
						case 104: return FunctionPtr(new FunctionVoidImpl<void(Mesh::*)()>(&Mesh::destroyPtr));
						case 105: return FunctionPtr(new FunctionImpl<Mesh&(Mesh::*)()>(&Mesh::acquirePtr));
						case 106: return FunctionPtr(new FunctionImpl<Mesh&(Mesh::*)()>(&Mesh::unacquirePtr));
						case 107: return FunctionPtr(new FunctionImpl<bool(Mesh::*)() const>(&Mesh::isValidPtr));
						case 108: return FunctionPtr(new FunctionImpl<bool(Mesh::*)() const>(&Mesh::isOwnerPtr));
						case 109: return FunctionPtr(new FunctionImpl<bool(Mesh::*)() const>(&Mesh::isConstPtr));
						case 110: return FunctionPtr(new FunctionImpl<uint32_t(Mesh::*)() const>(&Mesh::getCountPtr));
						case 111: return FunctionPtr(new FunctionImpl<const void*(Mesh::*)() const>(&Mesh::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3116, 2996, 2996, 2996, 2996, 2996, 2996, 3242, 3242, 3242, 3242, 3242, 3242, 3480, 3480, 3480, 3751, 2556, 3521, 3521, 2364, 2713, 2887, 2116, 2365, 2714, 2888, 2117, 1634, 3463, 1529, 3438, 2040, 2040, 2600, 2560, 2560, 2558, 2558, 1923, 1920, 1622, 3459, 1519, 1519, 3429, 3451, 2032, 2032, 2582, 2389, 2389, 2390, 2390, 2954, 2953, 2585, 2586, 1613, 3455, 1509, 3420, 3447, 2023, 2023, 2561, 2090, 2090, 2089, 2089, 2136, 2136, 2136, 1906, 1906, 1905, 1905, 1905, 1905, 1925, 1925, 1925, 1925, 1935, 1935, 1921, 1921, 3334, 3334, 3334, 3332, 3335, 3338, 3333, 3330, 3336, 3268, 3346, 4049, 3911, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1274, 1585, 1585, 987, 987, 987, 988, 1877, 1877, 1877, 1274, 4073, 4073, 4039, 1585, 4039, 4039, 4039, 1686, 56, 1817, 1018, 4073, 4073, 4073, 4073, 4039, 4039, 1585, 1585, 4039, 4039, 4039, 1681, 52, 1808, 1004, 1585, 1585, 3961, 3961, 4073, 4073, 4039, 1585, 1585, 4039, 4039, 4039, 1678, 49, 1802, 990, 149, 149, 149, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1585, 4073, 4073, 1585, 4073, 1585, 1585, 1585, 3961, 985, 4073, 4073, 986, 986, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 3, 6, 9, 11, 13, 15, 18, 21, 24, 26, 28, 30, 32, 34, 36, 37, 37, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 44, 45, 46, 47, 47, 47, 47, 48, 49, 50, 51, 51, 52, 54, 57, 58, 60, 61, 62, 62, 62, 62, 63, 64, 65, 66, 66, 66, 66, 67, 69, 70, 72, 73, 74, 74, 74, 74, 75, 76, 76, 77, 78, 80, 81, 83, 86, 87, 89, 91, 94, 95, 97, 99, 100, 104, 107, 110, 111, 113, 114, 114, 115, 117, 118, 118, 118, 119, 120, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121 };
			static constexpr uint16_t function_arg_types[] = { 1877, 989, 62, 1841, 989, 62, 1273, 989, 62, 1877, 62, 1841, 62, 1273, 62, 1877, 989, 62, 1841, 989, 62, 1273, 989, 62, 1877, 62, 1841, 62, 1273, 62, 1877, 989, 1841, 989, 1273, 989, 1877, 987, 987, 987, 988, 4039, 1019, 1585, 1019, 1818, 1877, 4039, 4039, 1797, 1797, 4039, 1005, 1585, 1005, 1019, 1585, 1005, 1005, 1005, 1809, 1877, 4039, 4039, 1010, 998, 4039, 991, 1585, 991, 991, 991, 1803, 1877, 4039, 4039, 1818, 1809, 1585, 62, 62, 1585, 62, 2051, 1585, 62, 62, 2051, 62, 1585, 62, 2051, 1585, 62, 62, 2051, 62, 1585, 62, 62, 4039, 4039, 1585, 62, 4039, 4039, 62, 4039, 1585, 62, 62, 4039, 62, 62, 1585, 2051, 4039, 2051, 1585, 1585, 1855 };
			static constexpr uint16_t function_arg_names[] = { 3288, 2045, 1559, 3288, 2045, 1559, 3990, 2045, 1559, 3288, 1559, 3288, 1559, 3990, 1559, 3288, 2045, 1559, 3288, 2045, 1559, 3990, 2045, 1559, 3288, 1559, 3288, 1559, 3990, 1559, 3288, 2045, 3288, 2045, 3990, 2045, 3288, 2072, 3470, 4050, 1574, 3309, 3290, 1607, 3290, 3290, 3288, 2993, 2993, 3226, 4028, 3304, 2077, 1607, 2077, 3290, 1607, 2077, 3322, 2077, 2077, 3288, 2993, 2993, 4036, 4036, 3296, 1550, 1607, 1550, 3319, 1550, 1550, 3288, 2993, 2993, 3290, 2077, 2065, 1559, 1559, 2065, 1559, 1549, 2065, 1559, 1559, 1549, 1559, 2065, 1559, 1549, 2065, 1559, 1559, 1549, 1559, 2065, 1559, 1559, 3265, 3266, 2065, 1559, 3265, 3266, 1559, 1600, 4030, 1559, 1559, 1600, 1559, 1559, 1645, 4016, 1959, 4016, 3419, 3419, 3484 };
			static constexpr uint16_t function_arg_values[] = { 0, 678, 3294, 0, 678, 3294, 0, 678, 3294, 0, 0, 0, 0, 0, 0, 0, 678, 3294, 0, 678, 3294, 0, 678, 3294, 0, 0, 0, 0, 0, 0, 0, 678, 0, 678, 0, 678, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 978, 978, 0, 0, 4033, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 3294, 0, 3294, 0, 0, 3294, 3294, 0, 3294, 0, 3294, 0, 0, 3294, 3294, 0, 3294, 0, 3294, 3294, 0, 0, 0, 3294, 0, 0, 3294, 0, 0, 3294, 3294, 0, 3294, 3294, 2016, 15, 14, 16, 4033, 4033, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 100, 83 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 12, 20 };
			static constexpr uint16_t enum_var_names[] = { 678, 620, 577, 101, 103, 105, 108, 102, 104, 106, 107, 1091, 93, 87, 88, 89, 84, 85, 86, 1090 };
	};
	constexpr uint16_t ReflectionMesh::constructor_bases[];
	constexpr uint16_t ReflectionMesh::constructor_arg_types[];
	constexpr uint16_t ReflectionMesh::constructor_arg_names[];
	constexpr uint16_t ReflectionMesh::constructor_arg_values[];
	constexpr uint8_t ReflectionMesh::function_flags[];
	constexpr uint16_t ReflectionMesh::function_names[];
	constexpr uint16_t ReflectionMesh::function_types[];
	constexpr uint16_t ReflectionMesh::function_bases[];
	constexpr uint16_t ReflectionMesh::function_arg_types[];
	constexpr uint16_t ReflectionMesh::function_arg_names[];
	constexpr uint16_t ReflectionMesh::function_arg_values[];
	constexpr uint16_t ReflectionMesh::callback_names[];
	constexpr uint16_t ReflectionMesh::callback_types[];
	constexpr uint16_t ReflectionMesh::callback_bases[];
	constexpr uint16_t ReflectionMesh::callback_arg_types[];
	constexpr uint16_t ReflectionMesh::callback_arg_names[];
	constexpr uint16_t ReflectionMesh::enum_names[];
	constexpr uint16_t ReflectionMesh::enum_bases[];
	constexpr uint16_t ReflectionMesh::enum_var_names[];
	static ReflectionMesh reflection_mesh;
	
	// Tellusim::Json
	class ReflectionJson : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Json::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Json, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Json, TypeList<Json::Type>>());
						case 2: return ConstructorPtr(new ConstructorImpl<Json, TypeList<const char*, Json::Type>>({}, Json::TypeUnknown));
						case 3: return ConstructorPtr(new ConstructorImpl<Json, TypeList<const String&, Json::Type>>({}, Json::TypeUnknown));
						case 4: return ConstructorPtr(new ConstructorImpl<Json, TypeList<Json*, const char*, Json::Type>>({}, {}, Json::TypeUnknown));
						case 5: return ConstructorPtr(new ConstructorImpl<Json, TypeList<Json*, const String&, Json::Type>>({}, {}, Json::TypeUnknown));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Json>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Json::*)()>(&Json::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(Json::*)(const char*, size_t, bool)>(&Json::create, {}, 0, false));
						case 2: return FunctionPtr(new FunctionImpl<bool(Json::*)(const String&, size_t, bool)>(&Json::create, {}, 0, false));
						case 3: return FunctionPtr(new FunctionImpl<bool(Json::*)(const char*)>(&Json::load));
						case 4: return FunctionPtr(new FunctionImpl<bool(Json::*)(const String&)>(&Json::load));
						case 5: return FunctionPtr(new FunctionImpl<bool(Json::*)(Stream&)>(&Json::load));
						case 6: return FunctionPtr(new FunctionImpl<bool(Json::*)(const char*, bool) const>(&Json::save, {}, false));
						case 7: return FunctionPtr(new FunctionImpl<bool(Json::*)(const String&, bool) const>(&Json::save, {}, false));
						case 8: return FunctionPtr(new FunctionImpl<bool(Json::*)(Stream&, bool) const>(&Json::save, Stream::null, false));
						case 9: return FunctionPtr(new FunctionImpl<const Json(Json::*)() const>(&Json::getRoot));
						case 10: return FunctionPtr(new FunctionImpl<Json(Json::*)()>(&Json::getRoot));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(Json&, bool)>(&Json::setParent, Json::null, true));
						case 12: return FunctionPtr(new FunctionImpl<const Json(Json::*)() const>(&Json::getParent));
						case 13: return FunctionPtr(new FunctionImpl<Json(Json::*)()>(&Json::getParent));
						case 14: return FunctionPtr(new FunctionImpl<Json(Json::*)(const char*, Json::Type, bool)>(&Json::addChild, {}, Json::TypeUnknown, true));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(Json&, bool)>(&Json::addChild, Json::null, true));
						case 16: return FunctionPtr(new FunctionImpl<bool(Json::*)(Json&)>(&Json::removeChild));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Json::*)()>(&Json::releaseChildren));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(const char*) const>(&Json::findChild));
						case 19: return FunctionPtr(new FunctionImpl<bool(Json::*)(const char*) const>(&Json::isChild));
						case 20: return FunctionPtr(new FunctionImpl<const Json(Json::*)(const char*) const>(&Json::getChild));
						case 21: return FunctionPtr(new FunctionImpl<Json(Json::*)(const char*)>(&Json::getChild));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)() const>(&Json::getNumChildren));
						case 23: return FunctionPtr(new FunctionImpl<const Array<Json>(Json::*)() const>(&Json::getChildren));
						case 24: return FunctionPtr(new FunctionImpl<Array<Json>(Json::*)()>(&Json::getChildren));
						case 25: return FunctionPtr(new FunctionImpl<const Json(Json::*)(uint32_t) const>(&Json::getChild));
						case 26: return FunctionPtr(new FunctionImpl<Json(Json::*)(uint32_t)>(&Json::getChild));
						case 27: return FunctionPtr(new FunctionImpl<String(Json::*)() const>(&Json::getPathName));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const char*)>(&Json::setName));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const String&)>(&Json::setName));
						case 30: return FunctionPtr(new FunctionImpl<String(Json::*)() const>(&Json::getName));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(Json::Type)>(&Json::setType));
						case 32: return FunctionPtr(new FunctionImpl<Json::Type(Json::*)() const>(&Json::getType));
						case 33: return FunctionPtr(new FunctionImpl<const char*(Json::Type)>(&Json::getTypeName));
						case 34: return FunctionPtr(new FunctionImpl<const char*(Json::*)() const>(&Json::getTypeName));
						case 35: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isUnknown));
						case 36: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isNull));
						case 37: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isBool));
						case 38: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isNumber));
						case 39: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isString));
						case 40: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isObject));
						case 41: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isArray));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(bool)>(&Json::setData));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(int32_t, uint32_t)>(&Json::setData, {}, 10));
						case 44: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(uint32_t, uint32_t)>(&Json::setData, {}, 10));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(uint64_t, uint32_t)>(&Json::setData, {}, 10));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(float32_t, uint32_t, bool, bool)>(&Json::setData, {}, 6, true, true));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(float64_t, uint32_t, bool, bool)>(&Json::setData, {}, 12, true, true));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const char*)>(&Json::setData));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const String&)>(&Json::setData));
						case 50: return FunctionPtr(new FunctionImpl<String(Json::*)() const>(&Json::getData));
						case 51: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::getDataBool));
						case 52: return FunctionPtr(new FunctionImpl<int32_t(Json::*)(uint32_t) const>(&Json::getDatai32, 10));
						case 53: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(uint32_t) const>(&Json::getDatau32, 10));
						case 54: return FunctionPtr(new FunctionImpl<uint64_t(Json::*)(uint32_t) const>(&Json::getDatau64, 10));
						case 55: return FunctionPtr(new FunctionImpl<float32_t(Json::*)() const>(&Json::getDataf32));
						case 56: return FunctionPtr(new FunctionImpl<float64_t(Json::*)() const>(&Json::getDataf64));
						case 57: return FunctionPtr(new FunctionImpl<String(Json::*)() const>(&Json::getNumber));
						case 58: return FunctionPtr(new FunctionImpl<String(Json::*)() const>(&Json::getString));
						case 59: return FunctionPtr(new FunctionImpl<bool(Json::*)(const char*, bool) const>(&Json::getData));
						case 60: return FunctionPtr(new FunctionImpl<int32_t(Json::*)(const char*, int32_t, uint32_t) const>(&Json::getData, {}, {}, 10));
						case 61: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(const char*, uint32_t, uint32_t) const>(&Json::getData, {}, {}, 10));
						case 62: return FunctionPtr(new FunctionImpl<uint64_t(Json::*)(const char*, uint64_t, uint32_t) const>(&Json::getData, {}, {}, 10));
						case 63: return FunctionPtr(new FunctionImpl<float32_t(Json::*)(const char*, float32_t) const>(&Json::getData));
						case 64: return FunctionPtr(new FunctionImpl<float64_t(Json::*)(const char*, float64_t) const>(&Json::getData));
						case 65: return FunctionPtr(new FunctionImpl<String(Json::*)(const char*, const String&) const>(&Json::getData, {}, String::null));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const char**, uint32_t)>(&Json::setData));
						case 67: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const String*, uint32_t)>(&Json::setData));
						case 68: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const int32_t*, uint32_t, uint32_t)>(&Json::setData, {}, {}, 10));
						case 69: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const uint32_t*, uint32_t, uint32_t)>(&Json::setData, {}, {}, 10));
						case 70: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const float32_t*, uint32_t, uint32_t, bool, bool)>(&Json::setData, {}, {}, 6, true, true));
						case 71: return FunctionPtr(new FunctionVoidImpl<void(Json::*)(const float64_t*, uint32_t, uint32_t, bool, bool)>(&Json::setData, {}, {}, 12, true, true));
						case 72: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(String*, uint32_t) const>(&Json::getData));
						case 73: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(int32_t*, uint32_t, uint32_t) const>(&Json::getData, {}, {}, 10));
						case 74: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(uint32_t*, uint32_t, uint32_t) const>(&Json::getData, {}, {}, 10));
						case 75: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(float32_t*, uint32_t) const>(&Json::getData));
						case 76: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)(float64_t*, uint32_t) const>(&Json::getData));
						case 77: return FunctionPtr(new FunctionImpl<Json(Json::*)() const>(&Json::clonePtr));
						case 78: return FunctionPtr(new FunctionVoidImpl<void(Json::*)()>(&Json::clearPtr));
						case 79: return FunctionPtr(new FunctionVoidImpl<void(Json::*)()>(&Json::destroyPtr));
						case 80: return FunctionPtr(new FunctionImpl<Json&(Json::*)()>(&Json::acquirePtr));
						case 81: return FunctionPtr(new FunctionImpl<Json&(Json::*)()>(&Json::unacquirePtr));
						case 82: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isValidPtr));
						case 83: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isOwnerPtr));
						case 84: return FunctionPtr(new FunctionImpl<bool(Json::*)() const>(&Json::isConstPtr));
						case 85: return FunctionPtr(new FunctionImpl<uint32_t(Json::*)() const>(&Json::getCountPtr));
						case 86: return FunctionPtr(new FunctionImpl<const void*(Json::*)() const>(&Json::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5, 8, 11 };
			static constexpr uint16_t constructor_arg_types[] = { 855, 1877, 855, 1841, 855, 854, 1877, 855, 854, 1841, 855 };
			static constexpr uint16_t constructor_arg_names[] = { 4036, 3288, 4036, 3288, 4036, 3348, 3288, 4036, 3348, 3288, 4036 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 1389, 0, 1389, 0, 0, 1389, 0, 0, 1389 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 1902, 1902, 3242, 3242, 3242, 3480, 3480, 3480, 2715, 2715, 3770, 2651, 2651, 1513, 1513, 3424, 3409, 2028, 3044, 2190, 2190, 2567, 2191, 2191, 2190, 2190, 2660, 3751, 3751, 2556, 3915, 2878, 2879, 2879, 3198, 3135, 3032, 3136, 3181, 3137, 3021, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 2260, 2261, 2266, 2267, 2268, 2264, 2265, 2627, 2796, 2260, 2260, 2260, 2260, 2260, 2260, 2260, 3590, 3590, 3590, 3590, 3590, 3590, 2260, 2260, 2260, 2260, 2260, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1793, 852, 4039, 1793, 852, 852, 4039, 1585, 4073, 4039, 1585, 1793, 852, 4039, 1676, 48, 1793, 852, 1274, 4073, 4073, 1274, 4073, 855, 1877, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1274, 1585, 3003, 4039, 4044, 2051, 2054, 1274, 1274, 1585, 3003, 4039, 4044, 2051, 2054, 1274, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 4039, 4039, 4039, 4039, 852, 4073, 4073, 853, 853, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 3, 6, 7, 8, 9, 11, 13, 15, 15, 15, 17, 17, 17, 20, 22, 23, 23, 24, 25, 26, 27, 27, 27, 27, 28, 29, 29, 30, 31, 31, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 36, 38, 40, 44, 48, 49, 50, 50, 50, 51, 52, 53, 53, 53, 53, 53, 55, 58, 61, 64, 66, 68, 70, 72, 74, 77, 80, 85, 90, 92, 95, 98, 100, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102 };
			static constexpr uint16_t function_arg_types[] = { 1877, 3961, 1585, 1841, 3961, 1585, 1877, 1841, 1273, 1877, 1585, 1841, 1585, 1273, 1585, 853, 1585, 1877, 855, 1585, 853, 1585, 853, 1877, 1877, 1877, 1877, 4039, 4039, 1877, 1841, 855, 855, 1585, 3003, 4039, 4039, 4039, 4044, 4039, 2051, 4039, 1585, 1585, 2054, 4039, 1585, 1585, 1877, 1841, 4039, 4039, 4039, 1877, 1585, 1877, 3003, 4039, 1877, 4039, 4039, 1877, 4044, 4039, 1877, 2051, 1877, 2054, 1877, 1841, 1878, 4039, 1842, 4039, 1881, 4039, 4039, 1882, 4039, 4039, 1879, 4039, 4039, 1585, 1585, 1880, 4039, 4039, 1585, 1585, 1276, 4039, 3005, 4039, 4039, 4041, 4039, 4039, 2053, 4039, 2055, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3989, 3960, 3341, 3989, 3960, 3341, 3288, 3288, 3990, 3288, 1656, 3288, 1656, 3990, 1656, 3348, 1607, 3288, 4036, 1607, 1609, 1607, 1609, 3288, 3288, 3288, 3288, 2993, 2993, 3288, 3288, 4036, 4036, 4056, 4056, 3374, 4056, 3374, 4056, 3374, 4056, 1972, 1656, 2014, 4056, 1972, 1656, 2014, 4056, 4056, 3374, 3374, 3374, 3288, 4056, 3288, 4056, 3374, 3288, 4056, 3374, 3288, 4056, 3374, 3288, 4056, 3288, 4056, 3288, 4056, 4061, 3960, 4061, 3960, 4061, 3960, 3374, 4061, 3960, 3374, 4061, 3960, 1972, 1656, 2014, 4061, 3960, 1972, 1656, 2014, 4061, 3960, 4061, 3960, 3374, 4061, 3960, 3374, 4061, 3960, 4061, 3960 };
			static constexpr uint16_t function_arg_values[] = { 0, 3, 2016, 0, 3, 2016, 0, 0, 0, 0, 2016, 0, 2016, 0, 2016, 0, 4033, 0, 1389, 4033, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 9, 0, 21, 4033, 4033, 0, 12, 4033, 4033, 0, 0, 9, 9, 9, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0, 0, 1277, 0, 0, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 21, 4033, 4033, 0, 0, 12, 4033, 4033, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311 };
			static constexpr uint16_t enum_bases[] = { 0, 8 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1360, 1318, 1361, 1379, 1362, 1315, 1117 };
	};
	constexpr uint16_t ReflectionJson::constructor_bases[];
	constexpr uint16_t ReflectionJson::constructor_arg_types[];
	constexpr uint16_t ReflectionJson::constructor_arg_names[];
	constexpr uint16_t ReflectionJson::constructor_arg_values[];
	constexpr uint8_t ReflectionJson::function_flags[];
	constexpr uint16_t ReflectionJson::function_names[];
	constexpr uint16_t ReflectionJson::function_types[];
	constexpr uint16_t ReflectionJson::function_bases[];
	constexpr uint16_t ReflectionJson::function_arg_types[];
	constexpr uint16_t ReflectionJson::function_arg_names[];
	constexpr uint16_t ReflectionJson::function_arg_values[];
	constexpr uint16_t ReflectionJson::callback_names[];
	constexpr uint16_t ReflectionJson::callback_types[];
	constexpr uint16_t ReflectionJson::callback_bases[];
	constexpr uint16_t ReflectionJson::callback_arg_types[];
	constexpr uint16_t ReflectionJson::callback_arg_names[];
	constexpr uint16_t ReflectionJson::enum_names[];
	constexpr uint16_t ReflectionJson::enum_bases[];
	constexpr uint16_t ReflectionJson::enum_var_names[];
	static ReflectionJson reflection_json;
	
	// Tellusim::Xml
	class ReflectionXml : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Xml::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Xml, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Xml, TypeList<const char*, const char*>>({}, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<Xml, TypeList<const String&, const char*>>({}, nullptr));
						case 3: return ConstructorPtr(new ConstructorImpl<Xml, TypeList<Xml*, const char*, const char*>>({}, {}, nullptr));
						case 4: return ConstructorPtr(new ConstructorImpl<Xml, TypeList<Xml*, const String&, const char*>>({}, {}, nullptr));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Xml>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)()>(&Xml::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*, size_t, bool)>(&Xml::create, {}, 0, false));
						case 2: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const String&, size_t, bool)>(&Xml::create, {}, 0, false));
						case 3: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*)>(&Xml::load));
						case 4: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const String&)>(&Xml::load));
						case 5: return FunctionPtr(new FunctionImpl<bool(Xml::*)(Stream&)>(&Xml::load));
						case 6: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*, bool) const>(&Xml::save, {}, false));
						case 7: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const String&, bool) const>(&Xml::save, {}, false));
						case 8: return FunctionPtr(new FunctionImpl<bool(Xml::*)(Stream&, bool) const>(&Xml::save, Stream::null, false));
						case 9: return FunctionPtr(new FunctionImpl<const Xml(Xml::*)() const>(&Xml::getRoot));
						case 10: return FunctionPtr(new FunctionImpl<Xml(Xml::*)()>(&Xml::getRoot));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(Xml&, bool)>(&Xml::setParent, Xml::null, true));
						case 12: return FunctionPtr(new FunctionImpl<const Xml(Xml::*)() const>(&Xml::getParent));
						case 13: return FunctionPtr(new FunctionImpl<Xml(Xml::*)()>(&Xml::getParent));
						case 14: return FunctionPtr(new FunctionImpl<Xml(Xml::*)(const char*, bool)>(&Xml::addChild, {}, true));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(Xml&, bool)>(&Xml::addChild, Xml::null, true));
						case 16: return FunctionPtr(new FunctionImpl<bool(Xml::*)(Xml&)>(&Xml::removeChild));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)()>(&Xml::releaseChildren));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(const char*) const>(&Xml::findChild));
						case 19: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*) const>(&Xml::isChild));
						case 20: return FunctionPtr(new FunctionImpl<const Xml(Xml::*)(const char*) const>(&Xml::getChild));
						case 21: return FunctionPtr(new FunctionImpl<Xml(Xml::*)(const char*)>(&Xml::getChild));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)() const>(&Xml::getNumChildren));
						case 23: return FunctionPtr(new FunctionImpl<const Array<Xml>(Xml::*)() const>(&Xml::getChildren));
						case 24: return FunctionPtr(new FunctionImpl<Array<Xml>(Xml::*)()>(&Xml::getChildren));
						case 25: return FunctionPtr(new FunctionImpl<const Xml(Xml::*)(uint32_t) const>(&Xml::getChild));
						case 26: return FunctionPtr(new FunctionImpl<Xml(Xml::*)(uint32_t)>(&Xml::getChild));
						case 27: return FunctionPtr(new FunctionImpl<String(Xml::*)() const>(&Xml::getPathName));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const char*)>(&Xml::setName));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const String&)>(&Xml::setName));
						case 30: return FunctionPtr(new FunctionImpl<String(Xml::*)() const>(&Xml::getName));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(bool)>(&Xml::setData));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const char*)>(&Xml::setData));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const String&)>(&Xml::setData));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(int32_t, uint32_t)>(&Xml::setData, {}, 10));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, uint32_t)>(&Xml::setData, {}, 10));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint64_t, uint32_t)>(&Xml::setData, {}, 10));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(float32_t, uint32_t, bool, bool)>(&Xml::setData, {}, 6, true, true));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(float64_t, uint32_t, bool, bool)>(&Xml::setData, {}, 12, true, true));
						case 39: return FunctionPtr(new FunctionImpl<String(Xml::*)() const>(&Xml::getData));
						case 40: return FunctionPtr(new FunctionImpl<bool(Xml::*)() const>(&Xml::getDataBool));
						case 41: return FunctionPtr(new FunctionImpl<int32_t(Xml::*)(uint32_t) const>(&Xml::getDatai32, 10));
						case 42: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t) const>(&Xml::getDatau32, 10));
						case 43: return FunctionPtr(new FunctionImpl<uint64_t(Xml::*)(uint32_t) const>(&Xml::getDatau64, 10));
						case 44: return FunctionPtr(new FunctionImpl<float32_t(Xml::*)() const>(&Xml::getDataf32));
						case 45: return FunctionPtr(new FunctionImpl<float64_t(Xml::*)() const>(&Xml::getDataf64));
						case 46: return FunctionPtr(new FunctionImpl<String(Xml::*)(const char*, const String&) const>(&Xml::getData, {}, String::null));
						case 47: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*, bool) const>(&Xml::getData));
						case 48: return FunctionPtr(new FunctionImpl<int32_t(Xml::*)(const char*, int32_t, uint32_t) const>(&Xml::getData, {}, {}, 10));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(const char*, uint32_t, uint32_t) const>(&Xml::getData, {}, {}, 10));
						case 50: return FunctionPtr(new FunctionImpl<uint64_t(Xml::*)(const char*, uint64_t, uint32_t) const>(&Xml::getData, {}, {}, 10));
						case 51: return FunctionPtr(new FunctionImpl<float32_t(Xml::*)(const char*, float32_t) const>(&Xml::getData));
						case 52: return FunctionPtr(new FunctionImpl<float64_t(Xml::*)(const char*, float64_t) const>(&Xml::getData));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const char**, uint32_t, uint32_t)>(&Xml::setData, {}, {}, Maxu32));
						case 54: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const String*, uint32_t, uint32_t)>(&Xml::setData, {}, {}, Maxu32));
						case 55: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const int32_t*, uint32_t, uint32_t, uint32_t)>(&Xml::setData, {}, {}, 10, Maxu32));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const uint32_t*, uint32_t, uint32_t, uint32_t)>(&Xml::setData, {}, {}, 10, Maxu32));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const float32_t*, uint32_t, uint32_t, bool, bool, uint32_t)>(&Xml::setData, {}, {}, 6, true, true, Maxu32));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(const float64_t*, uint32_t, uint32_t, bool, bool, uint32_t)>(&Xml::setData, {}, {}, 12, true, true, Maxu32));
						case 59: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(String*, uint32_t) const>(&Xml::getData));
						case 60: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(int32_t*, uint32_t, uint32_t) const>(&Xml::getData, {}, {}, 10));
						case 61: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t*, uint32_t, uint32_t) const>(&Xml::getData, {}, {}, 10));
						case 62: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(float32_t*, uint32_t) const>(&Xml::getData));
						case 63: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(float64_t*, uint32_t) const>(&Xml::getData));
						case 64: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(const char*)>(&Xml::addAttribute));
						case 65: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*)>(&Xml::removeAttribute));
						case 66: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(const char*) const>(&Xml::findAttribute));
						case 67: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*) const>(&Xml::isAttribute));
						case 68: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)()>(&Xml::removeAttributes));
						case 69: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)() const>(&Xml::getNumAttributes));
						case 70: return FunctionPtr(new FunctionImpl<String(Xml::*)(uint32_t) const>(&Xml::getAttributeName));
						case 71: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*)>(&Xml::setAttributes));
						case 72: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, bool)>(&Xml::setAttribute));
						case 73: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const char*)>(&Xml::setAttribute));
						case 74: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const String&)>(&Xml::setAttribute));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, int32_t, uint32_t)>(&Xml::setAttribute, {}, {}, 10));
						case 76: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, uint32_t, uint32_t)>(&Xml::setAttribute, {}, {}, 10));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, uint64_t, uint32_t)>(&Xml::setAttribute, {}, {}, 10));
						case 78: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, float32_t, uint32_t, bool, bool)>(&Xml::setAttribute, {}, {}, 6, true, true));
						case 79: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, float64_t, uint32_t, bool, bool)>(&Xml::setAttribute, {}, {}, 12, true, true));
						case 80: return FunctionPtr(new FunctionImpl<String(Xml::*)(uint32_t) const>(&Xml::getAttribute));
						case 81: return FunctionPtr(new FunctionImpl<int32_t(Xml::*)(uint32_t, uint32_t) const>(&Xml::getAttributei32, {}, 10));
						case 82: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t, uint32_t) const>(&Xml::getAttributeu32, {}, 10));
						case 83: return FunctionPtr(new FunctionImpl<uint64_t(Xml::*)(uint32_t, uint32_t) const>(&Xml::getAttributeu64, {}, 10));
						case 84: return FunctionPtr(new FunctionImpl<float32_t(Xml::*)(uint32_t) const>(&Xml::getAttributef32));
						case 85: return FunctionPtr(new FunctionImpl<float64_t(Xml::*)(uint32_t) const>(&Xml::getAttributef64));
						case 86: return FunctionPtr(new FunctionImpl<String(Xml::*)(const char*, const String&) const>(&Xml::getAttribute, {}, String::null));
						case 87: return FunctionPtr(new FunctionImpl<bool(Xml::*)(const char*, bool) const>(&Xml::getAttribute));
						case 88: return FunctionPtr(new FunctionImpl<int32_t(Xml::*)(const char*, int32_t, uint32_t) const>(&Xml::getAttribute, {}, {}, 10));
						case 89: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(const char*, uint32_t, uint32_t) const>(&Xml::getAttribute, {}, {}, 10));
						case 90: return FunctionPtr(new FunctionImpl<uint64_t(Xml::*)(const char*, uint64_t, uint32_t) const>(&Xml::getAttribute, {}, {}, 10));
						case 91: return FunctionPtr(new FunctionImpl<float32_t(Xml::*)(const char*, float32_t) const>(&Xml::getAttribute));
						case 92: return FunctionPtr(new FunctionImpl<float64_t(Xml::*)(const char*, float64_t) const>(&Xml::getAttribute));
						case 93: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const char**, uint32_t, const char*)>(&Xml::setAttribute, {}, {}, {}, nullptr));
						case 94: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const String*, uint32_t, const char*)>(&Xml::setAttribute, {}, {}, {}, nullptr));
						case 95: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const int32_t*, uint32_t, uint32_t)>(&Xml::setAttribute, {}, {}, {}, 10));
						case 96: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const uint32_t*, uint32_t, uint32_t)>(&Xml::setAttribute, {}, {}, {}, 10));
						case 97: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const float32_t*, uint32_t, uint32_t, bool, bool)>(&Xml::setAttribute, {}, {}, {}, 6, true, true));
						case 98: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)(uint32_t, const float64_t*, uint32_t, uint32_t, bool, bool)>(&Xml::setAttribute, {}, {}, {}, 12, true, true));
						case 99: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t, String*, uint32_t, const char*) const>(&Xml::getAttribute, {}, {}, {}, nullptr));
						case 100: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t, int32_t*, uint32_t, uint32_t) const>(&Xml::getAttribute, {}, {}, {}, 10));
						case 101: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t, uint32_t*, uint32_t, uint32_t) const>(&Xml::getAttribute, {}, {}, {}, 10));
						case 102: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t, float32_t*, uint32_t) const>(&Xml::getAttribute));
						case 103: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)(uint32_t, float64_t*, uint32_t) const>(&Xml::getAttribute));
						case 104: return FunctionPtr(new FunctionImpl<Xml(Xml::*)() const>(&Xml::clonePtr));
						case 105: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)()>(&Xml::clearPtr));
						case 106: return FunctionPtr(new FunctionVoidImpl<void(Xml::*)()>(&Xml::destroyPtr));
						case 107: return FunctionPtr(new FunctionImpl<Xml&(Xml::*)()>(&Xml::acquirePtr));
						case 108: return FunctionPtr(new FunctionImpl<Xml&(Xml::*)()>(&Xml::unacquirePtr));
						case 109: return FunctionPtr(new FunctionImpl<bool(Xml::*)() const>(&Xml::isValidPtr));
						case 110: return FunctionPtr(new FunctionImpl<bool(Xml::*)() const>(&Xml::isOwnerPtr));
						case 111: return FunctionPtr(new FunctionImpl<bool(Xml::*)() const>(&Xml::isConstPtr));
						case 112: return FunctionPtr(new FunctionImpl<uint32_t(Xml::*)() const>(&Xml::getCountPtr));
						case 113: return FunctionPtr(new FunctionImpl<const void*(Xml::*)() const>(&Xml::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 4, 7, 10 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1877, 1841, 1877, 1499, 1877, 1877, 1499, 1841, 1877 };
			static constexpr uint16_t constructor_arg_names[] = { 3288, 1565, 3288, 1565, 3348, 3288, 1565, 3348, 3288, 1565 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 3294, 0, 3294, 0, 0, 3294, 0, 0, 3294 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 2, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 1902, 1902, 3242, 3242, 3242, 3480, 3480, 3480, 2715, 2715, 3770, 2651, 2651, 1513, 1513, 3424, 3409, 2028, 3044, 2190, 2190, 2567, 2191, 2191, 2190, 2190, 2660, 3751, 3751, 2556, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 2260, 2261, 2266, 2267, 2268, 2264, 2265, 2260, 2260, 2260, 2260, 2260, 2260, 2260, 3590, 3590, 3590, 3590, 3590, 3590, 2260, 2260, 2260, 2260, 2260, 1511, 3422, 2025, 3023, 3423, 2564, 2100, 3516, 3509, 3509, 3509, 3509, 3509, 3509, 3509, 3509, 2098, 2108, 2110, 2111, 2106, 2107, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 3509, 3509, 3509, 3509, 3509, 3509, 2098, 2098, 2098, 2098, 2098, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1876, 1497, 4039, 1876, 1497, 1497, 4039, 1585, 4073, 4039, 1585, 1876, 1497, 4039, 1700, 58, 1876, 1497, 1274, 4073, 4073, 1274, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1274, 1585, 3003, 4039, 4044, 2051, 2054, 1274, 1585, 3003, 4039, 4044, 2051, 2054, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 4039, 4039, 4039, 4039, 4039, 1585, 4039, 1585, 4073, 4039, 1274, 1585, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1274, 3003, 4039, 4044, 2051, 2054, 1274, 1585, 3003, 4039, 4044, 2051, 2054, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 4039, 4039, 4039, 4039, 1497, 4073, 4073, 1498, 1498, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 3, 6, 7, 8, 9, 11, 13, 15, 15, 15, 17, 17, 17, 19, 21, 22, 22, 23, 24, 25, 26, 26, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32, 33, 35, 37, 39, 43, 47, 47, 47, 48, 49, 50, 50, 50, 52, 54, 57, 60, 63, 65, 67, 70, 73, 77, 81, 87, 93, 95, 98, 101, 103, 105, 106, 107, 108, 109, 109, 109, 110, 111, 113, 115, 117, 120, 123, 126, 131, 136, 137, 139, 141, 143, 144, 145, 147, 149, 152, 155, 158, 160, 162, 166, 170, 174, 178, 184, 190, 194, 198, 202, 205, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208 };
			static constexpr uint16_t function_arg_types[] = { 1877, 3961, 1585, 1841, 3961, 1585, 1877, 1841, 1273, 1877, 1585, 1841, 1585, 1273, 1585, 1498, 1585, 1877, 1585, 1498, 1585, 1498, 1877, 1877, 1877, 1877, 4039, 4039, 1877, 1841, 1585, 1877, 1841, 3003, 4039, 4039, 4039, 4044, 4039, 2051, 4039, 1585, 1585, 2054, 4039, 1585, 1585, 4039, 4039, 4039, 1877, 1841, 1877, 1585, 1877, 3003, 4039, 1877, 4039, 4039, 1877, 4044, 4039, 1877, 2051, 1877, 2054, 1878, 4039, 4039, 1842, 4039, 4039, 1881, 4039, 4039, 4039, 1882, 4039, 4039, 4039, 1879, 4039, 4039, 1585, 1585, 4039, 1880, 4039, 4039, 1585, 1585, 4039, 1276, 4039, 3005, 4039, 4039, 4041, 4039, 4039, 2053, 4039, 2055, 4039, 1877, 1877, 1877, 1877, 4039, 1877, 4039, 1585, 4039, 1877, 4039, 1841, 4039, 3003, 4039, 4039, 4039, 4039, 4039, 4044, 4039, 4039, 2051, 4039, 1585, 1585, 4039, 2054, 4039, 1585, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1877, 1841, 1877, 1585, 1877, 3003, 4039, 1877, 4039, 4039, 1877, 4044, 4039, 1877, 2051, 1877, 2054, 4039, 1878, 4039, 1877, 4039, 1842, 4039, 1877, 4039, 1881, 4039, 4039, 4039, 1882, 4039, 4039, 4039, 1879, 4039, 4039, 1585, 1585, 4039, 1880, 4039, 4039, 1585, 1585, 4039, 1276, 4039, 1877, 4039, 3005, 4039, 4039, 4039, 4041, 4039, 4039, 4039, 2053, 4039, 4039, 2055, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3989, 3960, 3341, 3989, 3960, 3341, 3288, 3288, 3990, 3288, 1656, 3288, 1656, 3990, 1656, 3348, 1607, 3288, 1607, 1609, 1607, 1609, 3288, 3288, 3288, 3288, 2993, 2993, 3288, 3288, 4056, 4056, 4056, 4056, 3374, 4056, 3374, 4056, 3374, 4056, 1972, 1656, 2014, 4056, 1972, 1656, 2014, 3374, 3374, 3374, 3288, 4056, 3288, 4056, 3288, 4056, 3374, 3288, 4056, 3374, 3288, 4056, 3374, 3288, 4056, 3288, 4056, 4061, 3960, 4091, 4061, 3960, 4091, 4061, 3960, 3374, 4091, 4061, 3960, 3374, 4091, 4061, 3960, 1972, 1656, 2014, 4091, 4061, 3960, 1972, 1656, 2014, 4091, 4061, 3960, 4061, 3960, 3374, 4061, 3960, 3374, 4061, 3960, 4061, 3960, 3288, 3288, 3288, 3288, 2993, 3989, 2993, 4056, 2993, 4056, 2993, 4056, 2993, 4056, 3374, 2993, 4056, 3374, 2993, 4056, 3374, 2993, 4056, 1972, 1656, 2014, 2993, 4056, 1972, 1656, 2014, 2993, 2993, 3374, 2993, 3374, 2993, 3374, 2993, 2993, 3288, 4056, 3288, 4056, 3288, 4056, 3374, 3288, 4056, 3374, 3288, 4056, 3374, 3288, 4056, 3288, 4056, 2993, 4061, 3960, 1957, 2993, 4061, 3960, 1957, 2993, 4061, 3960, 3374, 2993, 4061, 3960, 3374, 2993, 4061, 3960, 1972, 1656, 2014, 2993, 4061, 3960, 1972, 1656, 2014, 2993, 4061, 3960, 1957, 2993, 4061, 3960, 3374, 2993, 4061, 3960, 3374, 2993, 4061, 3960, 2993, 4061, 3960 };
			static constexpr uint16_t function_arg_values[] = { 0, 3, 2016, 0, 3, 2016, 0, 0, 0, 0, 2016, 0, 2016, 0, 2016, 0, 4033, 0, 4033, 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 9, 0, 21, 4033, 4033, 0, 12, 4033, 4033, 9, 9, 9, 0, 1277, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0, 0, 0, 984, 0, 0, 984, 0, 0, 9, 984, 0, 0, 9, 984, 0, 0, 21, 4033, 4033, 984, 0, 0, 12, 4033, 4033, 984, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 9, 0, 0, 21, 4033, 4033, 0, 0, 12, 4033, 4033, 0, 0, 9, 0, 9, 0, 9, 0, 0, 0, 1277, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 0, 3294, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 21, 4033, 4033, 0, 0, 0, 12, 4033, 4033, 0, 0, 0, 3294, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionXml::constructor_bases[];
	constexpr uint16_t ReflectionXml::constructor_arg_types[];
	constexpr uint16_t ReflectionXml::constructor_arg_names[];
	constexpr uint16_t ReflectionXml::constructor_arg_values[];
	constexpr uint8_t ReflectionXml::function_flags[];
	constexpr uint16_t ReflectionXml::function_names[];
	constexpr uint16_t ReflectionXml::function_types[];
	constexpr uint16_t ReflectionXml::function_bases[];
	constexpr uint16_t ReflectionXml::function_arg_types[];
	constexpr uint16_t ReflectionXml::function_arg_names[];
	constexpr uint16_t ReflectionXml::function_arg_values[];
	constexpr uint16_t ReflectionXml::callback_names[];
	constexpr uint16_t ReflectionXml::callback_types[];
	constexpr uint16_t ReflectionXml::callback_bases[];
	constexpr uint16_t ReflectionXml::callback_arg_types[];
	constexpr uint16_t ReflectionXml::callback_arg_names[];
	constexpr uint16_t ReflectionXml::enum_names[];
	constexpr uint16_t ReflectionXml::enum_bases[];
	constexpr uint16_t ReflectionXml::enum_var_names[];
	static ReflectionXml reflection_xml;
	
	// Tellusim::Buffer
	class ReflectionBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Buffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Buffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Buffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Buffer::*)() const>(&Buffer::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Buffer::*)() const>(&Buffer::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Buffer::*)() const>(&Buffer::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Buffer::*)()>(&Buffer::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Buffer::*)() const>(&Buffer::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Buffer::*)(const char*)>(&Buffer::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(Buffer::*)() const>(&Buffer::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(Buffer::*)(Buffer::Flags, size_t, Format)>(&Buffer::create, (Buffer::Flags)0, {}, Tellusim::FormatUnknown));
						case 8: return FunctionPtr(new FunctionImpl<bool(Buffer::*)() const>(&Buffer::isMapped));
						case 9: return FunctionPtr(new FunctionImpl<Buffer::Flags(Buffer::*)() const>(&Buffer::getFlags));
						case 10: return FunctionPtr(new FunctionImpl<bool(Buffer::*)(Buffer::Flags) const>(&Buffer::hasFlag));
						case 11: return FunctionPtr(new FunctionImpl<bool(Buffer::*)(Buffer::Flags) const>(&Buffer::hasFlags));
						case 12: return FunctionPtr(new FunctionImpl<String(Buffer::*)() const>(&Buffer::getFlagsName));
						case 13: return FunctionPtr(new FunctionImpl<Format(Buffer::*)() const>(&Buffer::getFormat));
						case 14: return FunctionPtr(new FunctionImpl<const char*(Buffer::*)() const>(&Buffer::getFormatName));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Buffer::*)() const>(&Buffer::getComponents));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(Buffer::*)() const>(&Buffer::getPixelSize));
						case 17: return FunctionPtr(new FunctionImpl<size_t(Buffer::*)()>(&Buffer::getSize));
						case 18: return FunctionPtr(new FunctionImpl<size_t(Buffer::*)()>(&Buffer::getPageSize));
						case 19: return FunctionPtr(new FunctionImpl<String(Buffer::*)() const>(&Buffer::getDescription));
						case 20: return FunctionPtr(new FunctionImpl<Buffer(Buffer::*)() const>(&Buffer::clonePtr));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Buffer::*)()>(&Buffer::clearPtr));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Buffer::*)()>(&Buffer::destroyPtr));
						case 23: return FunctionPtr(new FunctionImpl<Buffer&(Buffer::*)()>(&Buffer::acquirePtr));
						case 24: return FunctionPtr(new FunctionImpl<Buffer&(Buffer::*)()>(&Buffer::unacquirePtr));
						case 25: return FunctionPtr(new FunctionImpl<bool(Buffer::*)() const>(&Buffer::isValidPtr));
						case 26: return FunctionPtr(new FunctionImpl<bool(Buffer::*)() const>(&Buffer::isOwnerPtr));
						case 27: return FunctionPtr(new FunctionImpl<bool(Buffer::*)() const>(&Buffer::isConstPtr));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(Buffer::*)() const>(&Buffer::getCountPtr));
						case 29: return FunctionPtr(new FunctionImpl<const void*(Buffer::*)() const>(&Buffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 3118, 2341, 2947, 2948, 2342, 2355, 2357, 2223, 2667, 2760, 2636, 2296, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 1585, 155, 1585, 1585, 1274, 765, 1877, 4039, 4039, 3961, 3961, 1274, 152, 4073, 4073, 153, 153, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 4, 4, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
			static constexpr uint16_t function_arg_types[] = { 1877, 155, 3961, 765, 155, 155 };
			static constexpr uint16_t function_arg_names[] = { 3288, 2045, 3960, 2066, 2045, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 767, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753 };
			static constexpr uint16_t enum_bases[] = { 0, 24 };
			static constexpr uint16_t enum_var_names[] = { 678, 699, 745, 720, 721, 711, 652, 623, 647, 619, 734, 723, 582, 730, 709, 594, 645, 614, 739, 641, 727, 581, 437, 1102 };
	};
	constexpr uint16_t ReflectionBuffer::constructor_bases[];
	constexpr uint16_t ReflectionBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionBuffer::function_flags[];
	constexpr uint16_t ReflectionBuffer::function_names[];
	constexpr uint16_t ReflectionBuffer::function_types[];
	constexpr uint16_t ReflectionBuffer::function_bases[];
	constexpr uint16_t ReflectionBuffer::function_arg_types[];
	constexpr uint16_t ReflectionBuffer::function_arg_names[];
	constexpr uint16_t ReflectionBuffer::function_arg_values[];
	constexpr uint16_t ReflectionBuffer::callback_names[];
	constexpr uint16_t ReflectionBuffer::callback_types[];
	constexpr uint16_t ReflectionBuffer::callback_bases[];
	constexpr uint16_t ReflectionBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionBuffer::enum_names[];
	constexpr uint16_t ReflectionBuffer::enum_bases[];
	constexpr uint16_t ReflectionBuffer::enum_var_names[];
	static ReflectionBuffer reflection_buffer;
	
	// Tellusim::BufferTable
	class ReflectionBufferTable : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return BufferTable::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<BufferTable, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<BufferTable>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(BufferTable::*)() const>(&BufferTable::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(BufferTable::*)() const>(&BufferTable::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(BufferTable::*)() const>(&BufferTable::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(BufferTable::*)()>(&BufferTable::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(BufferTable::*)() const>(&BufferTable::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(BufferTable::*)(const char*)>(&BufferTable::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(BufferTable::*)() const>(&BufferTable::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(BufferTable::*)(uint32_t)>(&BufferTable::create));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(BufferTable::*)() const>(&BufferTable::getSize));
						case 9: return FunctionPtr(new FunctionImpl<Buffer(BufferTable::*)(uint32_t) const>(&BufferTable::get));
						case 10: return FunctionPtr(new FunctionImpl<bool(BufferTable::*)(uint32_t) const>(&BufferTable::isOwner));
						case 11: return FunctionPtr(new FunctionImpl<size_t(BufferTable::*)() const>(&BufferTable::getMemory));
						case 12: return FunctionPtr(new FunctionImpl<BufferTable(BufferTable::*)() const>(&BufferTable::clonePtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(BufferTable::*)()>(&BufferTable::clearPtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(BufferTable::*)()>(&BufferTable::destroyPtr));
						case 15: return FunctionPtr(new FunctionImpl<BufferTable&(BufferTable::*)()>(&BufferTable::acquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<BufferTable&(BufferTable::*)()>(&BufferTable::unacquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(BufferTable::*)() const>(&BufferTable::isValidPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(BufferTable::*)() const>(&BufferTable::isOwnerPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(BufferTable::*)() const>(&BufferTable::isConstPtr));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(BufferTable::*)() const>(&BufferTable::getCountPtr));
						case 21: return FunctionPtr(new FunctionImpl<const void*(BufferTable::*)() const>(&BufferTable::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 2760, 2078, 3141, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 4039, 152, 1585, 3961, 157, 4073, 4073, 158, 158, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 1877, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3960, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionBufferTable::constructor_bases[];
	constexpr uint16_t ReflectionBufferTable::constructor_arg_types[];
	constexpr uint16_t ReflectionBufferTable::constructor_arg_names[];
	constexpr uint16_t ReflectionBufferTable::constructor_arg_values[];
	constexpr uint8_t ReflectionBufferTable::function_flags[];
	constexpr uint16_t ReflectionBufferTable::function_names[];
	constexpr uint16_t ReflectionBufferTable::function_types[];
	constexpr uint16_t ReflectionBufferTable::function_bases[];
	constexpr uint16_t ReflectionBufferTable::function_arg_types[];
	constexpr uint16_t ReflectionBufferTable::function_arg_names[];
	constexpr uint16_t ReflectionBufferTable::function_arg_values[];
	constexpr uint16_t ReflectionBufferTable::callback_names[];
	constexpr uint16_t ReflectionBufferTable::callback_types[];
	constexpr uint16_t ReflectionBufferTable::callback_bases[];
	constexpr uint16_t ReflectionBufferTable::callback_arg_types[];
	constexpr uint16_t ReflectionBufferTable::callback_arg_names[];
	constexpr uint16_t ReflectionBufferTable::enum_names[];
	constexpr uint16_t ReflectionBufferTable::enum_bases[];
	constexpr uint16_t ReflectionBufferTable::enum_var_names[];
	static ReflectionBufferTable reflection_buffer_table;
	
	// Tellusim::D3D12Buffer
	class ReflectionD3D12Buffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Buffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Buffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Buffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(D3D12Buffer::*)(Buffer::Flags, ID3D12Resource*, uint32_t)>(&D3D12Buffer::create));
						case 1: return FunctionPtr(new FunctionImpl<ID3D12Resource*(D3D12Buffer::*)() const>(&D3D12Buffer::getD3D12Buffer));
						case 2: return FunctionPtr(new FunctionImpl<size_t(D3D12Buffer::*)() const>(&D3D12Buffer::getUnorderedAccessView));
						case 3: return FunctionPtr(new FunctionImpl<size_t(D3D12Buffer::*)() const>(&D3D12Buffer::getShaderResourceView));
						case 4: return FunctionPtr(new FunctionImpl<uint64_t(D3D12Buffer::*)() const>(&D3D12Buffer::getBufferAddress));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(D3D12Buffer::*)(uint32_t)>(&D3D12Buffer::setBufferState));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Buffer::*)() const>(&D3D12Buffer::getBufferState));
						case 7: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Buffer::*)() const>(&D3D12Buffer::getSharedHandle));
						case 8: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Buffer::*)() const>(&D3D12Buffer::getInteropHandle));
						case 9: return FunctionPtr(new FunctionImpl<D3D12Buffer(D3D12Buffer::*)() const>(&D3D12Buffer::clonePtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(D3D12Buffer::*)()>(&D3D12Buffer::clearPtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(D3D12Buffer::*)()>(&D3D12Buffer::destroyPtr));
						case 12: return FunctionPtr(new FunctionImpl<D3D12Buffer&(D3D12Buffer::*)()>(&D3D12Buffer::acquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<D3D12Buffer&(D3D12Buffer::*)()>(&D3D12Buffer::unacquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(D3D12Buffer::*)() const>(&D3D12Buffer::isValidPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(D3D12Buffer::*)() const>(&D3D12Buffer::isOwnerPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(D3D12Buffer::*)() const>(&D3D12Buffer::isConstPtr));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Buffer::*)() const>(&D3D12Buffer::getCountPtr));
						case 18: return FunctionPtr(new FunctionImpl<const void*(D3D12Buffer::*)() const>(&D3D12Buffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2255, 2886, 2755, 2144, 3535, 2150, 2757, 2441, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 832, 3961, 3961, 4044, 4073, 4039, 4074, 4074, 403, 4073, 4073, 404, 404, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 155, 832, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1593, 3983, 3983 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Buffer::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Buffer::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Buffer::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Buffer::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Buffer::function_flags[];
	constexpr uint16_t ReflectionD3D12Buffer::function_names[];
	constexpr uint16_t ReflectionD3D12Buffer::function_types[];
	constexpr uint16_t ReflectionD3D12Buffer::function_bases[];
	constexpr uint16_t ReflectionD3D12Buffer::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Buffer::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Buffer::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Buffer::callback_names[];
	constexpr uint16_t ReflectionD3D12Buffer::callback_types[];
	constexpr uint16_t ReflectionD3D12Buffer::callback_bases[];
	constexpr uint16_t ReflectionD3D12Buffer::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Buffer::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Buffer::enum_names[];
	constexpr uint16_t ReflectionD3D12Buffer::enum_bases[];
	constexpr uint16_t ReflectionD3D12Buffer::enum_var_names[];
	static ReflectionD3D12Buffer reflection_d3d12_buffer;
	
	// Tellusim::D3D11Buffer
	class ReflectionD3D11Buffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Buffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Buffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Buffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(D3D11Buffer::*)(Buffer::Flags, ID3D11Buffer*)>(&D3D11Buffer::create));
						case 1: return FunctionPtr(new FunctionImpl<ID3D11Buffer*(D3D11Buffer::*)() const>(&D3D11Buffer::getD3D11Buffer));
						case 2: return FunctionPtr(new FunctionImpl<ID3D11UnorderedAccessView*(D3D11Buffer::*)() const>(&D3D11Buffer::getUnorderedAccessView));
						case 3: return FunctionPtr(new FunctionImpl<ID3D11ShaderResourceView*(D3D11Buffer::*)() const>(&D3D11Buffer::getShaderResourceView));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(D3D11Buffer::*)() const>(&D3D11Buffer::getInteropHandle));
						case 5: return FunctionPtr(new FunctionImpl<D3D11Buffer(D3D11Buffer::*)() const>(&D3D11Buffer::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(D3D11Buffer::*)()>(&D3D11Buffer::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(D3D11Buffer::*)()>(&D3D11Buffer::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<D3D11Buffer&(D3D11Buffer::*)()>(&D3D11Buffer::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<D3D11Buffer&(D3D11Buffer::*)()>(&D3D11Buffer::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(D3D11Buffer::*)() const>(&D3D11Buffer::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(D3D11Buffer::*)() const>(&D3D11Buffer::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(D3D11Buffer::*)() const>(&D3D11Buffer::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Buffer::*)() const>(&D3D11Buffer::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(D3D11Buffer::*)() const>(&D3D11Buffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2250, 2886, 2755, 2441, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 820, 828, 826, 4074, 389, 4073, 4073, 390, 390, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_arg_types[] = { 155, 820 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1593 };
			static constexpr uint16_t function_arg_values[] = { 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Buffer::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Buffer::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Buffer::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Buffer::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Buffer::function_flags[];
	constexpr uint16_t ReflectionD3D11Buffer::function_names[];
	constexpr uint16_t ReflectionD3D11Buffer::function_types[];
	constexpr uint16_t ReflectionD3D11Buffer::function_bases[];
	constexpr uint16_t ReflectionD3D11Buffer::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Buffer::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Buffer::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Buffer::callback_names[];
	constexpr uint16_t ReflectionD3D11Buffer::callback_types[];
	constexpr uint16_t ReflectionD3D11Buffer::callback_bases[];
	constexpr uint16_t ReflectionD3D11Buffer::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Buffer::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Buffer::enum_names[];
	constexpr uint16_t ReflectionD3D11Buffer::enum_bases[];
	constexpr uint16_t ReflectionD3D11Buffer::enum_var_names[];
	static ReflectionD3D11Buffer reflection_d3d11_buffer;
	
	// Tellusim::MTLBuffer
	class ReflectionMTLBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLBuffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(MTLBuffer::*)(Buffer::Flags, void*)>(&MTLBuffer::create));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(MTLBuffer::*)() const>(&MTLBuffer::getMTLBuffer));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLBuffer::*)() const>(&MTLBuffer::getSharedPtr));
						case 3: return FunctionPtr(new FunctionImpl<MTLBuffer(MTLBuffer::*)() const>(&MTLBuffer::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MTLBuffer::*)()>(&MTLBuffer::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLBuffer::*)()>(&MTLBuffer::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<MTLBuffer&(MTLBuffer::*)()>(&MTLBuffer::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLBuffer&(MTLBuffer::*)()>(&MTLBuffer::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(MTLBuffer::*)() const>(&MTLBuffer::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLBuffer::*)() const>(&MTLBuffer::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLBuffer::*)() const>(&MTLBuffer::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(MTLBuffer::*)() const>(&MTLBuffer::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(MTLBuffer::*)() const>(&MTLBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2475, 2759, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4074, 4074, 899, 4073, 4073, 900, 900, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_arg_types[] = { 155, 4074 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1593 };
			static constexpr uint16_t function_arg_values[] = { 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLBuffer::constructor_bases[];
	constexpr uint16_t ReflectionMTLBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLBuffer::function_flags[];
	constexpr uint16_t ReflectionMTLBuffer::function_names[];
	constexpr uint16_t ReflectionMTLBuffer::function_types[];
	constexpr uint16_t ReflectionMTLBuffer::function_bases[];
	constexpr uint16_t ReflectionMTLBuffer::function_arg_types[];
	constexpr uint16_t ReflectionMTLBuffer::function_arg_names[];
	constexpr uint16_t ReflectionMTLBuffer::function_arg_values[];
	constexpr uint16_t ReflectionMTLBuffer::callback_names[];
	constexpr uint16_t ReflectionMTLBuffer::callback_types[];
	constexpr uint16_t ReflectionMTLBuffer::callback_bases[];
	constexpr uint16_t ReflectionMTLBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionMTLBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionMTLBuffer::enum_names[];
	constexpr uint16_t ReflectionMTLBuffer::enum_bases[];
	constexpr uint16_t ReflectionMTLBuffer::enum_var_names[];
	static ReflectionMTLBuffer reflection_mtl_buffer;
	
	// Tellusim::VKBuffer
	class ReflectionVKBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKBuffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(VKBuffer::*)(Buffer::Flags, size_t, VkBuffer, uint32_t)>(&VKBuffer::create));
						case 1: return FunctionPtr(new FunctionImpl<VkBuffer(VKBuffer::*)() const>(&VKBuffer::getVKBuffer));
						case 2: return FunctionPtr(new FunctionImpl<VkBufferView(VKBuffer::*)() const>(&VKBuffer::getBufferView));
						case 3: return FunctionPtr(new FunctionImpl<uint64_t(VKBuffer::*)() const>(&VKBuffer::getBufferAddress));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(VKBuffer::*)(uint32_t)>(&VKBuffer::setBufferAccess));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(VKBuffer::*)() const>(&VKBuffer::getBufferAccess));
						case 6: return FunctionPtr(new FunctionVoidImpl<void*(VKBuffer::*)() const>(&VKBuffer::getSharedPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void*(VKBuffer::*)() const>(&VKBuffer::getInteropHandle));
						case 8: return FunctionPtr(new FunctionImpl<VKBuffer(VKBuffer::*)() const>(&VKBuffer::clonePtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(VKBuffer::*)()>(&VKBuffer::clearPtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(VKBuffer::*)()>(&VKBuffer::destroyPtr));
						case 11: return FunctionPtr(new FunctionImpl<VKBuffer&(VKBuffer::*)()>(&VKBuffer::acquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<VKBuffer&(VKBuffer::*)()>(&VKBuffer::unacquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(VKBuffer::*)() const>(&VKBuffer::isValidPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(VKBuffer::*)() const>(&VKBuffer::isOwnerPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(VKBuffer::*)() const>(&VKBuffer::isConstPtr));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(VKBuffer::*)() const>(&VKBuffer::getCountPtr));
						case 17: return FunctionPtr(new FunctionImpl<const void*(VKBuffer::*)() const>(&VKBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2893, 2151, 2144, 3534, 2143, 2759, 2441, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1450, 1451, 4044, 4073, 4039, 4074, 4074, 1396, 4073, 4073, 1397, 1397, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
			static constexpr uint16_t function_arg_types[] = { 155, 3961, 1450, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 3960, 1593, 1504, 1504 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKBuffer::constructor_bases[];
	constexpr uint16_t ReflectionVKBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionVKBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionVKBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionVKBuffer::function_flags[];
	constexpr uint16_t ReflectionVKBuffer::function_names[];
	constexpr uint16_t ReflectionVKBuffer::function_types[];
	constexpr uint16_t ReflectionVKBuffer::function_bases[];
	constexpr uint16_t ReflectionVKBuffer::function_arg_types[];
	constexpr uint16_t ReflectionVKBuffer::function_arg_names[];
	constexpr uint16_t ReflectionVKBuffer::function_arg_values[];
	constexpr uint16_t ReflectionVKBuffer::callback_names[];
	constexpr uint16_t ReflectionVKBuffer::callback_types[];
	constexpr uint16_t ReflectionVKBuffer::callback_bases[];
	constexpr uint16_t ReflectionVKBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionVKBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionVKBuffer::enum_names[];
	constexpr uint16_t ReflectionVKBuffer::enum_bases[];
	constexpr uint16_t ReflectionVKBuffer::enum_var_names[];
	static ReflectionVKBuffer reflection_vk_buffer;
	
	// Tellusim::GLBuffer
	class ReflectionGLBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLBuffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLBuffer::*)(Buffer::Flags, uint32_t, uint32_t)>(&GLBuffer::create));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(GLBuffer::*)() const>(&GLBuffer::getTarget));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(GLBuffer::*)() const>(&GLBuffer::getBufferID));
						case 3: return FunctionPtr(new FunctionImpl<GLBuffer(GLBuffer::*)() const>(&GLBuffer::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(GLBuffer::*)()>(&GLBuffer::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLBuffer::*)()>(&GLBuffer::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<GLBuffer&(GLBuffer::*)()>(&GLBuffer::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<GLBuffer&(GLBuffer::*)()>(&GLBuffer::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(GLBuffer::*)() const>(&GLBuffer::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(GLBuffer::*)() const>(&GLBuffer::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(GLBuffer::*)() const>(&GLBuffer::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(GLBuffer::*)() const>(&GLBuffer::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(GLBuffer::*)() const>(&GLBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2815, 2148, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 779, 4073, 4073, 780, 780, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 155, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 4004, 1594 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLBuffer::constructor_bases[];
	constexpr uint16_t ReflectionGLBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionGLBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionGLBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionGLBuffer::function_flags[];
	constexpr uint16_t ReflectionGLBuffer::function_names[];
	constexpr uint16_t ReflectionGLBuffer::function_types[];
	constexpr uint16_t ReflectionGLBuffer::function_bases[];
	constexpr uint16_t ReflectionGLBuffer::function_arg_types[];
	constexpr uint16_t ReflectionGLBuffer::function_arg_names[];
	constexpr uint16_t ReflectionGLBuffer::function_arg_values[];
	constexpr uint16_t ReflectionGLBuffer::callback_names[];
	constexpr uint16_t ReflectionGLBuffer::callback_types[];
	constexpr uint16_t ReflectionGLBuffer::callback_bases[];
	constexpr uint16_t ReflectionGLBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionGLBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionGLBuffer::enum_names[];
	constexpr uint16_t ReflectionGLBuffer::enum_bases[];
	constexpr uint16_t ReflectionGLBuffer::enum_var_names[];
	static ReflectionGLBuffer reflection_gl_buffer;
	
	// Tellusim::GLESBuffer
	class ReflectionGLESBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLESBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLESBuffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLESBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLESBuffer::*)(Buffer::Flags, uint32_t, uint32_t)>(&GLESBuffer::create));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(GLESBuffer::*)() const>(&GLESBuffer::getTarget));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(GLESBuffer::*)() const>(&GLESBuffer::getBufferID));
						case 3: return FunctionPtr(new FunctionImpl<GLESBuffer(GLESBuffer::*)() const>(&GLESBuffer::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(GLESBuffer::*)()>(&GLESBuffer::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLESBuffer::*)()>(&GLESBuffer::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<GLESBuffer&(GLESBuffer::*)()>(&GLESBuffer::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<GLESBuffer&(GLESBuffer::*)()>(&GLESBuffer::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(GLESBuffer::*)() const>(&GLESBuffer::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(GLESBuffer::*)() const>(&GLESBuffer::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(GLESBuffer::*)() const>(&GLESBuffer::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(GLESBuffer::*)() const>(&GLESBuffer::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(GLESBuffer::*)() const>(&GLESBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2815, 2148, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 783, 4073, 4073, 784, 784, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 155, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 4004, 1594 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLESBuffer::constructor_bases[];
	constexpr uint16_t ReflectionGLESBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionGLESBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionGLESBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionGLESBuffer::function_flags[];
	constexpr uint16_t ReflectionGLESBuffer::function_names[];
	constexpr uint16_t ReflectionGLESBuffer::function_types[];
	constexpr uint16_t ReflectionGLESBuffer::function_bases[];
	constexpr uint16_t ReflectionGLESBuffer::function_arg_types[];
	constexpr uint16_t ReflectionGLESBuffer::function_arg_names[];
	constexpr uint16_t ReflectionGLESBuffer::function_arg_values[];
	constexpr uint16_t ReflectionGLESBuffer::callback_names[];
	constexpr uint16_t ReflectionGLESBuffer::callback_types[];
	constexpr uint16_t ReflectionGLESBuffer::callback_bases[];
	constexpr uint16_t ReflectionGLESBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionGLESBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionGLESBuffer::enum_names[];
	constexpr uint16_t ReflectionGLESBuffer::enum_bases[];
	constexpr uint16_t ReflectionGLESBuffer::enum_var_names[];
	static ReflectionGLESBuffer reflection_gles_buffer;
	
	// Tellusim::CUBuffer
	class ReflectionCUBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CUBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CUBuffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CUBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<size_t(CUBuffer::*)() const>(&CUBuffer::getBufferPtr));
						case 1: return FunctionPtr(new FunctionImpl<uint8_t*(CUBuffer::*)() const>(&CUBuffer::getBufferData));
						case 2: return FunctionPtr(new FunctionImpl<CUevent(CUBuffer::*)() const>(&CUBuffer::getBufferEvent));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(CUBuffer::*)() const>(&CUBuffer::getArrayFormat));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(CUBuffer::*)() const>(&CUBuffer::getArrayChannels));
						case 5: return FunctionPtr(new FunctionImpl<CUexternalMemory(CUBuffer::*)() const>(&CUBuffer::getSharedMemory));
						case 6: return FunctionPtr(new FunctionImpl<CUBuffer(CUBuffer::*)() const>(&CUBuffer::clonePtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(CUBuffer::*)()>(&CUBuffer::clearPtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(CUBuffer::*)()>(&CUBuffer::destroyPtr));
						case 9: return FunctionPtr(new FunctionImpl<CUBuffer&(CUBuffer::*)()>(&CUBuffer::acquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<CUBuffer&(CUBuffer::*)()>(&CUBuffer::unacquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(CUBuffer::*)() const>(&CUBuffer::isValidPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(CUBuffer::*)() const>(&CUBuffer::isOwnerPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(CUBuffer::*)() const>(&CUBuffer::isConstPtr));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(CUBuffer::*)() const>(&CUBuffer::getCountPtr));
						case 15: return FunctionPtr(new FunctionImpl<const void*(CUBuffer::*)() const>(&CUBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2149, 2145, 2147, 2095, 2094, 2758, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 3961, 4046, 210, 4039, 4039, 211, 200, 4073, 4073, 201, 201, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCUBuffer::constructor_bases[];
	constexpr uint16_t ReflectionCUBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionCUBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionCUBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionCUBuffer::function_flags[];
	constexpr uint16_t ReflectionCUBuffer::function_names[];
	constexpr uint16_t ReflectionCUBuffer::function_types[];
	constexpr uint16_t ReflectionCUBuffer::function_bases[];
	constexpr uint16_t ReflectionCUBuffer::function_arg_types[];
	constexpr uint16_t ReflectionCUBuffer::function_arg_names[];
	constexpr uint16_t ReflectionCUBuffer::function_arg_values[];
	constexpr uint16_t ReflectionCUBuffer::callback_names[];
	constexpr uint16_t ReflectionCUBuffer::callback_types[];
	constexpr uint16_t ReflectionCUBuffer::callback_bases[];
	constexpr uint16_t ReflectionCUBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionCUBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionCUBuffer::enum_names[];
	constexpr uint16_t ReflectionCUBuffer::enum_bases[];
	constexpr uint16_t ReflectionCUBuffer::enum_var_names[];
	static ReflectionCUBuffer reflection_cu_buffer;
	
	// Tellusim::HIPBuffer
	class ReflectionHIPBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return HIPBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<HIPBuffer, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<HIPBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(HIPBuffer::*)() const>(&HIPBuffer::getBufferPtr));
						case 1: return FunctionPtr(new FunctionImpl<uint8_t*(HIPBuffer::*)() const>(&HIPBuffer::getBufferData));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(HIPBuffer::*)() const>(&HIPBuffer::getBufferEvent));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(HIPBuffer::*)() const>(&HIPBuffer::getArrayFormat));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(HIPBuffer::*)() const>(&HIPBuffer::getArrayChannels));
						case 5: return FunctionPtr(new FunctionVoidImpl<void*(HIPBuffer::*)() const>(&HIPBuffer::getSharedMemory));
						case 6: return FunctionPtr(new FunctionImpl<HIPBuffer(HIPBuffer::*)() const>(&HIPBuffer::clonePtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(HIPBuffer::*)()>(&HIPBuffer::clearPtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(HIPBuffer::*)()>(&HIPBuffer::destroyPtr));
						case 9: return FunctionPtr(new FunctionImpl<HIPBuffer&(HIPBuffer::*)()>(&HIPBuffer::acquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<HIPBuffer&(HIPBuffer::*)()>(&HIPBuffer::unacquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(HIPBuffer::*)() const>(&HIPBuffer::isValidPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(HIPBuffer::*)() const>(&HIPBuffer::isOwnerPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(HIPBuffer::*)() const>(&HIPBuffer::isConstPtr));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(HIPBuffer::*)() const>(&HIPBuffer::getCountPtr));
						case 15: return FunctionPtr(new FunctionImpl<const void*(HIPBuffer::*)() const>(&HIPBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2149, 2145, 2147, 2095, 2094, 2758, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4046, 4074, 4039, 4039, 4074, 804, 4073, 4073, 805, 805, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionHIPBuffer::constructor_bases[];
	constexpr uint16_t ReflectionHIPBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionHIPBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionHIPBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionHIPBuffer::function_flags[];
	constexpr uint16_t ReflectionHIPBuffer::function_names[];
	constexpr uint16_t ReflectionHIPBuffer::function_types[];
	constexpr uint16_t ReflectionHIPBuffer::function_bases[];
	constexpr uint16_t ReflectionHIPBuffer::function_arg_types[];
	constexpr uint16_t ReflectionHIPBuffer::function_arg_names[];
	constexpr uint16_t ReflectionHIPBuffer::function_arg_values[];
	constexpr uint16_t ReflectionHIPBuffer::callback_names[];
	constexpr uint16_t ReflectionHIPBuffer::callback_types[];
	constexpr uint16_t ReflectionHIPBuffer::callback_bases[];
	constexpr uint16_t ReflectionHIPBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionHIPBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionHIPBuffer::enum_names[];
	constexpr uint16_t ReflectionHIPBuffer::enum_bases[];
	constexpr uint16_t ReflectionHIPBuffer::enum_var_names[];
	static ReflectionHIPBuffer reflection_hip_buffer;
	
	// Tellusim::FUBuffer
	class ReflectionFUBuffer : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUBuffer::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_buffer;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUBuffer, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUBuffer, TypeList<const Array<Buffer>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUBuffer>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUBuffer::*)(uint32_t)>(&FUBuffer::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUBuffer::*)() const>(&FUBuffer::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUBuffer::*)() const>(&FUBuffer::getNumBuffers));
						case 3: return FunctionPtr(new FunctionImpl<const Buffer(FUBuffer::*)(uint32_t) const>(&FUBuffer::getBuffer));
						case 4: return FunctionPtr(new FunctionImpl<Buffer(FUBuffer::*)(uint32_t)>(&FUBuffer::getBuffer));
						case 5: return FunctionPtr(new FunctionImpl<FUBuffer(FUBuffer::*)() const>(&FUBuffer::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUBuffer::*)()>(&FUBuffer::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUBuffer::*)()>(&FUBuffer::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUBuffer&(FUBuffer::*)()>(&FUBuffer::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUBuffer&(FUBuffer::*)()>(&FUBuffer::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUBuffer::*)() const>(&FUBuffer::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUBuffer::*)() const>(&FUBuffer::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUBuffer::*)() const>(&FUBuffer::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUBuffer::*)() const>(&FUBuffer::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUBuffer::*)() const>(&FUBuffer::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1666, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 1595, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2566, 2142, 2142, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1709, 152, 526, 4073, 4073, 527, 527, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUBuffer::constructor_bases[];
	constexpr uint16_t ReflectionFUBuffer::constructor_arg_types[];
	constexpr uint16_t ReflectionFUBuffer::constructor_arg_names[];
	constexpr uint16_t ReflectionFUBuffer::constructor_arg_values[];
	constexpr uint8_t ReflectionFUBuffer::function_flags[];
	constexpr uint16_t ReflectionFUBuffer::function_names[];
	constexpr uint16_t ReflectionFUBuffer::function_types[];
	constexpr uint16_t ReflectionFUBuffer::function_bases[];
	constexpr uint16_t ReflectionFUBuffer::function_arg_types[];
	constexpr uint16_t ReflectionFUBuffer::function_arg_names[];
	constexpr uint16_t ReflectionFUBuffer::function_arg_values[];
	constexpr uint16_t ReflectionFUBuffer::callback_names[];
	constexpr uint16_t ReflectionFUBuffer::callback_types[];
	constexpr uint16_t ReflectionFUBuffer::callback_bases[];
	constexpr uint16_t ReflectionFUBuffer::callback_arg_types[];
	constexpr uint16_t ReflectionFUBuffer::callback_arg_names[];
	constexpr uint16_t ReflectionFUBuffer::enum_names[];
	constexpr uint16_t ReflectionFUBuffer::enum_bases[];
	constexpr uint16_t ReflectionFUBuffer::enum_var_names[];
	static ReflectionFUBuffer reflection_fu_buffer;
	
	// Tellusim::Command
	class ReflectionCommand : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Command::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Command, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Command>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Command::*)() const>(&Command::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Command::*)() const>(&Command::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Command::*)() const>(&Command::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Pipeline&)>(&Command::setPipeline));
						case 4: return FunctionPtr(new FunctionImpl<Pipeline(Command::*)() const>(&Command::getPipeline));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Viewport&)>(&Command::setViewport));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(const Viewport*, uint32_t)>(&Command::setViewports));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Scissor&)>(&Command::setScissor));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(const Scissor*, uint32_t)>(&Command::setScissors));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Sampler&)>(&Command::setSampler));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Sampler>&)>(&Command::setSamplers));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Sampler>&)>(&Command::setSamplers));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Texture&)>(&Command::setTexture));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Texture&, const Slice&)>(&Command::setTexture));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Texture>&)>(&Command::setTextures));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Texture>&)>(&Command::setTextures));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Texture&)>(&Command::setSurfaceTexture));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Texture&, const Slice&, Format)>(&Command::setSurfaceTexture, {}, Texture::null, {}, Tellusim::FormatUnknown));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Texture>&)>(&Command::setSurfaceTextures));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Texture>&)>(&Command::setSurfaceTextures));
						case 20: return FunctionPtr(new FunctionVoidImpl<void*(Command::*)(uint32_t, size_t)>(&Command::getUniformData));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const void*, size_t)>(&Command::setUniformData));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Buffer&, size_t, size_t)>(&Command::setUniformBuffer, {}, Buffer::null, 0, 0));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, size_t, bool)>(&Command::setUniformOffset, {}, {}, false));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&)>(&Command::setUniformBuffers));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&, const Array<size_t>&)>(&Command::setUniformBuffers));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&)>(&Command::setUniformBuffers));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&, const InitializerList<size_t>&)>(&Command::setUniformBuffers));
						case 28: return FunctionPtr(new FunctionVoidImpl<void*(Command::*)(uint32_t, size_t)>(&Command::getStorageData));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const void*, size_t)>(&Command::setStorageData));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Buffer&, size_t, size_t)>(&Command::setStorageBuffer, {}, Buffer::null, 0, 0));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, size_t, bool)>(&Command::setStorageOffset, {}, {}, false));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&)>(&Command::setStorageBuffers));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&, const Array<size_t>&)>(&Command::setStorageBuffers));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&)>(&Command::setStorageBuffers));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&, const InitializerList<size_t>&)>(&Command::setStorageBuffers));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Tracing&)>(&Command::setTracing));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Tracing>&)>(&Command::setTracings));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Tracing>&)>(&Command::setTracings));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Buffer&)>(&Command::setTexelBuffer));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&)>(&Command::setTexelBuffers));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&)>(&Command::setTexelBuffers));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, TextureTable&)>(&Command::setTextureTable));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<TextureTable>&)>(&Command::setTextureTables));
						case 44: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<TextureTable>&)>(&Command::setTextureTables));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, BufferTable&)>(&Command::setStorageTable));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<BufferTable>&)>(&Command::setStorageTables));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<BufferTable>&)>(&Command::setStorageTables));
						case 48: return FunctionPtr(new FunctionVoidImpl<void*(Command::*)(uint32_t, size_t)>(&Command::getVertexData));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const void*, size_t)>(&Command::setVertexData));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, Buffer&, size_t)>(&Command::setVertexBuffer, {}, Buffer::null, 0));
						case 51: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, size_t, bool)>(&Command::setVertexOffset, {}, {}, false));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&)>(&Command::setVertexBuffers));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const Array<Buffer>&, const Array<size_t>&)>(&Command::setVertexBuffers));
						case 54: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&)>(&Command::setVertexBuffers));
						case 55: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, const InitializerList<Buffer>&, const InitializerList<size_t>&)>(&Command::setVertexBuffers));
						case 56: return FunctionPtr(new FunctionVoidImpl<void*(Command::*)(Format, size_t)>(&Command::getIndexData));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Format, const void*, size_t)>(&Command::setIndexData));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Format, Buffer&, size_t)>(&Command::setIndexBuffer, (Format)0, Buffer::null, 0));
						case 59: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(size_t, bool)>(&Command::setIndexOffset, {}, false));
						case 60: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(const InitializerList<uint16_t>&)>(&Command::setIndices));
						case 61: return FunctionPtr(new FunctionVoidImpl<void*(Command::*)(size_t)>(&Command::getIndirectData));
						case 62: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(const void*, size_t)>(&Command::setIndirectData));
						case 63: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Buffer&, size_t)>(&Command::setIndirectBuffer, Buffer::null, 0));
						case 64: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(size_t, bool)>(&Command::setIndirectOffset, {}, false));
						case 65: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(const Color&)>(&Command::setBlendColor));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(float32_t, float32_t, float32_t, float32_t)>(&Command::setBlendColor));
						case 67: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t)>(&Command::setStencilRef));
						case 68: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, uint32_t)>(&Command::drawArrays, {}, 0));
						case 69: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, uint32_t, uint32_t, uint32_t)>(&Command::drawArraysInstanced, {}, {}, {}, 0));
						case 70: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, size_t)>(&Command::drawArraysIndirect, {}, sizeof(Command::DrawArraysIndirect)));
						case 71: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Buffer&, size_t, uint32_t, size_t)>(&Command::drawArraysIndirect, Buffer::null, {}, {}, sizeof(Command::DrawArraysIndirect)));
						case 72: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, uint32_t, int32_t)>(&Command::drawElements, {}, 0, 0));
						case 73: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, uint32_t, uint32_t)>(&Command::drawElementsInstanced));
						case 74: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, uint32_t, int32_t, uint32_t, uint32_t)>(&Command::drawElementsInstanced, {}, {}, {}, {}, 0));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, size_t)>(&Command::drawElementsIndirect, {}, sizeof(Command::DrawElementsIndirect)));
						case 76: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Buffer&, size_t, uint32_t, size_t)>(&Command::drawElementsIndirect, Buffer::null, {}, {}, sizeof(Command::DrawElementsIndirect)));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, uint32_t, uint32_t)>(&Command::drawMesh, {}, 1, 1));
						case 78: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(uint32_t, size_t)>(&Command::drawMeshIndirect, {}, sizeof(Command::DrawMeshIndirect)));
						case 79: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Buffer&, size_t, uint32_t, size_t)>(&Command::drawMeshIndirect, Buffer::null, {}, {}, sizeof(Command::DrawMeshIndirect)));
						case 80: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Buffer&, size_t)>(&Command::beginConditional));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(Command::*)()>(&Command::endConditional));
						case 82: return FunctionPtr(new FunctionImpl<bool(Command::*)(Query&)>(&Command::beginQuery));
						case 83: return FunctionPtr(new FunctionVoidImpl<void(Command::*)(Query&)>(&Command::endQuery));
						case 84: return FunctionPtr(new FunctionImpl<Command(Command::*)() const>(&Command::clonePtr));
						case 85: return FunctionPtr(new FunctionVoidImpl<void(Command::*)()>(&Command::clearPtr));
						case 86: return FunctionPtr(new FunctionVoidImpl<void(Command::*)()>(&Command::destroyPtr));
						case 87: return FunctionPtr(new FunctionImpl<Command&(Command::*)()>(&Command::acquirePtr));
						case 88: return FunctionPtr(new FunctionImpl<Command&(Command::*)()>(&Command::unacquirePtr));
						case 89: return FunctionPtr(new FunctionImpl<bool(Command::*)() const>(&Command::isValidPtr));
						case 90: return FunctionPtr(new FunctionImpl<bool(Command::*)() const>(&Command::isOwnerPtr));
						case 91: return FunctionPtr(new FunctionImpl<bool(Command::*)() const>(&Command::isConstPtr));
						case 92: return FunctionPtr(new FunctionImpl<uint32_t(Command::*)() const>(&Command::getCountPtr));
						case 93: return FunctionPtr(new FunctionImpl<const void*(Command::*)() const>(&Command::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 3777, 2662, 3941, 3942, 3820, 3822, 3810, 3815, 3815, 3885, 3885, 3900, 3900, 3865, 3865, 3866, 3866, 2881, 3918, 3916, 3922, 3917, 3917, 3917, 3917, 2789, 3849, 3847, 3853, 3848, 3848, 3848, 3848, 3906, 3910, 3910, 3875, 3876, 3876, 3898, 3899, 3899, 3854, 3855, 3855, 2909, 3932, 3928, 3933, 3930, 3930, 3930, 3930, 2423, 3668, 3666, 3669, 3670, 2428, 3673, 3672, 3674, 3526, 3526, 3843, 1982, 1984, 1983, 1983, 1985, 1987, 1987, 1986, 1986, 1989, 1990, 1990, 1577, 2006, 1578, 2008, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1131, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1585, 4073, 263, 4073, 4073, 264, 264, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 22, 24, 26, 30, 32, 34, 36, 39, 43, 46, 48, 51, 53, 56, 58, 61, 65, 68, 70, 73, 75, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 107, 110, 113, 115, 118, 120, 123, 125, 128, 131, 133, 134, 135, 137, 139, 141, 142, 146, 147, 149, 153, 155, 159, 162, 165, 170, 172, 176, 179, 181, 185, 187, 187, 188, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189 };
			static constexpr uint16_t function_arg_types[] = { 1132, 4039, 1859, 1860, 4039, 4039, 1835, 1836, 4039, 4039, 1193, 4039, 1690, 4039, 1786, 4039, 1294, 4039, 1294, 1839, 4039, 1695, 4039, 1787, 4039, 1294, 4039, 1294, 1839, 765, 4039, 1695, 4039, 1787, 4039, 3961, 4039, 1885, 3961, 4039, 153, 3961, 3961, 4039, 3961, 1585, 4039, 1666, 4039, 1666, 1702, 4039, 1783, 4039, 1783, 1791, 4039, 3961, 4039, 1885, 3961, 4039, 153, 3961, 3961, 4039, 3961, 1585, 4039, 1666, 4039, 1666, 1702, 4039, 1783, 4039, 1783, 1791, 4039, 1303, 4039, 1697, 4039, 1789, 4039, 153, 4039, 1666, 4039, 1783, 4039, 1300, 4039, 1696, 4039, 1788, 4039, 158, 4039, 1667, 4039, 1784, 4039, 3961, 4039, 1885, 3961, 4039, 153, 3961, 4039, 3961, 1585, 4039, 1666, 4039, 1666, 1702, 4039, 1783, 4039, 1783, 1791, 765, 3961, 765, 1885, 3961, 765, 153, 3961, 3961, 1585, 1792, 3961, 1885, 3961, 153, 3961, 3961, 1585, 1721, 2051, 2051, 2051, 2051, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 3961, 153, 3961, 4039, 3961, 4039, 4039, 3003, 4039, 4039, 4039, 4039, 4039, 3003, 4039, 4039, 4039, 3961, 153, 3961, 4039, 3961, 4039, 4039, 4039, 4039, 3961, 153, 3961, 4039, 3961, 153, 3961, 1168, 1168 };
			static constexpr uint16_t function_arg_names[] = { 3350, 2993, 4071, 4072, 3316, 2993, 3488, 3489, 3312, 2993, 3478, 2993, 3479, 2993, 3479, 2993, 4012, 2993, 4012, 3967, 2993, 4015, 2993, 4015, 2993, 4012, 2993, 4012, 3967, 2066, 2993, 4015, 2993, 4015, 2993, 3960, 2993, 3975, 3960, 2993, 1593, 3317, 3960, 2993, 3317, 3405, 2993, 1595, 2993, 1595, 3318, 2993, 1595, 2993, 1595, 3318, 2993, 3960, 2993, 3975, 3960, 2993, 1593, 3317, 3960, 2993, 3317, 3405, 2993, 1595, 2993, 1595, 3318, 2993, 1595, 2993, 1595, 3318, 2993, 4026, 2993, 4027, 2993, 4027, 2993, 1593, 2993, 1595, 2993, 1595, 2993, 4001, 2993, 4002, 2993, 4002, 2993, 4001, 2993, 4002, 2993, 4002, 2993, 3960, 2993, 3975, 3960, 2993, 1593, 3317, 2993, 3317, 3405, 2993, 1595, 2993, 1595, 3318, 2993, 1595, 2993, 1595, 3318, 2066, 3960, 2066, 3975, 3960, 2066, 1593, 3317, 3317, 3405, 2995, 3960, 3975, 3960, 1593, 3317, 3317, 3405, 1650, 3372, 2075, 1567, 1500, 3402, 3315, 1573, 3315, 1573, 3306, 1572, 3303, 3991, 1593, 3317, 3303, 3991, 3305, 1571, 1573, 3305, 1571, 3306, 3305, 1571, 1573, 3306, 1572, 3303, 3991, 1593, 3317, 3303, 3991, 4089, 2980, 1959, 3303, 3991, 1593, 3317, 3303, 3991, 1593, 3317, 3370, 3370 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 767, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2016, 0, 0, 0, 0, 0, 3, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 3963, 0, 0, 0, 3963, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3964, 0, 0, 0, 3964, 0, 6, 6, 0, 3965, 0, 0, 0, 3965, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCommand::constructor_bases[];
	constexpr uint16_t ReflectionCommand::constructor_arg_types[];
	constexpr uint16_t ReflectionCommand::constructor_arg_names[];
	constexpr uint16_t ReflectionCommand::constructor_arg_values[];
	constexpr uint8_t ReflectionCommand::function_flags[];
	constexpr uint16_t ReflectionCommand::function_names[];
	constexpr uint16_t ReflectionCommand::function_types[];
	constexpr uint16_t ReflectionCommand::function_bases[];
	constexpr uint16_t ReflectionCommand::function_arg_types[];
	constexpr uint16_t ReflectionCommand::function_arg_names[];
	constexpr uint16_t ReflectionCommand::function_arg_values[];
	constexpr uint16_t ReflectionCommand::callback_names[];
	constexpr uint16_t ReflectionCommand::callback_types[];
	constexpr uint16_t ReflectionCommand::callback_bases[];
	constexpr uint16_t ReflectionCommand::callback_arg_types[];
	constexpr uint16_t ReflectionCommand::callback_arg_names[];
	constexpr uint16_t ReflectionCommand::enum_names[];
	constexpr uint16_t ReflectionCommand::enum_bases[];
	constexpr uint16_t ReflectionCommand::enum_var_names[];
	static ReflectionCommand reflection_command;
	
	// Tellusim::D3D12Command
	class ReflectionD3D12Command : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Command::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_command;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Command, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Command>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D12GraphicsCommandList*(D3D12Command::*)() const>(&D3D12Command::getD3D12Command));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(D3D12Command::*)()>(&D3D12Command::update));
						case 2: return FunctionPtr(new FunctionImpl<D3D12Command(D3D12Command::*)() const>(&D3D12Command::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Command::*)()>(&D3D12Command::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D12Command::*)()>(&D3D12Command::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Command&(D3D12Command::*)()>(&D3D12Command::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<D3D12Command&(D3D12Command::*)()>(&D3D12Command::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Command::*)() const>(&D3D12Command::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Command::*)() const>(&D3D12Command::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(D3D12Command::*)() const>(&D3D12Command::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Command::*)() const>(&D3D12Command::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(D3D12Command::*)() const>(&D3D12Command::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2256, 4051, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 831, 4073, 405, 4073, 4073, 406, 406, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Command::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Command::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Command::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Command::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Command::function_flags[];
	constexpr uint16_t ReflectionD3D12Command::function_names[];
	constexpr uint16_t ReflectionD3D12Command::function_types[];
	constexpr uint16_t ReflectionD3D12Command::function_bases[];
	constexpr uint16_t ReflectionD3D12Command::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Command::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Command::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Command::callback_names[];
	constexpr uint16_t ReflectionD3D12Command::callback_types[];
	constexpr uint16_t ReflectionD3D12Command::callback_bases[];
	constexpr uint16_t ReflectionD3D12Command::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Command::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Command::enum_names[];
	constexpr uint16_t ReflectionD3D12Command::enum_bases[];
	constexpr uint16_t ReflectionD3D12Command::enum_var_names[];
	static ReflectionD3D12Command reflection_d3d12_command;
	
	// Tellusim::MTLCommand
	class ReflectionMTLCommand : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLCommand::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_command;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLCommand, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLCommand>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(MTLCommand::*)() const>(&MTLCommand::getEncoder));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MTLCommand::*)(void*, bool)>(&MTLCommand::flush, {}, false));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(MTLCommand::*)(bool, bool)>(&MTLCommand::flush, false, false));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MTLCommand::*)()>(&MTLCommand::update));
						case 4: return FunctionPtr(new FunctionImpl<MTLCommand(MTLCommand::*)() const>(&MTLCommand::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLCommand::*)()>(&MTLCommand::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(MTLCommand::*)()>(&MTLCommand::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLCommand&(MTLCommand::*)()>(&MTLCommand::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<MTLCommand&(MTLCommand::*)()>(&MTLCommand::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLCommand::*)() const>(&MTLCommand::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLCommand::*)() const>(&MTLCommand::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(MTLCommand::*)() const>(&MTLCommand::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(MTLCommand::*)() const>(&MTLCommand::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(MTLCommand::*)() const>(&MTLCommand::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2320, 2056, 2056, 4051, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4073, 4073, 4073, 901, 4073, 4073, 902, 902, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 4074, 1585, 1585, 1585 };
			static constexpr uint16_t function_arg_names[] = { 2004, 2009, 1902, 2009 };
			static constexpr uint16_t function_arg_values[] = { 0, 2016, 2016, 2016 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLCommand::constructor_bases[];
	constexpr uint16_t ReflectionMTLCommand::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLCommand::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLCommand::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLCommand::function_flags[];
	constexpr uint16_t ReflectionMTLCommand::function_names[];
	constexpr uint16_t ReflectionMTLCommand::function_types[];
	constexpr uint16_t ReflectionMTLCommand::function_bases[];
	constexpr uint16_t ReflectionMTLCommand::function_arg_types[];
	constexpr uint16_t ReflectionMTLCommand::function_arg_names[];
	constexpr uint16_t ReflectionMTLCommand::function_arg_values[];
	constexpr uint16_t ReflectionMTLCommand::callback_names[];
	constexpr uint16_t ReflectionMTLCommand::callback_types[];
	constexpr uint16_t ReflectionMTLCommand::callback_bases[];
	constexpr uint16_t ReflectionMTLCommand::callback_arg_types[];
	constexpr uint16_t ReflectionMTLCommand::callback_arg_names[];
	constexpr uint16_t ReflectionMTLCommand::enum_names[];
	constexpr uint16_t ReflectionMTLCommand::enum_bases[];
	constexpr uint16_t ReflectionMTLCommand::enum_var_names[];
	static ReflectionMTLCommand reflection_mtl_command;
	
	// Tellusim::VKCommand
	class ReflectionVKCommand : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKCommand::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_command;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKCommand, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKCommand>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<VkCommandBuffer(VKCommand::*)() const>(&VKCommand::getVKCommand));
						case 1: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCommand::*)() const>(&VKCommand::getSamplerDescriptor));
						case 2: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCommand::*)() const>(&VKCommand::getImageDescriptor));
						case 3: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCommand::*)() const>(&VKCommand::getBufferDescriptor));
						case 4: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCommand::*)() const>(&VKCommand::getTracingDescriptor));
						case 5: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCommand::*)() const>(&VKCommand::getTexelDescriptor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(VKCommand::*)()>(&VKCommand::update));
						case 7: return FunctionPtr(new FunctionImpl<VKCommand(VKCommand::*)() const>(&VKCommand::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(VKCommand::*)()>(&VKCommand::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(VKCommand::*)()>(&VKCommand::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<VKCommand&(VKCommand::*)()>(&VKCommand::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<VKCommand&(VKCommand::*)()>(&VKCommand::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(VKCommand::*)() const>(&VKCommand::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(VKCommand::*)() const>(&VKCommand::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(VKCommand::*)() const>(&VKCommand::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(VKCommand::*)() const>(&VKCommand::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(VKCommand::*)() const>(&VKCommand::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2894, 2725, 2420, 2146, 2867, 2820, 4051, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1452, 1453, 1453, 1453, 1453, 1453, 4073, 1398, 4073, 4073, 1399, 1399, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKCommand::constructor_bases[];
	constexpr uint16_t ReflectionVKCommand::constructor_arg_types[];
	constexpr uint16_t ReflectionVKCommand::constructor_arg_names[];
	constexpr uint16_t ReflectionVKCommand::constructor_arg_values[];
	constexpr uint8_t ReflectionVKCommand::function_flags[];
	constexpr uint16_t ReflectionVKCommand::function_names[];
	constexpr uint16_t ReflectionVKCommand::function_types[];
	constexpr uint16_t ReflectionVKCommand::function_bases[];
	constexpr uint16_t ReflectionVKCommand::function_arg_types[];
	constexpr uint16_t ReflectionVKCommand::function_arg_names[];
	constexpr uint16_t ReflectionVKCommand::function_arg_values[];
	constexpr uint16_t ReflectionVKCommand::callback_names[];
	constexpr uint16_t ReflectionVKCommand::callback_types[];
	constexpr uint16_t ReflectionVKCommand::callback_bases[];
	constexpr uint16_t ReflectionVKCommand::callback_arg_types[];
	constexpr uint16_t ReflectionVKCommand::callback_arg_names[];
	constexpr uint16_t ReflectionVKCommand::enum_names[];
	constexpr uint16_t ReflectionVKCommand::enum_bases[];
	constexpr uint16_t ReflectionVKCommand::enum_var_names[];
	static ReflectionVKCommand reflection_vk_command;
	
	// Tellusim::FUCommand
	class ReflectionFUCommand : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUCommand::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_command;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUCommand, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUCommand, TypeList<const Array<Command>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUCommand>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUCommand::*)(uint32_t)>(&FUCommand::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUCommand::*)() const>(&FUCommand::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUCommand::*)() const>(&FUCommand::getNumCommands));
						case 3: return FunctionPtr(new FunctionImpl<const Command(FUCommand::*)(uint32_t) const>(&FUCommand::getCommand));
						case 4: return FunctionPtr(new FunctionImpl<Command(FUCommand::*)(uint32_t)>(&FUCommand::getCommand));
						case 5: return FunctionPtr(new FunctionImpl<FUCommand(FUCommand::*)() const>(&FUCommand::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUCommand::*)()>(&FUCommand::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUCommand::*)()>(&FUCommand::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUCommand&(FUCommand::*)()>(&FUCommand::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUCommand&(FUCommand::*)()>(&FUCommand::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUCommand::*)() const>(&FUCommand::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUCommand::*)() const>(&FUCommand::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUCommand::*)() const>(&FUCommand::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUCommand::*)() const>(&FUCommand::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUCommand::*)() const>(&FUCommand::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1670, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 1654, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2570, 2220, 2220, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1722, 263, 528, 4073, 4073, 529, 529, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUCommand::constructor_bases[];
	constexpr uint16_t ReflectionFUCommand::constructor_arg_types[];
	constexpr uint16_t ReflectionFUCommand::constructor_arg_names[];
	constexpr uint16_t ReflectionFUCommand::constructor_arg_values[];
	constexpr uint8_t ReflectionFUCommand::function_flags[];
	constexpr uint16_t ReflectionFUCommand::function_names[];
	constexpr uint16_t ReflectionFUCommand::function_types[];
	constexpr uint16_t ReflectionFUCommand::function_bases[];
	constexpr uint16_t ReflectionFUCommand::function_arg_types[];
	constexpr uint16_t ReflectionFUCommand::function_arg_names[];
	constexpr uint16_t ReflectionFUCommand::function_arg_values[];
	constexpr uint16_t ReflectionFUCommand::callback_names[];
	constexpr uint16_t ReflectionFUCommand::callback_types[];
	constexpr uint16_t ReflectionFUCommand::callback_bases[];
	constexpr uint16_t ReflectionFUCommand::callback_arg_types[];
	constexpr uint16_t ReflectionFUCommand::callback_arg_names[];
	constexpr uint16_t ReflectionFUCommand::enum_names[];
	constexpr uint16_t ReflectionFUCommand::enum_bases[];
	constexpr uint16_t ReflectionFUCommand::enum_var_names[];
	static ReflectionFUCommand reflection_fu_command;
	
	// Tellusim::Compute
	class ReflectionCompute : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Compute::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Compute, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Compute>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Compute::*)() const>(&Compute::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Compute::*)() const>(&Compute::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Compute::*)() const>(&Compute::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Kernel&)>(&Compute::setKernel));
						case 4: return FunctionPtr(new FunctionImpl<Kernel(Compute::*)() const>(&Compute::getKernel));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Traversal&)>(&Compute::setTraversal));
						case 6: return FunctionPtr(new FunctionImpl<Traversal(Compute::*)() const>(&Compute::getTraversal));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Sampler&)>(&Compute::setSampler));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Sampler>&)>(&Compute::setSamplers));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Sampler>&)>(&Compute::setSamplers));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Texture&)>(&Compute::setTexture));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Texture&, const Slice&)>(&Compute::setTexture));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Texture>&)>(&Compute::setTextures));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Texture>&)>(&Compute::setTextures));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Texture&)>(&Compute::setSurfaceTexture));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Texture&, const Slice&, Format)>(&Compute::setSurfaceTexture, {}, Texture::null, {}, Tellusim::FormatUnknown));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Texture>&)>(&Compute::setSurfaceTextures));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Texture>&)>(&Compute::setSurfaceTextures));
						case 18: return FunctionPtr(new FunctionVoidImpl<void*(Compute::*)(uint32_t, size_t)>(&Compute::getUniformData));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const void*, size_t)>(&Compute::setUniformData));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Buffer&, size_t, size_t)>(&Compute::setUniformBuffer, {}, Buffer::null, 0, 0));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, size_t, bool)>(&Compute::setUniformOffset, {}, {}, false));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Buffer>&)>(&Compute::setUniformBuffers));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Buffer>&, const Array<size_t>&)>(&Compute::setUniformBuffers));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Buffer>&)>(&Compute::setUniformBuffers));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Buffer>&, const InitializerList<size_t>&)>(&Compute::setUniformBuffers));
						case 26: return FunctionPtr(new FunctionVoidImpl<void*(Compute::*)(uint32_t, size_t)>(&Compute::getStorageData));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const void*, size_t)>(&Compute::setStorageData));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Buffer&, size_t, size_t)>(&Compute::setStorageBuffer, {}, Buffer::null, 0, 0));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, size_t, bool)>(&Compute::setStorageOffset, {}, {}, false));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Buffer>&)>(&Compute::setStorageBuffers));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Buffer>&, const InitializerList<size_t>&)>(&Compute::setStorageBuffers));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Buffer>&)>(&Compute::setStorageBuffers));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Buffer>&, const Array<size_t>&)>(&Compute::setStorageBuffers));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Tracing&)>(&Compute::setTracing));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Tracing>&)>(&Compute::setTracings));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Tracing>&)>(&Compute::setTracings));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, Buffer&)>(&Compute::setTexelBuffer));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<Buffer>&)>(&Compute::setTexelBuffers));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<Buffer>&)>(&Compute::setTexelBuffers));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, TextureTable&)>(&Compute::setTextureTable));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<TextureTable>&)>(&Compute::setTextureTables));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<TextureTable>&)>(&Compute::setTextureTables));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, BufferTable&)>(&Compute::setStorageTable));
						case 44: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const Array<BufferTable>&)>(&Compute::setStorageTables));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, const InitializerList<BufferTable>&)>(&Compute::setStorageTables));
						case 46: return FunctionPtr(new FunctionVoidImpl<void*(Compute::*)(size_t)>(&Compute::getIndirectData));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const void*, size_t)>(&Compute::setIndirectData));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Buffer&, size_t)>(&Compute::setIndirectBuffer, Buffer::null, 0));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(size_t, bool)>(&Compute::setIndirectOffset, {}, false));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(uint32_t, uint32_t, uint32_t)>(&Compute::dispatch, {}, 1, 1));
						case 51: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const Texture&)>(&Compute::dispatch));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const Size&)>(&Compute::dispatch));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)()>(&Compute::dispatchIndirect));
						case 54: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, size_t, const void*, size_t)>(&Compute::setBuffer));
						case 55: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, const void*, size_t)>(&Compute::setBuffer));
						case 56: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, const void*)>(&Compute::setBuffer));
						case 57: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, size_t, Buffer&, size_t, size_t)>(&Compute::copyBuffer));
						case 58: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, size_t, Buffer&, size_t)>(&Compute::copyBuffer));
						case 59: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, Buffer&, size_t)>(&Compute::copyBuffer));
						case 60: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, Buffer&)>(&Compute::copyBuffer));
						case 61: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, Format, size_t, const void*, size_t)>(&Compute::clearBuffer));
						case 62: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, Format, const void*, size_t)>(&Compute::clearBuffer));
						case 63: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&, Format, const void*)>(&Compute::clearBuffer));
						case 64: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Buffer&)>(&Compute::clearBuffer));
						case 65: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Origin&, const Slice&, const Image&, const Slice&)>(&Compute::setTexture));
						case 66: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Origin&, const Image&)>(&Compute::setTexture));
						case 67: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Slice&, const Image&)>(&Compute::setTexture));
						case 68: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Image&)>(&Compute::setTexture));
						case 69: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Origin&, const Slice&, Texture&, const Region&, const Slice&)>(&Compute::copyTexture));
						case 70: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Origin&, Texture&, const Region&)>(&Compute::copyTexture));
						case 71: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Slice&, Texture&, const Slice&)>(&Compute::copyTexture));
						case 72: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, Texture&)>(&Compute::copyTexture));
						case 73: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Region&, const Slice&, const void*)>(&Compute::clearTexture));
						case 74: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Region&, const void*)>(&Compute::clearTexture));
						case 75: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const Slice&, const void*)>(&Compute::clearTexture));
						case 76: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Texture&, const void*)>(&Compute::clearTexture));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Texture&)>(&Compute::barrier));
						case 78: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Buffer&)>(&Compute::barrier));
						case 79: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const Array<Texture>&)>(&Compute::barrier));
						case 80: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const Array<Buffer>&)>(&Compute::barrier));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const InitializerList<Texture>&)>(&Compute::barrier));
						case 82: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(const InitializerList<Buffer>&)>(&Compute::barrier));
						case 83: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Buffer&, size_t)>(&Compute::beginConditional));
						case 84: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)()>(&Compute::endConditional));
						case 85: return FunctionPtr(new FunctionImpl<bool(Compute::*)(Query&)>(&Compute::beginQuery));
						case 86: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)(Query&)>(&Compute::endQuery));
						case 87: return FunctionPtr(new FunctionImpl<Compute(Compute::*)() const>(&Compute::clonePtr));
						case 88: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)()>(&Compute::clearPtr));
						case 89: return FunctionPtr(new FunctionVoidImpl<void(Compute::*)()>(&Compute::destroyPtr));
						case 90: return FunctionPtr(new FunctionImpl<Compute&(Compute::*)()>(&Compute::acquirePtr));
						case 91: return FunctionPtr(new FunctionImpl<Compute&(Compute::*)()>(&Compute::unacquirePtr));
						case 92: return FunctionPtr(new FunctionImpl<bool(Compute::*)() const>(&Compute::isValidPtr));
						case 93: return FunctionPtr(new FunctionImpl<bool(Compute::*)() const>(&Compute::isOwnerPtr));
						case 94: return FunctionPtr(new FunctionImpl<bool(Compute::*)() const>(&Compute::isConstPtr));
						case 95: return FunctionPtr(new FunctionImpl<uint32_t(Compute::*)() const>(&Compute::getCountPtr));
						case 96: return FunctionPtr(new FunctionImpl<const void*(Compute::*)() const>(&Compute::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 3695, 2462, 3914, 2877, 3810, 3815, 3815, 3885, 3885, 3900, 3900, 3865, 3865, 3866, 3866, 2881, 3918, 3916, 3922, 3917, 3917, 3917, 3917, 2789, 3849, 3847, 3853, 3848, 3848, 3848, 3848, 3906, 3910, 3910, 3875, 3876, 3876, 3898, 3899, 3899, 3854, 3855, 3855, 2428, 3673, 3672, 3674, 1975, 1975, 1975, 1976, 3533, 3533, 3533, 1891, 1891, 1891, 1891, 1617, 1617, 1617, 1617, 3885, 3885, 3885, 3885, 1897, 1897, 1897, 1897, 1640, 1640, 1640, 1640, 1569, 1569, 1569, 1569, 1569, 1569, 1577, 2006, 1578, 2008, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 856, 4073, 1309, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4074, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1585, 4073, 273, 4073, 4073, 274, 274, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 1, 2, 2, 4, 6, 8, 10, 13, 15, 17, 19, 23, 25, 27, 29, 32, 36, 39, 41, 44, 46, 49, 51, 54, 58, 61, 63, 66, 68, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 96, 98, 100, 102, 105, 106, 107, 107, 111, 114, 116, 121, 125, 128, 130, 135, 139, 142, 143, 148, 151, 154, 156, 162, 166, 170, 172, 176, 179, 182, 184, 185, 186, 187, 188, 189, 190, 192, 192, 193, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194 };
			static constexpr uint16_t function_arg_types[] = { 857, 1310, 4039, 1193, 4039, 1690, 4039, 1786, 4039, 1294, 4039, 1294, 1839, 4039, 1695, 4039, 1787, 4039, 1294, 4039, 1294, 1839, 765, 4039, 1695, 4039, 1787, 4039, 3961, 4039, 1885, 3961, 4039, 153, 3961, 3961, 4039, 3961, 1585, 4039, 1666, 4039, 1666, 1702, 4039, 1783, 4039, 1783, 1791, 4039, 3961, 4039, 1885, 3961, 4039, 153, 3961, 3961, 4039, 3961, 1585, 4039, 1783, 4039, 1783, 1791, 4039, 1666, 4039, 1666, 1702, 4039, 1303, 4039, 1697, 4039, 1789, 4039, 153, 4039, 1666, 4039, 1783, 4039, 1300, 4039, 1696, 4039, 1788, 4039, 158, 4039, 1667, 4039, 1784, 3961, 1885, 3961, 153, 3961, 3961, 1585, 4039, 4039, 4039, 1848, 1838, 153, 3961, 1885, 3961, 153, 1885, 3961, 153, 1885, 153, 3961, 153, 3961, 3961, 153, 3961, 153, 3961, 153, 153, 3961, 153, 153, 153, 765, 3961, 1885, 3961, 153, 765, 1885, 3961, 153, 765, 1885, 153, 1294, 1824, 1839, 1781, 1839, 1294, 1824, 1781, 1294, 1839, 1781, 1294, 1781, 1294, 1824, 1839, 1294, 1831, 1839, 1294, 1824, 1294, 1831, 1294, 1839, 1294, 1839, 1294, 1294, 1294, 1831, 1839, 1885, 1294, 1831, 1885, 1294, 1839, 1885, 1294, 1885, 1294, 153, 1695, 1666, 1787, 1783, 153, 3961, 1168, 1168 };
			static constexpr uint16_t function_arg_names[] = { 3229, 4031, 2993, 3478, 2993, 3479, 2993, 3479, 2993, 4012, 2993, 4012, 3967, 2993, 4015, 2993, 4015, 2993, 4012, 2993, 4012, 3967, 2066, 2993, 4015, 2993, 4015, 2993, 3960, 2993, 3975, 3960, 2993, 1593, 3317, 3960, 2993, 3317, 3405, 2993, 1595, 2993, 1595, 3318, 2993, 1595, 2993, 1595, 3318, 2993, 3960, 2993, 3975, 3960, 2993, 1593, 3317, 3960, 2993, 3317, 3405, 2993, 1595, 2993, 1595, 3318, 2993, 1595, 2993, 1595, 3318, 2993, 4026, 2993, 4027, 2993, 4027, 2993, 1593, 2993, 1595, 2993, 1595, 2993, 4001, 2993, 4002, 2993, 4002, 2993, 4001, 2993, 4002, 2993, 4002, 3960, 3975, 3960, 1593, 3317, 3317, 3405, 4089, 2980, 1959, 4012, 3960, 1593, 3317, 3975, 3960, 1593, 3975, 3960, 1593, 3975, 1593, 1965, 3975, 3980, 3960, 1593, 1965, 3975, 3960, 1593, 3975, 3960, 1593, 3975, 1593, 2066, 3317, 3975, 3960, 1593, 2066, 3975, 3960, 1593, 2066, 3975, 1593, 4012, 1966, 1967, 2989, 3982, 4012, 1966, 2989, 4012, 1967, 2989, 4012, 2989, 4012, 1966, 1967, 3975, 3981, 3982, 4012, 1966, 3975, 3981, 4012, 1967, 3975, 3982, 4012, 3975, 4012, 3403, 3967, 3975, 4012, 3403, 3975, 4012, 3967, 3975, 4012, 3975, 4012, 1593, 4015, 1595, 4015, 1595, 1593, 3317, 3370, 3370 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 767, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2016, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCompute::constructor_bases[];
	constexpr uint16_t ReflectionCompute::constructor_arg_types[];
	constexpr uint16_t ReflectionCompute::constructor_arg_names[];
	constexpr uint16_t ReflectionCompute::constructor_arg_values[];
	constexpr uint8_t ReflectionCompute::function_flags[];
	constexpr uint16_t ReflectionCompute::function_names[];
	constexpr uint16_t ReflectionCompute::function_types[];
	constexpr uint16_t ReflectionCompute::function_bases[];
	constexpr uint16_t ReflectionCompute::function_arg_types[];
	constexpr uint16_t ReflectionCompute::function_arg_names[];
	constexpr uint16_t ReflectionCompute::function_arg_values[];
	constexpr uint16_t ReflectionCompute::callback_names[];
	constexpr uint16_t ReflectionCompute::callback_types[];
	constexpr uint16_t ReflectionCompute::callback_bases[];
	constexpr uint16_t ReflectionCompute::callback_arg_types[];
	constexpr uint16_t ReflectionCompute::callback_arg_names[];
	constexpr uint16_t ReflectionCompute::enum_names[];
	constexpr uint16_t ReflectionCompute::enum_bases[];
	constexpr uint16_t ReflectionCompute::enum_var_names[];
	static ReflectionCompute reflection_compute;
	
	// Tellusim::D3D12Compute
	class ReflectionD3D12Compute : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Compute::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_compute;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Compute, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Compute>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D12GraphicsCommandList*(D3D12Compute::*)() const>(&D3D12Compute::getCommand));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(D3D12Compute::*)()>(&D3D12Compute::update));
						case 2: return FunctionPtr(new FunctionImpl<D3D12Compute(D3D12Compute::*)() const>(&D3D12Compute::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Compute::*)()>(&D3D12Compute::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D12Compute::*)()>(&D3D12Compute::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Compute&(D3D12Compute::*)()>(&D3D12Compute::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<D3D12Compute&(D3D12Compute::*)()>(&D3D12Compute::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Compute::*)() const>(&D3D12Compute::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Compute::*)() const>(&D3D12Compute::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(D3D12Compute::*)() const>(&D3D12Compute::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Compute::*)() const>(&D3D12Compute::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(D3D12Compute::*)() const>(&D3D12Compute::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2220, 4051, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 831, 4073, 407, 4073, 4073, 408, 408, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Compute::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Compute::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Compute::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Compute::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Compute::function_flags[];
	constexpr uint16_t ReflectionD3D12Compute::function_names[];
	constexpr uint16_t ReflectionD3D12Compute::function_types[];
	constexpr uint16_t ReflectionD3D12Compute::function_bases[];
	constexpr uint16_t ReflectionD3D12Compute::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Compute::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Compute::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Compute::callback_names[];
	constexpr uint16_t ReflectionD3D12Compute::callback_types[];
	constexpr uint16_t ReflectionD3D12Compute::callback_bases[];
	constexpr uint16_t ReflectionD3D12Compute::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Compute::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Compute::enum_names[];
	constexpr uint16_t ReflectionD3D12Compute::enum_bases[];
	constexpr uint16_t ReflectionD3D12Compute::enum_var_names[];
	static ReflectionD3D12Compute reflection_d3d12_compute;
	
	// Tellusim::MTLCompute
	class ReflectionMTLCompute : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLCompute::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_compute;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLCompute, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLCompute>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(MTLCompute::*)() const>(&MTLCompute::getEncoder));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(MTLCompute::*)(void*, bool)>(&MTLCompute::flush, {}, false));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(MTLCompute::*)(bool, bool)>(&MTLCompute::flush, false, false));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MTLCompute::*)()>(&MTLCompute::update));
						case 4: return FunctionPtr(new FunctionImpl<MTLCompute(MTLCompute::*)() const>(&MTLCompute::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLCompute::*)()>(&MTLCompute::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(MTLCompute::*)()>(&MTLCompute::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLCompute&(MTLCompute::*)()>(&MTLCompute::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<MTLCompute&(MTLCompute::*)()>(&MTLCompute::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLCompute::*)() const>(&MTLCompute::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLCompute::*)() const>(&MTLCompute::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(MTLCompute::*)() const>(&MTLCompute::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(MTLCompute::*)() const>(&MTLCompute::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(MTLCompute::*)() const>(&MTLCompute::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2320, 2056, 2056, 4051, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4073, 4073, 4073, 903, 4073, 4073, 904, 904, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 4074, 1585, 1585, 1585 };
			static constexpr uint16_t function_arg_names[] = { 2004, 2009, 1902, 2009 };
			static constexpr uint16_t function_arg_values[] = { 0, 2016, 2016, 2016 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLCompute::constructor_bases[];
	constexpr uint16_t ReflectionMTLCompute::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLCompute::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLCompute::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLCompute::function_flags[];
	constexpr uint16_t ReflectionMTLCompute::function_names[];
	constexpr uint16_t ReflectionMTLCompute::function_types[];
	constexpr uint16_t ReflectionMTLCompute::function_bases[];
	constexpr uint16_t ReflectionMTLCompute::function_arg_types[];
	constexpr uint16_t ReflectionMTLCompute::function_arg_names[];
	constexpr uint16_t ReflectionMTLCompute::function_arg_values[];
	constexpr uint16_t ReflectionMTLCompute::callback_names[];
	constexpr uint16_t ReflectionMTLCompute::callback_types[];
	constexpr uint16_t ReflectionMTLCompute::callback_bases[];
	constexpr uint16_t ReflectionMTLCompute::callback_arg_types[];
	constexpr uint16_t ReflectionMTLCompute::callback_arg_names[];
	constexpr uint16_t ReflectionMTLCompute::enum_names[];
	constexpr uint16_t ReflectionMTLCompute::enum_bases[];
	constexpr uint16_t ReflectionMTLCompute::enum_var_names[];
	static ReflectionMTLCompute reflection_mtl_compute;
	
	// Tellusim::VKCompute
	class ReflectionVKCompute : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKCompute::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_compute;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKCompute, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKCompute>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<VkCommandBuffer(VKCompute::*)() const>(&VKCompute::getCommand));
						case 1: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCompute::*)() const>(&VKCompute::getSamplerDescriptor));
						case 2: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCompute::*)() const>(&VKCompute::getImageDescriptor));
						case 3: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCompute::*)() const>(&VKCompute::getBufferDescriptor));
						case 4: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCompute::*)() const>(&VKCompute::getTracingDescriptor));
						case 5: return FunctionPtr(new FunctionImpl<VkDescriptorSet(VKCompute::*)() const>(&VKCompute::getTexelDescriptor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(VKCompute::*)()>(&VKCompute::update));
						case 7: return FunctionPtr(new FunctionImpl<VKCompute(VKCompute::*)() const>(&VKCompute::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(VKCompute::*)()>(&VKCompute::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(VKCompute::*)()>(&VKCompute::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<VKCompute&(VKCompute::*)()>(&VKCompute::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<VKCompute&(VKCompute::*)()>(&VKCompute::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(VKCompute::*)() const>(&VKCompute::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(VKCompute::*)() const>(&VKCompute::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(VKCompute::*)() const>(&VKCompute::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(VKCompute::*)() const>(&VKCompute::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(VKCompute::*)() const>(&VKCompute::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2220, 2725, 2420, 2146, 2867, 2820, 4051, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1452, 1453, 1453, 1453, 1453, 1453, 4073, 1400, 4073, 4073, 1401, 1401, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKCompute::constructor_bases[];
	constexpr uint16_t ReflectionVKCompute::constructor_arg_types[];
	constexpr uint16_t ReflectionVKCompute::constructor_arg_names[];
	constexpr uint16_t ReflectionVKCompute::constructor_arg_values[];
	constexpr uint8_t ReflectionVKCompute::function_flags[];
	constexpr uint16_t ReflectionVKCompute::function_names[];
	constexpr uint16_t ReflectionVKCompute::function_types[];
	constexpr uint16_t ReflectionVKCompute::function_bases[];
	constexpr uint16_t ReflectionVKCompute::function_arg_types[];
	constexpr uint16_t ReflectionVKCompute::function_arg_names[];
	constexpr uint16_t ReflectionVKCompute::function_arg_values[];
	constexpr uint16_t ReflectionVKCompute::callback_names[];
	constexpr uint16_t ReflectionVKCompute::callback_types[];
	constexpr uint16_t ReflectionVKCompute::callback_bases[];
	constexpr uint16_t ReflectionVKCompute::callback_arg_types[];
	constexpr uint16_t ReflectionVKCompute::callback_arg_names[];
	constexpr uint16_t ReflectionVKCompute::enum_names[];
	constexpr uint16_t ReflectionVKCompute::enum_bases[];
	constexpr uint16_t ReflectionVKCompute::enum_var_names[];
	static ReflectionVKCompute reflection_vk_compute;
	
	// Tellusim::FUCompute
	class ReflectionFUCompute : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUCompute::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_compute;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUCompute, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUCompute, TypeList<const Array<Compute>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUCompute>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUCompute::*)(uint32_t)>(&FUCompute::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUCompute::*)() const>(&FUCompute::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUCompute::*)() const>(&FUCompute::getNumComputes));
						case 3: return FunctionPtr(new FunctionImpl<const Compute(FUCompute::*)(uint32_t) const>(&FUCompute::getCompute));
						case 4: return FunctionPtr(new FunctionImpl<Compute(FUCompute::*)(uint32_t)>(&FUCompute::getCompute));
						case 5: return FunctionPtr(new FunctionImpl<FUCompute(FUCompute::*)() const>(&FUCompute::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUCompute::*)()>(&FUCompute::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUCompute::*)()>(&FUCompute::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUCompute&(FUCompute::*)()>(&FUCompute::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUCompute&(FUCompute::*)()>(&FUCompute::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUCompute::*)() const>(&FUCompute::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUCompute::*)() const>(&FUCompute::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUCompute::*)() const>(&FUCompute::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUCompute::*)() const>(&FUCompute::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUCompute::*)() const>(&FUCompute::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1671, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 1663, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2571, 2224, 2224, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1723, 273, 530, 4073, 4073, 531, 531, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUCompute::constructor_bases[];
	constexpr uint16_t ReflectionFUCompute::constructor_arg_types[];
	constexpr uint16_t ReflectionFUCompute::constructor_arg_names[];
	constexpr uint16_t ReflectionFUCompute::constructor_arg_values[];
	constexpr uint8_t ReflectionFUCompute::function_flags[];
	constexpr uint16_t ReflectionFUCompute::function_names[];
	constexpr uint16_t ReflectionFUCompute::function_types[];
	constexpr uint16_t ReflectionFUCompute::function_bases[];
	constexpr uint16_t ReflectionFUCompute::function_arg_types[];
	constexpr uint16_t ReflectionFUCompute::function_arg_names[];
	constexpr uint16_t ReflectionFUCompute::function_arg_values[];
	constexpr uint16_t ReflectionFUCompute::callback_names[];
	constexpr uint16_t ReflectionFUCompute::callback_types[];
	constexpr uint16_t ReflectionFUCompute::callback_bases[];
	constexpr uint16_t ReflectionFUCompute::callback_arg_types[];
	constexpr uint16_t ReflectionFUCompute::callback_arg_names[];
	constexpr uint16_t ReflectionFUCompute::enum_names[];
	constexpr uint16_t ReflectionFUCompute::enum_bases[];
	constexpr uint16_t ReflectionFUCompute::enum_var_names[];
	static ReflectionFUCompute reflection_fu_compute;
	
	// Tellusim::Context
	class ReflectionContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Context::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Context, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Context, TypeList<Platform, uint32_t>>((Platform)0, Maxu32));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Context>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Context::*)() const>(&Context::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Context::*)() const>(&Context::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Context::*)() const>(&Context::getIndex));
						case 3: return FunctionPtr(new FunctionImpl<bool(Context::*)() const>(&Context::isCreated));
						case 4: return FunctionPtr(new FunctionImpl<bool(Context::*)()>(&Context::create));
						case 5: return FunctionPtr(new FunctionImpl<bool(Context::*)()>(&Context::flush));
						case 6: return FunctionPtr(new FunctionImpl<bool(Context::*)()>(&Context::finish));
						case 7: return FunctionPtr(new FunctionImpl<Context(Context::*)() const>(&Context::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Context::*)()>(&Context::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(Context::*)()>(&Context::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<Context&(Context::*)()>(&Context::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<Context&(Context::*)()>(&Context::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(Context::*)() const>(&Context::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(Context::*)() const>(&Context::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(Context::*)() const>(&Context::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Context::*)() const>(&Context::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(Context::*)() const>(&Context::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1146, 4039 };
			static constexpr uint16_t constructor_arg_names[] = { 3352, 2993 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 984 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 3057, 1902, 2056, 2044, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 1585, 1585, 1585, 1585, 276, 4073, 4073, 277, 277, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionContext::constructor_bases[];
	constexpr uint16_t ReflectionContext::constructor_arg_types[];
	constexpr uint16_t ReflectionContext::constructor_arg_names[];
	constexpr uint16_t ReflectionContext::constructor_arg_values[];
	constexpr uint8_t ReflectionContext::function_flags[];
	constexpr uint16_t ReflectionContext::function_names[];
	constexpr uint16_t ReflectionContext::function_types[];
	constexpr uint16_t ReflectionContext::function_bases[];
	constexpr uint16_t ReflectionContext::function_arg_types[];
	constexpr uint16_t ReflectionContext::function_arg_names[];
	constexpr uint16_t ReflectionContext::function_arg_values[];
	constexpr uint16_t ReflectionContext::callback_names[];
	constexpr uint16_t ReflectionContext::callback_types[];
	constexpr uint16_t ReflectionContext::callback_bases[];
	constexpr uint16_t ReflectionContext::callback_arg_types[];
	constexpr uint16_t ReflectionContext::callback_arg_names[];
	constexpr uint16_t ReflectionContext::enum_names[];
	constexpr uint16_t ReflectionContext::enum_bases[];
	constexpr uint16_t ReflectionContext::enum_var_names[];
	static ReflectionContext reflection_context;
	
	// Tellusim::D3D12Context
	class ReflectionD3D12Context : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Context::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Context, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Context>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(D3D12Context::*)(ID3D12Device*, ID3D12CommandQueue*)>(&D3D12Context::create));
						case 1: return FunctionPtr(new FunctionImpl<IDXGIFactory4*(D3D12Context::*)() const>(&D3D12Context::getFactory));
						case 2: return FunctionPtr(new FunctionImpl<ID3D12Device*(D3D12Context::*)() const>(&D3D12Context::getDevice));
						case 3: return FunctionPtr(new FunctionImpl<ID3D12CommandQueue*(D3D12Context::*)() const>(&D3D12Context::getQueue));
						case 4: return FunctionPtr(new FunctionImpl<ID3D12GraphicsCommandList*(D3D12Context::*)() const>(&D3D12Context::getCommand));
						case 5: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&D3D12Context::getProcAddress));
						case 6: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&D3D12Context::error));
						case 7: return FunctionPtr(new FunctionImpl<D3D12Context(D3D12Context::*)() const>(&D3D12Context::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(D3D12Context::*)()>(&D3D12Context::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(D3D12Context::*)()>(&D3D12Context::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<D3D12Context&(D3D12Context::*)()>(&D3D12Context::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<D3D12Context&(D3D12Context::*)()>(&D3D12Context::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(D3D12Context::*)() const>(&D3D12Context::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(D3D12Context::*)() const>(&D3D12Context::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(D3D12Context::*)() const>(&D3D12Context::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Context::*)() const>(&D3D12Context::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(D3D12Context::*)() const>(&D3D12Context::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2326, 2298, 2690, 2220, 2686, 2010, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 836, 830, 829, 831, 4074, 1585, 409, 4073, 4073, 410, 410, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 830, 829, 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1969, 3371, 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Context::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Context::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Context::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Context::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Context::function_flags[];
	constexpr uint16_t ReflectionD3D12Context::function_names[];
	constexpr uint16_t ReflectionD3D12Context::function_types[];
	constexpr uint16_t ReflectionD3D12Context::function_bases[];
	constexpr uint16_t ReflectionD3D12Context::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Context::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Context::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Context::callback_names[];
	constexpr uint16_t ReflectionD3D12Context::callback_types[];
	constexpr uint16_t ReflectionD3D12Context::callback_bases[];
	constexpr uint16_t ReflectionD3D12Context::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Context::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Context::enum_names[];
	constexpr uint16_t ReflectionD3D12Context::enum_bases[];
	constexpr uint16_t ReflectionD3D12Context::enum_var_names[];
	static ReflectionD3D12Context reflection_d3d12_context;
	
	// Tellusim::D3D11Context
	class ReflectionD3D11Context : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Context::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Context, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Context>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(D3D11Context::*)(ID3D11Device*)>(&D3D11Context::create));
						case 1: return FunctionPtr(new FunctionImpl<IDXGIFactory*(D3D11Context::*)() const>(&D3D11Context::getFactory));
						case 2: return FunctionPtr(new FunctionImpl<ID3D11Device*(D3D11Context::*)() const>(&D3D11Context::getDevice));
						case 3: return FunctionPtr(new FunctionImpl<ID3D11DeviceContext*(D3D11Context::*)() const>(&D3D11Context::getD3D11Context));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&D3D11Context::getProcAddress));
						case 5: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&D3D11Context::error));
						case 6: return FunctionPtr(new FunctionImpl<D3D11Context(D3D11Context::*)() const>(&D3D11Context::clonePtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(D3D11Context::*)()>(&D3D11Context::clearPtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(D3D11Context::*)()>(&D3D11Context::destroyPtr));
						case 9: return FunctionPtr(new FunctionImpl<D3D11Context&(D3D11Context::*)()>(&D3D11Context::acquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<D3D11Context&(D3D11Context::*)()>(&D3D11Context::unacquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(D3D11Context::*)() const>(&D3D11Context::isValidPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(D3D11Context::*)() const>(&D3D11Context::isOwnerPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(D3D11Context::*)() const>(&D3D11Context::isConstPtr));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Context::*)() const>(&D3D11Context::getCountPtr));
						case 15: return FunctionPtr(new FunctionImpl<const void*(D3D11Context::*)() const>(&D3D11Context::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2326, 2298, 2251, 2686, 2010, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 835, 822, 823, 4074, 1585, 391, 4073, 4073, 392, 392, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 822, 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1969, 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Context::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Context::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Context::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Context::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Context::function_flags[];
	constexpr uint16_t ReflectionD3D11Context::function_names[];
	constexpr uint16_t ReflectionD3D11Context::function_types[];
	constexpr uint16_t ReflectionD3D11Context::function_bases[];
	constexpr uint16_t ReflectionD3D11Context::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Context::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Context::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Context::callback_names[];
	constexpr uint16_t ReflectionD3D11Context::callback_types[];
	constexpr uint16_t ReflectionD3D11Context::callback_bases[];
	constexpr uint16_t ReflectionD3D11Context::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Context::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Context::enum_names[];
	constexpr uint16_t ReflectionD3D11Context::enum_bases[];
	constexpr uint16_t ReflectionD3D11Context::enum_var_names[];
	static ReflectionD3D11Context reflection_d3d11_context;
	
	// Tellusim::MTLContext
	class ReflectionMTLContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(MTLContext::*)(void*, void*)>(&MTLContext::create));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getDevice));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getQueue));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getCommand));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getEncoder));
						case 5: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)(void*) const>(&MTLContext::getRenderEncoder));
						case 6: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getComputeEncoder));
						case 7: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getTracingEncoder));
						case 8: return FunctionPtr(new FunctionVoidImpl<void*(MTLContext::*)() const>(&MTLContext::getBlitEncoder));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(MTLContext::*)() const>(&MTLContext::endEncoder));
						case 10: return FunctionPtr(new FunctionImpl<MTLContext(MTLContext::*)() const>(&MTLContext::clonePtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(MTLContext::*)()>(&MTLContext::clearPtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(MTLContext::*)()>(&MTLContext::destroyPtr));
						case 13: return FunctionPtr(new FunctionImpl<MTLContext&(MTLContext::*)()>(&MTLContext::acquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<MTLContext&(MTLContext::*)()>(&MTLContext::unacquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(MTLContext::*)() const>(&MTLContext::isValidPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(MTLContext::*)() const>(&MTLContext::isOwnerPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(MTLContext::*)() const>(&MTLContext::isConstPtr));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(MTLContext::*)() const>(&MTLContext::getCountPtr));
						case 19: return FunctionPtr(new FunctionImpl<const void*(MTLContext::*)() const>(&MTLContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2298, 2690, 2220, 2320, 2704, 2225, 2868, 2130, 2007, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4074, 4074, 4074, 4074, 4074, 4074, 4074, 4074, 4073, 905, 4073, 4073, 906, 906, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4074, 4074, 4074 };
			static constexpr uint16_t function_arg_names[] = { 1969, 3371, 1962 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLContext::constructor_bases[];
	constexpr uint16_t ReflectionMTLContext::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLContext::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLContext::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLContext::function_flags[];
	constexpr uint16_t ReflectionMTLContext::function_names[];
	constexpr uint16_t ReflectionMTLContext::function_types[];
	constexpr uint16_t ReflectionMTLContext::function_bases[];
	constexpr uint16_t ReflectionMTLContext::function_arg_types[];
	constexpr uint16_t ReflectionMTLContext::function_arg_names[];
	constexpr uint16_t ReflectionMTLContext::function_arg_values[];
	constexpr uint16_t ReflectionMTLContext::callback_names[];
	constexpr uint16_t ReflectionMTLContext::callback_types[];
	constexpr uint16_t ReflectionMTLContext::callback_bases[];
	constexpr uint16_t ReflectionMTLContext::callback_arg_types[];
	constexpr uint16_t ReflectionMTLContext::callback_arg_names[];
	constexpr uint16_t ReflectionMTLContext::enum_names[];
	constexpr uint16_t ReflectionMTLContext::enum_bases[];
	constexpr uint16_t ReflectionMTLContext::enum_var_names[];
	static ReflectionMTLContext reflection_mtl_context;
	
	// Tellusim::VKContext
	class ReflectionVKContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(VKContext::*)(VkInstance, PFN_vkGetInstanceProcAddr, VkPhysicalDevice, VkDevice, uint32_t, uint32_t)>(&VKContext::create));
						case 1: return FunctionPtr(new FunctionImpl<VkInstance(VKContext::*)() const>(&VKContext::getInstance));
						case 2: return FunctionPtr(new FunctionImpl<VkPhysicalDevice(VKContext::*)() const>(&VKContext::getAdapter));
						case 3: return FunctionPtr(new FunctionImpl<VkDevice(VKContext::*)() const>(&VKContext::getDevice));
						case 4: return FunctionPtr(new FunctionImpl<VkQueue(VKContext::*)() const>(&VKContext::getQueue));
						case 5: return FunctionPtr(new FunctionImpl<VkCommandBuffer(VKContext::*)() const>(&VKContext::getCommand));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(VKContext::*)() const>(&VKContext::getFamily));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(VKContext::*)()>(&VKContext::getNumQueues));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(VKContext::*)(uint32_t)>(&VKContext::getQueueFlags));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(VKContext::*)(uint32_t)>(&VKContext::getQueueFamily));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(const char*)>(&VKContext::addContextExtension));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(const char*)>(&VKContext::addAdapterExtension));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(void*)>(&VKContext::addAdapterFeatures));
						case 13: return FunctionPtr(new FunctionImpl<PFN_vkGetInstanceProcAddr()>(&VKContext::getInstanceProcAddress));
						case 14: return FunctionPtr(new FunctionImpl<PFN_vkGetDeviceProcAddr()>(&VKContext::getDeviceProcAddress));
						case 15: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&VKContext::getProcAddress));
						case 16: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&VKContext::error));
						case 17: return FunctionPtr(new FunctionImpl<VKContext(VKContext::*)() const>(&VKContext::clonePtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(VKContext::*)()>(&VKContext::clearPtr));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(VKContext::*)()>(&VKContext::destroyPtr));
						case 20: return FunctionPtr(new FunctionImpl<VKContext&(VKContext::*)()>(&VKContext::acquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<VKContext&(VKContext::*)()>(&VKContext::unacquirePtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(VKContext::*)() const>(&VKContext::isValidPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(VKContext::*)() const>(&VKContext::isOwnerPtr));
						case 24: return FunctionPtr(new FunctionImpl<bool(VKContext::*)() const>(&VKContext::isConstPtr));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(VKContext::*)() const>(&VKContext::getCountPtr));
						case 26: return FunctionPtr(new FunctionImpl<const void*(VKContext::*)() const>(&VKContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2434, 2083, 2298, 2690, 2220, 2327, 2605, 2692, 2691, 1516, 1507, 1508, 2438, 2299, 2686, 2010, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1459, 1460, 1454, 1461, 1452, 4039, 4039, 4039, 4039, 4073, 4073, 4073, 1128, 1127, 4074, 1585, 1402, 4073, 4073, 1403, 1403, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 6, 6, 6, 6, 6, 6, 6, 6, 7, 8, 9, 10, 11, 11, 11, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13 };
			static constexpr uint16_t function_arg_types[] = { 1459, 1128, 1460, 1454, 4039, 4039, 4039, 4039, 1877, 1877, 4074, 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2998, 2074, 1506, 1969, 2017, 2993, 2993, 2993, 3288, 3288, 2019, 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKContext::constructor_bases[];
	constexpr uint16_t ReflectionVKContext::constructor_arg_types[];
	constexpr uint16_t ReflectionVKContext::constructor_arg_names[];
	constexpr uint16_t ReflectionVKContext::constructor_arg_values[];
	constexpr uint8_t ReflectionVKContext::function_flags[];
	constexpr uint16_t ReflectionVKContext::function_names[];
	constexpr uint16_t ReflectionVKContext::function_types[];
	constexpr uint16_t ReflectionVKContext::function_bases[];
	constexpr uint16_t ReflectionVKContext::function_arg_types[];
	constexpr uint16_t ReflectionVKContext::function_arg_names[];
	constexpr uint16_t ReflectionVKContext::function_arg_values[];
	constexpr uint16_t ReflectionVKContext::callback_names[];
	constexpr uint16_t ReflectionVKContext::callback_types[];
	constexpr uint16_t ReflectionVKContext::callback_bases[];
	constexpr uint16_t ReflectionVKContext::callback_arg_types[];
	constexpr uint16_t ReflectionVKContext::callback_arg_names[];
	constexpr uint16_t ReflectionVKContext::enum_names[];
	constexpr uint16_t ReflectionVKContext::enum_bases[];
	constexpr uint16_t ReflectionVKContext::enum_var_names[];
	static ReflectionVKContext reflection_vk_context;
	
	// Tellusim::GLContext
	class ReflectionGLContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLContext::*)(void*)>(&GLContext::create));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(GLContext::*)() const>(&GLContext::getGLDisplay));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(GLContext::*)() const>(&GLContext::getGLVisual));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(GLContext::*)() const>(&GLContext::getGLConfig));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(GLContext::*)() const>(&GLContext::getGLSurface));
						case 5: return FunctionPtr(new FunctionVoidImpl<void*(GLContext::*)() const>(&GLContext::getGLContext));
						case 6: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&GLContext::getProcAddress));
						case 7: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&GLContext::error));
						case 8: return FunctionPtr(new FunctionImpl<bool()>(&GLContext::check));
						case 9: return FunctionPtr(new FunctionImpl<GLContext(GLContext::*)() const>(&GLContext::clonePtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(GLContext::*)()>(&GLContext::clearPtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(GLContext::*)()>(&GLContext::destroyPtr));
						case 12: return FunctionPtr(new FunctionImpl<GLContext&(GLContext::*)()>(&GLContext::acquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<GLContext&(GLContext::*)()>(&GLContext::unacquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(GLContext::*)() const>(&GLContext::isValidPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(GLContext::*)() const>(&GLContext::isOwnerPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(GLContext::*)() const>(&GLContext::isConstPtr));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(GLContext::*)() const>(&GLContext::getCountPtr));
						case 18: return FunctionPtr(new FunctionImpl<const void*(GLContext::*)() const>(&GLContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2370, 2375, 2368, 2374, 2369, 2686, 2010, 1607, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4074, 4074, 4074, 4074, 4074, 4074, 1585, 1585, 781, 4073, 4073, 782, 782, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4074, 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1887, 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLContext::constructor_bases[];
	constexpr uint16_t ReflectionGLContext::constructor_arg_types[];
	constexpr uint16_t ReflectionGLContext::constructor_arg_names[];
	constexpr uint16_t ReflectionGLContext::constructor_arg_values[];
	constexpr uint8_t ReflectionGLContext::function_flags[];
	constexpr uint16_t ReflectionGLContext::function_names[];
	constexpr uint16_t ReflectionGLContext::function_types[];
	constexpr uint16_t ReflectionGLContext::function_bases[];
	constexpr uint16_t ReflectionGLContext::function_arg_types[];
	constexpr uint16_t ReflectionGLContext::function_arg_names[];
	constexpr uint16_t ReflectionGLContext::function_arg_values[];
	constexpr uint16_t ReflectionGLContext::callback_names[];
	constexpr uint16_t ReflectionGLContext::callback_types[];
	constexpr uint16_t ReflectionGLContext::callback_bases[];
	constexpr uint16_t ReflectionGLContext::callback_arg_types[];
	constexpr uint16_t ReflectionGLContext::callback_arg_names[];
	constexpr uint16_t ReflectionGLContext::enum_names[];
	constexpr uint16_t ReflectionGLContext::enum_bases[];
	constexpr uint16_t ReflectionGLContext::enum_var_names[];
	static ReflectionGLContext reflection_gl_context;
	
	// Tellusim::GLESContext
	class ReflectionGLESContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLESContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLESContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLESContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLESContext::*)(void*)>(&GLESContext::create));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(GLESContext::*)() const>(&GLESContext::getGLESDisplay));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(GLESContext::*)() const>(&GLESContext::getGLESConfig));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(GLESContext::*)() const>(&GLESContext::getGLESContext));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&GLESContext::getProcAddress));
						case 5: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&GLESContext::error));
						case 6: return FunctionPtr(new FunctionImpl<bool()>(&GLESContext::check));
						case 7: return FunctionPtr(new FunctionImpl<GLESContext(GLESContext::*)() const>(&GLESContext::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(GLESContext::*)()>(&GLESContext::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(GLESContext::*)()>(&GLESContext::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<GLESContext&(GLESContext::*)()>(&GLESContext::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<GLESContext&(GLESContext::*)()>(&GLESContext::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(GLESContext::*)() const>(&GLESContext::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(GLESContext::*)() const>(&GLESContext::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(GLESContext::*)() const>(&GLESContext::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(GLESContext::*)() const>(&GLESContext::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(GLESContext::*)() const>(&GLESContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2373, 2371, 2372, 2686, 2010, 1607, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4074, 4074, 4074, 4074, 1585, 1585, 785, 4073, 4073, 786, 786, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4074, 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1887, 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLESContext::constructor_bases[];
	constexpr uint16_t ReflectionGLESContext::constructor_arg_types[];
	constexpr uint16_t ReflectionGLESContext::constructor_arg_names[];
	constexpr uint16_t ReflectionGLESContext::constructor_arg_values[];
	constexpr uint8_t ReflectionGLESContext::function_flags[];
	constexpr uint16_t ReflectionGLESContext::function_names[];
	constexpr uint16_t ReflectionGLESContext::function_types[];
	constexpr uint16_t ReflectionGLESContext::function_bases[];
	constexpr uint16_t ReflectionGLESContext::function_arg_types[];
	constexpr uint16_t ReflectionGLESContext::function_arg_names[];
	constexpr uint16_t ReflectionGLESContext::function_arg_values[];
	constexpr uint16_t ReflectionGLESContext::callback_names[];
	constexpr uint16_t ReflectionGLESContext::callback_types[];
	constexpr uint16_t ReflectionGLESContext::callback_bases[];
	constexpr uint16_t ReflectionGLESContext::callback_arg_types[];
	constexpr uint16_t ReflectionGLESContext::callback_arg_names[];
	constexpr uint16_t ReflectionGLESContext::enum_names[];
	constexpr uint16_t ReflectionGLESContext::enum_bases[];
	constexpr uint16_t ReflectionGLESContext::enum_var_names[];
	static ReflectionGLESContext reflection_gles_context;
	
	// Tellusim::WGContext
	class ReflectionWGContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return WGContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<WGContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<WGContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(WGPUInstance, WGPUAdapter, WGPUDevice)>(&WGContext::open));
						case 1: return FunctionPtr(new FunctionImpl<bool(WGContext::*)(WGPUInstance, WGPUAdapter, WGPUDevice)>(&WGContext::create));
						case 2: return FunctionPtr(new FunctionImpl<WGPUInstance(WGContext::*)() const>(&WGContext::getInstance));
						case 3: return FunctionPtr(new FunctionImpl<WGPUAdapter(WGContext::*)() const>(&WGContext::getAdapter));
						case 4: return FunctionPtr(new FunctionImpl<WGPUDevice(WGContext::*)() const>(&WGContext::getDevice));
						case 5: return FunctionPtr(new FunctionImpl<WGContext(WGContext::*)() const>(&WGContext::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(WGContext::*)()>(&WGContext::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(WGContext::*)()>(&WGContext::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<WGContext&(WGContext::*)()>(&WGContext::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<WGContext&(WGContext::*)()>(&WGContext::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(WGContext::*)() const>(&WGContext::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(WGContext::*)() const>(&WGContext::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(WGContext::*)() const>(&WGContext::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(WGContext::*)() const>(&WGContext::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(WGContext::*)() const>(&WGContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 1, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3327, 1902, 2434, 2083, 2298, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 1585, 1470, 1468, 1469, 1466, 4073, 4073, 1467, 1467, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
			static constexpr uint16_t function_arg_types[] = { 1470, 1468, 1469, 1470, 1468, 1469 };
			static constexpr uint16_t function_arg_names[] = { 2998, 1506, 1969, 2998, 1506, 1969 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionWGContext::constructor_bases[];
	constexpr uint16_t ReflectionWGContext::constructor_arg_types[];
	constexpr uint16_t ReflectionWGContext::constructor_arg_names[];
	constexpr uint16_t ReflectionWGContext::constructor_arg_values[];
	constexpr uint8_t ReflectionWGContext::function_flags[];
	constexpr uint16_t ReflectionWGContext::function_names[];
	constexpr uint16_t ReflectionWGContext::function_types[];
	constexpr uint16_t ReflectionWGContext::function_bases[];
	constexpr uint16_t ReflectionWGContext::function_arg_types[];
	constexpr uint16_t ReflectionWGContext::function_arg_names[];
	constexpr uint16_t ReflectionWGContext::function_arg_values[];
	constexpr uint16_t ReflectionWGContext::callback_names[];
	constexpr uint16_t ReflectionWGContext::callback_types[];
	constexpr uint16_t ReflectionWGContext::callback_bases[];
	constexpr uint16_t ReflectionWGContext::callback_arg_types[];
	constexpr uint16_t ReflectionWGContext::callback_arg_names[];
	constexpr uint16_t ReflectionWGContext::enum_names[];
	constexpr uint16_t ReflectionWGContext::enum_bases[];
	constexpr uint16_t ReflectionWGContext::enum_var_names[];
	static ReflectionWGContext reflection_wg_context;
	
	// Tellusim::CUContext
	class ReflectionCUContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CUContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CUContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CUContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<int32_t(CUContext::*)() const>(&CUContext::getDevice));
						case 1: return FunctionPtr(new FunctionImpl<CUcontext(CUContext::*)() const>(&CUContext::getCUContext));
						case 2: return FunctionPtr(new FunctionImpl<CUstream(CUContext::*)() const>(&CUContext::getStream));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&CUContext::getProcAddress));
						case 4: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&CUContext::error));
						case 5: return FunctionPtr(new FunctionImpl<CUContext(CUContext::*)() const>(&CUContext::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(CUContext::*)()>(&CUContext::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(CUContext::*)()>(&CUContext::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<CUContext&(CUContext::*)()>(&CUContext::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<CUContext&(CUContext::*)()>(&CUContext::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(CUContext::*)() const>(&CUContext::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(CUContext::*)() const>(&CUContext::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(CUContext::*)() const>(&CUContext::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(CUContext::*)() const>(&CUContext::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(CUContext::*)() const>(&CUContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2298, 2178, 2794, 2686, 2010, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 3003, 209, 215, 4074, 1585, 202, 4073, 4073, 203, 203, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_arg_types[] = { 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCUContext::constructor_bases[];
	constexpr uint16_t ReflectionCUContext::constructor_arg_types[];
	constexpr uint16_t ReflectionCUContext::constructor_arg_names[];
	constexpr uint16_t ReflectionCUContext::constructor_arg_values[];
	constexpr uint8_t ReflectionCUContext::function_flags[];
	constexpr uint16_t ReflectionCUContext::function_names[];
	constexpr uint16_t ReflectionCUContext::function_types[];
	constexpr uint16_t ReflectionCUContext::function_bases[];
	constexpr uint16_t ReflectionCUContext::function_arg_types[];
	constexpr uint16_t ReflectionCUContext::function_arg_names[];
	constexpr uint16_t ReflectionCUContext::function_arg_values[];
	constexpr uint16_t ReflectionCUContext::callback_names[];
	constexpr uint16_t ReflectionCUContext::callback_types[];
	constexpr uint16_t ReflectionCUContext::callback_bases[];
	constexpr uint16_t ReflectionCUContext::callback_arg_types[];
	constexpr uint16_t ReflectionCUContext::callback_arg_names[];
	constexpr uint16_t ReflectionCUContext::enum_names[];
	constexpr uint16_t ReflectionCUContext::enum_bases[];
	constexpr uint16_t ReflectionCUContext::enum_var_names[];
	static ReflectionCUContext reflection_cu_context;
	
	// Tellusim::HIPContext
	class ReflectionHIPContext : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return HIPContext::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_context;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<HIPContext, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<HIPContext>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<int32_t(HIPContext::*)() const>(&HIPContext::getDevice));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(HIPContext::*)() const>(&HIPContext::getHIPContext));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(HIPContext::*)() const>(&HIPContext::getStream));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(const char*)>(&HIPContext::getProcAddress));
						case 4: return FunctionPtr(new FunctionImpl<bool(uint32_t)>(&HIPContext::error));
						case 5: return FunctionPtr(new FunctionImpl<HIPContext(HIPContext::*)() const>(&HIPContext::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(HIPContext::*)()>(&HIPContext::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(HIPContext::*)()>(&HIPContext::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<HIPContext&(HIPContext::*)()>(&HIPContext::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<HIPContext&(HIPContext::*)()>(&HIPContext::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(HIPContext::*)() const>(&HIPContext::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(HIPContext::*)() const>(&HIPContext::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(HIPContext::*)() const>(&HIPContext::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(HIPContext::*)() const>(&HIPContext::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(HIPContext::*)() const>(&HIPContext::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2298, 2405, 2794, 2686, 2010, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 3003, 4074, 4074, 4074, 1585, 806, 4073, 4073, 807, 807, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_arg_types[] = { 1877, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3469 };
			static constexpr uint16_t function_arg_values[] = { 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionHIPContext::constructor_bases[];
	constexpr uint16_t ReflectionHIPContext::constructor_arg_types[];
	constexpr uint16_t ReflectionHIPContext::constructor_arg_names[];
	constexpr uint16_t ReflectionHIPContext::constructor_arg_values[];
	constexpr uint8_t ReflectionHIPContext::function_flags[];
	constexpr uint16_t ReflectionHIPContext::function_names[];
	constexpr uint16_t ReflectionHIPContext::function_types[];
	constexpr uint16_t ReflectionHIPContext::function_bases[];
	constexpr uint16_t ReflectionHIPContext::function_arg_types[];
	constexpr uint16_t ReflectionHIPContext::function_arg_names[];
	constexpr uint16_t ReflectionHIPContext::function_arg_values[];
	constexpr uint16_t ReflectionHIPContext::callback_names[];
	constexpr uint16_t ReflectionHIPContext::callback_types[];
	constexpr uint16_t ReflectionHIPContext::callback_bases[];
	constexpr uint16_t ReflectionHIPContext::callback_arg_types[];
	constexpr uint16_t ReflectionHIPContext::callback_arg_names[];
	constexpr uint16_t ReflectionHIPContext::enum_names[];
	constexpr uint16_t ReflectionHIPContext::enum_bases[];
	constexpr uint16_t ReflectionHIPContext::enum_var_names[];
	static ReflectionHIPContext reflection_hip_context;
	
	// Tellusim::Query
	class ReflectionQuery : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Query::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Query, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Query>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Query::*)() const>(&Query::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Query::*)() const>(&Query::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Query::*)() const>(&Query::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Query::*)()>(&Query::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isCreated));
						case 5: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isAvailable));
						case 6: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isBegan));
						case 7: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isEnded));
						case 8: return FunctionPtr(new FunctionImpl<bool(Query::*)(Query::Type)>(&Query::create));
						case 9: return FunctionPtr(new FunctionImpl<Query::Type(Query::*)() const>(&Query::getType));
						case 10: return FunctionPtr(new FunctionImpl<const char*(Query::Type)>(&Query::getTypeName));
						case 11: return FunctionPtr(new FunctionImpl<const char*(Query::*)() const>(&Query::getTypeName));
						case 12: return FunctionPtr(new FunctionImpl<size_t(Query::*)() const>(&Query::getTypeSize));
						case 13: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isTime));
						case 14: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isClock));
						case 15: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isSamples));
						case 16: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isSamples1));
						case 17: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isStatistics));
						case 18: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isTimeType));
						case 19: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isSamplesType));
						case 20: return FunctionPtr(new FunctionImpl<bool(Query::*)(void*, size_t, bool) const>(&Query::get, {}, {}, true));
						case 21: return FunctionPtr(new FunctionImpl<uint64_t(Query::*)(bool, bool*) const>(&Query::getTime, true, nullptr));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(Query::*)(bool, bool*) const>(&Query::getSamples, true, nullptr));
						case 23: return FunctionPtr(new FunctionImpl<Query::Statistics(Query::*)(bool, bool*) const>(&Query::getStatistics, true, nullptr));
						case 24: return FunctionPtr(new FunctionImpl<Query(Query::*)() const>(&Query::clonePtr));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Query::*)()>(&Query::clearPtr));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(Query::*)()>(&Query::destroyPtr));
						case 27: return FunctionPtr(new FunctionImpl<Query&(Query::*)()>(&Query::acquirePtr));
						case 28: return FunctionPtr(new FunctionImpl<Query&(Query::*)()>(&Query::unacquirePtr));
						case 29: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isValidPtr));
						case 30: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isOwnerPtr));
						case 31: return FunctionPtr(new FunctionImpl<bool(Query::*)() const>(&Query::isConstPtr));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(Query::*)() const>(&Query::getCountPtr));
						case 33: return FunctionPtr(new FunctionImpl<const void*(Query::*)() const>(&Query::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3024, 3028, 3072, 1902, 2878, 2879, 2879, 2880, 3191, 3046, 3164, 3165, 3179, 3192, 3166, 2078, 2857, 2729, 2769, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 1585, 1585, 1585, 1585, 1170, 1877, 1877, 3961, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4044, 4039, 1169, 1167, 4073, 4073, 1168, 1168, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 7, 9, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11 };
			static constexpr uint16_t function_arg_types[] = { 1170, 1170, 4074, 3961, 1585, 1585, 1586, 1585, 1586, 1585, 1586 };
			static constexpr uint16_t function_arg_names[] = { 4036, 4036, 1963, 3960, 4076, 4076, 3984, 4076, 3984, 4076, 3984 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 4033, 4033, 3294, 4033, 3294, 4033, 3294 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311 };
			static constexpr uint16_t enum_bases[] = { 0, 7 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1386, 1325, 1371, 1372, 1377, 1117 };
	};
	constexpr uint16_t ReflectionQuery::constructor_bases[];
	constexpr uint16_t ReflectionQuery::constructor_arg_types[];
	constexpr uint16_t ReflectionQuery::constructor_arg_names[];
	constexpr uint16_t ReflectionQuery::constructor_arg_values[];
	constexpr uint8_t ReflectionQuery::function_flags[];
	constexpr uint16_t ReflectionQuery::function_names[];
	constexpr uint16_t ReflectionQuery::function_types[];
	constexpr uint16_t ReflectionQuery::function_bases[];
	constexpr uint16_t ReflectionQuery::function_arg_types[];
	constexpr uint16_t ReflectionQuery::function_arg_names[];
	constexpr uint16_t ReflectionQuery::function_arg_values[];
	constexpr uint16_t ReflectionQuery::callback_names[];
	constexpr uint16_t ReflectionQuery::callback_types[];
	constexpr uint16_t ReflectionQuery::callback_bases[];
	constexpr uint16_t ReflectionQuery::callback_arg_types[];
	constexpr uint16_t ReflectionQuery::callback_arg_names[];
	constexpr uint16_t ReflectionQuery::enum_names[];
	constexpr uint16_t ReflectionQuery::enum_bases[];
	constexpr uint16_t ReflectionQuery::enum_var_names[];
	static ReflectionQuery reflection_query;
	
	// Tellusim::FUQuery
	class ReflectionFUQuery : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUQuery::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_query;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUQuery, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUQuery, TypeList<const Array<Query>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUQuery>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUQuery::*)(uint32_t)>(&FUQuery::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUQuery::*)() const>(&FUQuery::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUQuery::*)() const>(&FUQuery::getNumQueries));
						case 3: return FunctionPtr(new FunctionImpl<const Query(FUQuery::*)(uint32_t) const>(&FUQuery::getQuery));
						case 4: return FunctionPtr(new FunctionImpl<Query(FUQuery::*)(uint32_t)>(&FUQuery::getQuery));
						case 5: return FunctionPtr(new FunctionImpl<FUQuery(FUQuery::*)() const>(&FUQuery::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUQuery::*)()>(&FUQuery::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUQuery::*)()>(&FUQuery::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUQuery&(FUQuery::*)()>(&FUQuery::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUQuery&(FUQuery::*)()>(&FUQuery::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUQuery::*)() const>(&FUQuery::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUQuery::*)() const>(&FUQuery::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUQuery::*)() const>(&FUQuery::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUQuery::*)() const>(&FUQuery::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUQuery::*)() const>(&FUQuery::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1689, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3369, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2604, 2689, 2689, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1829, 1167, 540, 4073, 4073, 541, 541, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUQuery::constructor_bases[];
	constexpr uint16_t ReflectionFUQuery::constructor_arg_types[];
	constexpr uint16_t ReflectionFUQuery::constructor_arg_names[];
	constexpr uint16_t ReflectionFUQuery::constructor_arg_values[];
	constexpr uint8_t ReflectionFUQuery::function_flags[];
	constexpr uint16_t ReflectionFUQuery::function_names[];
	constexpr uint16_t ReflectionFUQuery::function_types[];
	constexpr uint16_t ReflectionFUQuery::function_bases[];
	constexpr uint16_t ReflectionFUQuery::function_arg_types[];
	constexpr uint16_t ReflectionFUQuery::function_arg_names[];
	constexpr uint16_t ReflectionFUQuery::function_arg_values[];
	constexpr uint16_t ReflectionFUQuery::callback_names[];
	constexpr uint16_t ReflectionFUQuery::callback_types[];
	constexpr uint16_t ReflectionFUQuery::callback_bases[];
	constexpr uint16_t ReflectionFUQuery::callback_arg_types[];
	constexpr uint16_t ReflectionFUQuery::callback_arg_names[];
	constexpr uint16_t ReflectionFUQuery::enum_names[];
	constexpr uint16_t ReflectionFUQuery::enum_bases[];
	constexpr uint16_t ReflectionFUQuery::enum_var_names[];
	static ReflectionFUQuery reflection_fu_query;
	
	// Tellusim::Fence
	class ReflectionFence : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Fence::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Fence, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Fence>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Fence::*)() const>(&Fence::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Fence::*)() const>(&Fence::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Fence::*)() const>(&Fence::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Fence::*)()>(&Fence::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Fence::*)() const>(&Fence::isCreated));
						case 5: return FunctionPtr(new FunctionImpl<bool(Fence::*)(Fence::Flags)>(&Fence::create, Fence::DefaultFlags));
						case 6: return FunctionPtr(new FunctionImpl<Fence::Flags(Fence::*)() const>(&Fence::getFlags));
						case 7: return FunctionPtr(new FunctionImpl<bool(Fence::*)(Fence::Flags) const>(&Fence::hasFlag));
						case 8: return FunctionPtr(new FunctionImpl<bool(Fence::*)(Fence::Flags) const>(&Fence::hasFlags));
						case 9: return FunctionPtr(new FunctionImpl<String(Fence::*)() const>(&Fence::getFlagsName));
						case 10: return FunctionPtr(new FunctionImpl<String(Fence::*)() const>(&Fence::getDescription));
						case 11: return FunctionPtr(new FunctionImpl<Fence(Fence::*)() const>(&Fence::clonePtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Fence::*)()>(&Fence::clearPtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Fence::*)()>(&Fence::destroyPtr));
						case 14: return FunctionPtr(new FunctionImpl<Fence&(Fence::*)()>(&Fence::acquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<Fence&(Fence::*)()>(&Fence::unacquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(Fence::*)() const>(&Fence::isValidPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(Fence::*)() const>(&Fence::isOwnerPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(Fence::*)() const>(&Fence::isConstPtr));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(Fence::*)() const>(&Fence::getCountPtr));
						case 20: return FunctionPtr(new FunctionImpl<const void*(Fence::*)() const>(&Fence::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 1902, 2341, 2947, 2948, 2342, 2296, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 1585, 556, 1585, 1585, 1274, 1274, 554, 4073, 4073, 555, 555, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 556, 556, 556 };
			static constexpr uint16_t function_arg_names[] = { 2045, 2045, 2045 };
			static constexpr uint16_t function_arg_values[] = { 437, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753 };
			static constexpr uint16_t enum_bases[] = { 0, 7 };
			static constexpr uint16_t enum_var_names[] = { 678, 710, 714, 711, 623, 437, 1102 };
	};
	constexpr uint16_t ReflectionFence::constructor_bases[];
	constexpr uint16_t ReflectionFence::constructor_arg_types[];
	constexpr uint16_t ReflectionFence::constructor_arg_names[];
	constexpr uint16_t ReflectionFence::constructor_arg_values[];
	constexpr uint8_t ReflectionFence::function_flags[];
	constexpr uint16_t ReflectionFence::function_names[];
	constexpr uint16_t ReflectionFence::function_types[];
	constexpr uint16_t ReflectionFence::function_bases[];
	constexpr uint16_t ReflectionFence::function_arg_types[];
	constexpr uint16_t ReflectionFence::function_arg_names[];
	constexpr uint16_t ReflectionFence::function_arg_values[];
	constexpr uint16_t ReflectionFence::callback_names[];
	constexpr uint16_t ReflectionFence::callback_types[];
	constexpr uint16_t ReflectionFence::callback_bases[];
	constexpr uint16_t ReflectionFence::callback_arg_types[];
	constexpr uint16_t ReflectionFence::callback_arg_names[];
	constexpr uint16_t ReflectionFence::enum_names[];
	constexpr uint16_t ReflectionFence::enum_bases[];
	constexpr uint16_t ReflectionFence::enum_var_names[];
	static ReflectionFence reflection_fence;
	
	// Tellusim::VKFence
	class ReflectionVKFence : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKFence::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_fence;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKFence, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKFence>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<VkFence(VKFence::*)() const>(&VKFence::getVKFence));
						case 1: return FunctionPtr(new FunctionImpl<VkSemaphore(VKFence::*)() const>(&VKFence::getSemaphore));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(VKFence::*)() const>(&VKFence::getSharedHandle));
						case 3: return FunctionPtr(new FunctionImpl<VKFence(VKFence::*)() const>(&VKFence::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(VKFence::*)()>(&VKFence::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(VKFence::*)()>(&VKFence::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<VKFence&(VKFence::*)()>(&VKFence::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<VKFence&(VKFence::*)()>(&VKFence::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(VKFence::*)() const>(&VKFence::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(VKFence::*)() const>(&VKFence::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(VKFence::*)() const>(&VKFence::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(VKFence::*)() const>(&VKFence::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(VKFence::*)() const>(&VKFence::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2896, 2751, 2757, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1455, 1463, 4074, 1406, 4073, 4073, 1407, 1407, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKFence::constructor_bases[];
	constexpr uint16_t ReflectionVKFence::constructor_arg_types[];
	constexpr uint16_t ReflectionVKFence::constructor_arg_names[];
	constexpr uint16_t ReflectionVKFence::constructor_arg_values[];
	constexpr uint8_t ReflectionVKFence::function_flags[];
	constexpr uint16_t ReflectionVKFence::function_names[];
	constexpr uint16_t ReflectionVKFence::function_types[];
	constexpr uint16_t ReflectionVKFence::function_bases[];
	constexpr uint16_t ReflectionVKFence::function_arg_types[];
	constexpr uint16_t ReflectionVKFence::function_arg_names[];
	constexpr uint16_t ReflectionVKFence::function_arg_values[];
	constexpr uint16_t ReflectionVKFence::callback_names[];
	constexpr uint16_t ReflectionVKFence::callback_types[];
	constexpr uint16_t ReflectionVKFence::callback_bases[];
	constexpr uint16_t ReflectionVKFence::callback_arg_types[];
	constexpr uint16_t ReflectionVKFence::callback_arg_names[];
	constexpr uint16_t ReflectionVKFence::enum_names[];
	constexpr uint16_t ReflectionVKFence::enum_bases[];
	constexpr uint16_t ReflectionVKFence::enum_var_names[];
	static ReflectionVKFence reflection_vk_fence;
	
	// Tellusim::FUFence
	class ReflectionFUFence : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUFence::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_fence;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUFence, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUFence, TypeList<const Array<Fence>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUFence>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUFence::*)(uint32_t)>(&FUFence::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUFence::*)() const>(&FUFence::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUFence::*)() const>(&FUFence::getNumFences));
						case 3: return FunctionPtr(new FunctionImpl<const Fence(FUFence::*)(uint32_t) const>(&FUFence::getFence));
						case 4: return FunctionPtr(new FunctionImpl<Fence(FUFence::*)(uint32_t)>(&FUFence::getFence));
						case 5: return FunctionPtr(new FunctionImpl<FUFence(FUFence::*)() const>(&FUFence::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUFence::*)()>(&FUFence::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUFence::*)()>(&FUFence::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUFence&(FUFence::*)()>(&FUFence::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUFence&(FUFence::*)()>(&FUFence::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUFence::*)() const>(&FUFence::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUFence::*)() const>(&FUFence::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUFence::*)() const>(&FUFence::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUFence::*)() const>(&FUFence::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUFence::*)() const>(&FUFence::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1674, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 2021, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2580, 2329, 2329, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1775, 554, 534, 4073, 4073, 535, 535, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUFence::constructor_bases[];
	constexpr uint16_t ReflectionFUFence::constructor_arg_types[];
	constexpr uint16_t ReflectionFUFence::constructor_arg_names[];
	constexpr uint16_t ReflectionFUFence::constructor_arg_values[];
	constexpr uint8_t ReflectionFUFence::function_flags[];
	constexpr uint16_t ReflectionFUFence::function_names[];
	constexpr uint16_t ReflectionFUFence::function_types[];
	constexpr uint16_t ReflectionFUFence::function_bases[];
	constexpr uint16_t ReflectionFUFence::function_arg_types[];
	constexpr uint16_t ReflectionFUFence::function_arg_names[];
	constexpr uint16_t ReflectionFUFence::function_arg_values[];
	constexpr uint16_t ReflectionFUFence::callback_names[];
	constexpr uint16_t ReflectionFUFence::callback_types[];
	constexpr uint16_t ReflectionFUFence::callback_bases[];
	constexpr uint16_t ReflectionFUFence::callback_arg_types[];
	constexpr uint16_t ReflectionFUFence::callback_arg_names[];
	constexpr uint16_t ReflectionFUFence::enum_names[];
	constexpr uint16_t ReflectionFUFence::enum_bases[];
	constexpr uint16_t ReflectionFUFence::enum_var_names[];
	static ReflectionFUFence reflection_fu_fence;
	
	// Tellusim::Shader
	class ReflectionShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Shader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Shader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Shader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Shader::*)() const>(&Shader::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Shader::*)() const>(&Shader::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Shader::*)() const>(&Shader::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)()>(&Shader::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isCreated));
						case 5: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Stream&) const>(&Shader::saveState));
						case 6: return FunctionPtr(new FunctionImpl<Shader::Type(Shader::*)() const>(&Shader::getType));
						case 7: return FunctionPtr(new FunctionImpl<const char*(Shader::Type)>(&Shader::getTypeName));
						case 8: return FunctionPtr(new FunctionImpl<const char*(Shader::*)() const>(&Shader::getTypeName));
						case 9: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isVertex));
						case 10: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isControl));
						case 11: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isEvaluate));
						case 12: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isGeometry));
						case 13: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isFragment));
						case 14: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isCompute));
						case 15: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isTask));
						case 16: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isMesh));
						case 17: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isRayGen));
						case 18: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isRayMiss));
						case 19: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isClosest));
						case 20: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isFirstHit));
						case 21: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isIntersection));
						case 22: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isCallable));
						case 23: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isGraphicsType));
						case 24: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isTessellationType));
						case 25: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isTracingType));
						case 26: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isMeshType));
						case 27: return FunctionPtr(new FunctionImpl<String(Shader::*)() const>(&Shader::getName));
						case 28: return FunctionPtr(new FunctionImpl<String(Shader::*)() const>(&Shader::getMacros));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setSamplerOffset));
						case 30: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getSamplerOffset));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setTextureOffset));
						case 32: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getTextureOffset));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setSurfaceOffset));
						case 34: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getSurfaceOffset));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setUniformOffset));
						case 36: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getUniformOffset));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setStorageOffset));
						case 38: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getStorageOffset));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setTracingOffset));
						case 40: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getTracingOffset));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setTexelOffset));
						case 42: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getTexelOffset));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(int32_t)>(&Shader::setTableOffset));
						case 44: return FunctionPtr(new FunctionImpl<int32_t(Shader::*)() const>(&Shader::getTableOffset));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(uint32_t)>(&Shader::setPatchSize));
						case 46: return FunctionPtr(new FunctionImpl<uint32_t(Shader::*)() const>(&Shader::getPatchSize));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(uint32_t)>(&Shader::setInputSize));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Shader::*)() const>(&Shader::getInputSize));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)(uint32_t)>(&Shader::setOutputSize));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(Shader::*)() const>(&Shader::getOutputSize));
						case 51: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Shader::load, (Shader::Type)0, {}, String::null, nullptr, 0));
						case 52: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Shader::create, (Shader::Type)0, {}, String::null, nullptr, 0));
						case 53: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Shader::loadGLSL, (Shader::Type)0, {}, String::null, nullptr, 0));
						case 54: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Shader::createGLSL, (Shader::Type)0, {}, String::null, nullptr, 0));
						case 55: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Shader::Type, const char*)>(&Shader::loadSPIRV));
						case 56: return FunctionPtr(new FunctionImpl<bool(Shader::*)(Shader::Type, const Array<uint32_t>&)>(&Shader::createSPIRV));
						case 57: return FunctionPtr(new FunctionImpl<bool()>(&Shader::hasCache));
						case 58: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Shader::setCache));
						case 59: return FunctionPtr(new FunctionImpl<bool(const String&, Stream&)>(&Shader::loadCache));
						case 60: return FunctionPtr(new FunctionImpl<bool(const String&, Stream&)>(&Shader::saveCache));
						case 61: return FunctionPtr(new FunctionVoidImpl<void()>(&Shader::clearCache));
						case 62: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Shader::isMacro));
						case 63: return FunctionPtr(new FunctionImpl<bool(const char*, int32_t)>(&Shader::setMacro));
						case 64: return FunctionPtr(new FunctionImpl<bool(const char*, uint32_t)>(&Shader::setMacro));
						case 65: return FunctionPtr(new FunctionImpl<bool(const char*, const char*)>(&Shader::setMacro, {}, nullptr));
						case 66: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Shader::setMacros));
						case 67: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Shader::removeMacro));
						case 68: return FunctionPtr(new FunctionVoidImpl<void()>(&Shader::clearMacros));
						case 69: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Shader::isInclude));
						case 70: return FunctionPtr(new FunctionImpl<bool(const char*, const String&)>(&Shader::setInclude));
						case 71: return FunctionPtr(new FunctionImpl<bool(const char*)>(&Shader::removeInclude));
						case 72: return FunctionPtr(new FunctionVoidImpl<void()>(&Shader::clearIncludes));
						case 73: return FunctionPtr(new FunctionImpl<String(const char*, const String&, const char**, uint32_t)>(&Shader::preprocessor, {}, String::null, nullptr, 0));
						case 74: return FunctionPtr(new FunctionImpl<Shader(Shader::*)() const>(&Shader::clonePtr));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)()>(&Shader::clearPtr));
						case 76: return FunctionPtr(new FunctionVoidImpl<void(Shader::*)()>(&Shader::destroyPtr));
						case 77: return FunctionPtr(new FunctionImpl<Shader&(Shader::*)()>(&Shader::acquirePtr));
						case 78: return FunctionPtr(new FunctionImpl<Shader&(Shader::*)()>(&Shader::unacquirePtr));
						case 79: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isValidPtr));
						case 80: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isOwnerPtr));
						case 81: return FunctionPtr(new FunctionImpl<bool(Shader::*)() const>(&Shader::isConstPtr));
						case 82: return FunctionPtr(new FunctionImpl<uint32_t(Shader::*)() const>(&Shader::getCountPtr));
						case 83: return FunctionPtr(new FunctionImpl<const void*(Shader::*)() const>(&Shader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3482, 2878, 2879, 2879, 3202, 3055, 3073, 3087, 3083, 3051, 3184, 3120, 3155, 3156, 3047, 3076, 3103, 3039, 3089, 3185, 3193, 3121, 2556, 2479, 3814, 2728, 3894, 2841, 3864, 2804, 3922, 2885, 3853, 2793, 3909, 2871, 3879, 2823, 3871, 2812, 3775, 2659, 3676, 2431, 3764, 2633, 3242, 1902, 3244, 1919, 3245, 1929, 2943, 3546, 3243, 3481, 1618, 3117, 3704, 3704, 3704, 3705, 3436, 1628, 3097, 3664, 3430, 1623, 3361, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 1585, 1208, 1877, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1274, 1274, 4073, 3003, 4073, 3003, 4073, 3003, 4073, 3003, 4073, 3003, 4073, 3003, 4073, 3003, 4073, 3003, 4073, 4039, 4073, 4039, 4073, 4039, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1585, 1585, 1585, 4073, 1274, 1205, 4073, 4073, 1206, 1206, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 18, 23, 28, 33, 35, 37, 37, 38, 40, 42, 42, 43, 45, 47, 49, 50, 51, 51, 52, 54, 55, 55, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59 };
			static constexpr uint16_t function_arg_types[] = { 1273, 1208, 3003, 3003, 3003, 3003, 3003, 3003, 3003, 3003, 4039, 4039, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1208, 1703, 1877, 1841, 1273, 1841, 1273, 1877, 1877, 3003, 1877, 4039, 1877, 1877, 1877, 1877, 1877, 1877, 1841, 1877, 1877, 1841, 1878, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3990, 4036, 3317, 3317, 3317, 3317, 3317, 3317, 3317, 3317, 3960, 3960, 3960, 4036, 3288, 3255, 2992, 3960, 4036, 3975, 3255, 2992, 3960, 4036, 3288, 3255, 2992, 3960, 4036, 3975, 3255, 2992, 3960, 4036, 3288, 4036, 1948, 3288, 2979, 3990, 2979, 3990, 3288, 3288, 4056, 3288, 4056, 3288, 4056, 3255, 3288, 3288, 3288, 3975, 3288, 3975, 3255, 2992, 3960 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 0, 0, 0, 0, 0, 1277, 3294, 3 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311, 927 };
			static constexpr uint16_t enum_bases[] = { 0, 16, 35 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1390, 1330, 1338, 1342, 1340, 1329, 1382, 1358, 1367, 1368, 1326, 1339, 1347, 1321, 1117, 957, 971, 938, 944, 949, 947, 937, 968, 955, 959, 960, 936, 946, 951, 933, 972, 950, 969, 929 };
	};
	constexpr uint16_t ReflectionShader::constructor_bases[];
	constexpr uint16_t ReflectionShader::constructor_arg_types[];
	constexpr uint16_t ReflectionShader::constructor_arg_names[];
	constexpr uint16_t ReflectionShader::constructor_arg_values[];
	constexpr uint8_t ReflectionShader::function_flags[];
	constexpr uint16_t ReflectionShader::function_names[];
	constexpr uint16_t ReflectionShader::function_types[];
	constexpr uint16_t ReflectionShader::function_bases[];
	constexpr uint16_t ReflectionShader::function_arg_types[];
	constexpr uint16_t ReflectionShader::function_arg_names[];
	constexpr uint16_t ReflectionShader::function_arg_values[];
	constexpr uint16_t ReflectionShader::callback_names[];
	constexpr uint16_t ReflectionShader::callback_types[];
	constexpr uint16_t ReflectionShader::callback_bases[];
	constexpr uint16_t ReflectionShader::callback_arg_types[];
	constexpr uint16_t ReflectionShader::callback_arg_names[];
	constexpr uint16_t ReflectionShader::enum_names[];
	constexpr uint16_t ReflectionShader::enum_bases[];
	constexpr uint16_t ReflectionShader::enum_var_names[];
	static ReflectionShader reflection_shader;
	
	// Tellusim::ShaderCompiler
	class ReflectionShaderCompiler : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ShaderCompiler::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ShaderCompiler, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ShaderCompiler>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ShaderCompiler::*)(ShaderCompiler::Flags)>(&ShaderCompiler::setFlags));
						case 1: return FunctionPtr(new FunctionImpl<ShaderCompiler::Flags(ShaderCompiler::*)() const>(&ShaderCompiler::getFlags));
						case 2: return FunctionPtr(new FunctionImpl<bool(ShaderCompiler::*)(Stream&, Platform) const>(&ShaderCompiler::getBinary, Stream::null, Tellusim::PlatformUnknown));
						case 3: return FunctionPtr(new FunctionImpl<String(ShaderCompiler::*)(Platform) const>(&ShaderCompiler::getSource, Tellusim::PlatformUnknown));
						case 4: return FunctionPtr(new FunctionImpl<ShaderCompiler(ShaderCompiler::*)() const>(&ShaderCompiler::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ShaderCompiler::*)()>(&ShaderCompiler::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ShaderCompiler::*)()>(&ShaderCompiler::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<ShaderCompiler&(ShaderCompiler::*)()>(&ShaderCompiler::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<ShaderCompiler&(ShaderCompiler::*)()>(&ShaderCompiler::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(ShaderCompiler::*)() const>(&ShaderCompiler::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(ShaderCompiler::*)() const>(&ShaderCompiler::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(ShaderCompiler::*)() const>(&ShaderCompiler::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(ShaderCompiler::*)() const>(&ShaderCompiler::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(ShaderCompiler::*)() const>(&ShaderCompiler::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3628, 2341, 2119, 2765, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1211, 1585, 1274, 1209, 4073, 4073, 1210, 1210, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 1211, 1273, 1146, 1146 };
			static constexpr uint16_t function_arg_names[] = { 2045, 3990, 3352, 3352 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 1147, 1147 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753 };
			static constexpr uint16_t enum_bases[] = { 0, 2 };
			static constexpr uint16_t enum_var_names[] = { 678, 651 };
	};
	constexpr uint16_t ReflectionShaderCompiler::constructor_bases[];
	constexpr uint16_t ReflectionShaderCompiler::constructor_arg_types[];
	constexpr uint16_t ReflectionShaderCompiler::constructor_arg_names[];
	constexpr uint16_t ReflectionShaderCompiler::constructor_arg_values[];
	constexpr uint8_t ReflectionShaderCompiler::function_flags[];
	constexpr uint16_t ReflectionShaderCompiler::function_names[];
	constexpr uint16_t ReflectionShaderCompiler::function_types[];
	constexpr uint16_t ReflectionShaderCompiler::function_bases[];
	constexpr uint16_t ReflectionShaderCompiler::function_arg_types[];
	constexpr uint16_t ReflectionShaderCompiler::function_arg_names[];
	constexpr uint16_t ReflectionShaderCompiler::function_arg_values[];
	constexpr uint16_t ReflectionShaderCompiler::callback_names[];
	constexpr uint16_t ReflectionShaderCompiler::callback_types[];
	constexpr uint16_t ReflectionShaderCompiler::callback_bases[];
	constexpr uint16_t ReflectionShaderCompiler::callback_arg_types[];
	constexpr uint16_t ReflectionShaderCompiler::callback_arg_names[];
	constexpr uint16_t ReflectionShaderCompiler::enum_names[];
	constexpr uint16_t ReflectionShaderCompiler::enum_bases[];
	constexpr uint16_t ReflectionShaderCompiler::enum_var_names[];
	static ReflectionShaderCompiler reflection_shader_compiler;
	
	// Tellusim::D3D12Shader
	class ReflectionD3D12Shader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Shader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Shader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Shader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3DBlob*(D3D12Shader::*)() const>(&D3D12Shader::getShaderBlob));
						case 1: return FunctionPtr(new FunctionImpl<D3D12Shader(D3D12Shader::*)() const>(&D3D12Shader::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(D3D12Shader::*)()>(&D3D12Shader::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Shader::*)()>(&D3D12Shader::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<D3D12Shader&(D3D12Shader::*)()>(&D3D12Shader::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Shader&(D3D12Shader::*)()>(&D3D12Shader::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(D3D12Shader::*)() const>(&D3D12Shader::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Shader::*)() const>(&D3D12Shader::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Shader::*)() const>(&D3D12Shader::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Shader::*)() const>(&D3D12Shader::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(D3D12Shader::*)() const>(&D3D12Shader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2753, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 834, 417, 4073, 4073, 418, 418, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Shader::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Shader::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Shader::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Shader::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Shader::function_flags[];
	constexpr uint16_t ReflectionD3D12Shader::function_names[];
	constexpr uint16_t ReflectionD3D12Shader::function_types[];
	constexpr uint16_t ReflectionD3D12Shader::function_bases[];
	constexpr uint16_t ReflectionD3D12Shader::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Shader::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Shader::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Shader::callback_names[];
	constexpr uint16_t ReflectionD3D12Shader::callback_types[];
	constexpr uint16_t ReflectionD3D12Shader::callback_bases[];
	constexpr uint16_t ReflectionD3D12Shader::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Shader::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Shader::enum_names[];
	constexpr uint16_t ReflectionD3D12Shader::enum_bases[];
	constexpr uint16_t ReflectionD3D12Shader::enum_var_names[];
	static ReflectionD3D12Shader reflection_d3d12_shader;
	
	// Tellusim::D3D11Shader
	class ReflectionD3D11Shader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Shader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Shader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Shader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(D3D11Shader::*)() const>(&D3D11Shader::getD3D11Shader));
						case 1: return FunctionPtr(new FunctionImpl<ID3DBlob*(D3D11Shader::*)() const>(&D3D11Shader::getShaderBlob));
						case 2: return FunctionPtr(new FunctionImpl<D3D11Shader(D3D11Shader::*)() const>(&D3D11Shader::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D11Shader::*)()>(&D3D11Shader::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D11Shader::*)()>(&D3D11Shader::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D11Shader&(D3D11Shader::*)()>(&D3D11Shader::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<D3D11Shader&(D3D11Shader::*)()>(&D3D11Shader::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D11Shader::*)() const>(&D3D11Shader::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D11Shader::*)() const>(&D3D11Shader::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(D3D11Shader::*)() const>(&D3D11Shader::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Shader::*)() const>(&D3D11Shader::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(D3D11Shader::*)() const>(&D3D11Shader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2253, 2753, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 834, 395, 4073, 4073, 396, 396, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Shader::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Shader::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Shader::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Shader::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Shader::function_flags[];
	constexpr uint16_t ReflectionD3D11Shader::function_names[];
	constexpr uint16_t ReflectionD3D11Shader::function_types[];
	constexpr uint16_t ReflectionD3D11Shader::function_bases[];
	constexpr uint16_t ReflectionD3D11Shader::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Shader::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Shader::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Shader::callback_names[];
	constexpr uint16_t ReflectionD3D11Shader::callback_types[];
	constexpr uint16_t ReflectionD3D11Shader::callback_bases[];
	constexpr uint16_t ReflectionD3D11Shader::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Shader::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Shader::enum_names[];
	constexpr uint16_t ReflectionD3D11Shader::enum_bases[];
	constexpr uint16_t ReflectionD3D11Shader::enum_var_names[];
	static ReflectionD3D11Shader reflection_d3d11_shader;
	
	// Tellusim::MTLShader
	class ReflectionMTLShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLShader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MTLShader::*)(bool)>(&MTLShader::setIndirect));
						case 1: return FunctionPtr(new FunctionImpl<bool(MTLShader::*)() const>(&MTLShader::isIndirect));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLShader::*)() const>(&MTLShader::getLibrary));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(MTLShader::*)() const>(&MTLShader::getFunction));
						case 4: return FunctionPtr(new FunctionImpl<MTLShader(MTLShader::*)() const>(&MTLShader::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLShader::*)()>(&MTLShader::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(MTLShader::*)()>(&MTLShader::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLShader&(MTLShader::*)()>(&MTLShader::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<MTLShader&(MTLShader::*)()>(&MTLShader::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLShader::*)() const>(&MTLShader::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLShader::*)() const>(&MTLShader::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(MTLShader::*)() const>(&MTLShader::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(MTLShader::*)() const>(&MTLShader::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(MTLShader::*)() const>(&MTLShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3671, 3098, 2469, 2367, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4074, 4074, 915, 4073, 4073, 916, 916, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 1585 };
			static constexpr uint16_t function_arg_names[] = { 1996 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLShader::constructor_bases[];
	constexpr uint16_t ReflectionMTLShader::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLShader::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLShader::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLShader::function_flags[];
	constexpr uint16_t ReflectionMTLShader::function_names[];
	constexpr uint16_t ReflectionMTLShader::function_types[];
	constexpr uint16_t ReflectionMTLShader::function_bases[];
	constexpr uint16_t ReflectionMTLShader::function_arg_types[];
	constexpr uint16_t ReflectionMTLShader::function_arg_names[];
	constexpr uint16_t ReflectionMTLShader::function_arg_values[];
	constexpr uint16_t ReflectionMTLShader::callback_names[];
	constexpr uint16_t ReflectionMTLShader::callback_types[];
	constexpr uint16_t ReflectionMTLShader::callback_bases[];
	constexpr uint16_t ReflectionMTLShader::callback_arg_types[];
	constexpr uint16_t ReflectionMTLShader::callback_arg_names[];
	constexpr uint16_t ReflectionMTLShader::enum_names[];
	constexpr uint16_t ReflectionMTLShader::enum_bases[];
	constexpr uint16_t ReflectionMTLShader::enum_var_names[];
	static ReflectionMTLShader reflection_mtl_shader;
	
	// Tellusim::VKShader
	class ReflectionVKShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKShader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<VkShaderModule(VKShader::*)() const>(&VKShader::getModule));
						case 1: return FunctionPtr(new FunctionImpl<VKShader(VKShader::*)() const>(&VKShader::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(VKShader::*)()>(&VKShader::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(VKShader::*)()>(&VKShader::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<VKShader&(VKShader::*)()>(&VKShader::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<VKShader&(VKShader::*)()>(&VKShader::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(VKShader::*)() const>(&VKShader::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(VKShader::*)() const>(&VKShader::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(VKShader::*)() const>(&VKShader::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(VKShader::*)() const>(&VKShader::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(VKShader::*)() const>(&VKShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2530, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1464, 1408, 4073, 4073, 1409, 1409, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKShader::constructor_bases[];
	constexpr uint16_t ReflectionVKShader::constructor_arg_types[];
	constexpr uint16_t ReflectionVKShader::constructor_arg_names[];
	constexpr uint16_t ReflectionVKShader::constructor_arg_values[];
	constexpr uint8_t ReflectionVKShader::function_flags[];
	constexpr uint16_t ReflectionVKShader::function_names[];
	constexpr uint16_t ReflectionVKShader::function_types[];
	constexpr uint16_t ReflectionVKShader::function_bases[];
	constexpr uint16_t ReflectionVKShader::function_arg_types[];
	constexpr uint16_t ReflectionVKShader::function_arg_names[];
	constexpr uint16_t ReflectionVKShader::function_arg_values[];
	constexpr uint16_t ReflectionVKShader::callback_names[];
	constexpr uint16_t ReflectionVKShader::callback_types[];
	constexpr uint16_t ReflectionVKShader::callback_bases[];
	constexpr uint16_t ReflectionVKShader::callback_arg_types[];
	constexpr uint16_t ReflectionVKShader::callback_arg_names[];
	constexpr uint16_t ReflectionVKShader::enum_names[];
	constexpr uint16_t ReflectionVKShader::enum_bases[];
	constexpr uint16_t ReflectionVKShader::enum_var_names[];
	static ReflectionVKShader reflection_vk_shader;
	
	// Tellusim::GLShader
	class ReflectionGLShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLShader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLShader::*)(uint32_t)>(&GLShader::attachShader));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(GLShader::*)() const>(&GLShader::getShaderType));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(GLShader::*)() const>(&GLShader::getShaderID));
						case 3: return FunctionPtr(new FunctionImpl<GLShader(GLShader::*)() const>(&GLShader::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(GLShader::*)()>(&GLShader::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLShader::*)()>(&GLShader::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<GLShader&(GLShader::*)()>(&GLShader::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<GLShader&(GLShader::*)()>(&GLShader::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(GLShader::*)() const>(&GLShader::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(GLShader::*)() const>(&GLShader::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(GLShader::*)() const>(&GLShader::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(GLShader::*)() const>(&GLShader::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(GLShader::*)() const>(&GLShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1560, 2756, 2754, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 795, 4073, 4073, 796, 796, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4039 };
			static constexpr uint16_t function_arg_names[] = { 3364 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLShader::constructor_bases[];
	constexpr uint16_t ReflectionGLShader::constructor_arg_types[];
	constexpr uint16_t ReflectionGLShader::constructor_arg_names[];
	constexpr uint16_t ReflectionGLShader::constructor_arg_values[];
	constexpr uint8_t ReflectionGLShader::function_flags[];
	constexpr uint16_t ReflectionGLShader::function_names[];
	constexpr uint16_t ReflectionGLShader::function_types[];
	constexpr uint16_t ReflectionGLShader::function_bases[];
	constexpr uint16_t ReflectionGLShader::function_arg_types[];
	constexpr uint16_t ReflectionGLShader::function_arg_names[];
	constexpr uint16_t ReflectionGLShader::function_arg_values[];
	constexpr uint16_t ReflectionGLShader::callback_names[];
	constexpr uint16_t ReflectionGLShader::callback_types[];
	constexpr uint16_t ReflectionGLShader::callback_bases[];
	constexpr uint16_t ReflectionGLShader::callback_arg_types[];
	constexpr uint16_t ReflectionGLShader::callback_arg_names[];
	constexpr uint16_t ReflectionGLShader::enum_names[];
	constexpr uint16_t ReflectionGLShader::enum_bases[];
	constexpr uint16_t ReflectionGLShader::enum_var_names[];
	static ReflectionGLShader reflection_gl_shader;
	
	// Tellusim::GLESShader
	class ReflectionGLESShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLESShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLESShader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLESShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLESShader::*)(uint32_t)>(&GLESShader::attachShader));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(GLESShader::*)() const>(&GLESShader::getShaderType));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(GLESShader::*)() const>(&GLESShader::getShaderID));
						case 3: return FunctionPtr(new FunctionImpl<GLESShader(GLESShader::*)() const>(&GLESShader::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(GLESShader::*)()>(&GLESShader::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLESShader::*)()>(&GLESShader::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<GLESShader&(GLESShader::*)()>(&GLESShader::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<GLESShader&(GLESShader::*)()>(&GLESShader::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(GLESShader::*)() const>(&GLESShader::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(GLESShader::*)() const>(&GLESShader::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(GLESShader::*)() const>(&GLESShader::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(GLESShader::*)() const>(&GLESShader::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(GLESShader::*)() const>(&GLESShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1560, 2756, 2754, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 787, 4073, 4073, 788, 788, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4039 };
			static constexpr uint16_t function_arg_names[] = { 3364 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLESShader::constructor_bases[];
	constexpr uint16_t ReflectionGLESShader::constructor_arg_types[];
	constexpr uint16_t ReflectionGLESShader::constructor_arg_names[];
	constexpr uint16_t ReflectionGLESShader::constructor_arg_values[];
	constexpr uint8_t ReflectionGLESShader::function_flags[];
	constexpr uint16_t ReflectionGLESShader::function_names[];
	constexpr uint16_t ReflectionGLESShader::function_types[];
	constexpr uint16_t ReflectionGLESShader::function_bases[];
	constexpr uint16_t ReflectionGLESShader::function_arg_types[];
	constexpr uint16_t ReflectionGLESShader::function_arg_names[];
	constexpr uint16_t ReflectionGLESShader::function_arg_values[];
	constexpr uint16_t ReflectionGLESShader::callback_names[];
	constexpr uint16_t ReflectionGLESShader::callback_types[];
	constexpr uint16_t ReflectionGLESShader::callback_bases[];
	constexpr uint16_t ReflectionGLESShader::callback_arg_types[];
	constexpr uint16_t ReflectionGLESShader::callback_arg_names[];
	constexpr uint16_t ReflectionGLESShader::enum_names[];
	constexpr uint16_t ReflectionGLESShader::enum_bases[];
	constexpr uint16_t ReflectionGLESShader::enum_var_names[];
	static ReflectionGLESShader reflection_gles_shader;
	
	// Tellusim::CUShader
	class ReflectionCUShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CUShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CUShader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CUShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<CUmodule(CUShader::*)() const>(&CUShader::getModule));
						case 1: return FunctionPtr(new FunctionImpl<CUfunction(CUShader::*)() const>(&CUShader::getFunction));
						case 2: return FunctionPtr(new FunctionImpl<CUShader(CUShader::*)() const>(&CUShader::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(CUShader::*)()>(&CUShader::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(CUShader::*)()>(&CUShader::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<CUShader&(CUShader::*)()>(&CUShader::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<CUShader&(CUShader::*)()>(&CUShader::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(CUShader::*)() const>(&CUShader::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(CUShader::*)() const>(&CUShader::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(CUShader::*)() const>(&CUShader::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(CUShader::*)() const>(&CUShader::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(CUShader::*)() const>(&CUShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2530, 2367, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 214, 212, 204, 4073, 4073, 205, 205, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCUShader::constructor_bases[];
	constexpr uint16_t ReflectionCUShader::constructor_arg_types[];
	constexpr uint16_t ReflectionCUShader::constructor_arg_names[];
	constexpr uint16_t ReflectionCUShader::constructor_arg_values[];
	constexpr uint8_t ReflectionCUShader::function_flags[];
	constexpr uint16_t ReflectionCUShader::function_names[];
	constexpr uint16_t ReflectionCUShader::function_types[];
	constexpr uint16_t ReflectionCUShader::function_bases[];
	constexpr uint16_t ReflectionCUShader::function_arg_types[];
	constexpr uint16_t ReflectionCUShader::function_arg_names[];
	constexpr uint16_t ReflectionCUShader::function_arg_values[];
	constexpr uint16_t ReflectionCUShader::callback_names[];
	constexpr uint16_t ReflectionCUShader::callback_types[];
	constexpr uint16_t ReflectionCUShader::callback_bases[];
	constexpr uint16_t ReflectionCUShader::callback_arg_types[];
	constexpr uint16_t ReflectionCUShader::callback_arg_names[];
	constexpr uint16_t ReflectionCUShader::enum_names[];
	constexpr uint16_t ReflectionCUShader::enum_bases[];
	constexpr uint16_t ReflectionCUShader::enum_var_names[];
	static ReflectionCUShader reflection_cu_shader;
	
	// Tellusim::HIPShader
	class ReflectionHIPShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return HIPShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<HIPShader, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<HIPShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(HIPShader::*)() const>(&HIPShader::getModule));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(HIPShader::*)() const>(&HIPShader::getFunction));
						case 2: return FunctionPtr(new FunctionImpl<HIPShader(HIPShader::*)() const>(&HIPShader::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(HIPShader::*)()>(&HIPShader::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(HIPShader::*)()>(&HIPShader::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<HIPShader&(HIPShader::*)()>(&HIPShader::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<HIPShader&(HIPShader::*)()>(&HIPShader::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(HIPShader::*)() const>(&HIPShader::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(HIPShader::*)() const>(&HIPShader::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(HIPShader::*)() const>(&HIPShader::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(HIPShader::*)() const>(&HIPShader::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(HIPShader::*)() const>(&HIPShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2530, 2367, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 808, 4073, 4073, 809, 809, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionHIPShader::constructor_bases[];
	constexpr uint16_t ReflectionHIPShader::constructor_arg_types[];
	constexpr uint16_t ReflectionHIPShader::constructor_arg_names[];
	constexpr uint16_t ReflectionHIPShader::constructor_arg_values[];
	constexpr uint8_t ReflectionHIPShader::function_flags[];
	constexpr uint16_t ReflectionHIPShader::function_names[];
	constexpr uint16_t ReflectionHIPShader::function_types[];
	constexpr uint16_t ReflectionHIPShader::function_bases[];
	constexpr uint16_t ReflectionHIPShader::function_arg_types[];
	constexpr uint16_t ReflectionHIPShader::function_arg_names[];
	constexpr uint16_t ReflectionHIPShader::function_arg_values[];
	constexpr uint16_t ReflectionHIPShader::callback_names[];
	constexpr uint16_t ReflectionHIPShader::callback_types[];
	constexpr uint16_t ReflectionHIPShader::callback_bases[];
	constexpr uint16_t ReflectionHIPShader::callback_arg_types[];
	constexpr uint16_t ReflectionHIPShader::callback_arg_names[];
	constexpr uint16_t ReflectionHIPShader::enum_names[];
	constexpr uint16_t ReflectionHIPShader::enum_bases[];
	constexpr uint16_t ReflectionHIPShader::enum_var_names[];
	static ReflectionHIPShader reflection_hip_shader;
	
	// Tellusim::FUShader
	class ReflectionFUShader : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUShader::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_shader;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUShader, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUShader, TypeList<const Array<Shader>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUShader>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUShader::*)(uint32_t)>(&FUShader::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUShader::*)() const>(&FUShader::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUShader::*)() const>(&FUShader::getNumShaders));
						case 3: return FunctionPtr(new FunctionImpl<const Shader(FUShader::*)(uint32_t) const>(&FUShader::getShader));
						case 4: return FunctionPtr(new FunctionImpl<Shader(FUShader::*)(uint32_t)>(&FUShader::getShader));
						case 5: return FunctionPtr(new FunctionImpl<FUShader(FUShader::*)() const>(&FUShader::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUShader::*)()>(&FUShader::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUShader::*)()>(&FUShader::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUShader&(FUShader::*)()>(&FUShader::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUShader&(FUShader::*)()>(&FUShader::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUShader::*)() const>(&FUShader::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUShader::*)() const>(&FUShader::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUShader::*)() const>(&FUShader::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUShader::*)() const>(&FUShader::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUShader::*)() const>(&FUShader::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1691, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3953, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2609, 2752, 2752, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1837, 1205, 544, 4073, 4073, 545, 545, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUShader::constructor_bases[];
	constexpr uint16_t ReflectionFUShader::constructor_arg_types[];
	constexpr uint16_t ReflectionFUShader::constructor_arg_names[];
	constexpr uint16_t ReflectionFUShader::constructor_arg_values[];
	constexpr uint8_t ReflectionFUShader::function_flags[];
	constexpr uint16_t ReflectionFUShader::function_names[];
	constexpr uint16_t ReflectionFUShader::function_types[];
	constexpr uint16_t ReflectionFUShader::function_bases[];
	constexpr uint16_t ReflectionFUShader::function_arg_types[];
	constexpr uint16_t ReflectionFUShader::function_arg_names[];
	constexpr uint16_t ReflectionFUShader::function_arg_values[];
	constexpr uint16_t ReflectionFUShader::callback_names[];
	constexpr uint16_t ReflectionFUShader::callback_types[];
	constexpr uint16_t ReflectionFUShader::callback_bases[];
	constexpr uint16_t ReflectionFUShader::callback_arg_types[];
	constexpr uint16_t ReflectionFUShader::callback_arg_names[];
	constexpr uint16_t ReflectionFUShader::enum_names[];
	constexpr uint16_t ReflectionFUShader::enum_bases[];
	constexpr uint16_t ReflectionFUShader::enum_var_names[];
	static ReflectionFUShader reflection_fu_shader;
	
	// Tellusim::Sampler
	class ReflectionSampler : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Sampler::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Sampler, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Sampler>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Sampler::*)() const>(&Sampler::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Sampler::*)() const>(&Sampler::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Sampler::*)() const>(&Sampler::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)()>(&Sampler::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Sampler::*)() const>(&Sampler::isCreated));
						case 5: return FunctionPtr(new FunctionImpl<bool(Sampler::*)()>(&Sampler::create));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(const Sampler&)>(&Sampler::setParameters));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::Filter)>(&Sampler::setFilter));
						case 8: return FunctionPtr(new FunctionImpl<Sampler::Filter(Sampler::*)() const>(&Sampler::getFilter));
						case 9: return FunctionPtr(new FunctionImpl<bool(Sampler::*)() const>(&Sampler::isPointFilter));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(uint32_t)>(&Sampler::setAnisotropy));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Sampler::*)() const>(&Sampler::getAnisotropy));
						case 12: return FunctionPtr(new FunctionImpl<bool(Sampler::*)() const>(&Sampler::hasAnisotropy));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::WrapMode)>(&Sampler::setWrapMode));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::WrapMode, Sampler::WrapMode, Sampler::WrapMode)>(&Sampler::setWrapMode));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::WrapMode)>(&Sampler::setWrapModeS));
						case 16: return FunctionPtr(new FunctionImpl<Sampler::WrapMode(Sampler::*)() const>(&Sampler::getWrapModeS));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::WrapMode)>(&Sampler::setWrapModeT));
						case 18: return FunctionPtr(new FunctionImpl<Sampler::WrapMode(Sampler::*)() const>(&Sampler::getWrapModeT));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::WrapMode)>(&Sampler::setWrapModeR));
						case 20: return FunctionPtr(new FunctionImpl<Sampler::WrapMode(Sampler::*)() const>(&Sampler::getWrapModeR));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(float32_t, float32_t, float32_t)>(&Sampler::setLod));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(float32_t)>(&Sampler::setLodMin));
						case 23: return FunctionPtr(new FunctionImpl<float32_t(Sampler::*)() const>(&Sampler::getLodMin));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(float32_t)>(&Sampler::setLodMax));
						case 25: return FunctionPtr(new FunctionImpl<float32_t(Sampler::*)() const>(&Sampler::getLodMax));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(float32_t)>(&Sampler::setLodBias));
						case 27: return FunctionPtr(new FunctionImpl<float32_t(Sampler::*)() const>(&Sampler::getLodBias));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(const Color&)>(&Sampler::setBorderColor));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(float32_t, float32_t, float32_t, float32_t)>(&Sampler::setBorderColor));
						case 30: return FunctionPtr(new FunctionImpl<const Color&(Sampler::*)() const>(&Sampler::getBorderColor));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::CompareFunc)>(&Sampler::setCompareFunc));
						case 32: return FunctionPtr(new FunctionImpl<Sampler::CompareFunc(Sampler::*)() const>(&Sampler::getCompareFunc));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)(Sampler::ReductionMode)>(&Sampler::setReductionMode));
						case 34: return FunctionPtr(new FunctionImpl<Sampler::ReductionMode(Sampler::*)() const>(&Sampler::getReductionMode));
						case 35: return FunctionPtr(new FunctionImpl<Sampler(Sampler::*)() const>(&Sampler::clonePtr));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)()>(&Sampler::clearPtr));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Sampler::*)()>(&Sampler::destroyPtr));
						case 38: return FunctionPtr(new FunctionImpl<Sampler&(Sampler::*)()>(&Sampler::acquirePtr));
						case 39: return FunctionPtr(new FunctionImpl<Sampler&(Sampler::*)()>(&Sampler::unacquirePtr));
						case 40: return FunctionPtr(new FunctionImpl<bool(Sampler::*)() const>(&Sampler::isValidPtr));
						case 41: return FunctionPtr(new FunctionImpl<bool(Sampler::*)() const>(&Sampler::isOwnerPtr));
						case 42: return FunctionPtr(new FunctionImpl<bool(Sampler::*)() const>(&Sampler::isConstPtr));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(Sampler::*)() const>(&Sampler::getCountPtr));
						case 44: return FunctionPtr(new FunctionImpl<const void*(Sampler::*)() const>(&Sampler::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 1902, 3769, 3627, 2340, 3150, 3508, 2091, 2941, 3947, 3947, 3949, 2931, 3950, 2932, 3948, 2930, 3700, 3703, 2473, 3702, 2472, 3701, 2471, 3528, 3528, 2135, 3575, 2221, 3797, 2700, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 1585, 4073, 4073, 1195, 1585, 4073, 4039, 1585, 4073, 4073, 4073, 1198, 4073, 1198, 4073, 1198, 4073, 4073, 2051, 4073, 2051, 4073, 2051, 4073, 4073, 1721, 4073, 1194, 4073, 1197, 1192, 4073, 4073, 1193, 1193, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, 3, 3, 4, 7, 8, 8, 9, 9, 10, 10, 13, 14, 14, 15, 15, 16, 16, 17, 21, 21, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23 };
			static constexpr uint16_t function_arg_types[] = { 1834, 1195, 4039, 1198, 1198, 1198, 1198, 1198, 1198, 1198, 2051, 2051, 2051, 2051, 2051, 2051, 1721, 2051, 2051, 2051, 2051, 1194, 1197 };
			static constexpr uint16_t function_arg_names[] = { 3478, 2022, 1551, 3275, 3277, 3278, 3276, 3275, 3275, 3275, 3271, 3264, 1579, 3271, 3264, 1579, 1650, 3372, 2075, 1567, 1500, 2074, 3275 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 563, 0, 1492, 265, 1178 };
			static constexpr uint16_t enum_bases[] = { 0, 6, 8, 13, 21, 25 };
			static constexpr uint16_t enum_var_names[] = { 573, 569, 565, 564, 575, 1101, 1032, 981, 1494, 1496, 1495, 1493, 1118, 271, 266, 269, 267, 272, 270, 268, 1095, 1179, 1181, 1180, 1110 };
	};
	constexpr uint16_t ReflectionSampler::constructor_bases[];
	constexpr uint16_t ReflectionSampler::constructor_arg_types[];
	constexpr uint16_t ReflectionSampler::constructor_arg_names[];
	constexpr uint16_t ReflectionSampler::constructor_arg_values[];
	constexpr uint8_t ReflectionSampler::function_flags[];
	constexpr uint16_t ReflectionSampler::function_names[];
	constexpr uint16_t ReflectionSampler::function_types[];
	constexpr uint16_t ReflectionSampler::function_bases[];
	constexpr uint16_t ReflectionSampler::function_arg_types[];
	constexpr uint16_t ReflectionSampler::function_arg_names[];
	constexpr uint16_t ReflectionSampler::function_arg_values[];
	constexpr uint16_t ReflectionSampler::callback_names[];
	constexpr uint16_t ReflectionSampler::callback_types[];
	constexpr uint16_t ReflectionSampler::callback_bases[];
	constexpr uint16_t ReflectionSampler::callback_arg_types[];
	constexpr uint16_t ReflectionSampler::callback_arg_names[];
	constexpr uint16_t ReflectionSampler::enum_names[];
	constexpr uint16_t ReflectionSampler::enum_bases[];
	constexpr uint16_t ReflectionSampler::enum_var_names[];
	static ReflectionSampler reflection_sampler;
	
	// Tellusim::MTLSampler
	class ReflectionMTLSampler : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLSampler::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_sampler;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLSampler, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLSampler>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MTLSampler::*)(bool)>(&MTLSampler::setIndirect));
						case 1: return FunctionPtr(new FunctionImpl<bool(MTLSampler::*)() const>(&MTLSampler::isIndirect));
						case 2: return FunctionPtr(new FunctionImpl<MTLSampler(MTLSampler::*)() const>(&MTLSampler::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MTLSampler::*)()>(&MTLSampler::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MTLSampler::*)()>(&MTLSampler::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<MTLSampler&(MTLSampler::*)()>(&MTLSampler::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<MTLSampler&(MTLSampler::*)()>(&MTLSampler::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(MTLSampler::*)() const>(&MTLSampler::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(MTLSampler::*)() const>(&MTLSampler::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLSampler::*)() const>(&MTLSampler::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(MTLSampler::*)() const>(&MTLSampler::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(MTLSampler::*)() const>(&MTLSampler::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3671, 3098, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 913, 4073, 4073, 914, 914, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 1585 };
			static constexpr uint16_t function_arg_names[] = { 1996 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLSampler::constructor_bases[];
	constexpr uint16_t ReflectionMTLSampler::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLSampler::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLSampler::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLSampler::function_flags[];
	constexpr uint16_t ReflectionMTLSampler::function_names[];
	constexpr uint16_t ReflectionMTLSampler::function_types[];
	constexpr uint16_t ReflectionMTLSampler::function_bases[];
	constexpr uint16_t ReflectionMTLSampler::function_arg_types[];
	constexpr uint16_t ReflectionMTLSampler::function_arg_names[];
	constexpr uint16_t ReflectionMTLSampler::function_arg_values[];
	constexpr uint16_t ReflectionMTLSampler::callback_names[];
	constexpr uint16_t ReflectionMTLSampler::callback_types[];
	constexpr uint16_t ReflectionMTLSampler::callback_bases[];
	constexpr uint16_t ReflectionMTLSampler::callback_arg_types[];
	constexpr uint16_t ReflectionMTLSampler::callback_arg_names[];
	constexpr uint16_t ReflectionMTLSampler::enum_names[];
	constexpr uint16_t ReflectionMTLSampler::enum_bases[];
	constexpr uint16_t ReflectionMTLSampler::enum_var_names[];
	static ReflectionMTLSampler reflection_mtl_sampler;
	
	// Tellusim::FUSampler
	class ReflectionFUSampler : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUSampler::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_sampler;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUSampler, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUSampler, TypeList<const Array<Sampler>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUSampler>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUSampler::*)(uint32_t)>(&FUSampler::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUSampler::*)() const>(&FUSampler::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUSampler::*)() const>(&FUSampler::getNumSamplers));
						case 3: return FunctionPtr(new FunctionImpl<const Sampler(FUSampler::*)(uint32_t) const>(&FUSampler::getSampler));
						case 4: return FunctionPtr(new FunctionImpl<Sampler(FUSampler::*)(uint32_t)>(&FUSampler::getSampler));
						case 5: return FunctionPtr(new FunctionImpl<FUSampler(FUSampler::*)() const>(&FUSampler::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUSampler::*)()>(&FUSampler::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUSampler::*)()>(&FUSampler::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUSampler&(FUSampler::*)()>(&FUSampler::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUSampler&(FUSampler::*)()>(&FUSampler::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUSampler::*)() const>(&FUSampler::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUSampler::*)() const>(&FUSampler::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUSampler::*)() const>(&FUSampler::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUSampler::*)() const>(&FUSampler::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUSampler::*)() const>(&FUSampler::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1690, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3479, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2606, 2723, 2723, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1833, 1192, 542, 4073, 4073, 543, 543, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUSampler::constructor_bases[];
	constexpr uint16_t ReflectionFUSampler::constructor_arg_types[];
	constexpr uint16_t ReflectionFUSampler::constructor_arg_names[];
	constexpr uint16_t ReflectionFUSampler::constructor_arg_values[];
	constexpr uint8_t ReflectionFUSampler::function_flags[];
	constexpr uint16_t ReflectionFUSampler::function_names[];
	constexpr uint16_t ReflectionFUSampler::function_types[];
	constexpr uint16_t ReflectionFUSampler::function_bases[];
	constexpr uint16_t ReflectionFUSampler::function_arg_types[];
	constexpr uint16_t ReflectionFUSampler::function_arg_names[];
	constexpr uint16_t ReflectionFUSampler::function_arg_values[];
	constexpr uint16_t ReflectionFUSampler::callback_names[];
	constexpr uint16_t ReflectionFUSampler::callback_types[];
	constexpr uint16_t ReflectionFUSampler::callback_bases[];
	constexpr uint16_t ReflectionFUSampler::callback_arg_types[];
	constexpr uint16_t ReflectionFUSampler::callback_arg_names[];
	constexpr uint16_t ReflectionFUSampler::enum_names[];
	constexpr uint16_t ReflectionFUSampler::enum_bases[];
	constexpr uint16_t ReflectionFUSampler::enum_var_names[];
	static ReflectionFUSampler reflection_fu_sampler;
	
	// Tellusim::Texture
	class ReflectionTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Texture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Texture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Texture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Texture::*)() const>(&Texture::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Texture::*)() const>(&Texture::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Texture::*)()>(&Texture::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Texture::*)(const char*)>(&Texture::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(Texture::*)() const>(&Texture::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Texture::Type, Format, const Size&, uint32_t, Texture::Flags)>(&Texture::create, (Texture::Type)0, (Format)0, {}, {}, Texture::DefaultFlags));
						case 8: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, Texture::Flags)>(&Texture::create2D, (Format)0, {}, Texture::DefaultFlags));
						case 9: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, Texture::Flags)>(&Texture::create3D, (Format)0, {}, Texture::DefaultFlags));
						case 10: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, Texture::Flags)>(&Texture::createCube, (Format)0, {}, Texture::DefaultFlags));
						case 11: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, uint32_t, Texture::Flags)>(&Texture::create2D, (Format)0, {}, {}, Texture::DefaultFlags));
						case 12: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, uint32_t, uint32_t, Texture::Flags)>(&Texture::create3D, (Format)0, {}, {}, {}, Texture::DefaultFlags));
						case 13: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, uint32_t, uint32_t, Texture::Flags)>(&Texture::create2D, (Format)0, {}, {}, {}, Texture::DefaultFlags));
						case 14: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Format, uint32_t, uint32_t, Texture::Flags)>(&Texture::createCube, (Format)0, {}, {}, Texture::DefaultFlags));
						case 15: return FunctionPtr(new FunctionImpl<Texture::Type(Texture::*)() const>(&Texture::getType));
						case 16: return FunctionPtr(new FunctionImpl<const char*(Texture::Type)>(&Texture::getTypeName));
						case 17: return FunctionPtr(new FunctionImpl<const char*(Texture::*)() const>(&Texture::getTypeName));
						case 18: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::is2DType));
						case 19: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::is3DType));
						case 20: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isCubeType));
						case 21: return FunctionPtr(new FunctionImpl<Format(Texture::*)() const>(&Texture::getFormat));
						case 22: return FunctionPtr(new FunctionImpl<const char*(Texture::*)() const>(&Texture::getFormatName));
						case 23: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isColorFormat));
						case 24: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isDepthFormat));
						case 25: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isPixelFormat));
						case 26: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isPlainFormat));
						case 27: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isMixedFormat));
						case 28: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isBlockFormat));
						case 29: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isStencilFormat));
						case 30: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isNormFormat));
						case 31: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isSRGBFormat));
						case 32: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isFloatFormat));
						case 33: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isSignedFormat));
						case 34: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isUnsignedFormat));
						case 35: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isIntegerFormat));
						case 36: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isi8Format));
						case 37: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isu8Format));
						case 38: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::is8BitFormat));
						case 39: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isi16Format));
						case 40: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isu16Format));
						case 41: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isf16Format));
						case 42: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::is16BitFormat));
						case 43: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isi32Format));
						case 44: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isu32Format));
						case 45: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isf32Format));
						case 46: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::is32BitFormat));
						case 47: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isi64Format));
						case 48: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isu64Format));
						case 49: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isf64Format));
						case 50: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::is64BitFormat));
						case 51: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isBC15Format));
						case 52: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isBC67Format));
						case 53: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isETC2Format));
						case 54: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isASTCFormat));
						case 55: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getComponents));
						case 56: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getPixelSize));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getBlockSize));
						case 58: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getBlockWidth));
						case 59: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getBlockHeight));
						case 60: return FunctionPtr(new FunctionImpl<Texture::Flags(Texture::*)() const>(&Texture::getFlags));
						case 61: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Texture::Flags) const>(&Texture::hasFlag));
						case 62: return FunctionPtr(new FunctionImpl<bool(Texture::*)(Texture::Flags) const>(&Texture::hasFlags));
						case 63: return FunctionPtr(new FunctionImpl<String(Texture::*)() const>(&Texture::getFlagsName));
						case 64: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getMultisample));
						case 65: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::hasMultisample));
						case 66: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getWidth));
						case 67: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getHeight));
						case 68: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getDepth));
						case 69: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getFaces));
						case 70: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getLayers));
						case 71: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getMipmaps));
						case 72: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)(const Size&) const>(&Texture::findMipmap));
						case 73: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)(uint32_t) const>(&Texture::getWidth));
						case 74: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)(uint32_t) const>(&Texture::getHeight));
						case 75: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)(uint32_t) const>(&Texture::getDepth));
						case 76: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::hasFaces));
						case 77: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::hasLayers));
						case 78: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::hasMipmaps));
						case 79: return FunctionPtr(new FunctionImpl<Size(Texture::*)() const>(&Texture::getSize));
						case 80: return FunctionPtr(new FunctionImpl<Region(Texture::*)() const>(&Texture::getRegion));
						case 81: return FunctionPtr(new FunctionImpl<Slice(Texture::*)() const>(&Texture::getSlice));
						case 82: return FunctionPtr(new FunctionImpl<Size(Texture::*)(uint32_t) const>(&Texture::getSize));
						case 83: return FunctionPtr(new FunctionImpl<Region(Texture::*)(uint32_t) const>(&Texture::getRegion));
						case 84: return FunctionPtr(new FunctionImpl<Slice(Texture::*)(uint32_t) const>(&Texture::getSlice));
						case 85: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getTileWidth));
						case 86: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getTileHeight));
						case 87: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getTileDepth));
						case 88: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getTileMipmaps));
						case 89: return FunctionPtr(new FunctionImpl<Size(Texture::*)() const>(&Texture::getTileSize));
						case 90: return FunctionPtr(new FunctionImpl<String(Texture::*)() const>(&Texture::getDescription));
						case 91: return FunctionPtr(new FunctionImpl<size_t(Texture::*)() const>(&Texture::getMemory));
						case 92: return FunctionPtr(new FunctionImpl<Texture(Texture::*)() const>(&Texture::clonePtr));
						case 93: return FunctionPtr(new FunctionVoidImpl<void(Texture::*)()>(&Texture::clearPtr));
						case 94: return FunctionPtr(new FunctionVoidImpl<void(Texture::*)()>(&Texture::destroyPtr));
						case 95: return FunctionPtr(new FunctionImpl<Texture&(Texture::*)()>(&Texture::acquirePtr));
						case 96: return FunctionPtr(new FunctionImpl<Texture&(Texture::*)()>(&Texture::unacquirePtr));
						case 97: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isValidPtr));
						case 98: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isOwnerPtr));
						case 99: return FunctionPtr(new FunctionImpl<bool(Texture::*)() const>(&Texture::isConstPtr));
						case 100: return FunctionPtr(new FunctionImpl<uint32_t(Texture::*)() const>(&Texture::getCountPtr));
						case 101: return FunctionPtr(new FunctionImpl<const void*(Texture::*)() const>(&Texture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 1903, 1904, 1914, 1903, 1904, 1903, 1914, 2878, 2879, 2879, 3010, 3012, 3058, 2355, 2357, 3049, 3061, 3147, 3148, 3123, 3031, 3180, 3132, 3163, 3078, 3172, 3199, 3102, 3219, 3223, 3014, 3216, 3220, 3213, 3009, 3217, 3221, 3214, 3011, 3218, 3222, 3215, 3013, 3025, 3026, 3066, 3015, 2223, 2667, 2133, 2134, 2132, 2341, 2947, 2948, 2342, 2554, 2962, 2927, 2410, 2272, 2325, 2468, 2523, 2038, 2927, 2410, 2272, 2946, 2956, 2958, 2760, 2702, 2762, 2760, 2702, 2762, 2856, 2853, 2852, 2854, 2855, 2296, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1298, 1877, 1877, 1585, 1585, 1585, 765, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 4039, 4039, 4039, 4039, 1297, 1585, 1585, 1274, 4039, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1585, 1585, 1585, 1215, 1182, 1218, 1215, 1182, 1218, 4039, 4039, 4039, 4039, 1215, 1274, 3961, 1293, 4073, 4073, 1294, 1294, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 6, 9, 12, 15, 19, 24, 29, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 38, 39, 40, 40, 40, 40, 40, 40, 40, 41, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1298, 765, 1838, 4039, 1297, 765, 4039, 1297, 765, 4039, 1297, 765, 4039, 1297, 765, 4039, 4039, 1297, 765, 4039, 4039, 4039, 1297, 765, 4039, 4039, 4039, 1297, 765, 4039, 4039, 1297, 1298, 1297, 1297, 1838, 4039, 4039, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4036, 2066, 3960, 3237, 2045, 2066, 3960, 2045, 2066, 3960, 2045, 2066, 3960, 2045, 2066, 4089, 2980, 2045, 2066, 4089, 2980, 1959, 2045, 2066, 4089, 2980, 3237, 2045, 2066, 3960, 3237, 2045, 4036, 2045, 2045, 3960, 3274, 3274, 3274, 3274, 3274, 3274 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 437, 0, 0, 437, 0, 0, 437, 0, 0, 437, 0, 0, 0, 437, 0, 0, 0, 0, 437, 0, 0, 0, 0, 437, 0, 0, 0, 437, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 5, 31 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1312, 1313, 1332, 1117, 678, 699, 745, 726, 597, 720, 721, 711, 623, 647, 724, 673, 664, 638, 629, 632, 633, 670, 671, 672, 606, 607, 605, 669, 437, 1102 };
	};
	constexpr uint16_t ReflectionTexture::constructor_bases[];
	constexpr uint16_t ReflectionTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionTexture::function_flags[];
	constexpr uint16_t ReflectionTexture::function_names[];
	constexpr uint16_t ReflectionTexture::function_types[];
	constexpr uint16_t ReflectionTexture::function_bases[];
	constexpr uint16_t ReflectionTexture::function_arg_types[];
	constexpr uint16_t ReflectionTexture::function_arg_names[];
	constexpr uint16_t ReflectionTexture::function_arg_values[];
	constexpr uint16_t ReflectionTexture::callback_names[];
	constexpr uint16_t ReflectionTexture::callback_types[];
	constexpr uint16_t ReflectionTexture::callback_bases[];
	constexpr uint16_t ReflectionTexture::callback_arg_types[];
	constexpr uint16_t ReflectionTexture::callback_arg_names[];
	constexpr uint16_t ReflectionTexture::enum_names[];
	constexpr uint16_t ReflectionTexture::enum_bases[];
	constexpr uint16_t ReflectionTexture::enum_var_names[];
	static ReflectionTexture reflection_texture;
	
	// Tellusim::TextureTable
	class ReflectionTextureTable : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return TextureTable::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<TextureTable, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<TextureTable>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(TextureTable::*)() const>(&TextureTable::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(TextureTable::*)() const>(&TextureTable::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(TextureTable::*)() const>(&TextureTable::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(TextureTable::*)()>(&TextureTable::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(TextureTable::*)() const>(&TextureTable::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(TextureTable::*)(const char*)>(&TextureTable::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(TextureTable::*)() const>(&TextureTable::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(TextureTable::*)(Texture::Type, uint32_t)>(&TextureTable::create));
						case 8: return FunctionPtr(new FunctionImpl<Texture::Type(TextureTable::*)() const>(&TextureTable::getType));
						case 9: return FunctionPtr(new FunctionImpl<const char*(TextureTable::*)() const>(&TextureTable::getTypeName));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(TextureTable::*)() const>(&TextureTable::getSize));
						case 11: return FunctionPtr(new FunctionImpl<Texture(TextureTable::*)(uint32_t) const>(&TextureTable::get));
						case 12: return FunctionPtr(new FunctionImpl<bool(TextureTable::*)(uint32_t) const>(&TextureTable::isOwner));
						case 13: return FunctionPtr(new FunctionImpl<size_t(TextureTable::*)() const>(&TextureTable::getMemory));
						case 14: return FunctionPtr(new FunctionImpl<TextureTable(TextureTable::*)() const>(&TextureTable::clonePtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(TextureTable::*)()>(&TextureTable::clearPtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(TextureTable::*)()>(&TextureTable::destroyPtr));
						case 17: return FunctionPtr(new FunctionImpl<TextureTable&(TextureTable::*)()>(&TextureTable::acquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<TextureTable&(TextureTable::*)()>(&TextureTable::unacquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(TextureTable::*)() const>(&TextureTable::isValidPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(TextureTable::*)() const>(&TextureTable::isOwnerPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(TextureTable::*)() const>(&TextureTable::isConstPtr));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(TextureTable::*)() const>(&TextureTable::getCountPtr));
						case 23: return FunctionPtr(new FunctionImpl<const void*(TextureTable::*)() const>(&TextureTable::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 2878, 2879, 2760, 2078, 3141, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 1298, 1877, 4039, 1293, 1585, 3961, 1299, 4073, 4073, 1300, 1300, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 3, 3, 3, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1298, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4036, 3960, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionTextureTable::constructor_bases[];
	constexpr uint16_t ReflectionTextureTable::constructor_arg_types[];
	constexpr uint16_t ReflectionTextureTable::constructor_arg_names[];
	constexpr uint16_t ReflectionTextureTable::constructor_arg_values[];
	constexpr uint8_t ReflectionTextureTable::function_flags[];
	constexpr uint16_t ReflectionTextureTable::function_names[];
	constexpr uint16_t ReflectionTextureTable::function_types[];
	constexpr uint16_t ReflectionTextureTable::function_bases[];
	constexpr uint16_t ReflectionTextureTable::function_arg_types[];
	constexpr uint16_t ReflectionTextureTable::function_arg_names[];
	constexpr uint16_t ReflectionTextureTable::function_arg_values[];
	constexpr uint16_t ReflectionTextureTable::callback_names[];
	constexpr uint16_t ReflectionTextureTable::callback_types[];
	constexpr uint16_t ReflectionTextureTable::callback_bases[];
	constexpr uint16_t ReflectionTextureTable::callback_arg_types[];
	constexpr uint16_t ReflectionTextureTable::callback_arg_names[];
	constexpr uint16_t ReflectionTextureTable::enum_names[];
	constexpr uint16_t ReflectionTextureTable::enum_bases[];
	constexpr uint16_t ReflectionTextureTable::enum_var_names[];
	static ReflectionTextureTable reflection_texture_table;
	
	// Tellusim::D3D12Texture
	class ReflectionD3D12Texture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Texture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Texture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Texture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(D3D12Texture::*)(Texture::Type, ID3D12Resource*, uint32_t, Texture::Flags, Format)>(&D3D12Texture::create, (Texture::Type)0, {}, {}, Texture::DefaultFlags, Tellusim::FormatUnknown));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Texture::*)() const>(&D3D12Texture::getDXGIFormat));
						case 2: return FunctionPtr(new FunctionImpl<ID3D12Resource*(D3D12Texture::*)() const>(&D3D12Texture::getD3D12Texture));
						case 3: return FunctionPtr(new FunctionImpl<size_t(D3D12Texture::*)() const>(&D3D12Texture::getShaderResourceView));
						case 4: return FunctionPtr(new FunctionImpl<size_t(D3D12Texture::*)() const>(&D3D12Texture::getRenderTargetView));
						case 5: return FunctionPtr(new FunctionImpl<size_t(D3D12Texture::*)() const>(&D3D12Texture::getDepthStencilView));
						case 6: return FunctionPtr(new FunctionImpl<size_t(D3D12Texture::*)() const>(&D3D12Texture::getUnorderedAccessView));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(D3D12Texture::*)(uint32_t)>(&D3D12Texture::setTextureState));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Texture::*)() const>(&D3D12Texture::getTextureState));
						case 9: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Texture::*)() const>(&D3D12Texture::getSharedHandle));
						case 10: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Texture::*)() const>(&D3D12Texture::getInteropHandle));
						case 11: return FunctionPtr(new FunctionImpl<D3D12Texture(D3D12Texture::*)() const>(&D3D12Texture::clonePtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(D3D12Texture::*)()>(&D3D12Texture::clearPtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(D3D12Texture::*)()>(&D3D12Texture::destroyPtr));
						case 14: return FunctionPtr(new FunctionImpl<D3D12Texture&(D3D12Texture::*)()>(&D3D12Texture::acquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<D3D12Texture&(D3D12Texture::*)()>(&D3D12Texture::unacquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(D3D12Texture::*)() const>(&D3D12Texture::isValidPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(D3D12Texture::*)() const>(&D3D12Texture::isOwnerPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(D3D12Texture::*)() const>(&D3D12Texture::isConstPtr));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Texture::*)() const>(&D3D12Texture::getCountPtr));
						case 20: return FunctionPtr(new FunctionImpl<const void*(D3D12Texture::*)() const>(&D3D12Texture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2259, 2258, 2755, 2707, 2292, 2886, 3897, 2847, 2757, 2441, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 832, 3961, 3961, 3961, 3961, 4073, 4039, 4074, 4074, 423, 4073, 4073, 424, 424, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
			static constexpr uint16_t function_arg_types[] = { 1298, 832, 4039, 1297, 765, 4039 };
			static constexpr uint16_t function_arg_names[] = { 4036, 4012, 3983, 2045, 2066, 3983 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 437, 767, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Texture::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Texture::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Texture::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Texture::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Texture::function_flags[];
	constexpr uint16_t ReflectionD3D12Texture::function_names[];
	constexpr uint16_t ReflectionD3D12Texture::function_types[];
	constexpr uint16_t ReflectionD3D12Texture::function_bases[];
	constexpr uint16_t ReflectionD3D12Texture::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Texture::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Texture::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Texture::callback_names[];
	constexpr uint16_t ReflectionD3D12Texture::callback_types[];
	constexpr uint16_t ReflectionD3D12Texture::callback_bases[];
	constexpr uint16_t ReflectionD3D12Texture::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Texture::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Texture::enum_names[];
	constexpr uint16_t ReflectionD3D12Texture::enum_bases[];
	constexpr uint16_t ReflectionD3D12Texture::enum_var_names[];
	static ReflectionD3D12Texture reflection_d3d12_texture;
	
	// Tellusim::D3D11Texture
	class ReflectionD3D11Texture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Texture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Texture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Texture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(D3D11Texture::*)(Texture::Type, ID3D11Texture2D*, Texture::Flags, Format)>(&D3D11Texture::create, (Texture::Type)0, {}, Texture::DefaultFlags, Tellusim::FormatUnknown));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Texture::*)() const>(&D3D11Texture::getDXGIFormat));
						case 2: return FunctionPtr(new FunctionImpl<ID3D11Texture2D*(D3D11Texture::*)() const>(&D3D11Texture::getD3D11Texture));
						case 3: return FunctionPtr(new FunctionImpl<ID3D11ShaderResourceView*(D3D11Texture::*)() const>(&D3D11Texture::getShaderResourceView));
						case 4: return FunctionPtr(new FunctionImpl<ID3D11RenderTargetView*(D3D11Texture::*)() const>(&D3D11Texture::getRenderTargetView));
						case 5: return FunctionPtr(new FunctionImpl<ID3D11DepthStencilView*(D3D11Texture::*)() const>(&D3D11Texture::getDepthStencilView));
						case 6: return FunctionPtr(new FunctionImpl<ID3D11UnorderedAccessView*(D3D11Texture::*)() const>(&D3D11Texture::getUnorderedAccessView));
						case 7: return FunctionPtr(new FunctionVoidImpl<void*(D3D11Texture::*)() const>(&D3D11Texture::getInteropHandle));
						case 8: return FunctionPtr(new FunctionImpl<D3D11Texture(D3D11Texture::*)() const>(&D3D11Texture::clonePtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(D3D11Texture::*)()>(&D3D11Texture::clearPtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(D3D11Texture::*)()>(&D3D11Texture::destroyPtr));
						case 11: return FunctionPtr(new FunctionImpl<D3D11Texture&(D3D11Texture::*)()>(&D3D11Texture::acquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<D3D11Texture&(D3D11Texture::*)()>(&D3D11Texture::unacquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(D3D11Texture::*)() const>(&D3D11Texture::isValidPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(D3D11Texture::*)() const>(&D3D11Texture::isOwnerPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(D3D11Texture::*)() const>(&D3D11Texture::isConstPtr));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Texture::*)() const>(&D3D11Texture::getCountPtr));
						case 17: return FunctionPtr(new FunctionImpl<const void*(D3D11Texture::*)() const>(&D3D11Texture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2259, 2254, 2755, 2707, 2292, 2886, 2441, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 827, 826, 824, 821, 828, 4074, 401, 4073, 4073, 402, 402, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 1298, 827, 1297, 765 };
			static constexpr uint16_t function_arg_names[] = { 4036, 4012, 2045, 2066 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 437, 767 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Texture::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Texture::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Texture::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Texture::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Texture::function_flags[];
	constexpr uint16_t ReflectionD3D11Texture::function_names[];
	constexpr uint16_t ReflectionD3D11Texture::function_types[];
	constexpr uint16_t ReflectionD3D11Texture::function_bases[];
	constexpr uint16_t ReflectionD3D11Texture::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Texture::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Texture::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Texture::callback_names[];
	constexpr uint16_t ReflectionD3D11Texture::callback_types[];
	constexpr uint16_t ReflectionD3D11Texture::callback_bases[];
	constexpr uint16_t ReflectionD3D11Texture::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Texture::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Texture::enum_names[];
	constexpr uint16_t ReflectionD3D11Texture::enum_bases[];
	constexpr uint16_t ReflectionD3D11Texture::enum_var_names[];
	static ReflectionD3D11Texture reflection_d3d11_texture;
	
	// Tellusim::MTLTexture
	class ReflectionMTLTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLTexture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(MTLTexture::*)(void*, Texture::Flags, Format)>(&MTLTexture::create, {}, Texture::DefaultFlags, Tellusim::FormatUnknown));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(MTLTexture::*)() const>(&MTLTexture::getPixelFormat));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(MTLTexture::*)() const>(&MTLTexture::getTextureType));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(MTLTexture::*)() const>(&MTLTexture::getMTLTexture));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(MTLTexture::*)() const>(&MTLTexture::getMTLBuffer));
						case 5: return FunctionPtr(new FunctionVoidImpl<void*(MTLTexture::*)() const>(&MTLTexture::getSharedPtr));
						case 6: return FunctionPtr(new FunctionImpl<MTLTexture(MTLTexture::*)() const>(&MTLTexture::clonePtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(MTLTexture::*)()>(&MTLTexture::clearPtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(MTLTexture::*)()>(&MTLTexture::destroyPtr));
						case 9: return FunctionPtr(new FunctionImpl<MTLTexture&(MTLTexture::*)()>(&MTLTexture::acquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<MTLTexture&(MTLTexture::*)()>(&MTLTexture::unacquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(MTLTexture::*)() const>(&MTLTexture::isValidPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(MTLTexture::*)() const>(&MTLTexture::isOwnerPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(MTLTexture::*)() const>(&MTLTexture::isConstPtr));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(MTLTexture::*)() const>(&MTLTexture::getCountPtr));
						case 15: return FunctionPtr(new FunctionImpl<const void*(MTLTexture::*)() const>(&MTLTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2666, 2848, 2477, 2475, 2759, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 4074, 4074, 4074, 921, 4073, 4073, 922, 922, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4074, 1297, 765 };
			static constexpr uint16_t function_arg_names[] = { 4012, 2045, 2066 };
			static constexpr uint16_t function_arg_values[] = { 0, 437, 767 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLTexture::constructor_bases[];
	constexpr uint16_t ReflectionMTLTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLTexture::function_flags[];
	constexpr uint16_t ReflectionMTLTexture::function_names[];
	constexpr uint16_t ReflectionMTLTexture::function_types[];
	constexpr uint16_t ReflectionMTLTexture::function_bases[];
	constexpr uint16_t ReflectionMTLTexture::function_arg_types[];
	constexpr uint16_t ReflectionMTLTexture::function_arg_names[];
	constexpr uint16_t ReflectionMTLTexture::function_arg_values[];
	constexpr uint16_t ReflectionMTLTexture::callback_names[];
	constexpr uint16_t ReflectionMTLTexture::callback_types[];
	constexpr uint16_t ReflectionMTLTexture::callback_bases[];
	constexpr uint16_t ReflectionMTLTexture::callback_arg_types[];
	constexpr uint16_t ReflectionMTLTexture::callback_arg_names[];
	constexpr uint16_t ReflectionMTLTexture::enum_names[];
	constexpr uint16_t ReflectionMTLTexture::enum_bases[];
	constexpr uint16_t ReflectionMTLTexture::enum_var_names[];
	static ReflectionMTLTexture reflection_mtl_texture;
	
	// Tellusim::VKTexture
	class ReflectionVKTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKTexture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(VKTexture::*)(Texture::Type, uint32_t, VkImage, uint32_t, Texture::Flags, Format)>(&VKTexture::create, (Texture::Type)0, {}, {}, {}, Texture::DefaultFlags, Tellusim::FormatUnknown));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(VKTexture::*)() const>(&VKTexture::getPixelFormat));
						case 2: return FunctionPtr(new FunctionImpl<VkImage(VKTexture::*)() const>(&VKTexture::getVKTexture));
						case 3: return FunctionPtr(new FunctionImpl<VkImageView(VKTexture::*)() const>(&VKTexture::getTextureView));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(VKTexture::*)(uint32_t)>(&VKTexture::setTextureLayout));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(VKTexture::*)() const>(&VKTexture::getTextureLayout));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(VKTexture::*)(void*, const Slice&) const>(&VKTexture::getTextureRange));
						case 7: return FunctionPtr(new FunctionVoidImpl<void*(VKTexture::*)() const>(&VKTexture::getSharedPtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void*(VKTexture::*)() const>(&VKTexture::getInteropHandle));
						case 9: return FunctionPtr(new FunctionImpl<VKTexture(VKTexture::*)() const>(&VKTexture::clonePtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(VKTexture::*)()>(&VKTexture::clearPtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(VKTexture::*)()>(&VKTexture::destroyPtr));
						case 12: return FunctionPtr(new FunctionImpl<VKTexture&(VKTexture::*)()>(&VKTexture::acquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<VKTexture&(VKTexture::*)()>(&VKTexture::unacquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(VKTexture::*)() const>(&VKTexture::isValidPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(VKTexture::*)() const>(&VKTexture::isOwnerPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(VKTexture::*)() const>(&VKTexture::isConstPtr));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(VKTexture::*)() const>(&VKTexture::getCountPtr));
						case 18: return FunctionPtr(new FunctionImpl<const void*(VKTexture::*)() const>(&VKTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2666, 2897, 2849, 3890, 2835, 2843, 2759, 2441, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 1457, 1458, 4073, 4039, 4073, 4074, 4074, 1414, 4073, 4073, 1415, 1415, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 6, 6, 6, 6, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 };
			static constexpr uint16_t function_arg_types[] = { 1298, 4039, 1457, 4039, 1297, 765, 4039, 4074, 1839 };
			static constexpr uint16_t function_arg_names[] = { 4036, 2066, 4012, 3238, 2045, 4013, 3238, 3377, 3967 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 437, 767, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKTexture::constructor_bases[];
	constexpr uint16_t ReflectionVKTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionVKTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionVKTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionVKTexture::function_flags[];
	constexpr uint16_t ReflectionVKTexture::function_names[];
	constexpr uint16_t ReflectionVKTexture::function_types[];
	constexpr uint16_t ReflectionVKTexture::function_bases[];
	constexpr uint16_t ReflectionVKTexture::function_arg_types[];
	constexpr uint16_t ReflectionVKTexture::function_arg_names[];
	constexpr uint16_t ReflectionVKTexture::function_arg_values[];
	constexpr uint16_t ReflectionVKTexture::callback_names[];
	constexpr uint16_t ReflectionVKTexture::callback_types[];
	constexpr uint16_t ReflectionVKTexture::callback_bases[];
	constexpr uint16_t ReflectionVKTexture::callback_arg_types[];
	constexpr uint16_t ReflectionVKTexture::callback_arg_names[];
	constexpr uint16_t ReflectionVKTexture::enum_names[];
	constexpr uint16_t ReflectionVKTexture::enum_bases[];
	constexpr uint16_t ReflectionVKTexture::enum_var_names[];
	static ReflectionVKTexture reflection_vk_texture;
	
	// Tellusim::GLTexture
	class ReflectionGLTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLTexture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLTexture::*)(uint32_t, uint32_t, Texture::Flags, Format)>(&GLTexture::create, {}, {}, Texture::DefaultFlags, Tellusim::FormatUnknown));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(GLTexture::*)() const>(&GLTexture::getTarget));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(GLTexture::*)() const>(&GLTexture::getInternalFormat));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(GLTexture::*)() const>(&GLTexture::getTextureID));
						case 4: return FunctionPtr(new FunctionImpl<GLTexture(GLTexture::*)() const>(&GLTexture::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLTexture::*)()>(&GLTexture::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(GLTexture::*)()>(&GLTexture::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<GLTexture&(GLTexture::*)()>(&GLTexture::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<GLTexture&(GLTexture::*)()>(&GLTexture::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(GLTexture::*)() const>(&GLTexture::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(GLTexture::*)() const>(&GLTexture::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(GLTexture::*)() const>(&GLTexture::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(GLTexture::*)() const>(&GLTexture::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(GLTexture::*)() const>(&GLTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2815, 2439, 2834, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 4039, 801, 4073, 4073, 802, 802, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 1297, 765 };
			static constexpr uint16_t function_arg_names[] = { 4004, 4014, 2045, 2066 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 437, 767 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLTexture::constructor_bases[];
	constexpr uint16_t ReflectionGLTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionGLTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionGLTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionGLTexture::function_flags[];
	constexpr uint16_t ReflectionGLTexture::function_names[];
	constexpr uint16_t ReflectionGLTexture::function_types[];
	constexpr uint16_t ReflectionGLTexture::function_bases[];
	constexpr uint16_t ReflectionGLTexture::function_arg_types[];
	constexpr uint16_t ReflectionGLTexture::function_arg_names[];
	constexpr uint16_t ReflectionGLTexture::function_arg_values[];
	constexpr uint16_t ReflectionGLTexture::callback_names[];
	constexpr uint16_t ReflectionGLTexture::callback_types[];
	constexpr uint16_t ReflectionGLTexture::callback_bases[];
	constexpr uint16_t ReflectionGLTexture::callback_arg_types[];
	constexpr uint16_t ReflectionGLTexture::callback_arg_names[];
	constexpr uint16_t ReflectionGLTexture::enum_names[];
	constexpr uint16_t ReflectionGLTexture::enum_bases[];
	constexpr uint16_t ReflectionGLTexture::enum_var_names[];
	static ReflectionGLTexture reflection_gl_texture;
	
	// Tellusim::GLESTexture
	class ReflectionGLESTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLESTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLESTexture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLESTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(GLESTexture::*)(uint32_t, uint32_t, Texture::Flags, Format)>(&GLESTexture::create, {}, {}, Texture::DefaultFlags, Tellusim::FormatUnknown));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(GLESTexture::*)() const>(&GLESTexture::getTarget));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(GLESTexture::*)() const>(&GLESTexture::getInternalFormat));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(GLESTexture::*)() const>(&GLESTexture::getTextureID));
						case 4: return FunctionPtr(new FunctionImpl<GLESTexture(GLESTexture::*)() const>(&GLESTexture::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLESTexture::*)()>(&GLESTexture::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(GLESTexture::*)()>(&GLESTexture::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<GLESTexture&(GLESTexture::*)()>(&GLESTexture::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<GLESTexture&(GLESTexture::*)()>(&GLESTexture::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(GLESTexture::*)() const>(&GLESTexture::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(GLESTexture::*)() const>(&GLESTexture::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(GLESTexture::*)() const>(&GLESTexture::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(GLESTexture::*)() const>(&GLESTexture::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(GLESTexture::*)() const>(&GLESTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1902, 2815, 2439, 2834, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 4039, 793, 4073, 4073, 794, 794, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 1297, 765 };
			static constexpr uint16_t function_arg_names[] = { 4004, 4014, 2045, 2066 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 437, 767 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLESTexture::constructor_bases[];
	constexpr uint16_t ReflectionGLESTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionGLESTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionGLESTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionGLESTexture::function_flags[];
	constexpr uint16_t ReflectionGLESTexture::function_names[];
	constexpr uint16_t ReflectionGLESTexture::function_types[];
	constexpr uint16_t ReflectionGLESTexture::function_bases[];
	constexpr uint16_t ReflectionGLESTexture::function_arg_types[];
	constexpr uint16_t ReflectionGLESTexture::function_arg_names[];
	constexpr uint16_t ReflectionGLESTexture::function_arg_values[];
	constexpr uint16_t ReflectionGLESTexture::callback_names[];
	constexpr uint16_t ReflectionGLESTexture::callback_types[];
	constexpr uint16_t ReflectionGLESTexture::callback_bases[];
	constexpr uint16_t ReflectionGLESTexture::callback_arg_types[];
	constexpr uint16_t ReflectionGLESTexture::callback_arg_names[];
	constexpr uint16_t ReflectionGLESTexture::enum_names[];
	constexpr uint16_t ReflectionGLESTexture::enum_bases[];
	constexpr uint16_t ReflectionGLESTexture::enum_var_names[];
	static ReflectionGLESTexture reflection_gles_texture;
	
	// Tellusim::CUTexture
	class ReflectionCUTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CUTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CUTexture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CUTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<CUmipmappedArray(CUTexture::*)() const>(&CUTexture::getTextureArray));
						case 1: return FunctionPtr(new FunctionImpl<CUarray(CUTexture::*)(uint32_t) const>(&CUTexture::getTextureLevel));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(CUTexture::*)() const>(&CUTexture::getArrayFormat));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(CUTexture::*)() const>(&CUTexture::getArrayChannels));
						case 4: return FunctionPtr(new FunctionImpl<CUexternalMemory(CUTexture::*)() const>(&CUTexture::getSharedMemory));
						case 5: return FunctionPtr(new FunctionImpl<CUTexture(CUTexture::*)() const>(&CUTexture::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(CUTexture::*)()>(&CUTexture::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(CUTexture::*)()>(&CUTexture::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<CUTexture&(CUTexture::*)()>(&CUTexture::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<CUTexture&(CUTexture::*)()>(&CUTexture::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(CUTexture::*)() const>(&CUTexture::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(CUTexture::*)() const>(&CUTexture::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(CUTexture::*)() const>(&CUTexture::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(CUTexture::*)() const>(&CUTexture::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(CUTexture::*)() const>(&CUTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2829, 2836, 2095, 2094, 2758, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 213, 208, 4039, 4039, 211, 206, 4073, 4073, 207, 207, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4039 };
			static constexpr uint16_t function_arg_names[] = { 2993 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCUTexture::constructor_bases[];
	constexpr uint16_t ReflectionCUTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionCUTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionCUTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionCUTexture::function_flags[];
	constexpr uint16_t ReflectionCUTexture::function_names[];
	constexpr uint16_t ReflectionCUTexture::function_types[];
	constexpr uint16_t ReflectionCUTexture::function_bases[];
	constexpr uint16_t ReflectionCUTexture::function_arg_types[];
	constexpr uint16_t ReflectionCUTexture::function_arg_names[];
	constexpr uint16_t ReflectionCUTexture::function_arg_values[];
	constexpr uint16_t ReflectionCUTexture::callback_names[];
	constexpr uint16_t ReflectionCUTexture::callback_types[];
	constexpr uint16_t ReflectionCUTexture::callback_bases[];
	constexpr uint16_t ReflectionCUTexture::callback_arg_types[];
	constexpr uint16_t ReflectionCUTexture::callback_arg_names[];
	constexpr uint16_t ReflectionCUTexture::enum_names[];
	constexpr uint16_t ReflectionCUTexture::enum_bases[];
	constexpr uint16_t ReflectionCUTexture::enum_var_names[];
	static ReflectionCUTexture reflection_cu_texture;
	
	// Tellusim::HIPTexture
	class ReflectionHIPTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return HIPTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<HIPTexture, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<HIPTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(HIPTexture::*)() const>(&HIPTexture::getTextureArray));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(HIPTexture::*)(uint32_t) const>(&HIPTexture::getTextureLevel));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(HIPTexture::*)() const>(&HIPTexture::getArrayFormat));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(HIPTexture::*)() const>(&HIPTexture::getArrayChannels));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(HIPTexture::*)() const>(&HIPTexture::getSharedMemory));
						case 5: return FunctionPtr(new FunctionImpl<HIPTexture(HIPTexture::*)() const>(&HIPTexture::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(HIPTexture::*)()>(&HIPTexture::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(HIPTexture::*)()>(&HIPTexture::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<HIPTexture&(HIPTexture::*)()>(&HIPTexture::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<HIPTexture&(HIPTexture::*)()>(&HIPTexture::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(HIPTexture::*)() const>(&HIPTexture::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(HIPTexture::*)() const>(&HIPTexture::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(HIPTexture::*)() const>(&HIPTexture::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(HIPTexture::*)() const>(&HIPTexture::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(HIPTexture::*)() const>(&HIPTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2829, 2836, 2095, 2094, 2758, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 4039, 4039, 4074, 810, 4073, 4073, 811, 811, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4039 };
			static constexpr uint16_t function_arg_names[] = { 2993 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionHIPTexture::constructor_bases[];
	constexpr uint16_t ReflectionHIPTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionHIPTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionHIPTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionHIPTexture::function_flags[];
	constexpr uint16_t ReflectionHIPTexture::function_names[];
	constexpr uint16_t ReflectionHIPTexture::function_types[];
	constexpr uint16_t ReflectionHIPTexture::function_bases[];
	constexpr uint16_t ReflectionHIPTexture::function_arg_types[];
	constexpr uint16_t ReflectionHIPTexture::function_arg_names[];
	constexpr uint16_t ReflectionHIPTexture::function_arg_values[];
	constexpr uint16_t ReflectionHIPTexture::callback_names[];
	constexpr uint16_t ReflectionHIPTexture::callback_types[];
	constexpr uint16_t ReflectionHIPTexture::callback_bases[];
	constexpr uint16_t ReflectionHIPTexture::callback_arg_types[];
	constexpr uint16_t ReflectionHIPTexture::callback_arg_names[];
	constexpr uint16_t ReflectionHIPTexture::enum_names[];
	constexpr uint16_t ReflectionHIPTexture::enum_bases[];
	constexpr uint16_t ReflectionHIPTexture::enum_var_names[];
	static ReflectionHIPTexture reflection_hip_texture;
	
	// Tellusim::FUTexture
	class ReflectionFUTexture : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUTexture::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_texture;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUTexture, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUTexture, TypeList<const Array<Texture>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUTexture>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUTexture::*)(uint32_t)>(&FUTexture::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUTexture::*)() const>(&FUTexture::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUTexture::*)() const>(&FUTexture::getNumTextures));
						case 3: return FunctionPtr(new FunctionImpl<const Texture(FUTexture::*)(uint32_t) const>(&FUTexture::getTexture));
						case 4: return FunctionPtr(new FunctionImpl<Texture(FUTexture::*)(uint32_t)>(&FUTexture::getTexture));
						case 5: return FunctionPtr(new FunctionImpl<FUTexture(FUTexture::*)() const>(&FUTexture::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUTexture::*)()>(&FUTexture::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUTexture::*)()>(&FUTexture::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUTexture&(FUTexture::*)()>(&FUTexture::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUTexture&(FUTexture::*)()>(&FUTexture::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUTexture::*)() const>(&FUTexture::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUTexture::*)() const>(&FUTexture::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUTexture::*)() const>(&FUTexture::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUTexture::*)() const>(&FUTexture::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUTexture::*)() const>(&FUTexture::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1695, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 4015, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2616, 2828, 2828, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1847, 1293, 548, 4073, 4073, 549, 549, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUTexture::constructor_bases[];
	constexpr uint16_t ReflectionFUTexture::constructor_arg_types[];
	constexpr uint16_t ReflectionFUTexture::constructor_arg_names[];
	constexpr uint16_t ReflectionFUTexture::constructor_arg_values[];
	constexpr uint8_t ReflectionFUTexture::function_flags[];
	constexpr uint16_t ReflectionFUTexture::function_names[];
	constexpr uint16_t ReflectionFUTexture::function_types[];
	constexpr uint16_t ReflectionFUTexture::function_bases[];
	constexpr uint16_t ReflectionFUTexture::function_arg_types[];
	constexpr uint16_t ReflectionFUTexture::function_arg_names[];
	constexpr uint16_t ReflectionFUTexture::function_arg_values[];
	constexpr uint16_t ReflectionFUTexture::callback_names[];
	constexpr uint16_t ReflectionFUTexture::callback_types[];
	constexpr uint16_t ReflectionFUTexture::callback_bases[];
	constexpr uint16_t ReflectionFUTexture::callback_arg_types[];
	constexpr uint16_t ReflectionFUTexture::callback_arg_names[];
	constexpr uint16_t ReflectionFUTexture::enum_names[];
	constexpr uint16_t ReflectionFUTexture::enum_bases[];
	constexpr uint16_t ReflectionFUTexture::enum_var_names[];
	static ReflectionFUTexture reflection_fu_texture;
	
	// Tellusim::Tracing
	class ReflectionTracing : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Tracing::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Tracing, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Tracing>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Tracing::*)() const>(&Tracing::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Tracing::*)() const>(&Tracing::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)() const>(&Tracing::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)()>(&Tracing::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isCreated));
						case 5: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isBuilt));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(const char*)>(&Tracing::setName));
						case 7: return FunctionPtr(new FunctionImpl<String(Tracing::*)() const>(&Tracing::getName));
						case 8: return FunctionPtr(new FunctionImpl<bool(Tracing::*)(Tracing::Type, Tracing::Flags)>(&Tracing::create, (Tracing::Type)0, Tracing::DefaultFlags));
						case 9: return FunctionPtr(new FunctionImpl<Tracing::Type(Tracing::*)() const>(&Tracing::getType));
						case 10: return FunctionPtr(new FunctionImpl<const char*(Tracing::Type)>(&Tracing::getTypeName));
						case 11: return FunctionPtr(new FunctionImpl<const char*(Tracing::*)() const>(&Tracing::getTypeName));
						case 12: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isInstanceType));
						case 13: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isTriangleType));
						case 14: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isBoundType));
						case 15: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isGeometryType));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(const Tracing&)>(&Tracing::setParameters));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)() const>(&Tracing::getNumGeometries));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, Buffer&, size_t)>(&Tracing::setInstanceBuffer, {}, Buffer::null, 0));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(Buffer&, size_t)>(&Tracing::setInstanceBuffer, Buffer::null, 0));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t)>(&Tracing::setNumInstances));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)() const>(&Tracing::getNumInstances));
						case 22: return FunctionPtr(new FunctionImpl<Buffer(Tracing::*)() const>(&Tracing::getInstanceBuffer));
						case 23: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)() const>(&Tracing::getInstanceOffset));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(Buffer&, size_t)>(&Tracing::setIndirectBuffer, Buffer::null, 0));
						case 25: return FunctionPtr(new FunctionImpl<Buffer(Tracing::*)() const>(&Tracing::getIndirectBuffer));
						case 26: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)() const>(&Tracing::getIndirectOffset));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t, Format, size_t, Buffer, size_t)>(&Tracing::addVertexBuffer, {}, (Format)0, {}, Buffer::null, 0));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, uint32_t, Buffer&, size_t)>(&Tracing::setVertexBuffer, {}, {}, Buffer::null, 0));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, Buffer&, size_t)>(&Tracing::setVertexBuffer, {}, Buffer::null, 0));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, uint32_t)>(&Tracing::setNumVertices));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t) const>(&Tracing::getNumVertices));
						case 32: return FunctionPtr(new FunctionImpl<Format(Tracing::*)(uint32_t) const>(&Tracing::getVertexFormat));
						case 33: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t) const>(&Tracing::getVertexStride));
						case 34: return FunctionPtr(new FunctionImpl<Buffer(Tracing::*)(uint32_t) const>(&Tracing::getVertexBuffer));
						case 35: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)(uint32_t) const>(&Tracing::getVertexOffset));
						case 36: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t, Format, Buffer, size_t)>(&Tracing::addIndexBuffer, {}, (Format)0, Buffer::null, 0));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, uint32_t, Buffer&, size_t)>(&Tracing::setIndexBuffer, {}, {}, Buffer::null, 0));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, Buffer&, size_t)>(&Tracing::setIndexBuffer, {}, Buffer::null, 0));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, uint32_t)>(&Tracing::setNumIndices));
						case 40: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t) const>(&Tracing::getNumIndices));
						case 41: return FunctionPtr(new FunctionImpl<Format(Tracing::*)(uint32_t) const>(&Tracing::getIndexFormat));
						case 42: return FunctionPtr(new FunctionImpl<Buffer(Tracing::*)(uint32_t) const>(&Tracing::getIndexBuffer));
						case 43: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)(uint32_t) const>(&Tracing::getIndexOffset));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t, size_t, Buffer, size_t)>(&Tracing::addBoundBuffer, {}, {}, Buffer::null, 0));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, uint32_t, Buffer&, size_t)>(&Tracing::setBoundBuffer, {}, {}, Buffer::null, 0));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, Buffer&, size_t)>(&Tracing::setBoundBuffer, {}, Buffer::null, 0));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)(uint32_t, uint32_t)>(&Tracing::setNumBounds));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t) const>(&Tracing::getNumBounds));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)(uint32_t) const>(&Tracing::getBoundStride));
						case 50: return FunctionPtr(new FunctionImpl<Buffer(Tracing::*)(uint32_t) const>(&Tracing::getBoundBuffer));
						case 51: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)(uint32_t) const>(&Tracing::getBoundOffset));
						case 52: return FunctionPtr(new FunctionImpl<String(Tracing::*)() const>(&Tracing::getDescription));
						case 53: return FunctionPtr(new FunctionImpl<uint64_t(Tracing::*)() const>(&Tracing::getTracingAddress));
						case 54: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)() const>(&Tracing::getBuildSize));
						case 55: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)() const>(&Tracing::getUpdateSize));
						case 56: return FunctionPtr(new FunctionImpl<size_t(Tracing::*)() const>(&Tracing::getMemory));
						case 57: return FunctionPtr(new FunctionImpl<Tracing(Tracing::*)() const>(&Tracing::clonePtr));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)()>(&Tracing::clearPtr));
						case 59: return FunctionPtr(new FunctionVoidImpl<void(Tracing::*)()>(&Tracing::destroyPtr));
						case 60: return FunctionPtr(new FunctionImpl<Tracing&(Tracing::*)()>(&Tracing::acquirePtr));
						case 61: return FunctionPtr(new FunctionImpl<Tracing&(Tracing::*)()>(&Tracing::unacquirePtr));
						case 62: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isValidPtr));
						case 63: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isOwnerPtr));
						case 64: return FunctionPtr(new FunctionImpl<bool(Tracing::*)() const>(&Tracing::isConstPtr));
						case 65: return FunctionPtr(new FunctionImpl<uint32_t(Tracing::*)() const>(&Tracing::getCountPtr));
						case 66: return FunctionPtr(new FunctionImpl<const void*(Tracing::*)() const>(&Tracing::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 2, 0, 2, 0, 2, 1, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3037, 3751, 2556, 1902, 2878, 2879, 2879, 3101, 3196, 3033, 3088, 3769, 2582, 3679, 3679, 3757, 2589, 2435, 2437, 3672, 2427, 2429, 1544, 3928, 3928, 3760, 2624, 2910, 2916, 2905, 2912, 1521, 3666, 3666, 3756, 2588, 2424, 2422, 2425, 1512, 3530, 3530, 3754, 2565, 2140, 2137, 2138, 2296, 2865, 2157, 2891, 2500, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 1585, 4073, 1274, 1585, 1307, 1877, 1877, 1585, 1585, 1585, 1585, 4073, 4039, 4073, 4073, 4073, 4039, 152, 3961, 4073, 152, 3961, 4039, 4073, 4073, 4073, 4039, 765, 4039, 152, 3961, 4039, 4073, 4073, 4073, 4039, 765, 152, 3961, 4039, 4073, 4073, 4073, 4039, 4039, 152, 3961, 1274, 4044, 3961, 3961, 3961, 1302, 4073, 4073, 1303, 1303, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 1, 1, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 8, 10, 11, 11, 11, 11, 13, 13, 13, 18, 22, 25, 27, 28, 29, 30, 31, 32, 36, 40, 43, 45, 46, 47, 48, 49, 53, 57, 60, 62, 63, 64, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1307, 1306, 1307, 1850, 4039, 153, 3961, 153, 3961, 4039, 153, 3961, 4039, 765, 3961, 152, 3961, 4039, 4039, 153, 3961, 4039, 153, 3961, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 765, 152, 3961, 4039, 4039, 153, 3961, 4039, 153, 3961, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 3961, 152, 3961, 4039, 4039, 153, 3961, 4039, 153, 3961, 4039, 4039, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4036, 2045, 4036, 4026, 3306, 1593, 3317, 1593, 3317, 3306, 1593, 3317, 3315, 2066, 3991, 1593, 3317, 2993, 3315, 1593, 3317, 2993, 1593, 3317, 2993, 3315, 2993, 2993, 2993, 2993, 2993, 3305, 2066, 1593, 3317, 2993, 3305, 1593, 3317, 2993, 1593, 3317, 2993, 3305, 2993, 2993, 2993, 2993, 3300, 3991, 1593, 3317, 2993, 3300, 1593, 3317, 2993, 1593, 3317, 2993, 3300, 2993, 2993, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 437, 0, 0, 0, 0, 3, 0, 3, 0, 0, 3, 0, 0, 0, 156, 3, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 156, 3, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 156, 3, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311, 753, 0 };
			static constexpr uint16_t enum_bases[] = { 0, 5, 14, 15 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1346, 1388, 1319, 1117, 678, 646, 736, 613, 732, 625, 626, 437, 1102, 850 };
	};
	constexpr uint16_t ReflectionTracing::constructor_bases[];
	constexpr uint16_t ReflectionTracing::constructor_arg_types[];
	constexpr uint16_t ReflectionTracing::constructor_arg_names[];
	constexpr uint16_t ReflectionTracing::constructor_arg_values[];
	constexpr uint8_t ReflectionTracing::function_flags[];
	constexpr uint16_t ReflectionTracing::function_names[];
	constexpr uint16_t ReflectionTracing::function_types[];
	constexpr uint16_t ReflectionTracing::function_bases[];
	constexpr uint16_t ReflectionTracing::function_arg_types[];
	constexpr uint16_t ReflectionTracing::function_arg_names[];
	constexpr uint16_t ReflectionTracing::function_arg_values[];
	constexpr uint16_t ReflectionTracing::callback_names[];
	constexpr uint16_t ReflectionTracing::callback_types[];
	constexpr uint16_t ReflectionTracing::callback_bases[];
	constexpr uint16_t ReflectionTracing::callback_arg_types[];
	constexpr uint16_t ReflectionTracing::callback_arg_names[];
	constexpr uint16_t ReflectionTracing::enum_names[];
	constexpr uint16_t ReflectionTracing::enum_bases[];
	constexpr uint16_t ReflectionTracing::enum_var_names[];
	static ReflectionTracing reflection_tracing;
	
	// Tellusim::D3D12Tracing
	class ReflectionD3D12Tracing : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Tracing::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_tracing;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Tracing, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Tracing>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Tracing::*)(uint32_t) const>(&D3D12Tracing::getGeometryDesc));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Tracing::*)() const>(&D3D12Tracing::getBuildInputs));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Tracing::*)() const>(&D3D12Tracing::getPrebuildInfo));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(D3D12Tracing::*)() const>(&D3D12Tracing::getBuildDesc));
						case 4: return FunctionPtr(new FunctionImpl<Buffer(D3D12Tracing::*)() const>(&D3D12Tracing::getTracingBuffer));
						case 5: return FunctionPtr(new FunctionImpl<size_t(D3D12Tracing::*)() const>(&D3D12Tracing::getShaderResourceView));
						case 6: return FunctionPtr(new FunctionImpl<D3D12Tracing(D3D12Tracing::*)() const>(&D3D12Tracing::clonePtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(D3D12Tracing::*)()>(&D3D12Tracing::clearPtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(D3D12Tracing::*)()>(&D3D12Tracing::destroyPtr));
						case 9: return FunctionPtr(new FunctionImpl<D3D12Tracing&(D3D12Tracing::*)()>(&D3D12Tracing::acquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<D3D12Tracing&(D3D12Tracing::*)()>(&D3D12Tracing::unacquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(D3D12Tracing::*)() const>(&D3D12Tracing::isValidPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(D3D12Tracing::*)() const>(&D3D12Tracing::isOwnerPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(D3D12Tracing::*)() const>(&D3D12Tracing::isConstPtr));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Tracing::*)() const>(&D3D12Tracing::getCountPtr));
						case 15: return FunctionPtr(new FunctionImpl<const void*(D3D12Tracing::*)() const>(&D3D12Tracing::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2394, 2156, 2678, 2153, 2866, 2755, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 4074, 4074, 152, 3961, 425, 4073, 4073, 426, 426, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4039 };
			static constexpr uint16_t function_arg_names[] = { 2993 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Tracing::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Tracing::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Tracing::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Tracing::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Tracing::function_flags[];
	constexpr uint16_t ReflectionD3D12Tracing::function_names[];
	constexpr uint16_t ReflectionD3D12Tracing::function_types[];
	constexpr uint16_t ReflectionD3D12Tracing::function_bases[];
	constexpr uint16_t ReflectionD3D12Tracing::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Tracing::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Tracing::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Tracing::callback_names[];
	constexpr uint16_t ReflectionD3D12Tracing::callback_types[];
	constexpr uint16_t ReflectionD3D12Tracing::callback_bases[];
	constexpr uint16_t ReflectionD3D12Tracing::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Tracing::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Tracing::enum_names[];
	constexpr uint16_t ReflectionD3D12Tracing::enum_bases[];
	constexpr uint16_t ReflectionD3D12Tracing::enum_var_names[];
	static ReflectionD3D12Tracing reflection_d3d12_tracing;
	
	// Tellusim::MTLTracing
	class ReflectionMTLTracing : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLTracing::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_tracing;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLTracing, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLTracing>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(MTLTracing::*)(uint32_t) const>(&MTLTracing::getGeometryDesc));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(MTLTracing::*)() const>(&MTLTracing::getPrimitiveDesc));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLTracing::*)() const>(&MTLTracing::getInstanceDesc));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(MTLTracing::*)() const>(&MTLTracing::getAccelerationStructure));
						case 4: return FunctionPtr(new FunctionImpl<MTLTracing(MTLTracing::*)() const>(&MTLTracing::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLTracing::*)()>(&MTLTracing::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(MTLTracing::*)()>(&MTLTracing::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLTracing&(MTLTracing::*)()>(&MTLTracing::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<MTLTracing&(MTLTracing::*)()>(&MTLTracing::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLTracing::*)() const>(&MTLTracing::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLTracing::*)() const>(&MTLTracing::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(MTLTracing::*)() const>(&MTLTracing::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(MTLTracing::*)() const>(&MTLTracing::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(MTLTracing::*)() const>(&MTLTracing::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2394, 2684, 2436, 2082, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 4074, 4074, 923, 4073, 4073, 924, 924, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4039 };
			static constexpr uint16_t function_arg_names[] = { 2993 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLTracing::constructor_bases[];
	constexpr uint16_t ReflectionMTLTracing::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLTracing::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLTracing::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLTracing::function_flags[];
	constexpr uint16_t ReflectionMTLTracing::function_names[];
	constexpr uint16_t ReflectionMTLTracing::function_types[];
	constexpr uint16_t ReflectionMTLTracing::function_bases[];
	constexpr uint16_t ReflectionMTLTracing::function_arg_types[];
	constexpr uint16_t ReflectionMTLTracing::function_arg_names[];
	constexpr uint16_t ReflectionMTLTracing::function_arg_values[];
	constexpr uint16_t ReflectionMTLTracing::callback_names[];
	constexpr uint16_t ReflectionMTLTracing::callback_types[];
	constexpr uint16_t ReflectionMTLTracing::callback_bases[];
	constexpr uint16_t ReflectionMTLTracing::callback_arg_types[];
	constexpr uint16_t ReflectionMTLTracing::callback_arg_names[];
	constexpr uint16_t ReflectionMTLTracing::enum_names[];
	constexpr uint16_t ReflectionMTLTracing::enum_bases[];
	constexpr uint16_t ReflectionMTLTracing::enum_var_names[];
	static ReflectionMTLTracing reflection_mtl_tracing;
	
	// Tellusim::VKTracing
	class ReflectionVKTracing : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKTracing::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_tracing;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKTracing, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKTracing>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(VKTracing::*)() const>(&VKTracing::getBuildGeometryInfo));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(VKTracing::*)() const>(&VKTracing::getBuildSizeInfo));
						case 2: return FunctionPtr(new FunctionImpl<Buffer(VKTracing::*)() const>(&VKTracing::getTracingBuffer));
						case 3: return FunctionPtr(new FunctionImpl<VkAccelerationStructureKHR(VKTracing::*)() const>(&VKTracing::getAccelerationStructure));
						case 4: return FunctionPtr(new FunctionImpl<VKTracing(VKTracing::*)() const>(&VKTracing::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(VKTracing::*)()>(&VKTracing::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(VKTracing::*)()>(&VKTracing::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<VKTracing&(VKTracing::*)()>(&VKTracing::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<VKTracing&(VKTracing::*)()>(&VKTracing::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(VKTracing::*)() const>(&VKTracing::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(VKTracing::*)() const>(&VKTracing::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(VKTracing::*)() const>(&VKTracing::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(VKTracing::*)() const>(&VKTracing::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(VKTracing::*)() const>(&VKTracing::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2154, 2158, 2866, 2082, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 152, 1449, 1416, 4073, 4073, 1417, 1417, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKTracing::constructor_bases[];
	constexpr uint16_t ReflectionVKTracing::constructor_arg_types[];
	constexpr uint16_t ReflectionVKTracing::constructor_arg_names[];
	constexpr uint16_t ReflectionVKTracing::constructor_arg_values[];
	constexpr uint8_t ReflectionVKTracing::function_flags[];
	constexpr uint16_t ReflectionVKTracing::function_names[];
	constexpr uint16_t ReflectionVKTracing::function_types[];
	constexpr uint16_t ReflectionVKTracing::function_bases[];
	constexpr uint16_t ReflectionVKTracing::function_arg_types[];
	constexpr uint16_t ReflectionVKTracing::function_arg_names[];
	constexpr uint16_t ReflectionVKTracing::function_arg_values[];
	constexpr uint16_t ReflectionVKTracing::callback_names[];
	constexpr uint16_t ReflectionVKTracing::callback_types[];
	constexpr uint16_t ReflectionVKTracing::callback_bases[];
	constexpr uint16_t ReflectionVKTracing::callback_arg_types[];
	constexpr uint16_t ReflectionVKTracing::callback_arg_names[];
	constexpr uint16_t ReflectionVKTracing::enum_names[];
	constexpr uint16_t ReflectionVKTracing::enum_bases[];
	constexpr uint16_t ReflectionVKTracing::enum_var_names[];
	static ReflectionVKTracing reflection_vk_tracing;
	
	// Tellusim::FUTracing
	class ReflectionFUTracing : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUTracing::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_tracing;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUTracing, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUTracing, TypeList<const Array<Tracing>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUTracing>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUTracing::*)(uint32_t)>(&FUTracing::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUTracing::*)() const>(&FUTracing::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUTracing::*)() const>(&FUTracing::getNumTracings));
						case 3: return FunctionPtr(new FunctionImpl<const Tracing(FUTracing::*)(uint32_t) const>(&FUTracing::getTracing));
						case 4: return FunctionPtr(new FunctionImpl<Tracing(FUTracing::*)(uint32_t)>(&FUTracing::getTracing));
						case 5: return FunctionPtr(new FunctionImpl<FUTracing(FUTracing::*)() const>(&FUTracing::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUTracing::*)()>(&FUTracing::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUTracing::*)()>(&FUTracing::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUTracing&(FUTracing::*)()>(&FUTracing::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUTracing&(FUTracing::*)()>(&FUTracing::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUTracing::*)() const>(&FUTracing::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUTracing::*)() const>(&FUTracing::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUTracing::*)() const>(&FUTracing::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUTracing::*)() const>(&FUTracing::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUTracing::*)() const>(&FUTracing::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1697, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 4027, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2619, 2864, 2864, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1849, 1302, 550, 4073, 4073, 551, 551, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUTracing::constructor_bases[];
	constexpr uint16_t ReflectionFUTracing::constructor_arg_types[];
	constexpr uint16_t ReflectionFUTracing::constructor_arg_names[];
	constexpr uint16_t ReflectionFUTracing::constructor_arg_values[];
	constexpr uint8_t ReflectionFUTracing::function_flags[];
	constexpr uint16_t ReflectionFUTracing::function_names[];
	constexpr uint16_t ReflectionFUTracing::function_types[];
	constexpr uint16_t ReflectionFUTracing::function_bases[];
	constexpr uint16_t ReflectionFUTracing::function_arg_types[];
	constexpr uint16_t ReflectionFUTracing::function_arg_names[];
	constexpr uint16_t ReflectionFUTracing::function_arg_values[];
	constexpr uint16_t ReflectionFUTracing::callback_names[];
	constexpr uint16_t ReflectionFUTracing::callback_types[];
	constexpr uint16_t ReflectionFUTracing::callback_bases[];
	constexpr uint16_t ReflectionFUTracing::callback_arg_types[];
	constexpr uint16_t ReflectionFUTracing::callback_arg_names[];
	constexpr uint16_t ReflectionFUTracing::enum_names[];
	constexpr uint16_t ReflectionFUTracing::enum_bases[];
	constexpr uint16_t ReflectionFUTracing::enum_var_names[];
	static ReflectionFUTracing reflection_fu_tracing;
	
	// Tellusim::Target
	class ReflectionTarget : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Target::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Target, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Target>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Target::*)() const>(&Target::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Target::*)() const>(&Target::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getIndex));
						case 3: return FunctionPtr(new FunctionImpl<bool(Target::*)(Fence&)>(&Target::begin));
						case 4: return FunctionPtr(new FunctionImpl<bool(Target::*)()>(&Target::begin));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(Fence&)>(&Target::end));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Target::*)()>(&Target::end));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(Surface&)>(&Target::swap));
						case 8: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::isEnabled));
						case 9: return FunctionPtr(new FunctionImpl<Format(Target::*)(uint32_t) const>(&Target::getColorFormat, 0));
						case 10: return FunctionPtr(new FunctionImpl<Format(Target::*)() const>(&Target::getDepthFormat));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getMultisample));
						case 12: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::hasMultisample));
						case 13: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::isFlipped));
						case 14: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::isAtomic));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getWidth));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getHeight));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getDepth));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getFaces));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getLayers));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getMipmaps));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(const Color&)>(&Target::setClearColor));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(uint32_t, const Color&)>(&Target::setClearColor));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(float32_t, float32_t, float32_t, float32_t)>(&Target::setClearColor));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(uint32_t, float32_t, float32_t, float32_t, float32_t)>(&Target::setClearColor));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(Texture&, Target::Operation, const Slice&)>(&Target::setColorTexture, Texture::null, Target::OpDefault, Slice()));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(uint32_t, Texture&, Target::Operation, const Slice&)>(&Target::setColorTexture, {}, Texture::null, Target::OpDefault, Slice()));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(Texture&, const Slice&)>(&Target::setColorResolve, Texture::null, Slice()));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(uint32_t, Texture&, const Slice&)>(&Target::setColorResolve, {}, Texture::null, Slice()));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getNumTargets));
						case 30: return FunctionPtr(new FunctionImpl<const Color&(Target::*)(uint32_t) const>(&Target::getClearColor, 0));
						case 31: return FunctionPtr(new FunctionImpl<Target::Operation(Target::*)(uint32_t) const>(&Target::getColorOp, 0));
						case 32: return FunctionPtr(new FunctionImpl<Texture(Target::*)(uint32_t) const>(&Target::getColorTexture));
						case 33: return FunctionPtr(new FunctionImpl<Texture(Target::*)(uint32_t) const>(&Target::getColorResolve));
						case 34: return FunctionPtr(new FunctionImpl<const Slice&(Target::*)(uint32_t) const>(&Target::getColorTextureSlice));
						case 35: return FunctionPtr(new FunctionImpl<const Slice&(Target::*)(uint32_t) const>(&Target::getColorResolveSlice));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(float32_t, uint32_t)>(&Target::setClearDepth, {}, 0));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(Texture&, Target::Operation, const Slice&)>(&Target::setDepthTexture, Texture::null, Target::OpDefault, Slice()));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(Target::*)(Texture&, const Slice&)>(&Target::setDepthResolve, Texture::null, Slice()));
						case 39: return FunctionPtr(new FunctionImpl<float32_t(Target::*)() const>(&Target::getClearDepth));
						case 40: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getClearStencil));
						case 41: return FunctionPtr(new FunctionImpl<Target::Operation(Target::*)() const>(&Target::getDepthOp));
						case 42: return FunctionPtr(new FunctionImpl<Texture(Target::*)() const>(&Target::getDepthTexture));
						case 43: return FunctionPtr(new FunctionImpl<Texture(Target::*)() const>(&Target::getDepthResolve));
						case 44: return FunctionPtr(new FunctionImpl<const Slice&(Target::*)() const>(&Target::getDepthTextureSlice));
						case 45: return FunctionPtr(new FunctionImpl<const Slice&(Target::*)() const>(&Target::getDepthResolveSlice));
						case 46: return FunctionPtr(new FunctionImpl<Target(Target::*)() const>(&Target::clonePtr));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Target::*)()>(&Target::clearPtr));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(Target::*)()>(&Target::destroyPtr));
						case 49: return FunctionPtr(new FunctionImpl<Target&(Target::*)()>(&Target::acquirePtr));
						case 50: return FunctionPtr(new FunctionImpl<Target&(Target::*)()>(&Target::unacquirePtr));
						case 51: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::isValidPtr));
						case 52: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::isOwnerPtr));
						case 53: return FunctionPtr(new FunctionImpl<bool(Target::*)() const>(&Target::isConstPtr));
						case 54: return FunctionPtr(new FunctionImpl<uint32_t(Target::*)() const>(&Target::getCountPtr));
						case 55: return FunctionPtr(new FunctionImpl<const void*(Target::*)() const>(&Target::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1576, 1576, 2005, 2005, 3994, 3071, 2202, 2277, 2554, 2962, 3077, 3022, 2927, 2410, 2272, 2325, 2468, 2523, 3556, 3556, 3556, 3556, 3569, 3569, 3568, 3568, 2613, 2192, 2209, 2213, 2211, 2215, 2212, 3557, 3606, 3603, 2193, 2194, 2285, 2293, 2288, 2295, 2289, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 1585, 1585, 4073, 4073, 4073, 1585, 765, 765, 4039, 1585, 1585, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 1721, 1286, 1293, 1293, 1839, 1839, 4073, 4073, 4073, 2051, 4039, 1286, 1293, 1293, 1839, 1839, 1283, 4073, 4073, 1284, 1284, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 7, 11, 16, 19, 23, 25, 28, 28, 29, 30, 31, 32, 33, 34, 36, 39, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41 };
			static constexpr uint16_t function_arg_types[] = { 555, 555, 1280, 4039, 1721, 4039, 1721, 2051, 2051, 2051, 2051, 4039, 2051, 2051, 2051, 2051, 1294, 1286, 1839, 4039, 1294, 1286, 1839, 1294, 1839, 4039, 1294, 1839, 4039, 4039, 4039, 4039, 4039, 4039, 2051, 4039, 1294, 1286, 1839, 1294, 1839 };
			static constexpr uint16_t function_arg_names[] = { 2020, 2020, 3993, 2993, 1650, 2993, 1650, 3372, 2075, 1567, 1500, 2993, 3372, 2075, 1567, 1500, 4012, 3326, 3967, 2993, 4012, 3326, 3967, 4012, 3967, 2993, 4012, 3967, 2993, 2993, 2993, 2993, 2993, 2993, 1959, 3985, 4012, 3326, 3967, 4012, 3967 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1121, 1219, 0, 0, 1121, 1219, 0, 1219, 0, 0, 1219, 3, 3, 0, 0, 0, 0, 0, 3, 0, 1121, 1219, 0, 1219 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1126 };
			static constexpr uint16_t enum_bases[] = { 0, 14 };
			static constexpr uint16_t enum_var_names[] = { 114, 112, 113, 115, 523, 522, 520, 521, 1124, 1122, 1123, 1120, 1119, 1121 };
	};
	constexpr uint16_t ReflectionTarget::constructor_bases[];
	constexpr uint16_t ReflectionTarget::constructor_arg_types[];
	constexpr uint16_t ReflectionTarget::constructor_arg_names[];
	constexpr uint16_t ReflectionTarget::constructor_arg_values[];
	constexpr uint8_t ReflectionTarget::function_flags[];
	constexpr uint16_t ReflectionTarget::function_names[];
	constexpr uint16_t ReflectionTarget::function_types[];
	constexpr uint16_t ReflectionTarget::function_bases[];
	constexpr uint16_t ReflectionTarget::function_arg_types[];
	constexpr uint16_t ReflectionTarget::function_arg_names[];
	constexpr uint16_t ReflectionTarget::function_arg_values[];
	constexpr uint16_t ReflectionTarget::callback_names[];
	constexpr uint16_t ReflectionTarget::callback_types[];
	constexpr uint16_t ReflectionTarget::callback_bases[];
	constexpr uint16_t ReflectionTarget::callback_arg_types[];
	constexpr uint16_t ReflectionTarget::callback_arg_names[];
	constexpr uint16_t ReflectionTarget::enum_names[];
	constexpr uint16_t ReflectionTarget::enum_bases[];
	constexpr uint16_t ReflectionTarget::enum_var_names[];
	static ReflectionTarget reflection_target;
	
	// Tellusim::D3D12Target
	class ReflectionD3D12Target : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Target::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Target, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Target>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<size_t*(D3D12Target::*)() const>(&D3D12Target::getRenderTargetViews));
						case 1: return FunctionPtr(new FunctionImpl<size_t(D3D12Target::*)() const>(&D3D12Target::getDepthStencilView));
						case 2: return FunctionPtr(new FunctionImpl<D3D12Target(D3D12Target::*)() const>(&D3D12Target::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Target::*)()>(&D3D12Target::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D12Target::*)()>(&D3D12Target::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Target&(D3D12Target::*)()>(&D3D12Target::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<D3D12Target&(D3D12Target::*)()>(&D3D12Target::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Target::*)() const>(&D3D12Target::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Target::*)() const>(&D3D12Target::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(D3D12Target::*)() const>(&D3D12Target::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Target::*)() const>(&D3D12Target::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(D3D12Target::*)() const>(&D3D12Target::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2708, 2292, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 3962, 3961, 421, 4073, 4073, 422, 422, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Target::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Target::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Target::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Target::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Target::function_flags[];
	constexpr uint16_t ReflectionD3D12Target::function_names[];
	constexpr uint16_t ReflectionD3D12Target::function_types[];
	constexpr uint16_t ReflectionD3D12Target::function_bases[];
	constexpr uint16_t ReflectionD3D12Target::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Target::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Target::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Target::callback_names[];
	constexpr uint16_t ReflectionD3D12Target::callback_types[];
	constexpr uint16_t ReflectionD3D12Target::callback_bases[];
	constexpr uint16_t ReflectionD3D12Target::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Target::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Target::enum_names[];
	constexpr uint16_t ReflectionD3D12Target::enum_bases[];
	constexpr uint16_t ReflectionD3D12Target::enum_var_names[];
	static ReflectionD3D12Target reflection_d3d12_target;
	
	// Tellusim::D3D11Target
	class ReflectionD3D11Target : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Target::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Target, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Target>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D11RenderTargetView**(D3D11Target::*)() const>(&D3D11Target::getRenderTargetViews));
						case 1: return FunctionPtr(new FunctionImpl<ID3D11DepthStencilView*(D3D11Target::*)() const>(&D3D11Target::getDepthStencilView));
						case 2: return FunctionPtr(new FunctionImpl<D3D11Target(D3D11Target::*)() const>(&D3D11Target::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D11Target::*)()>(&D3D11Target::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D11Target::*)()>(&D3D11Target::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D11Target&(D3D11Target::*)()>(&D3D11Target::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<D3D11Target&(D3D11Target::*)()>(&D3D11Target::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D11Target::*)() const>(&D3D11Target::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D11Target::*)() const>(&D3D11Target::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(D3D11Target::*)() const>(&D3D11Target::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Target::*)() const>(&D3D11Target::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(D3D11Target::*)() const>(&D3D11Target::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2708, 2292, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 825, 821, 399, 4073, 4073, 400, 400, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Target::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Target::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Target::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Target::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Target::function_flags[];
	constexpr uint16_t ReflectionD3D11Target::function_names[];
	constexpr uint16_t ReflectionD3D11Target::function_types[];
	constexpr uint16_t ReflectionD3D11Target::function_bases[];
	constexpr uint16_t ReflectionD3D11Target::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Target::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Target::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Target::callback_names[];
	constexpr uint16_t ReflectionD3D11Target::callback_types[];
	constexpr uint16_t ReflectionD3D11Target::callback_bases[];
	constexpr uint16_t ReflectionD3D11Target::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Target::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Target::enum_names[];
	constexpr uint16_t ReflectionD3D11Target::enum_bases[];
	constexpr uint16_t ReflectionD3D11Target::enum_var_names[];
	static ReflectionD3D11Target reflection_d3d11_target;
	
	// Tellusim::MTLTarget
	class ReflectionMTLTarget : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLTarget::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLTarget, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLTarget>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(MTLTarget::*)() const>(&MTLTarget::getDescriptor));
						case 1: return FunctionPtr(new FunctionImpl<MTLTarget(MTLTarget::*)() const>(&MTLTarget::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(MTLTarget::*)()>(&MTLTarget::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MTLTarget::*)()>(&MTLTarget::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<MTLTarget&(MTLTarget::*)()>(&MTLTarget::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<MTLTarget&(MTLTarget::*)()>(&MTLTarget::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(MTLTarget::*)() const>(&MTLTarget::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(MTLTarget::*)() const>(&MTLTarget::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(MTLTarget::*)() const>(&MTLTarget::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(MTLTarget::*)() const>(&MTLTarget::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(MTLTarget::*)() const>(&MTLTarget::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2297, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 919, 4073, 4073, 920, 920, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLTarget::constructor_bases[];
	constexpr uint16_t ReflectionMTLTarget::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLTarget::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLTarget::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLTarget::function_flags[];
	constexpr uint16_t ReflectionMTLTarget::function_names[];
	constexpr uint16_t ReflectionMTLTarget::function_types[];
	constexpr uint16_t ReflectionMTLTarget::function_bases[];
	constexpr uint16_t ReflectionMTLTarget::function_arg_types[];
	constexpr uint16_t ReflectionMTLTarget::function_arg_names[];
	constexpr uint16_t ReflectionMTLTarget::function_arg_values[];
	constexpr uint16_t ReflectionMTLTarget::callback_names[];
	constexpr uint16_t ReflectionMTLTarget::callback_types[];
	constexpr uint16_t ReflectionMTLTarget::callback_bases[];
	constexpr uint16_t ReflectionMTLTarget::callback_arg_types[];
	constexpr uint16_t ReflectionMTLTarget::callback_arg_names[];
	constexpr uint16_t ReflectionMTLTarget::enum_names[];
	constexpr uint16_t ReflectionMTLTarget::enum_bases[];
	constexpr uint16_t ReflectionMTLTarget::enum_var_names[];
	static ReflectionMTLTarget reflection_mtl_target;
	
	// Tellusim::VKTarget
	class ReflectionVKTarget : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKTarget::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKTarget, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKTarget>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<VkRenderPass(VKTarget::*)() const>(&VKTarget::getRenderPass));
						case 1: return FunctionPtr(new FunctionImpl<VkFramebuffer(VKTarget::*)() const>(&VKTarget::getFramebuffer));
						case 2: return FunctionPtr(new FunctionImpl<VKTarget(VKTarget::*)() const>(&VKTarget::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(VKTarget::*)()>(&VKTarget::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(VKTarget::*)()>(&VKTarget::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<VKTarget&(VKTarget::*)()>(&VKTarget::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<VKTarget&(VKTarget::*)()>(&VKTarget::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(VKTarget::*)() const>(&VKTarget::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(VKTarget::*)() const>(&VKTarget::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(VKTarget::*)() const>(&VKTarget::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(VKTarget::*)() const>(&VKTarget::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(VKTarget::*)() const>(&VKTarget::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2705, 2362, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1462, 1456, 1412, 4073, 4073, 1413, 1413, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKTarget::constructor_bases[];
	constexpr uint16_t ReflectionVKTarget::constructor_arg_types[];
	constexpr uint16_t ReflectionVKTarget::constructor_arg_names[];
	constexpr uint16_t ReflectionVKTarget::constructor_arg_values[];
	constexpr uint8_t ReflectionVKTarget::function_flags[];
	constexpr uint16_t ReflectionVKTarget::function_names[];
	constexpr uint16_t ReflectionVKTarget::function_types[];
	constexpr uint16_t ReflectionVKTarget::function_bases[];
	constexpr uint16_t ReflectionVKTarget::function_arg_types[];
	constexpr uint16_t ReflectionVKTarget::function_arg_names[];
	constexpr uint16_t ReflectionVKTarget::function_arg_values[];
	constexpr uint16_t ReflectionVKTarget::callback_names[];
	constexpr uint16_t ReflectionVKTarget::callback_types[];
	constexpr uint16_t ReflectionVKTarget::callback_bases[];
	constexpr uint16_t ReflectionVKTarget::callback_arg_types[];
	constexpr uint16_t ReflectionVKTarget::callback_arg_names[];
	constexpr uint16_t ReflectionVKTarget::enum_names[];
	constexpr uint16_t ReflectionVKTarget::enum_bases[];
	constexpr uint16_t ReflectionVKTarget::enum_var_names[];
	static ReflectionVKTarget reflection_vk_target;
	
	// Tellusim::GLTarget
	class ReflectionGLTarget : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLTarget::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLTarget, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLTarget>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<uint32_t(GLTarget::*)() const>(&GLTarget::getFramebufferID));
						case 1: return FunctionPtr(new FunctionImpl<GLTarget(GLTarget::*)() const>(&GLTarget::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(GLTarget::*)()>(&GLTarget::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(GLTarget::*)()>(&GLTarget::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<GLTarget&(GLTarget::*)()>(&GLTarget::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<GLTarget&(GLTarget::*)()>(&GLTarget::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(GLTarget::*)() const>(&GLTarget::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(GLTarget::*)() const>(&GLTarget::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(GLTarget::*)() const>(&GLTarget::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(GLTarget::*)() const>(&GLTarget::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(GLTarget::*)() const>(&GLTarget::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2363, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4039, 799, 4073, 4073, 800, 800, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLTarget::constructor_bases[];
	constexpr uint16_t ReflectionGLTarget::constructor_arg_types[];
	constexpr uint16_t ReflectionGLTarget::constructor_arg_names[];
	constexpr uint16_t ReflectionGLTarget::constructor_arg_values[];
	constexpr uint8_t ReflectionGLTarget::function_flags[];
	constexpr uint16_t ReflectionGLTarget::function_names[];
	constexpr uint16_t ReflectionGLTarget::function_types[];
	constexpr uint16_t ReflectionGLTarget::function_bases[];
	constexpr uint16_t ReflectionGLTarget::function_arg_types[];
	constexpr uint16_t ReflectionGLTarget::function_arg_names[];
	constexpr uint16_t ReflectionGLTarget::function_arg_values[];
	constexpr uint16_t ReflectionGLTarget::callback_names[];
	constexpr uint16_t ReflectionGLTarget::callback_types[];
	constexpr uint16_t ReflectionGLTarget::callback_bases[];
	constexpr uint16_t ReflectionGLTarget::callback_arg_types[];
	constexpr uint16_t ReflectionGLTarget::callback_arg_names[];
	constexpr uint16_t ReflectionGLTarget::enum_names[];
	constexpr uint16_t ReflectionGLTarget::enum_bases[];
	constexpr uint16_t ReflectionGLTarget::enum_var_names[];
	static ReflectionGLTarget reflection_gl_target;
	
	// Tellusim::GLESTarget
	class ReflectionGLESTarget : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLESTarget::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLESTarget, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLESTarget>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<uint32_t(GLESTarget::*)() const>(&GLESTarget::getFramebufferID));
						case 1: return FunctionPtr(new FunctionImpl<GLESTarget(GLESTarget::*)() const>(&GLESTarget::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(GLESTarget::*)()>(&GLESTarget::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(GLESTarget::*)()>(&GLESTarget::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<GLESTarget&(GLESTarget::*)()>(&GLESTarget::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<GLESTarget&(GLESTarget::*)()>(&GLESTarget::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(GLESTarget::*)() const>(&GLESTarget::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(GLESTarget::*)() const>(&GLESTarget::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(GLESTarget::*)() const>(&GLESTarget::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(GLESTarget::*)() const>(&GLESTarget::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(GLESTarget::*)() const>(&GLESTarget::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2363, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4039, 791, 4073, 4073, 792, 792, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLESTarget::constructor_bases[];
	constexpr uint16_t ReflectionGLESTarget::constructor_arg_types[];
	constexpr uint16_t ReflectionGLESTarget::constructor_arg_names[];
	constexpr uint16_t ReflectionGLESTarget::constructor_arg_values[];
	constexpr uint8_t ReflectionGLESTarget::function_flags[];
	constexpr uint16_t ReflectionGLESTarget::function_names[];
	constexpr uint16_t ReflectionGLESTarget::function_types[];
	constexpr uint16_t ReflectionGLESTarget::function_bases[];
	constexpr uint16_t ReflectionGLESTarget::function_arg_types[];
	constexpr uint16_t ReflectionGLESTarget::function_arg_names[];
	constexpr uint16_t ReflectionGLESTarget::function_arg_values[];
	constexpr uint16_t ReflectionGLESTarget::callback_names[];
	constexpr uint16_t ReflectionGLESTarget::callback_types[];
	constexpr uint16_t ReflectionGLESTarget::callback_bases[];
	constexpr uint16_t ReflectionGLESTarget::callback_arg_types[];
	constexpr uint16_t ReflectionGLESTarget::callback_arg_names[];
	constexpr uint16_t ReflectionGLESTarget::enum_names[];
	constexpr uint16_t ReflectionGLESTarget::enum_bases[];
	constexpr uint16_t ReflectionGLESTarget::enum_var_names[];
	static ReflectionGLESTarget reflection_gles_target;
	
	// Tellusim::FUTarget
	class ReflectionFUTarget : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUTarget::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_target;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUTarget, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUTarget, TypeList<const Array<Target>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUTarget>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUTarget::*)(uint32_t)>(&FUTarget::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUTarget::*)() const>(&FUTarget::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUTarget::*)() const>(&FUTarget::getNumTargets));
						case 3: return FunctionPtr(new FunctionImpl<const Target(FUTarget::*)(uint32_t) const>(&FUTarget::getTarget));
						case 4: return FunctionPtr(new FunctionImpl<Target(FUTarget::*)(uint32_t)>(&FUTarget::getTarget));
						case 5: return FunctionPtr(new FunctionImpl<FUTarget(FUTarget::*)() const>(&FUTarget::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUTarget::*)()>(&FUTarget::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUTarget::*)()>(&FUTarget::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUTarget&(FUTarget::*)()>(&FUTarget::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUTarget&(FUTarget::*)()>(&FUTarget::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUTarget::*)() const>(&FUTarget::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUTarget::*)() const>(&FUTarget::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUTarget::*)() const>(&FUTarget::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUTarget::*)() const>(&FUTarget::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUTarget::*)() const>(&FUTarget::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1694, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 4005, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2613, 2815, 2815, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1844, 1283, 546, 4073, 4073, 547, 547, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUTarget::constructor_bases[];
	constexpr uint16_t ReflectionFUTarget::constructor_arg_types[];
	constexpr uint16_t ReflectionFUTarget::constructor_arg_names[];
	constexpr uint16_t ReflectionFUTarget::constructor_arg_values[];
	constexpr uint8_t ReflectionFUTarget::function_flags[];
	constexpr uint16_t ReflectionFUTarget::function_names[];
	constexpr uint16_t ReflectionFUTarget::function_types[];
	constexpr uint16_t ReflectionFUTarget::function_bases[];
	constexpr uint16_t ReflectionFUTarget::function_arg_types[];
	constexpr uint16_t ReflectionFUTarget::function_arg_names[];
	constexpr uint16_t ReflectionFUTarget::function_arg_values[];
	constexpr uint16_t ReflectionFUTarget::callback_names[];
	constexpr uint16_t ReflectionFUTarget::callback_types[];
	constexpr uint16_t ReflectionFUTarget::callback_bases[];
	constexpr uint16_t ReflectionFUTarget::callback_arg_types[];
	constexpr uint16_t ReflectionFUTarget::callback_arg_names[];
	constexpr uint16_t ReflectionFUTarget::enum_names[];
	constexpr uint16_t ReflectionFUTarget::enum_bases[];
	constexpr uint16_t ReflectionFUTarget::enum_var_names[];
	static ReflectionFUTarget reflection_fu_target;
	
	// Tellusim::Device
	class ReflectionDevice : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Device::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Device, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Device, TypeList<Context&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<Device, TypeList<Surface&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<Device, TypeList<Window&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Device>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Device::*)() const>(&Device::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Device::*)() const>(&Device::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Device::*)() const>(&Device::getIndex));
						case 3: return FunctionPtr(new FunctionImpl<String(Device::*)() const>(&Device::getName));
						case 4: return FunctionPtr(new FunctionImpl<String(Device::*)() const>(&Device::getVendor));
						case 5: return FunctionPtr(new FunctionImpl<String(Device::*)() const>(&Device::getVersion));
						case 6: return FunctionPtr(new FunctionImpl<const Device::Features&(Device::*)() const>(&Device::getFeatures));
						case 7: return FunctionPtr(new FunctionImpl<bool(Device::*)(Query::Type) const>(&Device::hasQuery));
						case 8: return FunctionPtr(new FunctionImpl<bool(Device::*)(Shader::Type) const>(&Device::hasShader));
						case 9: return FunctionPtr(new FunctionImpl<bool(Device::*)(Format) const>(&Device::hasTarget));
						case 10: return FunctionPtr(new FunctionImpl<bool(Device::*)(Format) const>(&Device::hasTexture));
						case 11: return FunctionPtr(new FunctionImpl<bool(Device::*)(Format) const>(&Device::hasSurface));
						case 12: return FunctionPtr(new FunctionImpl<Device(Device::*)(uint32_t, uint32_t) const>(&Device::createDevice, {}, 3));
						case 13: return FunctionPtr(new FunctionImpl<Device(Device::*)(uint32_t) const>(&Device::createCommandDevice, 3));
						case 14: return FunctionPtr(new FunctionImpl<Device(Device::*)(uint32_t) const>(&Device::createComputeDevice, 3));
						case 15: return FunctionPtr(new FunctionImpl<Device(Device::*)(uint32_t) const>(&Device::createCopyDevice, 3));
						case 16: return FunctionPtr(new FunctionImpl<Query(Device::*)() const>(&Device::createQuery));
						case 17: return FunctionPtr(new FunctionImpl<Query(Device::*)(Query::Type) const>(&Device::createQuery));
						case 18: return FunctionPtr(new FunctionImpl<Fence(Device::*)() const>(&Device::createFence));
						case 19: return FunctionPtr(new FunctionImpl<Fence(Device::*)(Fence&) const>(&Device::createFence));
						case 20: return FunctionPtr(new FunctionImpl<Fence(Device::*)(Fence::Flags) const>(&Device::createFence));
						case 21: return FunctionPtr(new FunctionImpl<Buffer(Device::*)() const>(&Device::createBuffer));
						case 22: return FunctionPtr(new FunctionImpl<Buffer(Device::*)(Buffer&) const>(&Device::createBuffer));
						case 23: return FunctionPtr(new FunctionImpl<Buffer(Device::*)(Buffer::Flags, size_t, Format) const>(&Device::createBuffer, {}, {}, Tellusim::FormatUnknown));
						case 24: return FunctionPtr(new FunctionImpl<Buffer(Device::*)(Buffer::Flags, const void*, size_t, Format) const>(&Device::createBuffer, {}, {}, {}, Tellusim::FormatUnknown));
						case 25: return FunctionPtr(new FunctionImpl<Sampler(Device::*)() const>(&Device::createSampler));
						case 26: return FunctionPtr(new FunctionImpl<Sampler(Device::*)(const Sampler&) const>(&Device::createSampler));
						case 27: return FunctionPtr(new FunctionImpl<Sampler(Device::*)(Sampler::Filter, Sampler::WrapMode, uint32_t) const>(&Device::createSampler, {}, Sampler::WrapModeRepeat, Sampler::MaxAnisotropy));
						case 28: return FunctionPtr(new FunctionImpl<Texture(Device::*)() const>(&Device::createTexture));
						case 29: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Texture&) const>(&Device::createTexture));
						case 30: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Texture::Type, Format, const Size&, uint32_t, Texture::Flags) const>(&Device::createTexture, {}, (Format)0, {}, {}, Texture::DefaultFlags));
						case 31: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Texture::Type, Format, const Size&, Texture::Flags) const>(&Device::createTexture, {}, (Format)0, {}, Texture::DefaultFlags));
						case 32: return FunctionPtr(new FunctionImpl<Texture(Device::*)(const Image&, Texture::Flags, Async*) const>(&Device::createTexture, Image::null, Texture::DefaultFlags, nullptr));
						case 33: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, Texture::Flags) const>(&Device::createTexture2D, (Format)0, {}, Texture::DefaultFlags));
						case 34: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, Texture::Flags) const>(&Device::createTexture3D, (Format)0, {}, Texture::DefaultFlags));
						case 35: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, Texture::Flags) const>(&Device::createTextureCube, (Format)0, {}, Texture::DefaultFlags));
						case 36: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, uint32_t, Texture::Flags) const>(&Device::createTexture2D, (Format)0, {}, {}, Texture::DefaultFlags));
						case 37: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, uint32_t, uint32_t, Texture::Flags) const>(&Device::createTexture3D, (Format)0, {}, {}, {}, Texture::DefaultFlags));
						case 38: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, uint32_t, uint32_t, Texture::Flags) const>(&Device::createTexture2D, (Format)0, {}, {}, {}, Texture::DefaultFlags));
						case 39: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Format, uint32_t, uint32_t, Texture::Flags) const>(&Device::createTextureCube, (Format)0, {}, {}, Texture::DefaultFlags));
						case 40: return FunctionPtr(new FunctionImpl<Texture(Device::*)(const char*, Texture::Flags, Image::Flags, uint32_t, Async*) const>(&Device::loadTexture, {}, Texture::DefaultFlags, Image::FlagNone, 0, nullptr));
						case 41: return FunctionPtr(new FunctionImpl<Texture(Device::*)(const String&, Texture::Flags, Image::Flags, uint32_t, Async*) const>(&Device::loadTexture, {}, Texture::DefaultFlags, Image::FlagNone, 0, nullptr));
						case 42: return FunctionPtr(new FunctionImpl<Texture(Device::*)(Stream&, Texture::Flags, Image::Flags, uint32_t, Async*) const>(&Device::loadTexture, Stream::null, Texture::DefaultFlags, Image::FlagNone, 0, nullptr));
						case 43: return FunctionPtr(new FunctionImpl<Tracing(Device::*)() const>(&Device::createTracing));
						case 44: return FunctionPtr(new FunctionImpl<Tracing(Device::*)(const Tracing&) const>(&Device::createTracing));
						case 45: return FunctionPtr(new FunctionImpl<Tracing(Device::*)(uint32_t, Buffer, size_t, Tracing::Flags) const>(&Device::createTracing, {}, Buffer::null, 0, Tracing::DefaultFlags));
						case 46: return FunctionPtr(new FunctionImpl<Tracing(Device::*)(uint32_t, Format, size_t, uint32_t, Format, Tracing::Flags) const>(&Device::createTracing, {}, (Format)0, {}, {}, (Format)0, Tracing::DefaultFlags));
						case 47: return FunctionPtr(new FunctionImpl<Tracing(Device::*)(uint32_t, size_t, Buffer, size_t, Tracing::Flags) const>(&Device::createTracing, {}, {}, Buffer::null, 0, Tracing::DefaultFlags));
						case 48: return FunctionPtr(new FunctionImpl<BufferTable(Device::*)() const>(&Device::createBufferTable));
						case 49: return FunctionPtr(new FunctionImpl<BufferTable(Device::*)(uint32_t) const>(&Device::createBufferTable));
						case 50: return FunctionPtr(new FunctionImpl<BufferTable(Device::*)(const Array<Buffer>&, bool) const>(&Device::createBufferTable, {}, false));
						case 51: return FunctionPtr(new FunctionImpl<TextureTable(Device::*)() const>(&Device::createTextureTable));
						case 52: return FunctionPtr(new FunctionImpl<TextureTable(Device::*)(Texture::Type, uint32_t) const>(&Device::createTextureTable));
						case 53: return FunctionPtr(new FunctionImpl<TextureTable(Device::*)(const Array<Texture>&, bool) const>(&Device::createTextureTable, {}, false));
						case 54: return FunctionPtr(new FunctionImpl<Shader(Device::*)() const>(&Device::createShader));
						case 55: return FunctionPtr(new FunctionImpl<Shader(Device::*)(Shader::Type, const char*, const String&) const>(&Device::loadShader, {}, {}, String::null));
						case 56: return FunctionPtr(new FunctionImpl<Shader(Device::*)(Shader::Type, const char*, const String&) const>(&Device::loadShaderGLSL, {}, {}, String::null));
						case 57: return FunctionPtr(new FunctionImpl<Shader(Device::*)(Shader::Type, const char*) const>(&Device::loadShaderSPIRV));
						case 58: return FunctionPtr(new FunctionImpl<Shader(Device::*)(Shader::Type, const char*, const String&) const>(&Device::createShader, {}, {}, String::null));
						case 59: return FunctionPtr(new FunctionImpl<Shader(Device::*)(Shader::Type, const char*, const String&) const>(&Device::createShaderGLSL, {}, {}, String::null));
						case 60: return FunctionPtr(new FunctionImpl<Shader(Device::*)(Shader::Type, const Array<uint32_t>&) const>(&Device::createShaderSPIRV));
						case 61: return FunctionPtr(new FunctionImpl<Kernel(Device::*)() const>(&Device::createKernel));
						case 62: return FunctionPtr(new FunctionImpl<Kernel(Device::*)(const Kernel&) const>(&Device::createKernel));
						case 63: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Kernel&) const>(&Device::releaseKernel));
						case 64: return FunctionPtr(new FunctionImpl<Pipeline(Device::*)() const>(&Device::createPipeline));
						case 65: return FunctionPtr(new FunctionImpl<Pipeline(Device::*)(const Pipeline&) const>(&Device::createPipeline));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Pipeline&) const>(&Device::releasePipeline));
						case 67: return FunctionPtr(new FunctionImpl<Traversal(Device::*)() const>(&Device::createTraversal));
						case 68: return FunctionPtr(new FunctionImpl<Traversal(Device::*)(const Traversal&) const>(&Device::createTraversal));
						case 69: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Traversal&) const>(&Device::releaseTraversal));
						case 70: return FunctionPtr(new FunctionImpl<Target(Device::*)() const>(&Device::createTarget));
						case 71: return FunctionPtr(new FunctionImpl<Target(Device::*)(Surface&) const>(&Device::createTarget));
						case 72: return FunctionPtr(new FunctionImpl<Target(Device::*)(Window&) const>(&Device::createTarget));
						case 73: return FunctionPtr(new FunctionImpl<Target(Device::*)(const InitializerList<Texture>&, Target::Operation) const>(&Device::createTarget, {}, Target::OpDefault));
						case 74: return FunctionPtr(new FunctionImpl<Compute(Device::*)() const>(&Device::createCompute));
						case 75: return FunctionPtr(new FunctionImpl<Command(Device::*)() const>(&Device::createCommand));
						case 76: return FunctionPtr(new FunctionImpl<Command(Device::*)(Target&) const>(&Device::createCommand));
						case 77: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, size_t, const void*, size_t) const>(&Device::setBuffer));
						case 78: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, const void*, size_t) const>(&Device::setBuffer));
						case 79: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, const void*) const>(&Device::setBuffer));
						case 80: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, size_t, void*, size_t) const>(&Device::getBuffer));
						case 81: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, void*, size_t) const>(&Device::getBuffer));
						case 82: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, void*) const>(&Device::getBuffer));
						case 83: return FunctionPtr(new FunctionVoidImpl<void*(Device::*)(Buffer&, size_t, size_t) const>(&Device::mapBuffer));
						case 84: return FunctionPtr(new FunctionVoidImpl<void*(Device::*)(Buffer&, size_t) const>(&Device::mapBuffer));
						case 85: return FunctionPtr(new FunctionVoidImpl<void*(Device::*)(Buffer&) const>(&Device::mapBuffer));
						case 86: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&) const>(&Device::unmapBuffer));
						case 87: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, size_t, Buffer&, size_t, size_t) const>(&Device::copyBuffer));
						case 88: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, size_t, Buffer&, size_t) const>(&Device::copyBuffer));
						case 89: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, Buffer&, size_t) const>(&Device::copyBuffer));
						case 90: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, Buffer&) const>(&Device::copyBuffer));
						case 91: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, Format, size_t, const void*, size_t) const>(&Device::clearBuffer));
						case 92: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, Format, const void*, size_t) const>(&Device::clearBuffer));
						case 93: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, Format, const void*) const>(&Device::clearBuffer));
						case 94: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&) const>(&Device::clearBuffer));
						case 95: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, const Array<size_t>&, const Array<size_t>&, bool, Fence&) const>(&Device::bindBuffer));
						case 96: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, const Array<size_t>&, const Array<size_t>&, bool) const>(&Device::bindBuffer));
						case 97: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, size_t, size_t, bool, Fence&) const>(&Device::bindBuffer));
						case 98: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, size_t, size_t, bool) const>(&Device::bindBuffer));
						case 99: return FunctionPtr(new FunctionImpl<bool(Device::*)(Buffer&, Buffer::Flags) const>(&Device::flushBuffer, Buffer::null, Buffer::FlagNone));
						case 100: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Buffer>&, Buffer::Flags) const>(&Device::flushBuffers, {}, Buffer::FlagNone));
						case 101: return FunctionPtr(new FunctionImpl<bool(Device::*)(const InitializerList<Buffer>&, Buffer::Flags) const>(&Device::flushBuffers, {}, Buffer::FlagNone));
						case 102: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Buffer&) const>(&Device::releaseBuffer));
						case 103: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Sampler&) const>(&Device::releaseSampler));
						case 104: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Origin&, const Slice&, const Image&, const Slice&) const>(&Device::setTexture));
						case 105: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Origin&, const Image&) const>(&Device::setTexture));
						case 106: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Slice&, const Image&) const>(&Device::setTexture));
						case 107: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Image&) const>(&Device::setTexture));
						case 108: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Slice&, Image&, const Slice&) const>(&Device::getTexture));
						case 109: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, Image&, const Slice&) const>(&Device::getTexture));
						case 110: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, Image&) const>(&Device::getTexture));
						case 111: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Origin&, const Slice&, Texture&, const Region&, const Slice&) const>(&Device::copyTexture));
						case 112: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Origin&, Texture&, const Region&) const>(&Device::copyTexture));
						case 113: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Slice&, Texture&, const Slice&) const>(&Device::copyTexture));
						case 114: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, Texture&) const>(&Device::copyTexture));
						case 115: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Region&, const Slice&, const void*) const>(&Device::clearTexture));
						case 116: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Region&, const void*) const>(&Device::clearTexture));
						case 117: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Slice&, const void*) const>(&Device::clearTexture));
						case 118: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const void*) const>(&Device::clearTexture));
						case 119: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Region*, uint32_t, const Slice*, uint32_t, bool, Fence&) const>(&Device::bindTexture));
						case 120: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Region*, uint32_t, const Slice*, uint32_t, bool) const>(&Device::bindTexture));
						case 121: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Region&, const Slice&, bool, Fence&) const>(&Device::bindTexture));
						case 122: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Region&, const Slice&, bool) const>(&Device::bindTexture));
						case 123: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Slice&) const>(&Device::createMipmaps));
						case 124: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&) const>(&Device::createMipmaps));
						case 125: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, Texture::Flags) const>(&Device::flushTexture, Texture::null, Texture::FlagNone));
						case 126: return FunctionPtr(new FunctionImpl<bool(Device::*)(Texture&, const Slice&, Texture::Flags) const>(&Device::flushTexture, Texture::null, {}, Texture::FlagNone));
						case 127: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Texture>&, Texture::Flags) const>(&Device::flushTextures, {}, Texture::FlagNone));
						case 128: return FunctionPtr(new FunctionImpl<bool(Device::*)(const InitializerList<Texture>&, Texture::Flags) const>(&Device::flushTextures, {}, Texture::FlagNone));
						case 129: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Texture&) const>(&Device::releaseTexture));
						case 130: return FunctionPtr(new FunctionImpl<bool(Device::*)(Tracing&, const Tracing::Instance*, uint32_t) const>(&Device::setTracing));
						case 131: return FunctionPtr(new FunctionImpl<bool(Device::*)(Tracing&, Buffer&, Tracing::Flags) const>(&Device::buildTracing, Tracing::null, Buffer::null, Tracing::FlagNone));
						case 132: return FunctionPtr(new FunctionImpl<bool(Device::*)(Tracing&, Buffer&, size_t, Tracing::Flags) const>(&Device::buildTracing, Tracing::null, Buffer::null, {}, Tracing::FlagNone));
						case 133: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Tracing>&, Buffer&, Tracing::Flags) const>(&Device::buildTracings, {}, Buffer::null, Tracing::FlagNone));
						case 134: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Tracing>&, Buffer&, size_t, Tracing::Flags) const>(&Device::buildTracings, {}, Buffer::null, {}, Tracing::FlagNone));
						case 135: return FunctionPtr(new FunctionImpl<bool(Device::*)(Tracing&, Buffer&, size_t) const>(&Device::copyTracing, Tracing::null, Buffer::null, 0));
						case 136: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Tracing>&, Buffer&, size_t, size_t) const>(&Device::copyTracings, {}, Buffer::null, {}, 0));
						case 137: return FunctionPtr(new FunctionImpl<bool(Device::*)(Tracing&) const>(&Device::flushTracing));
						case 138: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Tracing>&) const>(&Device::flushTracings));
						case 139: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Tracing&) const>(&Device::releaseTracing));
						case 140: return FunctionPtr(new FunctionImpl<bool(Device::*)(BufferTable&, uint32_t, Buffer&, bool) const>(&Device::setBufferTable, BufferTable::null, {}, Buffer::null, false));
						case 141: return FunctionPtr(new FunctionImpl<bool(Device::*)(BufferTable&, uint32_t, const Array<Buffer>&, bool) const>(&Device::setBufferTable, BufferTable::null, {}, {}, false));
						case 142: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(BufferTable&) const>(&Device::releaseBufferTable));
						case 143: return FunctionPtr(new FunctionImpl<bool(Device::*)(TextureTable&, uint32_t, Texture&, bool) const>(&Device::setTextureTable, TextureTable::null, {}, Texture::null, false));
						case 144: return FunctionPtr(new FunctionImpl<bool(Device::*)(TextureTable&, uint32_t, const Array<Texture>&, bool) const>(&Device::setTextureTable, TextureTable::null, {}, {}, false));
						case 145: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(TextureTable&) const>(&Device::releaseTextureTable));
						case 146: return FunctionPtr(new FunctionImpl<bool(Device::*)(Query&) const>(&Device::beginQuery));
						case 147: return FunctionPtr(new FunctionVoidImpl<void(Device::*)(Query&) const>(&Device::endQuery));
						case 148: return FunctionPtr(new FunctionImpl<bool(Device::*)(Query&, Buffer&, size_t) const>(&Device::copyQuery, Query::null, Buffer::null, 0));
						case 149: return FunctionPtr(new FunctionImpl<bool(Device::*)(const Array<Query>&, Buffer&, size_t, size_t) const>(&Device::copyQueries, {}, Buffer::null, 0, 0));
						case 150: return FunctionPtr(new FunctionImpl<bool(Device::*)(const InitializerList<Query>&, Buffer&, size_t, size_t) const>(&Device::copyQueries, {}, Buffer::null, 0, 0));
						case 151: return FunctionPtr(new FunctionImpl<bool(Device::*)(Fence&) const>(&Device::waitFence));
						case 152: return FunctionPtr(new FunctionImpl<bool(Device::*)(Fence&) const>(&Device::signalFence));
						case 153: return FunctionPtr(new FunctionImpl<bool(Device::*)(Device&) const>(&Device::execute));
						case 154: return FunctionPtr(new FunctionImpl<bool(Device::*)(Fence&) const>(&Device::flip));
						case 155: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::flip));
						case 156: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::flush));
						case 157: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::finish));
						case 158: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::check));
						case 159: return FunctionPtr(new FunctionImpl<Device(Device::*)() const>(&Device::clonePtr));
						case 160: return FunctionPtr(new FunctionVoidImpl<void(Device::*)()>(&Device::clearPtr));
						case 161: return FunctionPtr(new FunctionVoidImpl<void(Device::*)()>(&Device::destroyPtr));
						case 162: return FunctionPtr(new FunctionImpl<Device&(Device::*)()>(&Device::acquirePtr));
						case 163: return FunctionPtr(new FunctionImpl<Device&(Device::*)()>(&Device::unacquirePtr));
						case 164: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::isValidPtr));
						case 165: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::isOwnerPtr));
						case 166: return FunctionPtr(new FunctionImpl<bool(Device::*)() const>(&Device::isConstPtr));
						case 167: return FunctionPtr(new FunctionImpl<uint32_t(Device::*)() const>(&Device::getCountPtr));
						case 168: return FunctionPtr(new FunctionImpl<const void*(Device::*)() const>(&Device::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 2, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 277, 1280, 1472 };
			static constexpr uint16_t constructor_arg_names[] = { 1887, 3993, 4090 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 2556, 2902, 2903, 2328, 2966, 2971, 2974, 2975, 2973, 1916, 1910, 1912, 1913, 1928, 1928, 1918, 1918, 1918, 1907, 1907, 1907, 1907, 1931, 1931, 1931, 1937, 1937, 1937, 1937, 1937, 1938, 1939, 1940, 1938, 1939, 1938, 1940, 3249, 3249, 3249, 1942, 1942, 1942, 1942, 1942, 1908, 1908, 1908, 1941, 1941, 1941, 1932, 3246, 3247, 3248, 1932, 1933, 1934, 1922, 1922, 3410, 1926, 1926, 3412, 1943, 1943, 3417, 1936, 1936, 1936, 1936, 1911, 1909, 1909, 3533, 3533, 3533, 2142, 2142, 2142, 3258, 3258, 3258, 4048, 1891, 1891, 1891, 1891, 1617, 1617, 1617, 1617, 1580, 1580, 1580, 1580, 2057, 2058, 2058, 3407, 3413, 3885, 3885, 3885, 3885, 2828, 2828, 2828, 1897, 1897, 1897, 1897, 1640, 1640, 1640, 1640, 1581, 1581, 1581, 1581, 1924, 1924, 2059, 2059, 2060, 2060, 3414, 3906, 1596, 1596, 1597, 1597, 1898, 1899, 2061, 2062, 3416, 3536, 3536, 3408, 3898, 3898, 3415, 1578, 2008, 1896, 1895, 1895, 4077, 3957, 2011, 2046, 2046, 2056, 2044, 1607, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 1274, 1274, 1274, 1765, 1585, 1585, 1585, 1585, 1585, 454, 454, 454, 454, 1167, 1167, 554, 554, 554, 152, 152, 152, 152, 1192, 1192, 1192, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1302, 1302, 1302, 1302, 1302, 157, 157, 157, 1299, 1299, 1299, 1205, 1205, 1205, 1205, 1205, 1205, 1205, 856, 856, 4073, 1131, 1131, 4073, 1309, 1309, 4073, 1283, 1283, 1283, 1283, 273, 263, 263, 1585, 1585, 1585, 1585, 1585, 1585, 4074, 4074, 4074, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1585, 1585, 4073, 1585, 1585, 4073, 1585, 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 454, 4073, 4073, 455, 455, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 10, 11, 11, 12, 13, 13, 14, 17, 21, 21, 22, 25, 25, 26, 31, 35, 38, 41, 44, 47, 51, 56, 61, 65, 70, 75, 80, 80, 81, 85, 91, 96, 96, 97, 99, 99, 101, 103, 103, 106, 109, 111, 114, 117, 119, 119, 120, 121, 121, 122, 123, 123, 124, 125, 125, 126, 127, 129, 129, 129, 130, 134, 137, 139, 143, 146, 148, 151, 153, 154, 155, 160, 164, 167, 169, 174, 178, 181, 182, 187, 191, 196, 200, 202, 204, 206, 207, 208, 213, 216, 219, 221, 225, 228, 230, 236, 240, 244, 246, 250, 253, 256, 258, 265, 271, 276, 280, 282, 283, 285, 288, 290, 292, 293, 296, 299, 303, 306, 310, 313, 317, 318, 319, 320, 324, 328, 329, 333, 337, 338, 339, 340, 343, 347, 351, 352, 353, 354, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355 };
			static constexpr uint16_t function_arg_types[] = { 1170, 1208, 765, 765, 765, 4039, 4039, 4039, 4039, 4039, 1170, 555, 556, 153, 155, 3961, 765, 155, 1885, 3961, 765, 1834, 1195, 1198, 4039, 1294, 1298, 765, 1838, 4039, 1297, 1298, 765, 1838, 1297, 1781, 1297, 62, 765, 4039, 1297, 765, 4039, 1297, 765, 4039, 1297, 765, 4039, 4039, 1297, 765, 4039, 4039, 4039, 1297, 765, 4039, 4039, 4039, 1297, 765, 4039, 4039, 1297, 1877, 1297, 843, 4039, 62, 1841, 1297, 843, 4039, 62, 1273, 1297, 843, 4039, 62, 1850, 4039, 152, 3961, 1306, 4039, 765, 3961, 4039, 765, 1306, 4039, 3961, 152, 3961, 1306, 4039, 1666, 1585, 1298, 4039, 1695, 1585, 1208, 1877, 1841, 1208, 1877, 1841, 1208, 1877, 1208, 1877, 1841, 1208, 1877, 1841, 1208, 1703, 1795, 857, 1826, 1132, 1853, 1310, 1280, 1472, 1787, 1286, 1284, 153, 3961, 1885, 3961, 153, 1885, 3961, 153, 1885, 153, 3961, 4074, 3961, 153, 4074, 3961, 153, 4074, 153, 3961, 3961, 153, 3961, 153, 153, 153, 3961, 153, 3961, 3961, 153, 3961, 153, 3961, 153, 153, 3961, 153, 153, 153, 765, 3961, 1885, 3961, 153, 765, 1885, 3961, 153, 765, 1885, 153, 153, 1702, 1702, 1585, 555, 153, 1702, 1702, 1585, 153, 3961, 3961, 1585, 555, 153, 3961, 3961, 1585, 153, 155, 1666, 155, 1783, 155, 153, 1193, 1294, 1824, 1839, 1781, 1839, 1294, 1824, 1781, 1294, 1839, 1781, 1294, 1781, 1294, 1839, 839, 1839, 1294, 839, 1839, 1294, 839, 1294, 1824, 1839, 1294, 1831, 1839, 1294, 1824, 1294, 1831, 1294, 1839, 1294, 1839, 1294, 1294, 1294, 1831, 1839, 1885, 1294, 1831, 1885, 1294, 1839, 1885, 1294, 1885, 1294, 1832, 4039, 1840, 4039, 1585, 555, 1294, 1832, 4039, 1840, 4039, 1585, 1294, 1831, 1839, 1585, 555, 1294, 1831, 1839, 1585, 1294, 1839, 1294, 1294, 1297, 1294, 1839, 1297, 1695, 1297, 1787, 1297, 1294, 1303, 1851, 4039, 1303, 153, 1306, 1303, 153, 3961, 1306, 1697, 153, 1306, 1697, 153, 3961, 1306, 1303, 153, 3961, 1697, 153, 3961, 3961, 1303, 1697, 1303, 158, 4039, 153, 1585, 158, 4039, 1666, 1585, 158, 1300, 4039, 1294, 1585, 1300, 4039, 1695, 1585, 1300, 1168, 1168, 1168, 153, 3961, 1689, 153, 3961, 3961, 1785, 153, 3961, 3961, 555, 555, 455, 555 };
			static constexpr uint16_t function_arg_names[] = { 4036, 4036, 2066, 2066, 2066, 2993, 2070, 2070, 2070, 2070, 4036, 3954, 2045, 3954, 2045, 3960, 2066, 2045, 3975, 3960, 2066, 3478, 2022, 3275, 1551, 3954, 4036, 2066, 3960, 3237, 2045, 4036, 2066, 3960, 2045, 2989, 2045, 1559, 2066, 3960, 2045, 2066, 3960, 2045, 2066, 3960, 2045, 2066, 4089, 2980, 2045, 2066, 4089, 2980, 1959, 2045, 2066, 4089, 2980, 3237, 2045, 2066, 3960, 3237, 2045, 3288, 2045, 2990, 3317, 1559, 3288, 2045, 2990, 3317, 1559, 3990, 2045, 2990, 3317, 1559, 4026, 3306, 2999, 3000, 2045, 3315, 4065, 4066, 3305, 2994, 2045, 3300, 1591, 1589, 1590, 2045, 3960, 1595, 3341, 4036, 3960, 4015, 3341, 4036, 3288, 3255, 4036, 3288, 3255, 4036, 3288, 4036, 3975, 3255, 4036, 3975, 3255, 4036, 1948, 3229, 3229, 3350, 3350, 4031, 4031, 3993, 4090, 4015, 3326, 4004, 1593, 3317, 3975, 3960, 1593, 3975, 3960, 1593, 3975, 1593, 3317, 1963, 3960, 1593, 1963, 3960, 1593, 1963, 1593, 3317, 3960, 1593, 3960, 1593, 1593, 1593, 1965, 3975, 3980, 3960, 1593, 1965, 3975, 3960, 1593, 3975, 3960, 1593, 3975, 1593, 2066, 3317, 3975, 3960, 1593, 2066, 3975, 3960, 1593, 2066, 3975, 1593, 1593, 3318, 3966, 1655, 2020, 1593, 3318, 3966, 1655, 1593, 3317, 3960, 1655, 2020, 1593, 3317, 3960, 1655, 1593, 2045, 1595, 2045, 1595, 2045, 1593, 3478, 4012, 1966, 1967, 2989, 3982, 4012, 1966, 2989, 4012, 1967, 2989, 4012, 2989, 4012, 3982, 2989, 1967, 4012, 2989, 1967, 4012, 2989, 4012, 1966, 1967, 3975, 3981, 3982, 4012, 1966, 3975, 3981, 4012, 1967, 3975, 3982, 4012, 3975, 4012, 3403, 3967, 3975, 4012, 3403, 3975, 4012, 3967, 3975, 4012, 3975, 4012, 3404, 3311, 3968, 3313, 1655, 2020, 4012, 3404, 3311, 3968, 3313, 1655, 4012, 3403, 3967, 1655, 2020, 4012, 3403, 3967, 1655, 4012, 3967, 4012, 4012, 2045, 4012, 3967, 2045, 4015, 2045, 4015, 2045, 4012, 4026, 3001, 3306, 4026, 1593, 2045, 4026, 1593, 3317, 2045, 4027, 1593, 2045, 4027, 1593, 3317, 2045, 4026, 1593, 3317, 4027, 1593, 3317, 3991, 4026, 4027, 4026, 4001, 2993, 1593, 3341, 4001, 2993, 1595, 3341, 4001, 4001, 2993, 4012, 3341, 4001, 2993, 4015, 3341, 4001, 3370, 3370, 3370, 1593, 3317, 3369, 1593, 3317, 3991, 3369, 1593, 3317, 3991, 2020, 2020, 1969, 2020 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 18, 18, 18, 18, 0, 0, 0, 0, 0, 0, 767, 0, 0, 0, 767, 0, 0, 1199, 1196, 0, 0, 0, 0, 0, 1295, 0, 0, 0, 1295, 0, 1295, 3294, 0, 0, 1295, 0, 0, 1295, 0, 0, 1295, 0, 0, 0, 1295, 0, 0, 0, 0, 1295, 0, 0, 0, 0, 1295, 0, 0, 0, 1295, 0, 1295, 842, 3, 3294, 0, 1295, 842, 3, 3294, 0, 1295, 842, 3, 3294, 0, 0, 156, 3, 1304, 0, 0, 0, 0, 0, 1304, 0, 0, 156, 3, 1304, 0, 0, 2016, 0, 0, 0, 2016, 0, 0, 1277, 0, 0, 1277, 0, 0, 0, 0, 1277, 0, 0, 1277, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1285, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 0, 154, 0, 154, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1296, 0, 0, 1296, 0, 1296, 0, 1296, 0, 0, 0, 0, 0, 0, 1305, 0, 0, 0, 1305, 0, 0, 1305, 0, 0, 0, 1305, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 2016, 0, 0, 0, 0, 2016, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 3, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionDevice::constructor_bases[];
	constexpr uint16_t ReflectionDevice::constructor_arg_types[];
	constexpr uint16_t ReflectionDevice::constructor_arg_names[];
	constexpr uint16_t ReflectionDevice::constructor_arg_values[];
	constexpr uint8_t ReflectionDevice::function_flags[];
	constexpr uint16_t ReflectionDevice::function_names[];
	constexpr uint16_t ReflectionDevice::function_types[];
	constexpr uint16_t ReflectionDevice::function_bases[];
	constexpr uint16_t ReflectionDevice::function_arg_types[];
	constexpr uint16_t ReflectionDevice::function_arg_names[];
	constexpr uint16_t ReflectionDevice::function_arg_values[];
	constexpr uint16_t ReflectionDevice::callback_names[];
	constexpr uint16_t ReflectionDevice::callback_types[];
	constexpr uint16_t ReflectionDevice::callback_bases[];
	constexpr uint16_t ReflectionDevice::callback_arg_types[];
	constexpr uint16_t ReflectionDevice::callback_arg_names[];
	constexpr uint16_t ReflectionDevice::enum_names[];
	constexpr uint16_t ReflectionDevice::enum_bases[];
	constexpr uint16_t ReflectionDevice::enum_var_names[];
	static ReflectionDevice reflection_device;
	
	// Tellusim::D3D12Device
	class ReflectionD3D12Device : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Device::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_device;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Device, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<D3D12Device, TypeList<Context&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<D3D12Device, TypeList<Surface&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<D3D12Device, TypeList<Window&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Device>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(D3D12Device::*)(Buffer&, uint32_t)>(&D3D12Device::setBufferState));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(D3D12Device::*)(Texture&, uint32_t)>(&D3D12Device::setTextureState));
						case 2: return FunctionPtr(new FunctionImpl<ID3D12Device*(D3D12Device::*)() const>(&D3D12Device::getD3D12Device));
						case 3: return FunctionPtr(new FunctionImpl<ID3D12CommandQueue*(D3D12Device::*)() const>(&D3D12Device::getQueue));
						case 4: return FunctionPtr(new FunctionImpl<ID3D12GraphicsCommandList*(D3D12Device::*)() const>(&D3D12Device::getCommand));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Device(D3D12Device::*)() const>(&D3D12Device::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(D3D12Device::*)()>(&D3D12Device::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(D3D12Device::*)()>(&D3D12Device::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<D3D12Device&(D3D12Device::*)()>(&D3D12Device::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<D3D12Device&(D3D12Device::*)()>(&D3D12Device::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(D3D12Device::*)() const>(&D3D12Device::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(D3D12Device::*)() const>(&D3D12Device::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(D3D12Device::*)() const>(&D3D12Device::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Device::*)() const>(&D3D12Device::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(D3D12Device::*)() const>(&D3D12Device::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 2, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 277, 1280, 1472 };
			static constexpr uint16_t constructor_arg_names[] = { 1887, 3993, 4090 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3535, 3897, 2257, 2690, 2220, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 830, 829, 831, 411, 4073, 4073, 412, 412, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 153, 4039, 1294, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1593, 3983, 4012, 3983 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Device::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Device::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Device::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Device::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Device::function_flags[];
	constexpr uint16_t ReflectionD3D12Device::function_names[];
	constexpr uint16_t ReflectionD3D12Device::function_types[];
	constexpr uint16_t ReflectionD3D12Device::function_bases[];
	constexpr uint16_t ReflectionD3D12Device::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Device::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Device::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Device::callback_names[];
	constexpr uint16_t ReflectionD3D12Device::callback_types[];
	constexpr uint16_t ReflectionD3D12Device::callback_bases[];
	constexpr uint16_t ReflectionD3D12Device::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Device::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Device::enum_names[];
	constexpr uint16_t ReflectionD3D12Device::enum_bases[];
	constexpr uint16_t ReflectionD3D12Device::enum_var_names[];
	static ReflectionD3D12Device reflection_d3d12_device;
	
	// Tellusim::D3D11Device
	class ReflectionD3D11Device : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Device::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_device;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Device, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<D3D11Device, TypeList<Context&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<D3D11Device, TypeList<Surface&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<D3D11Device, TypeList<Window&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Device>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D11Device*(D3D11Device::*)() const>(&D3D11Device::getD3D11Device));
						case 1: return FunctionPtr(new FunctionImpl<ID3D11DeviceContext*(D3D11Device::*)() const>(&D3D11Device::getCommand));
						case 2: return FunctionPtr(new FunctionImpl<D3D11Device(D3D11Device::*)() const>(&D3D11Device::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D11Device::*)()>(&D3D11Device::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D11Device::*)()>(&D3D11Device::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D11Device&(D3D11Device::*)()>(&D3D11Device::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<D3D11Device&(D3D11Device::*)()>(&D3D11Device::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D11Device::*)() const>(&D3D11Device::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D11Device::*)() const>(&D3D11Device::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(D3D11Device::*)() const>(&D3D11Device::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Device::*)() const>(&D3D11Device::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(D3D11Device::*)() const>(&D3D11Device::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 2, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 277, 1280, 1472 };
			static constexpr uint16_t constructor_arg_names[] = { 1887, 3993, 4090 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2252, 2220, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 822, 823, 393, 4073, 4073, 394, 394, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Device::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Device::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Device::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Device::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Device::function_flags[];
	constexpr uint16_t ReflectionD3D11Device::function_names[];
	constexpr uint16_t ReflectionD3D11Device::function_types[];
	constexpr uint16_t ReflectionD3D11Device::function_bases[];
	constexpr uint16_t ReflectionD3D11Device::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Device::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Device::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Device::callback_names[];
	constexpr uint16_t ReflectionD3D11Device::callback_types[];
	constexpr uint16_t ReflectionD3D11Device::callback_bases[];
	constexpr uint16_t ReflectionD3D11Device::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Device::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Device::enum_names[];
	constexpr uint16_t ReflectionD3D11Device::enum_bases[];
	constexpr uint16_t ReflectionD3D11Device::enum_var_names[];
	static ReflectionD3D11Device reflection_d3d11_device;
	
	// Tellusim::MTLDevice
	class ReflectionMTLDevice : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLDevice::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_device;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLDevice, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<MTLDevice, TypeList<Context&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<MTLDevice, TypeList<Surface&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<MTLDevice, TypeList<Window&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLDevice>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getMTLDevice));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getQueue));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getCommand));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getEncoder));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)(void*) const>(&MTLDevice::getRenderEncoder));
						case 5: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getComputeEncoder));
						case 6: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getTracingEncoder));
						case 7: return FunctionPtr(new FunctionVoidImpl<void*(MTLDevice::*)() const>(&MTLDevice::getBlitEncoder));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(MTLDevice::*)() const>(&MTLDevice::endEncoder));
						case 9: return FunctionPtr(new FunctionImpl<MTLDevice(MTLDevice::*)() const>(&MTLDevice::clonePtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(MTLDevice::*)()>(&MTLDevice::clearPtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(MTLDevice::*)()>(&MTLDevice::destroyPtr));
						case 12: return FunctionPtr(new FunctionImpl<MTLDevice&(MTLDevice::*)()>(&MTLDevice::acquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<MTLDevice&(MTLDevice::*)()>(&MTLDevice::unacquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(MTLDevice::*)() const>(&MTLDevice::isValidPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(MTLDevice::*)() const>(&MTLDevice::isOwnerPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(MTLDevice::*)() const>(&MTLDevice::isConstPtr));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(MTLDevice::*)() const>(&MTLDevice::getCountPtr));
						case 18: return FunctionPtr(new FunctionImpl<const void*(MTLDevice::*)() const>(&MTLDevice::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 2, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 277, 1280, 1472 };
			static constexpr uint16_t constructor_arg_names[] = { 1887, 3993, 4090 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2476, 2690, 2220, 2320, 2704, 2225, 2868, 2130, 2007, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 4074, 4074, 4074, 4074, 4074, 4074, 4073, 907, 4073, 4073, 908, 908, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4074 };
			static constexpr uint16_t function_arg_names[] = { 1962 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLDevice::constructor_bases[];
	constexpr uint16_t ReflectionMTLDevice::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLDevice::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLDevice::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLDevice::function_flags[];
	constexpr uint16_t ReflectionMTLDevice::function_names[];
	constexpr uint16_t ReflectionMTLDevice::function_types[];
	constexpr uint16_t ReflectionMTLDevice::function_bases[];
	constexpr uint16_t ReflectionMTLDevice::function_arg_types[];
	constexpr uint16_t ReflectionMTLDevice::function_arg_names[];
	constexpr uint16_t ReflectionMTLDevice::function_arg_values[];
	constexpr uint16_t ReflectionMTLDevice::callback_names[];
	constexpr uint16_t ReflectionMTLDevice::callback_types[];
	constexpr uint16_t ReflectionMTLDevice::callback_bases[];
	constexpr uint16_t ReflectionMTLDevice::callback_arg_types[];
	constexpr uint16_t ReflectionMTLDevice::callback_arg_names[];
	constexpr uint16_t ReflectionMTLDevice::enum_names[];
	constexpr uint16_t ReflectionMTLDevice::enum_bases[];
	constexpr uint16_t ReflectionMTLDevice::enum_var_names[];
	static ReflectionMTLDevice reflection_mtl_device;
	
	// Tellusim::VKDevice
	class ReflectionVKDevice : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKDevice::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_device;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKDevice, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<VKDevice, TypeList<Context&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<VKDevice, TypeList<Surface&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<VKDevice, TypeList<Window&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKDevice>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(VKDevice::*)(Buffer&, uint32_t)>(&VKDevice::setBufferAccess));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(VKDevice::*)(Texture&, uint32_t)>(&VKDevice::setTextureLayout));
						case 2: return FunctionPtr(new FunctionImpl<bool(VKDevice::*)(void*, uint64_t, bool) const>(&VKDevice::waitVKFence));
						case 3: return FunctionPtr(new FunctionImpl<bool(VKDevice::*)(void*) const>(&VKDevice::signalVKFence));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(VKDevice::*)(void*, uint32_t) const>(&VKDevice::waitSemaphore));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(VKDevice::*)(void*) const>(&VKDevice::signalSemaphore));
						case 6: return FunctionPtr(new FunctionImpl<bool(VKDevice::*)(uint32_t) const>(&VKDevice::hasMemoryType));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(VKDevice::*)(uint32_t, uint32_t) const>(&VKDevice::getMemoryIndex));
						case 8: return FunctionPtr(new FunctionImpl<VkInstance(VKDevice::*)() const>(&VKDevice::getInstance));
						case 9: return FunctionPtr(new FunctionImpl<VkPhysicalDevice(VKDevice::*)() const>(&VKDevice::getAdapter));
						case 10: return FunctionPtr(new FunctionImpl<VkDevice(VKDevice::*)() const>(&VKDevice::getVKDevice));
						case 11: return FunctionPtr(new FunctionImpl<VkQueue(VKDevice::*)() const>(&VKDevice::getQueue));
						case 12: return FunctionPtr(new FunctionImpl<VkCommandBuffer(VKDevice::*)() const>(&VKDevice::getCommand));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(VKDevice::*)() const>(&VKDevice::getFamily));
						case 14: return FunctionPtr(new FunctionImpl<VKDevice(VKDevice::*)() const>(&VKDevice::clonePtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(VKDevice::*)()>(&VKDevice::clearPtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(VKDevice::*)()>(&VKDevice::destroyPtr));
						case 17: return FunctionPtr(new FunctionImpl<VKDevice&(VKDevice::*)()>(&VKDevice::acquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<VKDevice&(VKDevice::*)()>(&VKDevice::unacquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(VKDevice::*)() const>(&VKDevice::isValidPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(VKDevice::*)() const>(&VKDevice::isOwnerPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(VKDevice::*)() const>(&VKDevice::isConstPtr));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(VKDevice::*)() const>(&VKDevice::getCountPtr));
						case 23: return FunctionPtr(new FunctionImpl<const void*(VKDevice::*)() const>(&VKDevice::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 2, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 277, 1280, 1472 };
			static constexpr uint16_t constructor_arg_names[] = { 1887, 3993, 4090 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3534, 3890, 4079, 3959, 4078, 3958, 2957, 2501, 2434, 2083, 2895, 2690, 2220, 2327, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1585, 1585, 4073, 4073, 1585, 4039, 1459, 1460, 1454, 1461, 1452, 4039, 1404, 4073, 4073, 1405, 1405, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 4, 7, 8, 10, 11, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14 };
			static constexpr uint16_t function_arg_types[] = { 153, 4039, 1294, 4039, 4074, 4044, 1585, 4074, 4074, 4039, 4074, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1593, 1504, 4012, 3238, 2020, 4018, 3466, 2020, 3500, 3260, 3500, 2045, 4037, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKDevice::constructor_bases[];
	constexpr uint16_t ReflectionVKDevice::constructor_arg_types[];
	constexpr uint16_t ReflectionVKDevice::constructor_arg_names[];
	constexpr uint16_t ReflectionVKDevice::constructor_arg_values[];
	constexpr uint8_t ReflectionVKDevice::function_flags[];
	constexpr uint16_t ReflectionVKDevice::function_names[];
	constexpr uint16_t ReflectionVKDevice::function_types[];
	constexpr uint16_t ReflectionVKDevice::function_bases[];
	constexpr uint16_t ReflectionVKDevice::function_arg_types[];
	constexpr uint16_t ReflectionVKDevice::function_arg_names[];
	constexpr uint16_t ReflectionVKDevice::function_arg_values[];
	constexpr uint16_t ReflectionVKDevice::callback_names[];
	constexpr uint16_t ReflectionVKDevice::callback_types[];
	constexpr uint16_t ReflectionVKDevice::callback_bases[];
	constexpr uint16_t ReflectionVKDevice::callback_arg_types[];
	constexpr uint16_t ReflectionVKDevice::callback_arg_names[];
	constexpr uint16_t ReflectionVKDevice::enum_names[];
	constexpr uint16_t ReflectionVKDevice::enum_bases[];
	constexpr uint16_t ReflectionVKDevice::enum_var_names[];
	static ReflectionVKDevice reflection_vk_device;
	
	// Tellusim::FUDevice
	class ReflectionFUDevice : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUDevice::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_device;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUDevice, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUDevice, TypeList<const Array<Device>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUDevice>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUDevice::*)(uint32_t)>(&FUDevice::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUDevice::*)() const>(&FUDevice::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUDevice::*)() const>(&FUDevice::getNumDevices));
						case 3: return FunctionPtr(new FunctionImpl<const Device(FUDevice::*)(uint32_t) const>(&FUDevice::getDevice));
						case 4: return FunctionPtr(new FunctionImpl<Device(FUDevice::*)(uint32_t)>(&FUDevice::getDevice));
						case 5: return FunctionPtr(new FunctionImpl<FUDevice(FUDevice::*)() const>(&FUDevice::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUDevice::*)()>(&FUDevice::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUDevice::*)()>(&FUDevice::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUDevice&(FUDevice::*)()>(&FUDevice::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUDevice&(FUDevice::*)()>(&FUDevice::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUDevice::*)() const>(&FUDevice::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUDevice::*)() const>(&FUDevice::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUDevice::*)() const>(&FUDevice::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUDevice::*)() const>(&FUDevice::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUDevice::*)() const>(&FUDevice::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1673, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 1970, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2574, 2298, 2298, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1763, 454, 532, 4073, 4073, 533, 533, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUDevice::constructor_bases[];
	constexpr uint16_t ReflectionFUDevice::constructor_arg_types[];
	constexpr uint16_t ReflectionFUDevice::constructor_arg_names[];
	constexpr uint16_t ReflectionFUDevice::constructor_arg_values[];
	constexpr uint8_t ReflectionFUDevice::function_flags[];
	constexpr uint16_t ReflectionFUDevice::function_names[];
	constexpr uint16_t ReflectionFUDevice::function_types[];
	constexpr uint16_t ReflectionFUDevice::function_bases[];
	constexpr uint16_t ReflectionFUDevice::function_arg_types[];
	constexpr uint16_t ReflectionFUDevice::function_arg_names[];
	constexpr uint16_t ReflectionFUDevice::function_arg_values[];
	constexpr uint16_t ReflectionFUDevice::callback_names[];
	constexpr uint16_t ReflectionFUDevice::callback_types[];
	constexpr uint16_t ReflectionFUDevice::callback_bases[];
	constexpr uint16_t ReflectionFUDevice::callback_arg_types[];
	constexpr uint16_t ReflectionFUDevice::callback_arg_names[];
	constexpr uint16_t ReflectionFUDevice::enum_names[];
	constexpr uint16_t ReflectionFUDevice::enum_bases[];
	constexpr uint16_t ReflectionFUDevice::enum_var_names[];
	static ReflectionFUDevice reflection_fu_device;
	
	// Tellusim::Kernel
	class ReflectionKernel : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Kernel::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Kernel, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Kernel>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Kernel::*)() const>(&Kernel::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Kernel::*)() const>(&Kernel::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)()>(&Kernel::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Kernel::*)() const>(&Kernel::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)(const char*)>(&Kernel::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(Kernel::*)() const>(&Kernel::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(Kernel::*)()>(&Kernel::create));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)(const Kernel&)>(&Kernel::setParameters));
						case 9: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(Stream&) const>(&Kernel::saveState));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)(Shader&, bool)>(&Kernel::setShader, Shader::null, false));
						case 11: return FunctionPtr(new FunctionImpl<Shader(Kernel::*)() const>(&Kernel::getComputeShader));
						case 12: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(const char*, const String&, const char**, uint32_t)>(&Kernel::loadShader, {}, String::null, nullptr, 0));
						case 13: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(const char*, const String&, const char**, uint32_t)>(&Kernel::loadShaderGLSL, {}, String::null, nullptr, 0));
						case 14: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(const char*)>(&Kernel::loadShaderSPIRV));
						case 15: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(const char*, const String&, const char**, uint32_t)>(&Kernel::createShader, {}, String::null, nullptr, 0));
						case 16: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(const char*, const String&, const char**, uint32_t)>(&Kernel::createShaderGLSL, {}, String::null, nullptr, 0));
						case 17: return FunctionPtr(new FunctionImpl<bool(Kernel::*)(const Array<uint32_t>&)>(&Kernel::createShaderSPIRV));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)()>(&Kernel::addSampler));
						case 19: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setSamplers));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumSamplers));
						case 21: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setSamplerOffset));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getSamplerOffset));
						case 23: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, uint32_t, bool)>(&Kernel::setSamplerArray));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(uint32_t) const>(&Kernel::getSamplerArray));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)()>(&Kernel::addTexture));
						case 26: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTextures));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumTextures));
						case 28: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTextureOffset));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getTextureOffset));
						case 30: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, uint32_t, bool)>(&Kernel::setTextureArray));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(uint32_t) const>(&Kernel::getTextureArray));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)()>(&Kernel::addSurface));
						case 33: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setSurfaces));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumSurfaces));
						case 35: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setSurfaceOffset));
						case 36: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getSurfaceOffset));
						case 37: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, uint32_t, bool)>(&Kernel::setSurfaceArray));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(uint32_t) const>(&Kernel::getSurfaceArray));
						case 39: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(BindFlags)>(&Kernel::addUniform, Tellusim::BindFlagNone));
						case 40: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, BindFlags)>(&Kernel::setUniforms, {}, Tellusim::BindFlagNone));
						case 41: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumUniforms));
						case 42: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setUniformOffset));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getUniformOffset));
						case 44: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, BindFlags)>(&Kernel::setUniformFlags));
						case 45: return FunctionPtr(new FunctionImpl<BindFlags(Kernel::*)(uint32_t) const>(&Kernel::getUniformFlags));
						case 46: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(BindFlags)>(&Kernel::addStorage, Tellusim::BindFlagNone));
						case 47: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, BindFlags)>(&Kernel::setStorages, {}, Tellusim::BindFlagNone));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumStorages));
						case 49: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setStorageOffset));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getStorageOffset));
						case 51: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, BindFlags)>(&Kernel::setStorageFlags));
						case 52: return FunctionPtr(new FunctionImpl<BindFlags(Kernel::*)(uint32_t) const>(&Kernel::getStorageFlags));
						case 53: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)()>(&Kernel::addTracing));
						case 54: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTracings));
						case 55: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumTracings));
						case 56: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTracingOffset));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getTracingOffset));
						case 58: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)()>(&Kernel::addTexel));
						case 59: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTexels));
						case 60: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumTexels));
						case 61: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTexelOffset));
						case 62: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getTexelOffset));
						case 63: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(TableType, uint32_t)>(&Kernel::addTable));
						case 64: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getNumTables));
						case 65: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t)>(&Kernel::setTableOffset));
						case 66: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getTableOffset));
						case 67: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, TableType, uint32_t, BindFlags)>(&Kernel::setTableType, {}, (TableType)0, {}, Tellusim::BindFlagNone));
						case 68: return FunctionPtr(new FunctionImpl<TableType(Kernel::*)(uint32_t) const>(&Kernel::getTableType));
						case 69: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)(uint32_t) const>(&Kernel::getTableSize));
						case 70: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)(uint32_t, BindFlags)>(&Kernel::setTableFlags));
						case 71: return FunctionPtr(new FunctionImpl<BindFlags(Kernel::*)(uint32_t) const>(&Kernel::getTableFlags));
						case 72: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)(uint32_t, uint32_t, uint32_t)>(&Kernel::setGroupSize, {}, 1, 1));
						case 73: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getGroupSizeX));
						case 74: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getGroupSizeY));
						case 75: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getGroupSizeZ));
						case 76: return FunctionPtr(new FunctionImpl<Kernel(Kernel::*)() const>(&Kernel::clonePtr));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)()>(&Kernel::clearPtr));
						case 78: return FunctionPtr(new FunctionVoidImpl<void(Kernel::*)()>(&Kernel::destroyPtr));
						case 79: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)()>(&Kernel::acquirePtr));
						case 80: return FunctionPtr(new FunctionImpl<Kernel&(Kernel::*)()>(&Kernel::unacquirePtr));
						case 81: return FunctionPtr(new FunctionImpl<bool(Kernel::*)() const>(&Kernel::isValidPtr));
						case 82: return FunctionPtr(new FunctionImpl<bool(Kernel::*)() const>(&Kernel::isOwnerPtr));
						case 83: return FunctionPtr(new FunctionImpl<bool(Kernel::*)() const>(&Kernel::isConstPtr));
						case 84: return FunctionPtr(new FunctionImpl<uint32_t(Kernel::*)() const>(&Kernel::getCountPtr));
						case 85: return FunctionPtr(new FunctionImpl<const void*(Kernel::*)() const>(&Kernel::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 3769, 3482, 3829, 2227, 3246, 3247, 3248, 1932, 1933, 1934, 1533, 3815, 2606, 3814, 2728, 3811, 2724, 1539, 3900, 2616, 3894, 2841, 3886, 2829, 1536, 3867, 2611, 3864, 2804, 3861, 2801, 1542, 3923, 2622, 3922, 2885, 3919, 2882, 1535, 3856, 2610, 3853, 2793, 3850, 2790, 1541, 3910, 2619, 3909, 2871, 1538, 3880, 2615, 3879, 2823, 1537, 2612, 3871, 2812, 3872, 2814, 2813, 3869, 2810, 3655, 2402, 2403, 2404, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 4073, 1585, 4073, 1205, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 857, 4039, 857, 4039, 857, 4039, 4039, 857, 4039, 857, 4039, 857, 4039, 4039, 857, 4039, 857, 4039, 857, 4039, 4039, 857, 4039, 857, 4039, 857, 117, 4039, 857, 4039, 857, 4039, 857, 117, 4039, 857, 4039, 857, 4039, 4039, 857, 4039, 857, 4039, 4039, 4039, 857, 4039, 857, 1281, 4039, 857, 117, 4073, 4039, 4039, 4039, 856, 4073, 4073, 857, 857, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 3, 5, 5, 9, 13, 14, 18, 22, 23, 23, 24, 24, 25, 25, 28, 29, 29, 30, 30, 31, 31, 34, 35, 35, 36, 36, 37, 37, 40, 41, 42, 44, 44, 45, 45, 47, 48, 49, 51, 51, 52, 52, 54, 55, 55, 56, 56, 57, 57, 57, 58, 58, 59, 59, 61, 61, 62, 62, 66, 67, 68, 70, 71, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1795, 1273, 1206, 1585, 1877, 1841, 1878, 4039, 1877, 1841, 1878, 4039, 1877, 1877, 1841, 1878, 4039, 1877, 1841, 1878, 4039, 1703, 4039, 4039, 4039, 4039, 1585, 4039, 4039, 4039, 4039, 4039, 1585, 4039, 4039, 4039, 4039, 4039, 1585, 4039, 117, 4039, 117, 4039, 4039, 117, 4039, 117, 4039, 117, 4039, 4039, 117, 4039, 4039, 4039, 4039, 4039, 1281, 4039, 4039, 4039, 1281, 4039, 117, 4039, 4039, 4039, 117, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3229, 3990, 3952, 3341, 3288, 3255, 2992, 3960, 3288, 3255, 2992, 3960, 3288, 3975, 3255, 2992, 3960, 3975, 3255, 2992, 3960, 1948, 3295, 3317, 2993, 3295, 1558, 2993, 3295, 3317, 2993, 3295, 1558, 2993, 3295, 3317, 2993, 3295, 1558, 2993, 2045, 3295, 2045, 3317, 2993, 2045, 2993, 2045, 3295, 2045, 3317, 2993, 2045, 2993, 3295, 3317, 3295, 3317, 4036, 3960, 3317, 2993, 4036, 3960, 2045, 2993, 2993, 2993, 2045, 2993, 4089, 2980, 1959 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 2016, 0, 1277, 3294, 3, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 1277, 3294, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 0, 116, 0, 0, 0, 0, 116, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 6, 6 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionKernel::constructor_bases[];
	constexpr uint16_t ReflectionKernel::constructor_arg_types[];
	constexpr uint16_t ReflectionKernel::constructor_arg_names[];
	constexpr uint16_t ReflectionKernel::constructor_arg_values[];
	constexpr uint8_t ReflectionKernel::function_flags[];
	constexpr uint16_t ReflectionKernel::function_names[];
	constexpr uint16_t ReflectionKernel::function_types[];
	constexpr uint16_t ReflectionKernel::function_bases[];
	constexpr uint16_t ReflectionKernel::function_arg_types[];
	constexpr uint16_t ReflectionKernel::function_arg_names[];
	constexpr uint16_t ReflectionKernel::function_arg_values[];
	constexpr uint16_t ReflectionKernel::callback_names[];
	constexpr uint16_t ReflectionKernel::callback_types[];
	constexpr uint16_t ReflectionKernel::callback_bases[];
	constexpr uint16_t ReflectionKernel::callback_arg_types[];
	constexpr uint16_t ReflectionKernel::callback_arg_names[];
	constexpr uint16_t ReflectionKernel::enum_names[];
	constexpr uint16_t ReflectionKernel::enum_bases[];
	constexpr uint16_t ReflectionKernel::enum_var_names[];
	static ReflectionKernel reflection_kernel;
	
	// Tellusim::D3D12Kernel
	class ReflectionD3D12Kernel : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Kernel::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_kernel;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Kernel, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Kernel>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D12RootSignature*(D3D12Kernel::*)() const>(&D3D12Kernel::getRootSignature));
						case 1: return FunctionPtr(new FunctionImpl<D3D12Kernel(D3D12Kernel::*)() const>(&D3D12Kernel::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(D3D12Kernel::*)()>(&D3D12Kernel::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Kernel::*)()>(&D3D12Kernel::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<D3D12Kernel&(D3D12Kernel::*)()>(&D3D12Kernel::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Kernel&(D3D12Kernel::*)()>(&D3D12Kernel::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(D3D12Kernel::*)() const>(&D3D12Kernel::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Kernel::*)() const>(&D3D12Kernel::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Kernel::*)() const>(&D3D12Kernel::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Kernel::*)() const>(&D3D12Kernel::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(D3D12Kernel::*)() const>(&D3D12Kernel::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2716, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 833, 413, 4073, 4073, 414, 414, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Kernel::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Kernel::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Kernel::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Kernel::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Kernel::function_flags[];
	constexpr uint16_t ReflectionD3D12Kernel::function_names[];
	constexpr uint16_t ReflectionD3D12Kernel::function_types[];
	constexpr uint16_t ReflectionD3D12Kernel::function_bases[];
	constexpr uint16_t ReflectionD3D12Kernel::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Kernel::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Kernel::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Kernel::callback_names[];
	constexpr uint16_t ReflectionD3D12Kernel::callback_types[];
	constexpr uint16_t ReflectionD3D12Kernel::callback_bases[];
	constexpr uint16_t ReflectionD3D12Kernel::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Kernel::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Kernel::enum_names[];
	constexpr uint16_t ReflectionD3D12Kernel::enum_bases[];
	constexpr uint16_t ReflectionD3D12Kernel::enum_var_names[];
	static ReflectionD3D12Kernel reflection_d3d12_kernel;
	
	// Tellusim::MTLKernel
	class ReflectionMTLKernel : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLKernel::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_kernel;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLKernel, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLKernel>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MTLKernel::*)(bool)>(&MTLKernel::setIndirect));
						case 1: return FunctionPtr(new FunctionImpl<bool(MTLKernel::*)() const>(&MTLKernel::isIndirect));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLKernel::*)() const>(&MTLKernel::getComputeFunction));
						case 3: return FunctionPtr(new FunctionImpl<MTLKernel(MTLKernel::*)() const>(&MTLKernel::clonePtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(MTLKernel::*)()>(&MTLKernel::clearPtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLKernel::*)()>(&MTLKernel::destroyPtr));
						case 6: return FunctionPtr(new FunctionImpl<MTLKernel&(MTLKernel::*)()>(&MTLKernel::acquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLKernel&(MTLKernel::*)()>(&MTLKernel::unacquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(MTLKernel::*)() const>(&MTLKernel::isValidPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLKernel::*)() const>(&MTLKernel::isOwnerPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLKernel::*)() const>(&MTLKernel::isConstPtr));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(MTLKernel::*)() const>(&MTLKernel::getCountPtr));
						case 12: return FunctionPtr(new FunctionImpl<const void*(MTLKernel::*)() const>(&MTLKernel::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3671, 3098, 2226, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4074, 909, 4073, 4073, 910, 910, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 1585 };
			static constexpr uint16_t function_arg_names[] = { 1996 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLKernel::constructor_bases[];
	constexpr uint16_t ReflectionMTLKernel::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLKernel::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLKernel::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLKernel::function_flags[];
	constexpr uint16_t ReflectionMTLKernel::function_names[];
	constexpr uint16_t ReflectionMTLKernel::function_types[];
	constexpr uint16_t ReflectionMTLKernel::function_bases[];
	constexpr uint16_t ReflectionMTLKernel::function_arg_types[];
	constexpr uint16_t ReflectionMTLKernel::function_arg_names[];
	constexpr uint16_t ReflectionMTLKernel::function_arg_values[];
	constexpr uint16_t ReflectionMTLKernel::callback_names[];
	constexpr uint16_t ReflectionMTLKernel::callback_types[];
	constexpr uint16_t ReflectionMTLKernel::callback_bases[];
	constexpr uint16_t ReflectionMTLKernel::callback_arg_types[];
	constexpr uint16_t ReflectionMTLKernel::callback_arg_names[];
	constexpr uint16_t ReflectionMTLKernel::enum_names[];
	constexpr uint16_t ReflectionMTLKernel::enum_bases[];
	constexpr uint16_t ReflectionMTLKernel::enum_var_names[];
	static ReflectionMTLKernel reflection_mtl_kernel;
	
	// Tellusim::FUKernel
	class ReflectionFUKernel : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUKernel::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_kernel;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUKernel, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUKernel, TypeList<const Array<Kernel>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUKernel>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUKernel::*)(uint32_t)>(&FUKernel::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUKernel::*)() const>(&FUKernel::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUKernel::*)() const>(&FUKernel::getNumKernels));
						case 3: return FunctionPtr(new FunctionImpl<const Kernel(FUKernel::*)(uint32_t) const>(&FUKernel::getKernel));
						case 4: return FunctionPtr(new FunctionImpl<Kernel(FUKernel::*)(uint32_t)>(&FUKernel::getKernel));
						case 5: return FunctionPtr(new FunctionImpl<FUKernel(FUKernel::*)() const>(&FUKernel::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUKernel::*)()>(&FUKernel::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUKernel::*)()>(&FUKernel::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUKernel&(FUKernel::*)()>(&FUKernel::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUKernel&(FUKernel::*)()>(&FUKernel::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUKernel::*)() const>(&FUKernel::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUKernel::*)() const>(&FUKernel::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUKernel::*)() const>(&FUKernel::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUKernel::*)() const>(&FUKernel::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUKernel::*)() const>(&FUKernel::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1677, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3230, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2593, 2462, 2462, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1794, 856, 536, 4073, 4073, 537, 537, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUKernel::constructor_bases[];
	constexpr uint16_t ReflectionFUKernel::constructor_arg_types[];
	constexpr uint16_t ReflectionFUKernel::constructor_arg_names[];
	constexpr uint16_t ReflectionFUKernel::constructor_arg_values[];
	constexpr uint8_t ReflectionFUKernel::function_flags[];
	constexpr uint16_t ReflectionFUKernel::function_names[];
	constexpr uint16_t ReflectionFUKernel::function_types[];
	constexpr uint16_t ReflectionFUKernel::function_bases[];
	constexpr uint16_t ReflectionFUKernel::function_arg_types[];
	constexpr uint16_t ReflectionFUKernel::function_arg_names[];
	constexpr uint16_t ReflectionFUKernel::function_arg_values[];
	constexpr uint16_t ReflectionFUKernel::callback_names[];
	constexpr uint16_t ReflectionFUKernel::callback_types[];
	constexpr uint16_t ReflectionFUKernel::callback_bases[];
	constexpr uint16_t ReflectionFUKernel::callback_arg_types[];
	constexpr uint16_t ReflectionFUKernel::callback_arg_names[];
	constexpr uint16_t ReflectionFUKernel::enum_names[];
	constexpr uint16_t ReflectionFUKernel::enum_bases[];
	constexpr uint16_t ReflectionFUKernel::enum_var_names[];
	static ReflectionFUKernel reflection_fu_kernel;
	
	// Tellusim::Pipeline
	class ReflectionPipeline : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Pipeline::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Pipeline, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Pipeline>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Pipeline::*)() const>(&Pipeline::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Pipeline::*)() const>(&Pipeline::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)()>(&Pipeline::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(const char*)>(&Pipeline::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(Pipeline::*)() const>(&Pipeline::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)()>(&Pipeline::create));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(const Pipeline&)>(&Pipeline::setParameters));
						case 9: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Stream&) const>(&Pipeline::saveState));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Shader&, bool)>(&Pipeline::addShader, Shader::null, false));
						case 11: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getVertexShader));
						case 12: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getControlShader));
						case 13: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getEvaluateShader));
						case 14: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getGeometryShader));
						case 15: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getFragmentShader));
						case 16: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getTaskShader));
						case 17: return FunctionPtr(new FunctionImpl<Shader(Pipeline::*)() const>(&Pipeline::getMeshShader));
						case 18: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Pipeline::loadShader, {}, {}, String::null, nullptr, 0));
						case 19: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Pipeline::loadShaderGLSL, {}, {}, String::null, nullptr, 0));
						case 20: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Shader::Type, const char*)>(&Pipeline::loadShaderSPIRV));
						case 21: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Pipeline::createShader, {}, {}, String::null, nullptr, 0));
						case 22: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Pipeline::createShaderGLSL, {}, {}, String::null, nullptr, 0));
						case 23: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)(Shader::Type, const Array<uint32_t>&)>(&Pipeline::createShaderSPIRV));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask)>(&Pipeline::addSampler));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumSamplers));
						case 26: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setSamplerOffset));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getSamplerOffset));
						case 28: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask)>(&Pipeline::setSamplerMask));
						case 29: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getSamplerMask));
						case 30: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask, bool)>(&Pipeline::setSamplerMasks, {}, {}, {}, false));
						case 31: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getSamplerMasks));
						case 32: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, bool)>(&Pipeline::setSamplerArray));
						case 33: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getSamplerArray));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask)>(&Pipeline::addTexture));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumTextures));
						case 36: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setTextureOffset));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getTextureOffset));
						case 38: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask)>(&Pipeline::setTextureMask));
						case 39: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getTextureMask));
						case 40: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask, bool)>(&Pipeline::setTextureMasks, {}, {}, {}, false));
						case 41: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getTextureMasks));
						case 42: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, bool)>(&Pipeline::setTextureArray));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getTextureArray));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask)>(&Pipeline::addSurface));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumSurfaces));
						case 46: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setSurfaceOffset));
						case 47: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getSurfaceOffset));
						case 48: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask)>(&Pipeline::setSurfaceMask));
						case 49: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getSurfaceMask));
						case 50: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask, bool)>(&Pipeline::setSurfaceMasks, {}, {}, {}, false));
						case 51: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getSurfaceMasks));
						case 52: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, bool)>(&Pipeline::setSurfaceArray));
						case 53: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getSurfaceArray));
						case 54: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask, BindFlags)>(&Pipeline::addUniform, {}, Tellusim::BindFlagNone));
						case 55: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumUniforms));
						case 56: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setUniformOffset));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getUniformOffset));
						case 58: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask, BindFlags)>(&Pipeline::setUniformMask, {}, {}, Tellusim::BindFlagNone));
						case 59: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getUniformMask));
						case 60: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask, BindFlags)>(&Pipeline::setUniformMasks, {}, {}, {}, Tellusim::BindFlagNone));
						case 61: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getUniformMasks));
						case 62: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, BindFlags)>(&Pipeline::setUniformFlags));
						case 63: return FunctionPtr(new FunctionImpl<BindFlags(Pipeline::*)(uint32_t) const>(&Pipeline::getUniformFlags));
						case 64: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask, BindFlags)>(&Pipeline::addStorage, {}, Tellusim::BindFlagNone));
						case 65: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumStorages));
						case 66: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setStorageOffset));
						case 67: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getStorageOffset));
						case 68: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask, BindFlags)>(&Pipeline::setStorageMask, {}, {}, Tellusim::BindFlagNone));
						case 69: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getStorageMask));
						case 70: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask, BindFlags)>(&Pipeline::setStorageMasks, {}, {}, {}, Tellusim::BindFlagNone));
						case 71: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getStorageMasks));
						case 72: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, BindFlags)>(&Pipeline::setStorageFlags));
						case 73: return FunctionPtr(new FunctionImpl<BindFlags(Pipeline::*)(uint32_t) const>(&Pipeline::getStorageFlags));
						case 74: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask)>(&Pipeline::addTracing));
						case 75: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumTracings));
						case 76: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setTracingOffset));
						case 77: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getTracingOffset));
						case 78: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask)>(&Pipeline::setTracingMask));
						case 79: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getTracingMask));
						case 80: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask)>(&Pipeline::setTracingMasks));
						case 81: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getTracingMasks));
						case 82: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Shader::Mask)>(&Pipeline::addTexel));
						case 83: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumTexels));
						case 84: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setTexelOffset));
						case 85: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getTexelOffset));
						case 86: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask)>(&Pipeline::setTexelMask));
						case 87: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getTexelMask));
						case 88: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t, Shader::Mask)>(&Pipeline::setTexelMasks));
						case 89: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t, uint32_t) const>(&Pipeline::getTexelMasks));
						case 90: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(TableType, uint32_t, Shader::Mask, BindFlags)>(&Pipeline::addTable, (TableType)0, {}, {}, Tellusim::BindFlagNone));
						case 91: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumTables));
						case 92: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t)>(&Pipeline::setTableOffset));
						case 93: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getTableOffset));
						case 94: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, TableType, uint32_t, Shader::Mask, BindFlags)>(&Pipeline::setTableType, {}, (TableType)0, {}, {}, Tellusim::BindFlagNone));
						case 95: return FunctionPtr(new FunctionImpl<TableType(Pipeline::*)(uint32_t) const>(&Pipeline::getTableType));
						case 96: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getTableSize));
						case 97: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Shader::Mask, BindFlags)>(&Pipeline::setTableMask, {}, {}, Tellusim::BindFlagNone));
						case 98: return FunctionPtr(new FunctionImpl<Shader::Mask(Pipeline::*)(uint32_t) const>(&Pipeline::getTableMask));
						case 99: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, BindFlags)>(&Pipeline::setTableFlags));
						case 100: return FunctionPtr(new FunctionImpl<BindFlags(Pipeline::*)(uint32_t) const>(&Pipeline::getTableFlags));
						case 101: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumVertices));
						case 102: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getVertexStride));
						case 103: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getVertexRate));
						case 104: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(Pipeline::Attribute, Format, uint32_t, size_t, size_t, uint32_t)>(&Pipeline::addAttribute, (Pipeline::Attribute)0, (Format)0, {}, {}, {}, 0));
						case 105: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Pipeline::Attribute, Format, uint32_t, size_t, size_t, uint32_t)>(&Pipeline::setAttribute, {}, (Pipeline::Attribute)0, (Format)0, {}, {}, {}, 0));
						case 106: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Pipeline::Attribute)>(&Pipeline::setAttributeType));
						case 107: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, Format)>(&Pipeline::setAttributeFormat));
						case 108: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t)>(&Pipeline::setAttributeVertex));
						case 109: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, size_t)>(&Pipeline::setAttributeOffset));
						case 110: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, size_t)>(&Pipeline::setAttributeStride));
						case 111: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)(uint32_t, uint32_t)>(&Pipeline::setAttributeRate));
						case 112: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumAttributes));
						case 113: return FunctionPtr(new FunctionImpl<Pipeline::Attribute(Pipeline::*)(uint32_t) const>(&Pipeline::getAttributeType));
						case 114: return FunctionPtr(new FunctionImpl<Format(Pipeline::*)(uint32_t) const>(&Pipeline::getAttributeFormat));
						case 115: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getAttributeVertex));
						case 116: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getAttributeOffset));
						case 117: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getAttributeStride));
						case 118: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)(uint32_t) const>(&Pipeline::getAttributeRate));
						case 119: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::Primitive)>(&Pipeline::setPrimitive));
						case 120: return FunctionPtr(new FunctionImpl<Pipeline::Primitive(Pipeline::*)() const>(&Pipeline::getPrimitive));
						case 121: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::FillMode)>(&Pipeline::setFillMode));
						case 122: return FunctionPtr(new FunctionImpl<Pipeline::FillMode(Pipeline::*)() const>(&Pipeline::getFillMode));
						case 123: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::CullMode)>(&Pipeline::setCullMode));
						case 124: return FunctionPtr(new FunctionImpl<Pipeline::CullMode(Pipeline::*)() const>(&Pipeline::getCullMode));
						case 125: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::FrontMode)>(&Pipeline::setFrontMode));
						case 126: return FunctionPtr(new FunctionImpl<Pipeline::FrontMode(Pipeline::*)() const>(&Pipeline::getFrontMode));
						case 127: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(float32_t, float32_t, float32_t)>(&Pipeline::setDepthBias, {}, {}, 0.0f));
						case 128: return FunctionPtr(new FunctionImpl<float32_t(Pipeline::*)() const>(&Pipeline::getDepthBias));
						case 129: return FunctionPtr(new FunctionImpl<float32_t(Pipeline::*)() const>(&Pipeline::getDepthSlope));
						case 130: return FunctionPtr(new FunctionImpl<float32_t(Pipeline::*)() const>(&Pipeline::getDepthClamp));
						case 131: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setMultisample));
						case 132: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getMultisample));
						case 133: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setSampleMask));
						case 134: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getSampleMask));
						case 135: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setDepthClip));
						case 136: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getDepthClip));
						case 137: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setDepthReplace));
						case 138: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getDepthReplace));
						case 139: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setScissorTest));
						case 140: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getScissorTest));
						case 141: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setRasterDiscard));
						case 142: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getRasterDiscard));
						case 143: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setSampleShading));
						case 144: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getSampleShading));
						case 145: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setAlphaToCoverage));
						case 146: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getAlphaToCoverage));
						case 147: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setMultisampleRaster));
						case 148: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getMultisampleRaster));
						case 149: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(bool)>(&Pipeline::setConservativeRaster));
						case 150: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::getConservativeRaster));
						case 151: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setNumViewports));
						case 152: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumTargets));
						case 153: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumViewports));
						case 154: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setNumClipDistances));
						case 155: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getNumClipDistances));
						case 156: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&Pipeline::setBlend));
						case 157: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&Pipeline::setBlendColor));
						case 158: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&Pipeline::setBlendAlpha));
						case 159: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t, Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&Pipeline::setBlend));
						case 160: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t, Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&Pipeline::setBlendColor));
						case 161: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t, Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&Pipeline::setBlendAlpha));
						case 162: return FunctionPtr(new FunctionImpl<Pipeline::BlendOp(Pipeline::*)(uint32_t) const>(&Pipeline::getBlendColorOp));
						case 163: return FunctionPtr(new FunctionImpl<Pipeline::BlendOp(Pipeline::*)(uint32_t) const>(&Pipeline::getBlendAlphaOp));
						case 164: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(Pipeline::*)(uint32_t) const>(&Pipeline::getBlendSrcColorFunc));
						case 165: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(Pipeline::*)(uint32_t) const>(&Pipeline::getBlendSrcAlphaFunc));
						case 166: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(Pipeline::*)(uint32_t) const>(&Pipeline::getBlendDestColorFunc));
						case 167: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(Pipeline::*)(uint32_t) const>(&Pipeline::getBlendDestAlphaFunc));
						case 168: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::ColorMask)>(&Pipeline::setColorMask));
						case 169: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t, Pipeline::ColorMask)>(&Pipeline::setColorMask));
						case 170: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t, Format)>(&Pipeline::setColorFormat));
						case 171: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Format, uint32_t)>(&Pipeline::setColorFormat, (Format)0, 1));
						case 172: return FunctionPtr(new FunctionImpl<Pipeline::ColorMask(Pipeline::*)(uint32_t) const>(&Pipeline::getColorMask));
						case 173: return FunctionPtr(new FunctionImpl<Format(Pipeline::*)(uint32_t) const>(&Pipeline::getColorFormat));
						case 174: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::DepthMask)>(&Pipeline::setDepthMask));
						case 175: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::DepthFunc)>(&Pipeline::setDepthFunc));
						case 176: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Format)>(&Pipeline::setDepthFormat));
						case 177: return FunctionPtr(new FunctionImpl<Pipeline::DepthMask(Pipeline::*)() const>(&Pipeline::getDepthMask));
						case 178: return FunctionPtr(new FunctionImpl<Pipeline::DepthFunc(Pipeline::*)() const>(&Pipeline::getDepthFunc));
						case 179: return FunctionPtr(new FunctionImpl<Format(Pipeline::*)() const>(&Pipeline::getDepthFormat));
						case 180: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setStencilMask));
						case 181: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setStencilBackMask));
						case 182: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(uint32_t)>(&Pipeline::setStencilFrontMask));
						case 183: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::StencilFunc, Pipeline::StencilOp)>(&Pipeline::setStencilFunc));
						case 184: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::StencilFunc, Pipeline::StencilOp)>(&Pipeline::setStencilBackFunc));
						case 185: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::StencilFunc, Pipeline::StencilOp)>(&Pipeline::setStencilFrontFunc));
						case 186: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::StencilFunc, Pipeline::StencilOp, Pipeline::StencilOp, Pipeline::StencilOp)>(&Pipeline::setStencilFunc));
						case 187: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::StencilFunc, Pipeline::StencilOp, Pipeline::StencilOp, Pipeline::StencilOp)>(&Pipeline::setStencilBackFunc));
						case 188: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)(Pipeline::StencilFunc, Pipeline::StencilOp, Pipeline::StencilOp, Pipeline::StencilOp)>(&Pipeline::setStencilFrontFunc));
						case 189: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getStencilBackMask));
						case 190: return FunctionPtr(new FunctionImpl<Pipeline::StencilFunc(Pipeline::*)() const>(&Pipeline::getStencilBackFunc));
						case 191: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(Pipeline::*)() const>(&Pipeline::getStencilBackFailOp));
						case 192: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(Pipeline::*)() const>(&Pipeline::getStencilBackDepthFailOp));
						case 193: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(Pipeline::*)() const>(&Pipeline::getStencilBackDepthPassOp));
						case 194: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getStencilFrontMask));
						case 195: return FunctionPtr(new FunctionImpl<Pipeline::StencilFunc(Pipeline::*)() const>(&Pipeline::getStencilFrontFunc));
						case 196: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(Pipeline::*)() const>(&Pipeline::getStencilFrontFailOp));
						case 197: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(Pipeline::*)() const>(&Pipeline::getStencilFrontDepthFailOp));
						case 198: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(Pipeline::*)() const>(&Pipeline::getStencilFrontDepthPassOp));
						case 199: return FunctionPtr(new FunctionImpl<Pipeline(Pipeline::*)() const>(&Pipeline::clonePtr));
						case 200: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)()>(&Pipeline::clearPtr));
						case 201: return FunctionPtr(new FunctionVoidImpl<void(Pipeline::*)()>(&Pipeline::destroyPtr));
						case 202: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)()>(&Pipeline::acquirePtr));
						case 203: return FunctionPtr(new FunctionImpl<Pipeline&(Pipeline::*)()>(&Pipeline::unacquirePtr));
						case 204: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::isValidPtr));
						case 205: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::isOwnerPtr));
						case 206: return FunctionPtr(new FunctionImpl<bool(Pipeline::*)() const>(&Pipeline::isConstPtr));
						case 207: return FunctionPtr(new FunctionImpl<uint32_t(Pipeline::*)() const>(&Pipeline::getCountPtr));
						case 208: return FunctionPtr(new FunctionImpl<const void*(Pipeline::*)() const>(&Pipeline::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 3769, 3482, 1534, 2915, 2233, 2321, 2395, 2359, 2816, 2507, 3246, 3247, 3248, 1932, 1933, 1934, 1533, 2606, 3814, 2728, 3812, 2726, 3813, 2727, 3811, 2724, 1539, 2616, 3894, 2841, 3891, 2838, 3892, 2839, 3886, 2829, 1536, 2611, 3864, 2804, 3862, 2802, 3863, 2803, 3861, 2801, 1542, 2622, 3922, 2885, 3920, 2883, 3921, 2884, 3919, 2882, 1535, 2610, 3853, 2793, 3851, 2791, 3852, 2792, 3850, 2790, 1541, 2619, 3909, 2871, 3907, 2869, 3908, 2870, 1538, 2615, 3879, 2823, 3877, 2821, 3878, 2822, 1537, 2612, 3871, 2812, 3872, 2814, 2813, 3870, 2811, 3869, 2810, 2624, 2916, 2914, 1511, 3509, 3514, 3510, 3515, 3511, 3513, 3512, 2564, 2104, 2099, 2105, 2101, 2103, 2102, 3790, 2683, 3626, 2339, 3585, 2244, 3647, 2366, 3594, 2273, 2290, 2274, 3749, 2554, 3808, 2721, 3595, 2275, 3602, 2287, 3821, 2735, 3794, 2696, 3809, 2722, 3507, 2088, 3750, 2555, 3577, 2230, 3761, 2613, 2625, 3755, 2568, 3524, 3526, 3525, 3524, 3526, 3525, 2122, 2121, 2128, 2127, 2124, 2123, 3567, 3567, 3563, 3563, 2208, 2202, 3601, 3597, 3596, 2284, 2278, 2277, 3842, 3838, 3840, 3841, 3837, 3839, 3841, 3837, 3839, 2774, 2773, 2772, 2770, 2771, 2782, 2781, 2780, 2778, 2779, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 4073, 1585, 4073, 1205, 1205, 1205, 1205, 1205, 1205, 1205, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 1132, 4039, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 1132, 4039, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 1132, 4039, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 1132, 117, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 1132, 117, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 4039, 4039, 1132, 4039, 1132, 1207, 1132, 1207, 4039, 4039, 1132, 4039, 1132, 1281, 4039, 1132, 1207, 1132, 117, 4039, 4039, 4039, 4039, 1132, 1132, 1132, 1132, 1132, 1132, 1132, 4039, 1133, 765, 4039, 4039, 4039, 4039, 4073, 1142, 4073, 1140, 4073, 1137, 4073, 1141, 4073, 2051, 2051, 2051, 4073, 4039, 4073, 4039, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 4039, 4039, 4073, 4039, 4073, 4073, 4073, 4073, 4073, 4073, 1135, 1135, 1134, 1134, 1134, 1134, 4073, 4073, 4073, 4073, 1136, 765, 4073, 4073, 4073, 1139, 1138, 765, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 1143, 1144, 1144, 1144, 4039, 1143, 1144, 1144, 1144, 1131, 4073, 4073, 1132, 1132, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 3, 5, 5, 5, 5, 5, 5, 5, 5, 10, 15, 17, 22, 27, 29, 30, 30, 31, 31, 33, 34, 38, 40, 43, 44, 45, 45, 46, 46, 48, 49, 53, 55, 58, 59, 60, 60, 61, 61, 63, 64, 68, 70, 73, 74, 76, 76, 77, 77, 80, 81, 85, 87, 89, 90, 92, 92, 93, 93, 96, 97, 101, 103, 105, 106, 107, 107, 108, 108, 110, 111, 114, 116, 117, 117, 118, 118, 120, 121, 124, 126, 130, 130, 131, 131, 136, 137, 138, 141, 142, 144, 145, 145, 146, 147, 153, 160, 162, 164, 166, 168, 170, 172, 172, 173, 174, 175, 176, 177, 178, 179, 179, 180, 180, 181, 181, 182, 182, 185, 185, 185, 185, 186, 186, 187, 187, 188, 188, 189, 189, 190, 190, 191, 191, 192, 192, 193, 193, 194, 194, 195, 195, 196, 196, 196, 197, 197, 200, 203, 206, 210, 214, 218, 219, 220, 221, 222, 223, 224, 225, 227, 229, 231, 232, 233, 234, 235, 236, 236, 236, 236, 237, 238, 239, 241, 243, 245, 249, 253, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1826, 1273, 1206, 1585, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1703, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 1585, 4039, 4039, 4039, 4039, 1585, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 1585, 4039, 4039, 4039, 4039, 1585, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 1585, 4039, 4039, 4039, 4039, 1585, 4039, 1207, 117, 4039, 4039, 1207, 117, 4039, 4039, 4039, 1207, 117, 4039, 4039, 4039, 117, 4039, 1207, 117, 4039, 4039, 1207, 117, 4039, 4039, 4039, 1207, 117, 4039, 4039, 4039, 117, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 4039, 4039, 1281, 4039, 1207, 117, 4039, 4039, 1281, 4039, 1207, 117, 4039, 4039, 4039, 1207, 117, 4039, 4039, 117, 4039, 4039, 4039, 1133, 765, 4039, 3961, 3961, 4039, 4039, 1133, 765, 4039, 3961, 3961, 4039, 4039, 1133, 4039, 765, 4039, 4039, 4039, 3961, 4039, 3961, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1142, 1140, 1137, 1141, 2051, 2051, 2051, 4039, 4039, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 4039, 1135, 1134, 1134, 1135, 1134, 1134, 1135, 1134, 1134, 4039, 1135, 1134, 1134, 4039, 1135, 1134, 1134, 4039, 1135, 1134, 1134, 4039, 4039, 4039, 4039, 4039, 4039, 1136, 4039, 1136, 4039, 765, 765, 4039, 4039, 4039, 1139, 1138, 765, 4039, 4039, 4039, 1143, 1144, 1143, 1144, 1143, 1144, 1143, 1144, 1144, 1144, 1143, 1144, 1144, 1144, 1143, 1144, 1144, 1144 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3350, 3990, 3952, 3341, 4036, 3288, 3255, 2992, 3960, 4036, 3288, 3255, 2992, 3960, 4036, 3288, 4036, 3975, 3255, 2992, 3960, 4036, 3975, 3255, 2992, 3960, 4036, 1948, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 1558, 2993, 3295, 2993, 3295, 1558, 2993, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 1558, 2993, 3295, 2993, 3295, 1558, 2993, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 1558, 2993, 3295, 2993, 3295, 1558, 2993, 3260, 2045, 3317, 2993, 3260, 2045, 2993, 2993, 3295, 3260, 2045, 2993, 3295, 2993, 2045, 2993, 3260, 2045, 3317, 2993, 3260, 2045, 2993, 2993, 3295, 3260, 2045, 2993, 3295, 2993, 2045, 2993, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 2993, 3295, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 2993, 3295, 4036, 3960, 3260, 2045, 3317, 2993, 4036, 3960, 3260, 2045, 2993, 2993, 2993, 3260, 2045, 2993, 2993, 2045, 2993, 2993, 2993, 1562, 2066, 4064, 3317, 3991, 3378, 2993, 1562, 2066, 4064, 3317, 3991, 3378, 2993, 1562, 2993, 2066, 2993, 4064, 2993, 3317, 2993, 3991, 2993, 3378, 2993, 2993, 2993, 2993, 2993, 2993, 3363, 3275, 3275, 3275, 1579, 3969, 1611, 3287, 3477, 1996, 1996, 1996, 1996, 1996, 1996, 1996, 1996, 3316, 3302, 3326, 3975, 1963, 3326, 3975, 1963, 3326, 3975, 1963, 2993, 3326, 3975, 1963, 2993, 3326, 3975, 1963, 2993, 3326, 3975, 1963, 2993, 2993, 2993, 2993, 2993, 2993, 3260, 2993, 3260, 2993, 2066, 2066, 3295, 2993, 2993, 3260, 2074, 2066, 3260, 3260, 3260, 2074, 1980, 2074, 1980, 2074, 1980, 2074, 2015, 1971, 1980, 2074, 2015, 1971, 1980, 2074, 2015, 1971, 1980 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 2016, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 116, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 116, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 116, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1154, 64, 560, 373, 775, 142, 122, 254, 448, 438, 1261, 1251 };
			static constexpr uint16_t enum_bases[] = { 0, 12, 23, 26, 30, 33, 38, 58, 66, 70, 80, 88, 98 };
			static constexpr uint16_t enum_var_names[] = { 1159, 1160, 1155, 1156, 1158, 1157, 1162, 1163, 1165, 1164, 1161, 1109, 74, 65, 73, 76, 66, 78, 79, 71, 67, 70, 1088, 561, 562, 1100, 376, 374, 375, 1096, 776, 777, 1103, 143, 146, 145, 144, 1093, 135, 141, 136, 140, 139, 138, 137, 124, 123, 126, 125, 134, 133, 132, 131, 128, 127, 130, 129, 1092, 259, 260, 258, 257, 255, 262, 261, 256, 449, 450, 451, 1099, 446, 445, 439, 440, 443, 441, 447, 444, 442, 1098, 1267, 1266, 1268, 1265, 1263, 1264, 1262, 1114, 1259, 1258, 1252, 1253, 1256, 1254, 1260, 1257, 1255, 1113 };
	};
	constexpr uint16_t ReflectionPipeline::constructor_bases[];
	constexpr uint16_t ReflectionPipeline::constructor_arg_types[];
	constexpr uint16_t ReflectionPipeline::constructor_arg_names[];
	constexpr uint16_t ReflectionPipeline::constructor_arg_values[];
	constexpr uint8_t ReflectionPipeline::function_flags[];
	constexpr uint16_t ReflectionPipeline::function_names[];
	constexpr uint16_t ReflectionPipeline::function_types[];
	constexpr uint16_t ReflectionPipeline::function_bases[];
	constexpr uint16_t ReflectionPipeline::function_arg_types[];
	constexpr uint16_t ReflectionPipeline::function_arg_names[];
	constexpr uint16_t ReflectionPipeline::function_arg_values[];
	constexpr uint16_t ReflectionPipeline::callback_names[];
	constexpr uint16_t ReflectionPipeline::callback_types[];
	constexpr uint16_t ReflectionPipeline::callback_bases[];
	constexpr uint16_t ReflectionPipeline::callback_arg_types[];
	constexpr uint16_t ReflectionPipeline::callback_arg_names[];
	constexpr uint16_t ReflectionPipeline::enum_names[];
	constexpr uint16_t ReflectionPipeline::enum_bases[];
	constexpr uint16_t ReflectionPipeline::enum_var_names[];
	static ReflectionPipeline reflection_pipeline;
	
	// Tellusim::D3D12Pipeline
	class ReflectionD3D12Pipeline : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Pipeline::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_pipeline;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Pipeline, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Pipeline>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D12RootSignature*(D3D12Pipeline::*)() const>(&D3D12Pipeline::getRootSignature));
						case 1: return FunctionPtr(new FunctionImpl<D3D12Pipeline(D3D12Pipeline::*)() const>(&D3D12Pipeline::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(D3D12Pipeline::*)()>(&D3D12Pipeline::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Pipeline::*)()>(&D3D12Pipeline::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<D3D12Pipeline&(D3D12Pipeline::*)()>(&D3D12Pipeline::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Pipeline&(D3D12Pipeline::*)()>(&D3D12Pipeline::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(D3D12Pipeline::*)() const>(&D3D12Pipeline::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Pipeline::*)() const>(&D3D12Pipeline::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Pipeline::*)() const>(&D3D12Pipeline::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Pipeline::*)() const>(&D3D12Pipeline::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(D3D12Pipeline::*)() const>(&D3D12Pipeline::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2716, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 833, 415, 4073, 4073, 416, 416, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Pipeline::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Pipeline::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Pipeline::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Pipeline::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Pipeline::function_flags[];
	constexpr uint16_t ReflectionD3D12Pipeline::function_names[];
	constexpr uint16_t ReflectionD3D12Pipeline::function_types[];
	constexpr uint16_t ReflectionD3D12Pipeline::function_bases[];
	constexpr uint16_t ReflectionD3D12Pipeline::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Pipeline::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Pipeline::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Pipeline::callback_names[];
	constexpr uint16_t ReflectionD3D12Pipeline::callback_types[];
	constexpr uint16_t ReflectionD3D12Pipeline::callback_bases[];
	constexpr uint16_t ReflectionD3D12Pipeline::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Pipeline::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Pipeline::enum_names[];
	constexpr uint16_t ReflectionD3D12Pipeline::enum_bases[];
	constexpr uint16_t ReflectionD3D12Pipeline::enum_var_names[];
	static ReflectionD3D12Pipeline reflection_d3d12_pipeline;
	
	// Tellusim::MTLPipeline
	class ReflectionMTLPipeline : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLPipeline::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_pipeline;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLPipeline, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLPipeline>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MTLPipeline::*)(bool)>(&MTLPipeline::setIndirect));
						case 1: return FunctionPtr(new FunctionImpl<bool(MTLPipeline::*)() const>(&MTLPipeline::isIndirect));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLPipeline::*)() const>(&MTLPipeline::getVertexFunction));
						case 3: return FunctionPtr(new FunctionVoidImpl<void*(MTLPipeline::*)() const>(&MTLPipeline::getFragmentFunction));
						case 4: return FunctionPtr(new FunctionImpl<MTLPipeline(MTLPipeline::*)() const>(&MTLPipeline::clonePtr));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(MTLPipeline::*)()>(&MTLPipeline::clearPtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(MTLPipeline::*)()>(&MTLPipeline::destroyPtr));
						case 7: return FunctionPtr(new FunctionImpl<MTLPipeline&(MTLPipeline::*)()>(&MTLPipeline::acquirePtr));
						case 8: return FunctionPtr(new FunctionImpl<MTLPipeline&(MTLPipeline::*)()>(&MTLPipeline::unacquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(MTLPipeline::*)() const>(&MTLPipeline::isValidPtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(MTLPipeline::*)() const>(&MTLPipeline::isOwnerPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(MTLPipeline::*)() const>(&MTLPipeline::isConstPtr));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(MTLPipeline::*)() const>(&MTLPipeline::getCountPtr));
						case 13: return FunctionPtr(new FunctionImpl<const void*(MTLPipeline::*)() const>(&MTLPipeline::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3671, 3098, 2911, 2358, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4074, 4074, 911, 4073, 4073, 912, 912, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 1585 };
			static constexpr uint16_t function_arg_names[] = { 1996 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLPipeline::constructor_bases[];
	constexpr uint16_t ReflectionMTLPipeline::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLPipeline::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLPipeline::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLPipeline::function_flags[];
	constexpr uint16_t ReflectionMTLPipeline::function_names[];
	constexpr uint16_t ReflectionMTLPipeline::function_types[];
	constexpr uint16_t ReflectionMTLPipeline::function_bases[];
	constexpr uint16_t ReflectionMTLPipeline::function_arg_types[];
	constexpr uint16_t ReflectionMTLPipeline::function_arg_names[];
	constexpr uint16_t ReflectionMTLPipeline::function_arg_values[];
	constexpr uint16_t ReflectionMTLPipeline::callback_names[];
	constexpr uint16_t ReflectionMTLPipeline::callback_types[];
	constexpr uint16_t ReflectionMTLPipeline::callback_bases[];
	constexpr uint16_t ReflectionMTLPipeline::callback_arg_types[];
	constexpr uint16_t ReflectionMTLPipeline::callback_arg_names[];
	constexpr uint16_t ReflectionMTLPipeline::enum_names[];
	constexpr uint16_t ReflectionMTLPipeline::enum_bases[];
	constexpr uint16_t ReflectionMTLPipeline::enum_var_names[];
	static ReflectionMTLPipeline reflection_mtl_pipeline;
	
	// Tellusim::FUPipeline
	class ReflectionFUPipeline : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUPipeline::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_pipeline;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUPipeline, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUPipeline, TypeList<const Array<Pipeline>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUPipeline>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUPipeline::*)(uint32_t)>(&FUPipeline::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUPipeline::*)() const>(&FUPipeline::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUPipeline::*)() const>(&FUPipeline::getNumPipelines));
						case 3: return FunctionPtr(new FunctionImpl<const Pipeline(FUPipeline::*)(uint32_t) const>(&FUPipeline::getPipeline));
						case 4: return FunctionPtr(new FunctionImpl<Pipeline(FUPipeline::*)(uint32_t)>(&FUPipeline::getPipeline));
						case 5: return FunctionPtr(new FunctionImpl<FUPipeline(FUPipeline::*)() const>(&FUPipeline::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUPipeline::*)()>(&FUPipeline::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUPipeline::*)()>(&FUPipeline::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUPipeline&(FUPipeline::*)()>(&FUPipeline::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUPipeline&(FUPipeline::*)()>(&FUPipeline::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUPipeline::*)() const>(&FUPipeline::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUPipeline::*)() const>(&FUPipeline::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUPipeline::*)() const>(&FUPipeline::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUPipeline::*)() const>(&FUPipeline::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUPipeline::*)() const>(&FUPipeline::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1688, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3351, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2602, 2662, 2662, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1825, 1131, 538, 4073, 4073, 539, 539, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUPipeline::constructor_bases[];
	constexpr uint16_t ReflectionFUPipeline::constructor_arg_types[];
	constexpr uint16_t ReflectionFUPipeline::constructor_arg_names[];
	constexpr uint16_t ReflectionFUPipeline::constructor_arg_values[];
	constexpr uint8_t ReflectionFUPipeline::function_flags[];
	constexpr uint16_t ReflectionFUPipeline::function_names[];
	constexpr uint16_t ReflectionFUPipeline::function_types[];
	constexpr uint16_t ReflectionFUPipeline::function_bases[];
	constexpr uint16_t ReflectionFUPipeline::function_arg_types[];
	constexpr uint16_t ReflectionFUPipeline::function_arg_names[];
	constexpr uint16_t ReflectionFUPipeline::function_arg_values[];
	constexpr uint16_t ReflectionFUPipeline::callback_names[];
	constexpr uint16_t ReflectionFUPipeline::callback_types[];
	constexpr uint16_t ReflectionFUPipeline::callback_bases[];
	constexpr uint16_t ReflectionFUPipeline::callback_arg_types[];
	constexpr uint16_t ReflectionFUPipeline::callback_arg_names[];
	constexpr uint16_t ReflectionFUPipeline::enum_names[];
	constexpr uint16_t ReflectionFUPipeline::enum_bases[];
	constexpr uint16_t ReflectionFUPipeline::enum_var_names[];
	static ReflectionFUPipeline reflection_fu_pipeline;
	
	// Tellusim::Traversal
	class ReflectionTraversal : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Traversal::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Traversal, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Traversal>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Traversal::*)() const>(&Traversal::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Traversal::*)() const>(&Traversal::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)()>(&Traversal::clear));
						case 4: return FunctionPtr(new FunctionImpl<bool(Traversal::*)() const>(&Traversal::isCreated));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)(const char*)>(&Traversal::setName));
						case 6: return FunctionPtr(new FunctionImpl<String(Traversal::*)() const>(&Traversal::getName));
						case 7: return FunctionPtr(new FunctionImpl<bool(Traversal::*)()>(&Traversal::create));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)(const Traversal&)>(&Traversal::setParameters));
						case 9: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Stream&) const>(&Traversal::saveState));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)(Shader&, bool)>(&Traversal::addShader, Shader::null, false));
						case 11: return FunctionPtr(new FunctionImpl<Shader(Traversal::*)() const>(&Traversal::getRayGenShader));
						case 12: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Traversal::loadShader, {}, {}, String::null, nullptr, 0));
						case 13: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Traversal::loadShaderGLSL, {}, {}, String::null, nullptr, 0));
						case 14: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Shader::Type, const char*)>(&Traversal::loadShaderSPIRV));
						case 15: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Traversal::createShader, {}, {}, String::null, nullptr, 0));
						case 16: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Shader::Type, const char*, const String&, const char**, uint32_t)>(&Traversal::createShaderGLSL, {}, {}, String::null, nullptr, 0));
						case 17: return FunctionPtr(new FunctionImpl<bool(Traversal::*)(Shader::Type, const Array<uint32_t>&)>(&Traversal::createShaderSPIRV));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask)>(&Traversal::addSampler));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumSamplers));
						case 20: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setSamplerOffset));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getSamplerOffset));
						case 22: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask)>(&Traversal::setSamplerMask));
						case 23: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getSamplerMask));
						case 24: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask, bool)>(&Traversal::setSamplerMasks, {}, {}, {}, false));
						case 25: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getSamplerMasks));
						case 26: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, bool)>(&Traversal::setSamplerArray));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(uint32_t) const>(&Traversal::getSamplerArray));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask)>(&Traversal::addTexture));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumTextures));
						case 30: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setTextureOffset));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getTextureOffset));
						case 32: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask)>(&Traversal::setTextureMask));
						case 33: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getTextureMask));
						case 34: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask, bool)>(&Traversal::setTextureMasks, {}, {}, {}, false));
						case 35: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getTextureMasks));
						case 36: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, bool)>(&Traversal::setTextureArray));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(uint32_t) const>(&Traversal::getTextureArray));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask)>(&Traversal::addSurface));
						case 39: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumSurfaces));
						case 40: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setSurfaceOffset));
						case 41: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getSurfaceOffset));
						case 42: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask)>(&Traversal::setSurfaceMask));
						case 43: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getSurfaceMask));
						case 44: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask, bool)>(&Traversal::setSurfaceMasks, {}, {}, {}, false));
						case 45: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getSurfaceMasks));
						case 46: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, bool)>(&Traversal::setSurfaceArray));
						case 47: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(uint32_t) const>(&Traversal::getSurfaceArray));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask, BindFlags)>(&Traversal::addUniform, {}, Tellusim::BindFlagNone));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumUniforms));
						case 50: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setUniformOffset));
						case 51: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getUniformOffset));
						case 52: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask, BindFlags)>(&Traversal::setUniformMask, {}, {}, Tellusim::BindFlagNone));
						case 53: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getUniformMask));
						case 54: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask, BindFlags)>(&Traversal::setUniformMasks, {}, {}, {}, Tellusim::BindFlagNone));
						case 55: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getUniformMasks));
						case 56: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, BindFlags)>(&Traversal::setUniformFlags));
						case 57: return FunctionPtr(new FunctionImpl<BindFlags(Traversal::*)(uint32_t) const>(&Traversal::getUniformFlags));
						case 58: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask, BindFlags)>(&Traversal::addStorage, {}, Tellusim::BindFlagNone));
						case 59: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumStorages));
						case 60: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setStorageOffset));
						case 61: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getStorageOffset));
						case 62: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask, BindFlags)>(&Traversal::setStorageMask, {}, {}, Tellusim::BindFlagNone));
						case 63: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getStorageMask));
						case 64: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask, BindFlags)>(&Traversal::setStorageMasks, {}, {}, {}, Tellusim::BindFlagNone));
						case 65: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getStorageMasks));
						case 66: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, BindFlags)>(&Traversal::setStorageFlags));
						case 67: return FunctionPtr(new FunctionImpl<BindFlags(Traversal::*)(uint32_t) const>(&Traversal::getStorageFlags));
						case 68: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask)>(&Traversal::addTracing));
						case 69: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumTracings));
						case 70: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setTracingOffset));
						case 71: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getTracingOffset));
						case 72: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask)>(&Traversal::setTracingMask));
						case 73: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getTracingMask));
						case 74: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask)>(&Traversal::setTracingMasks));
						case 75: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getTracingMasks));
						case 76: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(Shader::Mask)>(&Traversal::addTexel));
						case 77: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumTexels));
						case 78: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setTexelOffset));
						case 79: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getTexelOffset));
						case 80: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask)>(&Traversal::setTexelMask));
						case 81: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getTexelMask));
						case 82: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, uint32_t, Shader::Mask)>(&Traversal::setTexelMasks));
						case 83: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t, uint32_t) const>(&Traversal::getTexelMasks));
						case 84: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(TableType, uint32_t, Shader::Mask, BindFlags)>(&Traversal::addTable, (TableType)0, {}, {}, Tellusim::BindFlagNone));
						case 85: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getNumTables));
						case 86: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t)>(&Traversal::setTableOffset));
						case 87: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getTableOffset));
						case 88: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, TableType, uint32_t, Shader::Mask, BindFlags)>(&Traversal::setTableType, {}, (TableType)0, {}, {}, Tellusim::BindFlagNone));
						case 89: return FunctionPtr(new FunctionImpl<TableType(Traversal::*)(uint32_t) const>(&Traversal::getTableType));
						case 90: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)(uint32_t) const>(&Traversal::getTableSize));
						case 91: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, Shader::Mask, BindFlags)>(&Traversal::setTableMask, {}, {}, Tellusim::BindFlagNone));
						case 92: return FunctionPtr(new FunctionImpl<Shader::Mask(Traversal::*)(uint32_t) const>(&Traversal::getTableMask));
						case 93: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)(uint32_t, BindFlags)>(&Traversal::setTableFlags));
						case 94: return FunctionPtr(new FunctionImpl<BindFlags(Traversal::*)(uint32_t) const>(&Traversal::getTableFlags));
						case 95: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)(uint32_t)>(&Traversal::setRecursionDepth));
						case 96: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getRecursionDepth));
						case 97: return FunctionPtr(new FunctionImpl<Traversal(Traversal::*)() const>(&Traversal::clonePtr));
						case 98: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)()>(&Traversal::clearPtr));
						case 99: return FunctionPtr(new FunctionVoidImpl<void(Traversal::*)()>(&Traversal::destroyPtr));
						case 100: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)()>(&Traversal::acquirePtr));
						case 101: return FunctionPtr(new FunctionImpl<Traversal&(Traversal::*)()>(&Traversal::unacquirePtr));
						case 102: return FunctionPtr(new FunctionImpl<bool(Traversal::*)() const>(&Traversal::isValidPtr));
						case 103: return FunctionPtr(new FunctionImpl<bool(Traversal::*)() const>(&Traversal::isOwnerPtr));
						case 104: return FunctionPtr(new FunctionImpl<bool(Traversal::*)() const>(&Traversal::isConstPtr));
						case 105: return FunctionPtr(new FunctionImpl<uint32_t(Traversal::*)() const>(&Traversal::getCountPtr));
						case 106: return FunctionPtr(new FunctionImpl<const void*(Traversal::*)() const>(&Traversal::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 1612, 3057, 3751, 2556, 1902, 3769, 3482, 1534, 2697, 3246, 3247, 3248, 1932, 1933, 1934, 1533, 2606, 3814, 2728, 3812, 2726, 3813, 2727, 3811, 2724, 1539, 2616, 3894, 2841, 3891, 2838, 3892, 2839, 3886, 2829, 1536, 2611, 3864, 2804, 3862, 2802, 3863, 2803, 3861, 2801, 1542, 2622, 3922, 2885, 3920, 2883, 3921, 2884, 3919, 2882, 1535, 2610, 3853, 2793, 3851, 2791, 3852, 2792, 3850, 2790, 1541, 2619, 3909, 2871, 3907, 2869, 3908, 2870, 1538, 2615, 3879, 2823, 3877, 2821, 3878, 2822, 1537, 2612, 3871, 2812, 3872, 2814, 2813, 3870, 2811, 3869, 2810, 3796, 2699, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 1585, 4073, 1274, 1585, 4073, 1585, 4073, 1205, 1585, 1585, 1585, 1585, 1585, 1585, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 1310, 4039, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 1310, 4039, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 1310, 4039, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 1310, 117, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 1310, 117, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 4039, 4039, 1310, 4039, 1310, 1207, 1310, 1207, 4039, 4039, 1310, 4039, 1310, 1281, 4039, 1310, 1207, 1310, 117, 4073, 4039, 1309, 4073, 4073, 1310, 1310, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 3, 5, 5, 10, 15, 17, 22, 27, 29, 30, 30, 31, 31, 33, 34, 38, 40, 43, 44, 45, 45, 46, 46, 48, 49, 53, 55, 58, 59, 60, 60, 61, 61, 63, 64, 68, 70, 73, 74, 76, 76, 77, 77, 80, 81, 85, 87, 89, 90, 92, 92, 93, 93, 96, 97, 101, 103, 105, 106, 107, 107, 108, 108, 110, 111, 114, 116, 117, 117, 118, 118, 120, 121, 124, 126, 130, 130, 131, 131, 136, 137, 138, 141, 142, 144, 145, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1853, 1273, 1206, 1585, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1208, 1877, 1841, 1878, 4039, 1208, 1877, 1841, 1878, 4039, 1208, 1703, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 1585, 4039, 4039, 4039, 4039, 1585, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 1585, 4039, 4039, 4039, 4039, 1585, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 1585, 4039, 4039, 4039, 4039, 1585, 4039, 1207, 117, 4039, 4039, 1207, 117, 4039, 4039, 4039, 1207, 117, 4039, 4039, 4039, 117, 4039, 1207, 117, 4039, 4039, 1207, 117, 4039, 4039, 4039, 1207, 117, 4039, 4039, 4039, 117, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 1207, 4039, 4039, 4039, 1207, 4039, 4039, 1281, 4039, 1207, 117, 4039, 4039, 1281, 4039, 1207, 117, 4039, 4039, 4039, 1207, 117, 4039, 4039, 117, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 4031, 3990, 3952, 3341, 4036, 3288, 3255, 2992, 3960, 4036, 3288, 3255, 2992, 3960, 4036, 3288, 4036, 3975, 3255, 2992, 3960, 4036, 3975, 3255, 2992, 3960, 4036, 1948, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 1558, 2993, 3295, 2993, 3295, 1558, 2993, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 1558, 2993, 3295, 2993, 3295, 1558, 2993, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 1558, 2993, 3295, 2993, 3295, 1558, 2993, 3260, 2045, 3317, 2993, 3260, 2045, 2993, 2993, 3295, 3260, 2045, 2993, 3295, 2993, 2045, 2993, 3260, 2045, 3317, 2993, 3260, 2045, 2993, 2993, 3295, 3260, 2045, 2993, 3295, 2993, 2045, 2993, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 2993, 3295, 3260, 3317, 2993, 3260, 2993, 2993, 3295, 3260, 2993, 3295, 4036, 3960, 3260, 2045, 3317, 2993, 4036, 3960, 3260, 2045, 2993, 2993, 2993, 3260, 2045, 2993, 2993, 2045, 2993, 1959 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 2016, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 0, 0, 1277, 3294, 3, 0, 0, 1277, 3294, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 116, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 116, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 116, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionTraversal::constructor_bases[];
	constexpr uint16_t ReflectionTraversal::constructor_arg_types[];
	constexpr uint16_t ReflectionTraversal::constructor_arg_names[];
	constexpr uint16_t ReflectionTraversal::constructor_arg_values[];
	constexpr uint8_t ReflectionTraversal::function_flags[];
	constexpr uint16_t ReflectionTraversal::function_names[];
	constexpr uint16_t ReflectionTraversal::function_types[];
	constexpr uint16_t ReflectionTraversal::function_bases[];
	constexpr uint16_t ReflectionTraversal::function_arg_types[];
	constexpr uint16_t ReflectionTraversal::function_arg_names[];
	constexpr uint16_t ReflectionTraversal::function_arg_values[];
	constexpr uint16_t ReflectionTraversal::callback_names[];
	constexpr uint16_t ReflectionTraversal::callback_types[];
	constexpr uint16_t ReflectionTraversal::callback_bases[];
	constexpr uint16_t ReflectionTraversal::callback_arg_types[];
	constexpr uint16_t ReflectionTraversal::callback_arg_names[];
	constexpr uint16_t ReflectionTraversal::enum_names[];
	constexpr uint16_t ReflectionTraversal::enum_bases[];
	constexpr uint16_t ReflectionTraversal::enum_var_names[];
	static ReflectionTraversal reflection_traversal;
	
	// Tellusim::D3D12Traversal
	class ReflectionD3D12Traversal : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Traversal::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_traversal;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Traversal, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Traversal>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<ID3D12RootSignature*(D3D12Traversal::*)() const>(&D3D12Traversal::getRootSignature));
						case 1: return FunctionPtr(new FunctionImpl<D3D12Traversal(D3D12Traversal::*)() const>(&D3D12Traversal::clonePtr));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(D3D12Traversal::*)()>(&D3D12Traversal::clearPtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D12Traversal::*)()>(&D3D12Traversal::destroyPtr));
						case 4: return FunctionPtr(new FunctionImpl<D3D12Traversal&(D3D12Traversal::*)()>(&D3D12Traversal::acquirePtr));
						case 5: return FunctionPtr(new FunctionImpl<D3D12Traversal&(D3D12Traversal::*)()>(&D3D12Traversal::unacquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<bool(D3D12Traversal::*)() const>(&D3D12Traversal::isValidPtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(D3D12Traversal::*)() const>(&D3D12Traversal::isOwnerPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(D3D12Traversal::*)() const>(&D3D12Traversal::isConstPtr));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Traversal::*)() const>(&D3D12Traversal::getCountPtr));
						case 10: return FunctionPtr(new FunctionImpl<const void*(D3D12Traversal::*)() const>(&D3D12Traversal::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2716, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 833, 427, 4073, 4073, 428, 428, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Traversal::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Traversal::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Traversal::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Traversal::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Traversal::function_flags[];
	constexpr uint16_t ReflectionD3D12Traversal::function_names[];
	constexpr uint16_t ReflectionD3D12Traversal::function_types[];
	constexpr uint16_t ReflectionD3D12Traversal::function_bases[];
	constexpr uint16_t ReflectionD3D12Traversal::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Traversal::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Traversal::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Traversal::callback_names[];
	constexpr uint16_t ReflectionD3D12Traversal::callback_types[];
	constexpr uint16_t ReflectionD3D12Traversal::callback_bases[];
	constexpr uint16_t ReflectionD3D12Traversal::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Traversal::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Traversal::enum_names[];
	constexpr uint16_t ReflectionD3D12Traversal::enum_bases[];
	constexpr uint16_t ReflectionD3D12Traversal::enum_var_names[];
	static ReflectionD3D12Traversal reflection_d3d12_traversal;
	
	// Tellusim::FUTraversal
	class ReflectionFUTraversal : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FUTraversal::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_traversal;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FUTraversal, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<FUTraversal, TypeList<const Array<Traversal>&, bool>>({}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FUTraversal>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FUTraversal::*)(uint32_t)>(&FUTraversal::setMask));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(FUTraversal::*)() const>(&FUTraversal::getMask));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(FUTraversal::*)() const>(&FUTraversal::getNumTraversals));
						case 3: return FunctionPtr(new FunctionImpl<const Traversal(FUTraversal::*)(uint32_t) const>(&FUTraversal::getTraversal));
						case 4: return FunctionPtr(new FunctionImpl<Traversal(FUTraversal::*)(uint32_t)>(&FUTraversal::getTraversal));
						case 5: return FunctionPtr(new FunctionImpl<FUTraversal(FUTraversal::*)() const>(&FUTraversal::clonePtr));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(FUTraversal::*)()>(&FUTraversal::clearPtr));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(FUTraversal::*)()>(&FUTraversal::destroyPtr));
						case 8: return FunctionPtr(new FunctionImpl<FUTraversal&(FUTraversal::*)()>(&FUTraversal::acquirePtr));
						case 9: return FunctionPtr(new FunctionImpl<FUTraversal&(FUTraversal::*)()>(&FUTraversal::unacquirePtr));
						case 10: return FunctionPtr(new FunctionImpl<bool(FUTraversal::*)() const>(&FUTraversal::isValidPtr));
						case 11: return FunctionPtr(new FunctionImpl<bool(FUTraversal::*)() const>(&FUTraversal::isOwnerPtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(FUTraversal::*)() const>(&FUTraversal::isConstPtr));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(FUTraversal::*)() const>(&FUTraversal::getCountPtr));
						case 14: return FunctionPtr(new FunctionImpl<const void*(FUTraversal::*)() const>(&FUTraversal::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 1698, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 4032, 3341 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3707, 2482, 2621, 2877, 2877, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4039, 1852, 1309, 552, 4073, 4073, 553, 553, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3260, 2993, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFUTraversal::constructor_bases[];
	constexpr uint16_t ReflectionFUTraversal::constructor_arg_types[];
	constexpr uint16_t ReflectionFUTraversal::constructor_arg_names[];
	constexpr uint16_t ReflectionFUTraversal::constructor_arg_values[];
	constexpr uint8_t ReflectionFUTraversal::function_flags[];
	constexpr uint16_t ReflectionFUTraversal::function_names[];
	constexpr uint16_t ReflectionFUTraversal::function_types[];
	constexpr uint16_t ReflectionFUTraversal::function_bases[];
	constexpr uint16_t ReflectionFUTraversal::function_arg_types[];
	constexpr uint16_t ReflectionFUTraversal::function_arg_names[];
	constexpr uint16_t ReflectionFUTraversal::function_arg_values[];
	constexpr uint16_t ReflectionFUTraversal::callback_names[];
	constexpr uint16_t ReflectionFUTraversal::callback_types[];
	constexpr uint16_t ReflectionFUTraversal::callback_bases[];
	constexpr uint16_t ReflectionFUTraversal::callback_arg_types[];
	constexpr uint16_t ReflectionFUTraversal::callback_arg_names[];
	constexpr uint16_t ReflectionFUTraversal::enum_names[];
	constexpr uint16_t ReflectionFUTraversal::enum_bases[];
	constexpr uint16_t ReflectionFUTraversal::enum_var_names[];
	static ReflectionFUTraversal reflection_fu_traversal;
	
	// Tellusim::Surface
	class ReflectionSurface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Surface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Surface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Surface, TypeList<Context&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<Surface, TypeList<Platform>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Surface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Platform(Surface::*)() const>(&Surface::getPlatform));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Surface::*)() const>(&Surface::getPlatformName));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getIndex));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)(uint32_t, uint32_t)>(&Surface::setSize));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getWidth));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getHeight));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)(uint32_t)>(&Surface::setMultisample));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getMultisample));
						case 8: return FunctionPtr(new FunctionImpl<bool(Surface::*)() const>(&Surface::hasMultisample));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)(uint32_t, uint32_t)>(&Surface::setColorLayer));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)(uint32_t, uint32_t)>(&Surface::setDepthLayer));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getColorLayer));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getDepthLayer));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getColorLayers));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getDepthLayers));
						case 15: return FunctionPtr(new FunctionImpl<bool(Surface::*)() const>(&Surface::hasColorLayers));
						case 16: return FunctionPtr(new FunctionImpl<bool(Surface::*)() const>(&Surface::hasDepthLayers));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)(Format)>(&Surface::setColorFormat));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)(Format)>(&Surface::setDepthFormat));
						case 19: return FunctionPtr(new FunctionImpl<Format(Surface::*)() const>(&Surface::getColorFormat));
						case 20: return FunctionPtr(new FunctionImpl<Format(Surface::*)() const>(&Surface::getDepthFormat));
						case 21: return FunctionPtr(new FunctionImpl<Surface(Surface::*)() const>(&Surface::clonePtr));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)()>(&Surface::clearPtr));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(Surface::*)()>(&Surface::destroyPtr));
						case 24: return FunctionPtr(new FunctionImpl<Surface&(Surface::*)()>(&Surface::acquirePtr));
						case 25: return FunctionPtr(new FunctionImpl<Surface&(Surface::*)()>(&Surface::unacquirePtr));
						case 26: return FunctionPtr(new FunctionImpl<bool(Surface::*)() const>(&Surface::isValidPtr));
						case 27: return FunctionPtr(new FunctionImpl<bool(Surface::*)() const>(&Surface::isOwnerPtr));
						case 28: return FunctionPtr(new FunctionImpl<bool(Surface::*)() const>(&Surface::isConstPtr));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(Surface::*)() const>(&Surface::getCountPtr));
						case 30: return FunctionPtr(new FunctionImpl<const void*(Surface::*)() const>(&Surface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 277, 1146 };
			static constexpr uint16_t constructor_arg_names[] = { 1887, 3352 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2668, 2669, 2421, 3830, 2927, 2410, 3749, 2554, 2962, 3566, 3600, 2206, 2282, 2207, 2283, 2944, 2945, 3563, 3596, 2202, 2277, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1146, 1877, 4039, 4073, 4039, 4039, 4073, 4039, 1585, 4073, 4073, 4039, 4039, 4039, 4039, 1585, 1585, 4073, 4073, 765, 765, 1279, 4073, 4073, 1280, 1280, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 5, 7, 7, 7, 7, 7, 7, 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039, 4039, 4039, 4039, 4039, 765, 765 };
			static constexpr uint16_t function_arg_names[] = { 4089, 2980, 3287, 3235, 3237, 3235, 3237, 2066, 2066 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionSurface::constructor_bases[];
	constexpr uint16_t ReflectionSurface::constructor_arg_types[];
	constexpr uint16_t ReflectionSurface::constructor_arg_names[];
	constexpr uint16_t ReflectionSurface::constructor_arg_values[];
	constexpr uint8_t ReflectionSurface::function_flags[];
	constexpr uint16_t ReflectionSurface::function_names[];
	constexpr uint16_t ReflectionSurface::function_types[];
	constexpr uint16_t ReflectionSurface::function_bases[];
	constexpr uint16_t ReflectionSurface::function_arg_types[];
	constexpr uint16_t ReflectionSurface::function_arg_names[];
	constexpr uint16_t ReflectionSurface::function_arg_values[];
	constexpr uint16_t ReflectionSurface::callback_names[];
	constexpr uint16_t ReflectionSurface::callback_types[];
	constexpr uint16_t ReflectionSurface::callback_bases[];
	constexpr uint16_t ReflectionSurface::callback_arg_types[];
	constexpr uint16_t ReflectionSurface::callback_arg_names[];
	constexpr uint16_t ReflectionSurface::enum_names[];
	constexpr uint16_t ReflectionSurface::enum_bases[];
	constexpr uint16_t ReflectionSurface::enum_var_names[];
	static ReflectionSurface reflection_surface;
	
	// Tellusim::D3D12Surface
	class ReflectionD3D12Surface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D12Surface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_surface;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D12Surface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<D3D12Surface, TypeList<D3D12Context&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D12Surface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<IDXGIFactory4*(D3D12Surface::*)() const>(&D3D12Surface::getFactory));
						case 1: return FunctionPtr(new FunctionImpl<ID3D12Device*(D3D12Surface::*)() const>(&D3D12Surface::getDevice));
						case 2: return FunctionPtr(new FunctionImpl<ID3D12CommandQueue*(D3D12Surface::*)() const>(&D3D12Surface::getQueue));
						case 3: return FunctionPtr(new FunctionImpl<ID3D12GraphicsCommandList*(D3D12Surface::*)() const>(&D3D12Surface::getCommand));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)(IDXGISwapChain*)>(&D3D12Surface::setSwapChain));
						case 5: return FunctionPtr(new FunctionImpl<IDXGISwapChain*(D3D12Surface::*)() const>(&D3D12Surface::getSwapChain));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)(ID3D12Resource*)>(&D3D12Surface::setRenderTarget));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)(ID3D12Resource*)>(&D3D12Surface::setDepthStencil));
						case 8: return FunctionPtr(new FunctionImpl<ID3D12Resource*(D3D12Surface::*)() const>(&D3D12Surface::getRenderTarget));
						case 9: return FunctionPtr(new FunctionImpl<ID3D12Resource*(D3D12Surface::*)() const>(&D3D12Surface::getDepthStencil));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)(size_t)>(&D3D12Surface::setRenderTargetView));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)(size_t)>(&D3D12Surface::setDepthStencilView));
						case 12: return FunctionPtr(new FunctionImpl<size_t(D3D12Surface::*)() const>(&D3D12Surface::getRenderTargetView));
						case 13: return FunctionPtr(new FunctionImpl<size_t(D3D12Surface::*)() const>(&D3D12Surface::getDepthStencilView));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Surface::*)() const>(&D3D12Surface::getColorDXGIFormat));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Surface::*)() const>(&D3D12Surface::getDepthDXGIFormat));
						case 16: return FunctionPtr(new FunctionImpl<D3D12Surface(D3D12Surface::*)() const>(&D3D12Surface::clonePtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)()>(&D3D12Surface::clearPtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(D3D12Surface::*)()>(&D3D12Surface::destroyPtr));
						case 19: return FunctionPtr(new FunctionImpl<D3D12Surface&(D3D12Surface::*)()>(&D3D12Surface::acquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<D3D12Surface&(D3D12Surface::*)()>(&D3D12Surface::unacquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(D3D12Surface::*)() const>(&D3D12Surface::isValidPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(D3D12Surface::*)() const>(&D3D12Surface::isOwnerPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(D3D12Surface::*)() const>(&D3D12Surface::isConstPtr));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(D3D12Surface::*)() const>(&D3D12Surface::getCountPtr));
						case 25: return FunctionPtr(new FunctionImpl<const void*(D3D12Surface::*)() const>(&D3D12Surface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 410 };
			static constexpr uint16_t constructor_arg_names[] = { 1887 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2326, 2298, 2690, 2220, 3868, 2805, 3801, 3604, 2706, 2291, 3802, 3605, 2707, 2292, 2201, 2276, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 836, 830, 829, 831, 4073, 837, 4073, 4073, 832, 832, 4073, 4073, 3961, 3961, 4039, 4039, 419, 4073, 4073, 420, 420, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 1, 1, 2, 3, 3, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
			static constexpr uint16_t function_arg_types[] = { 837, 832, 832, 3961, 3961 };
			static constexpr uint16_t function_arg_names[] = { 3995, 3444, 1960, 3445, 1961 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D12Surface::constructor_bases[];
	constexpr uint16_t ReflectionD3D12Surface::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D12Surface::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D12Surface::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D12Surface::function_flags[];
	constexpr uint16_t ReflectionD3D12Surface::function_names[];
	constexpr uint16_t ReflectionD3D12Surface::function_types[];
	constexpr uint16_t ReflectionD3D12Surface::function_bases[];
	constexpr uint16_t ReflectionD3D12Surface::function_arg_types[];
	constexpr uint16_t ReflectionD3D12Surface::function_arg_names[];
	constexpr uint16_t ReflectionD3D12Surface::function_arg_values[];
	constexpr uint16_t ReflectionD3D12Surface::callback_names[];
	constexpr uint16_t ReflectionD3D12Surface::callback_types[];
	constexpr uint16_t ReflectionD3D12Surface::callback_bases[];
	constexpr uint16_t ReflectionD3D12Surface::callback_arg_types[];
	constexpr uint16_t ReflectionD3D12Surface::callback_arg_names[];
	constexpr uint16_t ReflectionD3D12Surface::enum_names[];
	constexpr uint16_t ReflectionD3D12Surface::enum_bases[];
	constexpr uint16_t ReflectionD3D12Surface::enum_var_names[];
	static ReflectionD3D12Surface reflection_d3d12_surface;
	
	// Tellusim::D3D11Surface
	class ReflectionD3D11Surface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return D3D11Surface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_surface;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<D3D11Surface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<D3D11Surface, TypeList<D3D11Context&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<D3D11Surface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<IDXGIFactory*(D3D11Surface::*)() const>(&D3D11Surface::getFactory));
						case 1: return FunctionPtr(new FunctionImpl<ID3D11Device*(D3D11Surface::*)() const>(&D3D11Surface::getDevice));
						case 2: return FunctionPtr(new FunctionImpl<ID3D11DeviceContext*(D3D11Surface::*)() const>(&D3D11Surface::getContext));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)(IDXGISwapChain*)>(&D3D11Surface::setSwapChain));
						case 4: return FunctionPtr(new FunctionImpl<IDXGISwapChain*(D3D11Surface::*)() const>(&D3D11Surface::getSwapChain));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)(ID3D11Texture2D*)>(&D3D11Surface::setRenderTarget));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)(ID3D11Texture2D*)>(&D3D11Surface::setDepthStencil));
						case 7: return FunctionPtr(new FunctionImpl<ID3D11Texture2D*(D3D11Surface::*)() const>(&D3D11Surface::getRenderTarget));
						case 8: return FunctionPtr(new FunctionImpl<ID3D11Texture2D*(D3D11Surface::*)() const>(&D3D11Surface::getDepthStencil));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)(ID3D11RenderTargetView*)>(&D3D11Surface::setRenderTargetView));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)(ID3D11DepthStencilView*)>(&D3D11Surface::setDepthStencilView));
						case 11: return FunctionPtr(new FunctionImpl<ID3D11RenderTargetView*(D3D11Surface::*)() const>(&D3D11Surface::getRenderTargetView));
						case 12: return FunctionPtr(new FunctionImpl<ID3D11DepthStencilView*(D3D11Surface::*)() const>(&D3D11Surface::getDepthStencilView));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Surface::*)() const>(&D3D11Surface::getColorDXGIFormat));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Surface::*)() const>(&D3D11Surface::getDepthDXGIFormat));
						case 15: return FunctionPtr(new FunctionImpl<D3D11Surface(D3D11Surface::*)() const>(&D3D11Surface::clonePtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)()>(&D3D11Surface::clearPtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(D3D11Surface::*)()>(&D3D11Surface::destroyPtr));
						case 18: return FunctionPtr(new FunctionImpl<D3D11Surface&(D3D11Surface::*)()>(&D3D11Surface::acquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<D3D11Surface&(D3D11Surface::*)()>(&D3D11Surface::unacquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(D3D11Surface::*)() const>(&D3D11Surface::isValidPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(D3D11Surface::*)() const>(&D3D11Surface::isOwnerPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(D3D11Surface::*)() const>(&D3D11Surface::isConstPtr));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(D3D11Surface::*)() const>(&D3D11Surface::getCountPtr));
						case 24: return FunctionPtr(new FunctionImpl<const void*(D3D11Surface::*)() const>(&D3D11Surface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 392 };
			static constexpr uint16_t constructor_arg_names[] = { 1887 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2326, 2298, 2231, 3868, 2805, 3801, 3604, 2706, 2291, 3802, 3605, 2707, 2292, 2201, 2276, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 835, 822, 823, 4073, 837, 4073, 4073, 827, 827, 4073, 4073, 824, 821, 4039, 4039, 397, 4073, 4073, 398, 398, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 1, 2, 3, 3, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
			static constexpr uint16_t function_arg_types[] = { 837, 827, 827, 824, 821 };
			static constexpr uint16_t function_arg_names[] = { 3995, 3444, 1960, 3445, 1961 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionD3D11Surface::constructor_bases[];
	constexpr uint16_t ReflectionD3D11Surface::constructor_arg_types[];
	constexpr uint16_t ReflectionD3D11Surface::constructor_arg_names[];
	constexpr uint16_t ReflectionD3D11Surface::constructor_arg_values[];
	constexpr uint8_t ReflectionD3D11Surface::function_flags[];
	constexpr uint16_t ReflectionD3D11Surface::function_names[];
	constexpr uint16_t ReflectionD3D11Surface::function_types[];
	constexpr uint16_t ReflectionD3D11Surface::function_bases[];
	constexpr uint16_t ReflectionD3D11Surface::function_arg_types[];
	constexpr uint16_t ReflectionD3D11Surface::function_arg_names[];
	constexpr uint16_t ReflectionD3D11Surface::function_arg_values[];
	constexpr uint16_t ReflectionD3D11Surface::callback_names[];
	constexpr uint16_t ReflectionD3D11Surface::callback_types[];
	constexpr uint16_t ReflectionD3D11Surface::callback_bases[];
	constexpr uint16_t ReflectionD3D11Surface::callback_arg_types[];
	constexpr uint16_t ReflectionD3D11Surface::callback_arg_names[];
	constexpr uint16_t ReflectionD3D11Surface::enum_names[];
	constexpr uint16_t ReflectionD3D11Surface::enum_bases[];
	constexpr uint16_t ReflectionD3D11Surface::enum_var_names[];
	static ReflectionD3D11Surface reflection_d3d11_surface;
	
	// Tellusim::MTLSurface
	class ReflectionMTLSurface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MTLSurface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_surface;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MTLSurface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<MTLSurface, TypeList<MTLContext&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MTLSurface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(MTLSurface::*)() const>(&MTLSurface::getDevice));
						case 1: return FunctionPtr(new FunctionVoidImpl<void*(MTLSurface::*)() const>(&MTLSurface::getQueue));
						case 2: return FunctionPtr(new FunctionVoidImpl<void*(MTLSurface::*)() const>(&MTLSurface::getCommand));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(MTLSurface::*)(void*)>(&MTLSurface::setDescriptor));
						case 4: return FunctionPtr(new FunctionVoidImpl<void*(MTLSurface::*)() const>(&MTLSurface::getDescriptor));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(MTLSurface::*)() const>(&MTLSurface::getColorPixelFormat));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(MTLSurface::*)() const>(&MTLSurface::getDepthPixelFormat));
						case 7: return FunctionPtr(new FunctionImpl<MTLSurface(MTLSurface::*)() const>(&MTLSurface::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(MTLSurface::*)()>(&MTLSurface::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(MTLSurface::*)()>(&MTLSurface::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<MTLSurface&(MTLSurface::*)()>(&MTLSurface::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<MTLSurface&(MTLSurface::*)()>(&MTLSurface::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(MTLSurface::*)() const>(&MTLSurface::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(MTLSurface::*)() const>(&MTLSurface::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(MTLSurface::*)() const>(&MTLSurface::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(MTLSurface::*)() const>(&MTLSurface::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(MTLSurface::*)() const>(&MTLSurface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 906 };
			static constexpr uint16_t constructor_arg_names[] = { 1887 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2298, 2690, 2220, 3608, 2297, 2210, 2286, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4074, 4074, 4073, 4074, 4039, 4039, 917, 4073, 4073, 918, 918, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
			static constexpr uint16_t function_arg_types[] = { 4074 };
			static constexpr uint16_t function_arg_names[] = { 1962 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionMTLSurface::constructor_bases[];
	constexpr uint16_t ReflectionMTLSurface::constructor_arg_types[];
	constexpr uint16_t ReflectionMTLSurface::constructor_arg_names[];
	constexpr uint16_t ReflectionMTLSurface::constructor_arg_values[];
	constexpr uint8_t ReflectionMTLSurface::function_flags[];
	constexpr uint16_t ReflectionMTLSurface::function_names[];
	constexpr uint16_t ReflectionMTLSurface::function_types[];
	constexpr uint16_t ReflectionMTLSurface::function_bases[];
	constexpr uint16_t ReflectionMTLSurface::function_arg_types[];
	constexpr uint16_t ReflectionMTLSurface::function_arg_names[];
	constexpr uint16_t ReflectionMTLSurface::function_arg_values[];
	constexpr uint16_t ReflectionMTLSurface::callback_names[];
	constexpr uint16_t ReflectionMTLSurface::callback_types[];
	constexpr uint16_t ReflectionMTLSurface::callback_bases[];
	constexpr uint16_t ReflectionMTLSurface::callback_arg_types[];
	constexpr uint16_t ReflectionMTLSurface::callback_arg_names[];
	constexpr uint16_t ReflectionMTLSurface::enum_names[];
	constexpr uint16_t ReflectionMTLSurface::enum_bases[];
	constexpr uint16_t ReflectionMTLSurface::enum_var_names[];
	static ReflectionMTLSurface reflection_mtl_surface;
	
	// Tellusim::VKSurface
	class ReflectionVKSurface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return VKSurface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_surface;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<VKSurface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<VKSurface, TypeList<VKContext&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<VKSurface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<VkInstance(VKSurface::*)() const>(&VKSurface::getInstance));
						case 1: return FunctionPtr(new FunctionImpl<VkPhysicalDevice(VKSurface::*)() const>(&VKSurface::getAdapter));
						case 2: return FunctionPtr(new FunctionImpl<VkDevice(VKSurface::*)() const>(&VKSurface::getDevice));
						case 3: return FunctionPtr(new FunctionImpl<VkQueue(VKSurface::*)() const>(&VKSurface::getQueue));
						case 4: return FunctionPtr(new FunctionImpl<VkCommandBuffer(VKSurface::*)() const>(&VKSurface::getCommand));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(VKSurface::*)() const>(&VKSurface::getFamily));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkSwapchainKHR)>(&VKSurface::setSwapChain));
						case 7: return FunctionPtr(new FunctionImpl<VkSwapchainKHR(VKSurface::*)() const>(&VKSurface::getSwapChain));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkImage)>(&VKSurface::setColorImage));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkImage)>(&VKSurface::setDepthImage));
						case 10: return FunctionPtr(new FunctionImpl<VkImage(VKSurface::*)() const>(&VKSurface::getColorImage));
						case 11: return FunctionPtr(new FunctionImpl<VkImage(VKSurface::*)() const>(&VKSurface::getDepthImage));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkImageView)>(&VKSurface::setColorImageView));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkImageView)>(&VKSurface::setDepthImageView));
						case 14: return FunctionPtr(new FunctionImpl<VkImageView(VKSurface::*)() const>(&VKSurface::getColorImageView));
						case 15: return FunctionPtr(new FunctionImpl<VkImageView(VKSurface::*)() const>(&VKSurface::getDepthImageView));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkRenderPass)>(&VKSurface::setRenderPass));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)(VkFramebuffer)>(&VKSurface::setFramebuffer));
						case 18: return FunctionPtr(new FunctionImpl<VkRenderPass(VKSurface::*)() const>(&VKSurface::getRenderPass));
						case 19: return FunctionPtr(new FunctionImpl<VkFramebuffer(VKSurface::*)() const>(&VKSurface::getFramebuffer));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(VKSurface::*)() const>(&VKSurface::getColorPixelFormat));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(VKSurface::*)() const>(&VKSurface::getDepthPixelFormat));
						case 22: return FunctionPtr(new FunctionImpl<VKSurface(VKSurface::*)() const>(&VKSurface::clonePtr));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)()>(&VKSurface::clearPtr));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(VKSurface::*)()>(&VKSurface::destroyPtr));
						case 25: return FunctionPtr(new FunctionImpl<VKSurface&(VKSurface::*)()>(&VKSurface::acquirePtr));
						case 26: return FunctionPtr(new FunctionImpl<VKSurface&(VKSurface::*)()>(&VKSurface::unacquirePtr));
						case 27: return FunctionPtr(new FunctionImpl<bool(VKSurface::*)() const>(&VKSurface::isValidPtr));
						case 28: return FunctionPtr(new FunctionImpl<bool(VKSurface::*)() const>(&VKSurface::isOwnerPtr));
						case 29: return FunctionPtr(new FunctionImpl<bool(VKSurface::*)() const>(&VKSurface::isConstPtr));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(VKSurface::*)() const>(&VKSurface::getCountPtr));
						case 31: return FunctionPtr(new FunctionImpl<const void*(VKSurface::*)() const>(&VKSurface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 1403 };
			static constexpr uint16_t constructor_arg_names[] = { 1887 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2434, 2083, 2298, 2690, 2220, 2327, 3868, 2805, 3564, 3598, 2203, 2279, 3565, 3599, 2204, 2280, 3800, 3645, 2705, 2362, 2210, 2286, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1459, 1460, 1454, 1461, 1452, 4039, 4073, 1465, 4073, 4073, 1457, 1457, 4073, 4073, 1458, 1458, 4073, 4073, 1462, 1456, 4039, 4039, 1410, 4073, 4073, 1411, 1411, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 3, 3, 4, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
			static constexpr uint16_t function_arg_types[] = { 1465, 1457, 1457, 1458, 1458, 1462, 1456 };
			static constexpr uint16_t function_arg_names[] = { 3995, 2989, 2989, 2991, 2991, 3443, 2068 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionVKSurface::constructor_bases[];
	constexpr uint16_t ReflectionVKSurface::constructor_arg_types[];
	constexpr uint16_t ReflectionVKSurface::constructor_arg_names[];
	constexpr uint16_t ReflectionVKSurface::constructor_arg_values[];
	constexpr uint8_t ReflectionVKSurface::function_flags[];
	constexpr uint16_t ReflectionVKSurface::function_names[];
	constexpr uint16_t ReflectionVKSurface::function_types[];
	constexpr uint16_t ReflectionVKSurface::function_bases[];
	constexpr uint16_t ReflectionVKSurface::function_arg_types[];
	constexpr uint16_t ReflectionVKSurface::function_arg_names[];
	constexpr uint16_t ReflectionVKSurface::function_arg_values[];
	constexpr uint16_t ReflectionVKSurface::callback_names[];
	constexpr uint16_t ReflectionVKSurface::callback_types[];
	constexpr uint16_t ReflectionVKSurface::callback_bases[];
	constexpr uint16_t ReflectionVKSurface::callback_arg_types[];
	constexpr uint16_t ReflectionVKSurface::callback_arg_names[];
	constexpr uint16_t ReflectionVKSurface::enum_names[];
	constexpr uint16_t ReflectionVKSurface::enum_bases[];
	constexpr uint16_t ReflectionVKSurface::enum_var_names[];
	static ReflectionVKSurface reflection_vk_surface;
	
	// Tellusim::GLSurface
	class ReflectionGLSurface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLSurface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_surface;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLSurface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<GLSurface, TypeList<GLContext&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLSurface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(GLSurface::*)() const>(&GLSurface::getContext));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(GLSurface::*)(uint32_t)>(&GLSurface::setColorTextureID));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(GLSurface::*)(uint32_t)>(&GLSurface::setDepthTextureID));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(GLSurface::*)() const>(&GLSurface::getColorTextureID));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(GLSurface::*)() const>(&GLSurface::getDepthTextureID));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLSurface::*)(uint32_t)>(&GLSurface::setFramebufferID));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(GLSurface::*)() const>(&GLSurface::getFramebufferID));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(GLSurface::*)() const>(&GLSurface::getColorInternalFormat));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(GLSurface::*)() const>(&GLSurface::getDepthInternalFormat));
						case 9: return FunctionPtr(new FunctionImpl<GLSurface(GLSurface::*)() const>(&GLSurface::clonePtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(GLSurface::*)()>(&GLSurface::clearPtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(GLSurface::*)()>(&GLSurface::destroyPtr));
						case 12: return FunctionPtr(new FunctionImpl<GLSurface&(GLSurface::*)()>(&GLSurface::acquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<GLSurface&(GLSurface::*)()>(&GLSurface::unacquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(GLSurface::*)() const>(&GLSurface::isValidPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(GLSurface::*)() const>(&GLSurface::isOwnerPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(GLSurface::*)() const>(&GLSurface::isConstPtr));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(GLSurface::*)() const>(&GLSurface::getCountPtr));
						case 18: return FunctionPtr(new FunctionImpl<const void*(GLSurface::*)() const>(&GLSurface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 782 };
			static constexpr uint16_t constructor_arg_names[] = { 1887 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2231, 3570, 3607, 2214, 2294, 3646, 2363, 2205, 2281, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4073, 4073, 4039, 4039, 4073, 4039, 4039, 4039, 797, 4073, 4073, 798, 798, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 4014, 4014, 2069 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLSurface::constructor_bases[];
	constexpr uint16_t ReflectionGLSurface::constructor_arg_types[];
	constexpr uint16_t ReflectionGLSurface::constructor_arg_names[];
	constexpr uint16_t ReflectionGLSurface::constructor_arg_values[];
	constexpr uint8_t ReflectionGLSurface::function_flags[];
	constexpr uint16_t ReflectionGLSurface::function_names[];
	constexpr uint16_t ReflectionGLSurface::function_types[];
	constexpr uint16_t ReflectionGLSurface::function_bases[];
	constexpr uint16_t ReflectionGLSurface::function_arg_types[];
	constexpr uint16_t ReflectionGLSurface::function_arg_names[];
	constexpr uint16_t ReflectionGLSurface::function_arg_values[];
	constexpr uint16_t ReflectionGLSurface::callback_names[];
	constexpr uint16_t ReflectionGLSurface::callback_types[];
	constexpr uint16_t ReflectionGLSurface::callback_bases[];
	constexpr uint16_t ReflectionGLSurface::callback_arg_types[];
	constexpr uint16_t ReflectionGLSurface::callback_arg_names[];
	constexpr uint16_t ReflectionGLSurface::enum_names[];
	constexpr uint16_t ReflectionGLSurface::enum_bases[];
	constexpr uint16_t ReflectionGLSurface::enum_var_names[];
	static ReflectionGLSurface reflection_gl_surface;
	
	// Tellusim::GLESSurface
	class ReflectionGLESSurface : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return GLESSurface::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_surface;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<GLESSurface, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<GLESSurface, TypeList<GLESContext&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<GLESSurface>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void*(GLESSurface::*)() const>(&GLESSurface::getContext));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(GLESSurface::*)(uint32_t)>(&GLESSurface::setColorTextureID));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(GLESSurface::*)(uint32_t)>(&GLESSurface::setDepthTextureID));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(GLESSurface::*)() const>(&GLESSurface::getColorTextureID));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(GLESSurface::*)() const>(&GLESSurface::getDepthTextureID));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(GLESSurface::*)(uint32_t)>(&GLESSurface::setFramebufferID));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(GLESSurface::*)() const>(&GLESSurface::getFramebufferID));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(GLESSurface::*)() const>(&GLESSurface::getColorInternalFormat));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(GLESSurface::*)() const>(&GLESSurface::getDepthInternalFormat));
						case 9: return FunctionPtr(new FunctionImpl<GLESSurface(GLESSurface::*)() const>(&GLESSurface::clonePtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(GLESSurface::*)()>(&GLESSurface::clearPtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(GLESSurface::*)()>(&GLESSurface::destroyPtr));
						case 12: return FunctionPtr(new FunctionImpl<GLESSurface&(GLESSurface::*)()>(&GLESSurface::acquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<GLESSurface&(GLESSurface::*)()>(&GLESSurface::unacquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(GLESSurface::*)() const>(&GLESSurface::isValidPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(GLESSurface::*)() const>(&GLESSurface::isOwnerPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(GLESSurface::*)() const>(&GLESSurface::isConstPtr));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(GLESSurface::*)() const>(&GLESSurface::getCountPtr));
						case 18: return FunctionPtr(new FunctionImpl<const void*(GLESSurface::*)() const>(&GLESSurface::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 786 };
			static constexpr uint16_t constructor_arg_names[] = { 1887 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2231, 3570, 3607, 2214, 2294, 3646, 2363, 2205, 2281, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4074, 4073, 4073, 4039, 4039, 4073, 4039, 4039, 4039, 789, 4073, 4073, 790, 790, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 4014, 4014, 2069 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionGLESSurface::constructor_bases[];
	constexpr uint16_t ReflectionGLESSurface::constructor_arg_types[];
	constexpr uint16_t ReflectionGLESSurface::constructor_arg_names[];
	constexpr uint16_t ReflectionGLESSurface::constructor_arg_values[];
	constexpr uint8_t ReflectionGLESSurface::function_flags[];
	constexpr uint16_t ReflectionGLESSurface::function_names[];
	constexpr uint16_t ReflectionGLESSurface::function_types[];
	constexpr uint16_t ReflectionGLESSurface::function_bases[];
	constexpr uint16_t ReflectionGLESSurface::function_arg_types[];
	constexpr uint16_t ReflectionGLESSurface::function_arg_names[];
	constexpr uint16_t ReflectionGLESSurface::function_arg_values[];
	constexpr uint16_t ReflectionGLESSurface::callback_names[];
	constexpr uint16_t ReflectionGLESSurface::callback_types[];
	constexpr uint16_t ReflectionGLESSurface::callback_bases[];
	constexpr uint16_t ReflectionGLESSurface::callback_arg_types[];
	constexpr uint16_t ReflectionGLESSurface::callback_arg_names[];
	constexpr uint16_t ReflectionGLESSurface::enum_names[];
	constexpr uint16_t ReflectionGLESSurface::enum_bases[];
	constexpr uint16_t ReflectionGLESSurface::enum_var_names[];
	static ReflectionGLESSurface reflection_gles_surface;
	
	// Tellusim::Window
	class ReflectionWindow : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Window::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Window, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Window, TypeList<Platform, uint32_t>>((Platform)0, Maxu32));
						case 2: return ConstructorPtr(new ConstructorImpl<Window, TypeList<Surface&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Window>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<uint32_t()>(&Window::getNumWindows));
						case 1: return FunctionPtr(new FunctionImpl<Window(uint32_t)>(&Window::getWindow));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(bool)>(&Window::update, false));
						case 3: return FunctionPtr(new FunctionImpl<Platform(Window::*)() const>(&Window::getPlatform));
						case 4: return FunctionPtr(new FunctionImpl<const char*(Window::*)() const>(&Window::getPlatformName));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getIndex));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(Surface&)>(&Window::setSurface));
						case 7: return FunctionPtr(new FunctionImpl<Surface(Window::*)() const>(&Window::getSurface));
						case 8: return FunctionPtr(new FunctionVoidImpl<void*(Window::*)() const>(&Window::getHandle));
						case 9: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isCreated));
						case 10: return FunctionPtr(new FunctionImpl<bool(Window::*)(const char*, Window::Flags)>(&Window::create, {}, Window::DefaultFlags));
						case 11: return FunctionPtr(new FunctionImpl<bool(Window::*)(const String&, Window::Flags)>(&Window::create, {}, Window::DefaultFlags));
						case 12: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Flags)>(&Window::create, Window::DefaultFlags));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Window::*)()>(&Window::release));
						case 14: return FunctionPtr(new FunctionImpl<bool(Window::*)(const Color&)>(&Window::clear));
						case 15: return FunctionPtr(new FunctionImpl<bool(Window::*)(Image&) const>(&Window::grab));
						case 16: return FunctionPtr(new FunctionImpl<bool(Window::*)()>(&Window::render));
						case 17: return FunctionPtr(new FunctionImpl<bool(Window::*)()>(&Window::present));
						case 18: return FunctionPtr(new FunctionImpl<bool(Window::*)()>(&Window::finish));
						case 19: return FunctionPtr(new FunctionImpl<Format(Window::*)() const>(&Window::getColorFormat));
						case 20: return FunctionPtr(new FunctionImpl<Format(Window::*)() const>(&Window::getDepthFormat));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getMultisample));
						case 22: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::hasMultisample));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(Window::Flags)>(&Window::setFlags));
						case 24: return FunctionPtr(new FunctionImpl<Window::Flags(Window::*)() const>(&Window::getFlags));
						case 25: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Flags) const>(&Window::hasFlag));
						case 26: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Flags) const>(&Window::hasFlags));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(uint32_t)>(&Window::setRefreshRate));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getRefreshRate));
						case 29: return FunctionPtr(new FunctionImpl<bool(Window::*)(bool)>(&Window::setHidden));
						case 30: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isHidden));
						case 31: return FunctionPtr(new FunctionImpl<bool(Window::*)(bool)>(&Window::setFocused));
						case 32: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isFocused));
						case 33: return FunctionPtr(new FunctionImpl<bool(Window::*)(bool)>(&Window::setMinimized));
						case 34: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isMinimized));
						case 35: return FunctionPtr(new FunctionImpl<bool(Window::*)(bool)>(&Window::setFullscreen));
						case 36: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isFullscreen));
						case 37: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isOccluded));
						case 38: return FunctionPtr(new FunctionImpl<bool(Window::*)(const char*)>(&Window::setTitle));
						case 39: return FunctionPtr(new FunctionImpl<bool(Window::*)(const String&)>(&Window::setTitle));
						case 40: return FunctionPtr(new FunctionImpl<String(Window::*)() const>(&Window::getTitle));
						case 41: return FunctionPtr(new FunctionImpl<bool(Window::*)(const Image&)>(&Window::setIcon));
						case 42: return FunctionPtr(new FunctionImpl<Image(Window::*)() const>(&Window::getIcon));
						case 43: return FunctionPtr(new FunctionImpl<bool(Window::*)(int32_t, int32_t, uint32_t, uint32_t, bool)>(&Window::setGeometry, {}, {}, {}, {}, false));
						case 44: return FunctionPtr(new FunctionImpl<bool(Window::*)(int32_t, int32_t, bool)>(&Window::setPosition, {}, {}, false));
						case 45: return FunctionPtr(new FunctionImpl<int32_t(Window::*)(bool) const>(&Window::getPositionX, false));
						case 46: return FunctionPtr(new FunctionImpl<int32_t(Window::*)(bool) const>(&Window::getPositionY, false));
						case 47: return FunctionPtr(new FunctionImpl<bool(Window::*)(uint32_t, uint32_t, bool)>(&Window::setSize, {}, {}, false));
						case 48: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getWidth));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getHeight));
						case 50: return FunctionPtr(new FunctionImpl<float32_t(Window::*)() const>(&Window::getScale));
						case 51: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getDpiX));
						case 52: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getDpiY));
						case 53: return FunctionPtr(new FunctionImpl<bool(Window::*)(uint32_t, uint32_t, bool)>(&Window::setMinSize, {}, {}, false));
						case 54: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getMinWidth));
						case 55: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getMinHeight));
						case 56: return FunctionPtr(new FunctionImpl<bool(Window::*)(uint32_t, uint32_t, bool)>(&Window::setMaxSize, {}, {}, false));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getMaxWidth));
						case 58: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getMaxHeight));
						case 59: return FunctionPtr(new FunctionImpl<bool(Window::*)(int32_t, int32_t, bool)>(&Window::setMouse, {}, {}, false));
						case 60: return FunctionPtr(new FunctionImpl<int32_t(Window::*)() const>(&Window::getMouseX));
						case 61: return FunctionPtr(new FunctionImpl<int32_t(Window::*)() const>(&Window::getMouseY));
						case 62: return FunctionPtr(new FunctionImpl<bool(Window::*)(int32_t, int32_t)>(&Window::setMouseDelta));
						case 63: return FunctionPtr(new FunctionImpl<int32_t(Window::*)() const>(&Window::getMouseDX));
						case 64: return FunctionPtr(new FunctionImpl<int32_t(Window::*)() const>(&Window::getMouseDY));
						case 65: return FunctionPtr(new FunctionImpl<bool(Window::*)(bool, bool)>(&Window::setMouseHidden, {}, false));
						case 66: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isMouseHidden));
						case 67: return FunctionPtr(new FunctionImpl<bool(Window::*)(bool, bool)>(&Window::setMouseClipped, {}, false));
						case 68: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isMouseClipped));
						case 69: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isMouseInside));
						case 70: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Cursor, bool)>(&Window::setMouseCursor, (Window::Cursor)0, false));
						case 71: return FunctionPtr(new FunctionImpl<Window::Cursor(Window::*)() const>(&Window::getMouseCursor));
						case 72: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Button)>(&Window::setMouseButtons));
						case 73: return FunctionPtr(new FunctionImpl<Window::Button(Window::*)() const>(&Window::getMouseButtons));
						case 74: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Button, bool)>(&Window::setMouseButton));
						case 75: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Button, bool) const>(&Window::getMouseButton, (Window::Button)0, false));
						case 76: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Button) const>(&Window::wasMouseButtonReleased));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(Window::Button)>(&Window::releaseMouseButtons));
						case 78: return FunctionPtr(new FunctionImpl<Window::Button(Window::*)()>(&Window::clearMouseButtons));
						case 79: return FunctionPtr(new FunctionImpl<bool(Window::*)(Window::Axis, float32_t)>(&Window::setMouseAxis));
						case 80: return FunctionPtr(new FunctionImpl<float32_t(Window::*)(Window::Axis) const>(&Window::getMouseAxis));
						case 81: return FunctionPtr(new FunctionImpl<float32_t(Window::*)(Window::Axis)>(&Window::clearMouseAxis));
						case 82: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::MousePressedCallback&)>(&Window::setMousePressedCallback));
						case 83: return FunctionPtr(new FunctionImpl<Window::MousePressedCallback(Window::*)() const>(&Window::getMousePressedCallback));
						case 84: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::MouseReleasedCallback&)>(&Window::setMouseReleasedCallback));
						case 85: return FunctionPtr(new FunctionImpl<Window::MouseReleasedCallback(Window::*)() const>(&Window::getMouseReleasedCallback));
						case 86: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::MouseChangedCallback&)>(&Window::setMouseChangedCallback));
						case 87: return FunctionPtr(new FunctionImpl<Window::MouseChangedCallback(Window::*)() const>(&Window::getMouseChangedCallback));
						case 88: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::MouseRotatedCallback&)>(&Window::setMouseRotatedCallback));
						case 89: return FunctionPtr(new FunctionImpl<Window::MouseRotatedCallback(Window::*)() const>(&Window::getMouseRotatedCallback));
						case 90: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getNumTouches));
						case 91: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)(int32_t, int32_t)>(&Window::addTouch));
						case 92: return FunctionPtr(new FunctionImpl<int32_t(Window::*)(uint32_t) const>(&Window::getTouchX));
						case 93: return FunctionPtr(new FunctionImpl<int32_t(Window::*)(uint32_t) const>(&Window::getTouchY));
						case 94: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)(int32_t, int32_t) const>(&Window::findTouch));
						case 95: return FunctionPtr(new FunctionVoidImpl<void(Window::*)()>(&Window::clearTouches));
						case 96: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::TouchChangedCallback&)>(&Window::setTouchChangedCallback));
						case 97: return FunctionPtr(new FunctionImpl<Window::TouchChangedCallback(Window::*)() const>(&Window::getTouchChangedCallback));
						case 98: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(uint32_t, bool)>(&Window::setKeyboardKey));
						case 99: return FunctionPtr(new FunctionImpl<bool(Window::*)(uint32_t, bool) const>(&Window::getKeyboardKey, {}, false));
						case 100: return FunctionPtr(new FunctionImpl<bool(Window::*)(uint32_t) const>(&Window::wasKeyboardKeyPressed));
						case 101: return FunctionPtr(new FunctionImpl<bool(Window::*)(uint32_t) const>(&Window::wasKeyboardKeyReleased));
						case 102: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::KeyboardPressedCallback&)>(&Window::setKeyboardPressedCallback));
						case 103: return FunctionPtr(new FunctionImpl<Window::KeyboardPressedCallback(Window::*)() const>(&Window::getKeyboardPressedCallback));
						case 104: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::KeyboardReleasedCallback&)>(&Window::setKeyboardReleasedCallback));
						case 105: return FunctionPtr(new FunctionImpl<Window::KeyboardReleasedCallback(Window::*)() const>(&Window::getKeyboardReleasedCallback));
						case 106: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::SizeChangedCallback&)>(&Window::setSizeChangedCallback));
						case 107: return FunctionPtr(new FunctionImpl<Window::SizeChangedCallback(Window::*)() const>(&Window::getSizeChangedCallback));
						case 108: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::FocusChangedCallback&)>(&Window::setFocusChangedCallback));
						case 109: return FunctionPtr(new FunctionImpl<Window::FocusChangedCallback(Window::*)() const>(&Window::getFocusChangedCallback));
						case 110: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::CloseClickedCallback&)>(&Window::setCloseClickedCallback));
						case 111: return FunctionPtr(new FunctionImpl<Window::CloseClickedCallback(Window::*)() const>(&Window::getCloseClickedCallback));
						case 112: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::PauseChangedCallback&)>(&Window::setPauseChangedCallback));
						case 113: return FunctionPtr(new FunctionImpl<Window::PauseChangedCallback(Window::*)() const>(&Window::getPauseChangedCallback));
						case 114: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::FileDroppedCallback&)>(&Window::setFileDroppedCallback));
						case 115: return FunctionPtr(new FunctionImpl<Window::FileDroppedCallback(Window::*)() const>(&Window::getFileDroppedCallback));
						case 116: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::UpdateCallback&)>(&Window::setUpdateCallback));
						case 117: return FunctionPtr(new FunctionImpl<Window::UpdateCallback(Window::*)() const>(&Window::getUpdateCallback));
						case 118: return FunctionPtr(new FunctionVoidImpl<void(Window::*)(const Window::PresentCallback&)>(&Window::setPresentCallback));
						case 119: return FunctionPtr(new FunctionImpl<Window::PresentCallback(Window::*)() const>(&Window::getPresentCallback));
						case 120: return FunctionPtr(new FunctionImpl<Window::MainLoopCallback(Window::*)() const>(&Window::getMainLoopCallback));
						case 121: return FunctionPtr(new FunctionImpl<bool(Window::*)(const Window::MainLoopCallback&)>(&Window::run));
						case 122: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isRunning));
						case 123: return FunctionPtr(new FunctionVoidImpl<void(Window::*)()>(&Window::stop));
						case 124: return FunctionPtr(new FunctionImpl<bool(Window::*)(const char*)>(&Window::setCopyText));
						case 125: return FunctionPtr(new FunctionImpl<bool(Window::*)(const String&)>(&Window::setCopyText));
						case 126: return FunctionPtr(new FunctionImpl<String(Window::*)() const>(&Window::getPasteText));
						case 127: return FunctionPtr(new FunctionImpl<Window(Window::*)() const>(&Window::clonePtr));
						case 128: return FunctionPtr(new FunctionVoidImpl<void(Window::*)()>(&Window::clearPtr));
						case 129: return FunctionPtr(new FunctionVoidImpl<void(Window::*)()>(&Window::destroyPtr));
						case 130: return FunctionPtr(new FunctionImpl<Window&(Window::*)()>(&Window::acquirePtr));
						case 131: return FunctionPtr(new FunctionImpl<Window&(Window::*)()>(&Window::unacquirePtr));
						case 132: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isValidPtr));
						case 133: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isOwnerPtr));
						case 134: return FunctionPtr(new FunctionImpl<bool(Window::*)() const>(&Window::isConstPtr));
						case 135: return FunctionPtr(new FunctionImpl<uint32_t(Window::*)() const>(&Window::getCountPtr));
						case 136: return FunctionPtr(new FunctionImpl<const void*(Window::*)() const>(&Window::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 1146, 4039, 1280 };
			static constexpr uint16_t constructor_arg_names[] = { 3352, 2993, 3993 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 984, 0 };
			static constexpr uint8_t function_flags[] = { 1, 1, 1, 2, 2, 2, 0, 2, 2, 6, 4, 4, 4, 4, 4, 6, 4, 4, 4, 2, 2, 2, 2, 4, 2, 2, 2, 0, 2, 4, 2, 4, 2, 4, 2, 4, 2, 2, 4, 4, 2, 4, 2, 4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 4, 2, 2, 0, 2, 2, 4, 2, 4, 2, 2, 4, 2, 0, 2, 0, 2, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2, 0, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 4, 6, 4, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2626, 2928, 4051, 2668, 2669, 2421, 3860, 2800, 2406, 3057, 1902, 1902, 1902, 3406, 1612, 2935, 3442, 3362, 2044, 2202, 2277, 2554, 2962, 3628, 2341, 2947, 2948, 3798, 2701, 3657, 3092, 3630, 3079, 3719, 3122, 3648, 3084, 3138, 3904, 3904, 2860, 3663, 2419, 3650, 3782, 2675, 2676, 3830, 2927, 2410, 2730, 2310, 2311, 3717, 2518, 2511, 3708, 2499, 2489, 3731, 2552, 2553, 3740, 2545, 2546, 3741, 3128, 3737, 3126, 3129, 3739, 2544, 3735, 2541, 3734, 2540, 4086, 3411, 1632, 3733, 2539, 1631, 3744, 2549, 3745, 2550, 3736, 2542, 3746, 2551, 2618, 1540, 2862, 2863, 2043, 1641, 3905, 2861, 3696, 2464, 4084, 4085, 3697, 2465, 3698, 2466, 3831, 2761, 3629, 2343, 3561, 2198, 3776, 2661, 3624, 2334, 3924, 2889, 3787, 2680, 2480, 3475, 3162, 3988, 3580, 3580, 2658, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4039, 1471, 4073, 1146, 1877, 4039, 4073, 1279, 4074, 1585, 1585, 1585, 1585, 4073, 1585, 1585, 1585, 1585, 1585, 765, 765, 4039, 1585, 4073, 1478, 1585, 1585, 4073, 4039, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1274, 1585, 838, 1585, 1585, 3003, 3003, 1585, 4039, 4039, 2051, 4039, 4039, 1585, 4039, 4039, 1585, 4039, 4039, 1585, 3003, 3003, 1585, 3003, 3003, 1585, 1585, 1585, 1585, 1585, 1585, 1476, 1585, 1474, 1585, 1585, 1585, 4073, 1474, 1585, 2051, 2051, 4073, 1484, 4073, 1485, 4073, 1483, 4073, 1486, 4039, 4039, 3003, 3003, 4039, 4073, 4073, 1490, 4073, 1585, 1585, 1585, 4073, 1480, 4073, 1481, 4073, 1489, 4073, 1479, 4073, 1475, 4073, 1487, 4073, 1477, 4073, 1491, 4073, 1488, 1482, 1585, 1585, 4073, 1585, 1585, 1274, 1471, 4073, 4073, 1472, 1472, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 2, 2, 2, 3, 3, 3, 3, 5, 7, 8, 8, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 26, 29, 30, 31, 34, 34, 34, 34, 34, 34, 37, 37, 37, 40, 40, 40, 43, 43, 43, 45, 45, 45, 47, 47, 49, 49, 49, 51, 51, 52, 52, 54, 56, 57, 58, 58, 60, 61, 62, 63, 63, 64, 64, 65, 65, 66, 66, 66, 68, 69, 70, 72, 72, 73, 73, 75, 77, 78, 79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85, 86, 86, 87, 87, 88, 88, 88, 89, 89, 89, 90, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91 };
			static constexpr uint16_t function_arg_types[] = { 4039, 1585, 1280, 1877, 1478, 1841, 1478, 1478, 1721, 839, 1478, 1478, 1478, 4039, 1585, 1585, 1585, 1585, 1877, 1841, 1781, 3003, 3003, 4039, 4039, 1585, 3003, 3003, 1585, 1585, 1585, 4039, 4039, 1585, 4039, 4039, 1585, 4039, 4039, 1585, 3003, 3003, 1585, 3003, 3003, 1585, 1585, 1585, 1585, 1476, 1585, 1474, 1474, 1585, 1474, 1585, 1474, 1474, 1473, 2051, 1473, 1473, 1868, 1869, 1867, 1870, 3003, 3003, 4039, 4039, 3003, 3003, 1874, 4039, 1585, 4039, 1585, 4039, 4039, 1864, 1865, 1873, 1863, 1861, 1871, 1862, 1875, 1872, 1866, 1877, 1841 };
			static constexpr uint16_t function_arg_names[] = { 2993, 4076, 3993, 4019, 2045, 4019, 2045, 2045, 1650, 2989, 2045, 2045, 2045, 3378, 2981, 2063, 3272, 2073, 4019, 4019, 2989, 4115, 4116, 4089, 2980, 2065, 4115, 4116, 2065, 4019, 4019, 4089, 2980, 2065, 4089, 2980, 2065, 4089, 2980, 2065, 4115, 4116, 2065, 1991, 1992, 2981, 2065, 1644, 2065, 1947, 2065, 1599, 1598, 4056, 1598, 1612, 1598, 1599, 1566, 4056, 1566, 1566, 2074, 2074, 2074, 2074, 4115, 4116, 4025, 4025, 4115, 4116, 2074, 3231, 4056, 3231, 1612, 3231, 3231, 2074, 2074, 2074, 2074, 2074, 2074, 2074, 2074, 2074, 2074, 4011, 4011 };
			static constexpr uint16_t function_arg_values[] = { 0, 2016, 0, 0, 437, 0, 437, 437, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 2016, 2016, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 0, 2016, 0, 2016, 0, 2016, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 1083, 1084, 1082, 1085, 1301, 897, 898, 1217, 761, 250, 1130, 559, 1394, 1152, 926 };
			static constexpr uint16_t callback_types[] = { 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 1, 2, 4, 6, 6, 8, 9, 11, 12, 12, 13, 15, 15, 15, 15 };
			static constexpr uint16_t callback_arg_types[] = { 1474, 1474, 3003, 3003, 1473, 2051, 4039, 4039, 4039, 4039, 4039, 1585, 1585, 1877, 4039 };
			static constexpr uint16_t callback_arg_names[] = { 1598, 1598, 4115, 4116, 1566, 1958, 3231, 1649, 3231, 4089, 2980, 1604, 3349, 3288, 3418 };
			static constexpr uint16_t enum_names[] = { 753, 377, 159, 83, 0, 858 };
			static constexpr uint16_t enum_bases[] = { 0, 22, 34, 46, 51, 52, 92 };
			static constexpr uint16_t enum_var_names[] = { 678, 729, 608, 634, 704, 663, 656, 731, 635, 732, 627, 670, 671, 672, 740, 702, 611, 612, 610, 669, 437, 1102, 379, 382, 383, 386, 380, 387, 388, 381, 384, 385, 378, 1097, 178, 173, 174, 185, 186, 176, 177, 162, 163, 167, 168, 1094, 95, 96, 97, 94, 1090, 1116, 885, 867, 894, 860, 864, 881, 890, 888, 889, 884, 866, 880, 895, 865, 882, 891, 886, 861, 892, 893, 863, 859, 896, 862, 883, 868, 872, 873, 874, 875, 876, 877, 878, 879, 869, 870, 871, 1104, 887, 887 };
	};
	constexpr uint16_t ReflectionWindow::constructor_bases[];
	constexpr uint16_t ReflectionWindow::constructor_arg_types[];
	constexpr uint16_t ReflectionWindow::constructor_arg_names[];
	constexpr uint16_t ReflectionWindow::constructor_arg_values[];
	constexpr uint8_t ReflectionWindow::function_flags[];
	constexpr uint16_t ReflectionWindow::function_names[];
	constexpr uint16_t ReflectionWindow::function_types[];
	constexpr uint16_t ReflectionWindow::function_bases[];
	constexpr uint16_t ReflectionWindow::function_arg_types[];
	constexpr uint16_t ReflectionWindow::function_arg_names[];
	constexpr uint16_t ReflectionWindow::function_arg_values[];
	constexpr uint16_t ReflectionWindow::callback_names[];
	constexpr uint16_t ReflectionWindow::callback_types[];
	constexpr uint16_t ReflectionWindow::callback_bases[];
	constexpr uint16_t ReflectionWindow::callback_arg_types[];
	constexpr uint16_t ReflectionWindow::callback_arg_names[];
	constexpr uint16_t ReflectionWindow::enum_names[];
	constexpr uint16_t ReflectionWindow::enum_bases[];
	constexpr uint16_t ReflectionWindow::enum_var_names[];
	static ReflectionWindow reflection_window;
	
	// Tellusim::Font
	class ReflectionFont : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Font::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Font, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Font>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Font::*)()>(&Font::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(Font::*)() const>(&Font::isLoaded));
						case 2: return FunctionPtr(new FunctionImpl<bool(Font::*)(const char*)>(&Font::load));
						case 3: return FunctionPtr(new FunctionImpl<bool(Font::*)(Stream&)>(&Font::load));
						case 4: return FunctionPtr(new FunctionImpl<float32_t(Font::*)(const FontStyle&, uint32_t)>(&Font::getAdvance));
						case 5: return FunctionPtr(new FunctionImpl<Rect(Font::*)(const Vector3f&, const FontStyle&, const char*)>(&Font::getRect));
						case 6: return FunctionPtr(new FunctionImpl<Rect(Font::*)(const Vector3f&, const FontStyle&, const uint32_t*)>(&Font::getRect));
						case 7: return FunctionPtr(new FunctionImpl<Rect(Font::*)(const FontBatch*, uint32_t)>(&Font::getRect));
						case 8: return FunctionPtr(new FunctionImpl<Rect(Font::*)(const FontBatch32*, uint32_t)>(&Font::getRect));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(const Device&, const FontStyle&, const char*)>(&Font::create));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(const Device&, const FontStyle&, const uint32_t*)>(&Font::create));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(const Device&, const FontBatch*, uint32_t)>(&Font::create));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(const Device&, const FontBatch32*, uint32_t)>(&Font::create));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(Command&, const Vector3f&, const FontStyle&, const char*)>(&Font::draw));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(Command&, const Vector3f&, const FontStyle&, const uint32_t*)>(&Font::draw));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(Command&, const FontBatch*, uint32_t)>(&Font::draw));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Font::*)(Command&, const FontBatch32*, uint32_t)>(&Font::draw));
						case 17: return FunctionPtr(new FunctionImpl<bool(Font::*)(const Device&)>(&Font::flush));
						case 18: return FunctionPtr(new FunctionImpl<Font(Font::*)() const>(&Font::clonePtr));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(Font::*)()>(&Font::clearPtr));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(Font::*)()>(&Font::destroyPtr));
						case 21: return FunctionPtr(new FunctionImpl<Font&(Font::*)()>(&Font::acquirePtr));
						case 22: return FunctionPtr(new FunctionImpl<Font&(Font::*)()>(&Font::unacquirePtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(Font::*)() const>(&Font::isValidPtr));
						case 24: return FunctionPtr(new FunctionImpl<bool(Font::*)() const>(&Font::isOwnerPtr));
						case 25: return FunctionPtr(new FunctionImpl<bool(Font::*)() const>(&Font::isConstPtr));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(Font::*)() const>(&Font::getCountPtr));
						case 27: return FunctionPtr(new FunctionImpl<const void*(Font::*)() const>(&Font::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3116, 3242, 3242, 2085, 2698, 2698, 2698, 2698, 1902, 1902, 1902, 1902, 1981, 1981, 1981, 1981, 2056, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 2051, 1177, 1177, 1177, 1177, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1585, 762, 4073, 4073, 763, 763, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 1, 2, 4, 7, 10, 12, 14, 17, 20, 23, 26, 30, 34, 37, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1273, 1778, 4039, 1856, 1778, 1877, 1856, 1778, 1882, 1776, 4039, 1777, 4039, 1764, 1778, 1877, 1764, 1778, 1882, 1764, 1776, 4039, 1764, 1777, 4039, 264, 1856, 1778, 1877, 264, 1856, 1778, 1882, 264, 1776, 4039, 264, 1777, 4039, 1764 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3990, 3992, 1649, 3355, 3992, 3989, 3355, 3992, 3989, 1575, 3299, 1575, 3299, 1969, 3992, 3989, 1969, 3992, 3989, 1969, 1575, 3299, 1969, 1575, 3299, 1653, 3355, 3992, 3989, 1653, 3355, 3992, 3989, 1653, 1575, 3299, 1653, 1575, 3299, 1969 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionFont::constructor_bases[];
	constexpr uint16_t ReflectionFont::constructor_arg_types[];
	constexpr uint16_t ReflectionFont::constructor_arg_names[];
	constexpr uint16_t ReflectionFont::constructor_arg_values[];
	constexpr uint8_t ReflectionFont::function_flags[];
	constexpr uint16_t ReflectionFont::function_names[];
	constexpr uint16_t ReflectionFont::function_types[];
	constexpr uint16_t ReflectionFont::function_bases[];
	constexpr uint16_t ReflectionFont::function_arg_types[];
	constexpr uint16_t ReflectionFont::function_arg_names[];
	constexpr uint16_t ReflectionFont::function_arg_values[];
	constexpr uint16_t ReflectionFont::callback_names[];
	constexpr uint16_t ReflectionFont::callback_types[];
	constexpr uint16_t ReflectionFont::callback_bases[];
	constexpr uint16_t ReflectionFont::callback_arg_types[];
	constexpr uint16_t ReflectionFont::callback_arg_names[];
	constexpr uint16_t ReflectionFont::enum_names[];
	constexpr uint16_t ReflectionFont::enum_bases[];
	constexpr uint16_t ReflectionFont::enum_var_names[];
	static ReflectionFont reflection_font;
	
	// Tellusim::CanvasElement
	class ReflectionCanvasElement : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasElement::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasElement, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasElement>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<CanvasElement::Type(CanvasElement::*)() const>(&CanvasElement::getType));
						case 1: return FunctionPtr(new FunctionImpl<const char*(CanvasElement::Type)>(&CanvasElement::getTypeName));
						case 2: return FunctionPtr(new FunctionImpl<const char*(CanvasElement::*)() const>(&CanvasElement::getTypeName));
						case 3: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isText));
						case 4: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isMesh));
						case 5: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isRect));
						case 6: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isTriangle));
						case 7: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isEllipse));
						case 8: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isShape));
						case 9: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isStrip));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Canvas&)>(&CanvasElement::setCanvas));
						case 11: return FunctionPtr(new FunctionImpl<const Canvas(CanvasElement::*)() const>(&CanvasElement::getCanvas));
						case 12: return FunctionPtr(new FunctionImpl<Canvas(CanvasElement::*)()>(&CanvasElement::getCanvas));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(CanvasElement::Mode)>(&CanvasElement::setMode));
						case 14: return FunctionPtr(new FunctionImpl<CanvasElement::Mode(CanvasElement::*)() const>(&CanvasElement::getMode));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(CanvasElement::Align)>(&CanvasElement::setAlign));
						case 16: return FunctionPtr(new FunctionImpl<CanvasElement::Align(CanvasElement::*)() const>(&CanvasElement::getAlign));
						case 17: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)(CanvasElement::Align) const>(&CanvasElement::hasAlign));
						case 18: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)(CanvasElement::Align) const>(&CanvasElement::hasAligns));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(int32_t)>(&CanvasElement::setOrder));
						case 20: return FunctionPtr(new FunctionImpl<int32_t(CanvasElement::*)() const>(&CanvasElement::getOrder));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(bool)>(&CanvasElement::setEnabled));
						case 22: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isEnabled));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)()>(&CanvasElement::clearColor));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(CanvasElement::Stack)>(&CanvasElement::setColor));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(const Color&, CanvasElement::Stack)>(&CanvasElement::setColor, {}, CanvasElement::StackNone));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(float32_t, float32_t, float32_t, float32_t, CanvasElement::Stack)>(&CanvasElement::setColor, {}, {}, {}, {}, CanvasElement::StackNone));
						case 27: return FunctionPtr(new FunctionImpl<const Color&(CanvasElement::*)() const>(&CanvasElement::getColor));
						case 28: return FunctionPtr(new FunctionImpl<CanvasElement::Stack(CanvasElement::*)() const>(&CanvasElement::getColorOp));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)()>(&CanvasElement::clearTransform));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(CanvasElement::Stack)>(&CanvasElement::setTransform));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(const Matrix4x4f&, CanvasElement::Stack)>(&CanvasElement::setTransform, {}, CanvasElement::StackNone));
						case 32: return FunctionPtr(new FunctionImpl<const Matrix4x4f&(CanvasElement::*)() const>(&CanvasElement::getTransform));
						case 33: return FunctionPtr(new FunctionImpl<CanvasElement::Stack(CanvasElement::*)() const>(&CanvasElement::getTransformOp));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)()>(&CanvasElement::clearScissor));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(CanvasElement::Stack)>(&CanvasElement::setScissor));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(const Rect&, CanvasElement::Stack)>(&CanvasElement::setScissor, {}, CanvasElement::StackNone));
						case 37: return FunctionPtr(new FunctionImpl<const Rect&(CanvasElement::*)() const>(&CanvasElement::getScissor));
						case 38: return FunctionPtr(new FunctionImpl<CanvasElement::Stack(CanvasElement::*)() const>(&CanvasElement::getScissorOp));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(float32_t)>(&CanvasElement::setMipmap));
						case 40: return FunctionPtr(new FunctionImpl<float32_t(CanvasElement::*)() const>(&CanvasElement::getMipmap));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Sampler&)>(&CanvasElement::setSampler));
						case 42: return FunctionPtr(new FunctionImpl<Sampler(CanvasElement::*)() const>(&CanvasElement::getSampler));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Sampler::Filter)>(&CanvasElement::setFilter));
						case 44: return FunctionPtr(new FunctionImpl<Sampler::Filter(CanvasElement::*)() const>(&CanvasElement::getFilter));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(uint32_t)>(&CanvasElement::setAnisotropy));
						case 46: return FunctionPtr(new FunctionImpl<uint32_t(CanvasElement::*)() const>(&CanvasElement::getAnisotropy));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Sampler::WrapMode)>(&CanvasElement::setWrapMode));
						case 48: return FunctionPtr(new FunctionImpl<Sampler::WrapMode(CanvasElement::*)() const>(&CanvasElement::getWrapMode));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Texture&, bool)>(&CanvasElement::setTexture, Texture::null, false));
						case 50: return FunctionPtr(new FunctionImpl<Texture(CanvasElement::*)() const>(&CanvasElement::getTexture));
						case 51: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::getTextureLinear));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline)>(&CanvasElement::setPipeline));
						case 53: return FunctionPtr(new FunctionImpl<Pipeline(CanvasElement::*)() const>(&CanvasElement::getPipeline));
						case 54: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::Primitive)>(&CanvasElement::setPrimitive));
						case 55: return FunctionPtr(new FunctionImpl<Pipeline::Primitive(CanvasElement::*)() const>(&CanvasElement::getPrimitive));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::CullMode)>(&CanvasElement::setCullMode));
						case 57: return FunctionPtr(new FunctionImpl<Pipeline::CullMode(CanvasElement::*)() const>(&CanvasElement::getCullMode));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::FrontMode)>(&CanvasElement::setFrontMode));
						case 59: return FunctionPtr(new FunctionImpl<Pipeline::FrontMode(CanvasElement::*)() const>(&CanvasElement::getFrontMode));
						case 60: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&CanvasElement::setBlend));
						case 61: return FunctionPtr(new FunctionImpl<Pipeline::BlendOp(CanvasElement::*)() const>(&CanvasElement::getBlendOp));
						case 62: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(CanvasElement::*)() const>(&CanvasElement::getBlendSrcFunc));
						case 63: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(CanvasElement::*)() const>(&CanvasElement::getBlendDestFunc));
						case 64: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::ColorMask)>(&CanvasElement::setColorMask));
						case 65: return FunctionPtr(new FunctionImpl<Pipeline::ColorMask(CanvasElement::*)() const>(&CanvasElement::getColorMask));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::DepthMask)>(&CanvasElement::setDepthMask));
						case 67: return FunctionPtr(new FunctionImpl<Pipeline::DepthMask(CanvasElement::*)() const>(&CanvasElement::getDepthMask));
						case 68: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::DepthFunc)>(&CanvasElement::setDepthFunc));
						case 69: return FunctionPtr(new FunctionImpl<Pipeline::DepthFunc(CanvasElement::*)() const>(&CanvasElement::getDepthFunc));
						case 70: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(uint32_t)>(&CanvasElement::setStencilRef));
						case 71: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(Pipeline::StencilFunc, Pipeline::StencilOp, Pipeline::StencilOp, Pipeline::StencilOp)>(&CanvasElement::setStencilFunc));
						case 72: return FunctionPtr(new FunctionImpl<uint32_t(CanvasElement::*)() const>(&CanvasElement::getStencilRef));
						case 73: return FunctionPtr(new FunctionImpl<Pipeline::StencilFunc(CanvasElement::*)() const>(&CanvasElement::getStencilFunc));
						case 74: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(CanvasElement::*)() const>(&CanvasElement::getStencilFailOp));
						case 75: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(CanvasElement::*)() const>(&CanvasElement::getStencilDepthFailOp));
						case 76: return FunctionPtr(new FunctionImpl<Pipeline::StencilOp(CanvasElement::*)() const>(&CanvasElement::getStencilDepthPassOp));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)(const CanvasElement::DrawCallback&)>(&CanvasElement::setDrawCallback));
						case 78: return FunctionPtr(new FunctionImpl<CanvasElement::DrawCallback(CanvasElement::*)() const>(&CanvasElement::getDrawCallback));
						case 79: return FunctionPtr(new FunctionImpl<const Rect&(CanvasElement::*)()>(&CanvasElement::getRect));
						case 80: return FunctionPtr(new FunctionImpl<CanvasElement(CanvasElement::*)() const>(&CanvasElement::clonePtr));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)()>(&CanvasElement::clearPtr));
						case 82: return FunctionPtr(new FunctionVoidImpl<void(CanvasElement::*)()>(&CanvasElement::destroyPtr));
						case 83: return FunctionPtr(new FunctionImpl<CanvasElement&(CanvasElement::*)()>(&CanvasElement::acquirePtr));
						case 84: return FunctionPtr(new FunctionImpl<CanvasElement&(CanvasElement::*)()>(&CanvasElement::unacquirePtr));
						case 85: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isValidPtr));
						case 86: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isOwnerPtr));
						case 87: return FunctionPtr(new FunctionImpl<bool(CanvasElement::*)() const>(&CanvasElement::isConstPtr));
						case 88: return FunctionPtr(new FunctionImpl<uint32_t(CanvasElement::*)() const>(&CanvasElement::getCountPtr));
						case 89: return FunctionPtr(new FunctionImpl<const void*(CanvasElement::*)() const>(&CanvasElement::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2878, 2879, 2879, 3188, 3120, 3157, 3195, 3070, 3171, 3182, 3548, 2181, 2181, 3723, 2525, 3506, 2086, 2939, 2940, 3763, 2632, 3618, 3071, 1619, 3562, 3562, 3562, 2200, 2209, 1642, 3911, 3911, 2872, 2873, 1638, 3820, 3820, 2733, 2734, 3721, 2520, 3810, 2723, 3627, 2340, 3508, 2091, 3947, 2929, 3885, 2828, 2837, 3777, 2662, 3790, 2683, 3585, 2244, 3647, 2366, 3524, 2126, 2129, 2125, 3567, 2208, 3601, 2284, 3597, 2278, 3843, 3841, 2784, 2783, 2777, 2775, 2776, 3614, 2313, 2698, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 229, 1877, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 1710, 216, 4073, 227, 4073, 225, 1585, 1585, 4073, 3003, 4073, 1585, 4073, 4073, 4073, 4073, 1721, 228, 4073, 4073, 4073, 1799, 228, 4073, 4073, 4073, 1830, 228, 4073, 2051, 4073, 1192, 4073, 1195, 4073, 4039, 4073, 1198, 4073, 1293, 1585, 4073, 1131, 4073, 1142, 4073, 1137, 4073, 1141, 4073, 1135, 1134, 1134, 4073, 1136, 4073, 1139, 4073, 1138, 4073, 4073, 4039, 1143, 1144, 1144, 1144, 4073, 226, 1830, 223, 4073, 4073, 224, 224, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, 7, 7, 8, 8, 8, 9, 11, 16, 16, 16, 16, 17, 19, 19, 19, 19, 20, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 29, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 36, 36, 36, 36, 37, 37, 38, 38, 39, 39, 40, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45 };
			static constexpr uint16_t function_arg_types[] = { 229, 217, 227, 225, 225, 225, 3003, 1585, 228, 1721, 228, 2051, 2051, 2051, 2051, 228, 228, 1799, 228, 228, 1830, 228, 2051, 1193, 1195, 4039, 1198, 1294, 1585, 1131, 1142, 1137, 1141, 1135, 1134, 1134, 1136, 1139, 1138, 4039, 1143, 1144, 1144, 1144, 1718 };
			static constexpr uint16_t function_arg_names[] = { 4036, 1602, 3275, 1546, 1546, 1548, 3339, 1996, 3326, 1650, 3326, 3372, 2075, 1567, 1500, 3326, 3326, 4028, 3326, 3326, 3488, 3326, 3274, 3478, 2022, 1551, 3275, 4012, 3241, 3350, 3363, 3275, 3275, 3326, 3975, 1963, 3260, 3260, 2074, 3402, 2074, 2015, 1971, 1980, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1241, 0, 0, 0, 0, 1241, 0, 0, 1241, 0, 0, 1241, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 499 };
			static constexpr uint16_t callback_types[] = { 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 2 };
			static constexpr uint16_t callback_arg_types[] = { 263, 223 };
			static constexpr uint16_t callback_arg_names[] = { 1653, 1994 };
			static constexpr uint16_t enum_names[] = { 1311, 1033, 24, 1238 };
			static constexpr uint16_t enum_bases[] = { 0, 9, 23, 36, 42 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1385, 1358, 1369, 1388, 1337, 1374, 1380, 1117, 1062, 1063, 1070, 1066, 1067, 1068, 1069, 1072, 1071, 1065, 1064, 1073, 1046, 1106, 36, 33, 38, 26, 42, 28, 29, 34, 35, 39, 40, 27, 1087, 1241, 1243, 1242, 1244, 1240, 1239 };
	};
	constexpr uint16_t ReflectionCanvasElement::constructor_bases[];
	constexpr uint16_t ReflectionCanvasElement::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasElement::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasElement::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasElement::function_flags[];
	constexpr uint16_t ReflectionCanvasElement::function_names[];
	constexpr uint16_t ReflectionCanvasElement::function_types[];
	constexpr uint16_t ReflectionCanvasElement::function_bases[];
	constexpr uint16_t ReflectionCanvasElement::function_arg_types[];
	constexpr uint16_t ReflectionCanvasElement::function_arg_names[];
	constexpr uint16_t ReflectionCanvasElement::function_arg_values[];
	constexpr uint16_t ReflectionCanvasElement::callback_names[];
	constexpr uint16_t ReflectionCanvasElement::callback_types[];
	constexpr uint16_t ReflectionCanvasElement::callback_bases[];
	constexpr uint16_t ReflectionCanvasElement::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasElement::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasElement::enum_names[];
	constexpr uint16_t ReflectionCanvasElement::enum_bases[];
	constexpr uint16_t ReflectionCanvasElement::enum_var_names[];
	static ReflectionCanvasElement reflection_canvas_element;
	
	// Tellusim::CanvasText
	class ReflectionCanvasText : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasText::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasText, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasText, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasText, TypeList<Canvas&, const char*>>());
						case 3: return ConstructorPtr(new ConstructorImpl<CanvasText, TypeList<Canvas&, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasText>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const char*)>(&CanvasText::setFontName));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const String&)>(&CanvasText::setFontName));
						case 2: return FunctionPtr(new FunctionImpl<String(CanvasText::*)() const>(&CanvasText::getFontName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const Color&)>(&CanvasText::setFontColor));
						case 4: return FunctionPtr(new FunctionImpl<const Color&(CanvasText::*)() const>(&CanvasText::getFontColor));
						case 5: return FunctionPtr(new FunctionImpl<bool(CanvasText::*)(uint32_t)>(&CanvasText::setFontSize));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(CanvasText::*)() const>(&CanvasText::getFontSize));
						case 7: return FunctionPtr(new FunctionImpl<bool(CanvasText::*)(uint32_t)>(&CanvasText::setFontScale));
						case 8: return FunctionPtr(new FunctionImpl<uint32_t(CanvasText::*)() const>(&CanvasText::getFontScale));
						case 9: return FunctionPtr(new FunctionImpl<bool(CanvasText::*)(const FontStyle&)>(&CanvasText::setFontStyle));
						case 10: return FunctionPtr(new FunctionImpl<const FontStyle&(CanvasText::*)() const>(&CanvasText::getFontStyleConst));
						case 11: return FunctionPtr(new FunctionImpl<const FontStyle&(CanvasText::*)() const>(&CanvasText::getFontStyle));
						case 12: return FunctionPtr(new FunctionImpl<FontStyle&(CanvasText::*)()>(&CanvasText::getFontStyle));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const Vector3f&)>(&CanvasText::setPosition));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(float32_t, float32_t, float32_t)>(&CanvasText::setPosition, {}, {}, 0.0f));
						case 15: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasText::*)() const>(&CanvasText::getPosition));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const char*)>(&CanvasText::setText));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const String&)>(&CanvasText::setText));
						case 18: return FunctionPtr(new FunctionImpl<String(CanvasText::*)() const>(&CanvasText::getText));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)()>(&CanvasText::clearBatches));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const Array<FontBatch>&)>(&CanvasText::setBatches));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)(const FontBatch*, uint32_t)>(&CanvasText::setBatches));
						case 22: return FunctionPtr(new FunctionImpl<CanvasText(CanvasText::*)() const>(&CanvasText::clonePtr));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)()>(&CanvasText::clearPtr));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasText::*)()>(&CanvasText::destroyPtr));
						case 25: return FunctionPtr(new FunctionImpl<CanvasText&(CanvasText::*)()>(&CanvasText::acquirePtr));
						case 26: return FunctionPtr(new FunctionImpl<CanvasText&(CanvasText::*)()>(&CanvasText::unacquirePtr));
						case 27: return FunctionPtr(new FunctionImpl<bool(CanvasText::*)() const>(&CanvasText::isValidPtr));
						case 28: return FunctionPtr(new FunctionImpl<bool(CanvasText::*)() const>(&CanvasText::isOwnerPtr));
						case 29: return FunctionPtr(new FunctionImpl<bool(CanvasText::*)() const>(&CanvasText::isConstPtr));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(CanvasText::*)() const>(&CanvasText::getCountPtr));
						case 31: return FunctionPtr(new FunctionImpl<const void*(CanvasText::*)() const>(&CanvasText::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 1877, 217, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 4011, 1602, 4011 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3637, 3637, 2350, 3636, 2349, 3639, 2352, 3638, 2351, 3640, 2354, 2353, 2353, 3782, 3782, 2671, 3881, 3881, 2825, 1616, 3522, 3522, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4073, 1721, 1585, 4039, 1585, 4039, 1585, 1778, 1778, 764, 4073, 4073, 1856, 4073, 4073, 1274, 4073, 4073, 4073, 240, 4073, 4073, 241, 241, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 10, 10, 11, 12, 12, 12, 13, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1841, 1721, 4039, 4039, 1778, 1856, 2051, 2051, 2051, 1877, 1841, 1675, 1776, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3288, 1650, 3484, 3484, 3992, 3355, 4115, 4116, 4118, 4011, 4011, 1575, 1575, 3299 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasText::constructor_bases[];
	constexpr uint16_t ReflectionCanvasText::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasText::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasText::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasText::function_flags[];
	constexpr uint16_t ReflectionCanvasText::function_names[];
	constexpr uint16_t ReflectionCanvasText::function_types[];
	constexpr uint16_t ReflectionCanvasText::function_bases[];
	constexpr uint16_t ReflectionCanvasText::function_arg_types[];
	constexpr uint16_t ReflectionCanvasText::function_arg_names[];
	constexpr uint16_t ReflectionCanvasText::function_arg_values[];
	constexpr uint16_t ReflectionCanvasText::callback_names[];
	constexpr uint16_t ReflectionCanvasText::callback_types[];
	constexpr uint16_t ReflectionCanvasText::callback_bases[];
	constexpr uint16_t ReflectionCanvasText::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasText::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasText::enum_names[];
	constexpr uint16_t ReflectionCanvasText::enum_bases[];
	constexpr uint16_t ReflectionCanvasText::enum_var_names[];
	static ReflectionCanvasText reflection_canvas_text;
	
	// Tellusim::CanvasMesh
	class ReflectionCanvasMesh : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasMesh::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasMesh, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasMesh, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasMesh, TypeList<Canvas&, CanvasElement::Mode>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasMesh>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const char*)>(&CanvasMesh::setTextureName));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const String&)>(&CanvasMesh::setTextureName));
						case 2: return FunctionPtr(new FunctionImpl<String(CanvasMesh::*)() const>(&CanvasMesh::getTextureName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const GradientStyle&)>(&CanvasMesh::setGradientStyle));
						case 4: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasMesh::*)() const>(&CanvasMesh::getGradientStyleConst));
						case 5: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasMesh::*)() const>(&CanvasMesh::getGradientStyle));
						case 6: return FunctionPtr(new FunctionImpl<GradientStyle&(CanvasMesh::*)()>(&CanvasMesh::getGradientStyle));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)()>(&CanvasMesh::clearVertices));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t)>(&CanvasMesh::setNumVertices));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t)>(&CanvasMesh::reserveVertices));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)() const>(&CanvasMesh::getNumVertices));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const CanvasVertex*, uint32_t)>(&CanvasMesh::setVertices));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const CanvasVertex*, uint32_t)>(&CanvasMesh::addVertices));
						case 13: return FunctionPtr(new FunctionImpl<const CanvasVertex*(CanvasMesh::*)() const>(&CanvasMesh::getVertices));
						case 14: return FunctionPtr(new FunctionImpl<CanvasVertex*(CanvasMesh::*)()>(&CanvasMesh::getVertices));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, const CanvasVertex&)>(&CanvasMesh::setVertex));
						case 16: return FunctionPtr(new FunctionImpl<const CanvasVertex&(CanvasMesh::*)(uint32_t) const>(&CanvasMesh::getVertex));
						case 17: return FunctionPtr(new FunctionImpl<CanvasVertex&(CanvasMesh::*)(uint32_t)>(&CanvasMesh::getVertex));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, const Vector3f&)>(&CanvasMesh::setVertexPosition));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, float32_t, float32_t, float32_t)>(&CanvasMesh::setVertexPosition, {}, {}, {}, 0.0f));
						case 20: return FunctionPtr(new FunctionImpl<Vector3f(CanvasMesh::*)(uint32_t) const>(&CanvasMesh::getVertexPosition));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, const Vector2f&)>(&CanvasMesh::setVertexTexCoord));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, float32_t, float32_t)>(&CanvasMesh::setVertexTexCoord));
						case 23: return FunctionPtr(new FunctionImpl<Vector2f(CanvasMesh::*)(uint32_t) const>(&CanvasMesh::getVertexTexCoord));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, const Color&)>(&CanvasMesh::setVertexColor));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, uint32_t)>(&CanvasMesh::setVertexColor));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(uint32_t) const>(&CanvasMesh::getVertexColor));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(const Vector3f&)>(&CanvasMesh::addVertex));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(const Vector3f&, uint32_t)>(&CanvasMesh::addVertex));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(const Vector3f&, const Vector2f&)>(&CanvasMesh::addVertex));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(const Vector3f&, const Vector2f&, uint32_t)>(&CanvasMesh::addVertex));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(float32_t, float32_t, float32_t, float32_t, float32_t, uint32_t)>(&CanvasMesh::addVertex, {}, {}, {}, {}, {}, 0xffffffffu));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(float32_t, float32_t, float32_t, uint32_t)>(&CanvasMesh::addVertex, {}, {}, {}, 0xffffffffu));
						case 33: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(float32_t, float32_t, uint32_t)>(&CanvasMesh::addVertex, {}, {}, 0xffffffffu));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)()>(&CanvasMesh::clearIndices));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t)>(&CanvasMesh::setNumIndices));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t)>(&CanvasMesh::reserveIndices));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)() const>(&CanvasMesh::getNumIndices));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const uint32_t*, uint32_t)>(&CanvasMesh::setIndices));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const uint32_t*, uint32_t)>(&CanvasMesh::addIndices));
						case 40: return FunctionPtr(new FunctionImpl<const uint32_t*(CanvasMesh::*)() const>(&CanvasMesh::getIndices));
						case 41: return FunctionPtr(new FunctionImpl<uint32_t*(CanvasMesh::*)()>(&CanvasMesh::getIndices));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, uint32_t)>(&CanvasMesh::setIndex));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)(uint32_t) const>(&CanvasMesh::getIndex));
						case 44: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t)>(&CanvasMesh::addIndex));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, uint32_t)>(&CanvasMesh::addIndices));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, uint32_t, uint32_t)>(&CanvasMesh::addIndices));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(uint32_t, uint32_t, uint32_t, uint32_t)>(&CanvasMesh::addIndices));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)(const Rect&)>(&CanvasMesh::setRect));
						case 49: return FunctionPtr(new FunctionImpl<CanvasMesh(CanvasMesh::*)() const>(&CanvasMesh::clonePtr));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)()>(&CanvasMesh::clearPtr));
						case 51: return FunctionPtr(new FunctionVoidImpl<void(CanvasMesh::*)()>(&CanvasMesh::destroyPtr));
						case 52: return FunctionPtr(new FunctionImpl<CanvasMesh&(CanvasMesh::*)()>(&CanvasMesh::acquirePtr));
						case 53: return FunctionPtr(new FunctionImpl<CanvasMesh&(CanvasMesh::*)()>(&CanvasMesh::unacquirePtr));
						case 54: return FunctionPtr(new FunctionImpl<bool(CanvasMesh::*)() const>(&CanvasMesh::isValidPtr));
						case 55: return FunctionPtr(new FunctionImpl<bool(CanvasMesh::*)() const>(&CanvasMesh::isOwnerPtr));
						case 56: return FunctionPtr(new FunctionImpl<bool(CanvasMesh::*)() const>(&CanvasMesh::isConstPtr));
						case 57: return FunctionPtr(new FunctionImpl<uint32_t(CanvasMesh::*)() const>(&CanvasMesh::getCountPtr));
						case 58: return FunctionPtr(new FunctionImpl<const void*(CanvasMesh::*)() const>(&CanvasMesh::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 227 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 3275 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3893, 3893, 2840, 3652, 2398, 2397, 2397, 1643, 3760, 3465, 2624, 3940, 1545, 2923, 2923, 3927, 2904, 2904, 3934, 3934, 2913, 3935, 3935, 2917, 3931, 3931, 2908, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1624, 3756, 3460, 2588, 3670, 1522, 2426, 2426, 3665, 2421, 1520, 1522, 1522, 1522, 3795, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4073, 1779, 1779, 803, 4073, 4073, 4073, 4039, 4073, 4073, 1720, 245, 4073, 1719, 244, 4073, 4073, 1420, 4073, 4073, 1418, 4073, 4073, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4073, 4073, 4073, 4039, 4073, 4073, 1882, 4041, 4073, 4039, 4073, 4073, 4073, 4073, 4073, 232, 4073, 4073, 233, 233, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 2, 2, 3, 3, 3, 3, 3, 4, 5, 5, 7, 9, 9, 9, 11, 12, 13, 15, 19, 20, 22, 25, 26, 28, 30, 31, 32, 34, 36, 39, 45, 49, 52, 52, 53, 54, 54, 56, 58, 58, 58, 60, 61, 62, 64, 67, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1841, 1779, 4039, 4039, 1720, 4039, 1720, 4039, 4039, 1719, 4039, 4039, 4039, 1856, 4039, 2051, 2051, 2051, 4039, 4039, 1854, 4039, 2051, 2051, 4039, 4039, 1721, 4039, 4039, 4039, 1856, 1856, 4039, 1856, 1854, 1856, 1854, 4039, 2051, 2051, 2051, 2051, 2051, 4039, 2051, 2051, 2051, 4039, 2051, 2051, 4039, 4039, 4039, 1882, 4039, 1882, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1830 };
			static constexpr uint16_t function_arg_names[] = { 3288, 3288, 3992, 3315, 3315, 4068, 3315, 4068, 3315, 2993, 4064, 2993, 2993, 2993, 3355, 2993, 4115, 4116, 4118, 2993, 2993, 4010, 2993, 3476, 4000, 2993, 2993, 1650, 2993, 1650, 2993, 3355, 3355, 1650, 3355, 4010, 3355, 4010, 1650, 4115, 4116, 4118, 3476, 4000, 1650, 4115, 4116, 4118, 1650, 4115, 4116, 1650, 3305, 3305, 2995, 3305, 2995, 3305, 2993, 4056, 2993, 2985, 2985, 2986, 2985, 2986, 2987, 2985, 2986, 2987, 2988, 3401 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasMesh::constructor_bases[];
	constexpr uint16_t ReflectionCanvasMesh::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasMesh::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasMesh::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasMesh::function_flags[];
	constexpr uint16_t ReflectionCanvasMesh::function_names[];
	constexpr uint16_t ReflectionCanvasMesh::function_types[];
	constexpr uint16_t ReflectionCanvasMesh::function_bases[];
	constexpr uint16_t ReflectionCanvasMesh::function_arg_types[];
	constexpr uint16_t ReflectionCanvasMesh::function_arg_names[];
	constexpr uint16_t ReflectionCanvasMesh::function_arg_values[];
	constexpr uint16_t ReflectionCanvasMesh::callback_names[];
	constexpr uint16_t ReflectionCanvasMesh::callback_types[];
	constexpr uint16_t ReflectionCanvasMesh::callback_bases[];
	constexpr uint16_t ReflectionCanvasMesh::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasMesh::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasMesh::enum_names[];
	constexpr uint16_t ReflectionCanvasMesh::enum_bases[];
	constexpr uint16_t ReflectionCanvasMesh::enum_var_names[];
	static ReflectionCanvasMesh reflection_canvas_mesh;
	
	// Tellusim::CanvasRect
	class ReflectionCanvasRect : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasRect::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasRect, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasRect, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasRect, TypeList<Canvas&, float32_t>>());
						case 3: return ConstructorPtr(new ConstructorImpl<CanvasRect, TypeList<Canvas&, float32_t, const Vector2f&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasRect>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(float32_t)>(&CanvasRect::setRadius));
						case 1: return FunctionPtr(new FunctionImpl<float32_t(CanvasRect::*)() const>(&CanvasRect::getRadius));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const char*)>(&CanvasRect::setTextureName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const String&)>(&CanvasRect::setTextureName));
						case 4: return FunctionPtr(new FunctionImpl<String(CanvasRect::*)() const>(&CanvasRect::getTextureName));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const Color&)>(&CanvasRect::setStrokeColor));
						case 6: return FunctionPtr(new FunctionImpl<const Color&(CanvasRect::*)()>(&CanvasRect::getStrokeColor));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const StrokeStyle&)>(&CanvasRect::setStrokeStyle));
						case 8: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasRect::*)() const>(&CanvasRect::getStrokeStyleConst));
						case 9: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasRect::*)() const>(&CanvasRect::getStrokeStyle));
						case 10: return FunctionPtr(new FunctionImpl<StrokeStyle&(CanvasRect::*)()>(&CanvasRect::getStrokeStyle));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const GradientStyle&)>(&CanvasRect::setGradientStyle));
						case 12: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasRect::*)() const>(&CanvasRect::getGradientStyleConst));
						case 13: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasRect::*)() const>(&CanvasRect::getGradientStyle));
						case 14: return FunctionPtr(new FunctionImpl<GradientStyle&(CanvasRect::*)()>(&CanvasRect::getGradientStyle));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const Vector2f&)>(&CanvasRect::setSize));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(float32_t, float32_t)>(&CanvasRect::setSize));
						case 17: return FunctionPtr(new FunctionImpl<const Vector2f&(CanvasRect::*)() const>(&CanvasRect::getSize));
						case 18: return FunctionPtr(new FunctionImpl<float32_t(CanvasRect::*)() const>(&CanvasRect::getWidth));
						case 19: return FunctionPtr(new FunctionImpl<float32_t(CanvasRect::*)() const>(&CanvasRect::getHeight));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const Vector3f&)>(&CanvasRect::setPosition));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(float32_t, float32_t, float32_t)>(&CanvasRect::setPosition, {}, {}, 0.0f));
						case 22: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasRect::*)() const>(&CanvasRect::getPosition));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(const Rect&)>(&CanvasRect::setTexCoord));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)(float32_t, float32_t, float32_t, float32_t)>(&CanvasRect::setTexCoord));
						case 25: return FunctionPtr(new FunctionImpl<const Rect&(CanvasRect::*)() const>(&CanvasRect::getTexCoord));
						case 26: return FunctionPtr(new FunctionImpl<CanvasRect(CanvasRect::*)() const>(&CanvasRect::clonePtr));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)()>(&CanvasRect::clearPtr));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(CanvasRect::*)()>(&CanvasRect::destroyPtr));
						case 29: return FunctionPtr(new FunctionImpl<CanvasRect&(CanvasRect::*)()>(&CanvasRect::acquirePtr));
						case 30: return FunctionPtr(new FunctionImpl<CanvasRect&(CanvasRect::*)()>(&CanvasRect::unacquirePtr));
						case 31: return FunctionPtr(new FunctionImpl<bool(CanvasRect::*)() const>(&CanvasRect::isValidPtr));
						case 32: return FunctionPtr(new FunctionImpl<bool(CanvasRect::*)() const>(&CanvasRect::isOwnerPtr));
						case 33: return FunctionPtr(new FunctionImpl<bool(CanvasRect::*)() const>(&CanvasRect::isConstPtr));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(CanvasRect::*)() const>(&CanvasRect::getCountPtr));
						case 35: return FunctionPtr(new FunctionImpl<const void*(CanvasRect::*)() const>(&CanvasRect::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 6 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 2051, 217, 2051, 1854 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 3373, 1602, 3373, 3960 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3792, 2693, 3893, 3893, 2840, 3858, 2797, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 3830, 3830, 2760, 2927, 2410, 3782, 3782, 2671, 3873, 3873, 2818, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 2051, 4073, 4073, 1274, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 4073, 4073, 1854, 2051, 2051, 4073, 4073, 1856, 4073, 4073, 1830, 234, 4073, 4073, 235, 235, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 9, 9, 9, 9, 10, 13, 13, 14, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 };
			static constexpr uint16_t function_arg_types[] = { 2051, 1877, 1841, 1721, 1843, 1779, 1854, 2051, 2051, 1856, 2051, 2051, 2051, 1830, 2051, 2051, 2051, 2051 };
			static constexpr uint16_t function_arg_names[] = { 3373, 3288, 3288, 1650, 3992, 3992, 3960, 4089, 2980, 3355, 4115, 4116, 4118, 4010, 3239, 3470, 1588, 4024 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasRect::constructor_bases[];
	constexpr uint16_t ReflectionCanvasRect::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasRect::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasRect::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasRect::function_flags[];
	constexpr uint16_t ReflectionCanvasRect::function_names[];
	constexpr uint16_t ReflectionCanvasRect::function_types[];
	constexpr uint16_t ReflectionCanvasRect::function_bases[];
	constexpr uint16_t ReflectionCanvasRect::function_arg_types[];
	constexpr uint16_t ReflectionCanvasRect::function_arg_names[];
	constexpr uint16_t ReflectionCanvasRect::function_arg_values[];
	constexpr uint16_t ReflectionCanvasRect::callback_names[];
	constexpr uint16_t ReflectionCanvasRect::callback_types[];
	constexpr uint16_t ReflectionCanvasRect::callback_bases[];
	constexpr uint16_t ReflectionCanvasRect::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasRect::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasRect::enum_names[];
	constexpr uint16_t ReflectionCanvasRect::enum_bases[];
	constexpr uint16_t ReflectionCanvasRect::enum_var_names[];
	static ReflectionCanvasRect reflection_canvas_rect;
	
	// Tellusim::CanvasTriangle
	class ReflectionCanvasTriangle : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasTriangle::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasTriangle, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasTriangle, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasTriangle, TypeList<Canvas&, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasTriangle>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(float32_t)>(&CanvasTriangle::setRadius));
						case 1: return FunctionPtr(new FunctionImpl<float32_t(CanvasTriangle::*)() const>(&CanvasTriangle::getRadius));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const Color&)>(&CanvasTriangle::setStrokeColor));
						case 3: return FunctionPtr(new FunctionImpl<const Color&(CanvasTriangle::*)() const>(&CanvasTriangle::getStrokeColor));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const StrokeStyle&)>(&CanvasTriangle::setStrokeStyle));
						case 5: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasTriangle::*)() const>(&CanvasTriangle::getStrokeStyleConst));
						case 6: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasTriangle::*)() const>(&CanvasTriangle::getStrokeStyle));
						case 7: return FunctionPtr(new FunctionImpl<StrokeStyle&(CanvasTriangle::*)()>(&CanvasTriangle::getStrokeStyle));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const GradientStyle&)>(&CanvasTriangle::setGradientStyle));
						case 9: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasTriangle::*)() const>(&CanvasTriangle::getGradientStyleConst));
						case 10: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasTriangle::*)() const>(&CanvasTriangle::getGradientStyle));
						case 11: return FunctionPtr(new FunctionImpl<GradientStyle&(CanvasTriangle::*)()>(&CanvasTriangle::getGradientStyle));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const Vector3f&)>(&CanvasTriangle::setPosition0));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const Vector3f&)>(&CanvasTriangle::setPosition1));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const Vector3f&)>(&CanvasTriangle::setPosition2));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(float32_t, float32_t, float32_t)>(&CanvasTriangle::setPosition0, {}, {}, 0.0f));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(float32_t, float32_t, float32_t)>(&CanvasTriangle::setPosition1, {}, {}, 0.0f));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(float32_t, float32_t, float32_t)>(&CanvasTriangle::setPosition2, {}, {}, 0.0f));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)(const Vector3f&, const Vector3f&, const Vector3f&)>(&CanvasTriangle::setPosition));
						case 19: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasTriangle::*)() const>(&CanvasTriangle::getPosition0));
						case 20: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasTriangle::*)() const>(&CanvasTriangle::getPosition1));
						case 21: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasTriangle::*)() const>(&CanvasTriangle::getPosition2));
						case 22: return FunctionPtr(new FunctionImpl<CanvasTriangle(CanvasTriangle::*)() const>(&CanvasTriangle::clonePtr));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)()>(&CanvasTriangle::clearPtr));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasTriangle::*)()>(&CanvasTriangle::destroyPtr));
						case 25: return FunctionPtr(new FunctionImpl<CanvasTriangle&(CanvasTriangle::*)()>(&CanvasTriangle::acquirePtr));
						case 26: return FunctionPtr(new FunctionImpl<CanvasTriangle&(CanvasTriangle::*)()>(&CanvasTriangle::unacquirePtr));
						case 27: return FunctionPtr(new FunctionImpl<bool(CanvasTriangle::*)() const>(&CanvasTriangle::isValidPtr));
						case 28: return FunctionPtr(new FunctionImpl<bool(CanvasTriangle::*)() const>(&CanvasTriangle::isOwnerPtr));
						case 29: return FunctionPtr(new FunctionImpl<bool(CanvasTriangle::*)() const>(&CanvasTriangle::isConstPtr));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(CanvasTriangle::*)() const>(&CanvasTriangle::getCountPtr));
						case 31: return FunctionPtr(new FunctionImpl<const void*(CanvasTriangle::*)() const>(&CanvasTriangle::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 3373 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3792, 2693, 3858, 2797, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 3783, 3784, 3785, 3783, 3784, 3785, 3782, 2672, 2673, 2674, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 2051, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1856, 1856, 1856, 242, 4073, 4073, 243, 243, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 7, 10, 13, 16, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19 };
			static constexpr uint16_t function_arg_types[] = { 2051, 1721, 1843, 1779, 1856, 1856, 1856, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 1856, 1856, 1856 };
			static constexpr uint16_t function_arg_names[] = { 3373, 1650, 3992, 3992, 3355, 3355, 3355, 4115, 4116, 4118, 4115, 4116, 4118, 4115, 4116, 4118, 3356, 3357, 3358 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasTriangle::constructor_bases[];
	constexpr uint16_t ReflectionCanvasTriangle::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasTriangle::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasTriangle::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasTriangle::function_flags[];
	constexpr uint16_t ReflectionCanvasTriangle::function_names[];
	constexpr uint16_t ReflectionCanvasTriangle::function_types[];
	constexpr uint16_t ReflectionCanvasTriangle::function_bases[];
	constexpr uint16_t ReflectionCanvasTriangle::function_arg_types[];
	constexpr uint16_t ReflectionCanvasTriangle::function_arg_names[];
	constexpr uint16_t ReflectionCanvasTriangle::function_arg_values[];
	constexpr uint16_t ReflectionCanvasTriangle::callback_names[];
	constexpr uint16_t ReflectionCanvasTriangle::callback_types[];
	constexpr uint16_t ReflectionCanvasTriangle::callback_bases[];
	constexpr uint16_t ReflectionCanvasTriangle::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasTriangle::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasTriangle::enum_names[];
	constexpr uint16_t ReflectionCanvasTriangle::enum_bases[];
	constexpr uint16_t ReflectionCanvasTriangle::enum_var_names[];
	static ReflectionCanvasTriangle reflection_canvas_triangle;
	
	// Tellusim::CanvasEllipse
	class ReflectionCanvasEllipse : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasEllipse::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasEllipse, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasEllipse, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasEllipse, TypeList<Canvas&, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasEllipse>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(float32_t)>(&CanvasEllipse::setRadius));
						case 1: return FunctionPtr(new FunctionImpl<float32_t(CanvasEllipse::*)() const>(&CanvasEllipse::getRadius));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const char*)>(&CanvasEllipse::setTextureName));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const String&)>(&CanvasEllipse::setTextureName));
						case 4: return FunctionPtr(new FunctionImpl<String(CanvasEllipse::*)() const>(&CanvasEllipse::getTextureName));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const Color&)>(&CanvasEllipse::setStrokeColor));
						case 6: return FunctionPtr(new FunctionImpl<const Color&(CanvasEllipse::*)() const>(&CanvasEllipse::getStrokeColor));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const StrokeStyle&)>(&CanvasEllipse::setStrokeStyle));
						case 8: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasEllipse::*)() const>(&CanvasEllipse::getStrokeStyleConst));
						case 9: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasEllipse::*)() const>(&CanvasEllipse::getStrokeStyle));
						case 10: return FunctionPtr(new FunctionImpl<StrokeStyle&(CanvasEllipse::*)()>(&CanvasEllipse::getStrokeStyle));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const GradientStyle&)>(&CanvasEllipse::setGradientStyle));
						case 12: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasEllipse::*)() const>(&CanvasEllipse::getGradientStyleConst));
						case 13: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasEllipse::*)() const>(&CanvasEllipse::getGradientStyle));
						case 14: return FunctionPtr(new FunctionImpl<GradientStyle&(CanvasEllipse::*)()>(&CanvasEllipse::getGradientStyle));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const Vector3f&)>(&CanvasEllipse::setPosition));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const Vector3f&)>(&CanvasEllipse::setPosition0));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const Vector3f&)>(&CanvasEllipse::setPosition1));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(float32_t, float32_t, float32_t)>(&CanvasEllipse::setPosition, {}, {}, 0.0f));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(float32_t, float32_t, float32_t)>(&CanvasEllipse::setPosition0, {}, {}, 0.0f));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(float32_t, float32_t, float32_t)>(&CanvasEllipse::setPosition1, {}, {}, 0.0f));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const Vector3f&, const Vector3f&)>(&CanvasEllipse::setPosition));
						case 22: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasEllipse::*)() const>(&CanvasEllipse::getPosition0));
						case 23: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasEllipse::*)() const>(&CanvasEllipse::getPosition1));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(const Rect&)>(&CanvasEllipse::setTexCoord));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)(float32_t, float32_t, float32_t, float32_t)>(&CanvasEllipse::setTexCoord));
						case 26: return FunctionPtr(new FunctionImpl<const Rect&(CanvasEllipse::*)() const>(&CanvasEllipse::getTexCoord));
						case 27: return FunctionPtr(new FunctionImpl<CanvasEllipse(CanvasEllipse::*)() const>(&CanvasEllipse::clonePtr));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)()>(&CanvasEllipse::clearPtr));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(CanvasEllipse::*)()>(&CanvasEllipse::destroyPtr));
						case 30: return FunctionPtr(new FunctionImpl<CanvasEllipse&(CanvasEllipse::*)()>(&CanvasEllipse::acquirePtr));
						case 31: return FunctionPtr(new FunctionImpl<CanvasEllipse&(CanvasEllipse::*)()>(&CanvasEllipse::unacquirePtr));
						case 32: return FunctionPtr(new FunctionImpl<bool(CanvasEllipse::*)() const>(&CanvasEllipse::isValidPtr));
						case 33: return FunctionPtr(new FunctionImpl<bool(CanvasEllipse::*)() const>(&CanvasEllipse::isOwnerPtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(CanvasEllipse::*)() const>(&CanvasEllipse::isConstPtr));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(CanvasEllipse::*)() const>(&CanvasEllipse::getCountPtr));
						case 36: return FunctionPtr(new FunctionImpl<const void*(CanvasEllipse::*)() const>(&CanvasEllipse::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 3373 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3792, 2693, 3893, 3893, 2840, 3858, 2797, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 3782, 3783, 3784, 3782, 3783, 3784, 3782, 2672, 2673, 3873, 3873, 2818, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 2051, 4073, 4073, 1274, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1856, 1856, 4073, 4073, 1830, 230, 4073, 4073, 231, 231, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 8, 9, 12, 15, 18, 20, 20, 20, 21, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25 };
			static constexpr uint16_t function_arg_types[] = { 2051, 1877, 1841, 1721, 1843, 1779, 1856, 1856, 1856, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 1856, 1856, 1830, 2051, 2051, 2051, 2051 };
			static constexpr uint16_t function_arg_names[] = { 3373, 3288, 3288, 1650, 3992, 3992, 3355, 3355, 3355, 4115, 4116, 4118, 4115, 4116, 4118, 4115, 4116, 4118, 3356, 3357, 4010, 3239, 3470, 1588, 4024 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasEllipse::constructor_bases[];
	constexpr uint16_t ReflectionCanvasEllipse::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasEllipse::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasEllipse::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasEllipse::function_flags[];
	constexpr uint16_t ReflectionCanvasEllipse::function_names[];
	constexpr uint16_t ReflectionCanvasEllipse::function_types[];
	constexpr uint16_t ReflectionCanvasEllipse::function_bases[];
	constexpr uint16_t ReflectionCanvasEllipse::function_arg_types[];
	constexpr uint16_t ReflectionCanvasEllipse::function_arg_names[];
	constexpr uint16_t ReflectionCanvasEllipse::function_arg_values[];
	constexpr uint16_t ReflectionCanvasEllipse::callback_names[];
	constexpr uint16_t ReflectionCanvasEllipse::callback_types[];
	constexpr uint16_t ReflectionCanvasEllipse::callback_bases[];
	constexpr uint16_t ReflectionCanvasEllipse::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasEllipse::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasEllipse::enum_names[];
	constexpr uint16_t ReflectionCanvasEllipse::enum_bases[];
	constexpr uint16_t ReflectionCanvasEllipse::enum_var_names[];
	static ReflectionCanvasEllipse reflection_canvas_ellipse;
	
	// Tellusim::CanvasShape
	class ReflectionCanvasShape : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasShape::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasShape, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasShape, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasShape, TypeList<Canvas&, bool>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasShape>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(bool)>(&CanvasShape::setCubic));
						case 1: return FunctionPtr(new FunctionImpl<bool(CanvasShape::*)() const>(&CanvasShape::isCubic));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(float32_t)>(&CanvasShape::setThreshold));
						case 3: return FunctionPtr(new FunctionImpl<float32_t(CanvasShape::*)() const>(&CanvasShape::getThreshold));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(const Color&)>(&CanvasShape::setStrokeColor));
						case 5: return FunctionPtr(new FunctionImpl<const Color&(CanvasShape::*)() const>(&CanvasShape::getStrokeColor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(const StrokeStyle&)>(&CanvasShape::setStrokeStyle));
						case 7: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasShape::*)() const>(&CanvasShape::getStrokeStyleConst));
						case 8: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasShape::*)() const>(&CanvasShape::getStrokeStyle));
						case 9: return FunctionPtr(new FunctionImpl<StrokeStyle&(CanvasShape::*)()>(&CanvasShape::getStrokeStyle));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(const GradientStyle&)>(&CanvasShape::setGradientStyle));
						case 11: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasShape::*)() const>(&CanvasShape::getGradientStyleConst));
						case 12: return FunctionPtr(new FunctionImpl<const GradientStyle&(CanvasShape::*)() const>(&CanvasShape::getGradientStyle));
						case 13: return FunctionPtr(new FunctionImpl<GradientStyle&(CanvasShape::*)()>(&CanvasShape::getGradientStyle));
						case 14: return FunctionPtr(new FunctionImpl<bool(CanvasShape::*)(const char*, float32_t)>(&CanvasShape::createSVG, {}, 1.0f));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)()>(&CanvasShape::clearPositions));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(uint32_t)>(&CanvasShape::setNumPositions));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(uint32_t)>(&CanvasShape::reservePositions));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(CanvasShape::*)() const>(&CanvasShape::getNumPositions));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(const Vector3f*, uint32_t)>(&CanvasShape::setPositions));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(const Vector3f*, uint32_t)>(&CanvasShape::addPositions));
						case 21: return FunctionPtr(new FunctionImpl<const Vector3f*(CanvasShape::*)() const>(&CanvasShape::getPositions));
						case 22: return FunctionPtr(new FunctionImpl<Vector3f*(CanvasShape::*)()>(&CanvasShape::getPositions));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(uint32_t, const Vector3f&)>(&CanvasShape::setPosition));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(uint32_t, float32_t, float32_t, float32_t)>(&CanvasShape::setPosition, {}, {}, {}, 0.0f));
						case 25: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasShape::*)(uint32_t) const>(&CanvasShape::getPosition));
						case 26: return FunctionPtr(new FunctionImpl<Vector3f&(CanvasShape::*)(uint32_t)>(&CanvasShape::getPosition));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(CanvasShape::*)(const Vector2f&)>(&CanvasShape::addPosition));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(CanvasShape::*)(const Vector3f&)>(&CanvasShape::addPosition));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(CanvasShape::*)(float32_t, float32_t, float32_t)>(&CanvasShape::addPosition, {}, {}, 0.0f));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(const Rect&)>(&CanvasShape::setTexCoord));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)(float32_t, float32_t, float32_t, float32_t)>(&CanvasShape::setTexCoord));
						case 32: return FunctionPtr(new FunctionImpl<const Rect&(CanvasShape::*)() const>(&CanvasShape::getTexCoord));
						case 33: return FunctionPtr(new FunctionImpl<CanvasShape(CanvasShape::*)() const>(&CanvasShape::clonePtr));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)()>(&CanvasShape::clearPtr));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(CanvasShape::*)()>(&CanvasShape::destroyPtr));
						case 36: return FunctionPtr(new FunctionImpl<CanvasShape&(CanvasShape::*)()>(&CanvasShape::acquirePtr));
						case 37: return FunctionPtr(new FunctionImpl<CanvasShape&(CanvasShape::*)()>(&CanvasShape::unacquirePtr));
						case 38: return FunctionPtr(new FunctionImpl<bool(CanvasShape::*)() const>(&CanvasShape::isValidPtr));
						case 39: return FunctionPtr(new FunctionImpl<bool(CanvasShape::*)() const>(&CanvasShape::isOwnerPtr));
						case 40: return FunctionPtr(new FunctionImpl<bool(CanvasShape::*)() const>(&CanvasShape::isConstPtr));
						case 41: return FunctionPtr(new FunctionImpl<uint32_t(CanvasShape::*)() const>(&CanvasShape::getCountPtr));
						case 42: return FunctionPtr(new FunctionImpl<const void*(CanvasShape::*)() const>(&CanvasShape::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 1945 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3584, 3059, 3901, 2851, 3858, 2797, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 1930, 1636, 3758, 3464, 2603, 3786, 1532, 2677, 2677, 3782, 3782, 2671, 2671, 1531, 1531, 1531, 3873, 3873, 2818, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 2051, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 1585, 4073, 4073, 4073, 4039, 4073, 4073, 1857, 1422, 4073, 4073, 1856, 1421, 4039, 4039, 4039, 4073, 4073, 1830, 236, 4073, 4073, 237, 237, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 7, 7, 8, 9, 9, 11, 13, 13, 13, 15, 19, 20, 21, 22, 23, 26, 27, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31 };
			static constexpr uint16_t function_arg_types[] = { 1585, 2051, 1721, 1843, 1779, 1877, 2051, 4039, 4039, 1857, 4039, 1857, 4039, 4039, 1856, 4039, 2051, 2051, 2051, 4039, 4039, 1854, 1856, 2051, 2051, 2051, 1830, 2051, 2051, 2051, 2051 };
			static constexpr uint16_t function_arg_names[] = { 1945, 4016, 1650, 3992, 3992, 3975, 3484, 3310, 3310, 3360, 3310, 3360, 3310, 2993, 3355, 2993, 4115, 4116, 4118, 2993, 2993, 3355, 3355, 4115, 4116, 4118, 4010, 3239, 3470, 1588, 4024 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasShape::constructor_bases[];
	constexpr uint16_t ReflectionCanvasShape::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasShape::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasShape::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasShape::function_flags[];
	constexpr uint16_t ReflectionCanvasShape::function_names[];
	constexpr uint16_t ReflectionCanvasShape::function_types[];
	constexpr uint16_t ReflectionCanvasShape::function_bases[];
	constexpr uint16_t ReflectionCanvasShape::function_arg_types[];
	constexpr uint16_t ReflectionCanvasShape::function_arg_names[];
	constexpr uint16_t ReflectionCanvasShape::function_arg_values[];
	constexpr uint16_t ReflectionCanvasShape::callback_names[];
	constexpr uint16_t ReflectionCanvasShape::callback_types[];
	constexpr uint16_t ReflectionCanvasShape::callback_bases[];
	constexpr uint16_t ReflectionCanvasShape::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasShape::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasShape::enum_names[];
	constexpr uint16_t ReflectionCanvasShape::enum_bases[];
	constexpr uint16_t ReflectionCanvasShape::enum_var_names[];
	static ReflectionCanvasShape reflection_canvas_shape;
	
	// Tellusim::CanvasStrip
	class ReflectionCanvasStrip : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CanvasStrip::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_canvas_element;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CanvasStrip, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<CanvasStrip, TypeList<Canvas&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<CanvasStrip, TypeList<Canvas&, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CanvasStrip>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(float32_t)>(&CanvasStrip::setWidth));
						case 1: return FunctionPtr(new FunctionImpl<float32_t(CanvasStrip::*)() const>(&CanvasStrip::getWidth));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(float32_t)>(&CanvasStrip::setOffset));
						case 3: return FunctionPtr(new FunctionImpl<float32_t(CanvasStrip::*)() const>(&CanvasStrip::getOffset));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Color&)>(&CanvasStrip::setStrokeColor));
						case 5: return FunctionPtr(new FunctionImpl<const Color&(CanvasStrip::*)() const>(&CanvasStrip::getStrokeColor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const StrokeStyle&)>(&CanvasStrip::setStrokeStyle));
						case 7: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasStrip::*)() const>(&CanvasStrip::getStrokeStyleConst));
						case 8: return FunctionPtr(new FunctionImpl<const StrokeStyle&(CanvasStrip::*)() const>(&CanvasStrip::getStrokeStyle));
						case 9: return FunctionPtr(new FunctionImpl<StrokeStyle&(CanvasStrip::*)()>(&CanvasStrip::getStrokeStyle));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Vector2f&, const Vector2f&, const Vector2f&, float32_t)>(&CanvasStrip::createQuadratic, {}, {}, {}, 1.0f));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Vector3f&, const Vector3f&, const Vector3f&, float32_t)>(&CanvasStrip::createQuadratic, {}, {}, {}, 1.0f));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Vector2f&, const Vector2f&, const Vector2f&, const Vector2f&, float32_t)>(&CanvasStrip::createCubic, {}, {}, {}, {}, 1.0f));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Vector3f&, const Vector3f&, const Vector3f&, const Vector3f&, float32_t)>(&CanvasStrip::createCubic, {}, {}, {}, {}, 1.0f));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)()>(&CanvasStrip::clearPositions));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(uint32_t)>(&CanvasStrip::setNumPositions));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(uint32_t)>(&CanvasStrip::reservePositions));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(CanvasStrip::*)() const>(&CanvasStrip::getNumPositions));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Vector3f*, uint32_t)>(&CanvasStrip::setPositions));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(const Vector3f*, uint32_t)>(&CanvasStrip::addPositions));
						case 20: return FunctionPtr(new FunctionImpl<const Vector3f*(CanvasStrip::*)() const>(&CanvasStrip::getPositions));
						case 21: return FunctionPtr(new FunctionImpl<Vector3f*(CanvasStrip::*)()>(&CanvasStrip::getPositions));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(uint32_t, const Vector3f&)>(&CanvasStrip::setPosition));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)(uint32_t, float32_t, float32_t, float32_t)>(&CanvasStrip::setPosition, {}, {}, {}, 0.0f));
						case 24: return FunctionPtr(new FunctionImpl<const Vector3f&(CanvasStrip::*)(uint32_t) const>(&CanvasStrip::getPosition));
						case 25: return FunctionPtr(new FunctionImpl<Vector3f&(CanvasStrip::*)(uint32_t)>(&CanvasStrip::getPosition));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(CanvasStrip::*)(const Vector2f&)>(&CanvasStrip::addPosition));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(CanvasStrip::*)(const Vector3f&)>(&CanvasStrip::addPosition));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(CanvasStrip::*)(float32_t, float32_t, float32_t)>(&CanvasStrip::addPosition, {}, {}, 0.0f));
						case 29: return FunctionPtr(new FunctionImpl<CanvasStrip(CanvasStrip::*)() const>(&CanvasStrip::clonePtr));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)()>(&CanvasStrip::clearPtr));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(CanvasStrip::*)()>(&CanvasStrip::destroyPtr));
						case 32: return FunctionPtr(new FunctionImpl<CanvasStrip&(CanvasStrip::*)()>(&CanvasStrip::acquirePtr));
						case 33: return FunctionPtr(new FunctionImpl<CanvasStrip&(CanvasStrip::*)()>(&CanvasStrip::unacquirePtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(CanvasStrip::*)() const>(&CanvasStrip::isValidPtr));
						case 35: return FunctionPtr(new FunctionImpl<bool(CanvasStrip::*)() const>(&CanvasStrip::isOwnerPtr));
						case 36: return FunctionPtr(new FunctionImpl<bool(CanvasStrip::*)() const>(&CanvasStrip::isConstPtr));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(CanvasStrip::*)() const>(&CanvasStrip::getCountPtr));
						case 38: return FunctionPtr(new FunctionImpl<const void*(CanvasStrip::*)() const>(&CanvasStrip::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 217, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1602, 4089 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3946, 2927, 3762, 2628, 3858, 2797, 3859, 2799, 2798, 2798, 1927, 1927, 1915, 1915, 1636, 3758, 3464, 2603, 3786, 1532, 2677, 2677, 3782, 3782, 2671, 2671, 1531, 1531, 1531, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 2051, 4073, 2051, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 4073, 4073, 1857, 1422, 4073, 4073, 1856, 1421, 4039, 4039, 4039, 238, 4073, 4073, 239, 239, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 8, 12, 17, 22, 22, 23, 24, 24, 26, 28, 28, 28, 30, 34, 35, 36, 37, 38, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41 };
			static constexpr uint16_t function_arg_types[] = { 2051, 2051, 1721, 1843, 1854, 1854, 1854, 2051, 1856, 1856, 1856, 2051, 1854, 1854, 1854, 1854, 2051, 1856, 1856, 1856, 1856, 2051, 4039, 4039, 1857, 4039, 1857, 4039, 4039, 1856, 4039, 2051, 2051, 2051, 4039, 4039, 1854, 1856, 2051, 2051, 2051 };
			static constexpr uint16_t function_arg_names[] = { 4089, 3317, 1650, 3992, 3342, 3343, 3344, 4016, 3342, 3343, 3344, 4016, 3342, 3343, 3344, 3345, 4016, 3342, 3343, 3344, 3345, 4016, 3310, 3310, 3360, 3310, 3360, 3310, 2993, 3355, 2993, 4115, 4116, 4118, 2993, 2993, 3355, 3355, 4115, 4116, 4118 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvasStrip::constructor_bases[];
	constexpr uint16_t ReflectionCanvasStrip::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvasStrip::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvasStrip::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvasStrip::function_flags[];
	constexpr uint16_t ReflectionCanvasStrip::function_names[];
	constexpr uint16_t ReflectionCanvasStrip::function_types[];
	constexpr uint16_t ReflectionCanvasStrip::function_bases[];
	constexpr uint16_t ReflectionCanvasStrip::function_arg_types[];
	constexpr uint16_t ReflectionCanvasStrip::function_arg_names[];
	constexpr uint16_t ReflectionCanvasStrip::function_arg_values[];
	constexpr uint16_t ReflectionCanvasStrip::callback_names[];
	constexpr uint16_t ReflectionCanvasStrip::callback_types[];
	constexpr uint16_t ReflectionCanvasStrip::callback_bases[];
	constexpr uint16_t ReflectionCanvasStrip::callback_arg_types[];
	constexpr uint16_t ReflectionCanvasStrip::callback_arg_names[];
	constexpr uint16_t ReflectionCanvasStrip::enum_names[];
	constexpr uint16_t ReflectionCanvasStrip::enum_bases[];
	constexpr uint16_t ReflectionCanvasStrip::enum_var_names[];
	static ReflectionCanvasStrip reflection_canvas_strip;
	
	// Tellusim::Canvas
	class ReflectionCanvas : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Canvas::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Canvas, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Canvas, TypeList<Canvas*>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Canvas>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(Canvas::*)() const>(&Canvas::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)(const Target&, uint32_t) const>(&Canvas::getScale, Target::null, 100));
						case 3: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const Device&, Format, Format, uint32_t, uint32_t)>(&Canvas::create, Device::null, (Format)0, (Format)0, 1, 0));
						case 4: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const Device&, const Target&, uint32_t)>(&Canvas::create, Device::null, Target::null, 0));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(uint32_t)>(&Canvas::setPipelineHash));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getPipelineHash));
						case 7: return FunctionPtr(new FunctionImpl<Format(Canvas::*)() const>(&Canvas::getColorFormat));
						case 8: return FunctionPtr(new FunctionImpl<Format(Canvas::*)() const>(&Canvas::getDepthFormat));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getMultisample));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(int32_t)>(&Canvas::setOrder));
						case 11: return FunctionPtr(new FunctionImpl<int32_t(Canvas::*)() const>(&Canvas::getOrder));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(bool)>(&Canvas::setEnabled));
						case 13: return FunctionPtr(new FunctionImpl<bool(Canvas::*)() const>(&Canvas::isEnabled));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Viewport&)>(&Canvas::setViewport));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(uint32_t, uint32_t)>(&Canvas::setViewport));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(float32_t, float32_t)>(&Canvas::setViewport));
						case 17: return FunctionPtr(new FunctionImpl<const Viewport&(Canvas::*)() const>(&Canvas::getViewport));
						case 18: return FunctionPtr(new FunctionImpl<float32_t(Canvas::*)() const>(&Canvas::getWidth));
						case 19: return FunctionPtr(new FunctionImpl<float32_t(Canvas::*)() const>(&Canvas::getHeight));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::clearColor));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Color&)>(&Canvas::setColor));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(float32_t, float32_t, float32_t, float32_t)>(&Canvas::setColor));
						case 23: return FunctionPtr(new FunctionImpl<const Color&(Canvas::*)() const>(&Canvas::getColor));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::clearScissor));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Rect&)>(&Canvas::setScissor));
						case 26: return FunctionPtr(new FunctionImpl<const Rect&(Canvas::*)() const>(&Canvas::getScissor));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::clearTransform));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Matrix4x4f&)>(&Canvas::setTransform));
						case 29: return FunctionPtr(new FunctionImpl<const Matrix4x4f&(Canvas::*)() const>(&Canvas::getTransform));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)(Canvas&)>(&Canvas::setParent));
						case 31: return FunctionPtr(new FunctionImpl<const Canvas(Canvas::*)() const>(&Canvas::getParent));
						case 32: return FunctionPtr(new FunctionImpl<Canvas(Canvas::*)()>(&Canvas::getParent));
						case 33: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)(Canvas&)>(&Canvas::addChild));
						case 34: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(Canvas&)>(&Canvas::removeChild));
						case 35: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(Canvas&)>(&Canvas::raiseChild));
						case 36: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(Canvas&)>(&Canvas::lowerChild));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::releaseChildren));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)(const Canvas&) const>(&Canvas::findChild));
						case 39: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const Canvas&) const>(&Canvas::isChild));
						case 40: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getNumChildren));
						case 41: return FunctionPtr(new FunctionImpl<const Array<Canvas>(Canvas::*)() const>(&Canvas::getChildren));
						case 42: return FunctionPtr(new FunctionImpl<Array<Canvas>(Canvas::*)()>(&Canvas::getChildren));
						case 43: return FunctionPtr(new FunctionImpl<const Canvas(Canvas::*)(uint32_t) const>(&Canvas::getChild));
						case 44: return FunctionPtr(new FunctionImpl<Canvas(Canvas::*)(uint32_t)>(&Canvas::getChild));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)(CanvasElement&)>(&Canvas::addElement));
						case 46: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(CanvasElement&)>(&Canvas::removeElement));
						case 47: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(CanvasElement&)>(&Canvas::raiseElement));
						case 48: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(CanvasElement&)>(&Canvas::lowerElement));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)(const CanvasElement&) const>(&Canvas::findElement));
						case 50: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const CanvasElement&) const>(&Canvas::isElement));
						case 51: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getNumElements));
						case 52: return FunctionPtr(new FunctionImpl<const Array<CanvasElement>(Canvas::*)() const>(&Canvas::getElements));
						case 53: return FunctionPtr(new FunctionImpl<Array<CanvasElement>(Canvas::*)()>(&Canvas::getElements));
						case 54: return FunctionPtr(new FunctionImpl<const CanvasElement(Canvas::*)(uint32_t) const>(&Canvas::getElement));
						case 55: return FunctionPtr(new FunctionImpl<CanvasElement(Canvas::*)(uint32_t)>(&Canvas::getElement));
						case 56: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*) const>(&Canvas::isFont));
						case 57: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*, Stream&)>(&Canvas::addFont));
						case 58: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*, const uint8_t(*)[256])>(&Canvas::addFont));
						case 59: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const char*)>(&Canvas::removeFont));
						case 60: return FunctionPtr(new FunctionImpl<Font(Canvas::*)(const char*)>(&Canvas::getFont));
						case 61: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*) const>(&Canvas::isTexture));
						case 62: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*, Stream&)>(&Canvas::addTexture));
						case 63: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*, Texture&)>(&Canvas::addTexture));
						case 64: return FunctionPtr(new FunctionImpl<bool(Canvas::*)(const char*, const uint8_t(*)[256])>(&Canvas::addTexture));
						case 65: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const char*)>(&Canvas::removeTexture));
						case 66: return FunctionPtr(new FunctionImpl<Texture(Canvas::*)(const char*)>(&Canvas::getTexture));
						case 67: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(Pipeline::DepthMask)>(&Canvas::setDepthMask));
						case 68: return FunctionPtr(new FunctionImpl<Pipeline::DepthMask(Canvas::*)() const>(&Canvas::getDepthMask));
						case 69: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(Pipeline::DepthFunc)>(&Canvas::setDepthFunc));
						case 70: return FunctionPtr(new FunctionImpl<Pipeline::DepthFunc(Canvas::*)() const>(&Canvas::getDepthFunc));
						case 71: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(Command&, const Target&)>(&Canvas::draw));
						case 72: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(Command&)>(&Canvas::draw));
						case 73: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Canvas::CreateCallback&)>(&Canvas::setCreateCallback));
						case 74: return FunctionPtr(new FunctionImpl<Canvas::CreateCallback(Canvas::*)() const>(&Canvas::getCreateCallback));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Canvas::PipelineCallback&)>(&Canvas::setPipelineCallback));
						case 76: return FunctionPtr(new FunctionImpl<Canvas::PipelineCallback(Canvas::*)() const>(&Canvas::getPipelineCallback));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Canvas::BeginCallback&)>(&Canvas::setBeginCallback));
						case 78: return FunctionPtr(new FunctionImpl<Canvas::BeginCallback(Canvas::*)() const>(&Canvas::getBeginCallback));
						case 79: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)(const Canvas::DrawCallback&)>(&Canvas::setDrawCallback));
						case 80: return FunctionPtr(new FunctionImpl<Canvas::DrawCallback(Canvas::*)() const>(&Canvas::getDrawCallback));
						case 81: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getNumDrawPipelines));
						case 82: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getNumDrawElements));
						case 83: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getNumDrawCommands));
						case 84: return FunctionPtr(new FunctionImpl<Rect(Canvas::*)() const>(&Canvas::getRect));
						case 85: return FunctionPtr(new FunctionImpl<Canvas(Canvas::*)() const>(&Canvas::clonePtr));
						case 86: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::clearPtr));
						case 87: return FunctionPtr(new FunctionVoidImpl<void(Canvas::*)()>(&Canvas::destroyPtr));
						case 88: return FunctionPtr(new FunctionImpl<Canvas&(Canvas::*)()>(&Canvas::acquirePtr));
						case 89: return FunctionPtr(new FunctionImpl<Canvas&(Canvas::*)()>(&Canvas::unacquirePtr));
						case 90: return FunctionPtr(new FunctionImpl<bool(Canvas::*)() const>(&Canvas::isValidPtr));
						case 91: return FunctionPtr(new FunctionImpl<bool(Canvas::*)() const>(&Canvas::isOwnerPtr));
						case 92: return FunctionPtr(new FunctionImpl<bool(Canvas::*)() const>(&Canvas::isConstPtr));
						case 93: return FunctionPtr(new FunctionImpl<uint32_t(Canvas::*)() const>(&Canvas::getCountPtr));
						case 94: return FunctionPtr(new FunctionImpl<const void*(Canvas::*)() const>(&Canvas::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 218 };
			static constexpr uint16_t constructor_arg_names[] = { 3348 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2730, 1902, 1902, 3779, 2664, 2202, 2277, 2554, 3763, 2632, 3618, 3071, 3941, 3941, 3941, 2925, 2927, 2410, 1619, 3562, 3562, 2200, 1638, 3820, 2733, 1642, 3911, 2872, 3770, 2651, 2651, 1513, 3424, 3375, 3252, 3409, 2028, 3044, 2567, 2191, 2191, 2190, 2190, 1517, 3426, 3376, 3253, 2030, 3069, 2579, 2319, 2319, 2318, 2318, 3082, 1518, 1518, 3428, 2347, 3190, 1539, 1539, 1539, 3440, 2828, 3601, 2284, 3597, 2278, 1981, 1981, 3581, 2241, 3778, 2663, 3523, 2118, 3614, 2313, 2578, 2577, 2576, 2698, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 1585, 1585, 4073, 4039, 765, 765, 4039, 4073, 3003, 4073, 1585, 4073, 4073, 4073, 1859, 2051, 2051, 4073, 4073, 4073, 1721, 4073, 4073, 1830, 4073, 4073, 1799, 4039, 1710, 216, 4039, 1585, 1585, 1585, 4073, 4039, 1585, 4039, 1668, 45, 1710, 216, 4039, 1585, 1585, 1585, 4039, 1585, 4039, 1669, 46, 1716, 223, 1585, 1585, 1585, 4073, 762, 1585, 1585, 1585, 1585, 4073, 1293, 4073, 1139, 4073, 1138, 4073, 4073, 4073, 220, 4073, 222, 4073, 219, 4073, 221, 4039, 4039, 4039, 1177, 216, 4073, 4073, 217, 217, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 2, 7, 10, 11, 11, 11, 11, 11, 12, 12, 13, 13, 14, 16, 18, 18, 18, 18, 18, 19, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 26, 27, 28, 29, 30, 30, 31, 32, 32, 32, 32, 33, 34, 35, 36, 37, 38, 39, 40, 40, 40, 40, 41, 42, 43, 45, 47, 48, 49, 50, 52, 54, 56, 57, 58, 59, 59, 60, 60, 62, 63, 64, 64, 65, 65, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67 };
			static constexpr uint16_t function_arg_types[] = { 1845, 4039, 1764, 765, 765, 4039, 4039, 1764, 1845, 4039, 4039, 3003, 1585, 1859, 4039, 4039, 2051, 2051, 1721, 2051, 2051, 2051, 2051, 1830, 1799, 217, 217, 217, 217, 217, 1711, 1711, 4039, 4039, 224, 224, 224, 224, 1717, 1717, 4039, 4039, 1877, 1877, 1273, 1877, 1883, 1877, 1877, 1877, 1877, 1273, 1877, 1294, 1877, 1883, 1877, 1877, 1139, 1138, 264, 1845, 264, 1713, 1715, 1712, 1714 };
			static constexpr uint16_t function_arg_names[] = { 4004, 3484, 1969, 1650, 1959, 3287, 3484, 1969, 4004, 3484, 2979, 3339, 1996, 4071, 4089, 2980, 4089, 2980, 1650, 3372, 2075, 1567, 1500, 3488, 4028, 3348, 1609, 1609, 1609, 1609, 1609, 1609, 2993, 2993, 1994, 1994, 1994, 1994, 1994, 1994, 2993, 2993, 3288, 3288, 3990, 3288, 1583, 3288, 3288, 3288, 3288, 3990, 3288, 4012, 3288, 1583, 3288, 3288, 3260, 2074, 1653, 4004, 1653, 2074, 2074, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 10, 0, 0, 0, 6, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 368, 1145, 111, 499 };
			static constexpr uint16_t callback_types[] = { 1585, 1585, 1585, 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 3, 6, 8, 10 };
			static constexpr uint16_t callback_arg_types[] = { 1763, 216, 4039, 1131, 216, 223, 263, 216, 263, 216 };
			static constexpr uint16_t callback_arg_names[] = { 1969, 1602, 3484, 3350, 1602, 1994, 1653, 1602, 1653, 1602 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionCanvas::constructor_bases[];
	constexpr uint16_t ReflectionCanvas::constructor_arg_types[];
	constexpr uint16_t ReflectionCanvas::constructor_arg_names[];
	constexpr uint16_t ReflectionCanvas::constructor_arg_values[];
	constexpr uint8_t ReflectionCanvas::function_flags[];
	constexpr uint16_t ReflectionCanvas::function_names[];
	constexpr uint16_t ReflectionCanvas::function_types[];
	constexpr uint16_t ReflectionCanvas::function_bases[];
	constexpr uint16_t ReflectionCanvas::function_arg_types[];
	constexpr uint16_t ReflectionCanvas::function_arg_names[];
	constexpr uint16_t ReflectionCanvas::function_arg_values[];
	constexpr uint16_t ReflectionCanvas::callback_names[];
	constexpr uint16_t ReflectionCanvas::callback_types[];
	constexpr uint16_t ReflectionCanvas::callback_bases[];
	constexpr uint16_t ReflectionCanvas::callback_arg_types[];
	constexpr uint16_t ReflectionCanvas::callback_arg_names[];
	constexpr uint16_t ReflectionCanvas::enum_names[];
	constexpr uint16_t ReflectionCanvas::enum_bases[];
	constexpr uint16_t ReflectionCanvas::enum_var_names[];
	static ReflectionCanvas reflection_canvas;
	
	// Tellusim::Control
	class ReflectionControl : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Control::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Control, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Control, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<Control, TypeList<Control*, float32_t, float32_t>>({}, {}, 0.0f));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Control>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Control::Type(Control::*)() const>(&Control::getType));
						case 1: return FunctionPtr(new FunctionImpl<const char*(Control::Type)>(&Control::getTypeName));
						case 2: return FunctionPtr(new FunctionImpl<const char*(Control::*)() const>(&Control::getTypeName));
						case 3: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isUnknown));
						case 4: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isRoot));
						case 5: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isText));
						case 6: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isRect));
						case 7: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isGrid));
						case 8: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isGroup));
						case 9: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isPanel));
						case 10: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isDialog));
						case 11: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isWindow));
						case 12: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isCheck));
						case 13: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isCombo));
						case 14: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isButton));
						case 15: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isSlider));
						case 16: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isScroll));
						case 17: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isSplit));
						case 18: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isArea));
						case 19: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isTree));
						case 20: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isEdit));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(Control::Align)>(&Control::setAlign));
						case 22: return FunctionPtr(new FunctionImpl<Control::Align(Control::*)() const>(&Control::getAlign));
						case 23: return FunctionPtr(new FunctionImpl<bool(Control::*)(Control::Align) const>(&Control::hasAlign));
						case 24: return FunctionPtr(new FunctionImpl<bool(Control::*)(Control::Align) const>(&Control::hasAligns));
						case 25: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isSpacer));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(bool)>(&Control::setCreated));
						case 27: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isCreated));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(bool)>(&Control::setEnabled));
						case 29: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isEnabled));
						case 30: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::wasEnabled));
						case 31: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::wasUpdated));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(bool)>(&Control::setDisabled));
						case 33: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isDisabled));
						case 34: return FunctionPtr(new FunctionImpl<Canvas(Control::*)() const>(&Control::getCanvas));
						case 35: return FunctionPtr(new FunctionImpl<const ControlRoot(Control::*)() const>(&Control::getRoot));
						case 36: return FunctionPtr(new FunctionImpl<ControlRoot(Control::*)()>(&Control::getRoot));
						case 37: return FunctionPtr(new FunctionImpl<const ControlPanel(Control::*)() const>(&Control::getPanel));
						case 38: return FunctionPtr(new FunctionImpl<ControlPanel(Control::*)()>(&Control::getPanel));
						case 39: return FunctionPtr(new FunctionImpl<uint32_t(Control::*)(Control&)>(&Control::setParent));
						case 40: return FunctionPtr(new FunctionImpl<const Control(Control::*)() const>(&Control::getParent));
						case 41: return FunctionPtr(new FunctionImpl<Control(Control::*)()>(&Control::getParent));
						case 42: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isParentEnabled));
						case 43: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isParentDisabled));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(Control::*)(Control&)>(&Control::addChild));
						case 45: return FunctionPtr(new FunctionImpl<Control(Control::*)(uint32_t, Control&)>(&Control::setChild));
						case 46: return FunctionPtr(new FunctionImpl<bool(Control::*)(Control&)>(&Control::raiseChild));
						case 47: return FunctionPtr(new FunctionImpl<bool(Control::*)(Control&)>(&Control::lowerChild));
						case 48: return FunctionPtr(new FunctionImpl<bool(Control::*)(Control&)>(&Control::removeChild));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(Control::*)()>(&Control::releaseChildren));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(Control::*)(const Control&) const>(&Control::findChild));
						case 51: return FunctionPtr(new FunctionImpl<bool(Control::*)(const Control&, bool) const>(&Control::isChild, Control::null, false));
						case 52: return FunctionPtr(new FunctionImpl<uint32_t(Control::*)() const>(&Control::getNumChildren));
						case 53: return FunctionPtr(new FunctionImpl<const Array<Control>(Control::*)() const>(&Control::getChildren));
						case 54: return FunctionPtr(new FunctionImpl<Array<Control>(Control::*)()>(&Control::getChildren));
						case 55: return FunctionPtr(new FunctionImpl<const Control(Control::*)(uint32_t) const>(&Control::getChild));
						case 56: return FunctionPtr(new FunctionImpl<Control(Control::*)(uint32_t)>(&Control::getChild));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(const Vector2f&)>(&Control::setSize));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(float32_t, float32_t)>(&Control::setSize));
						case 59: return FunctionPtr(new FunctionImpl<const Vector2f&(Control::*)() const>(&Control::getSize));
						case 60: return FunctionPtr(new FunctionImpl<float32_t(Control::*)() const>(&Control::getWidth));
						case 61: return FunctionPtr(new FunctionImpl<float32_t(Control::*)() const>(&Control::getHeight));
						case 62: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(const Vector3f&)>(&Control::setPosition));
						case 63: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(float32_t, float32_t, float32_t)>(&Control::setPosition, {}, {}, 0.0f));
						case 64: return FunctionPtr(new FunctionImpl<const Vector3f&(Control::*)() const>(&Control::getPosition));
						case 65: return FunctionPtr(new FunctionImpl<float32_t(Control::*)() const>(&Control::getPositionX));
						case 66: return FunctionPtr(new FunctionImpl<float32_t(Control::*)() const>(&Control::getPositionY));
						case 67: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(const Vector3f&)>(&Control::setOffset));
						case 68: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(float32_t, float32_t, float32_t)>(&Control::setOffset, {}, {}, 0.0f));
						case 69: return FunctionPtr(new FunctionImpl<const Vector3f&(Control::*)() const>(&Control::getOffset));
						case 70: return FunctionPtr(new FunctionImpl<float32_t(Control::*)() const>(&Control::getOffsetX));
						case 71: return FunctionPtr(new FunctionImpl<float32_t(Control::*)() const>(&Control::getOffsetY));
						case 72: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(float32_t)>(&Control::setMargin));
						case 73: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(float32_t, float32_t)>(&Control::setMargin));
						case 74: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(float32_t, float32_t, float32_t, float32_t)>(&Control::setMargin));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(Control::*)(const Rect&)>(&Control::setMargin));
						case 76: return FunctionPtr(new FunctionImpl<const Rect&(Control::*)() const>(&Control::getMargin));
						case 77: return FunctionPtr(new FunctionImpl<const Rect&(Control::*)() const>(&Control::getRect));
						case 78: return FunctionPtr(new FunctionImpl<Control::State(Control::*)() const>(&Control::getState));
						case 79: return FunctionPtr(new FunctionImpl<Control(Control::*)() const>(&Control::clonePtr));
						case 80: return FunctionPtr(new FunctionVoidImpl<void(Control::*)()>(&Control::clearPtr));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(Control::*)()>(&Control::destroyPtr));
						case 82: return FunctionPtr(new FunctionImpl<Control&(Control::*)()>(&Control::acquirePtr));
						case 83: return FunctionPtr(new FunctionImpl<Control&(Control::*)()>(&Control::unacquirePtr));
						case 84: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isValidPtr));
						case 85: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isOwnerPtr));
						case 86: return FunctionPtr(new FunctionImpl<bool(Control::*)() const>(&Control::isConstPtr));
						case 87: return FunctionPtr(new FunctionImpl<uint32_t(Control::*)() const>(&Control::getCountPtr));
						case 88: return FunctionPtr(new FunctionImpl<const void*(Control::*)() const>(&Control::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 4 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 2051, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4089, 2980 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 4 };
			static constexpr uint8_t function_flags[] = { 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2, 2, 2, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2878, 2879, 2879, 3198, 3161, 3188, 3157, 3090, 3091, 3144, 3062, 3210, 3042, 3050, 3038, 3173, 3168, 3178, 3019, 3194, 3068, 3506, 2086, 2939, 2940, 3176, 3582, 3057, 3618, 3071, 4083, 4087, 3611, 3065, 2181, 2715, 2715, 2637, 2637, 3770, 2651, 2651, 3146, 3145, 1513, 3555, 3375, 3252, 3424, 3409, 2028, 3044, 2567, 2191, 2191, 2190, 2190, 3830, 3830, 2760, 2927, 2410, 3782, 3782, 2671, 2675, 2676, 3762, 3762, 2628, 2629, 2630, 3706, 3706, 3706, 3706, 2481, 2698, 2768, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 286, 1877, 1877, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 281, 1585, 1585, 1585, 4073, 1585, 4073, 1585, 1585, 1585, 4073, 1585, 216, 1742, 323, 1737, 315, 4039, 1724, 278, 1585, 1585, 4039, 278, 1585, 1585, 1585, 4073, 4039, 1585, 4039, 1672, 47, 1724, 278, 4073, 4073, 1854, 2051, 2051, 4073, 4073, 1856, 2051, 2051, 4073, 4073, 1856, 2051, 2051, 4073, 4073, 4073, 4073, 1830, 1830, 285, 278, 4073, 4073, 279, 279, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 11, 12, 13, 14, 14, 15, 17, 17, 17, 17, 18, 19, 20, 22, 22, 22, 22, 23, 26, 26, 26, 26, 27, 30, 30, 30, 30, 31, 33, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38 };
			static constexpr uint16_t function_arg_types[] = { 286, 281, 281, 281, 1585, 1585, 1585, 279, 279, 4039, 279, 279, 279, 279, 1725, 1725, 1585, 4039, 4039, 1854, 2051, 2051, 1856, 2051, 2051, 2051, 1856, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 2051, 1830 };
			static constexpr uint16_t function_arg_names[] = { 4036, 1546, 1546, 1548, 1944, 1996, 1973, 3348, 1609, 2993, 1609, 1609, 1609, 1609, 1609, 1609, 2982, 2993, 2993, 3960, 4089, 2980, 3355, 4115, 4116, 4118, 3317, 4115, 4116, 4118, 4056, 2983, 4067, 3239, 3470, 1588, 4024, 3259 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1311, 1245, 985, 24, 159, 83, 858 };
			static constexpr uint16_t enum_bases[] = { 0, 19, 25, 38, 57, 65, 71, 92 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1370, 1385, 1369, 1343, 1344, 1363, 1334, 1393, 1324, 1328, 1320, 1375, 1373, 1376, 1314, 1387, 1336, 1117, 1250, 1248, 1247, 1249, 1246, 1112, 1002, 1001, 1023, 1007, 1031, 1022, 1006, 1030, 999, 1021, 1000, 1003, 1105, 36, 33, 38, 26, 42, 28, 29, 31, 32, 37, 41, 25, 34, 35, 39, 40, 27, 30, 1087, 178, 173, 174, 185, 186, 176, 177, 1094, 93, 95, 96, 97, 94, 1090, 885, 894, 860, 864, 881, 890, 889, 884, 866, 880, 895, 865, 882, 891, 893, 863, 859, 862, 1104, 887, 887 };
	};
	constexpr uint16_t ReflectionControl::constructor_bases[];
	constexpr uint16_t ReflectionControl::constructor_arg_types[];
	constexpr uint16_t ReflectionControl::constructor_arg_names[];
	constexpr uint16_t ReflectionControl::constructor_arg_values[];
	constexpr uint8_t ReflectionControl::function_flags[];
	constexpr uint16_t ReflectionControl::function_names[];
	constexpr uint16_t ReflectionControl::function_types[];
	constexpr uint16_t ReflectionControl::function_bases[];
	constexpr uint16_t ReflectionControl::function_arg_types[];
	constexpr uint16_t ReflectionControl::function_arg_names[];
	constexpr uint16_t ReflectionControl::function_arg_values[];
	constexpr uint16_t ReflectionControl::callback_names[];
	constexpr uint16_t ReflectionControl::callback_types[];
	constexpr uint16_t ReflectionControl::callback_bases[];
	constexpr uint16_t ReflectionControl::callback_arg_types[];
	constexpr uint16_t ReflectionControl::callback_arg_names[];
	constexpr uint16_t ReflectionControl::enum_names[];
	constexpr uint16_t ReflectionControl::enum_bases[];
	constexpr uint16_t ReflectionControl::enum_var_names[];
	static ReflectionControl reflection_control;
	
	// Tellusim::ControlRoot
	class ReflectionControlRoot : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlRoot::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlRoot, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlRoot, TypeList<Canvas&, bool>>(Canvas::null, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlRoot>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const Viewport&)>(&ControlRoot::setViewport));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(uint32_t, uint32_t)>(&ControlRoot::setViewport));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(float32_t, float32_t)>(&ControlRoot::setViewport));
						case 3: return FunctionPtr(new FunctionImpl<const Viewport&(ControlRoot::*)() const>(&ControlRoot::getViewport));
						case 4: return FunctionPtr(new FunctionImpl<String(ControlRoot::*)() const>(&ControlRoot::getFontName));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const char*)>(&ControlRoot::setFontName));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const String&)>(&ControlRoot::setFontName));
						case 7: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(const uint8_t(*)[256], const char*)>(&ControlRoot::setFontBlob, {}, nullptr));
						case 8: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(uint32_t, bool)>(&ControlRoot::setFontSize, {}, false));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(ControlRoot::*)() const>(&ControlRoot::getFontSize));
						case 10: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(uint32_t, bool)>(&ControlRoot::setFontScale, {}, false));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(ControlRoot::*)() const>(&ControlRoot::getFontScale));
						case 12: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(const FontStyle&, bool)>(&ControlRoot::setFontStyle, {}, false));
						case 13: return FunctionPtr(new FunctionImpl<const FontStyle&(ControlRoot::*)() const>(&ControlRoot::getFontStyle));
						case 14: return FunctionPtr(new FunctionImpl<FontStyle&(ControlRoot::*)()>(&ControlRoot::getFontStyle));
						case 15: return FunctionPtr(new FunctionImpl<String(ControlRoot::*)() const>(&ControlRoot::getTextureName));
						case 16: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(const char*, uint32_t, uint32_t, float32_t)>(&ControlRoot::setTextureName, {}, 0, 0, 0.0f));
						case 17: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(const String&, uint32_t, uint32_t, float32_t)>(&ControlRoot::setTextureName, {}, 0, 0, 0.0f));
						case 18: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(const uint8_t(*)[256], const char*, uint32_t, uint32_t, float32_t)>(&ControlRoot::setTextureBlob, {}, nullptr, 0, 0, 0.0f));
						case 19: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getTextureWidth));
						case 20: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getTextureHeight));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Type, Control::State, const Color&)>(&ControlRoot::setTextColor));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Type, Control::State, const Vector3f&)>(&ControlRoot::setTextOffset));
						case 23: return FunctionPtr(new FunctionImpl<const Color&(ControlRoot::*)(Control::Type, Control::State) const>(&ControlRoot::getTextColor));
						case 24: return FunctionPtr(new FunctionImpl<const Vector3f&(ControlRoot::*)(Control::Type, Control::State) const>(&ControlRoot::getTextOffset));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Mesh, Control::State, const Color&)>(&ControlRoot::setMeshColor));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Mesh, const Rect&, const Rect&, const Vector2f&)>(&ControlRoot::setMeshRegion));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Mesh, const Rect&, const Rect&, const Vector2f&)>(&ControlRoot::setMeshRegions));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(ControlRoot::*)(Control::Mesh, Control::State) const>(&ControlRoot::getMeshColor));
						case 29: return FunctionPtr(new FunctionImpl<const Rect&(ControlRoot::*)(Control::Mesh) const>(&ControlRoot::getMeshGrid));
						case 30: return FunctionPtr(new FunctionImpl<const Rect&(ControlRoot::*)(Control::Mesh) const>(&ControlRoot::getMeshMargin));
						case 31: return FunctionPtr(new FunctionImpl<const Rect&(ControlRoot::*)(Control::Mesh, Control::State) const>(&ControlRoot::getMeshRegion));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(float32_t)>(&ControlRoot::setGroupRadius));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const Color&)>(&ControlRoot::setGroupColor));
						case 34: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getGroupRadius));
						case 35: return FunctionPtr(new FunctionImpl<const Color&(ControlRoot::*)() const>(&ControlRoot::getGroupColor));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(float32_t)>(&ControlRoot::setPanelRadius));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const Color&)>(&ControlRoot::setPanelColor));
						case 38: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getPanelRadius));
						case 39: return FunctionPtr(new FunctionImpl<const Color&(ControlRoot::*)() const>(&ControlRoot::getPanelColor));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const Color&)>(&ControlRoot::setCheckedColor));
						case 41: return FunctionPtr(new FunctionImpl<const Color&(ControlRoot::*)() const>(&ControlRoot::getCheckedColor));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(float32_t)>(&ControlRoot::setSplitSize));
						case 43: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getSplitSize));
						case 44: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(int32_t, int32_t, Control::Button)>(&ControlRoot::setMouse));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(float32_t, float32_t, Control::Button)>(&ControlRoot::setMouse));
						case 46: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlRoot::*)() const>(&ControlRoot::getMouse));
						case 47: return FunctionPtr(new FunctionImpl<Control::Button(ControlRoot::*)() const>(&ControlRoot::getMouseButtons));
						case 48: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getMouseX));
						case 49: return FunctionPtr(new FunctionImpl<float32_t(ControlRoot::*)() const>(&ControlRoot::getMouseY));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const Vector2f&)>(&ControlRoot::setMouseOffset));
						case 51: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlRoot::*)() const>(&ControlRoot::getMouseOffset));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Axis, float32_t)>(&ControlRoot::setMouseAxis));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control::Align, bool)>(&ControlRoot::setMouseAlign, (Control::Align)0, true));
						case 54: return FunctionPtr(new FunctionImpl<Control::Align(ControlRoot::*)() const>(&ControlRoot::getMouseAlign));
						case 55: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(Control::Align) const>(&ControlRoot::hasMouseAlign));
						case 56: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(Control::Align) const>(&ControlRoot::hasMouseAligns));
						case 57: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(uint32_t, uint32_t, bool)>(&ControlRoot::setKeyboardKey));
						case 58: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(uint32_t, bool)>(&ControlRoot::getKeyboardKey, {}, false));
						case 59: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::clearCurrentControl));
						case 60: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control, bool)>(&ControlRoot::setCurrentControl, {}, false));
						case 61: return FunctionPtr(new FunctionImpl<Control(ControlRoot::*)() const>(&ControlRoot::getCurrentControl));
						case 62: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isCurrentControl));
						case 63: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::getControlGrab));
						case 64: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::clearFocusedControl));
						case 65: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control)>(&ControlRoot::setFocusedControl));
						case 66: return FunctionPtr(new FunctionImpl<Control(ControlRoot::*)() const>(&ControlRoot::getFocusedControl));
						case 67: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isFocusedControl));
						case 68: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::clearMouseControl));
						case 69: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control)>(&ControlRoot::setMouseControl));
						case 70: return FunctionPtr(new FunctionImpl<Control(ControlRoot::*)() const>(&ControlRoot::getMouseControl));
						case 71: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isMouseControl));
						case 72: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::clearInputControl));
						case 73: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control)>(&ControlRoot::setInputControl));
						case 74: return FunctionPtr(new FunctionImpl<Control(ControlRoot::*)() const>(&ControlRoot::getInputControl));
						case 75: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isInputControl));
						case 76: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::clearModalControl));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(Control, bool)>(&ControlRoot::setModalControl, {}, true));
						case 78: return FunctionPtr(new FunctionImpl<Control(ControlRoot::*)() const>(&ControlRoot::getModalControl));
						case 79: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isModalDisabled));
						case 80: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isModalControl));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(int32_t)>(&ControlRoot::setOverlayOrder));
						case 82: return FunctionPtr(new FunctionImpl<int32_t(ControlRoot::*)() const>(&ControlRoot::getOverlayOrder));
						case 83: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)(uint32_t, int32_t)>(&ControlRoot::update, 0, 0));
						case 84: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const char*)>(&ControlRoot::setCopyText));
						case 85: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const String&)>(&ControlRoot::setCopyText));
						case 86: return FunctionPtr(new FunctionImpl<String(ControlRoot::*)()>(&ControlRoot::getPasteText));
						case 87: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const ControlRoot::CopyCallback&)>(&ControlRoot::setCopyCallback));
						case 88: return FunctionPtr(new FunctionImpl<ControlRoot::CopyCallback(ControlRoot::*)() const>(&ControlRoot::getCopyCallback));
						case 89: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)(const ControlRoot::PasteCallback&)>(&ControlRoot::setPasteCallback));
						case 90: return FunctionPtr(new FunctionImpl<ControlRoot::PasteCallback(ControlRoot::*)() const>(&ControlRoot::getPasteCallback));
						case 91: return FunctionPtr(new FunctionImpl<ControlRoot(ControlRoot::*)() const>(&ControlRoot::clonePtr));
						case 92: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::clearPtr));
						case 93: return FunctionPtr(new FunctionVoidImpl<void(ControlRoot::*)()>(&ControlRoot::destroyPtr));
						case 94: return FunctionPtr(new FunctionImpl<ControlRoot&(ControlRoot::*)()>(&ControlRoot::acquirePtr));
						case 95: return FunctionPtr(new FunctionImpl<ControlRoot&(ControlRoot::*)()>(&ControlRoot::unacquirePtr));
						case 96: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isValidPtr));
						case 97: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isOwnerPtr));
						case 98: return FunctionPtr(new FunctionImpl<bool(ControlRoot::*)() const>(&ControlRoot::isConstPtr));
						case 99: return FunctionPtr(new FunctionImpl<uint32_t(ControlRoot::*)() const>(&ControlRoot::getCountPtr));
						case 100: return FunctionPtr(new FunctionImpl<const void*(ControlRoot::*)() const>(&ControlRoot::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2 };
			static constexpr uint16_t constructor_arg_types[] = { 217, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 1602, 1583 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 2, 0, 2, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3941, 3941, 3941, 2925, 2350, 3637, 3637, 3635, 3639, 2352, 3638, 2351, 3640, 2353, 2353, 2840, 3893, 3893, 3887, 2850, 2833, 3882, 3884, 2826, 2827, 3712, 3713, 3714, 2503, 2504, 2505, 2506, 3654, 3653, 2400, 2399, 3768, 3767, 2639, 2638, 3554, 2189, 3836, 2767, 3731, 3731, 2537, 2541, 2552, 2553, 3742, 2547, 3733, 3732, 2538, 2960, 2961, 3696, 2464, 1620, 3586, 2245, 3060, 2232, 1621, 3631, 2344, 3080, 1633, 3738, 2543, 3127, 1625, 3675, 2430, 3100, 1630, 3722, 2524, 3125, 3124, 3766, 2635, 4051, 3580, 3580, 2658, 3579, 2237, 3774, 2657, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 4073, 1859, 1274, 4073, 4073, 1585, 1585, 4039, 1585, 4039, 1585, 1778, 764, 1274, 1585, 1585, 1585, 2051, 2051, 4073, 4073, 1721, 1856, 4073, 4073, 4073, 4039, 1830, 1830, 1830, 4073, 4073, 2051, 1721, 4073, 4073, 2051, 1721, 4073, 1721, 4073, 2051, 4073, 4073, 1854, 283, 2051, 2051, 4073, 1854, 4073, 4073, 281, 1585, 1585, 1585, 1585, 4073, 4073, 278, 1585, 1585, 4073, 4073, 278, 1585, 4073, 4073, 278, 1585, 4073, 4073, 278, 1585, 4073, 4073, 278, 1585, 1585, 4073, 3003, 1585, 4073, 4073, 1274, 4073, 326, 4073, 327, 323, 4073, 4073, 324, 324, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 3, 5, 5, 5, 6, 7, 9, 11, 11, 13, 13, 15, 15, 15, 15, 19, 23, 28, 28, 28, 31, 34, 36, 38, 41, 45, 49, 51, 52, 53, 55, 56, 57, 57, 57, 58, 59, 59, 59, 60, 60, 61, 61, 64, 67, 67, 67, 67, 67, 68, 68, 70, 72, 72, 73, 74, 77, 79, 79, 81, 81, 81, 81, 81, 82, 82, 82, 82, 83, 83, 83, 83, 84, 84, 84, 84, 86, 86, 86, 86, 87, 87, 89, 90, 91, 91, 92, 92, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93 };
			static constexpr uint16_t function_arg_types[] = { 1859, 4039, 4039, 2051, 2051, 1877, 1841, 1883, 1877, 4039, 1585, 4039, 1585, 1778, 1585, 1877, 4039, 4039, 2051, 1841, 4039, 4039, 2051, 1883, 1877, 4039, 4039, 2051, 286, 285, 1721, 286, 285, 1856, 286, 285, 286, 285, 284, 285, 1721, 284, 1830, 1830, 1854, 284, 1830, 1830, 1854, 284, 285, 284, 284, 284, 285, 2051, 1721, 2051, 1721, 1721, 2051, 3003, 3003, 283, 2051, 2051, 283, 1854, 282, 2051, 281, 1585, 281, 281, 4039, 4039, 1585, 4039, 1585, 278, 1585, 278, 278, 278, 278, 1585, 3003, 4039, 3003, 1877, 1841, 1743, 1744 };
			static constexpr uint16_t function_arg_names[] = { 4071, 4089, 2980, 4089, 2980, 3288, 3288, 1583, 3288, 3960, 4051, 3484, 4051, 3992, 4051, 3288, 4089, 2980, 1587, 3288, 4089, 2980, 1587, 1583, 3288, 4089, 2980, 1587, 4036, 3983, 1650, 4036, 3983, 3317, 4036, 3983, 4036, 3983, 3269, 3983, 1650, 3269, 2936, 3403, 1587, 3269, 2936, 3404, 1587, 3269, 3983, 3269, 3269, 3269, 3983, 3373, 1650, 3373, 1650, 1650, 3960, 4115, 4116, 1599, 4115, 4116, 1599, 3317, 1566, 1958, 1546, 1612, 1546, 1548, 3231, 1649, 4056, 3231, 1612, 1888, 2935, 1888, 1888, 1888, 1888, 1973, 3339, 3484, 3339, 4011, 4011, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 2016, 0, 2016, 0, 2016, 0, 3, 3, 4, 0, 3, 3, 4, 0, 3294, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4033, 0, 0, 0, 0, 0, 0, 2016, 0, 2016, 0, 0, 0, 0, 4033, 0, 3, 3, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 366, 1129 };
			static constexpr uint16_t callback_types[] = { 4073, 1274 };
			static constexpr uint16_t callback_bases[] = { 0, 2, 3 };
			static constexpr uint16_t callback_arg_types[] = { 323, 1877, 323 };
			static constexpr uint16_t callback_arg_names[] = { 0, 4011, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlRoot::constructor_bases[];
	constexpr uint16_t ReflectionControlRoot::constructor_arg_types[];
	constexpr uint16_t ReflectionControlRoot::constructor_arg_names[];
	constexpr uint16_t ReflectionControlRoot::constructor_arg_values[];
	constexpr uint8_t ReflectionControlRoot::function_flags[];
	constexpr uint16_t ReflectionControlRoot::function_names[];
	constexpr uint16_t ReflectionControlRoot::function_types[];
	constexpr uint16_t ReflectionControlRoot::function_bases[];
	constexpr uint16_t ReflectionControlRoot::function_arg_types[];
	constexpr uint16_t ReflectionControlRoot::function_arg_names[];
	constexpr uint16_t ReflectionControlRoot::function_arg_values[];
	constexpr uint16_t ReflectionControlRoot::callback_names[];
	constexpr uint16_t ReflectionControlRoot::callback_types[];
	constexpr uint16_t ReflectionControlRoot::callback_bases[];
	constexpr uint16_t ReflectionControlRoot::callback_arg_types[];
	constexpr uint16_t ReflectionControlRoot::callback_arg_names[];
	constexpr uint16_t ReflectionControlRoot::enum_names[];
	constexpr uint16_t ReflectionControlRoot::enum_bases[];
	constexpr uint16_t ReflectionControlRoot::enum_var_names[];
	static ReflectionControlRoot reflection_control_root;
	
	// Tellusim::ControlText
	class ReflectionControlText : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlText::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlText, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlText, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlText, TypeList<Control*, const char*>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlText, TypeList<Control*, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlText>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(CanvasElement::Mode)>(&ControlText::setMode));
						case 1: return FunctionPtr(new FunctionImpl<CanvasElement::Mode(ControlText::*)() const>(&ControlText::getMode));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(Pipeline&)>(&ControlText::setPipeline));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(Pipeline&, const CanvasElement::DrawCallback&)>(&ControlText::setPipeline));
						case 4: return FunctionPtr(new FunctionImpl<Pipeline(ControlText::*)() const>(&ControlText::getPipeline));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(const Color&)>(&ControlText::setColor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(float32_t, float32_t, float32_t, float32_t)>(&ControlText::setColor));
						case 7: return FunctionPtr(new FunctionImpl<const Color&(ControlText::*)() const>(&ControlText::getColor));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(Sampler::Filter)>(&ControlText::setFilter));
						case 9: return FunctionPtr(new FunctionImpl<Sampler::Filter(ControlText::*)() const>(&ControlText::getFilter));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(uint32_t)>(&ControlText::setAnisotropy));
						case 11: return FunctionPtr(new FunctionImpl<uint32_t(ControlText::*)() const>(&ControlText::getAnisotropy));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&ControlText::setBlend));
						case 13: return FunctionPtr(new FunctionImpl<Pipeline::BlendOp(ControlText::*)() const>(&ControlText::getBlendOp));
						case 14: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(ControlText::*)() const>(&ControlText::getBlendSrcFunc));
						case 15: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(ControlText::*)() const>(&ControlText::getBlendDestFunc));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(const char*)>(&ControlText::setFontName));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(const String&)>(&ControlText::setFontName));
						case 18: return FunctionPtr(new FunctionImpl<String(ControlText::*)() const>(&ControlText::getFontName));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(const Color&)>(&ControlText::setFontColor));
						case 20: return FunctionPtr(new FunctionImpl<const Color&(ControlText::*)() const>(&ControlText::getFontColor));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlText::*)(uint32_t)>(&ControlText::setFontSize));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(ControlText::*)() const>(&ControlText::getFontSize));
						case 23: return FunctionPtr(new FunctionImpl<bool(ControlText::*)(const FontStyle&)>(&ControlText::setFontStyle));
						case 24: return FunctionPtr(new FunctionImpl<const FontStyle&(ControlText::*)() const>(&ControlText::getFontStyleConst));
						case 25: return FunctionPtr(new FunctionImpl<const FontStyle&(ControlText::*)() const>(&ControlText::getFontStyle));
						case 26: return FunctionPtr(new FunctionImpl<FontStyle&(ControlText::*)()>(&ControlText::getFontStyle));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(Control::Align)>(&ControlText::setFontAlign));
						case 28: return FunctionPtr(new FunctionImpl<Control::Align(ControlText::*)() const>(&ControlText::getFontAlign));
						case 29: return FunctionPtr(new FunctionImpl<bool(ControlText::*)(Control::Align) const>(&ControlText::hasFontAlign));
						case 30: return FunctionPtr(new FunctionImpl<bool(ControlText::*)(Control::Align) const>(&ControlText::hasFontAligns));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(const char*)>(&ControlText::setText));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)(const String&)>(&ControlText::setText));
						case 33: return FunctionPtr(new FunctionImpl<String(ControlText::*)() const>(&ControlText::getText));
						case 34: return FunctionPtr(new FunctionImpl<CanvasText(ControlText::*)()>(&ControlText::getCanvasText));
						case 35: return FunctionPtr(new FunctionImpl<ControlText(ControlText::*)() const>(&ControlText::clonePtr));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)()>(&ControlText::clearPtr));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(ControlText::*)()>(&ControlText::destroyPtr));
						case 38: return FunctionPtr(new FunctionImpl<ControlText&(ControlText::*)()>(&ControlText::acquirePtr));
						case 39: return FunctionPtr(new FunctionImpl<ControlText&(ControlText::*)()>(&ControlText::unacquirePtr));
						case 40: return FunctionPtr(new FunctionImpl<bool(ControlText::*)() const>(&ControlText::isValidPtr));
						case 41: return FunctionPtr(new FunctionImpl<bool(ControlText::*)() const>(&ControlText::isOwnerPtr));
						case 42: return FunctionPtr(new FunctionImpl<bool(ControlText::*)() const>(&ControlText::isConstPtr));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(ControlText::*)() const>(&ControlText::getCountPtr));
						case 44: return FunctionPtr(new FunctionImpl<const void*(ControlText::*)() const>(&ControlText::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1877, 280, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4011, 3348, 4011 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3723, 2525, 3777, 3777, 2662, 3562, 3562, 2200, 3627, 2340, 3508, 2091, 3524, 2126, 2129, 2125, 3637, 3637, 2350, 3636, 2349, 3639, 2352, 3640, 2354, 2353, 2353, 3634, 2348, 2949, 2950, 3881, 3881, 2825, 2184, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 227, 4073, 4073, 1131, 4073, 4073, 1721, 4073, 1195, 4073, 4039, 4073, 1135, 1134, 1134, 4073, 4073, 1274, 4073, 1721, 1585, 4039, 1585, 1778, 1778, 764, 4073, 281, 1585, 1585, 4073, 4073, 1274, 240, 341, 4073, 4073, 342, 342, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 4, 4, 5, 9, 9, 10, 10, 11, 11, 14, 14, 14, 14, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 21, 22, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 };
			static constexpr uint16_t function_arg_types[] = { 227, 1132, 1132, 1718, 1721, 2051, 2051, 2051, 2051, 1195, 4039, 1135, 1134, 1134, 1877, 1841, 1721, 4039, 1778, 281, 281, 281, 1877, 1841 };
			static constexpr uint16_t function_arg_names[] = { 3275, 3350, 3350, 2074, 1650, 3372, 2075, 1567, 1500, 2022, 1551, 3326, 3975, 1963, 3288, 3288, 1650, 3960, 3992, 1546, 1546, 1548, 4011, 4011 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlText::constructor_bases[];
	constexpr uint16_t ReflectionControlText::constructor_arg_types[];
	constexpr uint16_t ReflectionControlText::constructor_arg_names[];
	constexpr uint16_t ReflectionControlText::constructor_arg_values[];
	constexpr uint8_t ReflectionControlText::function_flags[];
	constexpr uint16_t ReflectionControlText::function_names[];
	constexpr uint16_t ReflectionControlText::function_types[];
	constexpr uint16_t ReflectionControlText::function_bases[];
	constexpr uint16_t ReflectionControlText::function_arg_types[];
	constexpr uint16_t ReflectionControlText::function_arg_names[];
	constexpr uint16_t ReflectionControlText::function_arg_values[];
	constexpr uint16_t ReflectionControlText::callback_names[];
	constexpr uint16_t ReflectionControlText::callback_types[];
	constexpr uint16_t ReflectionControlText::callback_bases[];
	constexpr uint16_t ReflectionControlText::callback_arg_types[];
	constexpr uint16_t ReflectionControlText::callback_arg_names[];
	constexpr uint16_t ReflectionControlText::enum_names[];
	constexpr uint16_t ReflectionControlText::enum_bases[];
	constexpr uint16_t ReflectionControlText::enum_var_names[];
	static ReflectionControlText reflection_control_text;
	
	// Tellusim::ControlRect
	class ReflectionControlRect : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlRect::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlRect, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlRect, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlRect, TypeList<Control*, Texture&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlRect, TypeList<Control*, const char*>>());
						case 4: return ConstructorPtr(new ConstructorImpl<ControlRect, TypeList<Control*, CanvasElement::Mode>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlRect>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(bool)>(&ControlRect::setCallback));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::getCallback));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(bool)>(&ControlRect::setFullscreen));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::isFullscreen));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(CanvasElement::Mode)>(&ControlRect::setMode));
						case 5: return FunctionPtr(new FunctionImpl<CanvasElement::Mode(ControlRect::*)() const>(&ControlRect::getMode));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(Pipeline&)>(&ControlRect::setPipeline));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(Pipeline&, const CanvasElement::DrawCallback&)>(&ControlRect::setPipeline));
						case 8: return FunctionPtr(new FunctionImpl<Pipeline(ControlRect::*)() const>(&ControlRect::getPipeline));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(float32_t)>(&ControlRect::setRadius));
						case 10: return FunctionPtr(new FunctionImpl<float32_t(ControlRect::*)() const>(&ControlRect::getRadius));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const Color&)>(&ControlRect::setColor));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(float32_t, float32_t, float32_t, float32_t)>(&ControlRect::setColor));
						case 13: return FunctionPtr(new FunctionImpl<const Color&(ControlRect::*)() const>(&ControlRect::getColor));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const StrokeStyle&)>(&ControlRect::setStrokeStyle));
						case 15: return FunctionPtr(new FunctionImpl<const StrokeStyle&(ControlRect::*)() const>(&ControlRect::getStrokeStyleConst));
						case 16: return FunctionPtr(new FunctionImpl<const StrokeStyle&(ControlRect::*)() const>(&ControlRect::getStrokeStyle));
						case 17: return FunctionPtr(new FunctionImpl<StrokeStyle&(ControlRect::*)()>(&ControlRect::getStrokeStyle));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const GradientStyle&)>(&ControlRect::setGradientStyle));
						case 19: return FunctionPtr(new FunctionImpl<const GradientStyle&(ControlRect::*)() const>(&ControlRect::getGradientStyleConst));
						case 20: return FunctionPtr(new FunctionImpl<const GradientStyle&(ControlRect::*)() const>(&ControlRect::getGradientStyle));
						case 21: return FunctionPtr(new FunctionImpl<GradientStyle&(ControlRect::*)()>(&ControlRect::getGradientStyle));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(float32_t)>(&ControlRect::setMipmap));
						case 23: return FunctionPtr(new FunctionImpl<float32_t(ControlRect::*)() const>(&ControlRect::getMipmap));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(Sampler::Filter)>(&ControlRect::setFilter));
						case 25: return FunctionPtr(new FunctionImpl<Sampler::Filter(ControlRect::*)() const>(&ControlRect::getFilter));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(uint32_t)>(&ControlRect::setAnisotropy));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(ControlRect::*)() const>(&ControlRect::getAnisotropy));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(Sampler::WrapMode)>(&ControlRect::setWrapMode));
						case 29: return FunctionPtr(new FunctionImpl<Sampler::WrapMode(ControlRect::*)() const>(&ControlRect::getWrapMode));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(Pipeline::BlendOp, Pipeline::BlendFunc, Pipeline::BlendFunc)>(&ControlRect::setBlend));
						case 31: return FunctionPtr(new FunctionImpl<Pipeline::BlendOp(ControlRect::*)() const>(&ControlRect::getBlendOp));
						case 32: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(ControlRect::*)() const>(&ControlRect::getBlendSrcFunc));
						case 33: return FunctionPtr(new FunctionImpl<Pipeline::BlendFunc(ControlRect::*)() const>(&ControlRect::getBlendDestFunc));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(Texture&, bool)>(&ControlRect::setTexture, Texture::null, false));
						case 35: return FunctionPtr(new FunctionImpl<Texture(ControlRect::*)() const>(&ControlRect::getTexture));
						case 36: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::getTextureLinear));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const char*)>(&ControlRect::setTextureName));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const String&)>(&ControlRect::setTextureName));
						case 39: return FunctionPtr(new FunctionImpl<String(ControlRect::*)() const>(&ControlRect::getTextureName));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(float32_t, float32_t)>(&ControlRect::setTextureScale));
						case 41: return FunctionPtr(new FunctionImpl<float32_t(ControlRect::*)() const>(&ControlRect::getTextureScaleX));
						case 42: return FunctionPtr(new FunctionImpl<float32_t(ControlRect::*)() const>(&ControlRect::getTextureScaleY));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(bool, bool)>(&ControlRect::setTextureFlip));
						case 44: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::getTextureFlipX));
						case 45: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::getTextureFlipY));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(bool)>(&ControlRect::setTextureProj));
						case 47: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::getTextureProj));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const Rect&)>(&ControlRect::setTexCoord));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(float32_t, float32_t, float32_t, float32_t)>(&ControlRect::setTexCoord));
						case 50: return FunctionPtr(new FunctionImpl<const Rect&(ControlRect::*)() const>(&ControlRect::getTexCoord));
						case 51: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const ControlRect::InsideCallback&)>(&ControlRect::setInsideCallback));
						case 52: return FunctionPtr(new FunctionImpl<ControlRect::InsideCallback(ControlRect::*)() const>(&ControlRect::getInsideCallback));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const ControlRect::PressedCallback&)>(&ControlRect::setPressedCallback));
						case 54: return FunctionPtr(new FunctionImpl<ControlRect::PressedCallback(ControlRect::*)() const>(&ControlRect::getPressedCallback));
						case 55: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const ControlRect::ReleasedCallback&)>(&ControlRect::setReleasedCallback));
						case 56: return FunctionPtr(new FunctionImpl<ControlRect::ReleasedCallback(ControlRect::*)() const>(&ControlRect::getReleasedCallback));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const ControlRect::ClickedCallback&)>(&ControlRect::setClickedCallback));
						case 58: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const ControlRect::ClickedCallback&)>(&ControlRect::setClicked2Callback));
						case 59: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)(const ControlRect::ClickedCallback&)>(&ControlRect::setClickedRightCallback));
						case 60: return FunctionPtr(new FunctionImpl<ControlRect::ClickedCallback(ControlRect::*)() const>(&ControlRect::getClickedCallback));
						case 61: return FunctionPtr(new FunctionImpl<ControlRect::ClickedCallback(ControlRect::*)() const>(&ControlRect::getClicked2Callback));
						case 62: return FunctionPtr(new FunctionImpl<ControlRect::ClickedCallback(ControlRect::*)() const>(&ControlRect::getClickedRightCallback));
						case 63: return FunctionPtr(new FunctionImpl<CanvasRect(ControlRect::*)()>(&ControlRect::getCanvasRect));
						case 64: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlRect::*)()>(&ControlRect::getCanvasMesh));
						case 65: return FunctionPtr(new FunctionImpl<ControlRect(ControlRect::*)() const>(&ControlRect::clonePtr));
						case 66: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)()>(&ControlRect::clearPtr));
						case 67: return FunctionPtr(new FunctionVoidImpl<void(ControlRect::*)()>(&ControlRect::destroyPtr));
						case 68: return FunctionPtr(new FunctionImpl<ControlRect&(ControlRect::*)()>(&ControlRect::acquirePtr));
						case 69: return FunctionPtr(new FunctionImpl<ControlRect&(ControlRect::*)()>(&ControlRect::unacquirePtr));
						case 70: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::isValidPtr));
						case 71: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::isOwnerPtr));
						case 72: return FunctionPtr(new FunctionImpl<bool(ControlRect::*)() const>(&ControlRect::isConstPtr));
						case 73: return FunctionPtr(new FunctionImpl<uint32_t(ControlRect::*)() const>(&ControlRect::getCountPtr));
						case 74: return FunctionPtr(new FunctionImpl<const void*(ControlRect::*)() const>(&ControlRect::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5, 7 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1294, 280, 1877, 280, 227 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4012, 3348, 3288, 3348, 3275 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3547, 2179, 3648, 3084, 3723, 2525, 3777, 3777, 2662, 3792, 2693, 3562, 3562, 2200, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 3721, 2520, 3627, 2340, 3508, 2091, 3947, 2929, 3524, 2126, 2129, 2125, 3885, 2828, 2837, 3893, 3893, 2840, 3896, 2845, 2846, 3888, 2831, 2832, 3895, 2842, 3873, 3873, 2818, 3678, 2433, 3788, 2681, 3799, 2703, 3559, 3558, 3560, 2196, 2195, 2197, 2183, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 227, 4073, 4073, 1131, 4073, 2051, 4073, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 4073, 2051, 4073, 1195, 4073, 4039, 4073, 1198, 4073, 1135, 1134, 1134, 4073, 1293, 1585, 4073, 4073, 1274, 4073, 2051, 2051, 4073, 1585, 1585, 4073, 1585, 4073, 4073, 1830, 4073, 320, 4073, 321, 4073, 322, 4073, 4073, 4073, 319, 319, 319, 234, 232, 317, 4073, 4073, 318, 318, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 6, 6, 7, 7, 8, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 21, 21, 21, 21, 23, 23, 23, 24, 25, 25, 27, 27, 27, 29, 29, 29, 30, 30, 31, 35, 35, 36, 36, 37, 37, 38, 38, 39, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 227, 1132, 1132, 1718, 2051, 1721, 2051, 2051, 2051, 2051, 1843, 1779, 2051, 1195, 4039, 1198, 1135, 1134, 1134, 1294, 1585, 1877, 1841, 2051, 2051, 1585, 1585, 1585, 1830, 2051, 2051, 2051, 2051, 1739, 1740, 1741, 1738, 1738, 1738 };
			static constexpr uint16_t function_arg_names[] = { 1601, 2073, 3275, 3350, 3350, 2074, 3373, 1650, 3372, 2075, 1567, 1500, 3992, 3992, 3274, 2022, 1551, 3275, 3326, 3975, 1963, 4012, 3241, 3288, 3288, 3485, 3486, 2049, 2050, 3366, 4010, 3239, 3470, 1588, 4024, 2074, 2074, 2074, 2074, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 849, 1153, 1183, 249 };
			static constexpr uint16_t callback_types[] = { 1585, 4073, 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 3, 6, 9, 10 };
			static constexpr uint16_t callback_arg_types[] = { 317, 2051, 2051, 317, 2051, 2051, 317, 2051, 2051, 317 };
			static constexpr uint16_t callback_arg_names[] = { 0, 4115, 4116, 0, 4115, 4116, 0, 4115, 4116, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlRect::constructor_bases[];
	constexpr uint16_t ReflectionControlRect::constructor_arg_types[];
	constexpr uint16_t ReflectionControlRect::constructor_arg_names[];
	constexpr uint16_t ReflectionControlRect::constructor_arg_values[];
	constexpr uint8_t ReflectionControlRect::function_flags[];
	constexpr uint16_t ReflectionControlRect::function_names[];
	constexpr uint16_t ReflectionControlRect::function_types[];
	constexpr uint16_t ReflectionControlRect::function_bases[];
	constexpr uint16_t ReflectionControlRect::function_arg_types[];
	constexpr uint16_t ReflectionControlRect::function_arg_names[];
	constexpr uint16_t ReflectionControlRect::function_arg_values[];
	constexpr uint16_t ReflectionControlRect::callback_names[];
	constexpr uint16_t ReflectionControlRect::callback_types[];
	constexpr uint16_t ReflectionControlRect::callback_bases[];
	constexpr uint16_t ReflectionControlRect::callback_arg_types[];
	constexpr uint16_t ReflectionControlRect::callback_arg_names[];
	constexpr uint16_t ReflectionControlRect::enum_names[];
	constexpr uint16_t ReflectionControlRect::enum_bases[];
	constexpr uint16_t ReflectionControlRect::enum_var_names[];
	static ReflectionControlRect reflection_control_rect;
	
	// Tellusim::ControlGrid
	class ReflectionControlGrid : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlGrid::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlGrid, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlGrid, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlGrid, TypeList<Control*, uint32_t>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlGrid, TypeList<Control*, uint32_t, float32_t, float32_t>>({}, {}, {}, 0.0f));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlGrid>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlGrid::*)(uint32_t)>(&ControlGrid::setColumns));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(ControlGrid::*)() const>(&ControlGrid::getColumns));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlGrid::*)(const Vector2f&)>(&ControlGrid::setSpacing));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlGrid::*)(float32_t, float32_t)>(&ControlGrid::setSpacing));
						case 4: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlGrid::*)() const>(&ControlGrid::getSpacing));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlGrid::*)(uint32_t, float32_t)>(&ControlGrid::setColumnRatio));
						case 6: return FunctionPtr(new FunctionImpl<float32_t(ControlGrid::*)(uint32_t) const>(&ControlGrid::getColumnRatio));
						case 7: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlGrid::*)() const>(&ControlGrid::getControlsSize));
						case 8: return FunctionPtr(new FunctionImpl<ControlGrid(ControlGrid::*)() const>(&ControlGrid::clonePtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(ControlGrid::*)()>(&ControlGrid::clearPtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(ControlGrid::*)()>(&ControlGrid::destroyPtr));
						case 11: return FunctionPtr(new FunctionImpl<ControlGrid&(ControlGrid::*)()>(&ControlGrid::acquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<ControlGrid&(ControlGrid::*)()>(&ControlGrid::unacquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(ControlGrid::*)() const>(&ControlGrid::isValidPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(ControlGrid::*)() const>(&ControlGrid::isOwnerPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(ControlGrid::*)() const>(&ControlGrid::isConstPtr));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(ControlGrid::*)() const>(&ControlGrid::getCountPtr));
						case 17: return FunctionPtr(new FunctionImpl<const void*(ControlGrid::*)() const>(&ControlGrid::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 7 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 4039, 280, 4039, 2051, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 1652, 3348, 1652, 4115, 4116 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 4 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3572, 2217, 3835, 3835, 2766, 3571, 2216, 2236, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4073, 4073, 1854, 4073, 2051, 1854, 310, 4073, 4073, 311, 311, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 4, 4, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
			static constexpr uint16_t function_arg_types[] = { 4039, 1854, 2051, 2051, 4039, 2051, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1652, 3972, 4115, 4116, 2993, 3379, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlGrid::constructor_bases[];
	constexpr uint16_t ReflectionControlGrid::constructor_arg_types[];
	constexpr uint16_t ReflectionControlGrid::constructor_arg_names[];
	constexpr uint16_t ReflectionControlGrid::constructor_arg_values[];
	constexpr uint8_t ReflectionControlGrid::function_flags[];
	constexpr uint16_t ReflectionControlGrid::function_names[];
	constexpr uint16_t ReflectionControlGrid::function_types[];
	constexpr uint16_t ReflectionControlGrid::function_bases[];
	constexpr uint16_t ReflectionControlGrid::function_arg_types[];
	constexpr uint16_t ReflectionControlGrid::function_arg_names[];
	constexpr uint16_t ReflectionControlGrid::function_arg_values[];
	constexpr uint16_t ReflectionControlGrid::callback_names[];
	constexpr uint16_t ReflectionControlGrid::callback_types[];
	constexpr uint16_t ReflectionControlGrid::callback_bases[];
	constexpr uint16_t ReflectionControlGrid::callback_arg_types[];
	constexpr uint16_t ReflectionControlGrid::callback_arg_names[];
	constexpr uint16_t ReflectionControlGrid::enum_names[];
	constexpr uint16_t ReflectionControlGrid::enum_bases[];
	constexpr uint16_t ReflectionControlGrid::enum_var_names[];
	static ReflectionControlGrid reflection_control_grid;
	
	// Tellusim::ControlGroup
	class ReflectionControlGroup : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlGroup::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlGroup, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlGroup, TypeList<Control*, bool>>({}, false));
						case 2: return ConstructorPtr(new ConstructorImpl<ControlGroup, TypeList<Control*, const char*, bool>>({}, {}, false));
						case 3: return ConstructorPtr(new ConstructorImpl<ControlGroup, TypeList<Control*, const String&, bool>>({}, {}, false));
						case 4: return ConstructorPtr(new ConstructorImpl<ControlGroup, TypeList<Control*, const char*, uint32_t, bool>>({}, {}, {}, false));
						case 5: return ConstructorPtr(new ConstructorImpl<ControlGroup, TypeList<Control*, const char*, uint32_t, float32_t, float32_t, bool>>({}, {}, {}, {}, {}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlGroup>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(bool, bool)>(&ControlGroup::setAbove, {}, true));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isAbove));
						case 2: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isBelow));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(bool)>(&ControlGroup::setFoldable));
						case 4: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isFoldable));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(bool)>(&ControlGroup::setExpanded));
						case 6: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isExpanded));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(bool)>(&ControlGroup::setBackground));
						case 8: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::getBackground));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(float32_t)>(&ControlGroup::setGroupRadius));
						case 10: return FunctionPtr(new FunctionImpl<float32_t(ControlGroup::*)() const>(&ControlGroup::getGroupRadius));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const Color&)>(&ControlGroup::setGroupColor));
						case 12: return FunctionPtr(new FunctionImpl<const Color&(ControlGroup::*)() const>(&ControlGroup::getGroupColor));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const StrokeStyle&)>(&ControlGroup::setStrokeStyle));
						case 14: return FunctionPtr(new FunctionImpl<const StrokeStyle&(ControlGroup::*)() const>(&ControlGroup::getStrokeStyleConst));
						case 15: return FunctionPtr(new FunctionImpl<const StrokeStyle&(ControlGroup::*)() const>(&ControlGroup::getStrokeStyle));
						case 16: return FunctionPtr(new FunctionImpl<StrokeStyle&(ControlGroup::*)()>(&ControlGroup::getStrokeStyle));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const GradientStyle&)>(&ControlGroup::setGradientStyle));
						case 18: return FunctionPtr(new FunctionImpl<const GradientStyle&(ControlGroup::*)() const>(&ControlGroup::getGradientStyleConst));
						case 19: return FunctionPtr(new FunctionImpl<const GradientStyle&(ControlGroup::*)() const>(&ControlGroup::getGradientStyle));
						case 20: return FunctionPtr(new FunctionImpl<GradientStyle&(ControlGroup::*)()>(&ControlGroup::getGradientStyle));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const char*)>(&ControlGroup::setFoldedText));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const String&)>(&ControlGroup::setFoldedText));
						case 23: return FunctionPtr(new FunctionImpl<String(ControlGroup::*)() const>(&ControlGroup::getFoldedText));
						case 24: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const char*)>(&ControlGroup::setExpandedText));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const String&)>(&ControlGroup::setExpandedText));
						case 26: return FunctionPtr(new FunctionImpl<String(ControlGroup::*)() const>(&ControlGroup::getExpandedText));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(uint32_t)>(&ControlGroup::setColumns));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(ControlGroup::*)() const>(&ControlGroup::getColumns));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const Vector2f&)>(&ControlGroup::setSpacing));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(float32_t, float32_t)>(&ControlGroup::setSpacing));
						case 31: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlGroup::*)() const>(&ControlGroup::getSpacing));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(uint32_t, float32_t)>(&ControlGroup::setColumnRatio));
						case 33: return FunctionPtr(new FunctionImpl<float32_t(ControlGroup::*)(uint32_t) const>(&ControlGroup::getColumnRatio));
						case 34: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlGroup::*)() const>(&ControlGroup::getControlsSize));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)(const ControlGroup::ClickedCallback&)>(&ControlGroup::setClickedCallback));
						case 36: return FunctionPtr(new FunctionImpl<ControlGroup::ClickedCallback(ControlGroup::*)() const>(&ControlGroup::getClickedCallback));
						case 37: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)()>(&ControlGroup::isClicked));
						case 38: return FunctionPtr(new FunctionImpl<CanvasRect(ControlGroup::*)()>(&ControlGroup::getCanvasRect));
						case 39: return FunctionPtr(new FunctionImpl<ControlGroup(ControlGroup::*)() const>(&ControlGroup::clonePtr));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)()>(&ControlGroup::clearPtr));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(ControlGroup::*)()>(&ControlGroup::destroyPtr));
						case 42: return FunctionPtr(new FunctionImpl<ControlGroup&(ControlGroup::*)()>(&ControlGroup::acquirePtr));
						case 43: return FunctionPtr(new FunctionImpl<ControlGroup&(ControlGroup::*)()>(&ControlGroup::unacquirePtr));
						case 44: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isValidPtr));
						case 45: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isOwnerPtr));
						case 46: return FunctionPtr(new FunctionImpl<bool(ControlGroup::*)() const>(&ControlGroup::isConstPtr));
						case 47: return FunctionPtr(new FunctionImpl<uint32_t(ControlGroup::*)() const>(&ControlGroup::getCountPtr));
						case 48: return FunctionPtr(new FunctionImpl<const void*(ControlGroup::*)() const>(&ControlGroup::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 5, 8, 12, 18 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 1585, 280, 1877, 1585, 280, 1841, 1585, 280, 1877, 4039, 1585, 280, 1877, 4039, 2051, 2051, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 1501, 3348, 4011, 1501, 3348, 4011, 1501, 3348, 4011, 1652, 1501, 3348, 4011, 1652, 4115, 4116, 1501 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3504, 3016, 3029, 3632, 3081, 3619, 3074, 3519, 2114, 3654, 2400, 3653, 2399, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 3633, 3633, 2346, 3621, 3621, 2323, 3572, 2217, 3835, 3835, 2766, 3571, 2216, 2236, 3559, 2196, 3045, 2183, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 2051, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 4039, 4073, 4073, 1854, 4073, 2051, 1854, 4073, 314, 1585, 234, 312, 4073, 4073, 313, 313, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 11, 11, 12, 13, 13, 14, 14, 15, 17, 17, 19, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1585, 1585, 1585, 2051, 1721, 1843, 1779, 1877, 1841, 1877, 1841, 4039, 1854, 2051, 2051, 4039, 2051, 4039, 1736 };
			static constexpr uint16_t function_arg_names[] = { 1501, 4011, 2064, 2013, 1568, 3373, 1650, 3992, 3992, 4011, 4011, 4011, 4011, 1652, 3972, 4115, 4116, 2993, 3379, 2993, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 4033, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 249 };
			static constexpr uint16_t callback_types[] = { 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1 };
			static constexpr uint16_t callback_arg_types[] = { 312 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlGroup::constructor_bases[];
	constexpr uint16_t ReflectionControlGroup::constructor_arg_types[];
	constexpr uint16_t ReflectionControlGroup::constructor_arg_names[];
	constexpr uint16_t ReflectionControlGroup::constructor_arg_values[];
	constexpr uint8_t ReflectionControlGroup::function_flags[];
	constexpr uint16_t ReflectionControlGroup::function_names[];
	constexpr uint16_t ReflectionControlGroup::function_types[];
	constexpr uint16_t ReflectionControlGroup::function_bases[];
	constexpr uint16_t ReflectionControlGroup::function_arg_types[];
	constexpr uint16_t ReflectionControlGroup::function_arg_names[];
	constexpr uint16_t ReflectionControlGroup::function_arg_values[];
	constexpr uint16_t ReflectionControlGroup::callback_names[];
	constexpr uint16_t ReflectionControlGroup::callback_types[];
	constexpr uint16_t ReflectionControlGroup::callback_bases[];
	constexpr uint16_t ReflectionControlGroup::callback_arg_types[];
	constexpr uint16_t ReflectionControlGroup::callback_arg_names[];
	constexpr uint16_t ReflectionControlGroup::enum_names[];
	constexpr uint16_t ReflectionControlGroup::enum_bases[];
	constexpr uint16_t ReflectionControlGroup::enum_var_names[];
	static ReflectionControlGroup reflection_control_group;
	
	// Tellusim::ControlPanel
	class ReflectionControlPanel : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlPanel::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_rect;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlPanel, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlPanel, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlPanel, TypeList<Control*, uint32_t>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlPanel, TypeList<Control*, uint32_t, float32_t, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlPanel>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlPanel::*)(uint32_t)>(&ControlPanel::setColumns));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(ControlPanel::*)() const>(&ControlPanel::getColumns));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlPanel::*)(const Vector2f&)>(&ControlPanel::setSpacing));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlPanel::*)(float32_t, float32_t)>(&ControlPanel::setSpacing));
						case 4: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlPanel::*)() const>(&ControlPanel::getSpacing));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlPanel::*)(uint32_t, float32_t)>(&ControlPanel::setColumnRatio));
						case 6: return FunctionPtr(new FunctionImpl<float32_t(ControlPanel::*)(uint32_t) const>(&ControlPanel::getColumnRatio));
						case 7: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlPanel::*)() const>(&ControlPanel::getControlsSize));
						case 8: return FunctionPtr(new FunctionImpl<ControlPanel(ControlPanel::*)() const>(&ControlPanel::clonePtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(ControlPanel::*)()>(&ControlPanel::clearPtr));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(ControlPanel::*)()>(&ControlPanel::destroyPtr));
						case 11: return FunctionPtr(new FunctionImpl<ControlPanel&(ControlPanel::*)()>(&ControlPanel::acquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<ControlPanel&(ControlPanel::*)()>(&ControlPanel::unacquirePtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(ControlPanel::*)() const>(&ControlPanel::isValidPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(ControlPanel::*)() const>(&ControlPanel::isOwnerPtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(ControlPanel::*)() const>(&ControlPanel::isConstPtr));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(ControlPanel::*)() const>(&ControlPanel::getCountPtr));
						case 17: return FunctionPtr(new FunctionImpl<const void*(ControlPanel::*)() const>(&ControlPanel::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 7 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 4039, 280, 4039, 2051, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 1652, 3348, 1652, 4115, 4116 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3572, 2217, 3835, 3835, 2766, 3571, 2216, 2236, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4039, 4073, 4073, 1854, 4073, 2051, 1854, 315, 4073, 4073, 316, 316, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 4, 4, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
			static constexpr uint16_t function_arg_types[] = { 4039, 1854, 2051, 2051, 4039, 2051, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1652, 3972, 4115, 4116, 2993, 3379, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlPanel::constructor_bases[];
	constexpr uint16_t ReflectionControlPanel::constructor_arg_types[];
	constexpr uint16_t ReflectionControlPanel::constructor_arg_names[];
	constexpr uint16_t ReflectionControlPanel::constructor_arg_values[];
	constexpr uint8_t ReflectionControlPanel::function_flags[];
	constexpr uint16_t ReflectionControlPanel::function_names[];
	constexpr uint16_t ReflectionControlPanel::function_types[];
	constexpr uint16_t ReflectionControlPanel::function_bases[];
	constexpr uint16_t ReflectionControlPanel::function_arg_types[];
	constexpr uint16_t ReflectionControlPanel::function_arg_names[];
	constexpr uint16_t ReflectionControlPanel::function_arg_values[];
	constexpr uint16_t ReflectionControlPanel::callback_names[];
	constexpr uint16_t ReflectionControlPanel::callback_types[];
	constexpr uint16_t ReflectionControlPanel::callback_bases[];
	constexpr uint16_t ReflectionControlPanel::callback_arg_types[];
	constexpr uint16_t ReflectionControlPanel::callback_arg_names[];
	constexpr uint16_t ReflectionControlPanel::enum_names[];
	constexpr uint16_t ReflectionControlPanel::enum_bases[];
	constexpr uint16_t ReflectionControlPanel::enum_var_names[];
	static ReflectionControlPanel reflection_control_panel;
	
	// Tellusim::ControlDialog
	class ReflectionControlDialog : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlDialog::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_panel;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlDialog, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlDialog, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlDialog, TypeList<Control*, uint32_t>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlDialog, TypeList<Control*, uint32_t, float32_t, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlDialog>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)(bool)>(&ControlDialog::setConstrained));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)() const>(&ControlDialog::isConstrained));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)(bool)>(&ControlDialog::setResizable));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)() const>(&ControlDialog::isResizable));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)(bool)>(&ControlDialog::setMoveable));
						case 5: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)() const>(&ControlDialog::isMoveable));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)(float32_t)>(&ControlDialog::setResizeArea));
						case 7: return FunctionPtr(new FunctionImpl<float32_t(ControlDialog::*)() const>(&ControlDialog::getResizeArea));
						case 8: return FunctionPtr(new FunctionImpl<Control::Align(ControlDialog::*)() const>(&ControlDialog::getResizeAlign));
						case 9: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)(Control::Align) const>(&ControlDialog::hasResizeAlign));
						case 10: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)(Control::Align) const>(&ControlDialog::hasResizeAligns));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)(const Vector2f&)>(&ControlDialog::setMousePosition));
						case 12: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlDialog::*)() const>(&ControlDialog::getMousePosition));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)(const ControlDialog::UpdatedCallback&)>(&ControlDialog::setUpdatedCallback));
						case 14: return FunctionPtr(new FunctionImpl<ControlDialog::UpdatedCallback(ControlDialog::*)() const>(&ControlDialog::getUpdatedCallback));
						case 15: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)()>(&ControlDialog::isUpdated));
						case 16: return FunctionPtr(new FunctionImpl<ControlDialog(ControlDialog::*)() const>(&ControlDialog::clonePtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)()>(&ControlDialog::clearPtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(ControlDialog::*)()>(&ControlDialog::destroyPtr));
						case 19: return FunctionPtr(new FunctionImpl<ControlDialog&(ControlDialog::*)()>(&ControlDialog::acquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<ControlDialog&(ControlDialog::*)()>(&ControlDialog::unacquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)() const>(&ControlDialog::isValidPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)() const>(&ControlDialog::isOwnerPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(ControlDialog::*)() const>(&ControlDialog::isConstPtr));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(ControlDialog::*)() const>(&ControlDialog::getCountPtr));
						case 25: return FunctionPtr(new FunctionImpl<const void*(ControlDialog::*)() const>(&ControlDialog::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 7 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 4039, 280, 4039, 2051, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 1652, 3348, 1652, 4115, 4116 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3578, 3054, 3803, 3159, 3747, 3130, 3804, 2710, 2709, 2967, 2968, 3743, 2548, 3925, 2892, 3200, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 1585, 4073, 2051, 281, 1585, 1585, 4073, 1854, 4073, 303, 1585, 301, 4073, 4073, 302, 302, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1585, 2051, 281, 281, 1854, 1732 };
			static constexpr uint16_t function_arg_names[] = { 1886, 3467, 3285, 1554, 1546, 1548, 3355, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 1395 };
			static constexpr uint16_t callback_types[] = { 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1 };
			static constexpr uint16_t callback_arg_types[] = { 301 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlDialog::constructor_bases[];
	constexpr uint16_t ReflectionControlDialog::constructor_arg_types[];
	constexpr uint16_t ReflectionControlDialog::constructor_arg_names[];
	constexpr uint16_t ReflectionControlDialog::constructor_arg_values[];
	constexpr uint8_t ReflectionControlDialog::function_flags[];
	constexpr uint16_t ReflectionControlDialog::function_names[];
	constexpr uint16_t ReflectionControlDialog::function_types[];
	constexpr uint16_t ReflectionControlDialog::function_bases[];
	constexpr uint16_t ReflectionControlDialog::function_arg_types[];
	constexpr uint16_t ReflectionControlDialog::function_arg_names[];
	constexpr uint16_t ReflectionControlDialog::function_arg_values[];
	constexpr uint16_t ReflectionControlDialog::callback_names[];
	constexpr uint16_t ReflectionControlDialog::callback_types[];
	constexpr uint16_t ReflectionControlDialog::callback_bases[];
	constexpr uint16_t ReflectionControlDialog::callback_arg_types[];
	constexpr uint16_t ReflectionControlDialog::callback_arg_names[];
	constexpr uint16_t ReflectionControlDialog::enum_names[];
	constexpr uint16_t ReflectionControlDialog::enum_bases[];
	constexpr uint16_t ReflectionControlDialog::enum_var_names[];
	static ReflectionControlDialog reflection_control_dialog;
	
	// Tellusim::ControlWindow
	class ReflectionControlWindow : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlWindow::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_dialog;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlWindow, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlWindow, TypeList<ControlRoot*, Window&, Window&>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlWindow, TypeList<ControlRoot*, Window&, Window&, uint32_t>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlWindow, TypeList<ControlRoot*, Window&, Window&, uint32_t, float32_t, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlWindow>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<Window(ControlWindow::*)() const>(&ControlWindow::getParentWindow));
						case 1: return FunctionPtr(new FunctionImpl<Window(ControlWindow::*)() const>(&ControlWindow::getDialogWindow));
						case 2: return FunctionPtr(new FunctionImpl<ControlWindow(ControlWindow::*)() const>(&ControlWindow::clonePtr));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlWindow::*)()>(&ControlWindow::clearPtr));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlWindow::*)()>(&ControlWindow::destroyPtr));
						case 5: return FunctionPtr(new FunctionImpl<ControlWindow&(ControlWindow::*)()>(&ControlWindow::acquirePtr));
						case 6: return FunctionPtr(new FunctionImpl<ControlWindow&(ControlWindow::*)()>(&ControlWindow::unacquirePtr));
						case 7: return FunctionPtr(new FunctionImpl<bool(ControlWindow::*)() const>(&ControlWindow::isValidPtr));
						case 8: return FunctionPtr(new FunctionImpl<bool(ControlWindow::*)() const>(&ControlWindow::isOwnerPtr));
						case 9: return FunctionPtr(new FunctionImpl<bool(ControlWindow::*)() const>(&ControlWindow::isConstPtr));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(ControlWindow::*)() const>(&ControlWindow::getCountPtr));
						case 11: return FunctionPtr(new FunctionImpl<const void*(ControlWindow::*)() const>(&ControlWindow::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 3, 7, 13 };
			static constexpr uint16_t constructor_arg_types[] = { 325, 1472, 1472, 325, 1472, 1472, 4039, 325, 1472, 1472, 4039, 2051, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 3471, 3348, 4090, 3471, 3348, 4090, 1652, 3471, 3348, 4090, 1652, 4115, 4116 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2654, 2300, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1471, 1471, 351, 4073, 4073, 352, 352, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t function_arg_types[] = { 0 };
			static constexpr uint16_t function_arg_names[] = { 0 };
			static constexpr uint16_t function_arg_values[] = { 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlWindow::constructor_bases[];
	constexpr uint16_t ReflectionControlWindow::constructor_arg_types[];
	constexpr uint16_t ReflectionControlWindow::constructor_arg_names[];
	constexpr uint16_t ReflectionControlWindow::constructor_arg_values[];
	constexpr uint8_t ReflectionControlWindow::function_flags[];
	constexpr uint16_t ReflectionControlWindow::function_names[];
	constexpr uint16_t ReflectionControlWindow::function_types[];
	constexpr uint16_t ReflectionControlWindow::function_bases[];
	constexpr uint16_t ReflectionControlWindow::function_arg_types[];
	constexpr uint16_t ReflectionControlWindow::function_arg_names[];
	constexpr uint16_t ReflectionControlWindow::function_arg_values[];
	constexpr uint16_t ReflectionControlWindow::callback_names[];
	constexpr uint16_t ReflectionControlWindow::callback_types[];
	constexpr uint16_t ReflectionControlWindow::callback_bases[];
	constexpr uint16_t ReflectionControlWindow::callback_arg_types[];
	constexpr uint16_t ReflectionControlWindow::callback_arg_names[];
	constexpr uint16_t ReflectionControlWindow::enum_names[];
	constexpr uint16_t ReflectionControlWindow::enum_bases[];
	constexpr uint16_t ReflectionControlWindow::enum_var_names[];
	static ReflectionControlWindow reflection_control_window;
	
	// Tellusim::ControlCheck
	class ReflectionControlCheck : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlCheck::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlCheck, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlCheck, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlCheck, TypeList<Control*, const char*>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlCheck, TypeList<Control*, const String&>>());
						case 4: return ConstructorPtr(new ConstructorImpl<ControlCheck, TypeList<Control*, const char*, bool>>());
						case 5: return ConstructorPtr(new ConstructorImpl<ControlCheck, TypeList<Control*, const String&, bool>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlCheck>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)(const char*)>(&ControlCheck::setCheckText));
						case 1: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)(const String&)>(&ControlCheck::setCheckText));
						case 2: return FunctionPtr(new FunctionImpl<String(ControlCheck::*)() const>(&ControlCheck::getCheckText));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)(const Color&)>(&ControlCheck::setCheckColor));
						case 4: return FunctionPtr(new FunctionImpl<const Color&(ControlCheck::*)() const>(&ControlCheck::getCheckColor));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)(const Color&)>(&ControlCheck::setCheckedColor));
						case 6: return FunctionPtr(new FunctionImpl<const Color&(ControlCheck::*)() const>(&ControlCheck::getCheckedColor));
						case 7: return FunctionPtr(new FunctionImpl<bool(ControlCheck::*)(bool)>(&ControlCheck::switchChecked, false));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)(bool, bool)>(&ControlCheck::setChecked, {}, false));
						case 9: return FunctionPtr(new FunctionImpl<bool(ControlCheck::*)() const>(&ControlCheck::isChecked));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)(const ControlCheck::ClickedCallback&)>(&ControlCheck::setClickedCallback));
						case 11: return FunctionPtr(new FunctionImpl<ControlCheck::ClickedCallback(ControlCheck::*)() const>(&ControlCheck::getClickedCallback));
						case 12: return FunctionPtr(new FunctionImpl<bool(ControlCheck::*)()>(&ControlCheck::isClicked));
						case 13: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlCheck::*)()>(&ControlCheck::getCanvasMesh));
						case 14: return FunctionPtr(new FunctionImpl<ControlCheck(ControlCheck::*)() const>(&ControlCheck::clonePtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)()>(&ControlCheck::clearPtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(ControlCheck::*)()>(&ControlCheck::destroyPtr));
						case 17: return FunctionPtr(new FunctionImpl<ControlCheck&(ControlCheck::*)()>(&ControlCheck::acquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<ControlCheck&(ControlCheck::*)()>(&ControlCheck::unacquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(ControlCheck::*)() const>(&ControlCheck::isValidPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(ControlCheck::*)() const>(&ControlCheck::isOwnerPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlCheck::*)() const>(&ControlCheck::isConstPtr));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(ControlCheck::*)() const>(&ControlCheck::getCountPtr));
						case 23: return FunctionPtr(new FunctionImpl<const void*(ControlCheck::*)() const>(&ControlCheck::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5, 8, 11 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1877, 280, 1841, 280, 1877, 1585, 280, 1841, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4011, 3348, 4011, 3348, 4011, 1608, 3348, 4011, 1608 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3552, 3552, 2188, 3551, 2187, 3554, 2189, 3996, 3553, 3043, 3559, 2196, 3045, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 4073, 1274, 4073, 1721, 4073, 1721, 1585, 4073, 1585, 4073, 296, 1585, 232, 294, 4073, 4073, 295, 295, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 2, 2, 3, 3, 4, 4, 5, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
			static constexpr uint16_t function_arg_types[] = { 1877, 1841, 1721, 1721, 1585, 1585, 1585, 1729 };
			static constexpr uint16_t function_arg_names[] = { 4011, 4011, 1650, 1650, 1601, 1608, 1601, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 2016, 0, 2016, 0 };
			static constexpr uint16_t callback_names[] = { 249 };
			static constexpr uint16_t callback_types[] = { 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1 };
			static constexpr uint16_t callback_arg_types[] = { 294 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlCheck::constructor_bases[];
	constexpr uint16_t ReflectionControlCheck::constructor_arg_types[];
	constexpr uint16_t ReflectionControlCheck::constructor_arg_names[];
	constexpr uint16_t ReflectionControlCheck::constructor_arg_values[];
	constexpr uint8_t ReflectionControlCheck::function_flags[];
	constexpr uint16_t ReflectionControlCheck::function_names[];
	constexpr uint16_t ReflectionControlCheck::function_types[];
	constexpr uint16_t ReflectionControlCheck::function_bases[];
	constexpr uint16_t ReflectionControlCheck::function_arg_types[];
	constexpr uint16_t ReflectionControlCheck::function_arg_names[];
	constexpr uint16_t ReflectionControlCheck::function_arg_values[];
	constexpr uint16_t ReflectionControlCheck::callback_names[];
	constexpr uint16_t ReflectionControlCheck::callback_types[];
	constexpr uint16_t ReflectionControlCheck::callback_bases[];
	constexpr uint16_t ReflectionControlCheck::callback_arg_types[];
	constexpr uint16_t ReflectionControlCheck::callback_arg_names[];
	constexpr uint16_t ReflectionControlCheck::enum_names[];
	constexpr uint16_t ReflectionControlCheck::enum_bases[];
	constexpr uint16_t ReflectionControlCheck::enum_var_names[];
	static ReflectionControlCheck reflection_control_check;
	
	// Tellusim::ControlCombo
	class ReflectionControlCombo : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlCombo::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlCombo, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlCombo, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlCombo, TypeList<Control*, const InitializerList<const char*>&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlCombo, TypeList<Control*, const InitializerList<const char*>&, uint32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlCombo>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(bool)>(&ControlCombo::setTextEnabled));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)() const>(&ControlCombo::isTextEnabled));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(bool)>(&ControlCombo::setMultiSelection));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)() const>(&ControlCombo::isMultiSelection));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(const char*)>(&ControlCombo::setComboText));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(const String&)>(&ControlCombo::setComboText));
						case 6: return FunctionPtr(new FunctionImpl<String(ControlCombo::*)() const>(&ControlCombo::getComboText));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(const Color&)>(&ControlCombo::setComboColor));
						case 8: return FunctionPtr(new FunctionImpl<const Color&(ControlCombo::*)() const>(&ControlCombo::getComboColor));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(float32_t)>(&ControlCombo::setItemsSpacing));
						case 10: return FunctionPtr(new FunctionImpl<float32_t(ControlCombo::*)() const>(&ControlCombo::getItemsSpacing));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)()>(&ControlCombo::clearItems));
						case 12: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)(const char*)>(&ControlCombo::addItem));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)(const String&)>(&ControlCombo::addItem));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, const char*)>(&ControlCombo::addItem));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, const String&)>(&ControlCombo::addItem));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(const InitializerList<const char*>&)>(&ControlCombo::addItems));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t)>(&ControlCombo::removeItem));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)() const>(&ControlCombo::getNumItems));
						case 19: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)(uint32_t)>(&ControlCombo::switchItemSelected));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, bool)>(&ControlCombo::setItemSelected));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)(uint32_t) const>(&ControlCombo::isItemSelected));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, const char*)>(&ControlCombo::setItemText));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, const String&)>(&ControlCombo::setItemText));
						case 24: return FunctionPtr(new FunctionImpl<String(ControlCombo::*)(uint32_t) const>(&ControlCombo::getItemText));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)(const char*) const>(&ControlCombo::findItemText));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)(const String&) const>(&ControlCombo::findItemText));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, const Color&)>(&ControlCombo::setItemColor));
						case 28: return FunctionPtr(new FunctionImpl<const Color&(ControlCombo::*)(uint32_t) const>(&ControlCombo::getItemColor));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(uint32_t, bool)>(&ControlCombo::setCurrentIndex, {}, false));
						case 30: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)(const char*, bool)>(&ControlCombo::setCurrentText, {}, false));
						case 31: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)(const String&, bool)>(&ControlCombo::setCurrentText, {}, false));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)() const>(&ControlCombo::getCurrentIndex));
						case 33: return FunctionPtr(new FunctionImpl<String(ControlCombo::*)() const>(&ControlCombo::getCurrentText));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(const ControlCombo::ClickedCallback&)>(&ControlCombo::setClickedCallback));
						case 35: return FunctionPtr(new FunctionImpl<ControlCombo::ClickedCallback(ControlCombo::*)() const>(&ControlCombo::getClickedCallback));
						case 36: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)()>(&ControlCombo::isClicked));
						case 37: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)(const ControlCombo::ChangedCallback&)>(&ControlCombo::setChangedCallback));
						case 38: return FunctionPtr(new FunctionImpl<ControlCombo::ChangedCallback(ControlCombo::*)() const>(&ControlCombo::getChangedCallback));
						case 39: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)()>(&ControlCombo::isChanged));
						case 40: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlCombo::*)()>(&ControlCombo::getCanvasMesh));
						case 41: return FunctionPtr(new FunctionImpl<ControlCombo(ControlCombo::*)() const>(&ControlCombo::clonePtr));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)()>(&ControlCombo::clearPtr));
						case 43: return FunctionPtr(new FunctionVoidImpl<void(ControlCombo::*)()>(&ControlCombo::destroyPtr));
						case 44: return FunctionPtr(new FunctionImpl<ControlCombo&(ControlCombo::*)()>(&ControlCombo::acquirePtr));
						case 45: return FunctionPtr(new FunctionImpl<ControlCombo&(ControlCombo::*)()>(&ControlCombo::unacquirePtr));
						case 46: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)() const>(&ControlCombo::isValidPtr));
						case 47: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)() const>(&ControlCombo::isOwnerPtr));
						case 48: return FunctionPtr(new FunctionImpl<bool(ControlCombo::*)() const>(&ControlCombo::isConstPtr));
						case 49: return FunctionPtr(new FunctionImpl<uint32_t(ControlCombo::*)() const>(&ControlCombo::getCountPtr));
						case 50: return FunctionPtr(new FunctionImpl<const void*(ControlCombo::*)() const>(&ControlCombo::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 6 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1790, 280, 1790, 4039 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 3225, 3348, 3225, 2993 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3883, 3189, 3748, 3131, 3574, 3574, 2219, 3573, 2218, 3693, 2458, 1626, 1523, 1523, 1523, 1523, 1526, 3432, 2591, 3999, 3689, 3110, 3690, 3690, 2455, 2035, 2035, 3681, 2448, 3587, 3589, 3589, 2247, 2249, 3559, 2196, 3045, 3550, 2186, 3041, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 4073, 1274, 4073, 1721, 4073, 2051, 4073, 4039, 4039, 4073, 4073, 4073, 4073, 4039, 1585, 4073, 1585, 4073, 4073, 1274, 4039, 4039, 4073, 1721, 4073, 1585, 1585, 4039, 1274, 4073, 300, 1585, 4073, 299, 1585, 232, 297, 4073, 4073, 298, 298, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 6, 7, 8, 10, 12, 13, 14, 14, 15, 17, 18, 20, 22, 23, 24, 25, 27, 28, 30, 32, 34, 34, 34, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1877, 1841, 1721, 2051, 1877, 1841, 4039, 1877, 4039, 1841, 1790, 4039, 4039, 4039, 1585, 4039, 4039, 1877, 4039, 1841, 4039, 1877, 1841, 4039, 1721, 4039, 4039, 1585, 1877, 1585, 1841, 1585, 1731, 1730 };
			static constexpr uint16_t function_arg_names[] = { 1996, 3286, 4011, 4011, 1650, 3972, 4011, 4011, 2993, 4011, 2993, 4011, 3225, 2993, 2993, 2993, 3498, 2993, 2993, 4011, 2993, 4011, 2993, 4011, 4011, 2993, 1650, 2993, 2993, 1601, 4011, 1601, 4011, 1601, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 2016, 0, 2016, 0, 0 };
			static constexpr uint16_t callback_names[] = { 249, 247 };
			static constexpr uint16_t callback_types[] = { 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1, 2 };
			static constexpr uint16_t callback_arg_types[] = { 297, 297 };
			static constexpr uint16_t callback_arg_names[] = { 0, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlCombo::constructor_bases[];
	constexpr uint16_t ReflectionControlCombo::constructor_arg_types[];
	constexpr uint16_t ReflectionControlCombo::constructor_arg_names[];
	constexpr uint16_t ReflectionControlCombo::constructor_arg_values[];
	constexpr uint8_t ReflectionControlCombo::function_flags[];
	constexpr uint16_t ReflectionControlCombo::function_names[];
	constexpr uint16_t ReflectionControlCombo::function_types[];
	constexpr uint16_t ReflectionControlCombo::function_bases[];
	constexpr uint16_t ReflectionControlCombo::function_arg_types[];
	constexpr uint16_t ReflectionControlCombo::function_arg_names[];
	constexpr uint16_t ReflectionControlCombo::function_arg_values[];
	constexpr uint16_t ReflectionControlCombo::callback_names[];
	constexpr uint16_t ReflectionControlCombo::callback_types[];
	constexpr uint16_t ReflectionControlCombo::callback_bases[];
	constexpr uint16_t ReflectionControlCombo::callback_arg_types[];
	constexpr uint16_t ReflectionControlCombo::callback_arg_names[];
	constexpr uint16_t ReflectionControlCombo::enum_names[];
	constexpr uint16_t ReflectionControlCombo::enum_bases[];
	constexpr uint16_t ReflectionControlCombo::enum_var_names[];
	static ReflectionControlCombo reflection_control_combo;
	
	// Tellusim::ControlButton
	class ReflectionControlButton : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlButton::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlButton, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlButton, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlButton, TypeList<Control*, const char*>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlButton, TypeList<Control*, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlButton>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(bool)>(&ControlButton::setBackground));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)() const>(&ControlButton::getBackground));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(CanvasElement::Mode)>(&ControlButton::setButtonMode));
						case 3: return FunctionPtr(new FunctionImpl<CanvasElement::Mode(ControlButton::*)() const>(&ControlButton::getButtonMode));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(float32_t)>(&ControlButton::setButtonRadius));
						case 5: return FunctionPtr(new FunctionImpl<float32_t(ControlButton::*)() const>(&ControlButton::getButtonRadius));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(const Color&)>(&ControlButton::setButtonColor));
						case 7: return FunctionPtr(new FunctionImpl<const Color&(ControlButton::*)() const>(&ControlButton::getButtonColor));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(const StrokeStyle&)>(&ControlButton::setStrokeStyle));
						case 9: return FunctionPtr(new FunctionImpl<const StrokeStyle&(ControlButton::*)() const>(&ControlButton::getStrokeStyleConst));
						case 10: return FunctionPtr(new FunctionImpl<const StrokeStyle&(ControlButton::*)() const>(&ControlButton::getStrokeStyle));
						case 11: return FunctionPtr(new FunctionImpl<StrokeStyle&(ControlButton::*)()>(&ControlButton::getStrokeStyle));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(const GradientStyle&)>(&ControlButton::setGradientStyle));
						case 13: return FunctionPtr(new FunctionImpl<const GradientStyle&(ControlButton::*)() const>(&ControlButton::getGradientStyleConst));
						case 14: return FunctionPtr(new FunctionImpl<const GradientStyle&(ControlButton::*)() const>(&ControlButton::getGradientStyle));
						case 15: return FunctionPtr(new FunctionImpl<GradientStyle&(ControlButton::*)()>(&ControlButton::getGradientStyle));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(const ControlButton::PressedCallback&)>(&ControlButton::setPressedCallback));
						case 17: return FunctionPtr(new FunctionImpl<ControlButton::PressedCallback(ControlButton::*)() const>(&ControlButton::getPressedCallback));
						case 18: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)()>(&ControlButton::isPressed));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(const ControlButton::ReleasedCallback&)>(&ControlButton::setReleasedCallback));
						case 20: return FunctionPtr(new FunctionImpl<ControlButton::ReleasedCallback(ControlButton::*)() const>(&ControlButton::getReleasedCallback));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)()>(&ControlButton::isReleased));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)(const ControlButton::ClickedCallback&)>(&ControlButton::setClickedCallback));
						case 23: return FunctionPtr(new FunctionImpl<ControlButton::ClickedCallback(ControlButton::*)() const>(&ControlButton::getClickedCallback));
						case 24: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)()>(&ControlButton::isClicked));
						case 25: return FunctionPtr(new FunctionImpl<CanvasRect(ControlButton::*)()>(&ControlButton::getCanvasRect));
						case 26: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlButton::*)()>(&ControlButton::getCanvasMesh));
						case 27: return FunctionPtr(new FunctionImpl<ControlButton(ControlButton::*)() const>(&ControlButton::clonePtr));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)()>(&ControlButton::clearPtr));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(ControlButton::*)()>(&ControlButton::destroyPtr));
						case 30: return FunctionPtr(new FunctionImpl<ControlButton&(ControlButton::*)()>(&ControlButton::acquirePtr));
						case 31: return FunctionPtr(new FunctionImpl<ControlButton&(ControlButton::*)()>(&ControlButton::unacquirePtr));
						case 32: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)() const>(&ControlButton::isValidPtr));
						case 33: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)() const>(&ControlButton::isOwnerPtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(ControlButton::*)() const>(&ControlButton::isConstPtr));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(ControlButton::*)() const>(&ControlButton::getCountPtr));
						case 36: return FunctionPtr(new FunctionImpl<const void*(ControlButton::*)() const>(&ControlButton::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1877, 280, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4011, 3348, 4011 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3519, 2114, 3540, 2161, 3543, 2164, 3539, 2160, 3859, 2799, 2798, 2798, 3652, 2398, 2397, 2397, 3788, 2681, 3152, 3799, 2703, 3158, 3559, 2196, 3045, 2183, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 227, 4073, 2051, 4073, 1721, 4073, 1843, 1843, 1278, 4073, 1779, 1779, 803, 4073, 292, 1585, 4073, 293, 1585, 4073, 291, 1585, 234, 232, 289, 4073, 4073, 290, 290, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 };
			static constexpr uint16_t function_arg_types[] = { 1585, 227, 2051, 1721, 1843, 1779, 1727, 1728, 1726 };
			static constexpr uint16_t function_arg_names[] = { 1568, 3275, 3373, 1650, 3992, 3992, 2074, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 1153, 1183, 249 };
			static constexpr uint16_t callback_types[] = { 4073, 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 3, 6, 7 };
			static constexpr uint16_t callback_arg_types[] = { 289, 2051, 2051, 289, 2051, 2051, 289 };
			static constexpr uint16_t callback_arg_names[] = { 0, 4115, 4116, 0, 4115, 4116, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlButton::constructor_bases[];
	constexpr uint16_t ReflectionControlButton::constructor_arg_types[];
	constexpr uint16_t ReflectionControlButton::constructor_arg_names[];
	constexpr uint16_t ReflectionControlButton::constructor_arg_values[];
	constexpr uint8_t ReflectionControlButton::function_flags[];
	constexpr uint16_t ReflectionControlButton::function_names[];
	constexpr uint16_t ReflectionControlButton::function_types[];
	constexpr uint16_t ReflectionControlButton::function_bases[];
	constexpr uint16_t ReflectionControlButton::function_arg_types[];
	constexpr uint16_t ReflectionControlButton::function_arg_names[];
	constexpr uint16_t ReflectionControlButton::function_arg_values[];
	constexpr uint16_t ReflectionControlButton::callback_names[];
	constexpr uint16_t ReflectionControlButton::callback_types[];
	constexpr uint16_t ReflectionControlButton::callback_bases[];
	constexpr uint16_t ReflectionControlButton::callback_arg_types[];
	constexpr uint16_t ReflectionControlButton::callback_arg_names[];
	constexpr uint16_t ReflectionControlButton::enum_names[];
	constexpr uint16_t ReflectionControlButton::enum_bases[];
	constexpr uint16_t ReflectionControlButton::enum_var_names[];
	static ReflectionControlButton reflection_control_button;
	
	// Tellusim::ControlSlider
	class ReflectionControlSlider : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlSlider::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const String&>>());
						case 4: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*, uint32_t>>());
						case 5: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*, uint32_t, float64_t>>());
						case 6: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*, uint32_t, float64_t, float64_t, float64_t>>());
						case 7: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*, float64_t, float64_t, float64_t>>());
						case 8: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*, uint32_t, uint32_t, uint32_t>>());
						case 9: return ConstructorPtr(new ConstructorImpl<ControlSlider, TypeList<Control*, const char*, int32_t, int32_t, int32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlSlider>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(bool)>(&ControlSlider::setConstrained));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)() const>(&ControlSlider::isConstrained));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(bool)>(&ControlSlider::setTextEnabled));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)() const>(&ControlSlider::isTextEnabled));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const Color&)>(&ControlSlider::setSliderColor));
						case 5: return FunctionPtr(new FunctionImpl<const Color&(ControlSlider::*)() const>(&ControlSlider::getSliderColor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(uint32_t)>(&ControlSlider::setDigits));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(ControlSlider::*)() const>(&ControlSlider::getDigits));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(float64_t)>(&ControlSlider::setStep));
						case 9: return FunctionPtr(new FunctionImpl<float64_t(ControlSlider::*)() const>(&ControlSlider::getStep));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(float64_t)>(&ControlSlider::setBase));
						case 11: return FunctionPtr(new FunctionImpl<float64_t(ControlSlider::*)() const>(&ControlSlider::getBase));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const char*)>(&ControlSlider::setFormat));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const String&)>(&ControlSlider::setFormat));
						case 14: return FunctionPtr(new FunctionImpl<String(ControlSlider::*)() const>(&ControlSlider::getFormat));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(float64_t, bool, bool)>(&ControlSlider::setValue, {}, false, false));
						case 16: return FunctionPtr(new FunctionImpl<float64_t(ControlSlider::*)(bool) const>(&ControlSlider::getValue, false));
						case 17: return FunctionPtr(new FunctionImpl<float32_t(ControlSlider::*)(bool) const>(&ControlSlider::getValuef32, false));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(ControlSlider::*)(bool) const>(&ControlSlider::getValueu32, false));
						case 19: return FunctionPtr(new FunctionImpl<int32_t(ControlSlider::*)(bool) const>(&ControlSlider::getValuei32, false));
						case 20: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(float64_t, float64_t, bool)>(&ControlSlider::setRange, {}, {}, false));
						case 21: return FunctionPtr(new FunctionImpl<float64_t(ControlSlider::*)(bool) const>(&ControlSlider::getMinRange, false));
						case 22: return FunctionPtr(new FunctionImpl<float64_t(ControlSlider::*)(bool) const>(&ControlSlider::getMaxRange, false));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(float32_t)>(&ControlSlider::setHandleSize));
						case 24: return FunctionPtr(new FunctionImpl<float32_t(ControlSlider::*)() const>(&ControlSlider::getHandleSize));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::FormatCallback&)>(&ControlSlider::setFormatCallback));
						case 26: return FunctionPtr(new FunctionImpl<ControlSlider::FormatCallback(ControlSlider::*)() const>(&ControlSlider::getFormatCallback));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::PressedCallback&)>(&ControlSlider::setPressedCallback));
						case 28: return FunctionPtr(new FunctionImpl<ControlSlider::PressedCallback(ControlSlider::*)() const>(&ControlSlider::getPressedCallback));
						case 29: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)()>(&ControlSlider::isPressed));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::ReleasedCallback&)>(&ControlSlider::setReleasedCallback));
						case 31: return FunctionPtr(new FunctionImpl<ControlSlider::ReleasedCallback(ControlSlider::*)() const>(&ControlSlider::getReleasedCallback));
						case 32: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)()>(&ControlSlider::isReleased));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::ClickedCallback&)>(&ControlSlider::setClickedCallback));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::ClickedCallback&)>(&ControlSlider::setClicked2Callback));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::ClickedCallback&)>(&ControlSlider::setClickedRightCallback));
						case 36: return FunctionPtr(new FunctionImpl<ControlSlider::ClickedCallback(ControlSlider::*)() const>(&ControlSlider::getClickedCallback));
						case 37: return FunctionPtr(new FunctionImpl<ControlSlider::ClickedCallback(ControlSlider::*)() const>(&ControlSlider::getClicked2Callback));
						case 38: return FunctionPtr(new FunctionImpl<ControlSlider::ClickedCallback(ControlSlider::*)() const>(&ControlSlider::getClickedRightCallback));
						case 39: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)()>(&ControlSlider::isClicked));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)(const ControlSlider::ChangedCallback&)>(&ControlSlider::setChangedCallback));
						case 41: return FunctionPtr(new FunctionImpl<ControlSlider::ChangedCallback(ControlSlider::*)() const>(&ControlSlider::getChangedCallback));
						case 42: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)(bool)>(&ControlSlider::isChanged, true));
						case 43: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlSlider::*)()>(&ControlSlider::getCanvasMesh));
						case 44: return FunctionPtr(new FunctionImpl<ControlSlider(ControlSlider::*)() const>(&ControlSlider::clonePtr));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)()>(&ControlSlider::clearPtr));
						case 46: return FunctionPtr(new FunctionVoidImpl<void(ControlSlider::*)()>(&ControlSlider::destroyPtr));
						case 47: return FunctionPtr(new FunctionImpl<ControlSlider&(ControlSlider::*)()>(&ControlSlider::acquirePtr));
						case 48: return FunctionPtr(new FunctionImpl<ControlSlider&(ControlSlider::*)()>(&ControlSlider::unacquirePtr));
						case 49: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)() const>(&ControlSlider::isValidPtr));
						case 50: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)() const>(&ControlSlider::isOwnerPtr));
						case 51: return FunctionPtr(new FunctionImpl<bool(ControlSlider::*)() const>(&ControlSlider::isConstPtr));
						case 52: return FunctionPtr(new FunctionImpl<uint32_t(ControlSlider::*)() const>(&ControlSlider::getCountPtr));
						case 53: return FunctionPtr(new FunctionImpl<const void*(ControlSlider::*)() const>(&ControlSlider::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5, 8, 12, 18, 23, 28, 33 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1877, 280, 1841, 280, 1877, 4039, 280, 1877, 4039, 2054, 280, 1877, 4039, 2054, 2054, 2054, 280, 1877, 2054, 2054, 2054, 280, 1877, 4039, 4039, 4039, 280, 1877, 3003, 3003, 3003 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4011, 3348, 4011, 3348, 4011, 1972, 3348, 4011, 1972, 4056, 3348, 4011, 1972, 4056, 3271, 3264, 3348, 4011, 4056, 3271, 3264, 3348, 4011, 4056, 3271, 3264, 3348, 4011, 4056, 3271, 3264 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 2, 2, 2, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3578, 3054, 3883, 3189, 3832, 2763, 3609, 2301, 3844, 2785, 3520, 2115, 3641, 3641, 2355, 3926, 2898, 2899, 2901, 2900, 3793, 2513, 2493, 3656, 2407, 3642, 2356, 3788, 2681, 3152, 3799, 2703, 3158, 3559, 3558, 3560, 2196, 2195, 2197, 3045, 3550, 2186, 3041, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 1721, 4073, 4039, 4073, 2054, 4073, 2054, 4073, 4073, 1274, 4073, 2054, 2051, 4039, 3003, 4073, 2054, 2054, 4073, 2051, 4073, 336, 4073, 337, 1585, 4073, 338, 1585, 4073, 4073, 4073, 335, 335, 335, 1585, 4073, 334, 1585, 232, 332, 4073, 4073, 333, 333, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8, 8, 11, 12, 13, 14, 15, 18, 19, 20, 21, 21, 22, 22, 23, 23, 23, 24, 24, 24, 25, 26, 27, 27, 27, 27, 27, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1721, 4039, 2054, 2054, 1877, 1841, 2054, 1585, 1585, 1585, 1585, 1585, 1585, 2054, 2054, 1585, 1585, 1585, 2051, 1750, 1751, 1752, 1749, 1749, 1749, 1748, 1585 };
			static constexpr uint16_t function_arg_names[] = { 1886, 1996, 1650, 1972, 3986, 1570, 2066, 2066, 4056, 1601, 2014, 2014, 2014, 2014, 2014, 3271, 3264, 2014, 2014, 2014, 3960, 2074, 2074, 2074, 2074, 2074, 2074, 2074, 1612 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 2016, 2016, 2016, 2016, 2016, 0, 0, 2016, 2016, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 4033 };
			static constexpr uint16_t callback_names[] = { 766, 1153, 1183, 249, 247 };
			static constexpr uint16_t callback_types[] = { 1274, 4073, 4073, 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1, 2, 3, 4, 5 };
			static constexpr uint16_t callback_arg_types[] = { 332, 332, 332, 332, 332 };
			static constexpr uint16_t callback_arg_names[] = { 0, 0, 0, 0, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlSlider::constructor_bases[];
	constexpr uint16_t ReflectionControlSlider::constructor_arg_types[];
	constexpr uint16_t ReflectionControlSlider::constructor_arg_names[];
	constexpr uint16_t ReflectionControlSlider::constructor_arg_values[];
	constexpr uint8_t ReflectionControlSlider::function_flags[];
	constexpr uint16_t ReflectionControlSlider::function_names[];
	constexpr uint16_t ReflectionControlSlider::function_types[];
	constexpr uint16_t ReflectionControlSlider::function_bases[];
	constexpr uint16_t ReflectionControlSlider::function_arg_types[];
	constexpr uint16_t ReflectionControlSlider::function_arg_names[];
	constexpr uint16_t ReflectionControlSlider::function_arg_values[];
	constexpr uint16_t ReflectionControlSlider::callback_names[];
	constexpr uint16_t ReflectionControlSlider::callback_types[];
	constexpr uint16_t ReflectionControlSlider::callback_bases[];
	constexpr uint16_t ReflectionControlSlider::callback_arg_types[];
	constexpr uint16_t ReflectionControlSlider::callback_arg_names[];
	constexpr uint16_t ReflectionControlSlider::enum_names[];
	constexpr uint16_t ReflectionControlSlider::enum_bases[];
	constexpr uint16_t ReflectionControlSlider::enum_var_names[];
	static ReflectionControlSlider reflection_control_slider;
	
	// Tellusim::ControlScroll
	class ReflectionControlScroll : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlScroll::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlScroll, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlScroll, TypeList<Control*, bool>>({}, false));
						case 2: return ConstructorPtr(new ConstructorImpl<ControlScroll, TypeList<Control*, float64_t, bool>>({}, {}, false));
						case 3: return ConstructorPtr(new ConstructorImpl<ControlScroll, TypeList<Control*, float64_t, float64_t, float64_t, bool>>({}, {}, {}, {}, false));
						case 4: return ConstructorPtr(new ConstructorImpl<ControlScroll, TypeList<Control*, uint32_t, uint32_t, uint32_t, bool>>({}, {}, {}, {}, false));
						case 5: return ConstructorPtr(new ConstructorImpl<ControlScroll, TypeList<Control*, int32_t, int32_t, int32_t, bool>>({}, {}, {}, {}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlScroll>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(bool, bool)>(&ControlScroll::setVertical, {}, true));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)() const>(&ControlScroll::isHorizontal));
						case 2: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)() const>(&ControlScroll::isVertical));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const char*)>(&ControlScroll::setPrevText));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const String&)>(&ControlScroll::setPrevText));
						case 5: return FunctionPtr(new FunctionImpl<String(ControlScroll::*)() const>(&ControlScroll::getPrevText));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const char*)>(&ControlScroll::setNextText));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const String&)>(&ControlScroll::setNextText));
						case 8: return FunctionPtr(new FunctionImpl<String(ControlScroll::*)() const>(&ControlScroll::getNextText));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const Color&)>(&ControlScroll::setScrollColor));
						case 10: return FunctionPtr(new FunctionImpl<const Color&(ControlScroll::*)() const>(&ControlScroll::getScrollColor));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(float64_t)>(&ControlScroll::setStep));
						case 12: return FunctionPtr(new FunctionImpl<float64_t(ControlScroll::*)() const>(&ControlScroll::getStep));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(float64_t, bool)>(&ControlScroll::setValue, {}, false));
						case 14: return FunctionPtr(new FunctionImpl<float64_t(ControlScroll::*)() const>(&ControlScroll::getValue));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(float64_t)>(&ControlScroll::setFrame));
						case 16: return FunctionPtr(new FunctionImpl<float64_t(ControlScroll::*)() const>(&ControlScroll::getFrame));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(float64_t)>(&ControlScroll::setRange));
						case 18: return FunctionPtr(new FunctionImpl<float64_t(ControlScroll::*)() const>(&ControlScroll::getRange));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(Control::Align)>(&ControlScroll::setFrameAlign));
						case 20: return FunctionPtr(new FunctionImpl<Control::Align(ControlScroll::*)() const>(&ControlScroll::getFrameAlign));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)(Control::Align) const>(&ControlScroll::hasFrameAlign));
						case 22: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)(Control::Align) const>(&ControlScroll::hasFrameAligns));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const ControlScroll::ClickedCallback&)>(&ControlScroll::setClickedCallback));
						case 24: return FunctionPtr(new FunctionImpl<ControlScroll::ClickedCallback(ControlScroll::*)() const>(&ControlScroll::getClickedCallback));
						case 25: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)()>(&ControlScroll::isClicked));
						case 26: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)(const ControlScroll::ChangedCallback&)>(&ControlScroll::setChangedCallback));
						case 27: return FunctionPtr(new FunctionImpl<ControlScroll::ChangedCallback(ControlScroll::*)() const>(&ControlScroll::getChangedCallback));
						case 28: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)(bool)>(&ControlScroll::isChanged, true));
						case 29: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlScroll::*)()>(&ControlScroll::getCanvasMesh));
						case 30: return FunctionPtr(new FunctionImpl<ControlScroll(ControlScroll::*)() const>(&ControlScroll::clonePtr));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)()>(&ControlScroll::clearPtr));
						case 32: return FunctionPtr(new FunctionVoidImpl<void(ControlScroll::*)()>(&ControlScroll::destroyPtr));
						case 33: return FunctionPtr(new FunctionImpl<ControlScroll&(ControlScroll::*)()>(&ControlScroll::acquirePtr));
						case 34: return FunctionPtr(new FunctionImpl<ControlScroll&(ControlScroll::*)()>(&ControlScroll::unacquirePtr));
						case 35: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)() const>(&ControlScroll::isValidPtr));
						case 36: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)() const>(&ControlScroll::isOwnerPtr));
						case 37: return FunctionPtr(new FunctionImpl<bool(ControlScroll::*)() const>(&ControlScroll::isConstPtr));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(ControlScroll::*)() const>(&ControlScroll::getCountPtr));
						case 39: return FunctionPtr(new FunctionImpl<const void*(ControlScroll::*)() const>(&ControlScroll::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 5, 10, 15, 20 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 1585, 280, 2054, 1585, 280, 2054, 2054, 2054, 1585, 280, 4039, 4039, 4039, 1585, 280, 3003, 3003, 3003, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 4067, 3348, 4056, 4067, 3348, 4056, 2067, 3377, 4067, 3348, 4056, 2067, 3377, 4067, 3348, 4056, 2067, 3377, 4067 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016, 0, 0, 2016, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3936, 3093, 3203, 3789, 3789, 2682, 3752, 3752, 2557, 3823, 2744, 3844, 2785, 3926, 2898, 3643, 2360, 3793, 2695, 3644, 2361, 2951, 2952, 3559, 2196, 3045, 3550, 2186, 3041, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 1721, 4073, 2054, 4073, 2054, 4073, 2054, 4073, 2054, 4073, 281, 1585, 1585, 4073, 331, 1585, 4073, 330, 1585, 232, 328, 4073, 4073, 329, 329, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 16, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1877, 1841, 1877, 1841, 1721, 2054, 2054, 1585, 2054, 2054, 281, 281, 281, 1747, 1746, 1585 };
			static constexpr uint16_t function_arg_names[] = { 4067, 4011, 4011, 4011, 4011, 4011, 1650, 3986, 4056, 1601, 2067, 3377, 1546, 1546, 1548, 2074, 2074, 1612 };
			static constexpr uint16_t function_arg_values[] = { 0, 4033, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 4033 };
			static constexpr uint16_t callback_names[] = { 249, 247 };
			static constexpr uint16_t callback_types[] = { 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1, 2 };
			static constexpr uint16_t callback_arg_types[] = { 328, 328 };
			static constexpr uint16_t callback_arg_names[] = { 0, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlScroll::constructor_bases[];
	constexpr uint16_t ReflectionControlScroll::constructor_arg_types[];
	constexpr uint16_t ReflectionControlScroll::constructor_arg_names[];
	constexpr uint16_t ReflectionControlScroll::constructor_arg_values[];
	constexpr uint8_t ReflectionControlScroll::function_flags[];
	constexpr uint16_t ReflectionControlScroll::function_names[];
	constexpr uint16_t ReflectionControlScroll::function_types[];
	constexpr uint16_t ReflectionControlScroll::function_bases[];
	constexpr uint16_t ReflectionControlScroll::function_arg_types[];
	constexpr uint16_t ReflectionControlScroll::function_arg_names[];
	constexpr uint16_t ReflectionControlScroll::function_arg_values[];
	constexpr uint16_t ReflectionControlScroll::callback_names[];
	constexpr uint16_t ReflectionControlScroll::callback_types[];
	constexpr uint16_t ReflectionControlScroll::callback_bases[];
	constexpr uint16_t ReflectionControlScroll::callback_arg_types[];
	constexpr uint16_t ReflectionControlScroll::callback_arg_names[];
	constexpr uint16_t ReflectionControlScroll::enum_names[];
	constexpr uint16_t ReflectionControlScroll::enum_bases[];
	constexpr uint16_t ReflectionControlScroll::enum_var_names[];
	static ReflectionControlScroll reflection_control_scroll;
	
	// Tellusim::ControlSplit
	class ReflectionControlSplit : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlSplit::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlSplit, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlSplit, TypeList<Control*, bool>>({}, false));
						case 2: return ConstructorPtr(new ConstructorImpl<ControlSplit, TypeList<Control*, float32_t, bool>>({}, {}, false));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlSplit>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlSplit::*)(bool)>(&ControlSplit::setAbsolute));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlSplit::*)() const>(&ControlSplit::isAbsolute));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlSplit::*)(bool)>(&ControlSplit::setVertical));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlSplit::*)() const>(&ControlSplit::isHorizontal));
						case 4: return FunctionPtr(new FunctionImpl<bool(ControlSplit::*)() const>(&ControlSplit::isVertical));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlSplit::*)(float32_t)>(&ControlSplit::setValue));
						case 6: return FunctionPtr(new FunctionImpl<float32_t(ControlSplit::*)() const>(&ControlSplit::getValue));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(ControlSplit::*)(float32_t)>(&ControlSplit::setHandleSize));
						case 8: return FunctionPtr(new FunctionImpl<float32_t(ControlSplit::*)() const>(&ControlSplit::getHandleSize));
						case 9: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlSplit::*)() const>(&ControlSplit::getControlsSize));
						case 10: return FunctionPtr(new FunctionImpl<ControlSplit(ControlSplit::*)() const>(&ControlSplit::clonePtr));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlSplit::*)()>(&ControlSplit::clearPtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlSplit::*)()>(&ControlSplit::destroyPtr));
						case 13: return FunctionPtr(new FunctionImpl<ControlSplit&(ControlSplit::*)()>(&ControlSplit::acquirePtr));
						case 14: return FunctionPtr(new FunctionImpl<ControlSplit&(ControlSplit::*)()>(&ControlSplit::unacquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<bool(ControlSplit::*)() const>(&ControlSplit::isValidPtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(ControlSplit::*)() const>(&ControlSplit::isOwnerPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(ControlSplit::*)() const>(&ControlSplit::isConstPtr));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(ControlSplit::*)() const>(&ControlSplit::getCountPtr));
						case 19: return FunctionPtr(new FunctionImpl<const void*(ControlSplit::*)() const>(&ControlSplit::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 2, 5 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 1585, 280, 2051, 1585 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 4067, 3348, 4056, 4067 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 2016, 0, 0, 2016 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3505, 3017, 3936, 3093, 3203, 3926, 2898, 3656, 2407, 2236, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 1585, 4073, 2051, 4073, 2051, 1854, 339, 4073, 4073, 340, 340, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 2051, 2051 };
			static constexpr uint16_t function_arg_names[] = { 1502, 4067, 4056, 3960 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlSplit::constructor_bases[];
	constexpr uint16_t ReflectionControlSplit::constructor_arg_types[];
	constexpr uint16_t ReflectionControlSplit::constructor_arg_names[];
	constexpr uint16_t ReflectionControlSplit::constructor_arg_values[];
	constexpr uint8_t ReflectionControlSplit::function_flags[];
	constexpr uint16_t ReflectionControlSplit::function_names[];
	constexpr uint16_t ReflectionControlSplit::function_types[];
	constexpr uint16_t ReflectionControlSplit::function_bases[];
	constexpr uint16_t ReflectionControlSplit::function_arg_types[];
	constexpr uint16_t ReflectionControlSplit::function_arg_names[];
	constexpr uint16_t ReflectionControlSplit::function_arg_values[];
	constexpr uint16_t ReflectionControlSplit::callback_names[];
	constexpr uint16_t ReflectionControlSplit::callback_types[];
	constexpr uint16_t ReflectionControlSplit::callback_bases[];
	constexpr uint16_t ReflectionControlSplit::callback_arg_types[];
	constexpr uint16_t ReflectionControlSplit::callback_arg_names[];
	constexpr uint16_t ReflectionControlSplit::enum_names[];
	constexpr uint16_t ReflectionControlSplit::enum_bases[];
	constexpr uint16_t ReflectionControlSplit::enum_var_names[];
	static ReflectionControlSplit reflection_control_split;
	
	// Tellusim::ControlArea
	class ReflectionControlArea : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlArea::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlArea, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlArea, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlArea, TypeList<Control*, uint32_t>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlArea, TypeList<Control*, bool, bool>>());
						case 4: return ConstructorPtr(new ConstructorImpl<ControlArea, TypeList<Control*, uint32_t, float32_t, float32_t>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlArea>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(bool)>(&ControlArea::setAbsolute));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isAbsolute));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(bool)>(&ControlArea::setScalable));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isScalable));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(bool)>(&ControlArea::setScrollable));
						case 5: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isScrollable));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float32_t)>(&ControlArea::setScale));
						case 7: return FunctionPtr(new FunctionImpl<float32_t(ControlArea::*)() const>(&ControlArea::getScale));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float32_t, float32_t)>(&ControlArea::setScaleRange));
						case 9: return FunctionPtr(new FunctionImpl<float32_t(ControlArea::*)() const>(&ControlArea::getMinScale));
						case 10: return FunctionPtr(new FunctionImpl<float32_t(ControlArea::*)() const>(&ControlArea::getMaxScale));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float64_t)>(&ControlArea::setHorizontalStep));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float64_t)>(&ControlArea::setVerticalStep));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float64_t, float64_t)>(&ControlArea::setStep));
						case 14: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getHorizontalStep));
						case 15: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getVerticalStep));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float64_t)>(&ControlArea::setHorizontalValue));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float64_t)>(&ControlArea::setVerticalValue));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float64_t, float64_t)>(&ControlArea::setValue));
						case 19: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getHorizontalValue));
						case 20: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getVerticalValue));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(Control::Align)>(&ControlArea::setFrameAlign));
						case 22: return FunctionPtr(new FunctionImpl<Control::Align(ControlArea::*)() const>(&ControlArea::getFrameAlign));
						case 23: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getHorizontalFrame));
						case 24: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getVerticalFrame));
						case 25: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getHorizontalRange));
						case 26: return FunctionPtr(new FunctionImpl<float64_t(ControlArea::*)() const>(&ControlArea::getVerticalRange));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(bool, bool)>(&ControlArea::setHorizontalEnabled, {}, false));
						case 28: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isHorizontalEnabled));
						case 29: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isHorizontalDynamic));
						case 30: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isHorizontalHidden));
						case 31: return FunctionPtr(new FunctionImpl<const ControlScroll(ControlArea::*)() const>(&ControlArea::getHorizontalScroll));
						case 32: return FunctionPtr(new FunctionImpl<ControlScroll(ControlArea::*)()>(&ControlArea::getHorizontalScroll));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(bool, bool)>(&ControlArea::setVerticalEnabled, {}, false));
						case 34: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isVerticalEnabled));
						case 35: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isVerticalDynamic));
						case 36: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isVerticalHidden));
						case 37: return FunctionPtr(new FunctionImpl<const ControlScroll(ControlArea::*)() const>(&ControlArea::getVerticalScroll));
						case 38: return FunctionPtr(new FunctionImpl<ControlScroll(ControlArea::*)()>(&ControlArea::getVerticalScroll));
						case 39: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)(uint32_t)>(&ControlArea::setFontSize));
						case 40: return FunctionPtr(new FunctionImpl<uint32_t(ControlArea::*)() const>(&ControlArea::getFontSize));
						case 41: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)(const FontStyle&)>(&ControlArea::setFontStyle));
						case 42: return FunctionPtr(new FunctionImpl<const FontStyle&(ControlArea::*)() const>(&ControlArea::getFontStyleConst));
						case 43: return FunctionPtr(new FunctionImpl<const FontStyle&(ControlArea::*)() const>(&ControlArea::getFontStyle));
						case 44: return FunctionPtr(new FunctionImpl<FontStyle&(ControlArea::*)()>(&ControlArea::getFontStyle));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(uint32_t)>(&ControlArea::setColumns));
						case 46: return FunctionPtr(new FunctionImpl<uint32_t(ControlArea::*)() const>(&ControlArea::getColumns));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(const Vector2f&)>(&ControlArea::setSpacing));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(float32_t, float32_t)>(&ControlArea::setSpacing));
						case 49: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlArea::*)() const>(&ControlArea::getSpacing));
						case 50: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)(uint32_t, float32_t)>(&ControlArea::setColumnRatio));
						case 51: return FunctionPtr(new FunctionImpl<float32_t(ControlArea::*)(uint32_t) const>(&ControlArea::getColumnRatio));
						case 52: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlArea::*)() const>(&ControlArea::getControlsSize));
						case 53: return FunctionPtr(new FunctionImpl<const Vector2f&(ControlArea::*)() const>(&ControlArea::getControlsOffset));
						case 54: return FunctionPtr(new FunctionImpl<const Rect&(ControlArea::*)() const>(&ControlArea::getViewRect));
						case 55: return FunctionPtr(new FunctionImpl<ControlArea(ControlArea::*)() const>(&ControlArea::clonePtr));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)()>(&ControlArea::clearPtr));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(ControlArea::*)()>(&ControlArea::destroyPtr));
						case 58: return FunctionPtr(new FunctionImpl<ControlArea&(ControlArea::*)()>(&ControlArea::acquirePtr));
						case 59: return FunctionPtr(new FunctionImpl<ControlArea&(ControlArea::*)()>(&ControlArea::unacquirePtr));
						case 60: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isValidPtr));
						case 61: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isOwnerPtr));
						case 62: return FunctionPtr(new FunctionImpl<bool(ControlArea::*)() const>(&ControlArea::isConstPtr));
						case 63: return FunctionPtr(new FunctionImpl<uint32_t(ControlArea::*)() const>(&ControlArea::getCountPtr));
						case 64: return FunctionPtr(new FunctionImpl<const void*(ControlArea::*)() const>(&ControlArea::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 6, 10 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 4039, 280, 1585, 1585, 280, 4039, 2051, 2051 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 1652, 3348, 2983, 4067, 3348, 1652, 4115, 4116 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3505, 3017, 3816, 3167, 3824, 3169, 3817, 2730, 3819, 2514, 2495, 3659, 3938, 3844, 2415, 2921, 3660, 3939, 3926, 2416, 2922, 3644, 2361, 2412, 2918, 2413, 2919, 3658, 3095, 3094, 3096, 2414, 2414, 3937, 3205, 3204, 3206, 2920, 2920, 3639, 2352, 3640, 2354, 2353, 2353, 3572, 2217, 3835, 3835, 2766, 3571, 2216, 2236, 2235, 2924, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 1585, 4073, 2051, 4073, 2051, 2051, 4073, 4073, 4073, 2054, 2054, 4073, 4073, 4073, 2054, 2054, 4073, 281, 2054, 2054, 2054, 2054, 4073, 1585, 1585, 1585, 1745, 328, 4073, 1585, 1585, 1585, 1745, 328, 1585, 4039, 1585, 1778, 1778, 764, 4073, 4039, 4073, 4073, 1854, 4073, 2051, 1854, 1854, 1830, 287, 4073, 4073, 288, 288, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 6, 6, 6, 7, 8, 10, 10, 10, 11, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15, 17, 17, 17, 17, 17, 17, 19, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 21, 22, 22, 23, 25, 25, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1585, 2051, 2051, 2051, 2054, 2054, 2054, 2054, 2054, 2054, 2054, 2054, 281, 1585, 1585, 1585, 1585, 4039, 1778, 4039, 1854, 2051, 2051, 4039, 2051, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1502, 3483, 3490, 3484, 3271, 3264, 3986, 3986, 2983, 4067, 4056, 4056, 2983, 4067, 1546, 1996, 1993, 1996, 1993, 3960, 3992, 1652, 3972, 4115, 4116, 2993, 3379, 2993 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlArea::constructor_bases[];
	constexpr uint16_t ReflectionControlArea::constructor_arg_types[];
	constexpr uint16_t ReflectionControlArea::constructor_arg_names[];
	constexpr uint16_t ReflectionControlArea::constructor_arg_values[];
	constexpr uint8_t ReflectionControlArea::function_flags[];
	constexpr uint16_t ReflectionControlArea::function_names[];
	constexpr uint16_t ReflectionControlArea::function_types[];
	constexpr uint16_t ReflectionControlArea::function_bases[];
	constexpr uint16_t ReflectionControlArea::function_arg_types[];
	constexpr uint16_t ReflectionControlArea::function_arg_names[];
	constexpr uint16_t ReflectionControlArea::function_arg_values[];
	constexpr uint16_t ReflectionControlArea::callback_names[];
	constexpr uint16_t ReflectionControlArea::callback_types[];
	constexpr uint16_t ReflectionControlArea::callback_bases[];
	constexpr uint16_t ReflectionControlArea::callback_arg_types[];
	constexpr uint16_t ReflectionControlArea::callback_arg_names[];
	constexpr uint16_t ReflectionControlArea::enum_names[];
	constexpr uint16_t ReflectionControlArea::enum_bases[];
	constexpr uint16_t ReflectionControlArea::enum_var_names[];
	static ReflectionControlArea reflection_control_area;
	
	// Tellusim::ControlTree
	class ReflectionControlTree : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlTree::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlTree, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlTree, TypeList<Control*>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlTree>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(bool)>(&ControlTree::setSelectable));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)() const>(&ControlTree::isSelectable));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(bool)>(&ControlTree::setMultiSelection));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)() const>(&ControlTree::isMultiSelection));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const char*)>(&ControlTree::setFoldedText));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const String&)>(&ControlTree::setFoldedText));
						case 6: return FunctionPtr(new FunctionImpl<String(ControlTree::*)() const>(&ControlTree::getFoldedText));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const char*)>(&ControlTree::setExpandedText));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const String&)>(&ControlTree::setExpandedText));
						case 9: return FunctionPtr(new FunctionImpl<String(ControlTree::*)() const>(&ControlTree::getExpandedText));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(Texture&, uint32_t, uint32_t)>(&ControlTree::setTexture, Texture::null, 1, 1));
						case 11: return FunctionPtr(new FunctionImpl<Texture(ControlTree::*)() const>(&ControlTree::getTexture));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const char*, uint32_t, uint32_t)>(&ControlTree::setTextureName, {}, 1, 1));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const String&, uint32_t, uint32_t)>(&ControlTree::setTextureName, {}, 1, 1));
						case 14: return FunctionPtr(new FunctionImpl<String(ControlTree::*)() const>(&ControlTree::getTextureName));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, uint32_t)>(&ControlTree::setTextureGrid));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getTextureRows));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getTextureColumns));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)()>(&ControlTree::clearItems));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(const char*, uint32_t, bool)>(&ControlTree::addItem, {}, Maxu32, true));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(const String&, uint32_t, bool)>(&ControlTree::addItem, {}, Maxu32, true));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const InitializerList<const char*>&, uint32_t)>(&ControlTree::addItems, {}, Maxu32));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, bool)>(&ControlTree::removeItem, {}, false));
						case 23: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t)>(&ControlTree::viewItem));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getNumItems));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t) const>(&ControlTree::getItem));
						case 26: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t, bool)>(&ControlTree::switchItemHidden, {}, false));
						case 27: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, bool, bool)>(&ControlTree::setItemHidden, {}, {}, false));
						case 28: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t) const>(&ControlTree::isItemHidden));
						case 29: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t, bool)>(&ControlTree::switchItemExpanded, {}, false));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, bool, bool)>(&ControlTree::setItemExpanded, {}, {}, false));
						case 31: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t) const>(&ControlTree::isItemExpanded));
						case 32: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t, bool)>(&ControlTree::switchItemSelected, {}, false));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, bool, bool)>(&ControlTree::setItemSelected, {}, {}, false));
						case 34: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t) const>(&ControlTree::isItemSelected));
						case 35: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, uint32_t)>(&ControlTree::setItemParent));
						case 36: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t) const>(&ControlTree::getItemParent));
						case 37: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t, uint32_t, bool) const>(&ControlTree::isItemParent, {}, {}, false));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, uint32_t)>(&ControlTree::addItemChild));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, uint32_t)>(&ControlTree::removeItemChild));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, const Array<uint32_t>&)>(&ControlTree::addItemChildren));
						case 41: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, const Array<uint32_t>&)>(&ControlTree::removeItemChildren));
						case 42: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t, uint32_t) const>(&ControlTree::findItemChild));
						case 43: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)(uint32_t, uint32_t) const>(&ControlTree::isItemChild));
						case 44: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t) const>(&ControlTree::getNumItemChildren));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t, uint32_t) const>(&ControlTree::getItemChild));
						case 46: return FunctionPtr(new FunctionImpl<Array<uint32_t>(ControlTree::*)(uint32_t) const>(&ControlTree::getItemChildren));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, const char*)>(&ControlTree::setItemText));
						case 48: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, const String&)>(&ControlTree::setItemText));
						case 49: return FunctionPtr(new FunctionImpl<String(ControlTree::*)(uint32_t) const>(&ControlTree::getItemText));
						case 50: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(const char*) const>(&ControlTree::findItemText));
						case 51: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(const String&) const>(&ControlTree::findItemText));
						case 52: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, const Color&)>(&ControlTree::setItemColor));
						case 53: return FunctionPtr(new FunctionImpl<const Color&(ControlTree::*)(uint32_t) const>(&ControlTree::getItemColor));
						case 54: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, uint32_t, uint32_t)>(&ControlTree::setItemTexture, {}, {}, 0));
						case 55: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t) const>(&ControlTree::getItemTextureRow));
						case 56: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t) const>(&ControlTree::getItemTextureColumn));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, void*)>(&ControlTree::setItemData));
						case 58: return FunctionPtr(new FunctionVoidImpl<void*(ControlTree::*)(uint32_t) const>(&ControlTree::getItemData));
						case 59: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getFocusedItem));
						case 60: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(uint32_t, bool, bool, bool)>(&ControlTree::setCurrentItem, {}, false, false, false));
						case 61: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getCurrentItem));
						case 62: return FunctionPtr(new FunctionImpl<String(ControlTree::*)() const>(&ControlTree::getCurrentText));
						case 63: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)()>(&ControlTree::setSelection));
						case 64: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)()>(&ControlTree::clearSelection));
						case 65: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)()>(&ControlTree::inverseSelection));
						case 66: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getNumSelectedItems));
						case 67: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)(uint32_t) const>(&ControlTree::getSelectedItem));
						case 68: return FunctionPtr(new FunctionImpl<Array<uint32_t>(ControlTree::*)() const>(&ControlTree::getSelectedItems));
						case 69: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::ChangedCallback&)>(&ControlTree::setChangedCallback));
						case 70: return FunctionPtr(new FunctionImpl<ControlTree::ChangedCallback(ControlTree::*)() const>(&ControlTree::getChangedCallback));
						case 71: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::DraggedCallback&)>(&ControlTree::setDraggedCallback));
						case 72: return FunctionPtr(new FunctionImpl<ControlTree::DraggedCallback(ControlTree::*)() const>(&ControlTree::getDraggedCallback));
						case 73: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::DroppedCallback&)>(&ControlTree::setDroppedCallback));
						case 74: return FunctionPtr(new FunctionImpl<ControlTree::DroppedCallback(ControlTree::*)() const>(&ControlTree::getDroppedCallback));
						case 75: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::ClickedCallback&)>(&ControlTree::setClickedCallback));
						case 76: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::ClickedCallback&)>(&ControlTree::setClicked2Callback));
						case 77: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::ClickedCallback&)>(&ControlTree::setClickedRightCallback));
						case 78: return FunctionPtr(new FunctionImpl<ControlTree::ClickedCallback(ControlTree::*)() const>(&ControlTree::getClickedCallback));
						case 79: return FunctionPtr(new FunctionImpl<ControlTree::ClickedCallback(ControlTree::*)() const>(&ControlTree::getClicked2Callback));
						case 80: return FunctionPtr(new FunctionImpl<ControlTree::ClickedCallback(ControlTree::*)() const>(&ControlTree::getClickedRightCallback));
						case 81: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::ExpandedCallback&)>(&ControlTree::setExpandedCallback));
						case 82: return FunctionPtr(new FunctionImpl<ControlTree::ExpandedCallback(ControlTree::*)() const>(&ControlTree::getExpandedCallback));
						case 83: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)(const ControlTree::SelectedCallback&)>(&ControlTree::setSelectedCallback));
						case 84: return FunctionPtr(new FunctionImpl<ControlTree::SelectedCallback(ControlTree::*)() const>(&ControlTree::getSelectedCallback));
						case 85: return FunctionPtr(new FunctionImpl<ControlTree(ControlTree::*)() const>(&ControlTree::clonePtr));
						case 86: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)()>(&ControlTree::clearPtr));
						case 87: return FunctionPtr(new FunctionVoidImpl<void(ControlTree::*)()>(&ControlTree::destroyPtr));
						case 88: return FunctionPtr(new FunctionImpl<ControlTree&(ControlTree::*)()>(&ControlTree::acquirePtr));
						case 89: return FunctionPtr(new FunctionImpl<ControlTree&(ControlTree::*)()>(&ControlTree::unacquirePtr));
						case 90: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)() const>(&ControlTree::isValidPtr));
						case 91: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)() const>(&ControlTree::isOwnerPtr));
						case 92: return FunctionPtr(new FunctionImpl<bool(ControlTree::*)() const>(&ControlTree::isConstPtr));
						case 93: return FunctionPtr(new FunctionImpl<uint32_t(ControlTree::*)() const>(&ControlTree::getCountPtr));
						case 94: return FunctionPtr(new FunctionImpl<const void*(ControlTree::*)() const>(&ControlTree::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1 };
			static constexpr uint16_t constructor_arg_types[] = { 280 };
			static constexpr uint16_t constructor_arg_names[] = { 3348 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3826, 3170, 3748, 3131, 3633, 3633, 2346, 3621, 3621, 2323, 3885, 2828, 3893, 3893, 2840, 3889, 2844, 2830, 1626, 1523, 1523, 1526, 3432, 4070, 2591, 2443, 3998, 3685, 3108, 3997, 3684, 3107, 3999, 3689, 3110, 3688, 2454, 3109, 1524, 3433, 1525, 3434, 2034, 3105, 2590, 2445, 2446, 3690, 3690, 2455, 2035, 2035, 3681, 2448, 3691, 2457, 2456, 3682, 2449, 2345, 3588, 2248, 2249, 3828, 1639, 3008, 2608, 2747, 2748, 3550, 2186, 3613, 2312, 3615, 2315, 3559, 3558, 3560, 2196, 2195, 2197, 3620, 2322, 3827, 2746, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 1293, 4073, 4073, 1274, 4073, 4039, 4039, 4073, 4039, 4039, 4073, 4073, 4073, 4039, 4039, 1585, 4073, 1585, 1585, 4073, 1585, 1585, 4073, 1585, 4073, 4039, 1585, 4073, 4073, 4073, 4073, 4039, 1585, 4039, 4039, 59, 4073, 4073, 1274, 4039, 4039, 4073, 1721, 4073, 4039, 4039, 4073, 4074, 4039, 4073, 4039, 1274, 4073, 4073, 4073, 4039, 4039, 59, 4073, 345, 4073, 347, 4073, 348, 4073, 4073, 4073, 346, 346, 346, 4073, 349, 4073, 350, 343, 4073, 4073, 344, 344, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 6, 9, 9, 12, 15, 15, 17, 17, 17, 17, 20, 23, 25, 27, 28, 28, 29, 31, 34, 35, 37, 40, 41, 43, 46, 47, 49, 50, 53, 55, 57, 59, 61, 63, 65, 66, 68, 69, 71, 73, 74, 75, 76, 78, 79, 82, 83, 84, 86, 87, 87, 91, 91, 91, 91, 91, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95, 96, 97, 98, 98, 98, 98, 99, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1877, 1841, 1877, 1841, 1294, 4039, 4039, 1877, 4039, 4039, 1841, 4039, 4039, 4039, 4039, 1877, 4039, 1585, 1841, 4039, 1585, 1790, 4039, 4039, 1585, 4039, 4039, 4039, 1585, 4039, 1585, 1585, 4039, 4039, 1585, 4039, 1585, 1585, 4039, 4039, 1585, 4039, 1585, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 1585, 4039, 4039, 4039, 4039, 4039, 1703, 4039, 1703, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 1877, 4039, 1841, 4039, 1877, 1841, 4039, 1721, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4074, 4039, 4039, 1585, 1585, 1585, 4039, 1753, 1755, 1756, 1754, 1754, 1754, 1757, 1758 };
			static constexpr uint16_t function_arg_names[] = { 3497, 3286, 4011, 4011, 4011, 4011, 4012, 3474, 1652, 3288, 3474, 1652, 3288, 3474, 1652, 3474, 1652, 4011, 3348, 2013, 4011, 3348, 2013, 3225, 3348, 3224, 1610, 3224, 2993, 3224, 1610, 3224, 2981, 1610, 3224, 3224, 1610, 3224, 2013, 1610, 3224, 3224, 1610, 3224, 3498, 1610, 3224, 3224, 3348, 3224, 3224, 3348, 2982, 3224, 1609, 3224, 1609, 3224, 1610, 3224, 1610, 3224, 1609, 3224, 1609, 3224, 3224, 2993, 3224, 3224, 4011, 3224, 4011, 3224, 4011, 4011, 3224, 1650, 3224, 3224, 3473, 1651, 3224, 3224, 3224, 1948, 3224, 3224, 3496, 4069, 1601, 2993, 2074, 2074, 2074, 2074, 2074, 2074, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 6, 6, 0, 6, 6, 0, 0, 0, 984, 4033, 0, 984, 4033, 0, 984, 0, 2016, 0, 0, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2016, 2016, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 247, 498, 500, 249, 525, 1200 };
			static constexpr uint16_t callback_types[] = { 4073, 1585, 4073, 4073, 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 2, 4, 6, 8, 10, 11 };
			static constexpr uint16_t callback_arg_types[] = { 343, 4039, 343, 4039, 343, 4039, 343, 4039, 343, 4039, 343 };
			static constexpr uint16_t callback_arg_names[] = { 0, 3224, 0, 3224, 0, 3224, 0, 3224, 0, 3224, 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionControlTree::constructor_bases[];
	constexpr uint16_t ReflectionControlTree::constructor_arg_types[];
	constexpr uint16_t ReflectionControlTree::constructor_arg_names[];
	constexpr uint16_t ReflectionControlTree::constructor_arg_values[];
	constexpr uint8_t ReflectionControlTree::function_flags[];
	constexpr uint16_t ReflectionControlTree::function_names[];
	constexpr uint16_t ReflectionControlTree::function_types[];
	constexpr uint16_t ReflectionControlTree::function_bases[];
	constexpr uint16_t ReflectionControlTree::function_arg_types[];
	constexpr uint16_t ReflectionControlTree::function_arg_names[];
	constexpr uint16_t ReflectionControlTree::function_arg_values[];
	constexpr uint16_t ReflectionControlTree::callback_names[];
	constexpr uint16_t ReflectionControlTree::callback_types[];
	constexpr uint16_t ReflectionControlTree::callback_bases[];
	constexpr uint16_t ReflectionControlTree::callback_arg_types[];
	constexpr uint16_t ReflectionControlTree::callback_arg_names[];
	constexpr uint16_t ReflectionControlTree::enum_names[];
	constexpr uint16_t ReflectionControlTree::enum_bases[];
	constexpr uint16_t ReflectionControlTree::enum_var_names[];
	static ReflectionControlTree reflection_control_tree;
	
	// Tellusim::ControlEdit
	class ReflectionControlEdit : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return ControlEdit::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return &reflection_control_text;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<ControlEdit, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<ControlEdit, TypeList<Control*>>());
						case 2: return ConstructorPtr(new ConstructorImpl<ControlEdit, TypeList<Control*, const char*>>());
						case 3: return ConstructorPtr(new ConstructorImpl<ControlEdit, TypeList<Control*, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<ControlEdit>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(bool)>(&ControlEdit::setFrame));
						case 1: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)() const>(&ControlEdit::getFrame));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(bool)>(&ControlEdit::setBackground));
						case 3: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)() const>(&ControlEdit::getBackground));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(const Color&)>(&ControlEdit::setEditColor));
						case 5: return FunctionPtr(new FunctionImpl<const Color&(ControlEdit::*)() const>(&ControlEdit::getEditColor));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(ControlEdit::EditMode)>(&ControlEdit::setEditMode));
						case 7: return FunctionPtr(new FunctionImpl<ControlEdit::EditMode(ControlEdit::*)() const>(&ControlEdit::getEditMode));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(uint32_t)>(&ControlEdit::setPasswordCode));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(ControlEdit::*)() const>(&ControlEdit::getPasswordCode));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(ControlEdit::*)() const>(&ControlEdit::getNumCodes));
						case 11: return FunctionPtr(new FunctionImpl<const uint32_t*(ControlEdit::*)() const>(&ControlEdit::getCodes));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(uint32_t, uint32_t)>(&ControlEdit::setCurrentIndex, {}, Maxu32));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(ControlEdit::*)() const>(&ControlEdit::getCurrentIndex));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(ControlEdit::*)() const>(&ControlEdit::getSelectionIndex));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(bool, bool)>(&ControlEdit::setSelection, false, false));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)()>(&ControlEdit::clearSelection));
						case 17: return FunctionPtr(new FunctionImpl<String(ControlEdit::*)() const>(&ControlEdit::getSelectedText));
						case 18: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)(ControlRoot&, uint32_t, uint32_t)>(&ControlEdit::updateKeyboard));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(const ControlEdit::ClickedCallback&)>(&ControlEdit::setClickedCallback));
						case 20: return FunctionPtr(new FunctionImpl<ControlEdit::ClickedCallback(ControlEdit::*)() const>(&ControlEdit::getClickedCallback));
						case 21: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)()>(&ControlEdit::isClicked));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(const ControlEdit::ChangedCallback&)>(&ControlEdit::setChangedCallback));
						case 23: return FunctionPtr(new FunctionImpl<ControlEdit::ChangedCallback(ControlEdit::*)() const>(&ControlEdit::getChangedCallback));
						case 24: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)()>(&ControlEdit::isChanged));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)(const ControlEdit::ReturnedCallback&)>(&ControlEdit::setReturnedCallback));
						case 26: return FunctionPtr(new FunctionImpl<ControlEdit::ReturnedCallback(ControlEdit::*)() const>(&ControlEdit::getReturnedCallback));
						case 27: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)()>(&ControlEdit::isReturned));
						case 28: return FunctionPtr(new FunctionImpl<CanvasMesh(ControlEdit::*)()>(&ControlEdit::getCanvasMesh));
						case 29: return FunctionPtr(new FunctionImpl<ControlEdit(ControlEdit::*)() const>(&ControlEdit::clonePtr));
						case 30: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)()>(&ControlEdit::clearPtr));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(ControlEdit::*)()>(&ControlEdit::destroyPtr));
						case 32: return FunctionPtr(new FunctionImpl<ControlEdit&(ControlEdit::*)()>(&ControlEdit::acquirePtr));
						case 33: return FunctionPtr(new FunctionImpl<ControlEdit&(ControlEdit::*)()>(&ControlEdit::unacquirePtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)() const>(&ControlEdit::isValidPtr));
						case 35: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)() const>(&ControlEdit::isOwnerPtr));
						case 36: return FunctionPtr(new FunctionImpl<bool(ControlEdit::*)() const>(&ControlEdit::isConstPtr));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(ControlEdit::*)() const>(&ControlEdit::getCountPtr));
						case 38: return FunctionPtr(new FunctionImpl<const void*(ControlEdit::*)() const>(&ControlEdit::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3, 5 };
			static constexpr uint16_t constructor_arg_types[] = { 280, 280, 1877, 280, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 3348, 3348, 4011, 3348, 4011 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3643, 2360, 3519, 2114, 3616, 2316, 3617, 2317, 3773, 2656, 2569, 2199, 3587, 2247, 2750, 3828, 1639, 2749, 4052, 3559, 2196, 3045, 3550, 2186, 3041, 3805, 2712, 3160, 2182, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1585, 4073, 1721, 4073, 308, 4073, 4039, 4039, 1882, 4073, 4039, 4039, 4073, 4073, 1274, 1585, 4073, 307, 1585, 4073, 306, 1585, 4073, 309, 1585, 232, 304, 4073, 4073, 305, 305, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5, 5, 7, 7, 7, 9, 9, 9, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };
			static constexpr uint16_t function_arg_types[] = { 1585, 1585, 1721, 308, 4039, 4039, 4039, 1585, 1585, 324, 4039, 4039, 1734, 1733, 1735 };
			static constexpr uint16_t function_arg_names[] = { 2067, 1568, 1650, 3275, 1649, 2993, 3499, 1946, 1604, 3471, 3231, 1649, 2074, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 984, 2016, 2016, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 249, 247, 1191 };
			static constexpr uint16_t callback_types[] = { 4073, 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 1, 2, 3 };
			static constexpr uint16_t callback_arg_types[] = { 304, 304, 304 };
			static constexpr uint16_t callback_arg_names[] = { 0, 0, 0 };
			static constexpr uint16_t enum_names[] = { 501 };
			static constexpr uint16_t enum_bases[] = { 0, 6 };
			static constexpr uint16_t enum_var_names[] = { 506, 504, 503, 505, 507, 502 };
	};
	constexpr uint16_t ReflectionControlEdit::constructor_bases[];
	constexpr uint16_t ReflectionControlEdit::constructor_arg_types[];
	constexpr uint16_t ReflectionControlEdit::constructor_arg_names[];
	constexpr uint16_t ReflectionControlEdit::constructor_arg_values[];
	constexpr uint8_t ReflectionControlEdit::function_flags[];
	constexpr uint16_t ReflectionControlEdit::function_names[];
	constexpr uint16_t ReflectionControlEdit::function_types[];
	constexpr uint16_t ReflectionControlEdit::function_bases[];
	constexpr uint16_t ReflectionControlEdit::function_arg_types[];
	constexpr uint16_t ReflectionControlEdit::function_arg_names[];
	constexpr uint16_t ReflectionControlEdit::function_arg_values[];
	constexpr uint16_t ReflectionControlEdit::callback_names[];
	constexpr uint16_t ReflectionControlEdit::callback_types[];
	constexpr uint16_t ReflectionControlEdit::callback_bases[];
	constexpr uint16_t ReflectionControlEdit::callback_arg_types[];
	constexpr uint16_t ReflectionControlEdit::callback_arg_names[];
	constexpr uint16_t ReflectionControlEdit::enum_names[];
	constexpr uint16_t ReflectionControlEdit::enum_bases[];
	constexpr uint16_t ReflectionControlEdit::enum_var_names[];
	static ReflectionControlEdit reflection_control_edit;
	
	// Tellusim::DialogMessage
	class ReflectionDialogMessage : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogMessage::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogMessage, TypeList<const char*, const char*>>(nullptr, nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<DialogMessage, TypeList<const String&, const char*>>({}, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<DialogMessage, TypeList<const char*, const String&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<DialogMessage, TypeList<const String&, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogMessage>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)(int32_t, int32_t)>(&DialogMessage::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogMessage::*)() const>(&DialogMessage::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogMessage::*)() const>(&DialogMessage::getPositionY));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)(const char*)>(&DialogMessage::setTitle));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)(const String&)>(&DialogMessage::setTitle));
						case 5: return FunctionPtr(new FunctionImpl<String(DialogMessage::*)() const>(&DialogMessage::getTitle));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)(const char*)>(&DialogMessage::setMessage));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)(const String&)>(&DialogMessage::setMessage));
						case 8: return FunctionPtr(new FunctionImpl<String(DialogMessage::*)() const>(&DialogMessage::getMessage));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)(const DialogMessage::UpdateCallback&)>(&DialogMessage::setUpdateCallback));
						case 10: return FunctionPtr(new FunctionImpl<DialogMessage::UpdateCallback(DialogMessage::*)() const>(&DialogMessage::getUpdateCallback));
						case 11: return FunctionPtr(new FunctionImpl<DialogMessage::Result(DialogMessage::*)(DialogMessage::Flags)>(&DialogMessage::run, DialogMessage::DefaultFlags));
						case 12: return FunctionPtr(new FunctionImpl<DialogMessage(DialogMessage::*)() const>(&DialogMessage::clonePtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)()>(&DialogMessage::clearPtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(DialogMessage::*)()>(&DialogMessage::destroyPtr));
						case 15: return FunctionPtr(new FunctionImpl<DialogMessage&(DialogMessage::*)()>(&DialogMessage::acquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<DialogMessage&(DialogMessage::*)()>(&DialogMessage::unacquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(DialogMessage::*)() const>(&DialogMessage::isValidPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(DialogMessage::*)() const>(&DialogMessage::isOwnerPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(DialogMessage::*)() const>(&DialogMessage::isConstPtr));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(DialogMessage::*)() const>(&DialogMessage::getCountPtr));
						case 21: return FunctionPtr(new FunctionImpl<const void*(DialogMessage::*)() const>(&DialogMessage::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 4, 6, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1877, 1841, 1877, 1877, 1841, 1841, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 4019, 3270, 4019, 3270, 4019, 3270, 4019, 3270 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 3294, 0, 3294, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 3904, 3904, 2860, 3715, 3715, 2509, 3924, 2889, 3475, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 488, 487, 484, 4073, 4073, 485, 485, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 1877, 1841, 1877, 1841, 1774, 486 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 4019, 4019, 3270, 3270, 2074, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 1394 };
			static constexpr uint16_t callback_types[] = { 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 15, 21 };
			static constexpr uint16_t enum_var_names[] = { 678, 750, 675, 681, 604, 608, 662, 741, 688, 621, 665, 751, 682, 437, 1102, 1187, 1185, 1189, 1188, 1190, 1111 };
	};
	constexpr uint16_t ReflectionDialogMessage::constructor_bases[];
	constexpr uint16_t ReflectionDialogMessage::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogMessage::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogMessage::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogMessage::function_flags[];
	constexpr uint16_t ReflectionDialogMessage::function_names[];
	constexpr uint16_t ReflectionDialogMessage::function_types[];
	constexpr uint16_t ReflectionDialogMessage::function_bases[];
	constexpr uint16_t ReflectionDialogMessage::function_arg_types[];
	constexpr uint16_t ReflectionDialogMessage::function_arg_names[];
	constexpr uint16_t ReflectionDialogMessage::function_arg_values[];
	constexpr uint16_t ReflectionDialogMessage::callback_names[];
	constexpr uint16_t ReflectionDialogMessage::callback_types[];
	constexpr uint16_t ReflectionDialogMessage::callback_bases[];
	constexpr uint16_t ReflectionDialogMessage::callback_arg_types[];
	constexpr uint16_t ReflectionDialogMessage::callback_arg_names[];
	constexpr uint16_t ReflectionDialogMessage::enum_names[];
	constexpr uint16_t ReflectionDialogMessage::enum_bases[];
	constexpr uint16_t ReflectionDialogMessage::enum_var_names[];
	static ReflectionDialogMessage reflection_dialog_message;
	
	// Tellusim::DialogFileOpen
	class ReflectionDialogFileOpen : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogFileOpen::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogFileOpen, TypeList<const char*, const char*>>(nullptr, nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<DialogFileOpen, TypeList<const String&, const char*>>({}, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<DialogFileOpen, TypeList<const char*, const String&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<DialogFileOpen, TypeList<const String&, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogFileOpen>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(int32_t, int32_t)>(&DialogFileOpen::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogFileOpen::*)() const>(&DialogFileOpen::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogFileOpen::*)() const>(&DialogFileOpen::getPositionY));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const char*)>(&DialogFileOpen::setTitle));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const String&)>(&DialogFileOpen::setTitle));
						case 5: return FunctionPtr(new FunctionImpl<String(DialogFileOpen::*)() const>(&DialogFileOpen::getTitle));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const char*)>(&DialogFileOpen::setFilter));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const String&)>(&DialogFileOpen::setFilter));
						case 8: return FunctionPtr(new FunctionImpl<String(DialogFileOpen::*)() const>(&DialogFileOpen::getFilter));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const char*)>(&DialogFileOpen::setFile));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const String&)>(&DialogFileOpen::setFile));
						case 11: return FunctionPtr(new FunctionImpl<String(DialogFileOpen::*)() const>(&DialogFileOpen::getFile));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)(const DialogFileOpen::UpdateCallback&)>(&DialogFileOpen::setUpdateCallback));
						case 13: return FunctionPtr(new FunctionImpl<DialogFileOpen::UpdateCallback(DialogFileOpen::*)() const>(&DialogFileOpen::getUpdateCallback));
						case 14: return FunctionPtr(new FunctionImpl<DialogFileOpen::Result(DialogFileOpen::*)(DialogFileOpen::Flags)>(&DialogFileOpen::run, DialogFileOpen::DefaultFlags));
						case 15: return FunctionPtr(new FunctionImpl<DialogFileOpen(DialogFileOpen::*)() const>(&DialogFileOpen::clonePtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)()>(&DialogFileOpen::clearPtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(DialogFileOpen::*)()>(&DialogFileOpen::destroyPtr));
						case 18: return FunctionPtr(new FunctionImpl<DialogFileOpen&(DialogFileOpen::*)()>(&DialogFileOpen::acquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<DialogFileOpen&(DialogFileOpen::*)()>(&DialogFileOpen::unacquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(DialogFileOpen::*)() const>(&DialogFileOpen::isValidPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(DialogFileOpen::*)() const>(&DialogFileOpen::isOwnerPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(DialogFileOpen::*)() const>(&DialogFileOpen::isConstPtr));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(DialogFileOpen::*)() const>(&DialogFileOpen::getCountPtr));
						case 24: return FunctionPtr(new FunctionImpl<const void*(DialogFileOpen::*)() const>(&DialogFileOpen::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 4, 6, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1877, 1841, 1877, 1877, 1841, 1841, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 4019, 3288, 4019, 3288, 4019, 3288, 4019, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 3294, 0, 3294, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 3904, 3904, 2860, 3627, 3627, 2340, 3622, 3622, 2330, 3924, 2889, 3475, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 471, 470, 467, 4073, 4073, 468, 468, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 1877, 1841, 1877, 1841, 1877, 1841, 1769, 469 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 4019, 4019, 2022, 2022, 3288, 3288, 2074, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 1394 };
			static constexpr uint16_t callback_types[] = { 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 5, 8 };
			static constexpr uint16_t enum_var_names[] = { 678, 639, 665, 437, 1102, 1185, 1189, 1111 };
	};
	constexpr uint16_t ReflectionDialogFileOpen::constructor_bases[];
	constexpr uint16_t ReflectionDialogFileOpen::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogFileOpen::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogFileOpen::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogFileOpen::function_flags[];
	constexpr uint16_t ReflectionDialogFileOpen::function_names[];
	constexpr uint16_t ReflectionDialogFileOpen::function_types[];
	constexpr uint16_t ReflectionDialogFileOpen::function_bases[];
	constexpr uint16_t ReflectionDialogFileOpen::function_arg_types[];
	constexpr uint16_t ReflectionDialogFileOpen::function_arg_names[];
	constexpr uint16_t ReflectionDialogFileOpen::function_arg_values[];
	constexpr uint16_t ReflectionDialogFileOpen::callback_names[];
	constexpr uint16_t ReflectionDialogFileOpen::callback_types[];
	constexpr uint16_t ReflectionDialogFileOpen::callback_bases[];
	constexpr uint16_t ReflectionDialogFileOpen::callback_arg_types[];
	constexpr uint16_t ReflectionDialogFileOpen::callback_arg_names[];
	constexpr uint16_t ReflectionDialogFileOpen::enum_names[];
	constexpr uint16_t ReflectionDialogFileOpen::enum_bases[];
	constexpr uint16_t ReflectionDialogFileOpen::enum_var_names[];
	static ReflectionDialogFileOpen reflection_dialog_file_open;
	
	// Tellusim::DialogFileSave
	class ReflectionDialogFileSave : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogFileSave::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogFileSave, TypeList<const char*, const char*>>(nullptr, nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<DialogFileSave, TypeList<const String&, const char*>>({}, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<DialogFileSave, TypeList<const char*, const String&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<DialogFileSave, TypeList<const String&, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogFileSave>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(int32_t, int32_t)>(&DialogFileSave::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogFileSave::*)() const>(&DialogFileSave::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogFileSave::*)() const>(&DialogFileSave::getPositionY));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const char*)>(&DialogFileSave::setTitle));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const String&)>(&DialogFileSave::setTitle));
						case 5: return FunctionPtr(new FunctionImpl<String(DialogFileSave::*)() const>(&DialogFileSave::getTitle));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const char*)>(&DialogFileSave::setFilter));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const String&)>(&DialogFileSave::setFilter));
						case 8: return FunctionPtr(new FunctionImpl<String(DialogFileSave::*)() const>(&DialogFileSave::getFilter));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const char*)>(&DialogFileSave::setFile));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const String&)>(&DialogFileSave::setFile));
						case 11: return FunctionPtr(new FunctionImpl<String(DialogFileSave::*)() const>(&DialogFileSave::getFile));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)(const DialogFileSave::UpdateCallback&)>(&DialogFileSave::setUpdateCallback));
						case 13: return FunctionPtr(new FunctionImpl<DialogFileSave::UpdateCallback(DialogFileSave::*)() const>(&DialogFileSave::getUpdateCallback));
						case 14: return FunctionPtr(new FunctionImpl<DialogFileSave::Result(DialogFileSave::*)(DialogFileSave::Flags)>(&DialogFileSave::run, DialogFileSave::DefaultFlags));
						case 15: return FunctionPtr(new FunctionImpl<DialogFileSave(DialogFileSave::*)() const>(&DialogFileSave::clonePtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)()>(&DialogFileSave::clearPtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(DialogFileSave::*)()>(&DialogFileSave::destroyPtr));
						case 18: return FunctionPtr(new FunctionImpl<DialogFileSave&(DialogFileSave::*)()>(&DialogFileSave::acquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<DialogFileSave&(DialogFileSave::*)()>(&DialogFileSave::unacquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(DialogFileSave::*)() const>(&DialogFileSave::isValidPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(DialogFileSave::*)() const>(&DialogFileSave::isOwnerPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(DialogFileSave::*)() const>(&DialogFileSave::isConstPtr));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(DialogFileSave::*)() const>(&DialogFileSave::getCountPtr));
						case 24: return FunctionPtr(new FunctionImpl<const void*(DialogFileSave::*)() const>(&DialogFileSave::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 4, 6, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1877, 1841, 1877, 1877, 1841, 1841, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 4019, 3288, 4019, 3288, 4019, 3288, 4019, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 3294, 0, 3294, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 3904, 3904, 2860, 3627, 3627, 2340, 3622, 3622, 2330, 3924, 2889, 3475, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 476, 475, 472, 4073, 4073, 473, 473, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 1877, 1841, 1877, 1841, 1877, 1841, 1770, 474 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 4019, 4019, 2022, 2022, 3288, 3288, 2074, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 1394 };
			static constexpr uint16_t callback_types[] = { 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 6, 9 };
			static constexpr uint16_t enum_var_names[] = { 678, 639, 685, 665, 437, 1102, 1185, 1189, 1111 };
	};
	constexpr uint16_t ReflectionDialogFileSave::constructor_bases[];
	constexpr uint16_t ReflectionDialogFileSave::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogFileSave::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogFileSave::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogFileSave::function_flags[];
	constexpr uint16_t ReflectionDialogFileSave::function_names[];
	constexpr uint16_t ReflectionDialogFileSave::function_types[];
	constexpr uint16_t ReflectionDialogFileSave::function_bases[];
	constexpr uint16_t ReflectionDialogFileSave::function_arg_types[];
	constexpr uint16_t ReflectionDialogFileSave::function_arg_names[];
	constexpr uint16_t ReflectionDialogFileSave::function_arg_values[];
	constexpr uint16_t ReflectionDialogFileSave::callback_names[];
	constexpr uint16_t ReflectionDialogFileSave::callback_types[];
	constexpr uint16_t ReflectionDialogFileSave::callback_bases[];
	constexpr uint16_t ReflectionDialogFileSave::callback_arg_types[];
	constexpr uint16_t ReflectionDialogFileSave::callback_arg_names[];
	constexpr uint16_t ReflectionDialogFileSave::enum_names[];
	constexpr uint16_t ReflectionDialogFileSave::enum_bases[];
	constexpr uint16_t ReflectionDialogFileSave::enum_var_names[];
	static ReflectionDialogFileSave reflection_dialog_file_save;
	
	// Tellusim::DialogDirectory
	class ReflectionDialogDirectory : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogDirectory::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogDirectory, TypeList<const char*, const char*>>(nullptr, nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<DialogDirectory, TypeList<const String&, const char*>>({}, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<DialogDirectory, TypeList<const char*, const String&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<DialogDirectory, TypeList<const String&, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogDirectory>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)(int32_t, int32_t)>(&DialogDirectory::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogDirectory::*)() const>(&DialogDirectory::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogDirectory::*)() const>(&DialogDirectory::getPositionY));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)(const char*)>(&DialogDirectory::setTitle));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)(const String&)>(&DialogDirectory::setTitle));
						case 5: return FunctionPtr(new FunctionImpl<String(DialogDirectory::*)() const>(&DialogDirectory::getTitle));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)(const char*)>(&DialogDirectory::setDirectory));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)(const String&)>(&DialogDirectory::setDirectory));
						case 8: return FunctionPtr(new FunctionImpl<String(DialogDirectory::*)() const>(&DialogDirectory::getDirectory));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)(const DialogDirectory::UpdateCallback&)>(&DialogDirectory::setUpdateCallback));
						case 10: return FunctionPtr(new FunctionImpl<DialogDirectory::UpdateCallback(DialogDirectory::*)() const>(&DialogDirectory::getUpdateCallback));
						case 11: return FunctionPtr(new FunctionImpl<DialogDirectory::Result(DialogDirectory::*)(DialogDirectory::Flags)>(&DialogDirectory::run, DialogDirectory::DefaultFlags));
						case 12: return FunctionPtr(new FunctionImpl<DialogDirectory(DialogDirectory::*)() const>(&DialogDirectory::clonePtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)()>(&DialogDirectory::clearPtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(DialogDirectory::*)()>(&DialogDirectory::destroyPtr));
						case 15: return FunctionPtr(new FunctionImpl<DialogDirectory&(DialogDirectory::*)()>(&DialogDirectory::acquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<DialogDirectory&(DialogDirectory::*)()>(&DialogDirectory::unacquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(DialogDirectory::*)() const>(&DialogDirectory::isValidPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(DialogDirectory::*)() const>(&DialogDirectory::isOwnerPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(DialogDirectory::*)() const>(&DialogDirectory::isConstPtr));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(DialogDirectory::*)() const>(&DialogDirectory::getCountPtr));
						case 21: return FunctionPtr(new FunctionImpl<const void*(DialogDirectory::*)() const>(&DialogDirectory::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 4, 6, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1877, 1841, 1877, 1877, 1841, 1841, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 4019, 3288, 4019, 3288, 4019, 3288, 4019, 3288 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 3294, 0, 3294, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 3904, 3904, 2860, 3610, 3610, 2303, 3924, 2889, 3475, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 466, 465, 462, 4073, 4073, 463, 463, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 1877, 1841, 1877, 1841, 1768, 464 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 4019, 4019, 3288, 3288, 2074, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 1394 };
			static constexpr uint16_t callback_types[] = { 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 4, 7 };
			static constexpr uint16_t enum_var_names[] = { 678, 665, 437, 1102, 1185, 1189, 1111 };
	};
	constexpr uint16_t ReflectionDialogDirectory::constructor_bases[];
	constexpr uint16_t ReflectionDialogDirectory::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogDirectory::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogDirectory::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogDirectory::function_flags[];
	constexpr uint16_t ReflectionDialogDirectory::function_names[];
	constexpr uint16_t ReflectionDialogDirectory::function_types[];
	constexpr uint16_t ReflectionDialogDirectory::function_bases[];
	constexpr uint16_t ReflectionDialogDirectory::function_arg_types[];
	constexpr uint16_t ReflectionDialogDirectory::function_arg_names[];
	constexpr uint16_t ReflectionDialogDirectory::function_arg_values[];
	constexpr uint16_t ReflectionDialogDirectory::callback_names[];
	constexpr uint16_t ReflectionDialogDirectory::callback_types[];
	constexpr uint16_t ReflectionDialogDirectory::callback_bases[];
	constexpr uint16_t ReflectionDialogDirectory::callback_arg_types[];
	constexpr uint16_t ReflectionDialogDirectory::callback_arg_names[];
	constexpr uint16_t ReflectionDialogDirectory::enum_names[];
	constexpr uint16_t ReflectionDialogDirectory::enum_bases[];
	constexpr uint16_t ReflectionDialogDirectory::enum_var_names[];
	static ReflectionDialogDirectory reflection_dialog_directory;
	
	// Tellusim::DialogProgress
	class ReflectionDialogProgress : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogProgress::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogProgress, TypeList<const char*, const char*>>(nullptr, nullptr));
						case 1: return ConstructorPtr(new ConstructorImpl<DialogProgress, TypeList<const String&, const char*>>({}, nullptr));
						case 2: return ConstructorPtr(new ConstructorImpl<DialogProgress, TypeList<const char*, const String&>>());
						case 3: return ConstructorPtr(new ConstructorImpl<DialogProgress, TypeList<const String&, const String&>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogProgress>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)(int32_t, int32_t)>(&DialogProgress::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogProgress::*)() const>(&DialogProgress::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogProgress::*)() const>(&DialogProgress::getPositionY));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)(const char*)>(&DialogProgress::setTitle));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)(const String&)>(&DialogProgress::setTitle));
						case 5: return FunctionPtr(new FunctionImpl<String(DialogProgress::*)() const>(&DialogProgress::getTitle));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)(const char*)>(&DialogProgress::setMessage));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)(const String&)>(&DialogProgress::setMessage));
						case 8: return FunctionPtr(new FunctionImpl<String(DialogProgress::*)() const>(&DialogProgress::getMessage));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)(uint32_t)>(&DialogProgress::setProgress));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(DialogProgress::*)() const>(&DialogProgress::getProgress));
						case 11: return FunctionPtr(new FunctionImpl<DialogProgress::Result(DialogProgress::*)(DialogProgress::Flags)>(&DialogProgress::run, DialogProgress::DefaultFlags));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)()>(&DialogProgress::close));
						case 13: return FunctionPtr(new FunctionImpl<DialogProgress(DialogProgress::*)() const>(&DialogProgress::clonePtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)()>(&DialogProgress::clearPtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(DialogProgress::*)()>(&DialogProgress::destroyPtr));
						case 16: return FunctionPtr(new FunctionImpl<DialogProgress&(DialogProgress::*)()>(&DialogProgress::acquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<DialogProgress&(DialogProgress::*)()>(&DialogProgress::unacquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(DialogProgress::*)() const>(&DialogProgress::isValidPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(DialogProgress::*)() const>(&DialogProgress::isOwnerPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(DialogProgress::*)() const>(&DialogProgress::isConstPtr));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(DialogProgress::*)() const>(&DialogProgress::getCountPtr));
						case 22: return FunctionPtr(new FunctionImpl<const void*(DialogProgress::*)() const>(&DialogProgress::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 4, 6, 8 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1877, 1841, 1877, 1877, 1841, 1841, 1841 };
			static constexpr uint16_t constructor_arg_names[] = { 4019, 3270, 4019, 3270, 4019, 3270, 4019, 3270 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 3294, 0, 3294, 0, 0, 0, 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 3904, 3904, 2860, 3715, 3715, 2509, 3791, 2687, 3475, 1648, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4073, 4073, 1274, 4073, 4073, 1274, 4073, 4039, 492, 4073, 489, 4073, 4073, 490, 490, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 1877, 1841, 1877, 1841, 4039, 491 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 4019, 4019, 3270, 3270, 3365, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 4, 7 };
			static constexpr uint16_t enum_var_names[] = { 678, 665, 437, 1102, 1185, 1189, 1111 };
	};
	constexpr uint16_t ReflectionDialogProgress::constructor_bases[];
	constexpr uint16_t ReflectionDialogProgress::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogProgress::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogProgress::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogProgress::function_flags[];
	constexpr uint16_t ReflectionDialogProgress::function_names[];
	constexpr uint16_t ReflectionDialogProgress::function_types[];
	constexpr uint16_t ReflectionDialogProgress::function_bases[];
	constexpr uint16_t ReflectionDialogProgress::function_arg_types[];
	constexpr uint16_t ReflectionDialogProgress::function_arg_names[];
	constexpr uint16_t ReflectionDialogProgress::function_arg_values[];
	constexpr uint16_t ReflectionDialogProgress::callback_names[];
	constexpr uint16_t ReflectionDialogProgress::callback_types[];
	constexpr uint16_t ReflectionDialogProgress::callback_bases[];
	constexpr uint16_t ReflectionDialogProgress::callback_arg_types[];
	constexpr uint16_t ReflectionDialogProgress::callback_arg_names[];
	constexpr uint16_t ReflectionDialogProgress::enum_names[];
	constexpr uint16_t ReflectionDialogProgress::enum_bases[];
	constexpr uint16_t ReflectionDialogProgress::enum_var_names[];
	static ReflectionDialogProgress reflection_dialog_progress;
	
	// Tellusim::DialogColor
	class ReflectionDialogColor : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogColor::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogColor, TypeList<const char*, const Color&>>(nullptr, Color::zero));
						case 1: return ConstructorPtr(new ConstructorImpl<DialogColor, TypeList<const String&, const Color&>>({}, Color::zero));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogColor>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)(int32_t, int32_t)>(&DialogColor::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogColor::*)() const>(&DialogColor::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogColor::*)() const>(&DialogColor::getPositionY));
						case 3: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)(const char*)>(&DialogColor::setTitle));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)(const String&)>(&DialogColor::setTitle));
						case 5: return FunctionPtr(new FunctionImpl<String(DialogColor::*)() const>(&DialogColor::getTitle));
						case 6: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)(const Color&, bool)>(&DialogColor::setColor, {}, false));
						case 7: return FunctionPtr(new FunctionImpl<const Color&(DialogColor::*)() const>(&DialogColor::getColor));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)(const DialogColor::ChangedCallback&)>(&DialogColor::setChangedCallback));
						case 9: return FunctionPtr(new FunctionImpl<DialogColor::ChangedCallback(DialogColor::*)() const>(&DialogColor::getChangedCallback));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)(const DialogColor::UpdateCallback&)>(&DialogColor::setUpdateCallback));
						case 11: return FunctionPtr(new FunctionImpl<DialogColor::UpdateCallback(DialogColor::*)() const>(&DialogColor::getUpdateCallback));
						case 12: return FunctionPtr(new FunctionImpl<DialogColor::Result(DialogColor::*)(DialogColor::Flags)>(&DialogColor::run, DialogColor::DefaultFlags));
						case 13: return FunctionPtr(new FunctionImpl<DialogColor(DialogColor::*)() const>(&DialogColor::clonePtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)()>(&DialogColor::clearPtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(DialogColor::*)()>(&DialogColor::destroyPtr));
						case 16: return FunctionPtr(new FunctionImpl<DialogColor&(DialogColor::*)()>(&DialogColor::acquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<DialogColor&(DialogColor::*)()>(&DialogColor::unacquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(DialogColor::*)() const>(&DialogColor::isValidPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(DialogColor::*)() const>(&DialogColor::isOwnerPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(DialogColor::*)() const>(&DialogColor::isConstPtr));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(DialogColor::*)() const>(&DialogColor::getCountPtr));
						case 22: return FunctionPtr(new FunctionImpl<const void*(DialogColor::*)() const>(&DialogColor::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 2, 4 };
			static constexpr uint16_t constructor_arg_types[] = { 1877, 1721, 1841, 1721 };
			static constexpr uint16_t constructor_arg_names[] = { 4019, 1650, 4019, 1650 };
			static constexpr uint16_t constructor_arg_values[] = { 3294, 253, 0, 253 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 3904, 3904, 2860, 3562, 2200, 3550, 2186, 3924, 2889, 3475, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4073, 4073, 1274, 4073, 1721, 4073, 458, 4073, 461, 460, 456, 4073, 4073, 457, 457, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 3, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 1877, 1841, 1721, 1585, 1766, 1767, 459 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 4019, 4019, 1650, 1601, 2074, 2074, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 2016, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 247, 1394 };
			static constexpr uint16_t callback_types[] = { 4073, 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 1, 1 };
			static constexpr uint16_t callback_arg_types[] = { 251 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 5, 8 };
			static constexpr uint16_t enum_var_names[] = { 678, 583, 665, 437, 1102, 1185, 1189, 1111 };
	};
	constexpr uint16_t ReflectionDialogColor::constructor_bases[];
	constexpr uint16_t ReflectionDialogColor::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogColor::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogColor::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogColor::function_flags[];
	constexpr uint16_t ReflectionDialogColor::function_names[];
	constexpr uint16_t ReflectionDialogColor::function_types[];
	constexpr uint16_t ReflectionDialogColor::function_bases[];
	constexpr uint16_t ReflectionDialogColor::function_arg_types[];
	constexpr uint16_t ReflectionDialogColor::function_arg_names[];
	constexpr uint16_t ReflectionDialogColor::function_arg_values[];
	constexpr uint16_t ReflectionDialogColor::callback_names[];
	constexpr uint16_t ReflectionDialogColor::callback_types[];
	constexpr uint16_t ReflectionDialogColor::callback_bases[];
	constexpr uint16_t ReflectionDialogColor::callback_arg_types[];
	constexpr uint16_t ReflectionDialogColor::callback_arg_names[];
	constexpr uint16_t ReflectionDialogColor::enum_names[];
	constexpr uint16_t ReflectionDialogColor::enum_bases[];
	constexpr uint16_t ReflectionDialogColor::enum_var_names[];
	static ReflectionDialogColor reflection_dialog_color;
	
	// Tellusim::DialogMenu
	class ReflectionDialogMenu : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DialogMenu::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DialogMenu, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DialogMenu>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(int32_t, int32_t)>(&DialogMenu::setPosition));
						case 1: return FunctionPtr(new FunctionImpl<int32_t(DialogMenu::*)() const>(&DialogMenu::getPositionX));
						case 2: return FunctionPtr(new FunctionImpl<int32_t(DialogMenu::*)() const>(&DialogMenu::getPositionY));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)() const>(&DialogMenu::getNumItems));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, const char*)>(&DialogMenu::setItemText));
						case 5: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, const String&)>(&DialogMenu::setItemText));
						case 6: return FunctionPtr(new FunctionImpl<String(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemText));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, const char*)>(&DialogMenu::setItemKey));
						case 8: return FunctionPtr(new FunctionImpl<String(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemKey));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, const Image&)>(&DialogMenu::setItemImage));
						case 10: return FunctionPtr(new FunctionImpl<Image(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemImage));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, bool, bool)>(&DialogMenu::setItemChecked, {}, {}, false));
						case 12: return FunctionPtr(new FunctionImpl<bool(DialogMenu::*)(uint32_t) const>(&DialogMenu::isItemChecked));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, bool)>(&DialogMenu::setItemEnabled));
						case 14: return FunctionPtr(new FunctionImpl<bool(DialogMenu::*)(uint32_t) const>(&DialogMenu::isItemEnabled));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, bool)>(&DialogMenu::setItemHidden));
						case 16: return FunctionPtr(new FunctionImpl<bool(DialogMenu::*)(uint32_t) const>(&DialogMenu::isItemHidden));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(uint32_t, uint32_t)>(&DialogMenu::setItemsGroup));
						case 18: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemGroupIndex));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemGroupSize));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const char*, const char*)>(&DialogMenu::addItem, {}, nullptr));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const String&, const char*)>(&DialogMenu::addItem, {}, nullptr));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const char*, const Image&, const char*)>(&DialogMenu::addItem, {}, Image::null, nullptr));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const String&, const Image&, const char*)>(&DialogMenu::addItem, {}, Image::null, nullptr));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const char*, const DialogMenu::ClickedCallback&, const char*)>(&DialogMenu::addItem, {}, {}, nullptr));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const String&, const DialogMenu::ClickedCallback&, const char*)>(&DialogMenu::addItem, {}, {}, nullptr));
						case 26: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const char*, const Image&, const DialogMenu::ClickedCallback&, const char*)>(&DialogMenu::addItem, {}, Image::null, {}, nullptr));
						case 27: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const String&, const Image&, const DialogMenu::ClickedCallback&, const char*)>(&DialogMenu::addItem, {}, Image::null, {}, nullptr));
						case 28: return FunctionPtr(new FunctionImpl<DialogMenu::ClickedCallback(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemClickedCallback));
						case 29: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const char*, bool, const DialogMenu::ChangedCallback&, const char*)>(&DialogMenu::addItem, {}, {}, {}, nullptr));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const String&, bool, const DialogMenu::ChangedCallback&, const char*)>(&DialogMenu::addItem, {}, {}, {}, nullptr));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const char*, const Image&, bool, const DialogMenu::ChangedCallback&, const char*)>(&DialogMenu::addItem, {}, Image::null, {}, {}, nullptr));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)(const String&, const Image&, bool, const DialogMenu::ChangedCallback&, const char*)>(&DialogMenu::addItem, {}, Image::null, {}, {}, nullptr));
						case 33: return FunctionPtr(new FunctionImpl<DialogMenu::ChangedCallback(DialogMenu::*)(uint32_t) const>(&DialogMenu::getItemChangedCallback));
						case 34: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)(const DialogMenu::UpdateCallback&)>(&DialogMenu::setUpdateCallback));
						case 35: return FunctionPtr(new FunctionImpl<DialogMenu::UpdateCallback(DialogMenu::*)() const>(&DialogMenu::getUpdateCallback));
						case 36: return FunctionPtr(new FunctionImpl<DialogMenu::Result(DialogMenu::*)(DialogMenu::Flags)>(&DialogMenu::run, DialogMenu::DefaultFlags));
						case 37: return FunctionPtr(new FunctionImpl<DialogMenu(DialogMenu::*)() const>(&DialogMenu::clonePtr));
						case 38: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)()>(&DialogMenu::clearPtr));
						case 39: return FunctionPtr(new FunctionVoidImpl<void(DialogMenu::*)()>(&DialogMenu::destroyPtr));
						case 40: return FunctionPtr(new FunctionImpl<DialogMenu&(DialogMenu::*)()>(&DialogMenu::acquirePtr));
						case 41: return FunctionPtr(new FunctionImpl<DialogMenu&(DialogMenu::*)()>(&DialogMenu::unacquirePtr));
						case 42: return FunctionPtr(new FunctionImpl<bool(DialogMenu::*)() const>(&DialogMenu::isValidPtr));
						case 43: return FunctionPtr(new FunctionImpl<bool(DialogMenu::*)() const>(&DialogMenu::isOwnerPtr));
						case 44: return FunctionPtr(new FunctionImpl<bool(DialogMenu::*)() const>(&DialogMenu::isConstPtr));
						case 45: return FunctionPtr(new FunctionImpl<uint32_t(DialogMenu::*)() const>(&DialogMenu::getCountPtr));
						case 46: return FunctionPtr(new FunctionImpl<const void*(DialogMenu::*)() const>(&DialogMenu::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 3782, 2675, 2676, 2591, 3690, 3690, 2455, 3687, 2453, 3686, 2452, 3680, 3104, 3683, 3106, 3685, 3108, 3692, 2450, 2451, 1523, 1523, 1523, 1523, 1523, 1523, 1523, 1523, 2447, 1523, 1523, 1523, 1523, 2444, 3924, 2889, 3475, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 3003, 3003, 4039, 4073, 4073, 1274, 4073, 1274, 4073, 838, 4073, 1585, 4073, 1585, 4073, 1585, 4073, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 480, 4039, 4039, 4039, 4039, 479, 4073, 483, 482, 477, 4073, 4073, 478, 478, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 2, 2, 2, 2, 4, 6, 7, 9, 10, 12, 13, 16, 17, 19, 20, 22, 23, 25, 26, 27, 29, 31, 34, 37, 40, 43, 47, 51, 52, 56, 60, 65, 70, 71, 72, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73 };
			static constexpr uint16_t function_arg_types[] = { 3003, 3003, 4039, 1877, 4039, 1841, 4039, 4039, 1877, 4039, 4039, 1781, 4039, 4039, 1585, 1585, 4039, 4039, 1585, 4039, 4039, 1585, 4039, 4039, 4039, 4039, 4039, 1877, 1877, 1841, 1877, 1877, 1781, 1877, 1841, 1781, 1877, 1877, 1772, 1877, 1841, 1772, 1877, 1877, 1781, 1772, 1877, 1841, 1781, 1772, 1877, 4039, 1877, 1585, 1771, 1877, 1841, 1585, 1771, 1877, 1877, 1781, 1585, 1771, 1877, 1841, 1781, 1585, 1771, 1877, 4039, 1773, 481 };
			static constexpr uint16_t function_arg_names[] = { 4115, 4116, 2993, 4011, 2993, 4011, 2993, 2993, 3231, 2993, 2993, 2989, 2993, 2993, 1608, 1601, 2993, 2993, 1996, 2993, 2993, 2981, 2993, 2993, 3960, 2993, 2993, 4011, 3231, 4011, 3231, 4011, 2989, 3231, 4011, 2989, 3231, 4011, 2074, 3231, 4011, 2074, 3231, 4011, 2989, 2074, 3231, 4011, 2989, 2074, 3231, 2993, 4011, 1608, 2074, 3231, 4011, 1608, 2074, 3231, 4011, 2989, 1608, 2074, 3231, 4011, 2989, 1608, 2074, 3231, 2993, 2074, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3294, 0, 3294, 0, 0, 3294, 0, 0, 3294, 0, 0, 3294, 0, 0, 3294, 0, 0, 0, 3294, 0, 0, 0, 3294, 0, 0, 0, 0, 3294, 0, 0, 0, 3294, 0, 0, 0, 0, 3294, 0, 0, 0, 0, 3294, 0, 0, 437 };
			static constexpr uint16_t callback_names[] = { 249, 247, 1394 };
			static constexpr uint16_t callback_types[] = { 4073, 4073, 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 0, 1, 1 };
			static constexpr uint16_t callback_arg_types[] = { 1585 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 753, 1184 };
			static constexpr uint16_t enum_bases[] = { 0, 4, 7 };
			static constexpr uint16_t enum_var_names[] = { 678, 665, 437, 1102, 1185, 1186, 1111 };
	};
	constexpr uint16_t ReflectionDialogMenu::constructor_bases[];
	constexpr uint16_t ReflectionDialogMenu::constructor_arg_types[];
	constexpr uint16_t ReflectionDialogMenu::constructor_arg_names[];
	constexpr uint16_t ReflectionDialogMenu::constructor_arg_values[];
	constexpr uint8_t ReflectionDialogMenu::function_flags[];
	constexpr uint16_t ReflectionDialogMenu::function_names[];
	constexpr uint16_t ReflectionDialogMenu::function_types[];
	constexpr uint16_t ReflectionDialogMenu::function_bases[];
	constexpr uint16_t ReflectionDialogMenu::function_arg_types[];
	constexpr uint16_t ReflectionDialogMenu::function_arg_names[];
	constexpr uint16_t ReflectionDialogMenu::function_arg_values[];
	constexpr uint16_t ReflectionDialogMenu::callback_names[];
	constexpr uint16_t ReflectionDialogMenu::callback_types[];
	constexpr uint16_t ReflectionDialogMenu::callback_bases[];
	constexpr uint16_t ReflectionDialogMenu::callback_arg_types[];
	constexpr uint16_t ReflectionDialogMenu::callback_arg_names[];
	constexpr uint16_t ReflectionDialogMenu::enum_names[];
	constexpr uint16_t ReflectionDialogMenu::enum_bases[];
	constexpr uint16_t ReflectionDialogMenu::enum_var_names[];
	static ReflectionDialogMenu reflection_dialog_menu;
	
	// Tellusim::CubeFilter
	class ReflectionCubeFilter : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return CubeFilter::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<CubeFilter, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<CubeFilter>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(CubeFilter::*)()>(&CubeFilter::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(CubeFilter::Mode) const>(&CubeFilter::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(CubeFilter::*)() const>(&CubeFilter::getGroupSize));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(CubeFilter::*)() const>(&CubeFilter::getMaxOrder));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(CubeFilter::*)() const>(&CubeFilter::getMaxSize));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(CubeFilter::*)() const>(&CubeFilter::getHarmonics));
						case 6: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(const Device&, CubeFilter::Mode, uint32_t, uint32_t, uint32_t)>(&CubeFilter::create, Device::null, (CubeFilter::Mode)0, 3, 1024, 256));
						case 7: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(const Device&, CubeFilter::Flags, uint32_t, uint32_t, uint32_t)>(&CubeFilter::create, Device::null, (CubeFilter::Flags)0, 3, 1024, 256));
						case 8: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(Compute&, Buffer&, uint32_t, Texture&, const Slice&) const>(&CubeFilter::dispatch));
						case 9: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(Compute&, Buffer&, uint32_t, Texture&) const>(&CubeFilter::dispatch));
						case 10: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(Compute&, Texture&, const Slice&, Buffer&, uint32_t) const>(&CubeFilter::dispatch));
						case 11: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)(Compute&, Texture&, Buffer&, uint32_t) const>(&CubeFilter::dispatch));
						case 12: return FunctionPtr(new FunctionImpl<CubeFilter(CubeFilter::*)() const>(&CubeFilter::clonePtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(CubeFilter::*)()>(&CubeFilter::clearPtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(CubeFilter::*)()>(&CubeFilter::destroyPtr));
						case 15: return FunctionPtr(new FunctionImpl<CubeFilter&(CubeFilter::*)()>(&CubeFilter::acquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<CubeFilter&(CubeFilter::*)()>(&CubeFilter::unacquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)() const>(&CubeFilter::isValidPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)() const>(&CubeFilter::isOwnerPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(CubeFilter::*)() const>(&CubeFilter::isConstPtr));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(CubeFilter::*)() const>(&CubeFilter::getCountPtr));
						case 21: return FunctionPtr(new FunctionImpl<const void*(CubeFilter::*)() const>(&CubeFilter::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2401, 2492, 2496, 2408, 1902, 1902, 1975, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 4039, 4039, 4039, 1585, 1585, 1585, 1585, 1585, 1585, 369, 4073, 4073, 370, 370, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 6, 11, 16, 20, 25, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 };
			static constexpr uint16_t function_arg_types[] = { 372, 1764, 372, 4039, 4039, 4039, 1764, 371, 4039, 4039, 4039, 274, 153, 4039, 1294, 1839, 274, 153, 4039, 1294, 274, 1294, 1839, 153, 4039, 274, 1294, 153, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3275, 1969, 3275, 3339, 3960, 2937, 1969, 2045, 3339, 3960, 2937, 1662, 1593, 3317, 4012, 3967, 1662, 1593, 3317, 4012, 1662, 4012, 3967, 1593, 3317, 1662, 4012, 1593, 3317 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 18, 11, 17, 0, 0, 18, 11, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 6 };
			static constexpr uint16_t enum_var_names[] = { 1045, 1049, 1106, 617, 686, 754 };
	};
	constexpr uint16_t ReflectionCubeFilter::constructor_bases[];
	constexpr uint16_t ReflectionCubeFilter::constructor_arg_types[];
	constexpr uint16_t ReflectionCubeFilter::constructor_arg_names[];
	constexpr uint16_t ReflectionCubeFilter::constructor_arg_values[];
	constexpr uint8_t ReflectionCubeFilter::function_flags[];
	constexpr uint16_t ReflectionCubeFilter::function_names[];
	constexpr uint16_t ReflectionCubeFilter::function_types[];
	constexpr uint16_t ReflectionCubeFilter::function_bases[];
	constexpr uint16_t ReflectionCubeFilter::function_arg_types[];
	constexpr uint16_t ReflectionCubeFilter::function_arg_names[];
	constexpr uint16_t ReflectionCubeFilter::function_arg_values[];
	constexpr uint16_t ReflectionCubeFilter::callback_names[];
	constexpr uint16_t ReflectionCubeFilter::callback_types[];
	constexpr uint16_t ReflectionCubeFilter::callback_bases[];
	constexpr uint16_t ReflectionCubeFilter::callback_arg_types[];
	constexpr uint16_t ReflectionCubeFilter::callback_arg_names[];
	constexpr uint16_t ReflectionCubeFilter::enum_names[];
	constexpr uint16_t ReflectionCubeFilter::enum_bases[];
	constexpr uint16_t ReflectionCubeFilter::enum_var_names[];
	static ReflectionCubeFilter reflection_cube_filter;
	
	// Tellusim::DecoderJPEG
	class ReflectionDecoderJPEG : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return DecoderJPEG::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<DecoderJPEG, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<DecoderJPEG>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(DecoderJPEG::*)()>(&DecoderJPEG::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(DecoderJPEG::Mode) const>(&DecoderJPEG::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::Mode)>(&DecoderJPEG::isYUV));
						case 3: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(const Device&, DecoderJPEG::Mode)>(&DecoderJPEG::create));
						case 4: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(const Device&, DecoderJPEG::Flags)>(&DecoderJPEG::create));
						case 5: return FunctionPtr(new FunctionImpl<bool(const char*, Image&, DecoderJPEG::Mode&, Size&)>(&DecoderJPEG::load));
						case 6: return FunctionPtr(new FunctionImpl<bool(Stream&, Image&, DecoderJPEG::Mode&, Size&)>(&DecoderJPEG::load));
						case 7: return FunctionPtr(new FunctionImpl<Texture(DecoderJPEG::*)(const Device&, const char*, Texture::Flags) const>(&DecoderJPEG::loadTexture, Device::null, {}, Texture::DefaultFlags));
						case 8: return FunctionPtr(new FunctionImpl<Texture(DecoderJPEG::*)(const Device&, Stream&, Texture::Flags) const>(&DecoderJPEG::loadTexture, Device::null, Stream::null, Texture::DefaultFlags));
						case 9: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(Compute&, DecoderJPEG::Mode, Texture&, Texture&, const Slice&, const Slice&) const>(&DecoderJPEG::dispatch));
						case 10: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(Compute&, DecoderJPEG::Mode, Texture&, Texture&, const Slice&) const>(&DecoderJPEG::dispatch));
						case 11: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(Compute&, DecoderJPEG::Mode, Texture&, Texture&) const>(&DecoderJPEG::dispatch));
						case 12: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(Compute&, DecoderJPEG::Mode, Texture&, Texture&, const Slice&, const Slice&) const>(&DecoderJPEG::dispatchYUV));
						case 13: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(Compute&, DecoderJPEG::Mode, Texture&, Texture&, const Slice&) const>(&DecoderJPEG::dispatchYUV));
						case 14: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)(Compute&, DecoderJPEG::Mode, Texture&, Texture&) const>(&DecoderJPEG::dispatchYUV));
						case 15: return FunctionPtr(new FunctionImpl<DecoderJPEG(DecoderJPEG::*)() const>(&DecoderJPEG::clonePtr));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(DecoderJPEG::*)()>(&DecoderJPEG::clearPtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(DecoderJPEG::*)()>(&DecoderJPEG::destroyPtr));
						case 18: return FunctionPtr(new FunctionImpl<DecoderJPEG&(DecoderJPEG::*)()>(&DecoderJPEG::acquirePtr));
						case 19: return FunctionPtr(new FunctionImpl<DecoderJPEG&(DecoderJPEG::*)()>(&DecoderJPEG::unacquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)() const>(&DecoderJPEG::isValidPtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)() const>(&DecoderJPEG::isOwnerPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(DecoderJPEG::*)() const>(&DecoderJPEG::isConstPtr));
						case 23: return FunctionPtr(new FunctionImpl<uint32_t(DecoderJPEG::*)() const>(&DecoderJPEG::getCountPtr));
						case 24: return FunctionPtr(new FunctionImpl<const void*(DecoderJPEG::*)() const>(&DecoderJPEG::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 1, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 3211, 1902, 1902, 3242, 3242, 3249, 3249, 1975, 1975, 1975, 1977, 1977, 1977, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1293, 1293, 1585, 1585, 1585, 1585, 1585, 1585, 432, 4073, 4073, 433, 433, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 4, 6, 10, 14, 17, 20, 26, 31, 35, 41, 46, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50 };
			static constexpr uint16_t function_arg_types[] = { 435, 435, 1764, 435, 1764, 434, 1877, 839, 436, 1216, 1273, 839, 436, 1216, 1764, 1877, 1297, 1764, 1273, 1297, 274, 435, 1294, 1294, 1839, 1839, 274, 435, 1294, 1294, 1839, 274, 435, 1294, 1294, 274, 435, 1294, 1294, 1839, 1839, 274, 435, 1294, 1294, 1839, 274, 435, 1294, 1294 };
			static constexpr uint16_t function_arg_names[] = { 3275, 3275, 1969, 3275, 1969, 2045, 3288, 2989, 3275, 3960, 3990, 2989, 3275, 3960, 1969, 3288, 2045, 1969, 3990, 2045, 1662, 3275, 1963, 3975, 1967, 3982, 1662, 3275, 1963, 3975, 3982, 1662, 3275, 1963, 3975, 1662, 3275, 1963, 3975, 1967, 3982, 1662, 3275, 1963, 3975, 3982, 1662, 3275, 1963, 3975 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1295, 0, 0, 1295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 8, 17 };
			static constexpr uint16_t enum_var_names[] = { 1050, 1051, 1052, 1078, 1076, 1077, 1075, 1106, 678, 689, 690, 691, 749, 747, 748, 746, 754 };
	};
	constexpr uint16_t ReflectionDecoderJPEG::constructor_bases[];
	constexpr uint16_t ReflectionDecoderJPEG::constructor_arg_types[];
	constexpr uint16_t ReflectionDecoderJPEG::constructor_arg_names[];
	constexpr uint16_t ReflectionDecoderJPEG::constructor_arg_values[];
	constexpr uint8_t ReflectionDecoderJPEG::function_flags[];
	constexpr uint16_t ReflectionDecoderJPEG::function_names[];
	constexpr uint16_t ReflectionDecoderJPEG::function_types[];
	constexpr uint16_t ReflectionDecoderJPEG::function_bases[];
	constexpr uint16_t ReflectionDecoderJPEG::function_arg_types[];
	constexpr uint16_t ReflectionDecoderJPEG::function_arg_names[];
	constexpr uint16_t ReflectionDecoderJPEG::function_arg_values[];
	constexpr uint16_t ReflectionDecoderJPEG::callback_names[];
	constexpr uint16_t ReflectionDecoderJPEG::callback_types[];
	constexpr uint16_t ReflectionDecoderJPEG::callback_bases[];
	constexpr uint16_t ReflectionDecoderJPEG::callback_arg_types[];
	constexpr uint16_t ReflectionDecoderJPEG::callback_arg_names[];
	constexpr uint16_t ReflectionDecoderJPEG::enum_names[];
	constexpr uint16_t ReflectionDecoderJPEG::enum_bases[];
	constexpr uint16_t ReflectionDecoderJPEG::enum_var_names[];
	static ReflectionDecoderJPEG reflection_decoder_jpeg;
	
	// Tellusim::EncoderBC15
	class ReflectionEncoderBC15 : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return EncoderBC15::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<EncoderBC15, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<EncoderBC15>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(EncoderBC15::*)()>(&EncoderBC15::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)(EncoderBC15::Mode) const>(&EncoderBC15::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)(const Device&, EncoderBC15::Mode)>(&EncoderBC15::create));
						case 3: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)(const Device&, EncoderBC15::Flags)>(&EncoderBC15::create));
						case 4: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)(Compute&, EncoderBC15::Mode, Texture&, Texture&, const Slice&, const Slice&) const>(&EncoderBC15::dispatch));
						case 5: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)(Compute&, EncoderBC15::Mode, Texture&, Texture&, const Slice&) const>(&EncoderBC15::dispatch));
						case 6: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)(Compute&, EncoderBC15::Mode, Texture&, Texture&) const>(&EncoderBC15::dispatch));
						case 7: return FunctionPtr(new FunctionImpl<EncoderBC15(EncoderBC15::*)() const>(&EncoderBC15::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(EncoderBC15::*)()>(&EncoderBC15::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(EncoderBC15::*)()>(&EncoderBC15::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<EncoderBC15&(EncoderBC15::*)()>(&EncoderBC15::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<EncoderBC15&(EncoderBC15::*)()>(&EncoderBC15::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)() const>(&EncoderBC15::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)() const>(&EncoderBC15::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(EncoderBC15::*)() const>(&EncoderBC15::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(EncoderBC15::*)() const>(&EncoderBC15::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(EncoderBC15::*)() const>(&EncoderBC15::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 1902, 1902, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 512, 4073, 4073, 513, 513, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 3, 5, 11, 16, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 };
			static constexpr uint16_t function_arg_types[] = { 515, 1764, 515, 1764, 514, 274, 515, 1294, 1294, 1839, 1839, 274, 515, 1294, 1294, 1839, 274, 515, 1294, 1294 };
			static constexpr uint16_t function_arg_names[] = { 3275, 1969, 3275, 1969, 2045, 1662, 3275, 1963, 3975, 1967, 3982, 1662, 3275, 1963, 3975, 3982, 1662, 3275, 1963, 3975 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 6, 16 };
			static constexpr uint16_t enum_var_names[] = { 1037, 1038, 1039, 1040, 1041, 1106, 678, 585, 586, 587, 588, 589, 617, 756, 757, 754 };
	};
	constexpr uint16_t ReflectionEncoderBC15::constructor_bases[];
	constexpr uint16_t ReflectionEncoderBC15::constructor_arg_types[];
	constexpr uint16_t ReflectionEncoderBC15::constructor_arg_names[];
	constexpr uint16_t ReflectionEncoderBC15::constructor_arg_values[];
	constexpr uint8_t ReflectionEncoderBC15::function_flags[];
	constexpr uint16_t ReflectionEncoderBC15::function_names[];
	constexpr uint16_t ReflectionEncoderBC15::function_types[];
	constexpr uint16_t ReflectionEncoderBC15::function_bases[];
	constexpr uint16_t ReflectionEncoderBC15::function_arg_types[];
	constexpr uint16_t ReflectionEncoderBC15::function_arg_names[];
	constexpr uint16_t ReflectionEncoderBC15::function_arg_values[];
	constexpr uint16_t ReflectionEncoderBC15::callback_names[];
	constexpr uint16_t ReflectionEncoderBC15::callback_types[];
	constexpr uint16_t ReflectionEncoderBC15::callback_bases[];
	constexpr uint16_t ReflectionEncoderBC15::callback_arg_types[];
	constexpr uint16_t ReflectionEncoderBC15::callback_arg_names[];
	constexpr uint16_t ReflectionEncoderBC15::enum_names[];
	constexpr uint16_t ReflectionEncoderBC15::enum_bases[];
	constexpr uint16_t ReflectionEncoderBC15::enum_var_names[];
	static ReflectionEncoderBC15 reflection_encoder_bc15;
	
	// Tellusim::EncoderBC67
	class ReflectionEncoderBC67 : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return EncoderBC67::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<EncoderBC67, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<EncoderBC67>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(EncoderBC67::*)()>(&EncoderBC67::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)(EncoderBC67::Mode) const>(&EncoderBC67::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)(const Device&, EncoderBC67::Mode)>(&EncoderBC67::create));
						case 3: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)(const Device&, EncoderBC67::Flags)>(&EncoderBC67::create));
						case 4: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)(Compute&, EncoderBC67::Mode, Texture&, Texture&, const Slice&, const Slice&, uint32_t) const>(&EncoderBC67::dispatch, Compute::null, (EncoderBC67::Mode)0, Texture::null, Texture::null, {}, {}, 4));
						case 5: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)(Compute&, EncoderBC67::Mode, Texture&, Texture&, const Slice&, uint32_t) const>(&EncoderBC67::dispatch, Compute::null, (EncoderBC67::Mode)0, Texture::null, Texture::null, {}, 4));
						case 6: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)(Compute&, EncoderBC67::Mode, Texture&, Texture&, uint32_t) const>(&EncoderBC67::dispatch, Compute::null, (EncoderBC67::Mode)0, Texture::null, Texture::null, 4));
						case 7: return FunctionPtr(new FunctionImpl<EncoderBC67(EncoderBC67::*)() const>(&EncoderBC67::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(EncoderBC67::*)()>(&EncoderBC67::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(EncoderBC67::*)()>(&EncoderBC67::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<EncoderBC67&(EncoderBC67::*)()>(&EncoderBC67::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<EncoderBC67&(EncoderBC67::*)()>(&EncoderBC67::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)() const>(&EncoderBC67::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)() const>(&EncoderBC67::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(EncoderBC67::*)() const>(&EncoderBC67::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(EncoderBC67::*)() const>(&EncoderBC67::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(EncoderBC67::*)() const>(&EncoderBC67::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 1902, 1902, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 516, 4073, 4073, 517, 517, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 3, 5, 12, 18, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23 };
			static constexpr uint16_t function_arg_types[] = { 519, 1764, 519, 1764, 518, 274, 519, 1294, 1294, 1839, 1839, 4039, 274, 519, 1294, 1294, 1839, 4039, 274, 519, 1294, 1294, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3275, 1969, 3275, 1969, 2045, 1662, 3275, 1963, 3975, 1967, 3982, 1661, 1662, 3275, 1963, 3975, 3982, 1661, 1662, 3275, 1963, 3975, 1661 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 4, 10 };
			static constexpr uint16_t enum_var_names[] = { 1042, 1043, 1044, 1106, 678, 590, 591, 592, 617, 754 };
	};
	constexpr uint16_t ReflectionEncoderBC67::constructor_bases[];
	constexpr uint16_t ReflectionEncoderBC67::constructor_arg_types[];
	constexpr uint16_t ReflectionEncoderBC67::constructor_arg_names[];
	constexpr uint16_t ReflectionEncoderBC67::constructor_arg_values[];
	constexpr uint8_t ReflectionEncoderBC67::function_flags[];
	constexpr uint16_t ReflectionEncoderBC67::function_names[];
	constexpr uint16_t ReflectionEncoderBC67::function_types[];
	constexpr uint16_t ReflectionEncoderBC67::function_bases[];
	constexpr uint16_t ReflectionEncoderBC67::function_arg_types[];
	constexpr uint16_t ReflectionEncoderBC67::function_arg_names[];
	constexpr uint16_t ReflectionEncoderBC67::function_arg_values[];
	constexpr uint16_t ReflectionEncoderBC67::callback_names[];
	constexpr uint16_t ReflectionEncoderBC67::callback_types[];
	constexpr uint16_t ReflectionEncoderBC67::callback_bases[];
	constexpr uint16_t ReflectionEncoderBC67::callback_arg_types[];
	constexpr uint16_t ReflectionEncoderBC67::callback_arg_names[];
	constexpr uint16_t ReflectionEncoderBC67::enum_names[];
	constexpr uint16_t ReflectionEncoderBC67::enum_bases[];
	constexpr uint16_t ReflectionEncoderBC67::enum_var_names[];
	static ReflectionEncoderBC67 reflection_encoder_bc67;
	
	// Tellusim::EncoderASTC
	class ReflectionEncoderASTC : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return EncoderASTC::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<EncoderASTC, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<EncoderASTC>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(EncoderASTC::*)()>(&EncoderASTC::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)(EncoderASTC::Mode) const>(&EncoderASTC::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)(const Device&, EncoderASTC::Mode)>(&EncoderASTC::create));
						case 3: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)(const Device&, EncoderASTC::Flags)>(&EncoderASTC::create));
						case 4: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)(Compute&, EncoderASTC::Mode, Texture&, Texture&, const Slice&, const Slice&, uint32_t) const>(&EncoderASTC::dispatch, Compute::null, (EncoderASTC::Mode)0, Texture::null, Texture::null, {}, {}, 4));
						case 5: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)(Compute&, EncoderASTC::Mode, Texture&, Texture&, const Slice&, uint32_t) const>(&EncoderASTC::dispatch, Compute::null, (EncoderASTC::Mode)0, Texture::null, Texture::null, {}, 4));
						case 6: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)(Compute&, EncoderASTC::Mode, Texture&, Texture&, uint32_t) const>(&EncoderASTC::dispatch, Compute::null, (EncoderASTC::Mode)0, Texture::null, Texture::null, 4));
						case 7: return FunctionPtr(new FunctionImpl<EncoderASTC(EncoderASTC::*)() const>(&EncoderASTC::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(EncoderASTC::*)()>(&EncoderASTC::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(EncoderASTC::*)()>(&EncoderASTC::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<EncoderASTC&(EncoderASTC::*)()>(&EncoderASTC::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<EncoderASTC&(EncoderASTC::*)()>(&EncoderASTC::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)() const>(&EncoderASTC::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)() const>(&EncoderASTC::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(EncoderASTC::*)() const>(&EncoderASTC::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(EncoderASTC::*)() const>(&EncoderASTC::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(EncoderASTC::*)() const>(&EncoderASTC::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 1902, 1902, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 508, 4073, 4073, 509, 509, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 3, 5, 12, 18, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23 };
			static constexpr uint16_t function_arg_types[] = { 511, 1764, 511, 1764, 510, 274, 511, 1294, 1294, 1839, 1839, 4039, 274, 511, 1294, 1294, 1839, 4039, 274, 511, 1294, 1294, 4039 };
			static constexpr uint16_t function_arg_names[] = { 3275, 1969, 3275, 1969, 2045, 1662, 3275, 1963, 3975, 1967, 3982, 1661, 1662, 3275, 1963, 3975, 3982, 1661, 1662, 3275, 1963, 3975, 1661 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 4, 10 };
			static constexpr uint16_t enum_var_names[] = { 1034, 1035, 1036, 1106, 678, 578, 579, 580, 617, 754 };
	};
	constexpr uint16_t ReflectionEncoderASTC::constructor_bases[];
	constexpr uint16_t ReflectionEncoderASTC::constructor_arg_types[];
	constexpr uint16_t ReflectionEncoderASTC::constructor_arg_names[];
	constexpr uint16_t ReflectionEncoderASTC::constructor_arg_values[];
	constexpr uint8_t ReflectionEncoderASTC::function_flags[];
	constexpr uint16_t ReflectionEncoderASTC::function_names[];
	constexpr uint16_t ReflectionEncoderASTC::function_types[];
	constexpr uint16_t ReflectionEncoderASTC::function_bases[];
	constexpr uint16_t ReflectionEncoderASTC::function_arg_types[];
	constexpr uint16_t ReflectionEncoderASTC::function_arg_names[];
	constexpr uint16_t ReflectionEncoderASTC::function_arg_values[];
	constexpr uint16_t ReflectionEncoderASTC::callback_names[];
	constexpr uint16_t ReflectionEncoderASTC::callback_types[];
	constexpr uint16_t ReflectionEncoderASTC::callback_bases[];
	constexpr uint16_t ReflectionEncoderASTC::callback_arg_types[];
	constexpr uint16_t ReflectionEncoderASTC::callback_arg_names[];
	constexpr uint16_t ReflectionEncoderASTC::enum_names[];
	constexpr uint16_t ReflectionEncoderASTC::enum_bases[];
	constexpr uint16_t ReflectionEncoderASTC::enum_var_names[];
	static ReflectionEncoderASTC reflection_encoder_astc;
	
	// Tellusim::MeshModel
	class ReflectionMeshModel : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return MeshModel::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<MeshModel, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<MeshModel>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)()>(&MeshModel::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)() const>(&MeshModel::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<MeshModel::Flags(MeshModel::*)() const>(&MeshModel::getFlags));
						case 3: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(MeshModel::Flags) const>(&MeshModel::hasFlag));
						case 4: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(MeshModel::Flags) const>(&MeshModel::hasFlags));
						case 5: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(const Device&, const Pipeline&, const char*, MeshModel::Flags, Async*)>(&MeshModel::load, Device::null, Pipeline::null, {}, MeshModel::DefaultFlags, nullptr));
						case 6: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(const Device&, const Pipeline&, Stream&, MeshModel::Flags, Async*)>(&MeshModel::load, Device::null, Pipeline::null, Stream::null, MeshModel::DefaultFlags, nullptr));
						case 7: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(const Device&, const Pipeline&, const char*, MeshModel::Flags)>(&MeshModel::create, Device::null, Pipeline::null, {}, MeshModel::DefaultFlags));
						case 8: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(const Device&, const Pipeline&, const Mesh&, MeshModel::Flags)>(&MeshModel::create, Device::null, Pipeline::null, Mesh::null, MeshModel::DefaultFlags));
						case 9: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(const Device&, const Pipeline&, const MeshGeometry&, MeshModel::Flags)>(&MeshModel::create, Device::null, Pipeline::null, MeshGeometry::null, MeshModel::DefaultFlags));
						case 10: return FunctionPtr(new FunctionImpl<bool(MeshModel::*)(const Device&, const Pipeline&, const Array<MeshGeometry>&, MeshModel::Flags)>(&MeshModel::create, Device::null, Pipeline::null, {}, MeshModel::DefaultFlags));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(const MeshModel::CreateCallback&)>(&MeshModel::setVertexBufferCallback));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(const MeshModel::CreateCallback&)>(&MeshModel::setIndexBufferCallback));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(const MeshModel::CreateCallback&)>(&MeshModel::setMeshBufferCallback));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(Command&, uint32_t, const Pipeline*) const>(&MeshModel::setBuffers, Command::null, 0, nullptr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(Command&) const>(&MeshModel::draw));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(Command&, uint32_t) const>(&MeshModel::draw));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(Command&, uint32_t, uint32_t) const>(&MeshModel::draw));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(Command&, uint32_t, uint32_t, uint32_t) const>(&MeshModel::drawInstanced, Command::null, {}, {}, 0));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(MeshModel::*)(Command&, uint32_t, uint32_t, uint32_t, uint32_t) const>(&MeshModel::drawInstanced));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)() const>(&MeshModel::getNumVertices));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)() const>(&MeshModel::getNumVertexBuffers));
						case 22: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getVertexBufferStride));
						case 23: return FunctionPtr(new FunctionImpl<size_t(MeshModel::*)(uint32_t) const>(&MeshModel::getVertexBufferOffset));
						case 24: return FunctionPtr(new FunctionImpl<Buffer(MeshModel::*)() const>(&MeshModel::getVertexBuffer));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)() const>(&MeshModel::getNumIndices));
						case 26: return FunctionPtr(new FunctionImpl<Format(MeshModel::*)() const>(&MeshModel::getIndexFormat));
						case 27: return FunctionPtr(new FunctionImpl<Buffer(MeshModel::*)() const>(&MeshModel::getIndexBuffer));
						case 28: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)() const>(&MeshModel::getNumMeshlets));
						case 29: return FunctionPtr(new FunctionImpl<Buffer(MeshModel::*)() const>(&MeshModel::getMeshletBuffer));
						case 30: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)() const>(&MeshModel::getNumGeometries));
						case 31: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getNumGeometryIndices));
						case 32: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getNumGeometryVertices));
						case 33: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getNumGeometryMeshlets));
						case 34: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getGeometryBaseIndex));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getGeometryBaseVertex));
						case 36: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getGeometryBaseMeshlet));
						case 37: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t) const>(&MeshModel::getNumMaterials));
						case 38: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t, uint32_t) const>(&MeshModel::getNumMaterialIndices));
						case 39: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t, uint32_t) const>(&MeshModel::getNumMaterialVertices));
						case 40: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t, uint32_t) const>(&MeshModel::getNumMaterialMeshlets));
						case 41: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t, uint32_t) const>(&MeshModel::getMaterialBaseIndex));
						case 42: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t, uint32_t) const>(&MeshModel::getMaterialBaseVertex));
						case 43: return FunctionPtr(new FunctionImpl<uint32_t(MeshModel::*)(uint32_t, uint32_t) const>(&MeshModel::getMaterialBaseMeshlet));
						case 44: return FunctionPtr(new FunctionImpl<size_t(MeshModel::*)() const>(&MeshModel::getMemory));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2341, 2947, 2948, 3242, 3242, 1902, 1902, 1902, 1902, 3929, 3667, 3711, 3537, 1981, 1981, 1981, 1988, 1988, 2624, 2623, 2907, 2906, 2905, 2588, 2424, 2422, 2598, 2508, 2582, 2583, 2587, 2584, 2391, 2393, 2392, 2597, 2594, 2596, 2595, 2484, 2486, 2485, 2500 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1017, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 4039, 4039, 4039, 3961, 152, 4039, 765, 152, 4039, 152, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 3961 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 1, 2, 7, 12, 16, 20, 24, 28, 29, 30, 31, 34, 35, 37, 40, 44, 49, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 70 };
			static constexpr uint16_t function_arg_types[] = { 1017, 1017, 1764, 1826, 1877, 1017, 62, 1764, 1826, 1273, 1017, 62, 1764, 1826, 1877, 1017, 1764, 1826, 1801, 1017, 1764, 1826, 1809, 1017, 1764, 1826, 1682, 1017, 1816, 1816, 1816, 264, 4039, 1827, 264, 264, 4039, 264, 4039, 4039, 264, 4039, 4039, 4039, 264, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 2045, 1969, 3350, 3288, 2045, 1559, 1969, 3350, 3990, 2045, 1559, 1969, 3350, 3288, 2045, 1969, 3350, 3269, 2045, 1969, 3350, 2077, 2045, 1969, 3350, 2076, 2045, 2074, 2074, 2074, 1653, 2993, 3350, 1653, 1653, 2077, 1653, 2077, 3262, 1653, 2077, 3306, 1572, 1653, 2077, 3262, 3306, 1572, 2993, 2993, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 3262, 2077, 3262, 2077, 3262, 2077, 3262, 2077, 3262, 2077, 3262 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 437, 3294, 0, 0, 0, 437, 3294, 0, 0, 0, 437, 0, 0, 0, 437, 0, 0, 0, 437, 0, 0, 0, 437, 0, 0, 0, 0, 3, 3294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 368 };
			static constexpr uint16_t callback_types[] = { 1585 };
			static constexpr uint16_t callback_bases[] = { 0, 3 };
			static constexpr uint16_t callback_arg_types[] = { 1885, 3961, 1585 };
			static constexpr uint16_t callback_arg_names[] = { 3975, 3960, 3341 };
			static constexpr uint16_t enum_names[] = { 753 };
			static constexpr uint16_t enum_bases[] = { 0, 21 };
			static constexpr uint16_t enum_var_names[] = { 678, 618, 738, 683, 653, 642, 643, 644, 659, 658, 660, 657, 603, 599, 600, 602, 598, 601, 661, 437, 1102 };
	};
	constexpr uint16_t ReflectionMeshModel::constructor_bases[];
	constexpr uint16_t ReflectionMeshModel::constructor_arg_types[];
	constexpr uint16_t ReflectionMeshModel::constructor_arg_names[];
	constexpr uint16_t ReflectionMeshModel::constructor_arg_values[];
	constexpr uint8_t ReflectionMeshModel::function_flags[];
	constexpr uint16_t ReflectionMeshModel::function_names[];
	constexpr uint16_t ReflectionMeshModel::function_types[];
	constexpr uint16_t ReflectionMeshModel::function_bases[];
	constexpr uint16_t ReflectionMeshModel::function_arg_types[];
	constexpr uint16_t ReflectionMeshModel::function_arg_names[];
	constexpr uint16_t ReflectionMeshModel::function_arg_values[];
	constexpr uint16_t ReflectionMeshModel::callback_names[];
	constexpr uint16_t ReflectionMeshModel::callback_types[];
	constexpr uint16_t ReflectionMeshModel::callback_bases[];
	constexpr uint16_t ReflectionMeshModel::callback_arg_types[];
	constexpr uint16_t ReflectionMeshModel::callback_arg_names[];
	constexpr uint16_t ReflectionMeshModel::enum_names[];
	constexpr uint16_t ReflectionMeshModel::enum_bases[];
	constexpr uint16_t ReflectionMeshModel::enum_var_names[];
	static ReflectionMeshModel reflection_mesh_model;
	
	// Tellusim::SeparableFilter
	class ReflectionSeparableFilter : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return SeparableFilter::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<SeparableFilter, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<SeparableFilter>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)()>(&SeparableFilter::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)(Format, uint32_t) const>(&SeparableFilter::isCreated));
						case 2: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(SeparableFilter::Mode, const char*)>(&SeparableFilter::setInputSource));
						case 3: return FunctionPtr(new FunctionImpl<String(SeparableFilter::*)(SeparableFilter::Mode) const>(&SeparableFilter::getInputSource));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(SeparableFilter::Mode, const char*)>(&SeparableFilter::setOutputSource));
						case 5: return FunctionPtr(new FunctionImpl<String(SeparableFilter::*)(SeparableFilter::Mode) const>(&SeparableFilter::getOutputSource));
						case 6: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)(const Device&, Format, uint32_t, SeparableFilter::Flags)>(&SeparableFilter::create, Device::null, (Format)0, {}, SeparableFilter::DefaultFlags));
						case 7: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(SeparableFilter::Mode, const Array<Vector4f>&, bool)>(&SeparableFilter::setWeights, (SeparableFilter::Mode)0, {}, false));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(SeparableFilter::Mode, const Array<float32_t>&, bool)>(&SeparableFilter::setWeights, (SeparableFilter::Mode)0, {}, false));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(uint32_t, const Vector4f&)>(&SeparableFilter::setGaussianWeights));
						case 10: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(uint32_t, float32_t)>(&SeparableFilter::setGaussianWeights));
						case 11: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(uint32_t)>(&SeparableFilter::setSobelXWeights));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(uint32_t)>(&SeparableFilter::setSobelYWeights));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)(uint32_t)>(&SeparableFilter::setBoxWeights));
						case 14: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)(Compute&, SeparableFilter::Mode, uint32_t, Texture&, Texture&, const Slice&, const Slice&, const Vector4f&) const>(&SeparableFilter::dispatch, Compute::null, (SeparableFilter::Mode)0, {}, Texture::null, Texture::null, {}, {}, Vector4f::zero));
						case 15: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)(Compute&, SeparableFilter::Mode, uint32_t, Texture&, Texture&, const Slice&, const Vector4f&) const>(&SeparableFilter::dispatch, Compute::null, (SeparableFilter::Mode)0, {}, Texture::null, Texture::null, {}, Vector4f::zero));
						case 16: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)(Compute&, SeparableFilter::Mode, uint32_t, Texture&, Texture&, const Vector4f&) const>(&SeparableFilter::dispatch, Compute::null, (SeparableFilter::Mode)0, {}, Texture::null, Texture::null, Vector4f::zero));
						case 17: return FunctionPtr(new FunctionImpl<SeparableFilter(SeparableFilter::*)() const>(&SeparableFilter::clonePtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)()>(&SeparableFilter::clearPtr));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(SeparableFilter::*)()>(&SeparableFilter::destroyPtr));
						case 20: return FunctionPtr(new FunctionImpl<SeparableFilter&(SeparableFilter::*)()>(&SeparableFilter::acquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<SeparableFilter&(SeparableFilter::*)()>(&SeparableFilter::unacquirePtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)() const>(&SeparableFilter::isValidPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)() const>(&SeparableFilter::isOwnerPtr));
						case 24: return FunctionPtr(new FunctionImpl<bool(SeparableFilter::*)() const>(&SeparableFilter::isConstPtr));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(SeparableFilter::*)() const>(&SeparableFilter::getCountPtr));
						case 26: return FunctionPtr(new FunctionImpl<const void*(SeparableFilter::*)() const>(&SeparableFilter::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 3677, 2432, 3765, 2634, 1902, 3945, 3945, 3649, 3649, 3833, 3834, 3532, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4073, 1274, 4073, 1274, 1585, 4073, 4073, 4073, 4073, 4073, 4073, 4073, 1585, 1585, 1585, 1201, 4073, 4073, 1202, 1202, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 2, 4, 5, 7, 8, 12, 15, 18, 20, 22, 23, 24, 25, 33, 40, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46 };
			static constexpr uint16_t function_arg_types[] = { 765, 4039, 1204, 1877, 1204, 1204, 1877, 1204, 1764, 765, 4039, 1203, 1204, 1699, 1585, 1204, 1701, 1585, 4039, 1858, 4039, 2051, 4039, 4039, 4039, 274, 1204, 4039, 1294, 1294, 1839, 1839, 1858, 274, 1204, 4039, 1294, 1294, 1839, 1858, 274, 1204, 4039, 1294, 1294, 1858 };
			static constexpr uint16_t function_arg_names[] = { 2066, 3960, 3275, 3975, 3275, 3275, 3975, 3275, 1969, 2066, 3960, 2045, 3275, 4088, 3293, 3275, 4088, 3293, 3960, 3956, 3960, 3956, 3960, 3960, 3960, 1662, 3275, 3960, 1963, 3975, 1967, 3982, 3347, 1662, 3275, 3960, 1963, 3975, 3982, 3347, 1662, 3275, 3960, 1963, 3975, 3347 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 437, 0, 0, 2016, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1424, 0, 0, 0, 0, 0, 0, 1424, 0, 0, 0, 0, 0, 1424 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 7 };
			static constexpr uint16_t enum_var_names[] = { 1047, 1074, 1106, 678, 703, 752, 437 };
	};
	constexpr uint16_t ReflectionSeparableFilter::constructor_bases[];
	constexpr uint16_t ReflectionSeparableFilter::constructor_arg_types[];
	constexpr uint16_t ReflectionSeparableFilter::constructor_arg_names[];
	constexpr uint16_t ReflectionSeparableFilter::constructor_arg_values[];
	constexpr uint8_t ReflectionSeparableFilter::function_flags[];
	constexpr uint16_t ReflectionSeparableFilter::function_names[];
	constexpr uint16_t ReflectionSeparableFilter::function_types[];
	constexpr uint16_t ReflectionSeparableFilter::function_bases[];
	constexpr uint16_t ReflectionSeparableFilter::function_arg_types[];
	constexpr uint16_t ReflectionSeparableFilter::function_arg_names[];
	constexpr uint16_t ReflectionSeparableFilter::function_arg_values[];
	constexpr uint16_t ReflectionSeparableFilter::callback_names[];
	constexpr uint16_t ReflectionSeparableFilter::callback_types[];
	constexpr uint16_t ReflectionSeparableFilter::callback_bases[];
	constexpr uint16_t ReflectionSeparableFilter::callback_arg_types[];
	constexpr uint16_t ReflectionSeparableFilter::callback_arg_names[];
	constexpr uint16_t ReflectionSeparableFilter::enum_names[];
	constexpr uint16_t ReflectionSeparableFilter::enum_bases[];
	constexpr uint16_t ReflectionSeparableFilter::enum_var_names[];
	static ReflectionSeparableFilter reflection_separable_filter;
	
	// Tellusim::PrefixScan
	class ReflectionPrefixScan : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return PrefixScan::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<PrefixScan, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<PrefixScan>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(PrefixScan::*)()>(&PrefixScan::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(PrefixScan::Flags) const>(&PrefixScan::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(PrefixScan::*)() const>(&PrefixScan::getGroupSize));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(PrefixScan::*)() const>(&PrefixScan::getScanElements));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(PrefixScan::*)() const>(&PrefixScan::getMaxElements));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(PrefixScan::*)() const>(&PrefixScan::getMaxRegions));
						case 6: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(const Device&, PrefixScan::Mode, uint32_t, uint32_t, Async*)>(&PrefixScan::create, Device::null, (PrefixScan::Mode)0, 256, 1, nullptr));
						case 7: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(const Device&, PrefixScan::Flags, uint32_t, uint32_t, Async*)>(&PrefixScan::create, Device::null, (PrefixScan::Flags)0, 256, 1, nullptr));
						case 8: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(Compute&, Buffer&, uint32_t, uint32_t)>(&PrefixScan::dispatch));
						case 9: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(Compute&, Buffer&, uint32_t, const uint32_t*, const uint32_t*, PrefixScan::Flags)>(&PrefixScan::dispatch, Compute::null, Buffer::null, {}, {}, {}, PrefixScan::FlagNone));
						case 10: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(Compute&, Buffer&, Buffer&, uint32_t, PrefixScan::Flags, uint32_t)>(&PrefixScan::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, {}, PrefixScan::FlagNone, Maxu32));
						case 11: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(Compute&, Buffer&, uint32_t, Buffer&, uint32_t, PrefixScan::Flags, uint32_t)>(&PrefixScan::dispatchIndirect, Compute::null, Buffer::null, {}, Buffer::null, {}, PrefixScan::FlagNone, Maxu32));
						case 12: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)(Compute&, Buffer&, Buffer&, Buffer&, uint32_t, uint32_t, PrefixScan::Flags, uint32_t)>(&PrefixScan::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, Buffer::null, {}, {}, PrefixScan::FlagNone, Maxu32));
						case 13: return FunctionPtr(new FunctionImpl<PrefixScan(PrefixScan::*)() const>(&PrefixScan::clonePtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(PrefixScan::*)()>(&PrefixScan::clearPtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(PrefixScan::*)()>(&PrefixScan::destroyPtr));
						case 16: return FunctionPtr(new FunctionImpl<PrefixScan&(PrefixScan::*)()>(&PrefixScan::acquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<PrefixScan&(PrefixScan::*)()>(&PrefixScan::unacquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)() const>(&PrefixScan::isValidPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)() const>(&PrefixScan::isOwnerPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(PrefixScan::*)() const>(&PrefixScan::isConstPtr));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(PrefixScan::*)() const>(&PrefixScan::getCountPtr));
						case 22: return FunctionPtr(new FunctionImpl<const void*(PrefixScan::*)() const>(&PrefixScan::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2401, 2732, 2488, 2494, 1902, 1902, 1975, 1975, 1976, 1976, 1976, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 4039, 4039, 4039, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1148, 4073, 4073, 1149, 1149, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 6, 11, 15, 21, 27, 34, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42 };
			static constexpr uint16_t function_arg_types[] = { 1150, 1764, 1151, 4039, 4039, 62, 1764, 1150, 4039, 4039, 62, 274, 153, 4039, 4039, 274, 153, 4039, 1882, 1882, 1150, 274, 153, 153, 4039, 1150, 4039, 274, 153, 4039, 153, 4039, 1150, 4039, 274, 153, 153, 153, 4039, 4039, 1150, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1969, 3275, 2937, 3404, 1559, 1969, 2045, 2937, 3404, 1559, 1662, 1948, 3317, 3960, 1662, 1948, 1900, 3318, 3966, 2045, 1662, 1948, 1975, 3317, 2045, 3267, 1662, 1948, 1900, 1975, 3317, 2045, 3267, 1662, 1948, 1900, 1975, 1901, 1978, 2045, 3267 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 17, 6, 3294, 0, 0, 17, 6, 3294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 678, 984, 0, 0, 0, 0, 0, 678, 984, 0, 0, 0, 0, 0, 0, 678, 984 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 9 };
			static constexpr uint16_t enum_var_names[] = { 1061, 1048, 1106, 678, 716, 666, 645, 703, 754 };
	};
	constexpr uint16_t ReflectionPrefixScan::constructor_bases[];
	constexpr uint16_t ReflectionPrefixScan::constructor_arg_types[];
	constexpr uint16_t ReflectionPrefixScan::constructor_arg_names[];
	constexpr uint16_t ReflectionPrefixScan::constructor_arg_values[];
	constexpr uint8_t ReflectionPrefixScan::function_flags[];
	constexpr uint16_t ReflectionPrefixScan::function_names[];
	constexpr uint16_t ReflectionPrefixScan::function_types[];
	constexpr uint16_t ReflectionPrefixScan::function_bases[];
	constexpr uint16_t ReflectionPrefixScan::function_arg_types[];
	constexpr uint16_t ReflectionPrefixScan::function_arg_names[];
	constexpr uint16_t ReflectionPrefixScan::function_arg_values[];
	constexpr uint16_t ReflectionPrefixScan::callback_names[];
	constexpr uint16_t ReflectionPrefixScan::callback_types[];
	constexpr uint16_t ReflectionPrefixScan::callback_bases[];
	constexpr uint16_t ReflectionPrefixScan::callback_arg_types[];
	constexpr uint16_t ReflectionPrefixScan::callback_arg_names[];
	constexpr uint16_t ReflectionPrefixScan::enum_names[];
	constexpr uint16_t ReflectionPrefixScan::enum_bases[];
	constexpr uint16_t ReflectionPrefixScan::enum_var_names[];
	static ReflectionPrefixScan reflection_prefix_scan;
	
	// Tellusim::RadixSort
	class ReflectionRadixSort : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return RadixSort::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<RadixSort, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<RadixSort>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(RadixSort::*)()>(&RadixSort::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(RadixSort::Flags) const>(&RadixSort::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getDataSize));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getGroupSize));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getSortElements));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getUpdateElements));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getMaxElements));
						case 7: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getMaxRegions));
						case 8: return FunctionPtr(new FunctionImpl<PrefixScan(RadixSort::*)() const>(&RadixSort::getPrefixScan));
						case 9: return FunctionPtr(new FunctionImpl<Buffer(RadixSort::*)() const>(&RadixSort::getDataBuffer));
						case 10: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(const Device&, RadixSort::Mode, PrefixScan&, uint32_t, uint32_t, uint32_t, Async*)>(&RadixSort::create, Device::null, (RadixSort::Mode)0, PrefixScan::null, {}, 256, 1, nullptr));
						case 11: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(const Device&, RadixSort::Flags, PrefixScan&, uint32_t, uint32_t, uint32_t, Async*)>(&RadixSort::create, Device::null, (RadixSort::Flags)0, PrefixScan::null, {}, 256, 1, nullptr));
						case 12: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(Compute&, Buffer&, uint32_t, uint32_t, uint32_t, RadixSort::Flags, uint32_t)>(&RadixSort::dispatch, Compute::null, Buffer::null, {}, {}, {}, RadixSort::FlagNone, 32));
						case 13: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(Compute&, Buffer&, uint32_t, const uint32_t*, const uint32_t*, const uint32_t*, RadixSort::Flags, uint32_t)>(&RadixSort::dispatch, Compute::null, Buffer::null, {}, {}, {}, {}, RadixSort::FlagNone, 32));
						case 14: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(Compute&, Buffer&, Buffer&, uint32_t, RadixSort::Flags, uint32_t, uint32_t)>(&RadixSort::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, {}, RadixSort::FlagNone, 32, Maxu32));
						case 15: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(Compute&, Buffer&, uint32_t, Buffer&, uint32_t, RadixSort::Flags, uint32_t, uint32_t)>(&RadixSort::dispatchIndirect, Compute::null, Buffer::null, {}, Buffer::null, {}, RadixSort::FlagNone, 32, Maxu32));
						case 16: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)(Compute&, Buffer&, Buffer&, Buffer&, uint32_t, uint32_t, RadixSort::Flags, uint32_t, uint32_t)>(&RadixSort::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, Buffer::null, {}, {}, RadixSort::FlagNone, 32, Maxu32));
						case 17: return FunctionPtr(new FunctionImpl<RadixSort(RadixSort::*)() const>(&RadixSort::clonePtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(RadixSort::*)()>(&RadixSort::clearPtr));
						case 19: return FunctionPtr(new FunctionVoidImpl<void(RadixSort::*)()>(&RadixSort::destroyPtr));
						case 20: return FunctionPtr(new FunctionImpl<RadixSort&(RadixSort::*)()>(&RadixSort::acquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<RadixSort&(RadixSort::*)()>(&RadixSort::unacquirePtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)() const>(&RadixSort::isValidPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)() const>(&RadixSort::isOwnerPtr));
						case 24: return FunctionPtr(new FunctionImpl<bool(RadixSort::*)() const>(&RadixSort::isConstPtr));
						case 25: return FunctionPtr(new FunctionImpl<uint32_t(RadixSort::*)() const>(&RadixSort::getCountPtr));
						case 26: return FunctionPtr(new FunctionImpl<const void*(RadixSort::*)() const>(&RadixSort::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2263, 2401, 2764, 2890, 2488, 2494, 2679, 2262, 1902, 1902, 1975, 1975, 1976, 1976, 1976, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 4039, 4039, 4039, 4039, 4039, 1148, 152, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1171, 4073, 4073, 1172, 1172, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 15, 22, 30, 37, 45, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54 };
			static constexpr uint16_t function_arg_types[] = { 1173, 1764, 1174, 1149, 4039, 4039, 4039, 62, 1764, 1173, 1149, 4039, 4039, 4039, 62, 274, 153, 4039, 4039, 4039, 1173, 4039, 274, 153, 4039, 1882, 1882, 1882, 1173, 4039, 274, 153, 153, 4039, 1173, 4039, 4039, 274, 153, 4039, 153, 4039, 1173, 4039, 4039, 274, 153, 153, 153, 4039, 4039, 1173, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1969, 3275, 3487, 3960, 2937, 3404, 1559, 1969, 2045, 3487, 3960, 2937, 3404, 1559, 1662, 1948, 3233, 1949, 3960, 2045, 1582, 1662, 1948, 1900, 3234, 1950, 3966, 2045, 1582, 1662, 1948, 1975, 3317, 2045, 1582, 3267, 1662, 1948, 1900, 1975, 3317, 2045, 1582, 3267, 1662, 1948, 1900, 1975, 1901, 1978, 2045, 1582, 3267 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 17, 6, 3294, 0, 0, 0, 0, 17, 6, 3294, 0, 0, 0, 0, 0, 678, 19, 0, 0, 0, 0, 0, 0, 678, 19, 0, 0, 0, 0, 678, 19, 984, 0, 0, 0, 0, 0, 678, 19, 984, 0, 0, 0, 0, 0, 0, 678, 19, 984 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 11 };
			static constexpr uint16_t enum_var_names[] = { 1061, 1048, 1106, 678, 716, 666, 645, 684, 730, 709, 754 };
	};
	constexpr uint16_t ReflectionRadixSort::constructor_bases[];
	constexpr uint16_t ReflectionRadixSort::constructor_arg_types[];
	constexpr uint16_t ReflectionRadixSort::constructor_arg_names[];
	constexpr uint16_t ReflectionRadixSort::constructor_arg_values[];
	constexpr uint8_t ReflectionRadixSort::function_flags[];
	constexpr uint16_t ReflectionRadixSort::function_names[];
	constexpr uint16_t ReflectionRadixSort::function_types[];
	constexpr uint16_t ReflectionRadixSort::function_bases[];
	constexpr uint16_t ReflectionRadixSort::function_arg_types[];
	constexpr uint16_t ReflectionRadixSort::function_arg_names[];
	constexpr uint16_t ReflectionRadixSort::function_arg_values[];
	constexpr uint16_t ReflectionRadixSort::callback_names[];
	constexpr uint16_t ReflectionRadixSort::callback_types[];
	constexpr uint16_t ReflectionRadixSort::callback_bases[];
	constexpr uint16_t ReflectionRadixSort::callback_arg_types[];
	constexpr uint16_t ReflectionRadixSort::callback_arg_names[];
	constexpr uint16_t ReflectionRadixSort::enum_names[];
	constexpr uint16_t ReflectionRadixSort::enum_bases[];
	constexpr uint16_t ReflectionRadixSort::enum_var_names[];
	static ReflectionRadixSort reflection_radix_sort;
	
	// Tellusim::BitonicSort
	class ReflectionBitonicSort : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return BitonicSort::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<BitonicSort, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<BitonicSort>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(BitonicSort::*)()>(&BitonicSort::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(BitonicSort::Flags) const>(&BitonicSort::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(BitonicSort::*)() const>(&BitonicSort::getDataSize));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(BitonicSort::*)() const>(&BitonicSort::getGroupSize));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(BitonicSort::*)() const>(&BitonicSort::getSortElements));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(BitonicSort::*)() const>(&BitonicSort::getMaxRegions));
						case 6: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(const Device&, BitonicSort::Mode, uint32_t, uint32_t, uint32_t, Async*)>(&BitonicSort::create, Device::null, (BitonicSort::Mode)0, {}, 256, 1, nullptr));
						case 7: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(const Device&, BitonicSort::Flags, uint32_t, uint32_t, uint32_t, Async*)>(&BitonicSort::create, Device::null, (BitonicSort::Flags)0, {}, 256, 1, nullptr));
						case 8: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(Compute&, Buffer&, uint32_t, uint32_t, uint32_t, BitonicSort::Flags)>(&BitonicSort::dispatch, Compute::null, Buffer::null, {}, {}, {}, BitonicSort::FlagNone));
						case 9: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(Compute&, Buffer&, uint32_t, const uint32_t*, const uint32_t*, const uint32_t*, BitonicSort::Flags)>(&BitonicSort::dispatch, Compute::null, Buffer::null, {}, {}, {}, {}, BitonicSort::FlagNone));
						case 10: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(Compute&, Buffer&, Buffer&, uint32_t, BitonicSort::Flags)>(&BitonicSort::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, {}, BitonicSort::FlagNone));
						case 11: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(Compute&, Buffer&, uint32_t, Buffer&, uint32_t, BitonicSort::Flags)>(&BitonicSort::dispatchIndirect, Compute::null, Buffer::null, {}, Buffer::null, {}, BitonicSort::FlagNone));
						case 12: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)(Compute&, Buffer&, Buffer&, Buffer&, uint32_t, uint32_t, BitonicSort::Flags)>(&BitonicSort::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, Buffer::null, {}, {}, BitonicSort::FlagNone));
						case 13: return FunctionPtr(new FunctionImpl<BitonicSort(BitonicSort::*)() const>(&BitonicSort::clonePtr));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(BitonicSort::*)()>(&BitonicSort::clearPtr));
						case 15: return FunctionPtr(new FunctionVoidImpl<void(BitonicSort::*)()>(&BitonicSort::destroyPtr));
						case 16: return FunctionPtr(new FunctionImpl<BitonicSort&(BitonicSort::*)()>(&BitonicSort::acquirePtr));
						case 17: return FunctionPtr(new FunctionImpl<BitonicSort&(BitonicSort::*)()>(&BitonicSort::unacquirePtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)() const>(&BitonicSort::isValidPtr));
						case 19: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)() const>(&BitonicSort::isOwnerPtr));
						case 20: return FunctionPtr(new FunctionImpl<bool(BitonicSort::*)() const>(&BitonicSort::isConstPtr));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(BitonicSort::*)() const>(&BitonicSort::getCountPtr));
						case 22: return FunctionPtr(new FunctionImpl<const void*(BitonicSort::*)() const>(&BitonicSort::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2263, 2401, 2764, 2494, 1902, 1902, 1975, 1975, 1976, 1976, 1976, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 4039, 4039, 4039, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 118, 4073, 4073, 119, 119, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 7, 13, 19, 26, 31, 37, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44 };
			static constexpr uint16_t function_arg_types[] = { 120, 1764, 121, 4039, 4039, 4039, 62, 1764, 120, 4039, 4039, 4039, 62, 274, 153, 4039, 4039, 4039, 120, 274, 153, 4039, 1882, 1882, 1882, 120, 274, 153, 153, 4039, 120, 274, 153, 4039, 153, 4039, 120, 274, 153, 153, 153, 4039, 4039, 120 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1969, 3275, 3960, 2937, 3404, 1559, 1969, 2045, 3960, 2937, 3404, 1559, 1662, 1948, 3233, 1949, 3960, 2045, 1662, 1948, 1900, 3234, 1950, 3966, 2045, 1662, 1948, 1975, 3317, 2045, 1662, 1948, 1900, 1975, 3317, 2045, 1662, 1948, 1900, 1975, 1901, 1978, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 17, 6, 3294, 0, 0, 0, 17, 6, 3294, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 0, 678 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 9 };
			static constexpr uint16_t enum_var_names[] = { 1061, 1048, 1106, 678, 716, 666, 645, 684, 754 };
	};
	constexpr uint16_t ReflectionBitonicSort::constructor_bases[];
	constexpr uint16_t ReflectionBitonicSort::constructor_arg_types[];
	constexpr uint16_t ReflectionBitonicSort::constructor_arg_names[];
	constexpr uint16_t ReflectionBitonicSort::constructor_arg_values[];
	constexpr uint8_t ReflectionBitonicSort::function_flags[];
	constexpr uint16_t ReflectionBitonicSort::function_names[];
	constexpr uint16_t ReflectionBitonicSort::function_types[];
	constexpr uint16_t ReflectionBitonicSort::function_bases[];
	constexpr uint16_t ReflectionBitonicSort::function_arg_types[];
	constexpr uint16_t ReflectionBitonicSort::function_arg_names[];
	constexpr uint16_t ReflectionBitonicSort::function_arg_values[];
	constexpr uint16_t ReflectionBitonicSort::callback_names[];
	constexpr uint16_t ReflectionBitonicSort::callback_types[];
	constexpr uint16_t ReflectionBitonicSort::callback_bases[];
	constexpr uint16_t ReflectionBitonicSort::callback_arg_types[];
	constexpr uint16_t ReflectionBitonicSort::callback_arg_names[];
	constexpr uint16_t ReflectionBitonicSort::enum_names[];
	constexpr uint16_t ReflectionBitonicSort::enum_bases[];
	constexpr uint16_t ReflectionBitonicSort::enum_var_names[];
	static ReflectionBitonicSort reflection_bitonic_sort;
	
	// Tellusim::SpatialGrid
	class ReflectionSpatialGrid : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return SpatialGrid::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<SpatialGrid, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<SpatialGrid>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(SpatialGrid::*)()>(&SpatialGrid::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)() const>(&SpatialGrid::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(SpatialGrid::*)() const>(&SpatialGrid::getGroupSize));
						case 3: return FunctionPtr(new FunctionImpl<RadixSort(SpatialGrid::*)() const>(&SpatialGrid::getRadixSort));
						case 4: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)(const Device&, RadixSort&, uint32_t)>(&SpatialGrid::create, Device::null, RadixSort::null, 256));
						case 5: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)(Compute&, Buffer&, uint32_t, uint32_t, uint32_t)>(&SpatialGrid::dispatch, Compute::null, Buffer::null, {}, {}, 32));
						case 6: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)(Compute&, Buffer&, Buffer&, uint32_t, uint32_t)>(&SpatialGrid::dispatchIndirect, Compute::null, Buffer::null, Buffer::null, {}, Maxu32));
						case 7: return FunctionPtr(new FunctionImpl<SpatialGrid(SpatialGrid::*)() const>(&SpatialGrid::clonePtr));
						case 8: return FunctionPtr(new FunctionVoidImpl<void(SpatialGrid::*)()>(&SpatialGrid::clearPtr));
						case 9: return FunctionPtr(new FunctionVoidImpl<void(SpatialGrid::*)()>(&SpatialGrid::destroyPtr));
						case 10: return FunctionPtr(new FunctionImpl<SpatialGrid&(SpatialGrid::*)()>(&SpatialGrid::acquirePtr));
						case 11: return FunctionPtr(new FunctionImpl<SpatialGrid&(SpatialGrid::*)()>(&SpatialGrid::unacquirePtr));
						case 12: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)() const>(&SpatialGrid::isValidPtr));
						case 13: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)() const>(&SpatialGrid::isOwnerPtr));
						case 14: return FunctionPtr(new FunctionImpl<bool(SpatialGrid::*)() const>(&SpatialGrid::isConstPtr));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(SpatialGrid::*)() const>(&SpatialGrid::getCountPtr));
						case 16: return FunctionPtr(new FunctionImpl<const void*(SpatialGrid::*)() const>(&SpatialGrid::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2401, 2694, 1902, 1975, 1976, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 1171, 1585, 1585, 1585, 1231, 4073, 4073, 1232, 1232, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 3, 8, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13 };
			static constexpr uint16_t function_arg_types[] = { 1764, 1172, 4039, 274, 153, 4039, 4039, 4039, 274, 153, 153, 4039, 4039 };
			static constexpr uint16_t function_arg_names[] = { 1969, 3971, 2937, 1662, 1948, 3317, 3960, 1582, 1662, 1948, 1975, 3317, 3267 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 17, 0, 0, 0, 0, 19, 0, 0, 0, 0, 984 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionSpatialGrid::constructor_bases[];
	constexpr uint16_t ReflectionSpatialGrid::constructor_arg_types[];
	constexpr uint16_t ReflectionSpatialGrid::constructor_arg_names[];
	constexpr uint16_t ReflectionSpatialGrid::constructor_arg_values[];
	constexpr uint8_t ReflectionSpatialGrid::function_flags[];
	constexpr uint16_t ReflectionSpatialGrid::function_names[];
	constexpr uint16_t ReflectionSpatialGrid::function_types[];
	constexpr uint16_t ReflectionSpatialGrid::function_bases[];
	constexpr uint16_t ReflectionSpatialGrid::function_arg_types[];
	constexpr uint16_t ReflectionSpatialGrid::function_arg_names[];
	constexpr uint16_t ReflectionSpatialGrid::function_arg_values[];
	constexpr uint16_t ReflectionSpatialGrid::callback_names[];
	constexpr uint16_t ReflectionSpatialGrid::callback_types[];
	constexpr uint16_t ReflectionSpatialGrid::callback_bases[];
	constexpr uint16_t ReflectionSpatialGrid::callback_arg_types[];
	constexpr uint16_t ReflectionSpatialGrid::callback_arg_names[];
	constexpr uint16_t ReflectionSpatialGrid::enum_names[];
	constexpr uint16_t ReflectionSpatialGrid::enum_bases[];
	constexpr uint16_t ReflectionSpatialGrid::enum_var_names[];
	static ReflectionSpatialGrid reflection_spatial_grid;
	
	// Tellusim::SpatialTree
	class ReflectionSpatialTree : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return SpatialTree::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<SpatialTree, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<SpatialTree>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(SpatialTree::*)()>(&SpatialTree::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(SpatialTree::Flags) const>(&SpatialTree::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(SpatialTree::*)() const>(&SpatialTree::getGroupSize));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(SpatialTree::*)() const>(&SpatialTree::getBoundsNodes));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(SpatialTree::*)() const>(&SpatialTree::getMaxNodes));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(SpatialTree::*)() const>(&SpatialTree::getMaxRegions));
						case 6: return FunctionPtr(new FunctionImpl<RadixSort(SpatialTree::*)() const>(&SpatialTree::getRadixSort));
						case 7: return FunctionPtr(new FunctionImpl<Buffer(SpatialTree::*)() const>(&SpatialTree::getHashBuffer));
						case 8: return FunctionPtr(new FunctionImpl<Buffer(SpatialTree::*)() const>(&SpatialTree::getParentsBuffer));
						case 9: return FunctionPtr(new FunctionImpl<Buffer(SpatialTree::*)() const>(&SpatialTree::getCounterBuffer));
						case 10: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(const Device&, SpatialTree::Mode, RadixSort&, uint32_t, uint32_t, uint32_t, Async*)>(&SpatialTree::create, Device::null, (SpatialTree::Mode)0, RadixSort::null, {}, 256, 1, nullptr));
						case 11: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(const Device&, SpatialTree::Flags, RadixSort&, uint32_t, uint32_t, uint32_t, Async*)>(&SpatialTree::create, Device::null, (SpatialTree::Flags)0, RadixSort::null, {}, 256, 1, nullptr));
						case 12: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(Compute&, SpatialTree::Hash, Buffer&, uint32_t, uint32_t, SpatialTree::Flags)>(&SpatialTree::dispatch, Compute::null, (SpatialTree::Hash)0, Buffer::null, {}, {}, SpatialTree::FlagNone));
						case 13: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(Compute&, SpatialTree::Hash, Buffer&, uint32_t, const uint32_t*, const uint32_t*, SpatialTree::Flags)>(&SpatialTree::dispatch, Compute::null, (SpatialTree::Hash)0, Buffer::null, {}, {}, {}, SpatialTree::FlagNone));
						case 14: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(Compute&, SpatialTree::Hash, Buffer&, Buffer&, uint32_t, uint32_t, SpatialTree::Flags)>(&SpatialTree::dispatchIndirect, Compute::null, (SpatialTree::Hash)0, Buffer::null, Buffer::null, {}, Maxu32, SpatialTree::FlagNone));
						case 15: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)(Compute&, SpatialTree::Hash, Buffer&, uint32_t, Buffer&, uint32_t, uint32_t, SpatialTree::Flags)>(&SpatialTree::dispatchIndirect, Compute::null, (SpatialTree::Hash)0, Buffer::null, {}, Buffer::null, {}, Maxu32, SpatialTree::FlagNone));
						case 16: return FunctionPtr(new FunctionImpl<SpatialTree(SpatialTree::*)() const>(&SpatialTree::clonePtr));
						case 17: return FunctionPtr(new FunctionVoidImpl<void(SpatialTree::*)()>(&SpatialTree::clearPtr));
						case 18: return FunctionPtr(new FunctionVoidImpl<void(SpatialTree::*)()>(&SpatialTree::destroyPtr));
						case 19: return FunctionPtr(new FunctionImpl<SpatialTree&(SpatialTree::*)()>(&SpatialTree::acquirePtr));
						case 20: return FunctionPtr(new FunctionImpl<SpatialTree&(SpatialTree::*)()>(&SpatialTree::unacquirePtr));
						case 21: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)() const>(&SpatialTree::isValidPtr));
						case 22: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)() const>(&SpatialTree::isOwnerPtr));
						case 23: return FunctionPtr(new FunctionImpl<bool(SpatialTree::*)() const>(&SpatialTree::isConstPtr));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(SpatialTree::*)() const>(&SpatialTree::getCountPtr));
						case 25: return FunctionPtr(new FunctionImpl<const void*(SpatialTree::*)() const>(&SpatialTree::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 2401, 2141, 2491, 2494, 2694, 2409, 2655, 2239, 1902, 1902, 1975, 1975, 1976, 1976, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 4039, 4039, 4039, 4039, 1171, 152, 152, 152, 1585, 1585, 1585, 1585, 1585, 1585, 1233, 4073, 4073, 1234, 1234, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 15, 21, 28, 35, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43 };
			static constexpr uint16_t function_arg_types[] = { 1235, 1764, 1237, 1172, 4039, 4039, 4039, 62, 1764, 1235, 1172, 4039, 4039, 4039, 62, 274, 1236, 153, 4039, 4039, 1235, 274, 1236, 153, 4039, 1882, 1882, 1235, 274, 1236, 153, 153, 4039, 4039, 1235, 274, 1236, 153, 4039, 153, 4039, 4039, 1235 };
			static constexpr uint16_t function_arg_names[] = { 2045, 1969, 3275, 3971, 3960, 2937, 3404, 1559, 1969, 2045, 3971, 3960, 2937, 3404, 1559, 1662, 2979, 3291, 3317, 3960, 2045, 1662, 2979, 3291, 1900, 3318, 3966, 2045, 1662, 2979, 3291, 1975, 3317, 3267, 2045, 1662, 2979, 3291, 1900, 1975, 3317, 3267, 2045 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 17, 6, 3294, 0, 0, 0, 0, 17, 6, 3294, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 984, 678, 0, 0, 0, 0, 0, 0, 984, 678 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 812, 753 };
			static constexpr uint16_t enum_bases[] = { 0, 3, 10, 26 };
			static constexpr uint16_t enum_var_names[] = { 1061, 1048, 1106, 817, 819, 818, 816, 815, 814, 813, 678, 716, 666, 736, 683, 730, 709, 584, 650, 722, 718, 668, 717, 667, 754, 755 };
	};
	constexpr uint16_t ReflectionSpatialTree::constructor_bases[];
	constexpr uint16_t ReflectionSpatialTree::constructor_arg_types[];
	constexpr uint16_t ReflectionSpatialTree::constructor_arg_names[];
	constexpr uint16_t ReflectionSpatialTree::constructor_arg_values[];
	constexpr uint8_t ReflectionSpatialTree::function_flags[];
	constexpr uint16_t ReflectionSpatialTree::function_names[];
	constexpr uint16_t ReflectionSpatialTree::function_types[];
	constexpr uint16_t ReflectionSpatialTree::function_bases[];
	constexpr uint16_t ReflectionSpatialTree::function_arg_types[];
	constexpr uint16_t ReflectionSpatialTree::function_arg_names[];
	constexpr uint16_t ReflectionSpatialTree::function_arg_values[];
	constexpr uint16_t ReflectionSpatialTree::callback_names[];
	constexpr uint16_t ReflectionSpatialTree::callback_types[];
	constexpr uint16_t ReflectionSpatialTree::callback_bases[];
	constexpr uint16_t ReflectionSpatialTree::callback_arg_types[];
	constexpr uint16_t ReflectionSpatialTree::callback_arg_names[];
	constexpr uint16_t ReflectionSpatialTree::enum_names[];
	constexpr uint16_t ReflectionSpatialTree::enum_bases[];
	constexpr uint16_t ReflectionSpatialTree::enum_var_names[];
	static ReflectionSpatialTree reflection_spatial_tree;
	
	// Tellusim::FourierTransform
	class ReflectionFourierTransform : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return FourierTransform::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<FourierTransform, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<FourierTransform>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(FourierTransform::*)()>(&FourierTransform::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(FourierTransform::Mode) const>(&FourierTransform::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(FourierTransform::Flags) const>(&FourierTransform::isCreated));
						case 3: return FunctionPtr(new FunctionImpl<uint32_t(FourierTransform::*)() const>(&FourierTransform::getMaxWidth));
						case 4: return FunctionPtr(new FunctionImpl<uint32_t(FourierTransform::*)() const>(&FourierTransform::getMaxHeight));
						case 5: return FunctionPtr(new FunctionImpl<uint32_t(FourierTransform::*)(uint32_t) const>(&FourierTransform::getAlignedSize));
						case 6: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(const Device&, FourierTransform::Mode, uint32_t, uint32_t, Async*)>(&FourierTransform::create, Device::null, (FourierTransform::Mode)0, {}, {}, nullptr));
						case 7: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(const Device&, FourierTransform::Flags, uint32_t, uint32_t, Async*)>(&FourierTransform::create, Device::null, (FourierTransform::Flags)0, {}, {}, nullptr));
						case 8: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(Compute&, FourierTransform::Mode, FourierTransform::Operation, Texture&, Texture&, const Slice&, const Slice&) const>(&FourierTransform::dispatch));
						case 9: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(Compute&, FourierTransform::Mode, FourierTransform::Operation, Texture&, Texture&, const Slice&) const>(&FourierTransform::dispatch));
						case 10: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)(Compute&, FourierTransform::Mode, FourierTransform::Operation, Texture&, Texture&) const>(&FourierTransform::dispatch));
						case 11: return FunctionPtr(new FunctionImpl<FourierTransform(FourierTransform::*)() const>(&FourierTransform::clonePtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(FourierTransform::*)()>(&FourierTransform::clearPtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(FourierTransform::*)()>(&FourierTransform::destroyPtr));
						case 14: return FunctionPtr(new FunctionImpl<FourierTransform&(FourierTransform::*)()>(&FourierTransform::acquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<FourierTransform&(FourierTransform::*)()>(&FourierTransform::unacquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)() const>(&FourierTransform::isValidPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)() const>(&FourierTransform::isOwnerPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(FourierTransform::*)() const>(&FourierTransform::isConstPtr));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(FourierTransform::*)() const>(&FourierTransform::getCountPtr));
						case 20: return FunctionPtr(new FunctionImpl<const void*(FourierTransform::*)() const>(&FourierTransform::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 3057, 2499, 2489, 2087, 1902, 1902, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 4039, 4039, 4039, 1585, 1585, 1585, 1585, 1585, 770, 4073, 4073, 771, 771, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 2, 2, 3, 8, 13, 20, 26, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31 };
			static constexpr uint16_t function_arg_types[] = { 773, 772, 4039, 1764, 773, 4039, 4039, 62, 1764, 772, 4039, 4039, 62, 274, 773, 774, 1294, 1294, 1839, 1839, 274, 773, 774, 1294, 1294, 1839, 274, 773, 774, 1294, 1294 };
			static constexpr uint16_t function_arg_names[] = { 3275, 2045, 3960, 1969, 3275, 4089, 2980, 1559, 1969, 2045, 4089, 2980, 1559, 1662, 3275, 3326, 1963, 3975, 1967, 3982, 1662, 3275, 3326, 1963, 3975, 3982, 1662, 3275, 3326, 1963, 3975 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 0, 0, 3294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1033, 753, 1126 };
			static constexpr uint16_t enum_bases[] = { 0, 9, 23, 28 };
			static constexpr uint16_t enum_var_names[] = { 1059, 1060, 1057, 1058, 1053, 1055, 1054, 1056, 1106, 678, 705, 706, 696, 697, 692, 694, 693, 695, 680, 759, 758, 760, 754, 768, 98, 769, 99, 1108 };
	};
	constexpr uint16_t ReflectionFourierTransform::constructor_bases[];
	constexpr uint16_t ReflectionFourierTransform::constructor_arg_types[];
	constexpr uint16_t ReflectionFourierTransform::constructor_arg_names[];
	constexpr uint16_t ReflectionFourierTransform::constructor_arg_values[];
	constexpr uint8_t ReflectionFourierTransform::function_flags[];
	constexpr uint16_t ReflectionFourierTransform::function_names[];
	constexpr uint16_t ReflectionFourierTransform::function_types[];
	constexpr uint16_t ReflectionFourierTransform::function_bases[];
	constexpr uint16_t ReflectionFourierTransform::function_arg_types[];
	constexpr uint16_t ReflectionFourierTransform::function_arg_names[];
	constexpr uint16_t ReflectionFourierTransform::function_arg_values[];
	constexpr uint16_t ReflectionFourierTransform::callback_names[];
	constexpr uint16_t ReflectionFourierTransform::callback_types[];
	constexpr uint16_t ReflectionFourierTransform::callback_bases[];
	constexpr uint16_t ReflectionFourierTransform::callback_arg_types[];
	constexpr uint16_t ReflectionFourierTransform::callback_arg_names[];
	constexpr uint16_t ReflectionFourierTransform::enum_names[];
	constexpr uint16_t ReflectionFourierTransform::enum_bases[];
	constexpr uint16_t ReflectionFourierTransform::enum_var_names[];
	static ReflectionFourierTransform reflection_fourier_transform;
	
	// Tellusim::TensorGraph
	class ReflectionTensorGraph : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return TensorGraph::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<TensorGraph, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<TensorGraph>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionVoidImpl<void(TensorGraph::*)()>(&TensorGraph::clear));
						case 1: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)() const>(&TensorGraph::isCreated));
						case 2: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(const Device&, TensorGraph::Flags, TensorGraph::Masks, Async*)>(&TensorGraph::create, Device::null, TensorGraph::FlagsAll, TensorGraph::MasksAll, nullptr));
						case 3: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, TensorGraph::Operation, const Tensor&, TensorGraph::Flags) const>(&TensorGraph::dispatch, Compute::null, (TensorGraph::Operation)0, {}, TensorGraph::FlagNone));
						case 4: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, TensorGraph::Operation, Tensor&, const Tensor&, TensorGraph::Flags) const>(&TensorGraph::dispatch, Compute::null, (TensorGraph::Operation)0, {}, {}, TensorGraph::FlagNone));
						case 5: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, TensorGraph::Operation, Tensor&, const Tensor&, const Tensor&, TensorGraph::Flags) const>(&TensorGraph::dispatch, Compute::null, (TensorGraph::Operation)0, {}, {}, {}, TensorGraph::FlagNone));
						case 6: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, TensorGraph::Operation, Tensor&, const Tensor&, const Tensor&, const Tensor&, TensorGraph::Flags) const>(&TensorGraph::dispatch, Compute::null, (TensorGraph::Operation)0, {}, {}, {}, {}, TensorGraph::FlagNone));
						case 7: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, const Tensor&, Texture&, const Region&, const Slice&) const>(&TensorGraph::dispatch, Compute::null, {}, Texture::null, {}, Slice()));
						case 8: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, const Tensor&, Texture&, const Slice&) const>(&TensorGraph::dispatch, Compute::null, {}, Texture::null, Slice()));
						case 9: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, Texture&, const Tensor&, const Region&, const Slice&) const>(&TensorGraph::dispatch, Compute::null, Texture::null, {}, {}, Slice()));
						case 10: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)(Compute&, Texture&, const Tensor&, const Slice&) const>(&TensorGraph::dispatch, Compute::null, Texture::null, {}, Slice()));
						case 11: return FunctionPtr(new FunctionImpl<TensorGraph(TensorGraph::*)() const>(&TensorGraph::clonePtr));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(TensorGraph::*)()>(&TensorGraph::clearPtr));
						case 13: return FunctionPtr(new FunctionVoidImpl<void(TensorGraph::*)()>(&TensorGraph::destroyPtr));
						case 14: return FunctionPtr(new FunctionImpl<TensorGraph&(TensorGraph::*)()>(&TensorGraph::acquirePtr));
						case 15: return FunctionPtr(new FunctionImpl<TensorGraph&(TensorGraph::*)()>(&TensorGraph::unacquirePtr));
						case 16: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)() const>(&TensorGraph::isValidPtr));
						case 17: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)() const>(&TensorGraph::isOwnerPtr));
						case 18: return FunctionPtr(new FunctionImpl<bool(TensorGraph::*)() const>(&TensorGraph::isConstPtr));
						case 19: return FunctionPtr(new FunctionImpl<uint32_t(TensorGraph::*)() const>(&TensorGraph::getCountPtr));
						case 20: return FunctionPtr(new FunctionImpl<const void*(TensorGraph::*)() const>(&TensorGraph::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 1612, 3057, 1902, 1975, 1975, 1975, 1975, 1975, 1975, 1975, 1975, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4073, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1288, 4073, 4073, 1289, 1289, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 4, 8, 13, 19, 26, 31, 35, 40, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44 };
			static constexpr uint16_t function_arg_types[] = { 1764, 1290, 1291, 62, 274, 1292, 1846, 1290, 274, 1292, 1287, 1846, 1290, 274, 1292, 1287, 1846, 1846, 1290, 274, 1292, 1287, 1846, 1846, 1846, 1290, 274, 1846, 1294, 1831, 1839, 274, 1846, 1294, 1839, 274, 1294, 1846, 1831, 1839, 274, 1294, 1846, 1839 };
			static constexpr uint16_t function_arg_names[] = { 1969, 2045, 3261, 1559, 1662, 3326, 1963, 2045, 1662, 3326, 1963, 3976, 2045, 1662, 3326, 1963, 3976, 3977, 2045, 1662, 3326, 1963, 3976, 3977, 3978, 2045, 1662, 1963, 3975, 3403, 3967, 1662, 1963, 3975, 3967, 1662, 1963, 3975, 3403, 3967, 1662, 1963, 3975, 3967 };
			static constexpr uint16_t function_arg_values[] = { 0, 754, 974, 3294, 0, 0, 0, 678, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 1219, 0, 0, 0, 1219, 0, 0, 0, 0, 1219, 0, 0, 0, 1219 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 1126, 753, 973 };
			static constexpr uint16_t enum_bases[] = { 0, 27, 52, 80 };
			static constexpr uint16_t enum_var_names[] = { 248, 1175, 365, 246, 1308, 975, 1086, 925, 497, 23, 364, 431, 110, 109, 1226, 1225, 982, 82, 778, 1176, 1212, 1213, 1282, 1214, 367, 524, 1108, 678, 719, 631, 630, 733, 743, 744, 701, 700, 615, 648, 636, 698, 712, 713, 725, 715, 616, 622, 628, 742, 699, 735, 654, 754, 957, 935, 958, 940, 934, 970, 953, 956, 952, 943, 928, 939, 942, 932, 931, 966, 965, 954, 930, 948, 961, 962, 963, 967, 964, 941, 945, 974 };
	};
	constexpr uint16_t ReflectionTensorGraph::constructor_bases[];
	constexpr uint16_t ReflectionTensorGraph::constructor_arg_types[];
	constexpr uint16_t ReflectionTensorGraph::constructor_arg_names[];
	constexpr uint16_t ReflectionTensorGraph::constructor_arg_values[];
	constexpr uint8_t ReflectionTensorGraph::function_flags[];
	constexpr uint16_t ReflectionTensorGraph::function_names[];
	constexpr uint16_t ReflectionTensorGraph::function_types[];
	constexpr uint16_t ReflectionTensorGraph::function_bases[];
	constexpr uint16_t ReflectionTensorGraph::function_arg_types[];
	constexpr uint16_t ReflectionTensorGraph::function_arg_names[];
	constexpr uint16_t ReflectionTensorGraph::function_arg_values[];
	constexpr uint16_t ReflectionTensorGraph::callback_names[];
	constexpr uint16_t ReflectionTensorGraph::callback_types[];
	constexpr uint16_t ReflectionTensorGraph::callback_bases[];
	constexpr uint16_t ReflectionTensorGraph::callback_arg_types[];
	constexpr uint16_t ReflectionTensorGraph::callback_arg_names[];
	constexpr uint16_t ReflectionTensorGraph::enum_names[];
	constexpr uint16_t ReflectionTensorGraph::enum_bases[];
	constexpr uint16_t ReflectionTensorGraph::enum_var_names[];
	static ReflectionTensorGraph reflection_tensor_graph;
	
	// Tellusim::Controller
	class ReflectionController : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Controller::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Controller, TypeList<>>());
						case 1: return ConstructorPtr(new ConstructorImpl<Controller, TypeList<uint32_t>>());
						case 2: return ConstructorPtr(new ConstructorImpl<Controller, TypeList<Controller::Type, uint32_t>>((Controller::Type)0, Maxu32));
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Controller>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<uint32_t()>(&Controller::getNumControllers));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(const char*)>(&Controller::findController));
						case 2: return FunctionPtr(new FunctionImpl<Controller(uint32_t)>(&Controller::getController));
						case 3: return FunctionPtr(new FunctionVoidImpl<void()>(&Controller::update));
						case 4: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Type)>(&Controller::setType));
						case 5: return FunctionPtr(new FunctionImpl<Controller::Type(Controller::*)() const>(&Controller::getType));
						case 6: return FunctionPtr(new FunctionImpl<const char*(Controller::Type)>(&Controller::getTypeName));
						case 7: return FunctionPtr(new FunctionImpl<const char*(Controller::*)() const>(&Controller::getTypeName));
						case 8: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isUnknown));
						case 9: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isJoystick));
						case 10: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isGamePad));
						case 11: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isWheel));
						case 12: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(uint32_t)>(&Controller::setIndex));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(Controller::*)() const>(&Controller::getIndex));
						case 14: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(const char*)>(&Controller::setName));
						case 15: return FunctionPtr(new FunctionImpl<String(Controller::*)() const>(&Controller::getName));
						case 16: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(const char*)>(&Controller::setModel));
						case 17: return FunctionPtr(new FunctionImpl<String(Controller::*)() const>(&Controller::getModel));
						case 18: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isConnected));
						case 19: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::wasConnected));
						case 20: return FunctionPtr(new FunctionImpl<bool(Controller::*)(const char*)>(&Controller::connect, nullptr));
						case 21: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)()>(&Controller::release));
						case 22: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Stick, const char*)>(&Controller::setStickName));
						case 23: return FunctionPtr(new FunctionImpl<String(Controller::*)(Controller::Stick) const>(&Controller::getStickName));
						case 24: return FunctionPtr(new FunctionImpl<Controller::Stick(Controller::*)(const char*) const>(&Controller::findStick));
						case 25: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Stick, float32_t, float32_t)>(&Controller::setStick));
						case 26: return FunctionPtr(new FunctionImpl<float32_t(Controller::*)(Controller::Stick) const>(&Controller::getStickX));
						case 27: return FunctionPtr(new FunctionImpl<float32_t(Controller::*)(Controller::Stick) const>(&Controller::getStickY));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Axis, const char*)>(&Controller::setAxisName));
						case 29: return FunctionPtr(new FunctionImpl<String(Controller::*)(Controller::Axis) const>(&Controller::getAxisName));
						case 30: return FunctionPtr(new FunctionImpl<Controller::Axis(Controller::*)(const char*) const>(&Controller::findAxis));
						case 31: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Axis, float32_t)>(&Controller::setAxis));
						case 32: return FunctionPtr(new FunctionImpl<float32_t(Controller::*)(Controller::Axis) const>(&Controller::getAxis));
						case 33: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Button, const char*)>(&Controller::setButtonName));
						case 34: return FunctionPtr(new FunctionImpl<String(Controller::*)(Controller::Button) const>(&Controller::getButtonName));
						case 35: return FunctionPtr(new FunctionImpl<Controller::Button(Controller::*)(const char*) const>(&Controller::findButton));
						case 36: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Button, bool)>(&Controller::setButton));
						case 37: return FunctionPtr(new FunctionImpl<bool(Controller::*)(Controller::Button, bool) const>(&Controller::getButton, (Controller::Button)0, false));
						case 38: return FunctionPtr(new FunctionImpl<bool(Controller::*)(Controller::Button) const>(&Controller::wasButtonPressed));
						case 39: return FunctionPtr(new FunctionImpl<bool(Controller::*)(Controller::Button) const>(&Controller::wasButtonReleased));
						case 40: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Button, float32_t)>(&Controller::setButtonValue));
						case 41: return FunctionPtr(new FunctionImpl<float32_t(Controller::*)(Controller::Button) const>(&Controller::getButtonValue));
						case 42: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Motor, const char*)>(&Controller::setMotorName));
						case 43: return FunctionPtr(new FunctionImpl<String(Controller::*)(Controller::Motor) const>(&Controller::getMotorName));
						case 44: return FunctionPtr(new FunctionImpl<Controller::Motor(Controller::*)(const char*) const>(&Controller::findMotor));
						case 45: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(Controller::Motor, float32_t)>(&Controller::setMotor));
						case 46: return FunctionPtr(new FunctionImpl<float32_t(Controller::*)(Controller::Motor) const>(&Controller::getMotor));
						case 47: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(const Controller::ButtonPressedCallback&)>(&Controller::setButtonPressedCallback));
						case 48: return FunctionPtr(new FunctionImpl<Controller::ButtonPressedCallback(Controller::*)() const>(&Controller::getButtonPressedCallback));
						case 49: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(const Controller::ButtonReleasedCallback&)>(&Controller::setButtonReleasedCallback));
						case 50: return FunctionPtr(new FunctionImpl<Controller::ButtonReleasedCallback(Controller::*)() const>(&Controller::getButtonReleasedCallback));
						case 51: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(const Controller::ConnectedCallback&)>(&Controller::setConnectedCallback));
						case 52: return FunctionPtr(new FunctionImpl<Controller::ConnectedCallback(Controller::*)() const>(&Controller::getConnectedCallback));
						case 53: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)(const Controller::DisconnectedCallback&)>(&Controller::setDisconnectedCallback));
						case 54: return FunctionPtr(new FunctionImpl<Controller::DisconnectedCallback(Controller::*)() const>(&Controller::getDisconnectedCallback));
						case 55: return FunctionPtr(new FunctionImpl<Controller(Controller::*)() const>(&Controller::clonePtr));
						case 56: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)()>(&Controller::clearPtr));
						case 57: return FunctionPtr(new FunctionVoidImpl<void(Controller::*)()>(&Controller::destroyPtr));
						case 58: return FunctionPtr(new FunctionImpl<Controller&(Controller::*)()>(&Controller::acquirePtr));
						case 59: return FunctionPtr(new FunctionImpl<Controller&(Controller::*)()>(&Controller::unacquirePtr));
						case 60: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isValidPtr));
						case 61: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isOwnerPtr));
						case 62: return FunctionPtr(new FunctionImpl<bool(Controller::*)() const>(&Controller::isConstPtr));
						case 63: return FunctionPtr(new FunctionImpl<uint32_t(Controller::*)() const>(&Controller::getCountPtr));
						case 64: return FunctionPtr(new FunctionImpl<const void*(Controller::*)() const>(&Controller::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0, 1, 3 };
			static constexpr uint16_t constructor_arg_types[] = { 4039, 363, 4039 };
			static constexpr uint16_t constructor_arg_names[] = { 2993, 4036, 2993 };
			static constexpr uint16_t constructor_arg_values[] = { 0, 0, 984 };
			static constexpr uint8_t function_flags[] = { 1, 1, 1, 1, 0, 2, 1, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 2572, 2029, 2234, 4051, 3915, 2878, 2879, 2879, 3198, 3113, 3086, 3209, 3665, 2421, 3751, 2556, 3724, 2529, 3052, 4082, 1664, 3406, 3846, 2786, 2042, 3845, 2787, 2788, 3518, 2113, 2026, 3517, 2112, 3541, 2162, 2027, 3538, 2159, 4080, 4081, 3545, 2166, 3730, 2536, 2039, 3729, 2535, 3542, 2163, 3544, 2165, 3576, 2229, 3612, 2308, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 4039, 4039, 353, 4073, 4073, 363, 1877, 1877, 1585, 1585, 1585, 1585, 4073, 4039, 4073, 1274, 4073, 1274, 1585, 1585, 1585, 4073, 4073, 1274, 362, 4073, 2051, 2051, 4073, 1274, 355, 4073, 2051, 4073, 1274, 356, 4073, 1585, 1585, 1585, 4073, 2051, 4073, 1274, 361, 4073, 2051, 4073, 357, 4073, 358, 4073, 359, 4073, 360, 353, 4073, 4073, 354, 354, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 10, 11, 12, 15, 16, 17, 19, 20, 21, 23, 24, 26, 27, 28, 30, 32, 33, 34, 36, 37, 39, 40, 41, 43, 44, 45, 45, 46, 46, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48 };
			static constexpr uint16_t function_arg_types[] = { 1877, 4039, 363, 363, 4039, 1877, 1877, 1877, 362, 1877, 362, 1877, 362, 2051, 2051, 362, 362, 355, 1877, 355, 1877, 355, 2051, 355, 356, 1877, 356, 1877, 356, 1585, 356, 1585, 356, 356, 356, 2051, 356, 361, 1877, 361, 1877, 361, 2051, 361, 1759, 1760, 1761, 1762 };
			static constexpr uint16_t function_arg_names[] = { 3288, 2993, 4036, 4036, 2993, 3288, 3279, 3288, 3987, 3288, 3987, 3288, 3987, 4115, 4116, 3987, 3987, 1566, 3288, 1566, 3288, 1566, 4056, 1566, 1598, 3288, 1598, 3288, 1598, 4056, 1598, 1612, 1598, 1598, 1598, 4056, 1598, 3283, 3288, 3283, 3288, 3283, 4056, 3283, 2074, 2074, 2074, 2074 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 3294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 180, 184, 275, 496 };
			static constexpr uint16_t callback_types[] = { 4073, 4073, 4073, 4073 };
			static constexpr uint16_t callback_bases[] = { 0, 2, 4, 5, 6 };
			static constexpr uint16_t callback_arg_types[] = { 353, 356, 353, 356, 353, 353 };
			static constexpr uint16_t callback_arg_names[] = { 1889, 1598, 1889, 1598, 1889, 1889 };
			static constexpr uint16_t enum_names[] = { 1311, 1269, 83, 159, 1079 };
			static constexpr uint16_t enum_bases[] = { 0, 5, 8, 15, 45, 48 };
			static constexpr uint16_t enum_var_names[] = { 1389, 1351, 1341, 1392, 1117, 1270, 1271, 1115, 95, 96, 97, 90, 91, 92, 1090, 173, 185, 166, 196, 169, 188, 189, 194, 195, 191, 192, 160, 161, 198, 199, 197, 175, 170, 181, 171, 182, 172, 183, 165, 164, 190, 193, 187, 179, 1094, 1081, 1080, 1107 };
	};
	constexpr uint16_t ReflectionController::constructor_bases[];
	constexpr uint16_t ReflectionController::constructor_arg_types[];
	constexpr uint16_t ReflectionController::constructor_arg_names[];
	constexpr uint16_t ReflectionController::constructor_arg_values[];
	constexpr uint8_t ReflectionController::function_flags[];
	constexpr uint16_t ReflectionController::function_names[];
	constexpr uint16_t ReflectionController::function_types[];
	constexpr uint16_t ReflectionController::function_bases[];
	constexpr uint16_t ReflectionController::function_arg_types[];
	constexpr uint16_t ReflectionController::function_arg_names[];
	constexpr uint16_t ReflectionController::function_arg_values[];
	constexpr uint16_t ReflectionController::callback_names[];
	constexpr uint16_t ReflectionController::callback_types[];
	constexpr uint16_t ReflectionController::callback_bases[];
	constexpr uint16_t ReflectionController::callback_arg_types[];
	constexpr uint16_t ReflectionController::callback_arg_names[];
	constexpr uint16_t ReflectionController::enum_names[];
	constexpr uint16_t ReflectionController::enum_bases[];
	constexpr uint16_t ReflectionController::enum_var_names[];
	static ReflectionController reflection_controller;
	
	// Tellusim::Desktop
	class ReflectionDesktop : public ReflectionImpl {
		public:
			virtual const char *getName() const {
				return Desktop::getClassNamePtr();
			}
			virtual const Reflection *getBase() const {
				return nullptr;
			}
			virtual uint32_t getNumConstructors() const {
				return TS_COUNTOF(constructor_bases) - 1;
			}
			virtual uint32_t getNumConstructorArgs(uint32_t index) const {
				return constructor_bases[index + 1] - constructor_bases[index];
			}
			virtual const char *getConstructorArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_types[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_names[constructor_bases[index] + arg]];
			}
			virtual const char *getConstructorArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[constructor_arg_values[constructor_bases[index] + arg]];
			}
			virtual ConstructorPtr getConstructor(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return ConstructorPtr(new ConstructorImpl<Desktop, TypeList<>>());
					}
				#endif
				return ReflectionImpl::getConstructor(index);
			}
			virtual DestructorPtr getDestructor() const {
				return DestructorPtr(new DestructorImpl<Desktop>());
			}
			virtual uint32_t getNumFunctions() const {
				return TS_COUNTOF(function_bases) - 1;
			}
			virtual bool isStaticFunction(uint32_t index) const {
				return (function_flags[index] & 1) != 0;
			}
			virtual bool isConstFunction(uint32_t index) const {
				return (function_flags[index] & 2) != 0;
			}
			virtual bool isVirtualFunction(uint32_t index) const {
				return (function_flags[index] & 4) != 0;
			}
			virtual bool isAbstractFunction(uint32_t index) const {
				return (function_flags[index] & 8) != 0;
			}
			virtual const char *getFunctionName(uint32_t index) const {
				return reflection_names[function_names[index]];
			}
			virtual const char *getFunctionType(uint32_t index) const {
				return reflection_names[function_types[index]];
			}
			virtual uint32_t getNumFunctionArgs(uint32_t index) const {
				return function_bases[index + 1] - function_bases[index];
			}
			virtual const char *getFunctionArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_types[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_names[function_bases[index] + arg]];
			}
			virtual const char *getFunctionArgValue(uint32_t index, uint32_t arg) const {
				return reflection_names[function_arg_values[function_bases[index] + arg]];
			}
			virtual FunctionPtr getFunction(uint32_t index) const {
				#ifdef TS_REFLECTION_FUNC
					switch(index) {
						case 0: return FunctionPtr(new FunctionImpl<bool(Desktop::*)()>(&Desktop::update));
						case 1: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)() const>(&Desktop::getWidth));
						case 2: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)() const>(&Desktop::getHeight));
						case 3: return FunctionPtr(new FunctionImpl<int32_t(Desktop::*)() const>(&Desktop::getPositionX));
						case 4: return FunctionPtr(new FunctionImpl<int32_t(Desktop::*)() const>(&Desktop::getPositionY));
						case 5: return FunctionPtr(new FunctionImpl<float32_t(Desktop::*)() const>(&Desktop::getScale));
						case 6: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)() const>(&Desktop::getNumScreens));
						case 7: return FunctionPtr(new FunctionImpl<String(Desktop::*)(uint32_t) const>(&Desktop::getScreenName));
						case 8: return FunctionPtr(new FunctionImpl<String(Desktop::*)(uint32_t) const>(&Desktop::getScreenDevice));
						case 9: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t) const>(&Desktop::getScreenWidth));
						case 10: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t) const>(&Desktop::getScreenHeight));
						case 11: return FunctionPtr(new FunctionImpl<int32_t(Desktop::*)(uint32_t) const>(&Desktop::getScreenPositionX));
						case 12: return FunctionPtr(new FunctionImpl<int32_t(Desktop::*)(uint32_t) const>(&Desktop::getScreenPositionY));
						case 13: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t) const>(&Desktop::getScreenFrequency));
						case 14: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t) const>(&Desktop::getNumModes));
						case 15: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t, uint32_t) const>(&Desktop::getModeWidth));
						case 16: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t, uint32_t) const>(&Desktop::getModeHeight));
						case 17: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t, uint32_t, uint32_t) const>(&Desktop::getModeIndex));
						case 18: return FunctionPtr(new FunctionImpl<bool(Desktop::*)(uint32_t, uint32_t, uint32_t)>(&Desktop::setMode));
						case 19: return FunctionPtr(new FunctionImpl<bool(Desktop::*)(uint32_t)>(&Desktop::restoreMode));
						case 20: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t) const>(&Desktop::getWidth));
						case 21: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(uint32_t) const>(&Desktop::getHeight));
						case 22: return FunctionPtr(new FunctionImpl<int32_t(Desktop::*)(uint32_t) const>(&Desktop::getPositionX));
						case 23: return FunctionPtr(new FunctionImpl<int32_t(Desktop::*)(uint32_t) const>(&Desktop::getPositionY));
						case 24: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)(int32_t, int32_t) const>(&Desktop::getScreenIndex));
						case 25: return FunctionPtr(new FunctionImpl<bool(Desktop::*)(int32_t, int32_t) const>(&Desktop::setMouse));
						case 26: return FunctionPtr(new FunctionImpl<bool(Desktop::*)(int32_t&, int32_t&) const>(&Desktop::getMouse));
						case 27: return FunctionPtr(new FunctionImpl<Desktop(Desktop::*)() const>(&Desktop::clonePtr));
						case 28: return FunctionPtr(new FunctionVoidImpl<void(Desktop::*)()>(&Desktop::clearPtr));
						case 29: return FunctionPtr(new FunctionVoidImpl<void(Desktop::*)()>(&Desktop::destroyPtr));
						case 30: return FunctionPtr(new FunctionImpl<Desktop&(Desktop::*)()>(&Desktop::acquirePtr));
						case 31: return FunctionPtr(new FunctionImpl<Desktop&(Desktop::*)()>(&Desktop::unacquirePtr));
						case 32: return FunctionPtr(new FunctionImpl<bool(Desktop::*)() const>(&Desktop::isValidPtr));
						case 33: return FunctionPtr(new FunctionImpl<bool(Desktop::*)() const>(&Desktop::isOwnerPtr));
						case 34: return FunctionPtr(new FunctionImpl<bool(Desktop::*)() const>(&Desktop::isConstPtr));
						case 35: return FunctionPtr(new FunctionImpl<uint32_t(Desktop::*)() const>(&Desktop::getCountPtr));
						case 36: return FunctionPtr(new FunctionImpl<const void*(Desktop::*)() const>(&Desktop::getInternalPtr));
					}
				#endif
				return ReflectionImpl::getFunction(index);
			}
			virtual uint32_t getNumCallbacks() const {
				return TS_COUNTOF(callback_bases) - 1;
			}
			virtual const char *getCallbackName(uint32_t index) const {
				return reflection_names[callback_names[index]];
			}
			virtual const char *getCallbackType(uint32_t index) const {
				return reflection_names[callback_types[index]];
			}
			virtual uint32_t getNumCallbackArgs(uint32_t index) const {
				return callback_bases[index + 1] - callback_bases[index];
			}
			virtual const char *getCallbackArgType(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_types[callback_bases[index] + arg]];
			}
			virtual const char *getCallbackArgName(uint32_t index, uint32_t arg) const {
				return reflection_names[callback_arg_names[callback_bases[index] + arg]];
			}
			virtual uint32_t getNumEnums() const {
				return TS_COUNTOF(enum_bases) - 1;
			}
			virtual const char *getEnumName(uint32_t index) const {
				return reflection_names[enum_names[index]];
			}
			virtual uint32_t getNumEnumVars(uint32_t index) const {
				return enum_bases[index + 1] - enum_bases[index];
			}
			virtual const char *getEnumVarName(uint32_t index, uint32_t var) const {
				return reflection_names[enum_var_names[enum_bases[index] + var]];
			}
		private:
			static constexpr uint16_t constructor_bases[] = { 0, 0 };
			static constexpr uint16_t constructor_arg_types[] = { 0 };
			static constexpr uint16_t constructor_arg_names[] = { 0 };
			static constexpr uint16_t constructor_arg_values[] = { 0 };
			static constexpr uint8_t function_flags[] = { 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2 };
			static constexpr uint16_t function_names[] = { 4051, 2927, 2410, 2675, 2676, 2730, 2607, 2740, 2736, 2743, 2738, 2741, 2742, 2737, 2599, 2528, 2526, 2527, 3723, 3468, 2927, 2410, 2675, 2676, 2739, 3731, 2537, 1647, 1637, 1968, 1505, 4047, 3201, 3142, 3053, 2238, 2440 };
			static constexpr uint16_t function_types[] = { 1585, 4039, 4039, 3003, 3003, 2051, 4039, 1274, 1274, 4039, 4039, 3003, 3003, 4039, 4039, 4039, 4039, 4039, 1585, 1585, 4039, 4039, 3003, 3003, 4039, 1585, 1585, 452, 4073, 4073, 453, 453, 1585, 1585, 1585, 4039, 1885 };
			static constexpr uint16_t function_bases[] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 18, 19, 20, 21, 22, 23, 25, 27, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 };
			static constexpr uint16_t function_arg_types[] = { 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 4039, 3003, 3003, 3003, 3003, 3004, 3004 };
			static constexpr uint16_t function_arg_names[] = { 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 2993, 3275, 2993, 3275, 2993, 4089, 2980, 2993, 4089, 2980, 2993, 2993, 2993, 2993, 2993, 4115, 4116, 4115, 4116, 4115, 4116 };
			static constexpr uint16_t function_arg_values[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			static constexpr uint16_t callback_names[] = { 0 };
			static constexpr uint16_t callback_types[] = { 0 };
			static constexpr uint16_t callback_bases[] = { 0 };
			static constexpr uint16_t callback_arg_types[] = { 0 };
			static constexpr uint16_t callback_arg_names[] = { 0 };
			static constexpr uint16_t enum_names[] = { 0 };
			static constexpr uint16_t enum_bases[] = { 0 };
			static constexpr uint16_t enum_var_names[] = { 0 };
	};
	constexpr uint16_t ReflectionDesktop::constructor_bases[];
	constexpr uint16_t ReflectionDesktop::constructor_arg_types[];
	constexpr uint16_t ReflectionDesktop::constructor_arg_names[];
	constexpr uint16_t ReflectionDesktop::constructor_arg_values[];
	constexpr uint8_t ReflectionDesktop::function_flags[];
	constexpr uint16_t ReflectionDesktop::function_names[];
	constexpr uint16_t ReflectionDesktop::function_types[];
	constexpr uint16_t ReflectionDesktop::function_bases[];
	constexpr uint16_t ReflectionDesktop::function_arg_types[];
	constexpr uint16_t ReflectionDesktop::function_arg_names[];
	constexpr uint16_t ReflectionDesktop::function_arg_values[];
	constexpr uint16_t ReflectionDesktop::callback_names[];
	constexpr uint16_t ReflectionDesktop::callback_types[];
	constexpr uint16_t ReflectionDesktop::callback_bases[];
	constexpr uint16_t ReflectionDesktop::callback_arg_types[];
	constexpr uint16_t ReflectionDesktop::callback_arg_names[];
	constexpr uint16_t ReflectionDesktop::enum_names[];
	constexpr uint16_t ReflectionDesktop::enum_bases[];
	constexpr uint16_t ReflectionDesktop::enum_var_names[];
	static ReflectionDesktop reflection_desktop;
	
	// Tellusim::Reflection
	static SpinLock reflection_lock;
	static Map<const char*, Reflection*> reflection_instances;
	static void create_reflection_instances() {
		if(!reflection_instances) reflection_instances = {
			{ App::getClassNamePtr(), &reflection_app },
			{ Async::getClassNamePtr(), &reflection_async },
			{ Stream::getClassNamePtr(), &reflection_stream },
			{ Blob::getClassNamePtr(), &reflection_blob },
			{ File::getClassNamePtr(), &reflection_file },
			{ Socket::getClassNamePtr(), &reflection_socket },
			{ SocketSSL::getClassNamePtr(), &reflection_socket_ssl },
			{ Source::getClassNamePtr(), &reflection_source },
			{ Date::getClassNamePtr(), &reflection_date },
			{ Info::getClassNamePtr(), &reflection_info },
			{ Directory::getClassNamePtr(), &reflection_directory },
			{ Archive::getClassNamePtr(), &reflection_archive },
			{ Image::getClassNamePtr(), &reflection_image },
			{ ImageSampler::getClassNamePtr(), &reflection_image_sampler },
			{ MeshNode::getClassNamePtr(), &reflection_mesh_node },
			{ MeshIndices::getClassNamePtr(), &reflection_mesh_indices },
			{ MeshAttribute::getClassNamePtr(), &reflection_mesh_attribute },
			{ MeshJoint::getClassNamePtr(), &reflection_mesh_joint },
			{ MeshMaterial::getClassNamePtr(), &reflection_mesh_material },
			{ MeshGeometry::getClassNamePtr(), &reflection_mesh_geometry },
			{ MeshTransform::getClassNamePtr(), &reflection_mesh_transform },
			{ MeshAnimation::getClassNamePtr(), &reflection_mesh_animation },
			{ MeshAttachment::getClassNamePtr(), &reflection_mesh_attachment },
			{ Mesh::getClassNamePtr(), &reflection_mesh },
			{ Json::getClassNamePtr(), &reflection_json },
			{ Xml::getClassNamePtr(), &reflection_xml },
			{ Buffer::getClassNamePtr(), &reflection_buffer },
			{ BufferTable::getClassNamePtr(), &reflection_buffer_table },
			{ D3D12Buffer::getClassNamePtr(), &reflection_d3d12_buffer },
			{ D3D11Buffer::getClassNamePtr(), &reflection_d3d11_buffer },
			{ MTLBuffer::getClassNamePtr(), &reflection_mtl_buffer },
			{ VKBuffer::getClassNamePtr(), &reflection_vk_buffer },
			{ GLBuffer::getClassNamePtr(), &reflection_gl_buffer },
			{ GLESBuffer::getClassNamePtr(), &reflection_gles_buffer },
			{ CUBuffer::getClassNamePtr(), &reflection_cu_buffer },
			{ HIPBuffer::getClassNamePtr(), &reflection_hip_buffer },
			{ FUBuffer::getClassNamePtr(), &reflection_fu_buffer },
			{ Command::getClassNamePtr(), &reflection_command },
			{ D3D12Command::getClassNamePtr(), &reflection_d3d12_command },
			{ MTLCommand::getClassNamePtr(), &reflection_mtl_command },
			{ VKCommand::getClassNamePtr(), &reflection_vk_command },
			{ FUCommand::getClassNamePtr(), &reflection_fu_command },
			{ Compute::getClassNamePtr(), &reflection_compute },
			{ D3D12Compute::getClassNamePtr(), &reflection_d3d12_compute },
			{ MTLCompute::getClassNamePtr(), &reflection_mtl_compute },
			{ VKCompute::getClassNamePtr(), &reflection_vk_compute },
			{ FUCompute::getClassNamePtr(), &reflection_fu_compute },
			{ Context::getClassNamePtr(), &reflection_context },
			{ D3D12Context::getClassNamePtr(), &reflection_d3d12_context },
			{ D3D11Context::getClassNamePtr(), &reflection_d3d11_context },
			{ MTLContext::getClassNamePtr(), &reflection_mtl_context },
			{ VKContext::getClassNamePtr(), &reflection_vk_context },
			{ GLContext::getClassNamePtr(), &reflection_gl_context },
			{ GLESContext::getClassNamePtr(), &reflection_gles_context },
			{ WGContext::getClassNamePtr(), &reflection_wg_context },
			{ CUContext::getClassNamePtr(), &reflection_cu_context },
			{ HIPContext::getClassNamePtr(), &reflection_hip_context },
			{ Query::getClassNamePtr(), &reflection_query },
			{ FUQuery::getClassNamePtr(), &reflection_fu_query },
			{ Fence::getClassNamePtr(), &reflection_fence },
			{ VKFence::getClassNamePtr(), &reflection_vk_fence },
			{ FUFence::getClassNamePtr(), &reflection_fu_fence },
			{ Shader::getClassNamePtr(), &reflection_shader },
			{ ShaderCompiler::getClassNamePtr(), &reflection_shader_compiler },
			{ D3D12Shader::getClassNamePtr(), &reflection_d3d12_shader },
			{ D3D11Shader::getClassNamePtr(), &reflection_d3d11_shader },
			{ MTLShader::getClassNamePtr(), &reflection_mtl_shader },
			{ VKShader::getClassNamePtr(), &reflection_vk_shader },
			{ GLShader::getClassNamePtr(), &reflection_gl_shader },
			{ GLESShader::getClassNamePtr(), &reflection_gles_shader },
			{ CUShader::getClassNamePtr(), &reflection_cu_shader },
			{ HIPShader::getClassNamePtr(), &reflection_hip_shader },
			{ FUShader::getClassNamePtr(), &reflection_fu_shader },
			{ Sampler::getClassNamePtr(), &reflection_sampler },
			{ MTLSampler::getClassNamePtr(), &reflection_mtl_sampler },
			{ FUSampler::getClassNamePtr(), &reflection_fu_sampler },
			{ Texture::getClassNamePtr(), &reflection_texture },
			{ TextureTable::getClassNamePtr(), &reflection_texture_table },
			{ D3D12Texture::getClassNamePtr(), &reflection_d3d12_texture },
			{ D3D11Texture::getClassNamePtr(), &reflection_d3d11_texture },
			{ MTLTexture::getClassNamePtr(), &reflection_mtl_texture },
			{ VKTexture::getClassNamePtr(), &reflection_vk_texture },
			{ GLTexture::getClassNamePtr(), &reflection_gl_texture },
			{ GLESTexture::getClassNamePtr(), &reflection_gles_texture },
			{ CUTexture::getClassNamePtr(), &reflection_cu_texture },
			{ HIPTexture::getClassNamePtr(), &reflection_hip_texture },
			{ FUTexture::getClassNamePtr(), &reflection_fu_texture },
			{ Tracing::getClassNamePtr(), &reflection_tracing },
			{ D3D12Tracing::getClassNamePtr(), &reflection_d3d12_tracing },
			{ MTLTracing::getClassNamePtr(), &reflection_mtl_tracing },
			{ VKTracing::getClassNamePtr(), &reflection_vk_tracing },
			{ FUTracing::getClassNamePtr(), &reflection_fu_tracing },
			{ Target::getClassNamePtr(), &reflection_target },
			{ D3D12Target::getClassNamePtr(), &reflection_d3d12_target },
			{ D3D11Target::getClassNamePtr(), &reflection_d3d11_target },
			{ MTLTarget::getClassNamePtr(), &reflection_mtl_target },
			{ VKTarget::getClassNamePtr(), &reflection_vk_target },
			{ GLTarget::getClassNamePtr(), &reflection_gl_target },
			{ GLESTarget::getClassNamePtr(), &reflection_gles_target },
			{ FUTarget::getClassNamePtr(), &reflection_fu_target },
			{ Device::getClassNamePtr(), &reflection_device },
			{ D3D12Device::getClassNamePtr(), &reflection_d3d12_device },
			{ D3D11Device::getClassNamePtr(), &reflection_d3d11_device },
			{ MTLDevice::getClassNamePtr(), &reflection_mtl_device },
			{ VKDevice::getClassNamePtr(), &reflection_vk_device },
			{ FUDevice::getClassNamePtr(), &reflection_fu_device },
			{ Kernel::getClassNamePtr(), &reflection_kernel },
			{ D3D12Kernel::getClassNamePtr(), &reflection_d3d12_kernel },
			{ MTLKernel::getClassNamePtr(), &reflection_mtl_kernel },
			{ FUKernel::getClassNamePtr(), &reflection_fu_kernel },
			{ Pipeline::getClassNamePtr(), &reflection_pipeline },
			{ D3D12Pipeline::getClassNamePtr(), &reflection_d3d12_pipeline },
			{ MTLPipeline::getClassNamePtr(), &reflection_mtl_pipeline },
			{ FUPipeline::getClassNamePtr(), &reflection_fu_pipeline },
			{ Traversal::getClassNamePtr(), &reflection_traversal },
			{ D3D12Traversal::getClassNamePtr(), &reflection_d3d12_traversal },
			{ FUTraversal::getClassNamePtr(), &reflection_fu_traversal },
			{ Surface::getClassNamePtr(), &reflection_surface },
			{ D3D12Surface::getClassNamePtr(), &reflection_d3d12_surface },
			{ D3D11Surface::getClassNamePtr(), &reflection_d3d11_surface },
			{ MTLSurface::getClassNamePtr(), &reflection_mtl_surface },
			{ VKSurface::getClassNamePtr(), &reflection_vk_surface },
			{ GLSurface::getClassNamePtr(), &reflection_gl_surface },
			{ GLESSurface::getClassNamePtr(), &reflection_gles_surface },
			{ Window::getClassNamePtr(), &reflection_window },
			{ Font::getClassNamePtr(), &reflection_font },
			{ CanvasElement::getClassNamePtr(), &reflection_canvas_element },
			{ CanvasText::getClassNamePtr(), &reflection_canvas_text },
			{ CanvasMesh::getClassNamePtr(), &reflection_canvas_mesh },
			{ CanvasRect::getClassNamePtr(), &reflection_canvas_rect },
			{ CanvasTriangle::getClassNamePtr(), &reflection_canvas_triangle },
			{ CanvasEllipse::getClassNamePtr(), &reflection_canvas_ellipse },
			{ CanvasShape::getClassNamePtr(), &reflection_canvas_shape },
			{ CanvasStrip::getClassNamePtr(), &reflection_canvas_strip },
			{ Canvas::getClassNamePtr(), &reflection_canvas },
			{ Control::getClassNamePtr(), &reflection_control },
			{ ControlRoot::getClassNamePtr(), &reflection_control_root },
			{ ControlText::getClassNamePtr(), &reflection_control_text },
			{ ControlRect::getClassNamePtr(), &reflection_control_rect },
			{ ControlGrid::getClassNamePtr(), &reflection_control_grid },
			{ ControlGroup::getClassNamePtr(), &reflection_control_group },
			{ ControlPanel::getClassNamePtr(), &reflection_control_panel },
			{ ControlDialog::getClassNamePtr(), &reflection_control_dialog },
			{ ControlWindow::getClassNamePtr(), &reflection_control_window },
			{ ControlCheck::getClassNamePtr(), &reflection_control_check },
			{ ControlCombo::getClassNamePtr(), &reflection_control_combo },
			{ ControlButton::getClassNamePtr(), &reflection_control_button },
			{ ControlSlider::getClassNamePtr(), &reflection_control_slider },
			{ ControlScroll::getClassNamePtr(), &reflection_control_scroll },
			{ ControlSplit::getClassNamePtr(), &reflection_control_split },
			{ ControlArea::getClassNamePtr(), &reflection_control_area },
			{ ControlTree::getClassNamePtr(), &reflection_control_tree },
			{ ControlEdit::getClassNamePtr(), &reflection_control_edit },
			{ DialogMessage::getClassNamePtr(), &reflection_dialog_message },
			{ DialogFileOpen::getClassNamePtr(), &reflection_dialog_file_open },
			{ DialogFileSave::getClassNamePtr(), &reflection_dialog_file_save },
			{ DialogDirectory::getClassNamePtr(), &reflection_dialog_directory },
			{ DialogProgress::getClassNamePtr(), &reflection_dialog_progress },
			{ DialogColor::getClassNamePtr(), &reflection_dialog_color },
			{ DialogMenu::getClassNamePtr(), &reflection_dialog_menu },
			{ CubeFilter::getClassNamePtr(), &reflection_cube_filter },
			{ DecoderJPEG::getClassNamePtr(), &reflection_decoder_jpeg },
			{ EncoderBC15::getClassNamePtr(), &reflection_encoder_bc15 },
			{ EncoderBC67::getClassNamePtr(), &reflection_encoder_bc67 },
			{ EncoderASTC::getClassNamePtr(), &reflection_encoder_astc },
			{ MeshModel::getClassNamePtr(), &reflection_mesh_model },
			{ SeparableFilter::getClassNamePtr(), &reflection_separable_filter },
			{ PrefixScan::getClassNamePtr(), &reflection_prefix_scan },
			{ RadixSort::getClassNamePtr(), &reflection_radix_sort },
			{ BitonicSort::getClassNamePtr(), &reflection_bitonic_sort },
			{ SpatialGrid::getClassNamePtr(), &reflection_spatial_grid },
			{ SpatialTree::getClassNamePtr(), &reflection_spatial_tree },
			{ FourierTransform::getClassNamePtr(), &reflection_fourier_transform },
			{ TensorGraph::getClassNamePtr(), &reflection_tensor_graph },
			{ Controller::getClassNamePtr(), &reflection_controller },
			{ Desktop::getClassNamePtr(), &reflection_desktop },
		};
	}
	const Reflection *Reflection::get(const char *name) {
		AtomicLock atomic(reflection_lock);
		create_reflection_instances();
		auto it = reflection_instances.find(name);
		if(!it) it = reflection_instances.find(String(name));
		if(it) return it->data;
		TS_LOGF(Error, "Reflection::get(): can't find \"%s\"\n", name);
		return nullptr;
	}
	const Map<const char*, Reflection*> &Reflection::get() {
		AtomicLock atomic(reflection_lock);
		create_reflection_instances();
		return reflection_instances;
	}
}
